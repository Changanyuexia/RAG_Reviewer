{"function": "public void testMissingPrimaryKeyLookupQuery() throws Exception { indexType2TweeterDocuments(); final Table table = dataContext.getDefaultSchema().getTableByName(DEFAULT_TABLE_NAME); final Column[] pks = table.getPrimaryKeys().toArray(new Column[0]); try (DataSet ds = dataContext.query().from(table).selectAll().where(pks[0]).eq(\"missing\").execute()) { assertFalse(ds.next()); } }", "text": "Please use a better name (primaryKeys, primaryKeyColumns).", "function_tokens": ["public", "\u0120void", "\u0120test", "Missing", "Primary", "Key", "Look", "up", "Query", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120index", "Type", "2", "Twe", "eter", "Documents", "();", "\u0120final", "\u0120Table", "\u0120table", "\u0120=", "\u0120data", "Context", ".", "get", "Default", "Sche", "ma", "().", "get", "Table", "By", "Name", "(", "DE", "FAULT", "_", "TABLE", "_", "NAME", ");", "\u0120final", "\u0120Column", "[]", "\u0120p", "ks", "\u0120=", "\u0120table", ".", "get", "Primary", "Keys", "().", "to", "Array", "(", "new", "\u0120Column", "[", "0", "]);", "\u0120try", "\u0120(", "Data", "Set", "\u0120d", "s", "\u0120=", "\u0120data", "Context", ".", "query", "().", "from", "(", "table", ").", "select", "All", "().", "where", "(", "p", "ks", "[", "0", "]).", "eq", "(\"", "missing", "\").", "execute", "())", "\u0120{", "\u0120assert", "False", "(", "ds", ".", "next", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120use", "\u0120a", "\u0120better", "\u0120name", "\u0120(", "primary", "Keys", ",", "\u0120primary", "Key", "Column", "s", ")."]}
{"function": "public void loadJavaRDD() throws Exception { doReturn(javaPairRDD).when(sparkContext).newAPIHadoopFile(any(), any(), any(), any(), any()); doReturn(javaRDD).when(javaPairRDD).map(any()); JavaRDD<Country> retJavaRDD = SparkAvroLoader.loadJavaRDD(sparkContext, \"/avro/datastore\", Country.class); assertTrue(javaRDD == retJavaRDD); verify(sparkContext).newAPIHadoopFile( eq(\"/avro/datastore\"), eq(AvroKeyInputFormat.class), eq(Country.class), eq(NullWritable.class), configurationCaptor.capture()); assertEquals(Country.SCHEMA$.toString(), configurationCaptor.getValue().get(\"avro.schema.input.key\")); verify(javaPairRDD).map(mapFunctionCaptor.capture()); assertMapFunction(mapFunctionCaptor.getValue()); verifyNoMoreInteractions(sparkContext, javaPairRDD); verifyZeroInteractions(javaRDD); }", "text": "Wouln't it be better to use the expected type instead of any()?", "function_tokens": ["public", "\u0120void", "\u0120load", "Java", "R", "DD", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120do", "Return", "(", "java", "P", "air", "R", "DD", ").", "when", "(", "sp", "ark", "Context", ").", "new", "API", "H", "ado", "op", "File", "(", "any", "(),", "\u0120any", "(),", "\u0120any", "(),", "\u0120any", "(),", "\u0120any", "());", "\u0120do", "Return", "(", "java", "R", "DD", ").", "when", "(", "java", "P", "air", "R", "DD", ").", "map", "(", "any", "());", "\u0120Java", "R", "DD", "<", "Country", ">", "\u0120ret", "Java", "R", "DD", "\u0120=", "\u0120Spark", "Av", "ro", "Loader", ".", "load", "Java", "R", "DD", "(", "sp", "ark", "Context", ",", "\u0120\"/", "av", "ro", "/", "dat", "ast", "ore", "\",", "\u0120Country", ".", "class", ");", "\u0120assert", "True", "(", "java", "R", "DD", "\u0120==", "\u0120ret", "Java", "R", "DD", ");", "\u0120verify", "(", "sp", "ark", "Context", ").", "new", "API", "H", "ado", "op", "File", "(", "\u0120eq", "(\"", "/", "av", "ro", "/", "dat", "ast", "ore", "\"),", "\u0120eq", "(", "Av", "ro", "Key", "Input", "Format", ".", "class", "),", "\u0120eq", "(", "Country", ".", "class", "),", "\u0120eq", "(", "Null", "Writ", "able", ".", "class", "),", "\u0120configuration", "Capt", "or", ".", "capt", "ure", "());", "\u0120assert", "Equ", "als", "(", "Country", ".", "S", "CH", "EMA", "$.", "to", "String", "(),", "\u0120configuration", "Capt", "or", ".", "get", "Value", "().", "get", "(\"", "av", "ro", ".", "sche", "ma", ".", "input", ".", "key", "\")", ");", "\u0120verify", "(", "java", "P", "air", "R", "DD", ").", "map", "(", "map", "Function", "Capt", "or", ".", "capt", "ure", "());", "\u0120assert", "Map", "Function", "(", "map", "Function", "Capt", "or", ".", "get", "Value", "());", "\u0120verify", "No", "More", "Inter", "actions", "(", "sp", "ark", "Context", ",", "\u0120java", "P", "air", "R", "DD", ");", "\u0120verify", "Zero", "Inter", "actions", "(", "java", "R", "DD", ");", "\u0120}"], "docstring_tokens": ["W", "oul", "n", "'t", "\u0120it", "\u0120be", "\u0120better", "\u0120to", "\u0120use", "\u0120the", "\u0120expected", "\u0120type", "\u0120instead", "\u0120of", "\u0120any", "()", "?"]}
{"function": "protected AuditMessageType getParticipantObjectIdentificationForRequest(PRPAIN201306UV02 request, AssertionType assertion, AuditMessageType auditMsg) { auditMsg = getPatientParticipantObjectIdentificationForResponse(request, auditMsg); try { auditMsg = getQueryParamsParticipantObjectIdentificationForResponse(request, auditMsg); } catch (JAXBException ex) { if (LOG.isDebugEnabled()) { LOG.error(\"Error while creating ParticipantObjectIdentificationQueryByParameters segment : \" + ex.getLocalizedMessage(), ex); } } return auditMsg; }", "text": "Remove this \"if\" statement. That said, here are a few things for future reference: 1. You use \"is[Level]Enabled\" to check that specific level (e.g., if you're going to log trace, you'd check \"isTraceEnabled()\", not \"isDebugEnabled\"). 2. There is no \"isErrorEnabled\" -- unless you disable logging altogether, it's always enabled. I suppose you could use \"isEnabledFor(Level.ERROR)\", but you'd only be checking if logging is on at all. 3. As a rule of thumb, unless the logging operation is extremely heavy (e.g., transforming a large object for the trace logs), you don't want to check if \"Info\" level or lower are enabled, only higher (debug, trace).", "function_tokens": ["protected", "\u0120Audit", "Message", "Type", "\u0120get", "Particip", "ant", "Object", "Ident", "ification", "For", "Request", "(", "PR", "PA", "IN", "201", "306", "UV", "02", "\u0120request", ",", "\u0120Ass", "ert", "ion", "Type", "\u0120assertion", ",", "\u0120Audit", "Message", "Type", "\u0120audit", "Msg", ")", "\u0120{", "\u0120audit", "Msg", "\u0120=", "\u0120get", "Pat", "ient", "Particip", "ant", "Object", "Ident", "ification", "For", "Response", "(", "request", ",", "\u0120audit", "Msg", ");", "\u0120try", "\u0120{", "\u0120audit", "Msg", "\u0120=", "\u0120get", "Query", "Par", "ams", "Particip", "ant", "Object", "Ident", "ification", "For", "Response", "(", "request", ",", "\u0120audit", "Msg", ");", "\u0120}", "\u0120catch", "\u0120(", "J", "AX", "B", "Exception", "\u0120ex", ")", "\u0120{", "\u0120if", "\u0120(", "LOG", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Error", "\u0120while", "\u0120creating", "\u0120Participant", "Object", "Ident", "ification", "Query", "By", "Parameters", "\u0120segment", "\u0120:", "\u0120\"", "\u0120+", "\u0120ex", ".", "get", "Local", "ized", "Message", "(),", "\u0120ex", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120audit", "Msg", ";", "\u0120}"], "docstring_tokens": ["Remove", "\u0120this", "\u0120\"", "if", "\"", "\u0120statement", ".", "\u0120That", "\u0120said", ",", "\u0120here", "\u0120are", "\u0120a", "\u0120few", "\u0120things", "\u0120for", "\u0120future", "\u0120reference", ":", "\u01201", ".", "\u0120You", "\u0120use", "\u0120\"", "is", "[", "Level", "]", "Enabled", "\"", "\u0120to", "\u0120check", "\u0120that", "\u0120specific", "\u0120level", "\u0120(", "e", ".", "g", ".,", "\u0120if", "\u0120you", "'re", "\u0120going", "\u0120to", "\u0120log", "\u0120trace", ",", "\u0120you", "'d", "\u0120check", "\u0120\"", "is", "Tr", "ace", "Enabled", "()", "\",", "\u0120not", "\u0120\"", "is", "Debug", "Enabled", "\").", "\u01202", ".", "\u0120There", "\u0120is", "\u0120no", "\u0120\"", "is", "Error", "Enabled", "\"", "\u0120--", "\u0120unless", "\u0120you", "\u0120disable", "\u0120logging", "\u0120altogether", ",", "\u0120it", "'s", "\u0120always", "\u0120enabled", ".", "\u0120I", "\u0120suppose", "\u0120you", "\u0120could", "\u0120use", "\u0120\"", "is", "Enabled", "For", "(", "Level", ".", "ERROR", ")\",", "\u0120but", "\u0120you", "'d", "\u0120only", "\u0120be", "\u0120checking", "\u0120if", "\u0120logging", "\u0120is", "\u0120on", "\u0120at", "\u0120all", ".", "\u01203", ".", "\u0120As", "\u0120a", "\u0120rule", "\u0120of", "\u0120thumb", ",", "\u0120unless", "\u0120the", "\u0120logging", "\u0120operation", "\u0120is", "\u0120extremely", "\u0120heavy", "\u0120(", "e", ".", "g", ".,", "\u0120transforming", "\u0120a", "\u0120large", "\u0120object", "\u0120for", "\u0120the", "\u0120trace", "\u0120logs", "),", "\u0120you", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120check", "\u0120if", "\u0120\"", "Info", "\"", "\u0120level", "\u0120or", "\u0120lower", "\u0120are", "\u0120enabled", ",", "\u0120only", "\u0120higher", "\u0120(", "debug", ",", "\u0120trace", ")."]}
{"function": "private synchronized void addNode(DiscoveryDruidNode druidNode) { DiscoveryDruidNode prev = nodes.put(druidNode.getDruidNode().getHostAndPortToUse(), druidNode); if (prev == null) { for (DruidNodeDiscovery.Listener l : nodeListeners) { listenerExecutor.submit(() -> { try { l.nodeAdded(druidNode); } catch (Exception ex) { log.error(ex, \"Exception occured in DiscoveryDruidNode.nodeAdded(node=[%s]) in listener [%s].\", druidNode, l); } }); } } else { log.warn(\"Node[%s] discovered but existed already [%s].\", druidNode, prev); } }", "text": "is it possible that getDruidNode() or getHostAndPortToUse() are null?", "function_tokens": ["private", "\u0120synchronized", "\u0120void", "\u0120add", "Node", "(", "D", "iscovery", "D", "ru", "id", "Node", "\u0120dru", "id", "Node", ")", "\u0120{", "\u0120Discovery", "D", "ru", "id", "Node", "\u0120prev", "\u0120=", "\u0120nodes", ".", "put", "(", "d", "ru", "id", "Node", ".", "get", "D", "ru", "id", "Node", "().", "get", "Host", "And", "Port", "To", "Use", "(),", "\u0120dru", "id", "Node", ");", "\u0120if", "\u0120(", "prev", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "D", "ru", "id", "Node", "D", "iscovery", ".", "Listener", "\u0120l", "\u0120:", "\u0120node", "Listen", "ers", ")", "\u0120{", "\u0120listener", "Exec", "utor", ".", "submit", "(", "()", "\u0120->", "\u0120{", "\u0120try", "\u0120{", "\u0120l", ".", "node", "Added", "(", "d", "ru", "id", "Node", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120ex", ")", "\u0120{", "\u0120log", ".", "error", "(", "ex", ",", "\u0120\"", "Exception", "\u0120occ", "ured", "\u0120in", "\u0120Discovery", "D", "ru", "id", "Node", ".", "node", "Added", "(", "node", "=[", "%", "s", "])", "\u0120in", "\u0120listener", "\u0120[", "%", "s", "].\"", ",", "\u0120dru", "id", "Node", ",", "\u0120l", ");", "\u0120}", "\u0120});", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "warn", "(\"", "Node", "[", "%", "s", "]", "\u0120discovered", "\u0120but", "\u0120existed", "\u0120already", "\u0120[", "%", "s", "].\"", ",", "\u0120dru", "id", "Node", ",", "\u0120prev", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["is", "\u0120it", "\u0120possible", "\u0120that", "\u0120get", "D", "ru", "id", "Node", "()", "\u0120or", "\u0120get", "Host", "And", "Port", "To", "Use", "()", "\u0120are", "\u0120null", "?"]}
{"function": "public Step variantsLoadStep() throws Exception { return stepBuilderFactory.get(LOAD_VARIANTS).<Variant, Variant>chunk(10) .reader(reader) .writer(variantMongoWriter) .faultTolerant().skipLimit(50).skip(FlatFileParseException.class) .listener(new SkippedItemListener()) .build(); }", "text": "We talked about setting a chunk size. Shall we make it 1000 and set it in JobOptions? I'm not very happy about that location but other things like includeSrc, compressGenotypes, etc, are placed there too.", "function_tokens": ["public", "\u0120Step", "\u0120variants", "Load", "Step", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120return", "\u0120step", "Builder", "Factory", ".", "get", "(", "LOAD", "_", "V", "AR", "IAN", "TS", ").", "<", "Vari", "ant", ",", "\u0120Variant", ">", "ch", "unk", "(", "10", ")", "\u0120.", "reader", "(", "reader", ")", "\u0120.", "writer", "(", "vari", "ant", "M", "ongo", "Writer", ")", "\u0120.", "f", "ault", "T", "oler", "ant", "().", "skip", "Limit", "(", "50", ").", "skip", "(", "Fl", "at", "File", "Par", "se", "Exception", ".", "class", ")", "\u0120.", "list", "ener", "(", "new", "\u0120Sk", "ipped", "Item", "Listener", "())", "\u0120.", "build", "();", "\u0120}"], "docstring_tokens": ["We", "\u0120talked", "\u0120about", "\u0120setting", "\u0120a", "\u0120chunk", "\u0120size", ".", "\u0120Shall", "\u0120we", "\u0120make", "\u0120it", "\u01201000", "\u0120and", "\u0120set", "\u0120it", "\u0120in", "\u0120Job", "Options", "?", "\u0120I", "'m", "\u0120not", "\u0120very", "\u0120happy", "\u0120about", "\u0120that", "\u0120location", "\u0120but", "\u0120other", "\u0120things", "\u0120like", "\u0120include", "S", "rc", ",", "\u0120compress", "Gen", "otypes", ",", "\u0120etc", ",", "\u0120are", "\u0120placed", "\u0120there", "\u0120too", "."]}
{"function": "public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + zScore.hashCode(); return result; }", "text": "Please implement equals() method either. This will remove the potential problem when working with collections.", "function_tokens": ["public", "\u0120int", "\u0120hash", "Code", "()", "\u0120{", "\u0120int", "\u0120result", "\u0120=", "\u0120name", "\u0120!=", "\u0120null", "\u0120?", "\u0120name", ".", "hash", "Code", "()", "\u0120:", "\u01200", ";", "\u0120result", "\u0120=", "\u012031", "\u0120*", "\u0120result", "\u0120+", "\u0120z", "Score", ".", "hash", "Code", "();", "\u0120return", "\u0120result", ";", "\u0120}"], "docstring_tokens": ["Please", "\u0120implement", "\u0120equals", "()", "\u0120method", "\u0120either", ".", "\u0120This", "\u0120will", "\u0120remove", "\u0120the", "\u0120potential", "\u0120problem", "\u0120when", "\u0120working", "\u0120with", "\u0120collections", "."]}
{"function": "public Object execute(final ExecutionEvent event) throws ExecutionException { final TaskData data = getTaskData(event); if (data == null) return null; Job job = new Job(MessageFormat.format( Messages.RebasePullRequestHandler_RebaseJob, data.getTaskId())) { @Override protected IStatus run(IProgressMonitor monitor) { PullRequestComposite prComp = PullRequestConnector .getPullRequest(data); if (prComp == null) return Status.CANCEL_STATUS; PullRequest request = prComp.getRequest(); Repository repo = PullRequestUtils.getRepository(request); if (repo == null) return Status.CANCEL_STATUS; String branchName = PullRequestUtils.getBranchName(request); try { String target = request.getBase().getRef(); Ref targetRef = repo.findRef(request.getBase().getRef()); if (targetRef != null) { SubMonitor progress = SubMonitor.convert(monitor, 2); if (!PullRequestUtils.isCurrentBranch(branchName, repo)) { monitor.setTaskName(MessageFormat .format(Messages.RebasePullRequestHandler_TaskCheckout, branchName)); BranchOperationUI.checkout(repo, branchName).run( progress.split(1)); } else { progress.setWorkRemaining(1); } monitor.setTaskName(MessageFormat.format( Messages.RebasePullRequestHandler_TaskRebase, branchName, target)); new RebaseOperation(repo, targetRef) .execute(progress.split(1)); executeCallback(event); } } catch (IOException e) { GitHubUi.logError(e); } catch (CoreException e) { GitHubUi.logError(e); } return Status.OK_STATUS; } }; schedule(job, event); return null; }", "text": "one more progress monitor change", "function_tokens": ["public", "\u0120Object", "\u0120execute", "(", "final", "\u0120Execution", "Event", "\u0120event", ")", "\u0120throws", "\u0120Execution", "Exception", "\u0120{", "\u0120final", "\u0120Task", "Data", "\u0120data", "\u0120=", "\u0120get", "Task", "Data", "(", "event", ");", "\u0120if", "\u0120(", "data", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120null", ";", "\u0120Job", "\u0120job", "\u0120=", "\u0120new", "\u0120Job", "(", "Message", "Format", ".", "format", "(", "\u0120Messages", ".", "Reb", "ase", "Pull", "Request", "Handler", "_", "Reb", "ase", "Job", ",", "\u0120data", ".", "get", "Task", "Id", "()", "))", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120I", "Status", "\u0120run", "(", "I", "Progress", "Monitor", "\u0120monitor", ")", "\u0120{", "\u0120Pull", "Request", "Com", "pos", "ite", "\u0120pr", "Comp", "\u0120=", "\u0120Pull", "Request", "Connector", "\u0120.", "get", "Pull", "Request", "(", "data", ");", "\u0120if", "\u0120(", "pr", "Comp", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120Status", ".", "C", "ANC", "EL", "_", "STAT", "US", ";", "\u0120Pull", "Request", "\u0120request", "\u0120=", "\u0120pr", "Comp", ".", "get", "Request", "();", "\u0120Rep", "ository", "\u0120repo", "\u0120=", "\u0120Pull", "Request", "Ut", "ils", ".", "get", "Rep", "ository", "(", "request", ");", "\u0120if", "\u0120(", "re", "po", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120Status", ".", "C", "ANC", "EL", "_", "STAT", "US", ";", "\u0120String", "\u0120branch", "Name", "\u0120=", "\u0120Pull", "Request", "Ut", "ils", ".", "get", "B", "ranch", "Name", "(", "request", ");", "\u0120try", "\u0120{", "\u0120String", "\u0120target", "\u0120=", "\u0120request", ".", "get", "Base", "().", "get", "Ref", "();", "\u0120Ref", "\u0120target", "Ref", "\u0120=", "\u0120repo", ".", "find", "Ref", "(", "request", ".", "get", "Base", "().", "get", "Ref", "());", "\u0120if", "\u0120(", "target", "Ref", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Sub", "Monitor", "\u0120progress", "\u0120=", "\u0120Sub", "Monitor", ".", "con", "vert", "(", "monitor", ",", "\u01202", ");", "\u0120if", "\u0120(!", "Pull", "Request", "Ut", "ils", ".", "is", "Current", "B", "ranch", "(", "br", "anch", "Name", ",", "\u0120repo", "))", "\u0120{", "\u0120monitor", ".", "set", "Task", "Name", "(", "Message", "Format", "\u0120.", "format", "(", "Mess", "ages", ".", "Reb", "ase", "Pull", "Request", "Handler", "_", "Task", "Check", "out", ",", "\u0120branch", "Name", "));", "\u0120Branch", "Operation", "UI", ".", "check", "out", "(", "re", "po", ",", "\u0120branch", "Name", ").", "run", "(", "\u0120progress", ".", "split", "(", "1", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120progress", ".", "set", "Work", "Rem", "aining", "(", "1", ");", "\u0120}", "\u0120monitor", ".", "set", "Task", "Name", "(", "Message", "Format", ".", "format", "(", "\u0120Messages", ".", "Reb", "ase", "Pull", "Request", "Handler", "_", "Task", "Reb", "ase", ",", "\u0120branch", "Name", ",", "\u0120target", "));", "\u0120new", "\u0120Re", "base", "Operation", "(", "re", "po", ",", "\u0120target", "Ref", ")", "\u0120.", "execute", "(", "progress", ".", "split", "(", "1", "));", "\u0120execute", "Callback", "(", "event", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120GitHub", "U", "i", ".", "log", "Error", "(", "e", ");", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120GitHub", "U", "i", ".", "log", "Error", "(", "e", ");", "\u0120}", "\u0120return", "\u0120Status", ".", "OK", "_", "STAT", "US", ";", "\u0120}", "\u0120};", "\u0120schedule", "(", "job", ",", "\u0120event", ");", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["one", "\u0120more", "\u0120progress", "\u0120monitor", "\u0120change"]}
{"function": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { try { for (Element autoMountElement : roundEnv.getElementsAnnotatedWith(SecureAutoMount.class)) { final AutoMountContext context = getAutoMountContext(autoMountElement, SecureAutoMount.class); if (context == null) { continue; } for (Element elem : roundEnv.getElementsAnnotatedWith(AuthorizeInstantiation.class)) { final AuthorizeInstantiation mp = elem.getAnnotation(AuthorizeInstantiation.class); processMountPoint(context, elem, mp); } for (Element elem : roundEnv.getElementsAnnotatedWith(MountPath.class)) { final MountPath mp = elem.getAnnotation(MountPath.class); processMountPoint(context, elem, mp); } generateSource(context); } return true; } catch (IOException ex) { Logger.getLogger(SecureMountAnnotationProcessor.class.getName()).log(Level.SEVERE, null, ex); } return true; }", "text": "return false ?", "function_tokens": ["public", "\u0120boolean", "\u0120process", "(", "Set", "<?", "\u0120extends", "\u0120Type", "Element", ">", "\u0120annotations", ",", "\u0120Round", "Environment", "\u0120round", "En", "v", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120for", "\u0120(", "Element", "\u0120auto", "Mount", "Element", "\u0120:", "\u0120round", "En", "v", ".", "get", "E", "lements", "An", "not", "ated", "With", "(", "Secure", "Auto", "Mount", ".", "class", "))", "\u0120{", "\u0120final", "\u0120Auto", "Mount", "Context", "\u0120context", "\u0120=", "\u0120get", "Auto", "Mount", "Context", "(", "auto", "Mount", "Element", ",", "\u0120Secure", "Auto", "Mount", ".", "class", ");", "\u0120if", "\u0120(", "context", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120continue", ";", "\u0120}", "\u0120for", "\u0120(", "Element", "\u0120ele", "m", "\u0120:", "\u0120round", "En", "v", ".", "get", "E", "lements", "An", "not", "ated", "With", "(", "Author", "ize", "Instant", "iation", ".", "class", "))", "\u0120{", "\u0120final", "\u0120Author", "ize", "Instant", "iation", "\u0120mp", "\u0120=", "\u0120ele", "m", ".", "get", "An", "notation", "(", "Author", "ize", "Instant", "iation", ".", "class", ");", "\u0120process", "Mount", "Point", "(", "context", ",", "\u0120ele", "m", ",", "\u0120mp", ");", "\u0120}", "\u0120for", "\u0120(", "Element", "\u0120ele", "m", "\u0120:", "\u0120round", "En", "v", ".", "get", "E", "lements", "An", "not", "ated", "With", "(", "Mount", "Path", ".", "class", "))", "\u0120{", "\u0120final", "\u0120Mount", "Path", "\u0120mp", "\u0120=", "\u0120ele", "m", ".", "get", "An", "notation", "(", "Mount", "Path", ".", "class", ");", "\u0120process", "Mount", "Point", "(", "context", ",", "\u0120ele", "m", ",", "\u0120mp", ");", "\u0120}", "\u0120generate", "Source", "(", "context", ");", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120ex", ")", "\u0120{", "\u0120Log", "ger", ".", "get", "Log", "ger", "(", "Secure", "Mount", "An", "notation", "Process", "or", ".", "class", ".", "get", "Name", "()", ").", "log", "(", "Level", ".", "SE", "VER", "E", ",", "\u0120null", ",", "\u0120ex", ");", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["return", "\u0120false", "\u0120?"]}
{"function": "public void testFrameworkProducerDelete() throws Exception { setupFrameworkProducer(false); Exchange mockExchangeCreate = mock(Exchange.class); Exchange mockExchangeDelete = mock(Exchange.class); Message message = mock(Message.class); Metacard metacard = mock(MetacardImpl.class); when(metacard.getId()).thenReturn(\"metacard1\"); when(mockExchangeCreate.getIn()).thenReturn(message); when(mockExchangeCreate.getOut()).thenReturn(message); when(mockExchangeCreate.getIn().getHeader(OPERATION_HEADER_KEY)).thenReturn(CREATE_OPERATION); when(mockExchangeCreate.getIn().getHeader(TIMEOUT_HEADER_KEY)).thenReturn(1000L); when(mockExchangeCreate.getIn().getBody()).thenReturn(metacard); when(mockExchangeCreate.getIn().getBody(any())).thenReturn(metacard); frameworkProducer.process(mockExchangeCreate); when(mockExchangeDelete.getIn()).thenReturn(message); when(mockExchangeDelete.getOut()).thenReturn(message); when(mockExchangeDelete.getIn().getHeader(OPERATION_HEADER_KEY)).thenReturn(DELETE_OPERATION); when(mockExchangeDelete.getIn().getHeader(TIMEOUT_HEADER_KEY)).thenReturn(1000L); }", "text": "This test needs a verification.", "function_tokens": ["public", "\u0120void", "\u0120test", "Fram", "ework", "Produ", "cer", "Delete", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120setup", "Fram", "ework", "Produ", "cer", "(", "false", ");", "\u0120Exchange", "\u0120mock", "Ex", "change", "Create", "\u0120=", "\u0120mock", "(", "Ex", "change", ".", "class", ");", "\u0120Exchange", "\u0120mock", "Ex", "change", "Delete", "\u0120=", "\u0120mock", "(", "Ex", "change", ".", "class", ");", "\u0120Message", "\u0120message", "\u0120=", "\u0120mock", "(", "Message", ".", "class", ");", "\u0120Met", "ac", "ard", "\u0120met", "ac", "ard", "\u0120=", "\u0120mock", "(", "Met", "ac", "ard", "Impl", ".", "class", ");", "\u0120when", "(", "met", "ac", "ard", ".", "get", "Id", "()", ").", "then", "Return", "(\"", "met", "ac", "ard", "1", "\");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "In", "()", ").", "then", "Return", "(", "message", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "Out", "()", ").", "then", "Return", "(", "message", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "In", "().", "get", "Header", "(", "OPER", "ATION", "_", "HEAD", "ER", "_", "KEY", ")).", "then", "Return", "(", "CRE", "ATE", "_", "OPER", "ATION", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "In", "().", "get", "Header", "(", "TIME", "OUT", "_", "HEAD", "ER", "_", "KEY", ")).", "then", "Return", "(", "1000", "L", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "In", "().", "get", "Body", "()", ").", "then", "Return", "(", "met", "ac", "ard", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Create", ".", "get", "In", "().", "get", "Body", "(", "any", "())", ").", "then", "Return", "(", "met", "ac", "ard", ");", "\u0120framework", "Produ", "cer", ".", "process", "(", "m", "ock", "Ex", "change", "Create", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Delete", ".", "get", "In", "()", ").", "then", "Return", "(", "message", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Delete", ".", "get", "Out", "()", ").", "then", "Return", "(", "message", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Delete", ".", "get", "In", "().", "get", "Header", "(", "OPER", "ATION", "_", "HEAD", "ER", "_", "KEY", ")).", "then", "Return", "(", "DE", "LE", "TE", "_", "OPER", "ATION", ");", "\u0120when", "(", "m", "ock", "Ex", "change", "Delete", ".", "get", "In", "().", "get", "Header", "(", "TIME", "OUT", "_", "HEAD", "ER", "_", "KEY", ")).", "then", "Return", "(", "1000", "L", ");", "\u0120}"], "docstring_tokens": ["This", "\u0120test", "\u0120needs", "\u0120a", "\u0120verification", "."]}
{"function": "protected void onCreate(Bundle savedInstanceState) { Log.d(TAG, \"onCreate\"); requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); requestWindowFeature(Window.FEATURE_ACTIVITY_TRANSITIONS); super.onCreate(savedInstanceState); PreferencesState.getInstance().onCreateActivityPreferences(getResources(), getTheme()); if (EyeSeeTeaApplication.permissions == null) { EyeSeeTeaApplication.permissions = Permissions.getInstance(this); } if (!EyeSeeTeaApplication.permissions.areAllPermissionsGranted()) { EyeSeeTeaApplication.permissions.requestNextPermission(); } initView(savedInstanceState); PreferencesState.getInstance().setPushInProgress(false); List<SurveyDB> surveyDBs = SurveyDB.getAllSendingSurveys(); Log.d(TAG, \"Surveys sending: \" + surveyDBs.size()); for (SurveyDB surveyDB : surveyDBs) { surveyDB.setStatus(Constants.SURVEY_QUARANTINE); surveyDB.save(); } AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); try { Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); } catch (InterruptedException e) { e.printStackTrace(); } mBaseActivityStrategy.onCreate(); }", "text": "this code is very strange, can you explain to me because is necessary?", "function_tokens": ["protected", "\u0120void", "\u0120on", "Create", "(", "B", "undle", "\u0120saved", "Instance", "State", ")", "\u0120{", "\u0120Log", ".", "d", "(", "TAG", ",", "\u0120\"", "on", "Create", "\");", "\u0120request", "Window", "Feature", "(", "Window", ".", "FE", "ATURE", "_", "IND", "ET", "ER", "MIN", "ATE", "_", "PR", "OGR", "ESS", ");", "\u0120request", "Window", "Feature", "(", "Window", ".", "FE", "ATURE", "_", "ACT", "IV", "ITY", "_", "TR", "ANS", "IT", "IONS", ");", "\u0120super", ".", "on", "Create", "(", "s", "aved", "Instance", "State", ");", "\u0120Preferences", "State", ".", "get", "Instance", "().", "on", "Create", "Activity", "Pref", "erences", "(", "get", "Resources", "(),", "\u0120get", "Theme", "());", "\u0120if", "\u0120(", "Eye", "See", "Tea", "Application", ".", "per", "missions", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120Eye", "See", "Tea", "Application", ".", "per", "missions", "\u0120=", "\u0120Per", "missions", ".", "get", "Instance", "(", "this", ");", "\u0120}", "\u0120if", "\u0120(!", "Eye", "See", "Tea", "Application", ".", "per", "missions", ".", "are", "All", "Per", "missions", "Gr", "anted", "())", "\u0120{", "\u0120Eye", "See", "Tea", "Application", ".", "per", "missions", ".", "request", "Next", "Per", "mission", "();", "\u0120}", "\u0120init", "View", "(", "s", "aved", "Instance", "State", ");", "\u0120Preferences", "State", ".", "get", "Instance", "().", "set", "Push", "In", "Progress", "(", "false", ");", "\u0120List", "<", "Sur", "vey", "DB", ">", "\u0120survey", "DB", "s", "\u0120=", "\u0120Survey", "DB", ".", "get", "All", "S", "ending", "Sur", "ve", "ys", "();", "\u0120Log", ".", "d", "(", "TAG", ",", "\u0120\"", "Sur", "ve", "ys", "\u0120sending", ":", "\u0120\"", "\u0120+", "\u0120survey", "DB", "s", ".", "size", "());", "\u0120for", "\u0120(", "Sur", "vey", "DB", "\u0120survey", "DB", "\u0120:", "\u0120survey", "DB", "s", ")", "\u0120{", "\u0120survey", "DB", ".", "set", "Status", "(", "Const", "ants", ".", "S", "UR", "VE", "Y", "_", "QU", "AR", "ANT", "INE", ");", "\u0120survey", "DB", ".", "save", "();", "\u0120}", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "100", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Thread", ".", "sleep", "(", "100", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Thread", ".", "sleep", "(", "100", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120Al", "arm", "Push", "Re", "ceiver", ".", "set", "Push", "Al", "arm", "(", "this", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120m", "Base", "Activity", "Str", "ategy", ".", "on", "Create", "();", "\u0120}"], "docstring_tokens": ["this", "\u0120code", "\u0120is", "\u0120very", "\u0120strange", ",", "\u0120can", "\u0120you", "\u0120explain", "\u0120to", "\u0120me", "\u0120because", "\u0120is", "\u0120necessary", "?"]}
{"function": "public void testProcessNonJavaFilesWithoutException() throws Exception { final TreeWalker treeWalker = new TreeWalker(); treeWalker.setTabWidth(1); treeWalker.configure(new DefaultConfiguration(\"default config\")); final File file = new File(\"src/main/resources/checkstyle_packages.xml\"); final FileText fileText = new FileText(file, StandardCharsets.ISO_8859_1.name()); try { treeWalker.processFiltered(file, fileText); } catch (CheckstyleException ex) { fail(\"Exception not expected\"); } }", "text": "Like I mentioned to others, try-catch-fail is not a good option. JUnit automatically populates exception to user and fails the test. If exception occurs, user will now get a bland message and not the stack trace of the problem. There is nothing we can assert here?", "function_tokens": ["public", "\u0120void", "\u0120test", "Process", "Non", "Java", "Files", "Without", "Exception", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120Tree", "Walker", "\u0120tree", "Walker", "\u0120=", "\u0120new", "\u0120Tree", "Walker", "();", "\u0120tree", "Walker", ".", "set", "Tab", "Width", "(", "1", ");", "\u0120tree", "Walker", ".", "config", "ure", "(", "new", "\u0120Default", "Configuration", "(\"", "default", "\u0120config", "\")", ");", "\u0120final", "\u0120File", "\u0120file", "\u0120=", "\u0120new", "\u0120File", "(\"", "src", "/", "main", "/", "resources", "/", "check", "style", "_", "packages", ".", "xml", "\");", "\u0120final", "\u0120File", "Text", "\u0120file", "Text", "\u0120=", "\u0120new", "\u0120File", "Text", "(", "file", ",", "\u0120Standard", "Ch", "ars", "ets", ".", "ISO", "_", "88", "59", "_", "1", ".", "name", "());", "\u0120try", "\u0120{", "\u0120tree", "Walker", ".", "process", "Fil", "tered", "(", "file", ",", "\u0120file", "Text", ");", "\u0120}", "\u0120catch", "\u0120(", "Check", "style", "Exception", "\u0120ex", ")", "\u0120{", "\u0120fail", "(\"", "Exception", "\u0120not", "\u0120expected", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["Like", "\u0120I", "\u0120mentioned", "\u0120to", "\u0120others", ",", "\u0120try", "-", "catch", "-", "fail", "\u0120is", "\u0120not", "\u0120a", "\u0120good", "\u0120option", ".", "\u0120J", "Unit", "\u0120automatically", "\u0120pop", "ulates", "\u0120exception", "\u0120to", "\u0120user", "\u0120and", "\u0120fails", "\u0120the", "\u0120test", ".", "\u0120If", "\u0120exception", "\u0120occurs", ",", "\u0120user", "\u0120will", "\u0120now", "\u0120get", "\u0120a", "\u0120bland", "\u0120message", "\u0120and", "\u0120not", "\u0120the", "\u0120stack", "\u0120trace", "\u0120of", "\u0120the", "\u0120problem", ".", "\u0120There", "\u0120is", "\u0120nothing", "\u0120we", "\u0120can", "\u0120assert", "\u0120here", "?"]}
{"function": "protected void executeCommand() { final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance() .getProfile(getParameters().getProfileName()); sourceIp = getParameters().getSourceIp(); if (profile == null) { setSucceeded(false); } else { final boolean externalSsoEnabled = EngineLocalConfig.getInstance().getBoolean(\"ENGINE_SSO_ENABLE_EXTERNAL_SSO\"); final DbUser user = buildUser(externalSsoEnabled, getParameters(), profile.getAuthzName()); boolean isAdmin = !roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), \",\")).isEmpty(); user.setAdmin(isAdmin); setCurrentUser(user); setUserName(String.format(\"%s@%s\", getCurrentUser().getLoginName(), getCurrentUser().getDomain())); if (getParameters().isAdminRequired() && !isAdmin) { setSucceeded(false); } else if (permissionDao.getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), \",\"), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) { setSucceeded(false); } else { String engineSessionId = sessionDataContainer.generateEngineSessionId(); sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp()); sessionDataContainer.setUser(engineSessionId, user); sessionDataContainer.refresh(engineSessionId); sessionDataContainer.setProfile(engineSessionId, profile); sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName()); sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken()); sessionDataContainer.setSsoOvirtAppApiScope(engineSessionId, getParameters().getAppScope()); getReturnValue().setActionReturnValue(engineSessionId); setSucceeded(true); sessionId = engineSessionId; } } }", "text": "Maybe having such method would be nicer: buildUser(T params, String authzName) { boolean externalSsoEnabled = EngineLocalConfig.getInstance().getBoolean(\"ENGINE_SSO_ENABLE_EXTERNAL_SSO\"); buildUser(externalSsoEnabled , params, authzName) { }", "function_tokens": ["protected", "\u0120void", "\u0120execute", "Command", "()", "\u0120{", "\u0120final", "\u0120Authentication", "Profile", "\u0120profile", "\u0120=", "\u0120Authentication", "Profile", "Rep", "ository", ".", "get", "Instance", "()", "\u0120.", "get", "Profile", "(", "get", "Parameters", "().", "get", "Profile", "Name", "());", "\u0120source", "I", "p", "\u0120=", "\u0120get", "Parameters", "().", "get", "Source", "I", "p", "();", "\u0120if", "\u0120(", "profile", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120set", "S", "uc", "ceed", "ed", "(", "false", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120final", "\u0120boolean", "\u0120external", "S", "so", "Enabled", "\u0120=", "\u0120Engine", "Local", "Config", ".", "get", "Instance", "().", "get", "Boo", "lean", "(\"", "ENG", "INE", "_", "SS", "O", "_", "EN", "ABLE", "_", "EX", "TERN", "AL", "_", "SS", "O", "\");", "\u0120final", "\u0120D", "b", "User", "\u0120user", "\u0120=", "\u0120build", "User", "(", "external", "S", "so", "Enabled", ",", "\u0120get", "Parameters", "(),", "\u0120profile", ".", "get", "Auth", "z", "Name", "());", "\u0120boolean", "\u0120is", "Admin", "\u0120=", "\u0120!", "role", "D", "ao", ".", "get", "Any", "Admin", "Role", "For", "User", "And", "G", "roups", "(", "user", ".", "get", "Id", "(),", "\u0120String", "Ut", "ils", ".", "join", "(", "user", ".", "get", "Group", "Id", "s", "(),", "\u0120\"", ",\"", ")).", "is", "Empty", "();", "\u0120user", ".", "set", "Admin", "(", "is", "Admin", ");", "\u0120set", "Current", "User", "(", "user", ");", "\u0120set", "User", "Name", "(", "String", ".", "format", "(\"", "%", "s", "@", "%", "s", "\",", "\u0120get", "Current", "User", "().", "get", "Login", "Name", "(),", "\u0120get", "Current", "User", "().", "get", "Domain", "()", "));", "\u0120if", "\u0120(", "get", "Parameters", "().", "is", "Admin", "Required", "()", "\u0120&&", "\u0120!", "is", "Admin", ")", "\u0120{", "\u0120set", "S", "uc", "ceed", "ed", "(", "false", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "per", "mission", "D", "ao", ".", "get", "Entity", "Per", "missions", "For", "User", "And", "G", "roups", "(", "user", ".", "get", "Id", "(),", "\u0120String", "Ut", "ils", ".", "join", "(", "user", ".", "get", "Group", "Id", "s", "(),", "\u0120\"", ",\"", "),", "\u0120Action", "Group", ".", "LOG", "IN", ",", "\u0120B", "OTT", "OM", "_", "OB", "JECT", "_", "ID", ",", "\u0120V", "dc", "Object", "Type", ".", "Bottom", ",", "\u0120true", ")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120set", "S", "uc", "ceed", "ed", "(", "false", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120engine", "Session", "Id", "\u0120=", "\u0120session", "Data", "Container", ".", "gener", "ate", "Engine", "Session", "Id", "();", "\u0120session", "Data", "Container", ".", "set", "Source", "I", "p", "(", "engine", "Session", "Id", ",", "\u0120get", "Parameters", "().", "get", "Source", "I", "p", "());", "\u0120session", "Data", "Container", ".", "set", "User", "(", "engine", "Session", "Id", ",", "\u0120user", ");", "\u0120session", "Data", "Container", ".", "ref", "resh", "(", "engine", "Session", "Id", ");", "\u0120session", "Data", "Container", ".", "set", "Profile", "(", "engine", "Session", "Id", ",", "\u0120profile", ");", "\u0120session", "Data", "Container", ".", "set", "Princ", "ipal", "Name", "(", "engine", "Session", "Id", ",", "\u0120get", "Parameters", "().", "get", "Princ", "ipal", "Name", "());", "\u0120session", "Data", "Container", ".", "set", "S", "so", "Access", "Token", "(", "engine", "Session", "Id", ",", "\u0120get", "Parameters", "().", "get", "S", "so", "Token", "());", "\u0120session", "Data", "Container", ".", "set", "S", "so", "O", "virt", "App", "A", "pi", "Scope", "(", "engine", "Session", "Id", ",", "\u0120get", "Parameters", "().", "get", "App", "Scope", "());", "\u0120get", "Return", "Value", "().", "set", "Action", "Return", "Value", "(", "engine", "Session", "Id", ");", "\u0120set", "S", "uc", "ceed", "ed", "(", "true", ");", "\u0120session", "Id", "\u0120=", "\u0120engine", "Session", "Id", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Maybe", "\u0120having", "\u0120such", "\u0120method", "\u0120would", "\u0120be", "\u0120nicer", ":", "\u0120build", "User", "(", "T", "\u0120params", ",", "\u0120String", "\u0120auth", "z", "Name", ")", "\u0120{", "\u0120boolean", "\u0120external", "S", "so", "Enabled", "\u0120=", "\u0120Engine", "Local", "Config", ".", "get", "Instance", "().", "get", "Boo", "lean", "(\"", "ENG", "INE", "_", "SS", "O", "_", "EN", "ABLE", "_", "EX", "TERN", "AL", "_", "SS", "O", "\");", "\u0120build", "User", "(", "external", "S", "so", "Enabled", "\u0120,", "\u0120params", ",", "\u0120auth", "z", "Name", ")", "\u0120{", "\u0120}"]}
{"function": "private void closeConfirmationWindow() { if(getConfirmWindow() == null) { return; } else { setConfirmWindow(null); } }", "text": "you could just do setConfirmWindow(null); like above method", "function_tokens": ["private", "\u0120void", "\u0120close", "Conf", "irmation", "Window", "()", "\u0120{", "\u0120if", "(", "get", "Conf", "irm", "Window", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120set", "Conf", "irm", "Window", "(", "null", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["you", "\u0120could", "\u0120just", "\u0120do", "\u0120set", "Conf", "irm", "Window", "(", "null", ");", "\u0120like", "\u0120above", "\u0120method"]}
{"function": "public void queryFile1Contributors() { final IFileHistory history = historyProvider.getFileHistoryFor(iFile1, IFileHistoryProvider.NONE, new NullProgressMonitor()); assertNotNull(history); final IFileRevision[] revisions = history.getFileRevisions(); IFileRevision branchFileRevision1 = null; IFileRevision masterFileRevision3 = null; IFileRevision masterFileRevision1 = null; for (IFileRevision revision : revisions) { final String revisionId = revision.getContentIdentifier(); if (branchCommit1.getName().equals(revisionId)) { branchFileRevision1 = revision; } else if (masterCommit3.getName().equals(revisionId)) { masterFileRevision3 = revision; } else if (masterCommit1.getName().equals(revisionId)) { masterFileRevision1 = revision; } } assertNotNull(branchFileRevision1); assertNotNull(masterFileRevision3); assertNotNull(masterFileRevision1); final IFileRevision[] branchCommit1Parents = history.getContributors(branchFileRevision1); assertEquals(1, branchCommit1Parents.length); assertRevisionMatchCommit(branchCommit1Parents[0], masterCommit1); final IFileRevision[] masterCommit3Parents = history .getContributors(masterFileRevision3); assertEquals(1, masterCommit3Parents.length); assertRevisionMatchCommit(masterCommit3Parents[0], masterCommit1); final IFileRevision[] masterCommit1Parents = history .getContributors(masterFileRevision1); assertEquals(0, masterCommit1Parents.length); }", "text": "we don't use braces around single line blocks, many more occurrences in this patch", "function_tokens": ["public", "\u0120void", "\u0120query", "File", "1", "Contribut", "ors", "()", "\u0120{", "\u0120final", "\u0120I", "File", "History", "\u0120history", "\u0120=", "\u0120history", "Provider", ".", "get", "File", "History", "For", "(", "i", "File", "1", ",", "\u0120I", "File", "History", "Provider", ".", "N", "ONE", ",", "\u0120new", "\u0120Null", "Progress", "Monitor", "());", "\u0120assert", "Not", "Null", "(", "history", ");", "\u0120final", "\u0120I", "File", "Rev", "ision", "[]", "\u0120revisions", "\u0120=", "\u0120history", ".", "get", "File", "Rev", "isions", "();", "\u0120I", "File", "Rev", "ision", "\u0120branch", "File", "Rev", "ision", "1", "\u0120=", "\u0120null", ";", "\u0120I", "File", "Rev", "ision", "\u0120master", "File", "Rev", "ision", "3", "\u0120=", "\u0120null", ";", "\u0120I", "File", "Rev", "ision", "\u0120master", "File", "Rev", "ision", "1", "\u0120=", "\u0120null", ";", "\u0120for", "\u0120(", "IF", "ile", "Rev", "ision", "\u0120revision", "\u0120:", "\u0120revisions", ")", "\u0120{", "\u0120final", "\u0120String", "\u0120revision", "Id", "\u0120=", "\u0120revision", ".", "get", "Content", "Ident", "ifier", "();", "\u0120if", "\u0120(", "br", "anch", "Comm", "it", "1", ".", "get", "Name", "().", "equ", "als", "(", "re", "vision", "Id", "))", "\u0120{", "\u0120branch", "File", "Rev", "ision", "1", "\u0120=", "\u0120revision", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "master", "Comm", "it", "3", ".", "get", "Name", "().", "equ", "als", "(", "re", "vision", "Id", "))", "\u0120{", "\u0120master", "File", "Rev", "ision", "3", "\u0120=", "\u0120revision", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "master", "Comm", "it", "1", ".", "get", "Name", "().", "equ", "als", "(", "re", "vision", "Id", "))", "\u0120{", "\u0120master", "File", "Rev", "ision", "1", "\u0120=", "\u0120revision", ";", "\u0120}", "\u0120}", "\u0120assert", "Not", "Null", "(", "br", "anch", "File", "Rev", "ision", "1", ");", "\u0120assert", "Not", "Null", "(", "master", "File", "Rev", "ision", "3", ");", "\u0120assert", "Not", "Null", "(", "master", "File", "Rev", "ision", "1", ");", "\u0120final", "\u0120I", "File", "Rev", "ision", "[]", "\u0120branch", "Comm", "it", "1", "Parents", "\u0120=", "\u0120history", ".", "get", "Contribut", "ors", "(", "br", "anch", "File", "Rev", "ision", "1", ");", "\u0120assert", "Equ", "als", "(", "1", ",", "\u0120branch", "Comm", "it", "1", "Parents", ".", "length", ");", "\u0120assert", "Rev", "ision", "Match", "Comm", "it", "(", "br", "anch", "Comm", "it", "1", "Parents", "[", "0", "],", "\u0120master", "Comm", "it", "1", ");", "\u0120final", "\u0120I", "File", "Rev", "ision", "[]", "\u0120master", "Comm", "it", "3", "Parents", "\u0120=", "\u0120history", "\u0120.", "get", "Contribut", "ors", "(", "master", "File", "Rev", "ision", "3", ");", "\u0120assert", "Equ", "als", "(", "1", ",", "\u0120master", "Comm", "it", "3", "Parents", ".", "length", ");", "\u0120assert", "Rev", "ision", "Match", "Comm", "it", "(", "master", "Comm", "it", "3", "Parents", "[", "0", "],", "\u0120master", "Comm", "it", "1", ");", "\u0120final", "\u0120I", "File", "Rev", "ision", "[]", "\u0120master", "Comm", "it", "1", "Parents", "\u0120=", "\u0120history", "\u0120.", "get", "Contribut", "ors", "(", "master", "File", "Rev", "ision", "1", ");", "\u0120assert", "Equ", "als", "(", "0", ",", "\u0120master", "Comm", "it", "1", "Parents", ".", "length", ");", "\u0120}"], "docstring_tokens": ["we", "\u0120don", "'t", "\u0120use", "\u0120braces", "\u0120around", "\u0120single", "\u0120line", "\u0120blocks", ",", "\u0120many", "\u0120more", "\u0120occurrences", "\u0120in", "\u0120this", "\u0120patch"]}
{"function": "protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); finishIfNotRoot(); if (savedInstanceState != null) { wasExternal = savedInstanceState.getBoolean(\"was_external\"); } ACRAUtil.registerAppData(); uiController = new HomeActivityUIController(this); uiController.setupUI(); }", "text": "this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?", "function_tokens": ["protected", "\u0120void", "\u0120on", "Create", "(", "B", "undle", "\u0120saved", "Instance", "State", ")", "\u0120{", "\u0120super", ".", "on", "Create", "(", "s", "aved", "Instance", "State", ");", "\u0120finish", "If", "Not", "Root", "();", "\u0120if", "\u0120(", "s", "aved", "Instance", "State", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120was", "External", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Boo", "lean", "(\"", "was", "_", "external", "\");", "\u0120}", "\u0120AC", "RA", "Ut", "il", ".", "register", "AppData", "();", "\u0120u", "i", "Controller", "\u0120=", "\u0120new", "\u0120Home", "Activity", "U", "IC", "ont", "roller", "(", "this", ");", "\u0120u", "i", "Controller", ".", "setup", "UI", "();", "\u0120}"], "docstring_tokens": ["this", "\u0120used", "\u0120to", "\u0120bail", "\u0120after", "\u0120this", "\u0120call", "\u0120if", "\u0120it", "\u0120wasn", "'t", "\u0120the", "\u0120root", ",", "\u0120does", "\u0120returning", "\u0120v", ".", "\u0120not", "\u0120returning", "\u0120from", "\u0120on", "Create", "()", "\u0120in", "\u0120that", "\u0120case", "\u0120affect", "\u0120anything", "?"]}
{"function": "public void testCheckoutExistingBranch() throws Exception { Git git = new Git(db); writeTrashFile(\"a\", \"Hello world a\"); git.add().addFilepattern(\".\").call(); git.commit().setMessage(\"commit file a\").call(); git.branchCreate().setName(\"branch_1\").call(); git.rm().addFilepattern(\"a\").call(); FileUtils.mkdirs(new File(db.getWorkTree(), \"a\")); writeTrashFile(\"a/b\", \"Hello world b\"); git.add().addFilepattern(\"a\").call(); git.commit().setMessage(\"commit folder a\").call(); git.rm().addFilepattern(\"a\").call(); writeTrashFile(\"a\", \"New Hello world a\"); git.add().addFilepattern(\".\").call(); assertEquals( \"error: Your local changes to the following files would be overwritten by checkout:\", execute(\"git checkout branch_1\")); }", "text": "don't you want to add a/b?", "function_tokens": ["public", "\u0120void", "\u0120test", "Check", "out", "Ex", "isting", "B", "ranch", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Git", "\u0120git", "\u0120=", "\u0120new", "\u0120Git", "(", "db", ");", "\u0120write", "Tr", "ash", "File", "(\"", "a", "\",", "\u0120\"", "Hello", "\u0120world", "\u0120a", "\");", "\u0120git", ".", "add", "().", "add", "File", "pattern", "(\"", ".\"", ").", "call", "();", "\u0120git", ".", "commit", "().", "set", "Message", "(\"", "commit", "\u0120file", "\u0120a", "\").", "call", "();", "\u0120git", ".", "br", "anch", "Create", "().", "set", "Name", "(\"", "br", "anch", "_", "1", "\").", "call", "();", "\u0120git", ".", "rm", "().", "add", "File", "pattern", "(\"", "a", "\").", "call", "();", "\u0120File", "Ut", "ils", ".", "mk", "dir", "s", "(", "new", "\u0120File", "(", "db", ".", "get", "Work", "Tree", "(),", "\u0120\"", "a", "\")", ");", "\u0120write", "Tr", "ash", "File", "(\"", "a", "/", "b", "\",", "\u0120\"", "Hello", "\u0120world", "\u0120b", "\");", "\u0120git", ".", "add", "().", "add", "File", "pattern", "(\"", "a", "\").", "call", "();", "\u0120git", ".", "commit", "().", "set", "Message", "(\"", "commit", "\u0120folder", "\u0120a", "\").", "call", "();", "\u0120git", ".", "rm", "().", "add", "File", "pattern", "(\"", "a", "\").", "call", "();", "\u0120write", "Tr", "ash", "File", "(\"", "a", "\",", "\u0120\"", "New", "\u0120Hello", "\u0120world", "\u0120a", "\");", "\u0120git", ".", "add", "().", "add", "File", "pattern", "(\"", ".\"", ").", "call", "();", "\u0120assert", "Equ", "als", "(", "\u0120\"", "error", ":", "\u0120Your", "\u0120local", "\u0120changes", "\u0120to", "\u0120the", "\u0120following", "\u0120files", "\u0120would", "\u0120be", "\u0120overw", "ritten", "\u0120by", "\u0120checkout", ":", "\",", "\u0120execute", "(\"", "git", "\u0120checkout", "\u0120branch", "_", "1", "\")", ");", "\u0120}"], "docstring_tokens": ["don", "'t", "\u0120you", "\u0120want", "\u0120to", "\u0120add", "\u0120a", "/", "b", "?"]}
{"function": "private String formRevertMessage(RevertResult revertResult) { StringBuilder message = new StringBuilder(); if (revertResult.getNewHead() != null) { message.append(constant.revertedNewHead(revertResult.getNewHead())); } List<String> commits = revertResult.getRevertedCommits(); if (commits != null && commits.size() > 0) { StringBuilder revertedCommits = new StringBuilder(); for (String commit : commits) { revertedCommits.append(\" \"); revertedCommits.append(commit); } message.append( revertedCommits.length() > 0 ? \" \" + constant.revertedCommits(revertedCommits.toString()) : \"\\n\"); } return message.toString(); }", "text": "To me it would be a bit clearer to use append chain here.", "function_tokens": ["private", "\u0120String", "\u0120form", "R", "ever", "t", "Message", "(", "R", "ever", "t", "Result", "\u0120revert", "Result", ")", "\u0120{", "\u0120String", "Builder", "\u0120message", "\u0120=", "\u0120new", "\u0120String", "Builder", "();", "\u0120if", "\u0120(", "re", "vert", "Result", ".", "get", "New", "Head", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120message", ".", "append", "(", "const", "ant", ".", "re", "verted", "New", "Head", "(", "re", "vert", "Result", ".", "get", "New", "Head", "()", "));", "\u0120}", "\u0120List", "<", "String", ">", "\u0120commits", "\u0120=", "\u0120revert", "Result", ".", "get", "R", "ever", "ted", "Comm", "its", "();", "\u0120if", "\u0120(", "comm", "its", "\u0120!=", "\u0120null", "\u0120&&", "\u0120commits", ".", "size", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120String", "Builder", "\u0120reverted", "Comm", "its", "\u0120=", "\u0120new", "\u0120String", "Builder", "();", "\u0120for", "\u0120(", "String", "\u0120commit", "\u0120:", "\u0120commits", ")", "\u0120{", "\u0120reverted", "Comm", "its", ".", "append", "(\"", "\u0120\"", ");", "\u0120reverted", "Comm", "its", ".", "append", "(", "commit", ");", "\u0120}", "\u0120message", ".", "append", "(", "\u0120reverted", "Comm", "its", ".", "length", "()", "\u0120>", "\u01200", "\u0120?", "\u0120\"", "\u0120\"", "\u0120+", "\u0120constant", ".", "re", "verted", "Comm", "its", "(", "re", "verted", "Comm", "its", ".", "to", "String", "())", "\u0120:", "\u0120\"\\", "n", "\");", "\u0120}", "\u0120return", "\u0120message", ".", "to", "String", "();", "\u0120}"], "docstring_tokens": ["To", "\u0120me", "\u0120it", "\u0120would", "\u0120be", "\u0120a", "\u0120bit", "\u0120clearer", "\u0120to", "\u0120use", "\u0120append", "\u0120chain", "\u0120here", "."]}
{"function": "public static void init(Context context, String appDefinedUserAgent) { String appId = \"unknown\"; try { PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0); appId = pi.packageName; } catch (Exception ignore) { } String userAgent = \"Unknown\"; try { StringBuilder sb = new StringBuilder(); sb.append(\"RealmJava/\"); sb.append(BuildConfig.VERSION_NAME); sb.append(\" (\"); sb.append(Util.isEmptyString(Build.DEVICE) ? \"unknown-device\" : Build.DEVICE); sb.append(\", \"); sb.append(Util.isEmptyString(Build.MODEL) ? \"unknown-model\" : Build.MODEL); sb.append(\", v\"); sb.append(Build.VERSION.SDK_INT); sb.append(\")\"); if (!appDefinedUserAgent.isEmpty()) { sb.append(\" \"); sb.append(appDefinedUserAgent); } userAgent = sb.toString(); } catch (Exception e) { RealmLog.warn(\"Constructing User-Agent description failed.\", e); } if (SyncManager.Debug.separatedDirForSyncManager) { try { File dir = File.createTempFile(\"remote_sync_\", \"_\" + android.os.Process.myPid(), context.getFilesDir()); if (!dir.delete()) { throw new IllegalStateException(String.format(Locale.US, \"Temp file '%s' cannot be deleted.\", dir.getPath())); } if (!dir.mkdir()) { throw new IllegalStateException(String.format(Locale.US, \"Directory '%s' for SyncManager cannot be created. \", dir.getPath())); } SyncManager.nativeInitializeSyncManager(dir.getPath(), userAgent); } catch (IOException e) { throw new IllegalStateException(e); } } else { SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath(), userAgent); } UserStore userStore = new RealmFileUserStore(); SyncManager.init(appId, userAgent, userStore); }", "text": "use an overload or varargs to make this parameter optional, so: 1- you don't break current API 2- don't force the user to think about this parameter (especially in the context of non sync)", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120init", "(", "Context", "\u0120context", ",", "\u0120String", "\u0120app", "Def", "ined", "User", "Agent", ")", "\u0120{", "\u0120String", "\u0120app", "Id", "\u0120=", "\u0120\"", "unknown", "\";", "\u0120try", "\u0120{", "\u0120Package", "Info", "\u0120pi", "\u0120=", "\u0120context", ".", "get", "Package", "Manager", "().", "get", "Package", "Info", "(", "context", ".", "get", "Package", "Name", "(),", "\u01200", ");", "\u0120app", "Id", "\u0120=", "\u0120pi", ".", "package", "Name", ";", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120ignore", ")", "\u0120{", "\u0120}", "\u0120String", "\u0120user", "Agent", "\u0120=", "\u0120\"", "Unknown", "\";", "\u0120try", "\u0120{", "\u0120String", "Builder", "\u0120s", "b", "\u0120=", "\u0120new", "\u0120String", "Builder", "();", "\u0120s", "b", ".", "append", "(\"", "Real", "m", "Java", "/", "\");", "\u0120s", "b", ".", "append", "(", "Build", "Config", ".", "VERSION", "_", "NAME", ");", "\u0120s", "b", ".", "append", "(\"", "\u0120(\"", ");", "\u0120s", "b", ".", "append", "(", "Ut", "il", ".", "is", "Empty", "String", "(", "Build", ".", "DE", "VICE", ")", "\u0120?", "\u0120\"", "unknown", "-", "device", "\"", "\u0120:", "\u0120Build", ".", "DE", "VICE", ");", "\u0120s", "b", ".", "append", "(", "\",", "\u0120\"", ");", "\u0120s", "b", ".", "append", "(", "Ut", "il", ".", "is", "Empty", "String", "(", "Build", ".", "MOD", "EL", ")", "\u0120?", "\u0120\"", "unknown", "-", "model", "\"", "\u0120:", "\u0120Build", ".", "MOD", "EL", ");", "\u0120s", "b", ".", "append", "(", "\",", "\u0120v", "\");", "\u0120s", "b", ".", "append", "(", "Build", ".", "VERSION", ".", "SD", "K", "_", "INT", ");", "\u0120s", "b", ".", "append", "(", "\")", "\");", "\u0120if", "\u0120(!", "app", "Def", "ined", "User", "Agent", ".", "is", "Empty", "())", "\u0120{", "\u0120s", "b", ".", "append", "(\"", "\u0120\"", ");", "\u0120s", "b", ".", "append", "(", "app", "Def", "ined", "User", "Agent", ");", "\u0120}", "\u0120user", "Agent", "\u0120=", "\u0120s", "b", ".", "to", "String", "();", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120Realm", "Log", ".", "warn", "(\"", "Construct", "ing", "\u0120User", "-", "Agent", "\u0120description", "\u0120failed", ".\",", "\u0120e", ");", "\u0120}", "\u0120if", "\u0120(", "Sync", "Manager", ".", "Debug", ".", "separ", "ated", "Dir", "For", "Sync", "Manager", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120File", "\u0120dir", "\u0120=", "\u0120File", ".", "create", "Temp", "File", "(\"", "remote", "_", "sync", "_", "\",", "\u0120\"_", "\"", "\u0120+", "\u0120android", ".", "os", ".", "Process", ".", "my", "P", "id", "(),", "\u0120context", ".", "get", "Files", "Dir", "());", "\u0120if", "\u0120(!", "dir", ".", "delete", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(", "String", ".", "format", "(", "Loc", "ale", ".", "US", ",", "\u0120\"", "Temp", "\u0120file", "\u0120'", "%", "s", "'", "\u0120cannot", "\u0120be", "\u0120deleted", ".\",", "\u0120dir", ".", "get", "Path", "()", "));", "\u0120}", "\u0120if", "\u0120(!", "dir", ".", "mk", "dir", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(", "String", ".", "format", "(", "Loc", "ale", ".", "US", ",", "\u0120\"", "Directory", "\u0120'", "%", "s", "'", "\u0120for", "\u0120Sync", "Manager", "\u0120cannot", "\u0120be", "\u0120created", ".", "\u0120\",", "\u0120dir", ".", "get", "Path", "()", "));", "\u0120}", "\u0120Sync", "Manager", ".", "native", "Initial", "ize", "Sync", "Manager", "(", "dir", ".", "get", "Path", "(),", "\u0120user", "Agent", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(", "e", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Sync", "Manager", ".", "native", "Initial", "ize", "Sync", "Manager", "(", "context", ".", "get", "Files", "Dir", "().", "get", "Path", "(),", "\u0120user", "Agent", ");", "\u0120}", "\u0120User", "Store", "\u0120user", "Store", "\u0120=", "\u0120new", "\u0120Realm", "File", "User", "Store", "();", "\u0120Sync", "Manager", ".", "init", "(", "app", "Id", ",", "\u0120user", "Agent", ",", "\u0120user", "Store", ");", "\u0120}"], "docstring_tokens": ["use", "\u0120an", "\u0120overload", "\u0120or", "\u0120var", "args", "\u0120to", "\u0120make", "\u0120this", "\u0120parameter", "\u0120optional", ",", "\u0120so", ":", "\u01201", "-", "\u0120you", "\u0120don", "'t", "\u0120break", "\u0120current", "\u0120API", "\u01202", "-", "\u0120don", "'t", "\u0120force", "\u0120the", "\u0120user", "\u0120to", "\u0120think", "\u0120about", "\u0120this", "\u0120parameter", "\u0120(", "especially", "\u0120in", "\u0120the", "\u0120context", "\u0120of", "\u0120non", "\u0120sync", ")"]}
{"function": "private List<StoragePool> searchStoragePool() { Optional<Version> optionalVersion = Config.<HashSet<Version>> getValue(ConfigValues.SupportedClusterLevels).stream() .max(Comparator.naturalOrder()); List<StoragePool> dataCenters = genericSearch(storagePoolDao, true); optionalVersion.ifPresent( version -> dataCenters.forEach( dataCenter -> { dataCenter.setStoragePoolCompatibilityLevelUpgradeNeeded( version.compareTo(dataCenter.getCompatibilityVersion()) > 0); dataCenter.setMacPoolId(dcSingleMacPoolFinder.find(dataCenter.getId())); } )); return dataCenters; }", "text": "I believe it would be easier to do check !ifPresent and skip rest, instead of creating that first lambda. if you like 2 lambdas approach instead of one if and one lambda, then fine, but extract method to contain second lambda, because lambda in lambda ... that's like watching Inception again, and nobody should be forced to watch that...", "function_tokens": ["private", "\u0120List", "<", "Storage", "Pool", ">", "\u0120search", "Storage", "Pool", "()", "\u0120{", "\u0120Optional", "<", "Version", ">", "\u0120optional", "Version", "\u0120=", "\u0120Config", ".<", "Hash", "Set", "<", "Version", ">>", "\u0120get", "Value", "(", "Config", "Values", ".", "Supported", "Cl", "uster", "Level", "s", ").", "stream", "()", "\u0120.", "max", "(", "Compar", "ator", ".", "natural", "Order", "());", "\u0120List", "<", "Storage", "Pool", ">", "\u0120data", "Cent", "ers", "\u0120=", "\u0120generic", "Search", "(", "storage", "Pool", "D", "ao", ",", "\u0120true", ");", "\u0120optional", "Version", ".", "if", "Present", "(", "\u0120version", "\u0120->", "\u0120data", "Cent", "ers", ".", "for", "Each", "(", "\u0120data", "Center", "\u0120->", "\u0120{", "\u0120data", "Center", ".", "set", "Storage", "Pool", "Comp", "atibility", "Level", "Upgrade", "Need", "ed", "(", "\u0120version", ".", "comp", "are", "To", "(", "data", "Center", ".", "get", "Comp", "atibility", "Version", "())", "\u0120>", "\u01200", ");", "\u0120data", "Center", ".", "set", "Mac", "Pool", "Id", "(", "dc", "Single", "Mac", "Pool", "F", "inder", ".", "find", "(", "data", "Center", ".", "get", "Id", "()", "));", "\u0120}", "\u0120));", "\u0120return", "\u0120data", "Cent", "ers", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120believe", "\u0120it", "\u0120would", "\u0120be", "\u0120easier", "\u0120to", "\u0120do", "\u0120check", "\u0120!", "if", "Present", "\u0120and", "\u0120skip", "\u0120rest", ",", "\u0120instead", "\u0120of", "\u0120creating", "\u0120that", "\u0120first", "\u0120lambda", ".", "\u0120if", "\u0120you", "\u0120like", "\u01202", "\u0120lamb", "d", "as", "\u0120approach", "\u0120instead", "\u0120of", "\u0120one", "\u0120if", "\u0120and", "\u0120one", "\u0120lambda", ",", "\u0120then", "\u0120fine", ",", "\u0120but", "\u0120extract", "\u0120method", "\u0120to", "\u0120contain", "\u0120second", "\u0120lambda", ",", "\u0120because", "\u0120lambda", "\u0120in", "\u0120lambda", "\u0120...", "\u0120that", "'s", "\u0120like", "\u0120watching", "\u0120In", "ception", "\u0120again", ",", "\u0120and", "\u0120nobody", "\u0120should", "\u0120be", "\u0120forced", "\u0120to", "\u0120watch", "\u0120that", "..."]}
{"function": "public boolean save(final Tuple<String, LogicalPlan> tuple){ final LogicalPlan plan = tuple.getValue(); final String queryId = tuple.getKey(); final File storedPlanFile= new File(planFolderPath + queryId + \".plan\"); if (!storedPlanFile.exists()) { final DataFileWriter<LogicalPlan> dataFileWriter = new DataFileWriter<LogicalPlan>(datumWriter); try { dataFileWriter.create(plan.getSchema(), storedPlanFile); dataFileWriter.append(plan); dataFileWriter.close(); return true; } catch (final Exception e) { e.printStackTrace(); } } return false; }", "text": "File(planStorePath, queryId + \".plan\")", "function_tokens": ["public", "\u0120boolean", "\u0120save", "(", "final", "\u0120T", "uple", "<", "String", ",", "\u0120Log", "ical", "Plan", ">", "\u0120tuple", "){", "\u0120final", "\u0120Log", "ical", "Plan", "\u0120plan", "\u0120=", "\u0120tuple", ".", "get", "Value", "();", "\u0120final", "\u0120String", "\u0120query", "Id", "\u0120=", "\u0120tuple", ".", "get", "Key", "();", "\u0120final", "\u0120File", "\u0120stored", "Plan", "File", "=", "\u0120new", "\u0120File", "(", "plan", "Folder", "Path", "\u0120+", "\u0120query", "Id", "\u0120+", "\u0120\".", "plan", "\");", "\u0120if", "\u0120(!", "st", "ored", "Plan", "File", ".", "ex", "ists", "())", "\u0120{", "\u0120final", "\u0120Data", "File", "Writer", "<", "Log", "ical", "Plan", ">", "\u0120data", "File", "Writer", "\u0120=", "\u0120new", "\u0120Data", "File", "Writer", "<", "Log", "ical", "Plan", ">(", "dat", "um", "Writer", ");", "\u0120try", "\u0120{", "\u0120data", "File", "Writer", ".", "create", "(", "plan", ".", "get", "Sche", "ma", "(),", "\u0120stored", "Plan", "File", ");", "\u0120data", "File", "Writer", ".", "append", "(", "plan", ");", "\u0120data", "File", "Writer", ".", "close", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["File", "(", "plan", "Store", "Path", ",", "\u0120query", "Id", "\u0120+", "\u0120\".", "plan", "\")"]}
{"function": "public void onMessage(NodeRegistrationContainerReport nodeRegistrationContainerReport, EventPublisher publisher) { if (chillModeManager.getInChillMode()) { if (validate()) { chillModeManager.validateChillModeExitRules(publisher); return; } } else { return; } process(nodeRegistrationContainerReport); if(chillModeManager.getInChillMode()) { SCMChillModeManager.getLogger().info( \"SCM in chill mode. {} DataNodes registered, {} required.\", registeredDns, requiredDns); } if (validate()) { chillModeManager.validateChillModeExitRules(publisher); return; } }", "text": "We should process data from this report before validating again.", "function_tokens": ["public", "\u0120void", "\u0120on", "Message", "(", "Node", "Registration", "Container", "Report", "\u0120node", "Registration", "Container", "Report", ",", "\u0120Event", "Publisher", "\u0120publisher", ")", "\u0120{", "\u0120if", "\u0120(", "ch", "ill", "Mode", "Manager", ".", "get", "In", "Ch", "ill", "Mode", "())", "\u0120{", "\u0120if", "\u0120(", "valid", "ate", "())", "\u0120{", "\u0120chill", "Mode", "Manager", ".", "valid", "ate", "Ch", "ill", "Mode", "Exit", "Rules", "(", "pub", "lisher", ");", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120process", "(", "node", "Registration", "Container", "Report", ");", "\u0120if", "(", "ch", "ill", "Mode", "Manager", ".", "get", "In", "Ch", "ill", "Mode", "())", "\u0120{", "\u0120SC", "M", "Ch", "ill", "Mode", "Manager", ".", "get", "Log", "ger", "().", "info", "(", "\u0120\"", "SC", "M", "\u0120in", "\u0120chill", "\u0120mode", ".", "\u0120{}", "\u0120Data", "N", "odes", "\u0120registered", ",", "\u0120{}", "\u0120required", ".\",", "\u0120registered", "D", "ns", ",", "\u0120required", "D", "ns", ");", "\u0120}", "\u0120if", "\u0120(", "valid", "ate", "())", "\u0120{", "\u0120chill", "Mode", "Manager", ".", "valid", "ate", "Ch", "ill", "Mode", "Exit", "Rules", "(", "pub", "lisher", ");", "\u0120return", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["We", "\u0120should", "\u0120process", "\u0120data", "\u0120from", "\u0120this", "\u0120report", "\u0120before", "\u0120valid", "ating", "\u0120again", "."]}
{"function": "protected int doWork() { initializeAggregationState(); IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFilesAreReadable(INTERVALS); final int returnValue; if ( INTERVAL_ITERATOR ) { returnValue = processDataIntervalIteration(); } else { returnValue = processDataNormalIteration(); } if (returnValue != 0) { return returnValue; } log.info(\"Iteration complete, generating metric files\"); aggregatorList.forEach(this::writeMetricsFileForAggregator); log.info(String.format(\"Examined %d loci, Processed %d loci, Skipped %d loci.\\n\" + \"Computation took %d seconds.\", nTotalLoci, nProcessedLoci, nSkippedLoci, progressLogger.getElapsedSeconds())); return returnValue; }", "text": "at this point returnValue==0, so why change?", "function_tokens": ["protected", "\u0120int", "\u0120do", "Work", "()", "\u0120{", "\u0120initialize", "Agg", "regation", "State", "();", "\u0120I", "OU", "til", ".", "assert", "File", "Is", "Read", "able", "(", "IN", "PUT", ");", "\u0120I", "OU", "til", ".", "assert", "Files", "Are", "Read", "able", "(", "INTER", "V", "ALS", ");", "\u0120final", "\u0120int", "\u0120return", "Value", ";", "\u0120if", "\u0120(", "\u0120INTER", "VAL", "_", "IT", "ER", "ATOR", "\u0120)", "\u0120{", "\u0120return", "Value", "\u0120=", "\u0120process", "Data", "Inter", "val", "Iter", "ation", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "Value", "\u0120=", "\u0120process", "Data", "Normal", "Iter", "ation", "();", "\u0120}", "\u0120if", "\u0120(", "return", "Value", "\u0120!=", "\u01200", ")", "\u0120{", "\u0120return", "\u0120return", "Value", ";", "\u0120}", "\u0120log", ".", "info", "(\"", "Iter", "ation", "\u0120complete", ",", "\u0120generating", "\u0120metric", "\u0120files", "\");", "\u0120aggreg", "ator", "List", ".", "for", "Each", "(", "this", "::", "write", "Met", "rics", "File", "For", "Agg", "reg", "ator", ");", "\u0120log", ".", "info", "(", "String", ".", "format", "(\"", "Ex", "am", "ined", "\u0120%", "d", "\u0120loc", "i", ",", "\u0120Process", "ed", "\u0120%", "d", "\u0120loc", "i", ",", "\u0120Sk", "ipped", "\u0120%", "d", "\u0120loc", "i", ".", "\\", "n", "\"", "\u0120+", "\u0120\"", "Com", "put", "ation", "\u0120took", "\u0120%", "d", "\u0120seconds", ".\",", "\u0120n", "Total", "L", "oci", ",", "\u0120n", "Process", "ed", "L", "oci", ",", "\u0120n", "Sk", "ipped", "L", "oci", ",", "\u0120progress", "Log", "ger", ".", "get", "El", "apsed", "Second", "s", "()", "));", "\u0120return", "\u0120return", "Value", ";", "\u0120}"], "docstring_tokens": ["at", "\u0120this", "\u0120point", "\u0120return", "Value", "==", "0", ",", "\u0120so", "\u0120why", "\u0120change", "?"]}
{"function": "private void setExecutionEnvironment(TargetPlatformConfiguration result, Xpp3Dom configuration) { String value = getStringValue(configuration.getChild(\"executionEnvironment\")); if (value == null) { return; } if (value.startsWith(\"?\")) { throw new RuntimeException( \"The target-platform-configuration parameter <executionEnvironment> must not start with a '?'. Use <defaultExecutionEnvironment> without a leading '?' instead.\"); } try { ExecutionEnvironmentUtils.getExecutionEnvironment(value); } catch (UnknownEnvironmentException e) { throw new RuntimeException(\"Invalid execution environment profile name \" + value); } result.setExecutionEnvironment(value); }", "text": "We don't need this check. Even if \"?\" is used somewhere, which I doubt, UnknownEnvironmentException be self-exlanatory enough for somebody to investigate and fix it.", "function_tokens": ["private", "\u0120void", "\u0120set", "Exec", "ution", "Environment", "(", "Target", "Platform", "Configuration", "\u0120result", ",", "\u0120X", "pp", "3", "Dom", "\u0120configuration", ")", "\u0120{", "\u0120String", "\u0120value", "\u0120=", "\u0120get", "String", "Value", "(", "config", "uration", ".", "get", "Child", "(\"", "exec", "ution", "Environment", "\")", ");", "\u0120if", "\u0120(", "value", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "value", ".", "st", "arts", "With", "(\"", "?\"", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "\u0120\"", "The", "\u0120target", "-", "platform", "-", "config", "uration", "\u0120parameter", "\u0120<", "exec", "ution", "Environment", ">", "\u0120must", "\u0120not", "\u0120start", "\u0120with", "\u0120a", "\u0120'", "?", "'.", "\u0120Use", "\u0120<", "default", "Exec", "ution", "Environment", ">", "\u0120without", "\u0120a", "\u0120leading", "\u0120'", "?'", "\u0120instead", ".\"", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120Execution", "Environment", "Ut", "ils", ".", "get", "Exec", "ution", "Environment", "(", "value", ");", "\u0120}", "\u0120catch", "\u0120(", "Unknown", "Environment", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Invalid", "\u0120execution", "\u0120environment", "\u0120profile", "\u0120name", "\u0120\"", "\u0120+", "\u0120value", ");", "\u0120}", "\u0120result", ".", "set", "Exec", "ution", "Environment", "(", "value", ");", "\u0120}"], "docstring_tokens": ["We", "\u0120don", "'t", "\u0120need", "\u0120this", "\u0120check", ".", "\u0120Even", "\u0120if", "\u0120\"", "?\"", "\u0120is", "\u0120used", "\u0120somewhere", ",", "\u0120which", "\u0120I", "\u0120doubt", ",", "\u0120Unknown", "Environment", "Exception", "\u0120be", "\u0120self", "-", "ex", "lan", "atory", "\u0120enough", "\u0120for", "\u0120somebody", "\u0120to", "\u0120investigate", "\u0120and", "\u0120fix", "\u0120it", "."]}
{"function": "public void onBindEvent(BindButtonEvent event) { if (event.getState().equals(ButtonState.DOWN) && !SortOrderSystem.containsConsole()) { if (event.getId().equals(new SimpleUri(\"engine:tabbingModifier\"))) { shiftPressed = true; } if (event.getId().equals(new SimpleUri(\"engine:tabbingUI\"))) { TabbingManager.focusSetThrough = true; if (shiftPressed) { TabbingManager.changeCurrentNum(false); } else { TabbingManager.changeCurrentNum(true); } for (WidgetWithOrder widget : TabbingManager.getWidgetsList()) { if (widget.getOrder() == TabbingManager.getCurrentNum()) { if (!widget.isEnabled()) { TabbingManager.changeCurrentNum(true); } else { widget.onGainFocus(); TabbingManager.focusedWidget = widget; TabbingManager.getOpenScreen().getManager().setFocus(widget); } } else { widget.onLoseFocus(); if (widget instanceof UIRadialSection) { ((UIRadialSection) widget).setSelected(false); } } } event.prepare(new SimpleUri(\"engine:tabbingUI\"), ButtonState.UP, event.getDelta()); } else if (event.getId().equals(new SimpleUri(\"engine:activate\"))) { if (TabbingManager.focusedWidget instanceof UIDropdown) { ((UIDropdown) TabbingManager.focusedWidget).setOpenedReverse(); } else if (TabbingManager.focusedWidget instanceof ActivateableWidget) { ((ActivateableWidget) TabbingManager.focusedWidget).activateWidget(); } event.prepare(new SimpleUri(\"engine:activate\"), ButtonState.UP, event.getDelta()); } } if (event.getState().equals(ButtonState.UP) && !SortOrderSystem.containsConsole()) { if (event.getId().equals(new SimpleUri(\"engine:tabbingModifier\"))) { shiftPressed = false; } } }", "text": "You can replace this if with: java TabbingManager.changeCurrentNum(!shiftPressed);", "function_tokens": ["public", "\u0120void", "\u0120on", "Bind", "Event", "(", "Bind", "Button", "Event", "\u0120event", ")", "\u0120{", "\u0120if", "\u0120(", "event", ".", "get", "State", "().", "equ", "als", "(", "Button", "State", ".", "DOWN", ")", "\u0120&&", "\u0120!", "Sort", "Order", "System", ".", "cont", "ains", "Console", "())", "\u0120{", "\u0120if", "\u0120(", "event", ".", "get", "Id", "().", "equ", "als", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "tab", "bing", "Mod", "ifier", "\"", ")))", "\u0120{", "\u0120shift", "P", "ressed", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "event", ".", "get", "Id", "().", "equ", "als", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "tab", "bing", "UI", "\"", ")))", "\u0120{", "\u0120Tab", "bing", "Manager", ".", "focus", "Set", "Through", "\u0120=", "\u0120true", ";", "\u0120if", "\u0120(", "shift", "P", "ressed", ")", "\u0120{", "\u0120Tab", "bing", "Manager", ".", "change", "Current", "Num", "(", "false", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Tab", "bing", "Manager", ".", "change", "Current", "Num", "(", "true", ");", "\u0120}", "\u0120for", "\u0120(", "Widget", "With", "Order", "\u0120widget", "\u0120:", "\u0120Tab", "bing", "Manager", ".", "get", "W", "id", "gets", "List", "())", "\u0120{", "\u0120if", "\u0120(", "widget", ".", "get", "Order", "()", "\u0120==", "\u0120Tab", "bing", "Manager", ".", "get", "Current", "Num", "())", "\u0120{", "\u0120if", "\u0120(!", "widget", ".", "is", "Enabled", "())", "\u0120{", "\u0120Tab", "bing", "Manager", ".", "change", "Current", "Num", "(", "true", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120widget", ".", "on", "G", "ain", "Focus", "();", "\u0120Tab", "bing", "Manager", ".", "focused", "Widget", "\u0120=", "\u0120widget", ";", "\u0120Tab", "bing", "Manager", ".", "get", "Open", "Screen", "().", "get", "Manager", "().", "set", "Focus", "(", "widget", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120widget", ".", "on", "L", "ose", "Focus", "();", "\u0120if", "\u0120(", "widget", "\u0120instance", "of", "\u0120U", "IR", "ad", "ial", "Section", ")", "\u0120{", "\u0120((", "U", "IR", "ad", "ial", "Section", ")", "\u0120widget", ").", "set", "Se", "lected", "(", "false", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120event", ".", "prep", "are", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "tab", "bing", "UI", "\"),", "\u0120Button", "State", ".", "UP", ",", "\u0120event", ".", "get", "Delta", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "event", ".", "get", "Id", "().", "equ", "als", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "activate", "\"", ")))", "\u0120{", "\u0120if", "\u0120(", "Tab", "bing", "Manager", ".", "focused", "Widget", "\u0120instance", "of", "\u0120UID", "rop", "down", ")", "\u0120{", "\u0120((", "UID", "rop", "down", ")", "\u0120Tab", "bing", "Manager", ".", "focused", "Widget", ").", "set", "Op", "ened", "R", "ever", "se", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "Tab", "bing", "Manager", ".", "focused", "Widget", "\u0120instance", "of", "\u0120Activate", "able", "Widget", ")", "\u0120{", "\u0120((", "Activ", "ate", "able", "Widget", ")", "\u0120Tab", "bing", "Manager", ".", "focused", "Widget", ").", "activate", "Widget", "();", "\u0120}", "\u0120event", ".", "prep", "are", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "activate", "\"),", "\u0120Button", "State", ".", "UP", ",", "\u0120event", ".", "get", "Delta", "());", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "event", ".", "get", "State", "().", "equ", "als", "(", "Button", "State", ".", "UP", ")", "\u0120&&", "\u0120!", "Sort", "Order", "System", ".", "cont", "ains", "Console", "())", "\u0120{", "\u0120if", "\u0120(", "event", ".", "get", "Id", "().", "equ", "als", "(", "new", "\u0120Simple", "U", "ri", "(\"", "engine", ":", "tab", "bing", "Mod", "ifier", "\"", ")))", "\u0120{", "\u0120shift", "P", "ressed", "\u0120=", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["You", "\u0120can", "\u0120replace", "\u0120this", "\u0120if", "\u0120with", ":", "\u0120java", "\u0120Tab", "bing", "Manager", ".", "change", "Current", "Num", "(", "!", "shift", "P", "ressed", ");"]}
{"function": "protected boolean corsRequest() { if (!deployment.isCors()) return false; KeycloakSecurityContext securityContext = facade.getSecurityContext(); String origin = facade.getRequest().getHeader(CorsHeaders.ORIGIN); String exposeHeaders = deployment.getCorsExposedHeaders(); String requestOrigin = UriUtils.getOrigin(facade.getRequest().getURI()); log.debugv(\"Origin: {0} uri: {1}\", origin, facade.getRequest().getURI()); if (securityContext != null && origin != null && !origin.equals(requestOrigin)) { AccessToken token = securityContext.getToken(); Set<String> allowedOrigins = token.getAllowedOrigins(); if (log.isDebugEnabled()) { for (String a : allowedOrigins) log.debug(\" \" + a); } if (allowedOrigins == null || (!allowedOrigins.contains(\"*\") && !allowedOrigins.contains(origin))) { if (allowedOrigins == null) { log.debugv(\"allowedOrigins was null in token\"); } else { log.debugv(\"allowedOrigins did not contain origin\"); } facade.getResponse().sendError(403); facade.getResponse().end(); return true; } log.debugv(\"returning origin: {0}\", origin); facade.getResponse().setStatus(200); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\"); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, exposeHeaders); } else { log.debugv(\"cors validation not needed as we're not a secure session or origin header was null: {0}\", facade.getRequest().getURI()); } return false; }", "text": "Only set header if \"deployment.getCorsExposedHeaders() != null\"", "function_tokens": ["protected", "\u0120boolean", "\u0120c", "ors", "Request", "()", "\u0120{", "\u0120if", "\u0120(!", "de", "ploy", "ment", ".", "is", "C", "ors", "())", "\u0120return", "\u0120false", ";", "\u0120Key", "cl", "oak", "Security", "Context", "\u0120security", "Context", "\u0120=", "\u0120facade", ".", "get", "Security", "Context", "();", "\u0120String", "\u0120origin", "\u0120=", "\u0120facade", ".", "get", "Request", "().", "get", "Header", "(", "C", "ors", "Head", "ers", ".", "OR", "IG", "IN", ");", "\u0120String", "\u0120expose", "Head", "ers", "\u0120=", "\u0120deployment", ".", "get", "C", "ors", "Exp", "osed", "Head", "ers", "();", "\u0120String", "\u0120request", "Origin", "\u0120=", "\u0120Uri", "Ut", "ils", ".", "get", "Origin", "(", "fac", "ade", ".", "get", "Request", "().", "get", "URI", "());", "\u0120log", ".", "debug", "v", "(\"", "Origin", ":", "\u0120{", "0", "}", "\u0120ur", "i", ":", "\u0120{", "1", "}", "\",", "\u0120origin", ",", "\u0120facade", ".", "get", "Request", "().", "get", "URI", "());", "\u0120if", "\u0120(", "security", "Context", "\u0120!=", "\u0120null", "\u0120&&", "\u0120origin", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "origin", ".", "equ", "als", "(", "request", "Origin", "))", "\u0120{", "\u0120Access", "Token", "\u0120token", "\u0120=", "\u0120security", "Context", ".", "get", "Token", "();", "\u0120Set", "<", "String", ">", "\u0120allowed", "Orig", "ins", "\u0120=", "\u0120token", ".", "get", "All", "owed", "Orig", "ins", "();", "\u0120if", "\u0120(", "log", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120for", "\u0120(", "String", "\u0120a", "\u0120:", "\u0120allowed", "Orig", "ins", ")", "\u0120log", ".", "debug", "(\"", "\u0120\"", "\u0120+", "\u0120a", ");", "\u0120}", "\u0120if", "\u0120(", "allowed", "Orig", "ins", "\u0120==", "\u0120null", "\u0120||", "\u0120(!", "allowed", "Orig", "ins", ".", "cont", "ains", "(\"", "*", "\")", "\u0120&&", "\u0120!", "allowed", "Orig", "ins", ".", "cont", "ains", "(", "origin", ")))", "\u0120{", "\u0120if", "\u0120(", "allowed", "Orig", "ins", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120log", ".", "debug", "v", "(\"", "allowed", "Orig", "ins", "\u0120was", "\u0120null", "\u0120in", "\u0120token", "\");", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "debug", "v", "(\"", "allowed", "Orig", "ins", "\u0120did", "\u0120not", "\u0120contain", "\u0120origin", "\");", "\u0120}", "\u0120facade", ".", "get", "Response", "().", "send", "Error", "(", "403", ");", "\u0120facade", ".", "get", "Response", "().", "end", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120log", ".", "debug", "v", "(\"", "return", "ing", "\u0120origin", ":", "\u0120{", "0", "}", "\",", "\u0120origin", ");", "\u0120facade", ".", "get", "Response", "().", "set", "Status", "(", "200", ");", "\u0120facade", ".", "get", "Response", "().", "set", "Header", "(", "C", "ors", "Head", "ers", ".", "ACC", "ESS", "_", "CON", "TR", "OL", "_", "ALL", "OW", "_", "OR", "IG", "IN", ",", "\u0120origin", ");", "\u0120facade", ".", "get", "Response", "().", "set", "Header", "(", "C", "ors", "Head", "ers", ".", "ACC", "ESS", "_", "CON", "TR", "OL", "_", "ALL", "OW", "_", "CR", "ED", "ENT", "IAL", "S", ",", "\u0120\"", "true", "\");", "\u0120facade", ".", "get", "Response", "().", "set", "Header", "(", "C", "ors", "Head", "ers", ".", "ACC", "ESS", "_", "CON", "TR", "OL", "_", "EX", "POSE", "_", "HEAD", "ERS", ",", "\u0120expose", "Head", "ers", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "debug", "v", "(\"", "c", "ors", "\u0120validation", "\u0120not", "\u0120needed", "\u0120as", "\u0120we", "'re", "\u0120not", "\u0120a", "\u0120secure", "\u0120session", "\u0120or", "\u0120origin", "\u0120header", "\u0120was", "\u0120null", ":", "\u0120{", "0", "}", "\",", "\u0120facade", ".", "get", "Request", "().", "get", "URI", "());", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Only", "\u0120set", "\u0120header", "\u0120if", "\u0120\"", "de", "ploy", "ment", ".", "get", "C", "ors", "Exp", "osed", "Head", "ers", "()", "\u0120!=", "\u0120null", "\""]}
{"function": "public void beforeSend( ServerSession session, Transaction tx, Message message, boolean direct, boolean noAutoCreateQueue) { try { if (brokerMessageInterceptor == null) { BundleContext bundleContext = getBundleContext(); brokerMessageInterceptor = bundleContext.getService( ((List<ServiceReference<BrokerMessageInterceptor>>) bundleContext.getServiceReferences( BrokerMessageInterceptor.class, \"(name=subjectInjectorPlugin)\")) .get(0)); } brokerMessageInterceptor.handleMessage(session, tx, message, direct, noAutoCreateQueue); } catch (InvalidSyntaxException e) { LOGGER.error( \"Could retrieve the Subject Injector Plugin, subject will not be correctly applied to the message.\", e); } }", "text": "Is error the right log level here? Seems like warn or even info would be more appropriate.", "function_tokens": ["public", "\u0120void", "\u0120before", "Send", "(", "\u0120Server", "Session", "\u0120session", ",", "\u0120Transaction", "\u0120tx", ",", "\u0120Message", "\u0120message", ",", "\u0120boolean", "\u0120direct", ",", "\u0120boolean", "\u0120no", "Auto", "Create", "Queue", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "bro", "ker", "Message", "Inter", "ceptor", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120Bundle", "Context", "\u0120bundle", "Context", "\u0120=", "\u0120get", "B", "undle", "Context", "();", "\u0120broker", "Message", "Inter", "ceptor", "\u0120=", "\u0120bundle", "Context", ".", "get", "Service", "(", "\u0120((", "List", "<", "Service", "Reference", "<", "Bro", "ker", "Message", "Inter", "ceptor", ">>", ")", "\u0120bundle", "Context", ".", "get", "Service", "References", "(", "\u0120Bro", "ker", "Message", "Inter", "ceptor", ".", "class", ",", "\u0120\"(", "name", "=", "subject", "In", "ject", "or", "Plugin", ")\"", "))", "\u0120.", "get", "(", "0", "));", "\u0120}", "\u0120broker", "Message", "Inter", "ceptor", ".", "handle", "Message", "(", "session", ",", "\u0120tx", ",", "\u0120message", ",", "\u0120direct", ",", "\u0120no", "Auto", "Create", "Queue", ");", "\u0120}", "\u0120catch", "\u0120(", "Invalid", "Sy", "ntax", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(", "\u0120\"", "Could", "\u0120retrieve", "\u0120the", "\u0120Subject", "\u0120In", "ject", "or", "\u0120Plugin", ",", "\u0120subject", "\u0120will", "\u0120not", "\u0120be", "\u0120correctly", "\u0120applied", "\u0120to", "\u0120the", "\u0120message", ".\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Is", "\u0120error", "\u0120the", "\u0120right", "\u0120log", "\u0120level", "\u0120here", "?", "\u0120Seems", "\u0120like", "\u0120warn", "\u0120or", "\u0120even", "\u0120info", "\u0120would", "\u0120be", "\u0120more", "\u0120appropriate", "."]}
{"function": "public void delete() throws IOException, InterruptedException { checkPermission(DELETE); FolderComputation<I> computation = getComputation(); Executor executor = Executor.of(computation); if (executor != null) { LOGGER.log(Level.INFO, \"Interrupting {0} in order to delete it\", this); executor.interrupt(Result.ABORTED, new CauseOfInterruption.UserInterruption(User.current())); long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15); while (executor.isAlive() && executor.getCurrentExecutable() == computation && expiration - System.nanoTime() > 0L) { Thread.sleep(50L); } if (executor.isAlive() && executor.getCurrentExecutable() == computation) { LOGGER.log(Level.WARNING, \"Interrupted {0} in order to delete it, but it has not stopped yet\", this); } } super.delete(); }", "text": "Superfluous check I think-it has been a long time since Executors were reused.", "function_tokens": ["public", "\u0120void", "\u0120delete", "()", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120check", "Per", "mission", "(", "DE", "LE", "TE", ");", "\u0120Folder", "Com", "put", "ation", "<", "I", ">", "\u0120computation", "\u0120=", "\u0120get", "Com", "put", "ation", "();", "\u0120Exec", "utor", "\u0120execut", "or", "\u0120=", "\u0120Exec", "utor", ".", "of", "(", "com", "put", "ation", ");", "\u0120if", "\u0120(", "exec", "utor", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "INFO", ",", "\u0120\"", "Inter", "rupt", "ing", "\u0120{", "0", "}", "\u0120in", "\u0120order", "\u0120to", "\u0120delete", "\u0120it", "\",", "\u0120this", ");", "\u0120execut", "or", ".", "inter", "rupt", "(", "Result", ".", "AB", "ORT", "ED", ",", "\u0120new", "\u0120Cause", "Of", "Inter", "ruption", ".", "User", "Inter", "ruption", "(", "User", ".", "current", "()", "));", "\u0120long", "\u0120expiration", "\u0120=", "\u0120System", ".", "n", "ano", "Time", "()", "\u0120+", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", ".", "to", "N", "anos", "(", "15", ");", "\u0120while", "\u0120(", "exec", "utor", ".", "is", "Al", "ive", "()", "\u0120&&", "\u0120execut", "or", ".", "get", "Current", "Exec", "utable", "()", "\u0120==", "\u0120computation", "\u0120&&", "\u0120expiration", "\u0120-", "\u0120System", ".", "n", "ano", "Time", "()", "\u0120>", "\u01200", "L", ")", "\u0120{", "\u0120Thread", ".", "sleep", "(", "50", "L", ");", "\u0120}", "\u0120if", "\u0120(", "exec", "utor", ".", "is", "Al", "ive", "()", "\u0120&&", "\u0120execut", "or", ".", "get", "Current", "Exec", "utable", "()", "\u0120==", "\u0120computation", ")", "\u0120{", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "WARNING", ",", "\u0120\"", "Inter", "rupted", "\u0120{", "0", "}", "\u0120in", "\u0120order", "\u0120to", "\u0120delete", "\u0120it", ",", "\u0120but", "\u0120it", "\u0120has", "\u0120not", "\u0120stopped", "\u0120yet", "\",", "\u0120this", ");", "\u0120}", "\u0120}", "\u0120super", ".", "delete", "();", "\u0120}"], "docstring_tokens": ["Super", "flu", "ous", "\u0120check", "\u0120I", "\u0120think", "-", "it", "\u0120has", "\u0120been", "\u0120a", "\u0120long", "\u0120time", "\u0120since", "\u0120Exec", "ut", "ors", "\u0120were", "\u0120reused", "."]}
{"function": "private void refreshLocalMessageFlags(final Account account, final Folder remoteFolder, final LocalFolder localFolder, ArrayList<Message> syncFlagMessages, final AtomicInteger progress, final int todo ) throws MessagingException { final String folder = remoteFolder.getName(); if (remoteFolder.supportsFetchingFlags()) { if (K9.DEBUG) Log.d(K9.LOG_TAG, \"SYNC: About to sync flags for \" + syncFlagMessages.size() + \" remote messages for folder \" + folder); FetchProfile fp = new FetchProfile(); fp.add(FetchProfile.Item.FLAGS); List<Message> undeletedMessages = new LinkedList<Message>(); for (Message message : syncFlagMessages) { if (!message.isSet(Flag.DELETED)) { undeletedMessages.add(message); } } remoteFolder.fetch(undeletedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp, null); for (Message remoteMessage : syncFlagMessages) { Message localMessage = localFolder.getMessage(remoteMessage.getUid()); boolean messageChanged = syncFlags(localMessage, remoteMessage); if (messageChanged) { boolean shouldBeNotifiedOf = false; if (localMessage.isSet(Flag.DELETED) || isMessageSuppressed(account, folder, localMessage)) { for (MessagingListener l : getListeners()) { l.synchronizeMailboxRemovedMessage(account, folder, localMessage); } } else { for (MessagingListener l : getListeners()) { l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage); } if (shouldNotifyForMessage(account, localFolder, localMessage)) { shouldBeNotifiedOf = true; } } if (!shouldBeNotifiedOf) { NotificationData data = getNotificationData(account, -1); if (data != null) { synchronized (data) { MessageReference ref = localMessage.makeMessageReference(); if (data.removeMatchingMessage(mApplication, ref)) { notifyAccountWithDataLocked(mApplication, account, null, data); } } } } } progress.incrementAndGet(); for (MessagingListener l : getListeners()) { l.synchronizeMailboxProgress(account, folder, progress.get(), todo); } } } }", "text": "Can you create a constant for the -1? I'm not sure what that represents here.", "function_tokens": ["private", "\u0120void", "\u0120refresh", "Local", "Message", "Flags", "(", "final", "\u0120Account", "\u0120account", ",", "\u0120final", "\u0120Folder", "\u0120remote", "Folder", ",", "\u0120final", "\u0120Local", "Folder", "\u0120local", "Folder", ",", "\u0120Array", "List", "<", "Message", ">", "\u0120sync", "Flag", "Mess", "ages", ",", "\u0120final", "\u0120Atomic", "Integer", "\u0120progress", ",", "\u0120final", "\u0120int", "\u0120to", "do", "\u0120)", "\u0120throws", "\u0120Mess", "aging", "Exception", "\u0120{", "\u0120final", "\u0120String", "\u0120folder", "\u0120=", "\u0120remote", "Folder", ".", "get", "Name", "();", "\u0120if", "\u0120(", "remote", "Folder", ".", "supp", "orts", "F", "etch", "ing", "Flags", "())", "\u0120{", "\u0120if", "\u0120(", "K", "9", ".", "DEBUG", ")", "\u0120Log", ".", "d", "(", "K", "9", ".", "LOG", "_", "TAG", ",", "\u0120\"", "SY", "NC", ":", "\u0120About", "\u0120to", "\u0120sync", "\u0120flags", "\u0120for", "\u0120\"", "\u0120+", "\u0120sync", "Flag", "Mess", "ages", ".", "size", "()", "\u0120+", "\u0120\"", "\u0120remote", "\u0120messages", "\u0120for", "\u0120folder", "\u0120\"", "\u0120+", "\u0120folder", ");", "\u0120F", "etch", "Profile", "\u0120f", "p", "\u0120=", "\u0120new", "\u0120F", "etch", "Profile", "();", "\u0120f", "p", ".", "add", "(", "F", "etch", "Profile", ".", "Item", ".", "FLAG", "S", ");", "\u0120List", "<", "Message", ">", "\u0120und", "ele", "ted", "Mess", "ages", "\u0120=", "\u0120new", "\u0120Link", "ed", "List", "<", "Message", ">", "();", "\u0120for", "\u0120(", "Message", "\u0120message", "\u0120:", "\u0120sync", "Flag", "Mess", "ages", ")", "\u0120{", "\u0120if", "\u0120(!", "message", ".", "is", "Set", "(", "Flag", ".", "DE", "LET", "ED", "))", "\u0120{", "\u0120und", "ele", "ted", "Mess", "ages", ".", "add", "(", "message", ");", "\u0120}", "\u0120}", "\u0120remote", "Folder", ".", "f", "etch", "(", "und", "ele", "ted", "Mess", "ages", ".", "to", "Array", "(", "EMP", "TY", "_", "M", "ES", "SA", "GE", "_", "AR", "RAY", "),", "\u0120f", "p", ",", "\u0120null", ");", "\u0120for", "\u0120(", "Message", "\u0120remote", "Message", "\u0120:", "\u0120sync", "Flag", "Mess", "ages", ")", "\u0120{", "\u0120Message", "\u0120local", "Message", "\u0120=", "\u0120local", "Folder", ".", "get", "Message", "(", "remote", "Message", ".", "get", "U", "id", "());", "\u0120boolean", "\u0120message", "Changed", "\u0120=", "\u0120sync", "Flags", "(", "local", "Message", ",", "\u0120remote", "Message", ");", "\u0120if", "\u0120(", "message", "Changed", ")", "\u0120{", "\u0120boolean", "\u0120should", "Be", "Not", "ified", "Of", "\u0120=", "\u0120false", ";", "\u0120if", "\u0120(", "local", "Message", ".", "is", "Set", "(", "Flag", ".", "DE", "LET", "ED", ")", "\u0120||", "\u0120is", "Message", "Supp", "ressed", "(", "account", ",", "\u0120folder", ",", "\u0120local", "Message", "))", "\u0120{", "\u0120for", "\u0120(", "Mess", "aging", "Listener", "\u0120l", "\u0120:", "\u0120get", "Listen", "ers", "())", "\u0120{", "\u0120l", ".", "syn", "chron", "ize", "Mail", "box", "Removed", "Message", "(", "account", ",", "\u0120folder", ",", "\u0120local", "Message", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120for", "\u0120(", "Mess", "aging", "Listener", "\u0120l", "\u0120:", "\u0120get", "Listen", "ers", "())", "\u0120{", "\u0120l", ".", "syn", "chron", "ize", "Mail", "box", "Add", "Or", "Update", "Message", "(", "account", ",", "\u0120folder", ",", "\u0120local", "Message", ");", "\u0120}", "\u0120if", "\u0120(", "should", "Not", "ify", "For", "Message", "(", "account", ",", "\u0120local", "Folder", ",", "\u0120local", "Message", "))", "\u0120{", "\u0120should", "Be", "Not", "ified", "Of", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "should", "Be", "Not", "ified", "Of", ")", "\u0120{", "\u0120Notification", "Data", "\u0120data", "\u0120=", "\u0120get", "Not", "ification", "Data", "(", "account", ",", "\u0120-", "1", ");", "\u0120if", "\u0120(", "data", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120synchronized", "\u0120(", "data", ")", "\u0120{", "\u0120Message", "Reference", "\u0120ref", "\u0120=", "\u0120local", "Message", ".", "make", "Message", "Reference", "();", "\u0120if", "\u0120(", "data", ".", "remove", "M", "atching", "Message", "(", "m", "Application", ",", "\u0120ref", "))", "\u0120{", "\u0120notify", "Account", "With", "Data", "L", "ocked", "(", "m", "Application", ",", "\u0120account", ",", "\u0120null", ",", "\u0120data", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120progress", ".", "incre", "ment", "And", "Get", "();", "\u0120for", "\u0120(", "Mess", "aging", "Listener", "\u0120l", "\u0120:", "\u0120get", "Listen", "ers", "())", "\u0120{", "\u0120l", ".", "syn", "chron", "ize", "Mail", "box", "Progress", "(", "account", ",", "\u0120folder", ",", "\u0120progress", ".", "get", "(),", "\u0120to", "do", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Can", "\u0120you", "\u0120create", "\u0120a", "\u0120constant", "\u0120for", "\u0120the", "\u0120-", "1", "?", "\u0120I", "'m", "\u0120not", "\u0120sure", "\u0120what", "\u0120that", "\u0120represents", "\u0120here", "."]}
{"function": "public InputStream getObject(String bucketName, String objectName, long offset, Long length) throws InvalidBucketNameException, NoSuchAlgorithmException, InsufficientDataException, IOException, InvalidKeyException, NoResponseException, XmlPullParserException, ErrorResponseException, InternalException, InvalidArgumentException { if (offset < 0) { throw new InvalidArgumentException(\"offset should be zero or greater\"); } if (length != null && length <= 0) { throw new InvalidArgumentException(\"length should be greater than zero\"); } if ((bucketName == null) || (bucketName.isEmpty())) { throw new InvalidArgumentException(\"bucket name cannot be empty\"); } if ((objectName == null) || (objectName.isEmpty())) { throw new InvalidArgumentException(\"object name cannot be empty\"); } Map<String,String> headerMap = new HashMap<>(); if (offset > 0) { if (length != null) { headerMap.put(\"Range\", \"bytes=\" + offset + \"-\" + (offset + length - 1)); } else { headerMap.put(\"Range\", \"bytes=\" + offset + \"-\"); } } HttpResponse response = executeGet(bucketName, objectName, headerMap, null); return response.body().byteStream(); }", "text": "Do this validation first. See the order of method arguments.", "function_tokens": ["public", "\u0120Input", "Stream", "\u0120get", "Object", "(", "String", "\u0120bucket", "Name", ",", "\u0120String", "\u0120object", "Name", ",", "\u0120long", "\u0120offset", ",", "\u0120Long", "\u0120length", ")", "\u0120throws", "\u0120Invalid", "B", "ucket", "Name", "Exception", ",", "\u0120No", "Such", "Al", "gorithm", "Exception", ",", "\u0120Ins", "ufficient", "Data", "Exception", ",", "\u0120IO", "Exception", ",", "\u0120Invalid", "Key", "Exception", ",", "\u0120No", "Response", "Exception", ",", "\u0120X", "ml", "Pull", "Parser", "Exception", ",", "\u0120Error", "Response", "Exception", ",", "\u0120Internal", "Exception", ",", "\u0120Invalid", "Arg", "ument", "Exception", "\u0120{", "\u0120if", "\u0120(", "offset", "\u0120<", "\u01200", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Invalid", "Arg", "ument", "Exception", "(\"", "offset", "\u0120should", "\u0120be", "\u0120zero", "\u0120or", "\u0120greater", "\");", "\u0120}", "\u0120if", "\u0120(", "length", "\u0120!=", "\u0120null", "\u0120&&", "\u0120length", "\u0120<=", "\u01200", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Invalid", "Arg", "ument", "Exception", "(\"", "length", "\u0120should", "\u0120be", "\u0120greater", "\u0120than", "\u0120zero", "\");", "\u0120}", "\u0120if", "\u0120((", "buck", "et", "Name", "\u0120==", "\u0120null", ")", "\u0120||", "\u0120(", "buck", "et", "Name", ".", "is", "Empty", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Invalid", "Arg", "ument", "Exception", "(\"", "buck", "et", "\u0120name", "\u0120cannot", "\u0120be", "\u0120empty", "\");", "\u0120}", "\u0120if", "\u0120((", "object", "Name", "\u0120==", "\u0120null", ")", "\u0120||", "\u0120(", "object", "Name", ".", "is", "Empty", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Invalid", "Arg", "ument", "Exception", "(\"", "object", "\u0120name", "\u0120cannot", "\u0120be", "\u0120empty", "\");", "\u0120}", "\u0120Map", "<", "String", ",", "String", ">", "\u0120header", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120if", "\u0120(", "offset", "\u0120>", "\u01200", ")", "\u0120{", "\u0120if", "\u0120(", "length", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120header", "Map", ".", "put", "(\"", "Range", "\",", "\u0120\"", "bytes", "=\"", "\u0120+", "\u0120offset", "\u0120+", "\u0120\"", "-\"", "\u0120+", "\u0120(", "offset", "\u0120+", "\u0120length", "\u0120-", "\u01201", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120header", "Map", ".", "put", "(\"", "Range", "\",", "\u0120\"", "bytes", "=\"", "\u0120+", "\u0120offset", "\u0120+", "\u0120\"-", "\");", "\u0120}", "\u0120}", "\u0120H", "ttp", "Response", "\u0120response", "\u0120=", "\u0120execute", "Get", "(", "buck", "et", "Name", ",", "\u0120object", "Name", ",", "\u0120header", "Map", ",", "\u0120null", ");", "\u0120return", "\u0120response", ".", "body", "().", "byte", "Stream", "();", "\u0120}"], "docstring_tokens": ["Do", "\u0120this", "\u0120validation", "\u0120first", ".", "\u0120See", "\u0120the", "\u0120order", "\u0120of", "\u0120method", "\u0120arguments", "."]}
{"function": "public static FileUtils.FileCopyResult unzip( final ByteSource byteSource, final File outDir, boolean cacheLocally ) throws IOException { return unzip(byteSource, outDir, Predicates.<Throwable>alwaysTrue(), cacheLocally); }", "text": "I think that by default we should retry on Exceptions but not on other kinds of Throwables.", "function_tokens": ["public", "\u0120static", "\u0120File", "Ut", "ils", ".", "File", "Copy", "Result", "\u0120un", "zip", "(", "\u0120final", "\u0120Byte", "Source", "\u0120byte", "Source", ",", "\u0120final", "\u0120File", "\u0120out", "Dir", ",", "\u0120boolean", "\u0120cache", "Loc", "ally", "\u0120)", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120return", "\u0120un", "zip", "(", "byte", "Source", ",", "\u0120out", "Dir", ",", "\u0120Pred", "icates", ".<", "Throw", "able", ">", "always", "True", "(),", "\u0120cache", "Loc", "ally", ");", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120that", "\u0120by", "\u0120default", "\u0120we", "\u0120should", "\u0120ret", "ry", "\u0120on", "\u0120Ex", "ceptions", "\u0120but", "\u0120not", "\u0120on", "\u0120other", "\u0120kinds", "\u0120of", "\u0120Throw", "ables", "."]}
{"function": "public PrologEnvironment newPrologEnvironment() throws CompileException { PrologEnvironment env; if(urlLoader != null) { env = envFactory.create(urlLoader); return env; } else { env = envFactory.create(getClass().getClassLoader()); } String rules = getConfig().getPrologRules(); if (rules != null) { PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE); JavaObjectTerm streamObject = new JavaObjectTerm(in); if (!env.execute(Prolog.BUILTIN, \"consult_stream\", SymbolTerm.intern(\"rules.pl\"), streamObject)) { throw new CompileException(\"Cannot consult rules.pl \" + getProject().getName() + \" \" + getConfig().getRevision()); } } return env; }", "text": "Style-nit: Unnecessary blank line.", "function_tokens": ["public", "\u0120Pro", "log", "Environment", "\u0120new", "Pro", "log", "Environment", "()", "\u0120throws", "\u0120Comp", "ile", "Exception", "\u0120{", "\u0120Pro", "log", "Environment", "\u0120env", ";", "\u0120if", "(", "url", "Loader", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120env", "\u0120=", "\u0120env", "Factory", ".", "create", "(", "url", "Loader", ");", "\u0120return", "\u0120env", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120env", "\u0120=", "\u0120env", "Factory", ".", "create", "(", "get", "Class", "().", "get", "Class", "Loader", "());", "\u0120}", "\u0120String", "\u0120rules", "\u0120=", "\u0120get", "Config", "().", "get", "Pro", "log", "Rules", "();", "\u0120if", "\u0120(", "rules", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Push", "back", "Reader", "\u0120in", "\u0120=", "\u0120new", "\u0120Push", "back", "Reader", "(", "new", "\u0120String", "Reader", "(", "rules", "),", "\u0120Pro", "log", ".", "P", "USH", "BACK", "_", "SIZE", ");", "\u0120Java", "Object", "Term", "\u0120stream", "Object", "\u0120=", "\u0120new", "\u0120Java", "Object", "Term", "(", "in", ");", "\u0120if", "\u0120(!", "env", ".", "execute", "(", "Pro", "log", ".", "BU", "IL", "T", "IN", ",", "\u0120\"", "cons", "ult", "_", "stream", "\",", "\u0120Symbol", "Term", ".", "intern", "(\"", "rules", ".", "pl", "\"),", "\u0120stream", "Object", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Comp", "ile", "Exception", "(\"", "C", "annot", "\u0120consult", "\u0120rules", ".", "pl", "\u0120\"", "\u0120+", "\u0120get", "Project", "().", "get", "Name", "()", "\u0120+", "\u0120\"", "\u0120\"", "\u0120+", "\u0120get", "Config", "().", "get", "Rev", "ision", "());", "\u0120}", "\u0120}", "\u0120return", "\u0120env", ";", "\u0120}"], "docstring_tokens": ["Style", "-", "nit", ":", "\u0120Un", "necessary", "\u0120blank", "\u0120line", "."]}
{"function": "public void scheduleTask(TaskDefinition task) throws SchedulerException { if (!Context.getSchedulerService().getTaskByName(task.getName()).getStarted()) { Context.getSchedulerService().scheduleTask(task); } }", "text": "After taking a second look, i think we do not need this call at all. All those check of ensure that a service is not started before schedule, etc, belong to the service layer API. Your role is to simply call Context.getSchedulerService().scheduleTask(task) and that is all.", "function_tokens": ["public", "\u0120void", "\u0120schedule", "Task", "(", "Task", "Definition", "\u0120task", ")", "\u0120throws", "\u0120Sched", "uler", "Exception", "\u0120{", "\u0120if", "\u0120(!", "Context", ".", "get", "S", "ched", "uler", "Service", "().", "get", "Task", "By", "Name", "(", "task", ".", "get", "Name", "()", ").", "get", "Start", "ed", "())", "\u0120{", "\u0120Context", ".", "get", "S", "ched", "uler", "Service", "().", "sche", "dule", "Task", "(", "task", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["After", "\u0120taking", "\u0120a", "\u0120second", "\u0120look", ",", "\u0120i", "\u0120think", "\u0120we", "\u0120do", "\u0120not", "\u0120need", "\u0120this", "\u0120call", "\u0120at", "\u0120all", ".", "\u0120All", "\u0120those", "\u0120check", "\u0120of", "\u0120ensure", "\u0120that", "\u0120a", "\u0120service", "\u0120is", "\u0120not", "\u0120started", "\u0120before", "\u0120schedule", ",", "\u0120etc", ",", "\u0120belong", "\u0120to", "\u0120the", "\u0120service", "\u0120layer", "\u0120API", ".", "\u0120Your", "\u0120role", "\u0120is", "\u0120to", "\u0120simply", "\u0120call", "\u0120Context", ".", "get", "S", "ched", "uler", "Service", "().", "sche", "dule", "Task", "(", "task", ")", "\u0120and", "\u0120that", "\u0120is", "\u0120all", "."]}
{"function": "protected ImmutableList<PubsubMessage> sendBatch(final List<PubsubMessage> batch) throws InterruptedException { final int batchSize = batch.size(); final List<ApiFuture<String>> sendResults = batch.stream() .map(publisher::publish) .collect(Collectors.toCollection(() -> new ArrayList<>(batchSize))); final ImmutableList.Builder<PubsubMessage> remaining = ImmutableList.builder(); for (int i = 0; i < batchSize; ++i) { final ApiFuture<String> pendingResult = sendResults.get(i); try { final String messageId = pendingResult.get(); if (logger.isDebugEnabled()) { final PubsubMessage message = batch.get(i); logger.debug(\"Finished sending event (partyId={}, eventId={}) to Pub/Sub: messageId = {}\", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), messageId); } } catch (final ExecutionException e) { final PubsubMessage message = batch.get(i); final Throwable cause = e.getCause(); if (cause instanceof ApiException) { final ApiException apiException = (ApiException) cause; if (apiException.isRetryable()) { logger.debug(\"Transient error sending event (partyId={}, eventId={}) to Pub/Sub; retrying.\", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); remaining.add(message); } else { logger.warn(\"Permanent error sending event (partyId={}, eventId={}) to Pub/Sub; abandoning.\", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); } } else { logger.error(\"Unknown error sending event (partyId={}, eventId={}) to Pub/Sub; abandoning.\", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); } } } return remaining.build(); }", "text": "debug logging should not change the applicationflow. getAttributesOrThrow would. getAttributesOrDefault is better I think", "function_tokens": ["protected", "\u0120Imm", "utable", "List", "<", "Pub", "sub", "Message", ">", "\u0120send", "B", "atch", "(", "final", "\u0120List", "<", "Pub", "sub", "Message", ">", "\u0120batch", ")", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120final", "\u0120int", "\u0120batch", "Size", "\u0120=", "\u0120batch", ".", "size", "();", "\u0120final", "\u0120List", "<", "A", "pi", "Future", "<", "String", ">>", "\u0120send", "Results", "\u0120=", "\u0120batch", ".", "stream", "()", "\u0120.", "map", "(", "pub", "lisher", "::", "pub", "lish", ")", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "Collection", "(", "()", "\u0120->", "\u0120new", "\u0120Array", "List", "<", ">(", "batch", "Size", "))", ");", "\u0120final", "\u0120Imm", "utable", "List", ".", "Builder", "<", "Pub", "sub", "Message", ">", "\u0120remaining", "\u0120=", "\u0120Imm", "utable", "List", ".", "builder", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120batch", "Size", ";", "\u0120++", "i", ")", "\u0120{", "\u0120final", "\u0120Ap", "i", "Future", "<", "String", ">", "\u0120pending", "Result", "\u0120=", "\u0120send", "Results", ".", "get", "(", "i", ");", "\u0120try", "\u0120{", "\u0120final", "\u0120String", "\u0120message", "Id", "\u0120=", "\u0120pending", "Result", ".", "get", "();", "\u0120if", "\u0120(", "log", "ger", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120final", "\u0120Pub", "sub", "Message", "\u0120message", "\u0120=", "\u0120batch", ".", "get", "(", "i", ");", "\u0120logger", ".", "debug", "(\"", "Fin", "ished", "\u0120sending", "\u0120event", "\u0120(", "party", "Id", "={", "},", "\u0120event", "Id", "={", "})", "\u0120to", "\u0120Pub", "/", "Sub", ":", "\u0120message", "Id", "\u0120=", "\u0120{}", "\",", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "PART", "Y", "ID", "),", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "EV", "ENT", "ID", "),", "\u0120message", "Id", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Execution", "Exception", "\u0120e", ")", "\u0120{", "\u0120final", "\u0120Pub", "sub", "Message", "\u0120message", "\u0120=", "\u0120batch", ".", "get", "(", "i", ");", "\u0120final", "\u0120Throw", "able", "\u0120cause", "\u0120=", "\u0120e", ".", "get", "Cause", "();", "\u0120if", "\u0120(", "cause", "\u0120instance", "of", "\u0120Ap", "i", "Exception", ")", "\u0120{", "\u0120final", "\u0120Ap", "i", "Exception", "\u0120api", "Exception", "\u0120=", "\u0120(", "A", "pi", "Exception", ")", "\u0120cause", ";", "\u0120if", "\u0120(", "api", "Exception", ".", "is", "Ret", "ry", "able", "())", "\u0120{", "\u0120logger", ".", "debug", "(\"", "Trans", "ient", "\u0120error", "\u0120sending", "\u0120event", "\u0120(", "party", "Id", "={", "},", "\u0120event", "Id", "={", "})", "\u0120to", "\u0120Pub", "/", "Sub", ";", "\u0120ret", "rying", ".\",", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "PART", "Y", "ID", "),", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "EV", "ENT", "ID", "),", "\u0120cause", ");", "\u0120remaining", ".", "add", "(", "message", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120logger", ".", "warn", "(\"", "P", "ermanent", "\u0120error", "\u0120sending", "\u0120event", "\u0120(", "party", "Id", "={", "},", "\u0120event", "Id", "={", "})", "\u0120to", "\u0120Pub", "/", "Sub", ";", "\u0120abandoning", ".\",", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "PART", "Y", "ID", "),", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "EV", "ENT", "ID", "),", "\u0120cause", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120logger", ".", "error", "(\"", "Unknown", "\u0120error", "\u0120sending", "\u0120event", "\u0120(", "party", "Id", "={", "},", "\u0120event", "Id", "={", "})", "\u0120to", "\u0120Pub", "/", "Sub", ";", "\u0120abandoning", ".\",", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "PART", "Y", "ID", "),", "\u0120message", ".", "get", "Attributes", "Or", "Throw", "(", "M", "ES", "SA", "GE", "_", "AT", "TR", "IB", "UTE", "_", "EV", "ENT", "ID", "),", "\u0120cause", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120remaining", ".", "build", "();", "\u0120}"], "docstring_tokens": ["debug", "\u0120logging", "\u0120should", "\u0120not", "\u0120change", "\u0120the", "\u0120application", "flow", ".", "\u0120get", "Attributes", "Or", "Throw", "\u0120would", ".", "\u0120get", "Attributes", "Or", "Default", "\u0120is", "\u0120better", "\u0120I", "\u0120think"]}
{"function": "public String validate(String parameterValue, ModelValidatorContext context) throws ValidationException { try { if (!isValidJSON(parameterValue)) { throw new ValidationException(\"Expected value should match JSON format, received \" + parameterValue); } } catch (ValidationException er) { throw new ValidationException(\"Validator error from JsonParser: Expected value should match JSON format, received \" + parameterValue); } return parameterValue; }", "text": "I think this part should be improved. isValidJSON returns a boolean and also throws a ValidationException. You should rather decide on a single strategy, either return true false or return void and throw an exception. I prefer the latter, as an exception contains more meaningful error messages than true/false. In that case the method should be renamed checkValidJson", "function_tokens": ["public", "\u0120String", "\u0120validate", "(", "String", "\u0120parameter", "Value", ",", "\u0120Model", "Valid", "ator", "Context", "\u0120context", ")", "\u0120throws", "\u0120Val", "idation", "Exception", "\u0120{", "\u0120try", "\u0120{", "\u0120if", "\u0120(!", "is", "Valid", "JSON", "(", "param", "eter", "Value", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Val", "idation", "Exception", "(\"", "Ex", "pected", "\u0120value", "\u0120should", "\u0120match", "\u0120JSON", "\u0120format", ",", "\u0120received", "\u0120\"", "\u0120+", "\u0120parameter", "Value", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Val", "idation", "Exception", "\u0120er", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Val", "idation", "Exception", "(\"", "Valid", "ator", "\u0120error", "\u0120from", "\u0120J", "son", "Parser", ":", "\u0120Ex", "pected", "\u0120value", "\u0120should", "\u0120match", "\u0120JSON", "\u0120format", ",", "\u0120received", "\u0120\"", "\u0120+", "\u0120parameter", "Value", ");", "\u0120}", "\u0120return", "\u0120parameter", "Value", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120this", "\u0120part", "\u0120should", "\u0120be", "\u0120improved", ".", "\u0120is", "Valid", "JSON", "\u0120returns", "\u0120a", "\u0120boolean", "\u0120and", "\u0120also", "\u0120throws", "\u0120a", "\u0120Val", "idation", "Exception", ".", "\u0120You", "\u0120should", "\u0120rather", "\u0120decide", "\u0120on", "\u0120a", "\u0120single", "\u0120strategy", ",", "\u0120either", "\u0120return", "\u0120true", "\u0120false", "\u0120or", "\u0120return", "\u0120void", "\u0120and", "\u0120throw", "\u0120an", "\u0120exception", ".", "\u0120I", "\u0120prefer", "\u0120the", "\u0120latter", ",", "\u0120as", "\u0120an", "\u0120exception", "\u0120contains", "\u0120more", "\u0120meaningful", "\u0120error", "\u0120messages", "\u0120than", "\u0120true", "/", "false", ".", "\u0120In", "\u0120that", "\u0120case", "\u0120the", "\u0120method", "\u0120should", "\u0120be", "\u0120renamed", "\u0120check", "Valid", "J", "son"]}
{"function": "public void getVersion() throws Exception { String version = gApi.config().server().getVersion(); Truth.assertThat(version).is(Version.getVersion()); }", "text": "Can be inlined in the assertThat statement below.", "function_tokens": ["public", "\u0120void", "\u0120get", "Version", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120String", "\u0120version", "\u0120=", "\u0120g", "A", "pi", ".", "config", "().", "server", "().", "get", "Version", "();", "\u0120Truth", ".", "assert", "That", "(", "version", ").", "is", "(", "Version", ".", "get", "Version", "());", "\u0120}"], "docstring_tokens": ["Can", "\u0120be", "\u0120in", "lined", "\u0120in", "\u0120the", "\u0120assert", "That", "\u0120statement", "\u0120below", "."]}
{"function": "public HttpRequest filter(HttpRequest request) throws HttpException { Credentials currentCreds = checkNotNull(creds.get(), \"credential supplier returned null\"); Signer signer = Signer.getSigner(); String signature; Multimap<String, String> decodedParams = queryParser().apply(request.getEndpoint().getRawQuery()); SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"); df.setTimeZone(new SimpleTimeZone(0, \"GMT\")); String timestamp = df.format(new Date()); String signatureNonce = UUID.randomUUID().toString(); decodedParams.put(\"AccessKeyId\", currentCreds.identity); decodedParams.put(\"Timestamp\", timestamp); decodedParams.put(\"SignatureNonce\", signatureNonce); String prefix; try { prefix = request.getMethod() + SEPARATOR + AcsURLEncoder.percentEncode(\"/\") + SEPARATOR; } catch (UnsupportedEncodingException e) { throw Throwables.propagate(e); } String stringToSign = prefix; ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder(); for (Map.Entry<String, String> entry : decodedParams.entries()) builder.add(Strings2.urlEncode(entry.getKey()) + \"=\" + Strings2.urlEncode(entry.getValue())); stringToSign += Strings2.urlEncode(Joiner.on(\"&\").join(builder.build())); signature = signer.signString(stringToSign, currentCreds.credential + \"&\"); decodedParams.put(\"Signature\", signature); request = request.toBuilder().endpoint(uriBuilder(request.getEndpoint()).query(decodedParams).build()).build(); return request; }", "text": "If you use the jclouds Uris and UriBuilder classes I think you don't have to worry about manually encoding the parameters.", "function_tokens": ["public", "\u0120H", "ttp", "Request", "\u0120filter", "(", "Http", "Request", "\u0120request", ")", "\u0120throws", "\u0120H", "ttp", "Exception", "\u0120{", "\u0120C", "red", "entials", "\u0120current", "C", "red", "s", "\u0120=", "\u0120check", "Not", "Null", "(", "c", "red", "s", ".", "get", "(),", "\u0120\"", "c", "red", "ential", "\u0120supplier", "\u0120returned", "\u0120null", "\");", "\u0120Sign", "er", "\u0120sign", "er", "\u0120=", "\u0120Sign", "er", ".", "get", "Sign", "er", "();", "\u0120String", "\u0120signature", ";", "\u0120Mult", "im", "ap", "<", "String", ",", "\u0120String", ">", "\u0120dec", "oded", "Par", "ams", "\u0120=", "\u0120query", "Parser", "().", "apply", "(", "request", ".", "get", "End", "point", "().", "get", "Raw", "Query", "());", "\u0120Simple", "Date", "Format", "\u0120df", "\u0120=", "\u0120new", "\u0120Simple", "Date", "Format", "(\"", "yy", "yy", "-", "MM", "-", "dd", "'", "T", "'", "HH", ":", "mm", ":", "ss", "'", "Z", "'", "\");", "\u0120df", ".", "set", "Time", "Zone", "(", "new", "\u0120Simple", "Time", "Zone", "(", "0", ",", "\u0120\"", "GMT", "\")", ");", "\u0120String", "\u0120timestamp", "\u0120=", "\u0120df", ".", "format", "(", "new", "\u0120Date", "());", "\u0120String", "\u0120signature", "Non", "ce", "\u0120=", "\u0120U", "UID", ".", "random", "U", "UID", "().", "to", "String", "();", "\u0120dec", "oded", "Par", "ams", ".", "put", "(\"", "Access", "Key", "Id", "\",", "\u0120current", "C", "red", "s", ".", "ident", "ity", ");", "\u0120dec", "oded", "Par", "ams", ".", "put", "(\"", "Tim", "estamp", "\",", "\u0120timestamp", ");", "\u0120dec", "oded", "Par", "ams", ".", "put", "(\"", "Sign", "ature", "Non", "ce", "\",", "\u0120signature", "Non", "ce", ");", "\u0120String", "\u0120prefix", ";", "\u0120try", "\u0120{", "\u0120prefix", "\u0120=", "\u0120request", ".", "get", "Method", "()", "\u0120+", "\u0120SE", "PAR", "ATOR", "\u0120+", "\u0120Ac", "s", "UR", "LE", "nc", "oder", ".", "percent", "En", "code", "(\"", "/", "\")", "\u0120+", "\u0120SE", "PAR", "ATOR", ";", "\u0120}", "\u0120catch", "\u0120(", "Un", "supported", "Enc", "oding", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120Throw", "ables", ".", "prop", "agate", "(", "e", ");", "\u0120}", "\u0120String", "\u0120string", "To", "Sign", "\u0120=", "\u0120prefix", ";", "\u0120Imm", "utable", "S", "orted", "Set", ".", "Builder", "<", "String", ">", "\u0120builder", "\u0120=", "\u0120Imm", "utable", "S", "orted", "Set", ".", "natural", "Order", "();", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120String", ">", "\u0120entry", "\u0120:", "\u0120dec", "oded", "Par", "ams", ".", "ent", "ries", "())", "\u0120builder", ".", "add", "(", "Str", "ings", "2", ".", "url", "En", "code", "(", "entry", ".", "get", "Key", "())", "\u0120+", "\u0120\"", "=\"", "\u0120+", "\u0120Str", "ings", "2", ".", "url", "En", "code", "(", "entry", ".", "get", "Value", "()", "));", "\u0120string", "To", "Sign", "\u0120+=", "\u0120Str", "ings", "2", ".", "url", "En", "code", "(", "Jo", "iner", ".", "on", "(\"", "&", "\").", "join", "(", "builder", ".", "build", "()", "));", "\u0120signature", "\u0120=", "\u0120sign", "er", ".", "sign", "String", "(", "string", "To", "Sign", ",", "\u0120current", "C", "red", "s", ".", "c", "red", "ential", "\u0120+", "\u0120\"", "&", "\");", "\u0120dec", "oded", "Par", "ams", ".", "put", "(\"", "Sign", "ature", "\",", "\u0120signature", ");", "\u0120request", "\u0120=", "\u0120request", ".", "to", "Builder", "().", "end", "point", "(", "uri", "Builder", "(", "request", ".", "get", "End", "point", "()", ").", "query", "(", "dec", "oded", "Par", "ams", ").", "build", "()", ").", "build", "();", "\u0120return", "\u0120request", ";", "\u0120}"], "docstring_tokens": ["If", "\u0120you", "\u0120use", "\u0120the", "\u0120j", "cloud", "s", "\u0120U", "ris", "\u0120and", "\u0120Uri", "Builder", "\u0120classes", "\u0120I", "\u0120think", "\u0120you", "\u0120don", "'t", "\u0120have", "\u0120to", "\u0120worry", "\u0120about", "\u0120manually", "\u0120encoding", "\u0120the", "\u0120parameters", "."]}
{"function": "public void beforeDocumentChange(DocumentEvent event) { Document document = event.getDocument(); SPath path = editorManager.getEditorPool().getFile(document); if (path == null) { VirtualFile virtualFile = FileDocumentManager.getInstance() .getFile(document); if (virtualFile == null) { LOG.debug(\"Ignoring event for document \" + document + \" - document is not known to the editor pool and a \" + \"VirtualFile for the document could not be found\"); return; } path = virtualFileConverter.convertToPath(virtualFile); if (path == null) { LOG.debug(\"Ignoring event for document \" + document + \" - document is not known to the editor pool and an \" + \"SPath for the document could not be found\"); return; } else if (!editorManager.getSession() .isShared(path.getResource())) { LOG.debug(\"Ignoring Event for document \" + document + \" - document is not shared\"); return; } } String newText = event.getNewFragment().toString(); String replacedText = event.getOldFragment().toString(); editorManager .generateTextEdit(event.getOffset(), newText, replacedText, path); }", "text": "Are you tracking all files in the IDE ? If yes this could flood the log file a little bit depending on your sharing setup, e.g you do a partial sharing with only a few files.", "function_tokens": ["public", "\u0120void", "\u0120before", "Document", "Change", "(", "Document", "Event", "\u0120event", ")", "\u0120{", "\u0120Document", "\u0120document", "\u0120=", "\u0120event", ".", "get", "Document", "();", "\u0120SP", "ath", "\u0120path", "\u0120=", "\u0120editor", "Manager", ".", "get", "Editor", "Pool", "().", "get", "File", "(", "document", ");", "\u0120if", "\u0120(", "path", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120Virtual", "File", "\u0120virtual", "File", "\u0120=", "\u0120File", "Document", "Manager", ".", "get", "Instance", "()", "\u0120.", "get", "File", "(", "document", ");", "\u0120if", "\u0120(", "virtual", "File", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Ign", "oring", "\u0120event", "\u0120for", "\u0120document", "\u0120\"", "\u0120+", "\u0120document", "\u0120+", "\u0120\"", "\u0120-", "\u0120document", "\u0120is", "\u0120not", "\u0120known", "\u0120to", "\u0120the", "\u0120editor", "\u0120pool", "\u0120and", "\u0120a", "\u0120\"", "\u0120+", "\u0120\"", "Virtual", "File", "\u0120for", "\u0120the", "\u0120document", "\u0120could", "\u0120not", "\u0120be", "\u0120found", "\");", "\u0120return", ";", "\u0120}", "\u0120path", "\u0120=", "\u0120virtual", "File", "Con", "ver", "ter", ".", "con", "vert", "To", "Path", "(", "virtual", "File", ");", "\u0120if", "\u0120(", "path", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Ign", "oring", "\u0120event", "\u0120for", "\u0120document", "\u0120\"", "\u0120+", "\u0120document", "\u0120+", "\u0120\"", "\u0120-", "\u0120document", "\u0120is", "\u0120not", "\u0120known", "\u0120to", "\u0120the", "\u0120editor", "\u0120pool", "\u0120and", "\u0120an", "\u0120\"", "\u0120+", "\u0120\"", "SP", "ath", "\u0120for", "\u0120the", "\u0120document", "\u0120could", "\u0120not", "\u0120be", "\u0120found", "\");", "\u0120return", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(!", "editor", "Manager", ".", "get", "Session", "()", "\u0120.", "is", "Sh", "ared", "(", "path", ".", "get", "Resource", "()", "))", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Ign", "oring", "\u0120Event", "\u0120for", "\u0120document", "\u0120\"", "\u0120+", "\u0120document", "\u0120+", "\u0120\"", "\u0120-", "\u0120document", "\u0120is", "\u0120not", "\u0120shared", "\");", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120String", "\u0120new", "Text", "\u0120=", "\u0120event", ".", "get", "New", "Frag", "ment", "().", "to", "String", "();", "\u0120String", "\u0120replaced", "Text", "\u0120=", "\u0120event", ".", "get", "Old", "Frag", "ment", "().", "to", "String", "();", "\u0120editor", "Manager", "\u0120.", "gener", "ate", "Text", "Edit", "(", "event", ".", "get", "Offset", "(),", "\u0120new", "Text", ",", "\u0120replaced", "Text", ",", "\u0120path", ");", "\u0120}"], "docstring_tokens": ["Are", "\u0120you", "\u0120tracking", "\u0120all", "\u0120files", "\u0120in", "\u0120the", "\u0120IDE", "\u0120?", "\u0120If", "\u0120yes", "\u0120this", "\u0120could", "\u0120flood", "\u0120the", "\u0120log", "\u0120file", "\u0120a", "\u0120little", "\u0120bit", "\u0120depending", "\u0120on", "\u0120your", "\u0120sharing", "\u0120setup", ",", "\u0120e", ".", "g", "\u0120you", "\u0120do", "\u0120a", "\u0120partial", "\u0120sharing", "\u0120with", "\u0120only", "\u0120a", "\u0120few", "\u0120files", "."]}
{"function": "private void initialize() { Assert.isNotNull(scope, \"Task scope should not be null.\"); events.addAll(manager.getEvents(scope)); try { ReviewTaskProvider reviewTaskProvider = new ReviewTaskProvider(); reviewTaskProvider.open(manager); reviewTaskProvider.query(scope, null); } catch (CoreException e) { System.out.println(e); } events.addAll(manager.getEvents(scope)); }", "text": "the constructor already asserts that", "function_tokens": ["private", "\u0120void", "\u0120initialize", "()", "\u0120{", "\u0120Ass", "ert", ".", "is", "Not", "Null", "(", "scope", ",", "\u0120\"", "Task", "\u0120scope", "\u0120should", "\u0120not", "\u0120be", "\u0120null", ".\"", ");", "\u0120events", ".", "add", "All", "(", "manager", ".", "get", "Events", "(", "scope", "));", "\u0120try", "\u0120{", "\u0120Review", "Task", "Provider", "\u0120review", "Task", "Provider", "\u0120=", "\u0120new", "\u0120Review", "Task", "Provider", "();", "\u0120review", "Task", "Provider", ".", "open", "(", "manager", ");", "\u0120review", "Task", "Provider", ".", "query", "(", "scope", ",", "\u0120null", ");", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120System", ".", "out", ".", "println", "(", "e", ");", "\u0120}", "\u0120events", ".", "add", "All", "(", "manager", ".", "get", "Events", "(", "scope", "));", "\u0120}"], "docstring_tokens": ["the", "\u0120constructor", "\u0120already", "\u0120asserts", "\u0120that"]}
{"function": "public void registerInterposedSynchronization(Synchronization sync) throws IllegalStateException { try { Transaction tx = transactionManager.getTransaction(); JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx); if (jcaOrderedLastSynchronization == null) { jcaOrderedLastSynchronization = new JCAOrderedLastSynchronizationList(tx, interposedSyncs); delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization); } jcaOrderedLastSynchronization.add(sync); } catch (SystemException e) { throw new IllegalStateException(e); } }", "text": "putIfAbsent semantics is better", "function_tokens": ["public", "\u0120void", "\u0120register", "Inter", "posed", "S", "ynchron", "ization", "(", "S", "ynchron", "ization", "\u0120sync", ")", "\u0120throws", "\u0120Illegal", "State", "Exception", "\u0120{", "\u0120try", "\u0120{", "\u0120Transaction", "\u0120tx", "\u0120=", "\u0120transaction", "Manager", ".", "get", "Transaction", "();", "\u0120J", "CA", "Ord", "ered", "Last", "S", "ynchron", "ization", "List", "\u0120j", "ca", "Ord", "ered", "Last", "S", "ynchron", "ization", "\u0120=", "\u0120inter", "posed", "Syn", "cs", ".", "get", "(", "tx", ");", "\u0120if", "\u0120(", "j", "ca", "Ord", "ered", "Last", "S", "ynchron", "ization", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120j", "ca", "Ord", "ered", "Last", "S", "ynchron", "ization", "\u0120=", "\u0120new", "\u0120J", "CA", "Ord", "ered", "Last", "S", "ynchron", "ization", "List", "(", "tx", ",", "\u0120inter", "posed", "Syn", "cs", ");", "\u0120delegate", ".", "register", "Inter", "posed", "S", "ynchron", "ization", "(", "j", "ca", "Ord", "ered", "Last", "S", "ynchron", "ization", ");", "\u0120}", "\u0120j", "ca", "Ord", "ered", "Last", "S", "ynchron", "ization", ".", "add", "(", "sync", ");", "\u0120}", "\u0120catch", "\u0120(", "System", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["put", "If", "Abs", "ent", "\u0120semantics", "\u0120is", "\u0120better"]}
{"function": "void setUp() { mockApplicationContext = mock(ApplicationContext.class); mockEventStore = mock(EventStore.class); mockRepositoryProvider = mock(RepositoryProvider.class); executor = spy(new MockExecutor()); testSubject = new SpringAggregateSnapshotterFactoryBean(); testSubject.setApplicationContext(mockApplicationContext); testSubject.setExecutor(executor); when(mockApplicationContext.getBeansOfType(AggregateFactory.class)).thenReturn( Collections.singletonMap(\"myFactory\", new AbstractAggregateFactory<StubAggregate>(StubAggregate.class) { @Override public StubAggregate doCreateAggregate(String aggregateIdentifier, DomainEventMessage firstEvent) { return new StubAggregate(aggregateIdentifier); } })); testSubject.setEventStore(mockEventStore); testSubject.setRepositoryProvider(mockRepositoryProvider); mockTransactionManager = mock(PlatformTransactionManager.class); aggregateIdentifier = UUID.randomUUID().toString(); String type = \"StubAggregate\"; DomainEventMessage event1 = new GenericDomainEventMessage<>(type, aggregateIdentifier, 0L, \"Mock contents\", MetaData.emptyInstance()); DomainEventMessage event2 = new GenericDomainEventMessage<>(type, aggregateIdentifier, 1L, \"Mock contents\", MetaData.emptyInstance()); when(mockEventStore.readEvents(aggregateIdentifier)).thenReturn(DomainEventStream.of(event1, event2)); }", "text": "Would be nice for the test to pass without modifications, to show backwards compatibility.", "function_tokens": ["void", "\u0120set", "Up", "()", "\u0120{", "\u0120mock", "Application", "Context", "\u0120=", "\u0120mock", "(", "Application", "Context", ".", "class", ");", "\u0120mock", "Event", "Store", "\u0120=", "\u0120mock", "(", "Event", "Store", ".", "class", ");", "\u0120mock", "Rep", "ository", "Provider", "\u0120=", "\u0120mock", "(", "Rep", "ository", "Provider", ".", "class", ");", "\u0120execut", "or", "\u0120=", "\u0120spy", "(", "new", "\u0120Mock", "Exec", "utor", "());", "\u0120test", "Subject", "\u0120=", "\u0120new", "\u0120Spring", "Agg", "regate", "Snap", "shot", "ter", "Factory", "Be", "an", "();", "\u0120test", "Subject", ".", "set", "Application", "Context", "(", "m", "ock", "Application", "Context", ");", "\u0120test", "Subject", ".", "set", "Exec", "utor", "(", "exec", "utor", ");", "\u0120when", "(", "m", "ock", "Application", "Context", ".", "get", "Be", "ans", "Of", "Type", "(", "Agg", "regate", "Factory", ".", "class", ")).", "then", "Return", "(", "\u0120Collections", ".", "sing", "leton", "Map", "(\"", "my", "Factory", "\",", "\u0120new", "\u0120Abstract", "Agg", "regate", "Factory", "<", "St", "ub", "Agg", "regate", ">(", "St", "ub", "Agg", "regate", ".", "class", ")", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Stub", "Agg", "regate", "\u0120do", "Create", "Agg", "regate", "(", "String", "\u0120aggregate", "Ident", "ifier", ",", "\u0120Domain", "Event", "Message", "\u0120first", "Event", ")", "\u0120{", "\u0120return", "\u0120new", "\u0120Stub", "Agg", "regate", "(", "agg", "regate", "Ident", "ifier", ");", "\u0120}", "\u0120}", "));", "\u0120test", "Subject", ".", "set", "Event", "Store", "(", "m", "ock", "Event", "Store", ");", "\u0120test", "Subject", ".", "set", "Rep", "ository", "Provider", "(", "m", "ock", "Rep", "ository", "Provider", ");", "\u0120mock", "Transaction", "Manager", "\u0120=", "\u0120mock", "(", "Platform", "Transaction", "Manager", ".", "class", ");", "\u0120aggregate", "Ident", "ifier", "\u0120=", "\u0120U", "UID", ".", "random", "U", "UID", "().", "to", "String", "();", "\u0120String", "\u0120type", "\u0120=", "\u0120\"", "St", "ub", "Agg", "regate", "\";", "\u0120Domain", "Event", "Message", "\u0120event", "1", "\u0120=", "\u0120new", "\u0120Generic", "Domain", "Event", "Message", "<", ">(", "type", ",", "\u0120aggregate", "Ident", "ifier", ",", "\u01200", "L", ",", "\u0120\"", "M", "ock", "\u0120contents", "\",", "\u0120Meta", "Data", ".", "empty", "Instance", "());", "\u0120Domain", "Event", "Message", "\u0120event", "2", "\u0120=", "\u0120new", "\u0120Generic", "Domain", "Event", "Message", "<", ">(", "type", ",", "\u0120aggregate", "Ident", "ifier", ",", "\u01201", "L", ",", "\u0120\"", "M", "ock", "\u0120contents", "\",", "\u0120Meta", "Data", ".", "empty", "Instance", "());", "\u0120when", "(", "m", "ock", "Event", "Store", ".", "read", "Events", "(", "agg", "regate", "Ident", "ifier", ")).", "then", "Return", "(", "Domain", "Event", "Stream", ".", "of", "(", "event", "1", ",", "\u0120event", "2", "));", "\u0120}"], "docstring_tokens": ["Would", "\u0120be", "\u0120nice", "\u0120for", "\u0120the", "\u0120test", "\u0120to", "\u0120pass", "\u0120without", "\u0120modifications", ",", "\u0120to", "\u0120show", "\u0120backwards", "\u0120compatibility", "."]}
{"function": "public void run() { try (OpenShiftClient client = clouldClientHelper.get()) { logger.info(\"Watching ConfigMap in namespace {}\", client.getNamespace()); try (Watch watchable = client.configMaps().watch(new Watcher<ConfigMap>() { @Override public void eventReceived(Action action, ConfigMap kieServerState) { logger.info(\"Event - Action: {}, {} on ConfigMap \", action, kieServerState.getMetadata().getName()); DeploymentConfig dc = client.deploymentConfigs().withName(kieServerId).get(); if (kieServerId.equals(kieServerState.getMetadata().getName()) && action.equals(Action.MODIFIED) && \"True\".equals(dc.getStatus().getConditions().get(0).getStatus()) && triggerRollout(client, kieServerId)) { ObjectMeta md = dc.getSpec().getTemplate().getMetadata(); Map<String, String> ann = md.getAnnotations() == null ? new HashMap<>() : md.getAnnotations(); md.setAnnotations(ann); ann.put(ROLLOUT_TRIGGER_TIMESTAMP, ZonedDateTime.now().format(DateTimeFormatter.ISO_INSTANT)); client.deploymentConfigs().createOrReplace(dc); logger.info(\"Update DeploymentConfig: {}\", md.getName()); } else { logger.info(\"Event - Ignored\"); } } @Override public void onClose(KubernetesClientException cause) { logger.info(\"Watcher closed.\"); if (cause != null) { logger.info(cause.getMessage()); } } })) { logger.info(\"Watcher created.\"); Runtime.getRuntime().addShutdownHook(new Thread(() -> { synchronized (this) { isWatchRunning = false; notifyAll(); logger.info(\"ShutdownHook sent notifyAll.\"); } })); synchronized (this) { while (isWatchRunning && !Thread.currentThread().isInterrupted()) { logger.info(\"WatchRunner thread starts.\"); try { wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); logger.error(\"WatchRunner thread being interrupted\", e); } logger.info(\"WatchRunner thread being notified.\"); } logger.info(\"WatchRunner thread exits.\"); } } } catch (KubernetesClientException e) { logger.error(\"Failed\", e); } }", "text": "not sure how often this can be logged so maybe change the level to debug and also log the event that is being ignored?", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120try", "\u0120(", "Open", "Shift", "Client", "\u0120client", "\u0120=", "\u0120cl", "ould", "Client", "Helper", ".", "get", "())", "\u0120{", "\u0120logger", ".", "info", "(\"", "Watch", "ing", "\u0120Config", "Map", "\u0120in", "\u0120namespace", "\u0120{}", "\",", "\u0120client", ".", "get", "Names", "pace", "());", "\u0120try", "\u0120(", "Watch", "\u0120watch", "able", "\u0120=", "\u0120client", ".", "config", "Maps", "().", "watch", "(", "new", "\u0120Wat", "cher", "<", "Config", "Map", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120event", "Re", "ceived", "(", "Action", "\u0120action", ",", "\u0120Config", "Map", "\u0120k", "ie", "Server", "State", ")", "\u0120{", "\u0120logger", ".", "info", "(\"", "Event", "\u0120-", "\u0120Action", ":", "\u0120{", "},", "\u0120{}", "\u0120on", "\u0120Config", "Map", "\u0120\",", "\u0120action", ",", "\u0120k", "ie", "Server", "State", ".", "get", "Met", "adata", "().", "get", "Name", "());", "\u0120Deploy", "ment", "Config", "\u0120dc", "\u0120=", "\u0120client", ".", "de", "ploy", "ment", "Config", "s", "().", "with", "Name", "(", "kie", "Server", "Id", ").", "get", "();", "\u0120if", "\u0120(", "kie", "Server", "Id", ".", "equ", "als", "(", "kie", "Server", "State", ".", "get", "Met", "adata", "().", "get", "Name", "())", "\u0120&&", "\u0120action", ".", "equ", "als", "(", "Action", ".", "MOD", "IFIED", ")", "\u0120&&", "\u0120\"", "True", "\".", "equ", "als", "(", "dc", ".", "get", "Status", "().", "get", "Cond", "itions", "().", "get", "(", "0", ").", "get", "Status", "())", "\u0120&&", "\u0120trigger", "Roll", "out", "(", "client", ",", "\u0120k", "ie", "Server", "Id", "))", "\u0120{", "\u0120Object", "Meta", "\u0120md", "\u0120=", "\u0120dc", ".", "get", "Spec", "().", "get", "Template", "().", "get", "Met", "adata", "();", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120ann", "\u0120=", "\u0120md", ".", "get", "An", "notations", "()", "\u0120==", "\u0120null", "\u0120?", "\u0120new", "\u0120Hash", "Map", "<", ">", "()", "\u0120:", "\u0120md", ".", "get", "An", "notations", "();", "\u0120md", ".", "set", "An", "notations", "(", "ann", ");", "\u0120ann", ".", "put", "(", "RO", "LL", "OUT", "_", "TR", "IG", "GER", "_", "T", "IM", "EST", "AMP", ",", "\u0120Z", "oned", "Date", "Time", ".", "now", "().", "format", "(", "Date", "Time", "Form", "atter", ".", "ISO", "_", "INST", "ANT", "));", "\u0120client", ".", "de", "ploy", "ment", "Config", "s", "().", "create", "Or", "Re", "place", "(", "dc", ");", "\u0120logger", ".", "info", "(\"", "Update", "\u0120Deploy", "ment", "Config", ":", "\u0120{}", "\",", "\u0120md", ".", "get", "Name", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120logger", ".", "info", "(\"", "Event", "\u0120-", "\u0120Ign", "ored", "\");", "\u0120}", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Close", "(", "K", "uber", "net", "es", "Client", "Exception", "\u0120cause", ")", "\u0120{", "\u0120logger", ".", "info", "(\"", "W", "atcher", "\u0120closed", ".\"", ");", "\u0120if", "\u0120(", "cause", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "info", "(", "cause", ".", "get", "Message", "());", "\u0120}", "\u0120}", "\u0120}", "))", "\u0120{", "\u0120logger", ".", "info", "(\"", "W", "atcher", "\u0120created", ".\"", ");", "\u0120Runtime", ".", "get", "Runtime", "().", "add", "Shut", "down", "H", "ook", "(", "new", "\u0120Thread", "(", "()", "\u0120->", "\u0120{", "\u0120synchronized", "\u0120(", "this", ")", "\u0120{", "\u0120is", "Watch", "Running", "\u0120=", "\u0120false", ";", "\u0120notify", "All", "();", "\u0120logger", ".", "info", "(\"", "Shut", "down", "H", "ook", "\u0120sent", "\u0120notify", "All", ".\"", ");", "\u0120}", "\u0120}", "));", "\u0120synchronized", "\u0120(", "this", ")", "\u0120{", "\u0120while", "\u0120(", "is", "Watch", "Running", "\u0120&&", "\u0120!", "Thread", ".", "current", "Thread", "().", "is", "Inter", "rupted", "())", "\u0120{", "\u0120logger", ".", "info", "(\"", "Watch", "Runner", "\u0120thread", "\u0120starts", ".\"", ");", "\u0120try", "\u0120{", "\u0120wait", "();", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120Thread", ".", "current", "Thread", "().", "inter", "rupt", "();", "\u0120logger", ".", "error", "(\"", "Watch", "Runner", "\u0120thread", "\u0120being", "\u0120interrupted", "\",", "\u0120e", ");", "\u0120}", "\u0120logger", ".", "info", "(\"", "Watch", "Runner", "\u0120thread", "\u0120being", "\u0120notified", ".\"", ");", "\u0120}", "\u0120logger", ".", "info", "(\"", "Watch", "Runner", "\u0120thread", "\u0120exits", ".\"", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "K", "uber", "net", "es", "Client", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "error", "(\"", "F", "ailed", "\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["not", "\u0120sure", "\u0120how", "\u0120often", "\u0120this", "\u0120can", "\u0120be", "\u0120logged", "\u0120so", "\u0120maybe", "\u0120change", "\u0120the", "\u0120level", "\u0120to", "\u0120debug", "\u0120and", "\u0120also", "\u0120log", "\u0120the", "\u0120event", "\u0120that", "\u0120is", "\u0120being", "\u0120ignored", "?"]}
{"function": "private static Integer getPlatFormOffset() { String currentOs = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT); String currentJdk = System.getProperty(\"java.version\").toLowerCase(Locale.ROOT); for (int i = 0; i < PLATFORM_LIST.size(); i++) { if (currentOs.toLowerCase(Locale.ROOT).contains(PLATFORM_LIST.get(i).split(\",\")[0].toLowerCase(Locale.ROOT)) && currentJdk.toLowerCase(Locale.ROOT).contains( PLATFORM_LIST.get(i).split(\",\")[1].toLowerCase(Locale.ROOT))) { return i; } } return null; }", "text": "Throw an exception here and log an error including the currentOs and currentJdk. Returning null will cause a NPE upstream and we'll not know which OS, JDK name caused it.", "function_tokens": ["private", "\u0120static", "\u0120Integer", "\u0120get", "Pl", "at", "Form", "Offset", "()", "\u0120{", "\u0120String", "\u0120current", "Os", "\u0120=", "\u0120System", ".", "get", "Property", "(\"", "os", ".", "name", "\").", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", ");", "\u0120String", "\u0120current", "J", "dk", "\u0120=", "\u0120System", ".", "get", "Property", "(\"", "java", ".", "version", "\").", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", ");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120PL", "AT", "FORM", "_", "LIST", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "current", "Os", ".", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", ").", "cont", "ains", "(", "PL", "AT", "FORM", "_", "LIST", ".", "get", "(", "i", ").", "split", "(", "\",\"", ")[", "0", "].", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", "))", "\u0120&&", "\u0120current", "J", "dk", ".", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", ").", "cont", "ains", "(", "\u0120PL", "AT", "FORM", "_", "LIST", ".", "get", "(", "i", ").", "split", "(", "\",\"", ")[", "1", "].", "to", "Lower", "Case", "(", "Loc", "ale", ".", "RO", "OT", ")))", "\u0120{", "\u0120return", "\u0120i", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Throw", "\u0120an", "\u0120exception", "\u0120here", "\u0120and", "\u0120log", "\u0120an", "\u0120error", "\u0120including", "\u0120the", "\u0120current", "Os", "\u0120and", "\u0120current", "J", "dk", ".", "\u0120Returning", "\u0120null", "\u0120will", "\u0120cause", "\u0120a", "\u0120N", "PE", "\u0120upstream", "\u0120and", "\u0120we", "'ll", "\u0120not", "\u0120know", "\u0120which", "\u0120OS", ",", "\u0120JD", "K", "\u0120name", "\u0120caused", "\u0120it", "."]}
{"function": "public void subscribeUnsubscribe() throws Exception { final Postman postman = Mockito.mock(Postman.class); final DyBase base = new DyBase(); final Alias alias = new EmAlias(this.randomAlias(base), postman); final Bout bout = alias.inbox().bout(alias.inbox().start()); final Alias friend = this.randomAlias(base); bout.friends().invite(friend.name()); final ArgumentCaptor<Envelope> captor = ArgumentCaptor.forClass(Envelope.class); friend.inbox().bout(bout.number()).subscribe(false); bout.messages().post(DON_T_SEND_IT); friend.inbox().bout(bout.number()).subscribe(true); bout.messages().post(SEND_IT); bout.messages().post(SEND_IT); friend.inbox().bout(bout.number()).subscribe(false); bout.messages().post(DON_T_SEND_IT); Mockito.verify(postman, Mockito.times(2)).send(captor.capture()); final List<Envelope> messages = captor.getAllValues(); for (final Envelope envelope : messages) { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); MimeMultipart.class.cast(envelope.unwrap().getContent()) .writeTo(baos); MatcherAssert.assertThat( baos.toString(), Matchers.containsString( SEND_IT ) ); } }", "text": "@pecko let's also assert it does not contain the other string.", "function_tokens": ["public", "\u0120void", "\u0120subscribe", "Un", "sub", "scribe", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120Post", "man", "\u0120post", "man", "\u0120=", "\u0120Mock", "ito", ".", "m", "ock", "(", "Post", "man", ".", "class", ");", "\u0120final", "\u0120Dy", "Base", "\u0120base", "\u0120=", "\u0120new", "\u0120Dy", "Base", "();", "\u0120final", "\u0120Al", "ias", "\u0120alias", "\u0120=", "\u0120new", "\u0120Em", "Alias", "(", "this", ".", "random", "Alias", "(", "base", "),", "\u0120post", "man", ");", "\u0120final", "\u0120Bout", "\u0120bout", "\u0120=", "\u0120alias", ".", "in", "box", "().", "b", "out", "(", "alias", ".", "in", "box", "().", "start", "());", "\u0120final", "\u0120Al", "ias", "\u0120friend", "\u0120=", "\u0120this", ".", "random", "Alias", "(", "base", ");", "\u0120bout", ".", "friends", "().", "inv", "ite", "(", "friend", ".", "name", "());", "\u0120final", "\u0120Argument", "Capt", "or", "<", "En", "velop", "e", ">", "\u0120capt", "or", "\u0120=", "\u0120Argument", "Capt", "or", ".", "for", "Class", "(", "En", "velop", "e", ".", "class", ");", "\u0120friend", ".", "in", "box", "().", "b", "out", "(", "b", "out", ".", "number", "()", ").", "sub", "scribe", "(", "false", ");", "\u0120bout", ".", "mess", "ages", "().", "post", "(", "DON", "_", "T", "_", "S", "END", "_", "IT", ");", "\u0120friend", ".", "in", "box", "().", "b", "out", "(", "b", "out", ".", "number", "()", ").", "sub", "scribe", "(", "true", ");", "\u0120bout", ".", "mess", "ages", "().", "post", "(", "S", "END", "_", "IT", ");", "\u0120bout", ".", "mess", "ages", "().", "post", "(", "S", "END", "_", "IT", ");", "\u0120friend", ".", "in", "box", "().", "b", "out", "(", "b", "out", ".", "number", "()", ").", "sub", "scribe", "(", "false", ");", "\u0120bout", ".", "mess", "ages", "().", "post", "(", "DON", "_", "T", "_", "S", "END", "_", "IT", ");", "\u0120Mock", "ito", ".", "ver", "ify", "(", "post", "man", ",", "\u0120Mock", "ito", ".", "times", "(", "2", ")).", "send", "(", "capt", "or", ".", "capt", "ure", "());", "\u0120final", "\u0120List", "<", "En", "velop", "e", ">", "\u0120messages", "\u0120=", "\u0120capt", "or", ".", "get", "All", "Values", "();", "\u0120for", "\u0120(", "final", "\u0120En", "velop", "e", "\u0120envelope", "\u0120:", "\u0120messages", ")", "\u0120{", "\u0120final", "\u0120Byte", "Array", "Output", "Stream", "\u0120b", "aos", "\u0120=", "\u0120new", "\u0120Byte", "Array", "Output", "Stream", "();", "\u0120M", "ime", "Mult", "ip", "art", ".", "class", ".", "cast", "(", "en", "velop", "e", ".", "un", "wrap", "().", "get", "Content", "())", "\u0120.", "write", "To", "(", "ba", "os", ");", "\u0120Mat", "cher", "Ass", "ert", ".", "assert", "That", "(", "\u0120b", "aos", ".", "to", "String", "(),", "\u0120Mat", "chers", ".", "cont", "ains", "String", "(", "\u0120S", "END", "_", "IT", "\u0120)", "\u0120);", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "pe", "cko", "\u0120let", "'s", "\u0120also", "\u0120assert", "\u0120it", "\u0120does", "\u0120not", "\u0120contain", "\u0120the", "\u0120other", "\u0120string", "."]}
{"function": "private void testCopyQuestion() throws Exception { ______TS(\"Success case: copy questions successfully\"); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyTableToLoad(); assertFalse(\"Unable to submit when there are no questions selected\", feedbackEditPage.isCopySubmitButtonEnabled()); feedbackEditPage.verifyHtmlPart(By.id(\"copyModal\"), \"/instructorFeedbackCopyQuestionModal.html\"); feedbackEditPage.clickCopyTableAtRow(0); assertTrue(\"Can click after selecting\", feedbackEditPage.isCopySubmitButtonEnabled()); feedbackEditPage.clickCopySubmitButton(); feedbackEditPage.verifyHtmlMainContent(\"/instructorFeedbackCopyQuestionSuccess.html\"); ______TS(\"Success case: copy multiple questions successfully\"); int numQuestionEditForms = feedbackEditPage.getNumberOfQuestionEditForms(); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyTableToLoad(); feedbackEditPage.clickCopyTableAtRow(0); feedbackEditPage.clickCopyTableAtRow(1); feedbackEditPage.clickCopySubmitButton(); assertEquals(numQuestionEditForms + 2, feedbackEditPage.getNumberOfQuestionEditForms()); ______TS(\"No copiable questions\"); feedbackEditPage = getFeedbackEditPageOfCourseWithoutQuestions(); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyErrorMessageToLoad(); assertEquals(\"There are no questions to be copied.\", feedbackEditPage.getCopyErrorMessageText()); assertFalse(\"Should not be able to submit if there are no questions\", feedbackEditPage.isCopySubmitButtonEnabled()); ______TS(\"Fails gracefully with an error message\"); feedbackEditPage = getFeedbackEditPage(); feedbackEditPage.changeActionLinkOnCopyButton(\"invalid URL\"); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyErrorMessageToLoad(); assertEquals(\"Error retrieving questions. Please close the dialog window and try again.\", feedbackEditPage.getCopyErrorMessageText()); assertFalse(\"Should not be able to submit if loading failed\", feedbackEditPage.isCopySubmitButtonEnabled()); String questionId = getFeedbackQuestionWithRetry(courseId, feedbackSessionName, 4).getId(); BackDoor.deleteFeedbackQuestion(questionId); questionId = getFeedbackQuestionWithRetry(courseId, feedbackSessionName, 3).getId(); BackDoor.deleteFeedbackQuestion(questionId); }", "text": "Not related to gender type", "function_tokens": ["private", "\u0120void", "\u0120test", "Copy", "Question", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120______", "TS", "(\"", "Success", "\u0120case", ":", "\u0120copy", "\u0120questions", "\u0120successfully", "\");", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Button", "();", "\u0120feedback", "Edit", "Page", ".", "wait", "For", "Copy", "Table", "To", "Load", "();", "\u0120assert", "False", "(\"", "Un", "able", "\u0120to", "\u0120submit", "\u0120when", "\u0120there", "\u0120are", "\u0120no", "\u0120questions", "\u0120selected", "\",", "\u0120feedback", "Edit", "Page", ".", "is", "Copy", "Submit", "Button", "Enabled", "());", "\u0120feedback", "Edit", "Page", ".", "ver", "ify", "H", "tml", "Part", "(", "By", ".", "id", "(\"", "copy", "Mod", "al", "\"),", "\u0120\"/", "in", "struct", "or", "Feed", "back", "Copy", "Question", "Mod", "al", ".", "html", "\");", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Table", "At", "Row", "(", "0", ");", "\u0120assert", "True", "(\"", "Can", "\u0120click", "\u0120after", "\u0120selecting", "\",", "\u0120feedback", "Edit", "Page", ".", "is", "Copy", "Submit", "Button", "Enabled", "());", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Submit", "Button", "();", "\u0120feedback", "Edit", "Page", ".", "ver", "ify", "H", "tml", "Main", "Content", "(\"", "/", "in", "struct", "or", "Feed", "back", "Copy", "Question", "Success", ".", "html", "\");", "\u0120______", "TS", "(\"", "Success", "\u0120case", ":", "\u0120copy", "\u0120multiple", "\u0120questions", "\u0120successfully", "\");", "\u0120int", "\u0120num", "Question", "Edit", "Form", "s", "\u0120=", "\u0120feedback", "Edit", "Page", ".", "get", "Number", "Of", "Question", "Edit", "Form", "s", "();", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Button", "();", "\u0120feedback", "Edit", "Page", ".", "wait", "For", "Copy", "Table", "To", "Load", "();", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Table", "At", "Row", "(", "0", ");", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Table", "At", "Row", "(", "1", ");", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Submit", "Button", "();", "\u0120assert", "Equ", "als", "(", "num", "Question", "Edit", "Form", "s", "\u0120+", "\u01202", ",", "\u0120feedback", "Edit", "Page", ".", "get", "Number", "Of", "Question", "Edit", "Form", "s", "());", "\u0120______", "TS", "(\"", "No", "\u0120cop", "iable", "\u0120questions", "\");", "\u0120feedback", "Edit", "Page", "\u0120=", "\u0120get", "Feed", "back", "Edit", "Page", "Of", "Course", "Without", "Questions", "();", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Button", "();", "\u0120feedback", "Edit", "Page", ".", "wait", "For", "Copy", "Error", "Message", "To", "Load", "();", "\u0120assert", "Equ", "als", "(\"", "There", "\u0120are", "\u0120no", "\u0120questions", "\u0120to", "\u0120be", "\u0120copied", ".\",", "\u0120feedback", "Edit", "Page", ".", "get", "Copy", "Error", "Message", "Text", "());", "\u0120assert", "False", "(\"", "Should", "\u0120not", "\u0120be", "\u0120able", "\u0120to", "\u0120submit", "\u0120if", "\u0120there", "\u0120are", "\u0120no", "\u0120questions", "\",", "\u0120feedback", "Edit", "Page", ".", "is", "Copy", "Submit", "Button", "Enabled", "());", "\u0120______", "TS", "(\"", "F", "ails", "\u0120grace", "fully", "\u0120with", "\u0120an", "\u0120error", "\u0120message", "\");", "\u0120feedback", "Edit", "Page", "\u0120=", "\u0120get", "Feed", "back", "Edit", "Page", "();", "\u0120feedback", "Edit", "Page", ".", "change", "Action", "Link", "On", "Copy", "Button", "(\"", "in", "valid", "\u0120URL", "\");", "\u0120feedback", "Edit", "Page", ".", "click", "Copy", "Button", "();", "\u0120feedback", "Edit", "Page", ".", "wait", "For", "Copy", "Error", "Message", "To", "Load", "();", "\u0120assert", "Equ", "als", "(\"", "Error", "\u0120retrieving", "\u0120questions", ".", "\u0120Please", "\u0120close", "\u0120the", "\u0120dialog", "\u0120window", "\u0120and", "\u0120try", "\u0120again", ".\",", "\u0120feedback", "Edit", "Page", ".", "get", "Copy", "Error", "Message", "Text", "());", "\u0120assert", "False", "(\"", "Should", "\u0120not", "\u0120be", "\u0120able", "\u0120to", "\u0120submit", "\u0120if", "\u0120loading", "\u0120failed", "\",", "\u0120feedback", "Edit", "Page", ".", "is", "Copy", "Submit", "Button", "Enabled", "());", "\u0120String", "\u0120question", "Id", "\u0120=", "\u0120get", "Feed", "back", "Question", "With", "Ret", "ry", "(", "course", "Id", ",", "\u0120feedback", "Session", "Name", ",", "\u01204", ").", "get", "Id", "();", "\u0120Back", "D", "oor", ".", "delete", "Feed", "back", "Question", "(", "question", "Id", ");", "\u0120question", "Id", "\u0120=", "\u0120get", "Feed", "back", "Question", "With", "Ret", "ry", "(", "course", "Id", ",", "\u0120feedback", "Session", "Name", ",", "\u01203", ").", "get", "Id", "();", "\u0120Back", "D", "oor", ".", "delete", "Feed", "back", "Question", "(", "question", "Id", ");", "\u0120}"], "docstring_tokens": ["Not", "\u0120related", "\u0120to", "\u0120gender", "\u0120type"]}
{"function": "public Ban.Builder profile(org.spongepowered.api.profile.GameProfile profile) { checkNotNull(profile, \"Profile cannot be null!\"); checkState(banType == BanTypes.PROFILE, \"Cannot set a GameProfile if the BanType is not BanType.USER_BAN!\"); this.profile = profile; return this; }", "text": "Message needs updating", "function_tokens": ["public", "\u0120Ban", ".", "Builder", "\u0120profile", "(", "org", ".", "sp", "onge", "powered", ".", "api", ".", "profile", ".", "Game", "Profile", "\u0120profile", ")", "\u0120{", "\u0120check", "Not", "Null", "(", "profile", ",", "\u0120\"", "Profile", "\u0120cannot", "\u0120be", "\u0120null", "!\"", ");", "\u0120check", "State", "(", "ban", "Type", "\u0120==", "\u0120Ban", "Types", ".", "PRO", "FILE", ",", "\u0120\"", "C", "annot", "\u0120set", "\u0120a", "\u0120Game", "Profile", "\u0120if", "\u0120the", "\u0120Ban", "Type", "\u0120is", "\u0120not", "\u0120Ban", "Type", ".", "USER", "_", "B", "AN", "!\"", ");", "\u0120this", ".", "profile", "\u0120=", "\u0120profile", ";", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["Message", "\u0120needs", "\u0120updating"]}
{"function": "public void removeListener() { View view = getView(); if (view != null) { getDiagramEventBroker().removeNotificationListener(view, this); if (hostSemanticElement != null) { for (EObject stereotypeApplication : hostSemanticElement.getStereotypeApplications()) { getDiagramEventBroker().removeNotificationListener(stereotypeApplication, this); } getDiagramEventBroker().removeNotificationListener(hostSemanticElement, this); hostSemanticElement = null; } } if (!stereotypeList.isEmpty()) { for (Stereotype stereotype : stereotypeList) { View label = helper.getStereotypeLabel(hostView, stereotype); if (null != label) { getDiagramEventBroker().removeNotificationListener(label, this); } BasicCompartment compartment = helper.getStereotypeBraceCompartment(hostView, stereotype); if (compartment != null) { getDiagramEventBroker().addNotificationListener(helper.getStereotypeBraceCompartment(hostView, stereotype), this); } if (compartment != null && stereotype != null) { EList<Property> properties = stereotype.allAttributes(); for (Property property : properties) { getDiagramEventBroker().removeNotificationListener(helper.getStereotypePropertyInBrace(hostView, stereotype, property), this); } } } } }", "text": "'null !=' is preferably used", "function_tokens": ["public", "\u0120void", "\u0120remove", "Listener", "()", "\u0120{", "\u0120View", "\u0120view", "\u0120=", "\u0120get", "View", "();", "\u0120if", "\u0120(", "view", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "remove", "Not", "ification", "Listener", "(", "view", ",", "\u0120this", ");", "\u0120if", "\u0120(", "host", "Sem", "antic", "Element", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "EO", "b", "ject", "\u0120stereotype", "Application", "\u0120:", "\u0120host", "Sem", "antic", "Element", ".", "get", "St", "ere", "otype", "Applications", "())", "\u0120{", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "remove", "Not", "ification", "Listener", "(", "st", "ere", "otype", "Application", ",", "\u0120this", ");", "\u0120}", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "remove", "Not", "ification", "Listener", "(", "host", "Sem", "antic", "Element", ",", "\u0120this", ");", "\u0120host", "Sem", "antic", "Element", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "st", "ere", "otype", "List", ".", "is", "Empty", "())", "\u0120{", "\u0120for", "\u0120(", "St", "ere", "otype", "\u0120stereotype", "\u0120:", "\u0120stereotype", "List", ")", "\u0120{", "\u0120View", "\u0120label", "\u0120=", "\u0120helper", ".", "get", "St", "ere", "otype", "Label", "(", "host", "View", ",", "\u0120stereotype", ");", "\u0120if", "\u0120(", "null", "\u0120!=", "\u0120label", ")", "\u0120{", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "remove", "Not", "ification", "Listener", "(", "label", ",", "\u0120this", ");", "\u0120}", "\u0120Basic", "Comp", "artment", "\u0120compartment", "\u0120=", "\u0120helper", ".", "get", "St", "ere", "otype", "Br", "ace", "Comp", "artment", "(", "host", "View", ",", "\u0120stereotype", ");", "\u0120if", "\u0120(", "comp", "artment", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "add", "Not", "ification", "Listener", "(", "hel", "per", ".", "get", "St", "ere", "otype", "Br", "ace", "Comp", "artment", "(", "host", "View", ",", "\u0120stereotype", "),", "\u0120this", ");", "\u0120}", "\u0120if", "\u0120(", "comp", "artment", "\u0120!=", "\u0120null", "\u0120&&", "\u0120stereotype", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120E", "List", "<", "Property", ">", "\u0120properties", "\u0120=", "\u0120stereotype", ".", "all", "Attributes", "();", "\u0120for", "\u0120(", "Property", "\u0120property", "\u0120:", "\u0120properties", ")", "\u0120{", "\u0120get", "Di", "agram", "Event", "Bro", "ker", "().", "remove", "Not", "ification", "Listener", "(", "hel", "per", ".", "get", "St", "ere", "otype", "Property", "In", "Br", "ace", "(", "host", "View", ",", "\u0120stereotype", ",", "\u0120property", "),", "\u0120this", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["'", "null", "\u0120!", "='", "\u0120is", "\u0120preferably", "\u0120used"]}
{"function": "protected void reinitAllDatabases() throws IOException { boolean acquired = false; try { semaphore.acquire(Integer.MAX_VALUE); acquired = true; try { db.close(); } catch (IOException e) { log.warnUnableToCloseDb(e); } try { expiredDb.close(); } catch (IOException e) { log.warnUnableToCloseExpiredDb(e); } } catch (InterruptedException e) { log.warnUnableToCloseDb(e); log.warnUnableToCloseExpiredDb(e); } db = reinitDatabase(getQualifiedLocation(), dataDbOptions()); expiredDb = reinitDatabase(getQualifiedExpiredLocation(), expiredDbOptions()); if (acquired) { semaphore.release(Integer.MAX_VALUE); } }", "text": "This should be done in a proper try finally block. If a reinitDatabase method threw an IOException the semaphore would be irreparably broken.", "function_tokens": ["protected", "\u0120void", "\u0120rein", "it", "All", "Dat", "abases", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120boolean", "\u0120acquired", "\u0120=", "\u0120false", ";", "\u0120try", "\u0120{", "\u0120sem", "aph", "ore", ".", "ac", "quire", "(", "Integer", ".", "MAX", "_", "VALUE", ");", "\u0120acquired", "\u0120=", "\u0120true", ";", "\u0120try", "\u0120{", "\u0120db", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "Un", "able", "To", "Close", "Db", "(", "e", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120expired", "Db", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "Un", "able", "To", "Close", "Ex", "pired", "Db", "(", "e", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "Un", "able", "To", "Close", "Db", "(", "e", ");", "\u0120log", ".", "warn", "Un", "able", "To", "Close", "Ex", "pired", "Db", "(", "e", ");", "\u0120}", "\u0120db", "\u0120=", "\u0120rein", "it", "Database", "(", "get", "Qual", "ified", "Location", "(),", "\u0120data", "Db", "Options", "());", "\u0120expired", "Db", "\u0120=", "\u0120rein", "it", "Database", "(", "get", "Qual", "ified", "Ex", "pired", "Location", "(),", "\u0120expired", "Db", "Options", "());", "\u0120if", "\u0120(", "acqu", "ired", ")", "\u0120{", "\u0120sem", "aph", "ore", ".", "release", "(", "Integer", ".", "MAX", "_", "VALUE", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120should", "\u0120be", "\u0120done", "\u0120in", "\u0120a", "\u0120proper", "\u0120try", "\u0120finally", "\u0120block", ".", "\u0120If", "\u0120a", "\u0120rein", "it", "Database", "\u0120method", "\u0120threw", "\u0120an", "\u0120IO", "Exception", "\u0120the", "\u0120sem", "aph", "ore", "\u0120would", "\u0120be", "\u0120irre", "par", "ably", "\u0120broken", "."]}
{"function": "public MatchClause append(Filter filter) { if (clause == null) { clause = new StringBuilder(\"MATCH (n)\"); if (filter.getRelationshipDirection().equals(Direction.INCOMING)) { clause.append(\"<\"); } clause.append(String.format(\"-[%s:`%s`]-\", relationshipIdentifier(), this.relationshipType)); if (filter.getRelationshipDirection().equals(Direction.OUTGOING)) { clause.append(\">\"); } clause.append(String.format(\"(%s) \", nodeIdentifier())); } clause.append(filter.toCypher(relationshipIdentifier(), clause.indexOf(\" WHERE \") == -1)); return this; }", "text": "suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {", "function_tokens": ["public", "\u0120Match", "Cl", "ause", "\u0120append", "(", "Filter", "\u0120filter", ")", "\u0120{", "\u0120if", "\u0120(", "cl", "ause", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120clause", "\u0120=", "\u0120new", "\u0120String", "Builder", "(\"", "M", "ATCH", "\u0120(", "n", ")", "\");", "\u0120if", "\u0120(", "filter", ".", "get", "Relations", "hip", "D", "irection", "().", "equ", "als", "(", "D", "irection", ".", "IN", "COM", "ING", "))", "\u0120{", "\u0120clause", ".", "append", "(\"", "<", "\");", "\u0120}", "\u0120clause", ".", "append", "(", "String", ".", "format", "(\"", "-[", "%", "s", ":", "`", "%", "s", "`", "]-", "\",", "\u0120relationship", "Ident", "ifier", "(),", "\u0120this", ".", "relations", "hip", "Type", "));", "\u0120if", "\u0120(", "filter", ".", "get", "Relations", "hip", "D", "irection", "().", "equ", "als", "(", "D", "irection", ".", "OUT", "GO", "ING", "))", "\u0120{", "\u0120clause", ".", "append", "(", "\">", "\");", "\u0120}", "\u0120clause", ".", "append", "(", "String", ".", "format", "(\"", "(", "%", "s", ")", "\u0120\",", "\u0120node", "Ident", "ifier", "()", "));", "\u0120}", "\u0120clause", ".", "append", "(", "filter", ".", "to", "C", "yp", "her", "(", "relations", "hip", "Ident", "ifier", "(),", "\u0120clause", ".", "index", "Of", "(\"", "\u0120WHERE", "\u0120\"", ")", "\u0120==", "\u0120-", "1", "));", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120if", "\u0120(", "filter", ".", "get", "Relations", "hip", "D", "irection", "()", "\u0120==", "\u0120Direction", ".", "IN", "COM", "ING", ")", "\u0120{"]}
{"function": "public static AdjustableSweepBatchConfigSource create( MetricsManager metricsManager, Supplier<SweepBatchConfig> rawSweepBatchConfig) { AdjustableSweepBatchConfigSource configSource = new AdjustableSweepBatchConfigSource(rawSweepBatchConfig); Gauge<Double> gauge = AdjustableSweepBatchConfigSource::getBatchSizeMultiplier; metricsManager.addMetricFilter(AdjustableSweepBatchConfigSource.class, \"batchSizeMultiplier\", ImmutableMap.of(), () -> gauge.getValue() != 1.0); metricsManager.registerMetric(AdjustableSweepBatchConfigSource.class, \"batchSizeMultiplier\", gauge); return configSource; }", "text": "I am confused b/w the description and implementation of filter here.", "function_tokens": ["public", "\u0120static", "\u0120Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", "\u0120create", "(", "\u0120Met", "rics", "Manager", "\u0120metrics", "Manager", ",", "\u0120Supp", "lier", "<", "Swe", "ep", "B", "atch", "Config", ">", "\u0120raw", "Swe", "ep", "B", "atch", "Config", ")", "\u0120{", "\u0120Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", "\u0120config", "Source", "\u0120=", "\u0120new", "\u0120Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", "(", "raw", "Swe", "ep", "B", "atch", "Config", ");", "\u0120Gau", "ge", "<", "Double", ">", "\u0120gauge", "\u0120=", "\u0120Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", "::", "get", "B", "atch", "Size", "Mult", "ipl", "ier", ";", "\u0120metrics", "Manager", ".", "add", "Met", "ric", "Filter", "(", "Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", ".", "class", ",", "\u0120\"", "batch", "Size", "Mult", "ipl", "ier", "\",", "\u0120Imm", "utable", "Map", ".", "of", "(),", "\u0120()", "\u0120->", "\u0120gauge", ".", "get", "Value", "()", "\u0120!=", "\u01201", ".", "0", ");", "\u0120metrics", "Manager", ".", "register", "Met", "ric", "(", "Adjust", "able", "Swe", "ep", "B", "atch", "Config", "Source", ".", "class", ",", "\u0120\"", "batch", "Size", "Mult", "ipl", "ier", "\",", "\u0120gauge", ");", "\u0120return", "\u0120config", "Source", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120am", "\u0120confused", "\u0120b", "/", "w", "\u0120the", "\u0120description", "\u0120and", "\u0120implementation", "\u0120of", "\u0120filter", "\u0120here", "."]}
{"function": "public void configure(Binder binder) { JsonConfigProvider.bind(binder, \"druid.metadata.storage.tables\", MetadataStorageTablesConfig.class); JsonConfigProvider.bind(binder, \"druid.metadata.storage.connector\", MetadataStorageConnectorConfig.class); JsonConfigProvider.bind(binder, \"druid.manager.segments\", MetadataSegmentManagerConfig.class); JsonConfigProvider.bind(binder, \"druid.manager.rules\", MetadataRuleManagerConfig.class); binder.bind(PasswordProvider.class).toProvider( new Provider<PasswordProvider>() { @Inject MetadataStorageConnectorConfig metadataStorageConnectorConfig; @Inject Injector injector; @Override public PasswordProvider get() { final PasswordProvider passwordProvider; if (metadataStorageConnectorConfig == null || metadataStorageConnectorConfig.getPasswordProvider() == null) { JsonConfigProvider<PasswordProvider> provider = JsonConfigProvider.of(\"druid.password\", PasswordProvider.class); provider.inject(injector.getInstance(Properties.class), injector.getInstance(JsonConfigurator.class)); passwordProvider = provider.get().get(); } else { passwordProvider = metadataStorageConnectorConfig.getPasswordProvider(); } injector.injectMembers(passwordProvider); return passwordProvider; } } ); }", "text": "Logging might be helpful to warn users that this should not happen.", "function_tokens": ["public", "\u0120void", "\u0120configure", "(", "B", "inder", "\u0120b", "inder", ")", "\u0120{", "\u0120J", "son", "Config", "Provider", ".", "bind", "(", "b", "inder", ",", "\u0120\"", "d", "ru", "id", ".", "metadata", ".", "storage", ".", "t", "ables", "\",", "\u0120Met", "adata", "Storage", "T", "ables", "Config", ".", "class", ");", "\u0120J", "son", "Config", "Provider", ".", "bind", "(", "b", "inder", ",", "\u0120\"", "d", "ru", "id", ".", "metadata", ".", "storage", ".", "connect", "or", "\",", "\u0120Met", "adata", "Storage", "Connector", "Config", ".", "class", ");", "\u0120J", "son", "Config", "Provider", ".", "bind", "(", "b", "inder", ",", "\u0120\"", "d", "ru", "id", ".", "manager", ".", "se", "gments", "\",", "\u0120Met", "adata", "Seg", "ment", "Manager", "Config", ".", "class", ");", "\u0120J", "son", "Config", "Provider", ".", "bind", "(", "b", "inder", ",", "\u0120\"", "d", "ru", "id", ".", "manager", ".", "rules", "\",", "\u0120Met", "adata", "Rule", "Manager", "Config", ".", "class", ");", "\u0120b", "inder", ".", "bind", "(", "Password", "Provider", ".", "class", ").", "to", "Provider", "(", "\u0120new", "\u0120Provider", "<", "Password", "Provider", ">", "()", "\u0120{", "\u0120@", "In", "ject", "\u0120Met", "adata", "Storage", "Connector", "Config", "\u0120metadata", "Storage", "Connector", "Config", ";", "\u0120@", "In", "ject", "\u0120In", "ject", "or", "\u0120inject", "or", ";", "\u0120@", "Override", "\u0120public", "\u0120Password", "Provider", "\u0120get", "()", "\u0120{", "\u0120final", "\u0120Password", "Provider", "\u0120password", "Provider", ";", "\u0120if", "\u0120(", "metadata", "Storage", "Connector", "Config", "\u0120==", "\u0120null", "\u0120||", "\u0120metadata", "Storage", "Connector", "Config", ".", "get", "Password", "Provider", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120J", "son", "Config", "Provider", "<", "Password", "Provider", ">", "\u0120provider", "\u0120=", "\u0120J", "son", "Config", "Provider", ".", "of", "(\"", "d", "ru", "id", ".", "password", "\",", "\u0120Password", "Provider", ".", "class", ");", "\u0120provider", ".", "in", "ject", "(", "in", "ject", "or", ".", "get", "Instance", "(", "Pro", "perties", ".", "class", "),", "\u0120inject", "or", ".", "get", "Instance", "(", "J", "son", "Config", "ur", "ator", ".", "class", "));", "\u0120password", "Provider", "\u0120=", "\u0120provider", ".", "get", "().", "get", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120password", "Provider", "\u0120=", "\u0120metadata", "Storage", "Connector", "Config", ".", "get", "Password", "Provider", "();", "\u0120}", "\u0120inject", "or", ".", "in", "ject", "Members", "(", "password", "Provider", ");", "\u0120return", "\u0120password", "Provider", ";", "\u0120}", "\u0120}", "\u0120);", "\u0120}"], "docstring_tokens": ["Log", "ging", "\u0120might", "\u0120be", "\u0120helpful", "\u0120to", "\u0120warn", "\u0120users", "\u0120that", "\u0120this", "\u0120should", "\u0120not", "\u0120happen", "."]}
{"function": "public void testMigrationTask() throws InterruptedException { MigrationTask migrationTask = new MigrationTask(project); migrationTask.start(); Assert.assertTrue(migrationTask.isAlive()); migrationTask.join(); Assert.assertFalse(migrationTask.isAlive()); Assert.assertEquals(100, migrationTask.getProgress()); }", "text": "test should test, if metadata is migrated ;-)", "function_tokens": ["public", "\u0120void", "\u0120test", "M", "igration", "Task", "()", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120Migration", "Task", "\u0120migration", "Task", "\u0120=", "\u0120new", "\u0120Migration", "Task", "(", "project", ");", "\u0120migration", "Task", ".", "start", "();", "\u0120Ass", "ert", ".", "assert", "True", "(", "m", "igration", "Task", ".", "is", "Al", "ive", "());", "\u0120migration", "Task", ".", "join", "();", "\u0120Ass", "ert", ".", "assert", "False", "(", "m", "igration", "Task", ".", "is", "Al", "ive", "());", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "100", ",", "\u0120migration", "Task", ".", "get", "Progress", "());", "\u0120}"], "docstring_tokens": ["test", "\u0120should", "\u0120test", ",", "\u0120if", "\u0120metadata", "\u0120is", "\u0120migrated", "\u0120;", "-)"]}
{"function": "protected Object toNSCollection(ERXRestFormat.Delegate delegate, NSMutableDictionary<Object, Object> associatedObjects) { Object result = associatedObjects.get(_associatedObject); if (result == null) { if (delegate != null) { delegate.nodeWillWrite(this); } if (isArray()) { NSMutableArray<Object> array = new NSMutableArray<Object>(); for (ERXRestRequestNode child : _children) { array.add(child.toNSCollection(delegate, associatedObjects)); } result = array; } else if (isNull()) { result = NSKeyValueCoding.NullValue; } else if (_value != null) { result = _value; } else { NSMutableDictionary<Object, Object> dict = new NSMutableDictionary<Object, Object>(); for (Map.Entry<String, Object> attribute : _attributes.entrySet()) { String key = attribute.getKey(); Object value = attribute.getValue(); if (value == null) { value = NSKeyValueCoding.NullValue; } dict.put(key, value); } for (ERXRestRequestNode child : _children) { String name = child.name(); Object value = child.toNSCollection(delegate, associatedObjects); if (value != NSKeyValueCoding.NullValue || ERXProperties.booleanForKeyWithDefault(\"ERXRest.includeNullValues\", true) == true) { dict.put(name, value); } } if (dict.isEmpty()) { result = NSKeyValueCoding.NullValue; } else { result = dict; } } if (_associatedObject != null) { associatedObjects.put(_associatedObject, result); } } return result; }", "text": "_== true_ part is not needed as booleanForKeyWithDefault already returns a boolean ;)", "function_tokens": ["protected", "\u0120Object", "\u0120to", "NS", "Collection", "(", "ER", "X", "Rest", "Format", ".", "De", "legate", "\u0120delegate", ",", "\u0120NS", "M", "utable", "D", "ictionary", "<", "Object", ",", "\u0120Object", ">", "\u0120associated", "Object", "s", ")", "\u0120{", "\u0120Object", "\u0120result", "\u0120=", "\u0120associated", "Object", "s", ".", "get", "(_", "associated", "Object", ");", "\u0120if", "\u0120(", "result", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "de", "legate", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120delegate", ".", "node", "Will", "Write", "(", "this", ");", "\u0120}", "\u0120if", "\u0120(", "is", "Array", "())", "\u0120{", "\u0120NS", "M", "utable", "Array", "<", "Object", ">", "\u0120array", "\u0120=", "\u0120new", "\u0120NS", "M", "utable", "Array", "<", "Object", ">", "();", "\u0120for", "\u0120(", "ER", "X", "Rest", "Request", "Node", "\u0120child", "\u0120:", "\u0120_", "children", ")", "\u0120{", "\u0120array", ".", "add", "(", "child", ".", "to", "NS", "Collection", "(", "de", "legate", ",", "\u0120associated", "Object", "s", "));", "\u0120}", "\u0120result", "\u0120=", "\u0120array", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Null", "())", "\u0120{", "\u0120result", "\u0120=", "\u0120NS", "Key", "Value", "C", "oding", ".", "Null", "Value", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(_", "value", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120result", "\u0120=", "\u0120_", "value", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120NS", "M", "utable", "D", "ictionary", "<", "Object", ",", "\u0120Object", ">", "\u0120dict", "\u0120=", "\u0120new", "\u0120NS", "M", "utable", "D", "ictionary", "<", "Object", ",", "\u0120Object", ">", "();", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120Object", ">", "\u0120attribute", "\u0120:", "\u0120_", "att", "ributes", ".", "entry", "Set", "())", "\u0120{", "\u0120String", "\u0120key", "\u0120=", "\u0120attribute", ".", "get", "Key", "();", "\u0120Object", "\u0120value", "\u0120=", "\u0120attribute", ".", "get", "Value", "();", "\u0120if", "\u0120(", "value", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120value", "\u0120=", "\u0120NS", "Key", "Value", "C", "oding", ".", "Null", "Value", ";", "\u0120}", "\u0120dict", ".", "put", "(", "key", ",", "\u0120value", ");", "\u0120}", "\u0120for", "\u0120(", "ER", "X", "Rest", "Request", "Node", "\u0120child", "\u0120:", "\u0120_", "children", ")", "\u0120{", "\u0120String", "\u0120name", "\u0120=", "\u0120child", ".", "name", "();", "\u0120Object", "\u0120value", "\u0120=", "\u0120child", ".", "to", "NS", "Collection", "(", "de", "legate", ",", "\u0120associated", "Object", "s", ");", "\u0120if", "\u0120(", "value", "\u0120!=", "\u0120NS", "Key", "Value", "C", "oding", ".", "Null", "Value", "\u0120||", "\u0120ER", "X", "Pro", "perties", ".", "bo", "olean", "For", "Key", "With", "Default", "(\"", "ER", "X", "Rest", ".", "include", "Null", "Values", "\",", "\u0120true", ")", "\u0120==", "\u0120true", ")", "\u0120{", "\u0120dict", ".", "put", "(", "name", ",", "\u0120value", ");", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "dict", ".", "is", "Empty", "())", "\u0120{", "\u0120result", "\u0120=", "\u0120NS", "Key", "Value", "C", "oding", ".", "Null", "Value", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120result", "\u0120=", "\u0120dict", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(_", "associated", "Object", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120associated", "Object", "s", ".", "put", "(_", "associated", "Object", ",", "\u0120result", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120result", ";", "\u0120}"], "docstring_tokens": ["_", "==", "\u0120true", "_", "\u0120part", "\u0120is", "\u0120not", "\u0120needed", "\u0120as", "\u0120boolean", "For", "Key", "With", "Default", "\u0120already", "\u0120returns", "\u0120a", "\u0120boolean", "\u0120;)"]}
{"function": "public User addUserToProject(final Project project, final Account account, final Role... userRoles) { notNull(project, \"project\"); notNull(account, \"account\"); notEmpty(account.getUri(), \"account.uri\"); notNull(userRoles, \"userRoles\"); validateRoleURIs(userRoles); noNullElements(Arrays.stream(userRoles).map(Role::getUri).collect(Collectors.toList()), \"userRoles.uri\"); notEmpty(project.getId(), \"project.id\"); final User user = new User(account, userRoles); doPostProjectUsersUpdate(project, user); return getUser(project, account); }", "text": "redundant check", "function_tokens": ["public", "\u0120User", "\u0120add", "User", "To", "Project", "(", "final", "\u0120Project", "\u0120project", ",", "\u0120final", "\u0120Account", "\u0120account", ",", "\u0120final", "\u0120Role", "...", "\u0120user", "R", "oles", ")", "\u0120{", "\u0120not", "Null", "(", "project", ",", "\u0120\"", "project", "\");", "\u0120not", "Null", "(", "account", ",", "\u0120\"", "account", "\");", "\u0120not", "Empty", "(", "account", ".", "get", "U", "ri", "(),", "\u0120\"", "account", ".", "uri", "\");", "\u0120not", "Null", "(", "user", "R", "oles", ",", "\u0120\"", "user", "R", "oles", "\");", "\u0120validate", "Role", "UR", "Is", "(", "user", "R", "oles", ");", "\u0120no", "Null", "E", "lements", "(", "Ar", "rays", ".", "stream", "(", "user", "R", "oles", ").", "map", "(", "Role", "::", "get", "U", "ri", ").", "collect", "(", "Collect", "ors", ".", "to", "List", "()", "),", "\u0120\"", "user", "R", "oles", ".", "uri", "\");", "\u0120not", "Empty", "(", "project", ".", "get", "Id", "(),", "\u0120\"", "project", ".", "id", "\");", "\u0120final", "\u0120User", "\u0120user", "\u0120=", "\u0120new", "\u0120User", "(", "account", ",", "\u0120user", "R", "oles", ");", "\u0120do", "Post", "Project", "Users", "Update", "(", "project", ",", "\u0120user", ");", "\u0120return", "\u0120get", "User", "(", "project", ",", "\u0120account", ");", "\u0120}"], "docstring_tokens": ["red", "und", "ant", "\u0120check"]}
{"function": "public void testDeadlock() throws Exception { doTest(1000 * 30); boolean interrupted = Thread.interrupted(); if (interrupted) { fail(\"Thread was interrupted at end of test\"); } }", "text": "Why not inline this variable?", "function_tokens": ["public", "\u0120void", "\u0120test", "Dead", "lock", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120do", "Test", "(", "1000", "\u0120*", "\u012030", ");", "\u0120boolean", "\u0120interrupted", "\u0120=", "\u0120Thread", ".", "interrupted", "();", "\u0120if", "\u0120(", "interrupted", ")", "\u0120{", "\u0120fail", "(\"", "Thread", "\u0120was", "\u0120interrupted", "\u0120at", "\u0120end", "\u0120of", "\u0120test", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120not", "\u0120inline", "\u0120this", "\u0120variable", "?"]}
{"function": "public void makeSortable() { final Map<ImageResource, Integer> imageWeightMap = new HashMap<ImageResource, Integer>(); imageWeightMap.put(statusCell.upImage, 0); imageWeightMap.put(statusCell.volumeSomeBricksDownImage, 1); imageWeightMap.put(statusCell.allBricksDownImage, 2); imageWeightMap.put(statusCell.downImage, 3); makeSortable(new Comparator<GlusterVolumeEntity>() { private final CustomStatusImageComaparator imageComparator = new CustomStatusImageComaparator(imageWeightMap); @Override public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) { return imageComparator.compare(statusCell.getStatusImage(statusCell.getVolumeStatus(o1)), statusCell.getStatusImage(statusCell.getVolumeStatus(o2))); } }); }", "text": "Are we recalculating the volume status here?", "function_tokens": ["public", "\u0120void", "\u0120make", "Sort", "able", "()", "\u0120{", "\u0120final", "\u0120Map", "<", "Image", "Resource", ",", "\u0120Integer", ">", "\u0120image", "Weight", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "Image", "Resource", ",", "\u0120Integer", ">", "();", "\u0120image", "Weight", "Map", ".", "put", "(", "status", "Cell", ".", "up", "Image", ",", "\u01200", ");", "\u0120image", "Weight", "Map", ".", "put", "(", "status", "Cell", ".", "volume", "Some", "B", "ricks", "Down", "Image", ",", "\u01201", ");", "\u0120image", "Weight", "Map", ".", "put", "(", "status", "Cell", ".", "all", "B", "ricks", "Down", "Image", ",", "\u01202", ");", "\u0120image", "Weight", "Map", ".", "put", "(", "status", "Cell", ".", "down", "Image", ",", "\u01203", ");", "\u0120make", "Sort", "able", "(", "new", "\u0120Compar", "ator", "<", "Gl", "uster", "Volume", "Entity", ">", "()", "\u0120{", "\u0120private", "\u0120final", "\u0120Custom", "Status", "Image", "Com", "ap", "ar", "ator", "\u0120image", "Compar", "ator", "\u0120=", "\u0120new", "\u0120Custom", "Status", "Image", "Com", "ap", "ar", "ator", "(", "image", "Weight", "Map", ");", "\u0120@", "Override", "\u0120public", "\u0120int", "\u0120compare", "(", "Gl", "uster", "Volume", "Entity", "\u0120o", "1", ",", "\u0120Gl", "uster", "Volume", "Entity", "\u0120o", "2", ")", "\u0120{", "\u0120return", "\u0120image", "Compar", "ator", ".", "comp", "are", "(", "status", "Cell", ".", "get", "Status", "Image", "(", "status", "Cell", ".", "get", "Volume", "Status", "(", "o", "1", ")),", "\u0120status", "Cell", ".", "get", "Status", "Image", "(", "status", "Cell", ".", "get", "Volume", "Status", "(", "o", "2", "))", ");", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["Are", "\u0120we", "\u0120recal", "cul", "ating", "\u0120the", "\u0120volume", "\u0120status", "\u0120here", "?"]}
{"function": "public GoldenEgg(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.ARTIFACT}, \"{2}\"); this.subtype.add(SubType.FOOD); this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1))); Ability ability = new AnyColorManaAbility(new GenericManaCost(1)); ability.addCost(new TapSourceCost()); ability.addCost(new SacrificeSourceCost()); this.addAbility(ability); Ability ability1 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(3), new ManaCostsImpl(\"{1}\")); ability1.addCost(new TapSourceCost()); ability1.addCost(new SacrificeSourceCost()); this.addAbility(ability1); }", "text": "Costs 2.", "function_tokens": ["public", "\u0120Golden", "E", "gg", "(", "U", "UID", "\u0120owner", "Id", ",", "\u0120Card", "Set", "Info", "\u0120set", "Info", ")", "\u0120{", "\u0120super", "(", "owner", "Id", ",", "\u0120set", "Info", ",", "\u0120new", "\u0120Card", "Type", "[]", "{", "Card", "Type", ".", "ART", "IF", "ACT", "},", "\u0120\"{", "2", "}", "\");", "\u0120this", ".", "sub", "type", ".", "add", "(", "Sub", "Type", ".", "FO", "OD", ");", "\u0120this", ".", "add", "Ability", "(", "new", "\u0120En", "ters", "Battle", "field", "Tr", "ig", "gered", "Ability", "(", "new", "\u0120Draw", "Card", "Source", "Controller", "Effect", "(", "1", "))", ");", "\u0120Ability", "\u0120ability", "\u0120=", "\u0120new", "\u0120Any", "Color", "M", "ana", "Ability", "(", "new", "\u0120Generic", "M", "ana", "Cost", "(", "1", "));", "\u0120ability", ".", "add", "Cost", "(", "new", "\u0120Tap", "Source", "Cost", "());", "\u0120ability", ".", "add", "Cost", "(", "new", "\u0120Sacrifice", "Source", "Cost", "());", "\u0120this", ".", "add", "Ability", "(", "ability", ");", "\u0120Ability", "\u0120ability", "1", "\u0120=", "\u0120new", "\u0120Simple", "Activ", "ated", "Ability", "(", "Zone", ".", "B", "ATTLE", "FIELD", ",", "\u0120new", "\u0120Gain", "Life", "Effect", "(", "3", "),", "\u0120new", "\u0120Mana", "Cost", "s", "Impl", "(\"", "{", "1", "}", "\")", ");", "\u0120ability", "1", ".", "add", "Cost", "(", "new", "\u0120Tap", "Source", "Cost", "());", "\u0120ability", "1", ".", "add", "Cost", "(", "new", "\u0120Sacrifice", "Source", "Cost", "());", "\u0120this", ".", "add", "Ability", "(", "ability", "1", ");", "\u0120}"], "docstring_tokens": ["Cost", "s", "\u01202", "."]}
{"function": "public void unparse(SqlWriter writer, int leftPrec, int rightPrec) { writer.keyword(\"CREATE\"); if (isTemporary()) { writer.keyword(\"TEMPORARY\"); } if (getReplace()) { writer.keyword(\"OR REPLACE\"); } writer.keyword(\"VIEW\"); if (isIfNotExists()) { writer.keyword(\"IF NOT EXISTS\"); } viewName.unparse(writer, leftPrec, rightPrec); if (fieldList.size() > 0) { fieldList.unparse(writer, 1, rightPrec); } if (comment != null) { writer.newlineAndIndent(); writer.keyword(\"COMMENT\"); comment.unparse(writer, leftPrec, rightPrec); } writer.newlineAndIndent(); writer.keyword(\"AS\"); writer.newlineAndIndent(); query.unparse(writer, leftPrec, rightPrec); }", "text": "remove this ?", "function_tokens": ["public", "\u0120void", "\u0120un", "parse", "(", "S", "ql", "Writer", "\u0120writer", ",", "\u0120int", "\u0120left", "Pre", "c", ",", "\u0120int", "\u0120right", "Pre", "c", ")", "\u0120{", "\u0120writer", ".", "key", "word", "(\"", "CRE", "ATE", "\");", "\u0120if", "\u0120(", "is", "Tem", "porary", "())", "\u0120{", "\u0120writer", ".", "key", "word", "(\"", "T", "EMP", "OR", "ARY", "\");", "\u0120}", "\u0120if", "\u0120(", "get", "Re", "place", "())", "\u0120{", "\u0120writer", ".", "key", "word", "(\"", "OR", "\u0120REPL", "ACE", "\");", "\u0120}", "\u0120writer", ".", "key", "word", "(\"", "VIEW", "\");", "\u0120if", "\u0120(", "is", "If", "Not", "Ex", "ists", "())", "\u0120{", "\u0120writer", ".", "key", "word", "(\"", "IF", "\u0120NOT", "\u0120EX", "IS", "TS", "\");", "\u0120}", "\u0120view", "Name", ".", "un", "parse", "(", "writer", ",", "\u0120left", "Pre", "c", ",", "\u0120right", "Pre", "c", ");", "\u0120if", "\u0120(", "field", "List", ".", "size", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120field", "List", ".", "un", "parse", "(", "writer", ",", "\u01201", ",", "\u0120right", "Pre", "c", ");", "\u0120}", "\u0120if", "\u0120(", "comment", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120writer", ".", "new", "line", "And", "Ind", "ent", "();", "\u0120writer", ".", "key", "word", "(\"", "COM", "MENT", "\");", "\u0120comment", ".", "un", "parse", "(", "writer", ",", "\u0120left", "Pre", "c", ",", "\u0120right", "Pre", "c", ");", "\u0120}", "\u0120writer", ".", "new", "line", "And", "Ind", "ent", "();", "\u0120writer", ".", "key", "word", "(\"", "AS", "\");", "\u0120writer", ".", "new", "line", "And", "Ind", "ent", "();", "\u0120query", ".", "un", "parse", "(", "writer", ",", "\u0120left", "Pre", "c", ",", "\u0120right", "Pre", "c", ");", "\u0120}"], "docstring_tokens": ["remove", "\u0120this", "\u0120?"]}
{"function": "public void testValidCRAMFileWithoutSeqDict() throws Exception { final SamReader samReader = SamReaderFactory. makeDefault(). validationStringency(ValidationStringency.SILENT). referenceSequence(new File(TEST_DATA_DIR, \"nm_tag_validation.fa\")). open(new File(TEST_DATA_DIR, \"nm_tag_validation.cram\")); final ReferenceSequenceFile reference = new FastaSequenceFile(new File(TEST_DATA_DIR, \"nm_tag_validation.fa\"), true); final Histogram<String> results = executeValidation(samReader, reference, IndexValidationStringency.EXHAUSTIVE); Assert.assertTrue(!results.isEmpty()); }", "text": "just to be sure there is no index/dictionary involved: final ReferenceSequenceFile reference = new FastaSequenceFile(new File(TEST_DATA_DIR, \"nm_tag_validation.fa\"), true); final SamReader samReader = SamReaderFactory. makeDefault(). validationStringency(ValidationStringency.SILENT). referenceSource(new ReferenceSource(reference)). ...", "function_tokens": ["public", "\u0120void", "\u0120test", "Valid", "CR", "AM", "File", "Without", "Se", "q", "D", "ict", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120Sam", "Reader", "\u0120sam", "Reader", "\u0120=", "\u0120Sam", "Reader", "Factory", ".", "\u0120make", "Default", "().", "\u0120validation", "String", "ency", "(", "Val", "idation", "String", "ency", ".", "S", "IL", "ENT", ").", "\u0120reference", "Sequ", "ence", "(", "new", "\u0120File", "(", "T", "EST", "_", "DATA", "_", "DIR", ",", "\u0120\"", "nm", "_", "tag", "_", "valid", "ation", ".", "fa", "\")", ").", "\u0120open", "(", "new", "\u0120File", "(", "T", "EST", "_", "DATA", "_", "DIR", ",", "\u0120\"", "nm", "_", "tag", "_", "valid", "ation", ".", "c", "ram", "\")", ");", "\u0120final", "\u0120Reference", "Sequ", "ence", "File", "\u0120reference", "\u0120=", "\u0120new", "\u0120Fast", "a", "Sequ", "ence", "File", "(", "new", "\u0120File", "(", "T", "EST", "_", "DATA", "_", "DIR", ",", "\u0120\"", "nm", "_", "tag", "_", "valid", "ation", ".", "fa", "\"),", "\u0120true", ");", "\u0120final", "\u0120Hist", "ogram", "<", "String", ">", "\u0120results", "\u0120=", "\u0120execute", "Val", "idation", "(", "sam", "Reader", ",", "\u0120reference", ",", "\u0120Index", "Val", "idation", "String", "ency", ".", "EX", "HA", "UST", "IVE", ");", "\u0120Ass", "ert", ".", "assert", "True", "(", "!", "results", ".", "is", "Empty", "());", "\u0120}"], "docstring_tokens": ["just", "\u0120to", "\u0120be", "\u0120sure", "\u0120there", "\u0120is", "\u0120no", "\u0120index", "/", "d", "ictionary", "\u0120involved", ":", "\u0120final", "\u0120Reference", "Sequ", "ence", "File", "\u0120reference", "\u0120=", "\u0120new", "\u0120Fast", "a", "Sequ", "ence", "File", "(", "new", "\u0120File", "(", "T", "EST", "_", "DATA", "_", "DIR", ",", "\u0120\"", "nm", "_", "tag", "_", "valid", "ation", ".", "fa", "\"),", "\u0120true", ");", "\u0120final", "\u0120Sam", "Reader", "\u0120sam", "Reader", "\u0120=", "\u0120Sam", "Reader", "Factory", ".", "\u0120make", "Default", "().", "\u0120validation", "String", "ency", "(", "Val", "idation", "String", "ency", ".", "S", "IL", "ENT", ").", "\u0120reference", "Source", "(", "new", "\u0120Reference", "Source", "(", "reference", ")).", "\u0120..."]}
{"function": "public void cleanup() { if (model != null) { model.cleanup(); model = null; } if (modelItems != null) { for (T model: modelItems) { if (model instanceof HasCleanup) { ((HasCleanup)model).cleanup(); } } } for (Pair<T, V> item : items) { T value = item.getFirst(); if (!isGhost(value)) { if (item instanceof HasCleanup) { ((HasCleanup)value).cleanup(); } } } cleanContentPanel(); }", "text": "Yes had that on my to do list, but missed it.", "function_tokens": ["public", "\u0120void", "\u0120cleanup", "()", "\u0120{", "\u0120if", "\u0120(", "model", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120model", ".", "clean", "up", "();", "\u0120model", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120if", "\u0120(", "model", "Items", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "T", "\u0120model", ":", "\u0120model", "Items", ")", "\u0120{", "\u0120if", "\u0120(", "model", "\u0120instance", "of", "\u0120Has", "Clean", "up", ")", "\u0120{", "\u0120((", "Has", "Clean", "up", ")", "model", ").", "clean", "up", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "P", "air", "<", "T", ",", "\u0120V", ">", "\u0120item", "\u0120:", "\u0120items", ")", "\u0120{", "\u0120T", "\u0120value", "\u0120=", "\u0120item", ".", "get", "First", "();", "\u0120if", "\u0120(!", "is", "Ghost", "(", "value", "))", "\u0120{", "\u0120if", "\u0120(", "item", "\u0120instance", "of", "\u0120Has", "Clean", "up", ")", "\u0120{", "\u0120((", "Has", "Clean", "up", ")", "value", ").", "clean", "up", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120clean", "Content", "Panel", "();", "\u0120}"], "docstring_tokens": ["Yes", "\u0120had", "\u0120that", "\u0120on", "\u0120my", "\u0120to", "\u0120do", "\u0120list", ",", "\u0120but", "\u0120missed", "\u0120it", "."]}
{"function": "public String get(String name) { return (isSet(name)) ? myRecord.get(name) : new String(); }", "text": "just return \"\" instead of new String()", "function_tokens": ["public", "\u0120String", "\u0120get", "(", "String", "\u0120name", ")", "\u0120{", "\u0120return", "\u0120(", "is", "Set", "(", "name", "))", "\u0120?", "\u0120my", "Record", ".", "get", "(", "name", ")", "\u0120:", "\u0120new", "\u0120String", "();", "\u0120}"], "docstring_tokens": ["just", "\u0120return", "\u0120\"\"", "\u0120instead", "\u0120of", "\u0120new", "\u0120String", "()"]}
{"function": "private void updateMutePreviewOverlayVisibility() { mutePreviewOverlay.setVisibility( showMuteOverlayOnVideoCall() && muteButton.isChecked() && !isInGreenScreenMode ? View.VISIBLE : View.GONE); }", "text": "Just a tiny thing, I guess we can move the condition to an assign statement, it could be easier to read since the conditional expression is quite complex now. int mutePreviewOverlayVisibility = showMuteOverlayOnVideoCall() && muteButton.isChecked() && !isInGreenScreenMode ? View.VISIBLE : View.GONE; mutePreviewOverlay.setVisibility(mutePreviewOverlayVisibility);", "function_tokens": ["private", "\u0120void", "\u0120update", "M", "ute", "Preview", "Over", "lay", "Vis", "ibility", "()", "\u0120{", "\u0120mute", "Preview", "Over", "lay", ".", "set", "Vis", "ibility", "(", "\u0120show", "M", "ute", "Over", "lay", "On", "Video", "Call", "()", "\u0120&&", "\u0120mute", "Button", ".", "is", "Check", "ed", "()", "\u0120&&", "\u0120!", "is", "In", "Green", "Screen", "Mode", "\u0120?", "\u0120View", ".", "VIS", "IBLE", "\u0120:", "\u0120View", ".", "G", "ONE", ");", "\u0120}"], "docstring_tokens": ["Just", "\u0120a", "\u0120tiny", "\u0120thing", ",", "\u0120I", "\u0120guess", "\u0120we", "\u0120can", "\u0120move", "\u0120the", "\u0120condition", "\u0120to", "\u0120an", "\u0120assign", "\u0120statement", ",", "\u0120it", "\u0120could", "\u0120be", "\u0120easier", "\u0120to", "\u0120read", "\u0120since", "\u0120the", "\u0120conditional", "\u0120expression", "\u0120is", "\u0120quite", "\u0120complex", "\u0120now", ".", "\u0120int", "\u0120mute", "Preview", "Over", "lay", "Vis", "ibility", "\u0120=", "\u0120show", "M", "ute", "Over", "lay", "On", "Video", "Call", "()", "\u0120&&", "\u0120mute", "Button", ".", "is", "Check", "ed", "()", "\u0120&&", "\u0120!", "is", "In", "Green", "Screen", "Mode", "\u0120?", "\u0120View", ".", "VIS", "IBLE", "\u0120:", "\u0120View", ".", "G", "ONE", ";", "\u0120mute", "Preview", "Over", "lay", ".", "set", "Vis", "ibility", "(", "m", "ute", "Preview", "Over", "lay", "Vis", "ibility", ");"]}
{"function": "public void resetAllResponses() { for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) { questionResponseBundle.putIfAbsent(question, new ArrayList<>()); } }", "text": "emmmm i dont feel this replacement is necessary...and it might change what the code intends to do, as put will replace the value corresponding to the question even if the question is already associated with a value, but putIfAbsent only associate question with the new ArrayList<>() if the question is not associated to anything.", "function_tokens": ["public", "\u0120void", "\u0120reset", "All", "Resp", "ons", "es", "()", "\u0120{", "\u0120for", "\u0120(", "Feed", "back", "Question", "Attributes", "\u0120question", "\u0120:", "\u0120question", "Response", "B", "undle", ".", "key", "Set", "())", "\u0120{", "\u0120question", "Response", "B", "undle", ".", "put", "If", "Abs", "ent", "(", "question", ",", "\u0120new", "\u0120Array", "List", "<", ">", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["em", "mmm", "\u0120i", "\u0120dont", "\u0120feel", "\u0120this", "\u0120replacement", "\u0120is", "\u0120necessary", "...", "and", "\u0120it", "\u0120might", "\u0120change", "\u0120what", "\u0120the", "\u0120code", "\u0120intends", "\u0120to", "\u0120do", ",", "\u0120as", "\u0120put", "\u0120will", "\u0120replace", "\u0120the", "\u0120value", "\u0120corresponding", "\u0120to", "\u0120the", "\u0120question", "\u0120even", "\u0120if", "\u0120the", "\u0120question", "\u0120is", "\u0120already", "\u0120associated", "\u0120with", "\u0120a", "\u0120value", ",", "\u0120but", "\u0120put", "If", "Abs", "ent", "\u0120only", "\u0120associate", "\u0120question", "\u0120with", "\u0120the", "\u0120new", "\u0120Array", "List", "<", ">", "()", "\u0120if", "\u0120the", "\u0120question", "\u0120is", "\u0120not", "\u0120associated", "\u0120to", "\u0120anything", "."]}
{"function": "protected URLConnection getExternalGraphic(AjaxRequestTarget target, Form<?> form) { onlineResource.processInput(); if (onlineResource.getModelObject() != null) { URL url = null; try { String baseUrl = baseURL(form); String external = onlineResource.getModelObject().toString(); URI uri = new URI( external ); if( uri.isAbsolute() ){ url = uri.toURL(); if( !external.startsWith(baseUrl)){ form.warn( \"Recommend use of styles directory at \"+baseUrl); } } else { url = new URL( baseUrl + \"styles/\"+external ); } URLConnection conn = url.openConnection(); if(\"text/html\".equals(conn.getContentType())){ form.error(\"Unable to access url\"); return null; } return conn; } catch (FileNotFoundException notFound ){ form.error( \"Unable to access \"+url); } catch (Exception e) { e.printStackTrace(); form.error( \"Recommend use of styles directory at \"+e); } } return null; }", "text": "This logic changes a bit due to <LINK_0>", "function_tokens": ["protected", "\u0120URL", "Connection", "\u0120get", "External", "G", "raphic", "(", "A", "j", "ax", "Request", "Target", "\u0120target", ",", "\u0120Form", "<?", ">", "\u0120form", ")", "\u0120{", "\u0120online", "Resource", ".", "process", "Input", "();", "\u0120if", "\u0120(", "online", "Resource", ".", "get", "Model", "Object", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120URL", "\u0120url", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120String", "\u0120base", "Url", "\u0120=", "\u0120base", "URL", "(", "form", ");", "\u0120String", "\u0120external", "\u0120=", "\u0120online", "Resource", ".", "get", "Model", "Object", "().", "to", "String", "();", "\u0120URI", "\u0120ur", "i", "\u0120=", "\u0120new", "\u0120URI", "(", "\u0120external", "\u0120);", "\u0120if", "(", "\u0120ur", "i", ".", "is", "Abs", "olute", "()", "\u0120)", "{", "\u0120url", "\u0120=", "\u0120ur", "i", ".", "to", "URL", "();", "\u0120if", "(", "\u0120!", "external", ".", "st", "arts", "With", "(", "base", "Url", "))", "{", "\u0120form", ".", "warn", "(", "\u0120\"", "Recommend", "\u0120use", "\u0120of", "\u0120styles", "\u0120directory", "\u0120at", "\u0120\"+", "base", "Url", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120url", "\u0120=", "\u0120new", "\u0120URL", "(", "\u0120base", "Url", "\u0120+", "\u0120\"", "styles", "/\"", "+", "external", "\u0120);", "\u0120}", "\u0120URL", "Connection", "\u0120conn", "\u0120=", "\u0120url", ".", "open", "Connection", "();", "\u0120if", "(\"", "text", "/", "html", "\".", "equ", "als", "(", "conn", ".", "get", "Content", "Type", "()", "))", "{", "\u0120form", ".", "error", "(\"", "Un", "able", "\u0120to", "\u0120access", "\u0120url", "\");", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120return", "\u0120conn", ";", "\u0120}", "\u0120catch", "\u0120(", "File", "Not", "Found", "Exception", "\u0120not", "Found", "\u0120)", "{", "\u0120form", ".", "error", "(", "\u0120\"", "Un", "able", "\u0120to", "\u0120access", "\u0120\"+", "url", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120form", ".", "error", "(", "\u0120\"", "Recommend", "\u0120use", "\u0120of", "\u0120styles", "\u0120directory", "\u0120at", "\u0120\"+", "e", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120logic", "\u0120changes", "\u0120a", "\u0120bit", "\u0120due", "\u0120to", "\u0120<", "L", "INK", "_", "0", ">"]}
{"function": "private void loadButtonAction(ActionEvent e) { progressDialog = new ProgressDialog(list.getParent()); if (dbpath == SELECT_OPTION) { File dir = selectDirectory(); if (dir == null) { return; } } dbload.restart(); }", "text": "If dir is not to be used anywhere, you might as well do if (selectDirectory() == null)", "function_tokens": ["private", "\u0120void", "\u0120load", "Button", "Action", "(", "Action", "Event", "\u0120e", ")", "\u0120{", "\u0120progress", "Dialog", "\u0120=", "\u0120new", "\u0120Progress", "Dialog", "(", "list", ".", "get", "Parent", "());", "\u0120if", "\u0120(", "db", "path", "\u0120==", "\u0120SELECT", "_", "OP", "TION", ")", "\u0120{", "\u0120File", "\u0120dir", "\u0120=", "\u0120select", "Directory", "();", "\u0120if", "\u0120(", "dir", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120db", "load", ".", "rest", "art", "();", "\u0120}"], "docstring_tokens": ["If", "\u0120dir", "\u0120is", "\u0120not", "\u0120to", "\u0120be", "\u0120used", "\u0120anywhere", ",", "\u0120you", "\u0120might", "\u0120as", "\u0120well", "\u0120do", "\u0120if", "\u0120(", "select", "Directory", "()", "\u0120==", "\u0120null", ")"]}
{"function": "public Single<String> getP18ForItem(String entityId) { return depictsInterface.getLabelForEntity(entityId) .map(response -> { String name; try { JsonObject claims = response.getAsJsonObject(\"claims\").getAsJsonObject(); JsonObject P18 = claims.get(\"P18\").getAsJsonArray().get(0).getAsJsonObject(); JsonObject mainsnak = P18.get(\"mainsnak\").getAsJsonObject(); JsonObject datavalue = mainsnak.get(\"datavalue\").getAsJsonObject(); JsonPrimitive value = datavalue.get(\"value\").getAsJsonPrimitive(); name = value.toString(); name = name.substring(1, name.length() - 1); } catch (Exception e) { name=\"\"; } if (!name.isEmpty()){ return getImageUrl(name); } else return \"No Image for Depiction\"; }) .singleOrError(); }", "text": "Java convention for a variable says it should be p18 lowercase.", "function_tokens": ["public", "\u0120Single", "<", "String", ">", "\u0120get", "P", "18", "For", "Item", "(", "String", "\u0120entity", "Id", ")", "\u0120{", "\u0120return", "\u0120depicts", "Interface", ".", "get", "Label", "For", "Entity", "(", "entity", "Id", ")", "\u0120.", "map", "(", "response", "\u0120->", "\u0120{", "\u0120String", "\u0120name", ";", "\u0120try", "\u0120{", "\u0120J", "son", "Object", "\u0120claims", "\u0120=", "\u0120response", ".", "get", "As", "J", "son", "Object", "(\"", "claim", "s", "\").", "get", "As", "J", "son", "Object", "();", "\u0120J", "son", "Object", "\u0120P", "18", "\u0120=", "\u0120claims", ".", "get", "(\"", "P", "18", "\").", "get", "As", "J", "son", "Array", "().", "get", "(", "0", ").", "get", "As", "J", "son", "Object", "();", "\u0120J", "son", "Object", "\u0120m", "ains", "n", "ak", "\u0120=", "\u0120P", "18", ".", "get", "(\"", "m", "ains", "n", "ak", "\").", "get", "As", "J", "son", "Object", "();", "\u0120J", "son", "Object", "\u0120dat", "aval", "ue", "\u0120=", "\u0120m", "ains", "n", "ak", ".", "get", "(\"", "dat", "aval", "ue", "\").", "get", "As", "J", "son", "Object", "();", "\u0120J", "son", "Prim", "itive", "\u0120value", "\u0120=", "\u0120dat", "aval", "ue", ".", "get", "(\"", "value", "\").", "get", "As", "J", "son", "Prim", "itive", "();", "\u0120name", "\u0120=", "\u0120value", ".", "to", "String", "();", "\u0120name", "\u0120=", "\u0120name", ".", "sub", "string", "(", "1", ",", "\u0120name", ".", "length", "()", "\u0120-", "\u01201", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120name", "=\"", "\";", "\u0120}", "\u0120if", "\u0120(!", "name", ".", "is", "Empty", "()", "){", "\u0120return", "\u0120get", "Image", "Url", "(", "name", ");", "\u0120}", "\u0120else", "\u0120return", "\u0120\"", "No", "\u0120Image", "\u0120for", "\u0120Dep", "iction", "\";", "\u0120})", "\u0120.", "single", "Or", "Error", "();", "\u0120}"], "docstring_tokens": ["Java", "\u0120convention", "\u0120for", "\u0120a", "\u0120variable", "\u0120says", "\u0120it", "\u0120should", "\u0120be", "\u0120p", "18", "\u0120lower", "case", "."]}
{"function": "public String getServerState() { this.officeServer.refreshState(); return contextualLocalizationManager.getTranslationPlain( TRANSLATION_KEY_SERVER_STATE_PREFIX + this.officeServer.getState().name().toLowerCase()); }", "text": "Small detail: missing this.. See the line you replaced for ex.", "function_tokens": ["public", "\u0120String", "\u0120get", "Server", "State", "()", "\u0120{", "\u0120this", ".", "office", "Server", ".", "ref", "resh", "State", "();", "\u0120return", "\u0120contextual", "Local", "ization", "Manager", ".", "get", "Translation", "Pl", "ain", "(", "\u0120TRAN", "SL", "ATION", "_", "KEY", "_", "SER", "VER", "_", "STATE", "_", "P", "REF", "IX", "\u0120+", "\u0120this", ".", "office", "Server", ".", "get", "State", "().", "name", "().", "to", "Lower", "Case", "());", "\u0120}"], "docstring_tokens": ["Small", "\u0120detail", ":", "\u0120missing", "\u0120this", "..", "\u0120See", "\u0120the", "\u0120line", "\u0120you", "\u0120replaced", "\u0120for", "\u0120ex", "."]}
{"function": "public void visitToken(DetailAST token) { switch (token.getType()) { case TokenTypes.INTERFACE_DEF: checkServiceInterface(token); break; default: break; } }", "text": "There is just one case here. We can replace this switch statement with if.", "function_tokens": ["public", "\u0120void", "\u0120visit", "Token", "(", "Det", "ail", "AST", "\u0120token", ")", "\u0120{", "\u0120switch", "\u0120(", "token", ".", "get", "Type", "())", "\u0120{", "\u0120case", "\u0120Token", "Types", ".", "INTER", "FACE", "_", "DEF", ":", "\u0120check", "Service", "Interface", "(", "token", ");", "\u0120break", ";", "\u0120default", ":", "\u0120break", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["There", "\u0120is", "\u0120just", "\u0120one", "\u0120case", "\u0120here", ".", "\u0120We", "\u0120can", "\u0120replace", "\u0120this", "\u0120switch", "\u0120statement", "\u0120with", "\u0120if", "."]}
{"function": "public DeCoupleMBusDeviceCommandExecutor() { super(MbusChannelElementsDto.class); }", "text": "The class passed on to the super constructor shouldn't be MbusChannelElementsDto. I think the cleanest would be to pass DecoupleMbusDto.class (and make DecoupleMbusDto implement ActionRequestDto).", "function_tokens": ["public", "\u0120De", "C", "ouple", "MB", "us", "Device", "Command", "Exec", "utor", "()", "\u0120{", "\u0120super", "(", "M", "bus", "Channel", "E", "lements", "D", "to", ".", "class", ");", "\u0120}"], "docstring_tokens": ["The", "\u0120class", "\u0120passed", "\u0120on", "\u0120to", "\u0120the", "\u0120super", "\u0120constructor", "\u0120shouldn", "'t", "\u0120be", "\u0120M", "bus", "Channel", "E", "lements", "D", "to", ".", "\u0120I", "\u0120think", "\u0120the", "\u0120clean", "est", "\u0120would", "\u0120be", "\u0120to", "\u0120pass", "\u0120Dec", "ouple", "M", "bus", "D", "to", ".", "class", "\u0120(", "and", "\u0120make", "\u0120Dec", "ouple", "M", "bus", "D", "to", "\u0120implement", "\u0120Action", "Request", "D", "to", ")."]}
{"function": "public ServerWebSocketInitializer(final ServerInfo serverInfo) { LOG.info(\"Currently time out time is not used \" + serverInfo.getTimeOut()); this.serverInfo = serverInfo; connectionServer = createServerSocket(); manager = createConnectionManager(getServerInfo()); }", "text": "Colon after \"used\"", "function_tokens": ["public", "\u0120Server", "Web", "Socket", "Initial", "izer", "(", "final", "\u0120Server", "Info", "\u0120server", "Info", ")", "\u0120{", "\u0120LOG", ".", "info", "(\"", "Currently", "\u0120time", "\u0120out", "\u0120time", "\u0120is", "\u0120not", "\u0120used", "\u0120\"", "\u0120+", "\u0120server", "Info", ".", "get", "Time", "Out", "());", "\u0120this", ".", "server", "Info", "\u0120=", "\u0120server", "Info", ";", "\u0120connection", "Server", "\u0120=", "\u0120create", "Server", "Socket", "();", "\u0120manager", "\u0120=", "\u0120create", "Connection", "Manager", "(", "get", "Server", "Info", "());", "\u0120}"], "docstring_tokens": ["Col", "on", "\u0120after", "\u0120\"", "used", "\""]}
{"function": "public ArrayList<OncoTreeNode> getOncoTree(Version version) throws TopBraidException { ArrayList<OncoTreeNode> list = new ArrayList<OncoTreeNode>(super.query(String.format(query, version.getGraphURI()), new ParameterizedTypeReference<List<OncoTreeNode>>(){})); return list; }", "text": "I guess getOncoTree() returns List<OncoTreeNode> and we must return ArrayList<OncoTreeNode> ? Still, we don't really need to create a named variable here .. we could do: return new ArrayList<OncoTreeNode>(super.query ....", "function_tokens": ["public", "\u0120Array", "List", "<", "On", "co", "Tree", "Node", ">", "\u0120get", "On", "co", "Tree", "(", "Version", "\u0120version", ")", "\u0120throws", "\u0120Top", "B", "raid", "Exception", "\u0120{", "\u0120Array", "List", "<", "On", "co", "Tree", "Node", ">", "\u0120list", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "On", "co", "Tree", "Node", ">(", "super", ".", "query", "(", "String", ".", "format", "(", "query", ",", "\u0120version", ".", "get", "Graph", "URI", "()", "),", "\u0120new", "\u0120Param", "eter", "ized", "Type", "Reference", "<", "List", "<", "On", "co", "Tree", "Node", ">>", "(){", "}", "));", "\u0120return", "\u0120list", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120guess", "\u0120get", "On", "co", "Tree", "()", "\u0120returns", "\u0120List", "<", "On", "co", "Tree", "Node", ">", "\u0120and", "\u0120we", "\u0120must", "\u0120return", "\u0120Array", "List", "<", "On", "co", "Tree", "Node", ">", "\u0120?", "\u0120Still", ",", "\u0120we", "\u0120don", "'t", "\u0120really", "\u0120need", "\u0120to", "\u0120create", "\u0120a", "\u0120named", "\u0120variable", "\u0120here", "\u0120..", "\u0120we", "\u0120could", "\u0120do", ":", "\u0120return", "\u0120new", "\u0120Array", "List", "<", "On", "co", "Tree", "Node", ">(", "super", ".", "query", "\u0120...."]}
{"function": "public void doSample() { sendData(pm.isScreenOn()?\"on\":\"off\"); }", "text": "@orhan89 while you're add it, could you do a API version check and use isInteractive() if available?<LINK_0>", "function_tokens": ["public", "\u0120void", "\u0120do", "Sample", "()", "\u0120{", "\u0120send", "Data", "(", "pm", ".", "is", "Screen", "On", "()", "?\"", "on", "\":\"", "off", "\");", "\u0120}"], "docstring_tokens": ["@", "or", "han", "89", "\u0120while", "\u0120you", "'re", "\u0120add", "\u0120it", ",", "\u0120could", "\u0120you", "\u0120do", "\u0120a", "\u0120API", "\u0120version", "\u0120check", "\u0120and", "\u0120use", "\u0120is", "Inter", "active", "()", "\u0120if", "\u0120available", "?", "<", "L", "INK", "_", "0", ">"]}
{"function": "public Configuration setDefaults(Configuration defaults) { this.defaults = defaults; return this; }", "text": "I suggest to check defaults != this before setting.", "function_tokens": ["public", "\u0120Configuration", "\u0120set", "Def", "aults", "(", "Configuration", "\u0120defaults", ")", "\u0120{", "\u0120this", ".", "default", "s", "\u0120=", "\u0120defaults", ";", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120suggest", "\u0120to", "\u0120check", "\u0120defaults", "\u0120!=", "\u0120this", "\u0120before", "\u0120setting", "."]}
{"function": "public void refreshMetadata(String username) { if (mNosaraClient == null) { return; } if (!TextUtils.isEmpty(username)) { mUserName = username; if (getAnonID() != null) { mNosaraClient.trackAliasUser(mUserName, getAnonID()); clearAnonID(); } } else { mUserName = null; if (getAnonID() == null) { generateNewAnonID(); } } }", "text": "There is a problem here :cry: :disappointed: We need to change the library since trackaliasUser uses TracksClient.NosaraUserType.WPCOM (wpcom:user_id) internally. We should add another trackaliasUser method that takes the userType parameter....", "function_tokens": ["public", "\u0120void", "\u0120refresh", "Met", "adata", "(", "String", "\u0120username", ")", "\u0120{", "\u0120if", "\u0120(", "m", "N", "os", "ara", "Client", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(!", "Text", "Ut", "ils", ".", "is", "Empty", "(", "username", "))", "\u0120{", "\u0120m", "User", "Name", "\u0120=", "\u0120username", ";", "\u0120if", "\u0120(", "get", "An", "on", "ID", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120m", "N", "os", "ara", "Client", ".", "track", "Alias", "User", "(", "m", "User", "Name", ",", "\u0120get", "An", "on", "ID", "());", "\u0120clear", "An", "on", "ID", "();", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120m", "User", "Name", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "get", "An", "on", "ID", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120generate", "New", "An", "on", "ID", "();", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["There", "\u0120is", "\u0120a", "\u0120problem", "\u0120here", "\u0120:", "cry", ":", "\u0120:", "dis", "appointed", ":", "\u0120We", "\u0120need", "\u0120to", "\u0120change", "\u0120the", "\u0120library", "\u0120since", "\u0120track", "alias", "User", "\u0120uses", "\u0120Tracks", "Client", ".", "N", "os", "ara", "User", "Type", ".", "W", "PC", "OM", "\u0120(", "wp", "com", ":", "user", "_", "id", ")", "\u0120internally", ".", "\u0120We", "\u0120should", "\u0120add", "\u0120another", "\u0120track", "alias", "User", "\u0120method", "\u0120that", "\u0120takes", "\u0120the", "\u0120user", "Type", "\u0120parameter", "...."]}
{"function": "private void removeHiddenInstructors(FeedbackQuestionAttributes question, List<FeedbackResponseAttributes> responses, Map<String, String> recipients, Set<String> hiddenInstructorEmails) { boolean noChangeRequired = hiddenInstructorEmails == null || hiddenInstructorEmails.isEmpty() || question.getRecipientType() != FeedbackParticipantType.INSTRUCTORS; if (noChangeRequired) { return; } for (String instructorEmail : hiddenInstructorEmails) { if (recipients.containsKey(instructorEmail)) { recipients.remove(instructorEmail); } Iterator<FeedbackResponseAttributes> iterResponse = responses.iterator(); while (iterResponse.hasNext()) { FeedbackResponseAttributes response = iterResponse.next(); if (response.recipientEmail.equals(instructorEmail)) { iterResponse.remove(); } } } }", "text": "@unyoungwax, oops missed this, but consider prefixing this boolean with <code>is...</code>", "function_tokens": ["private", "\u0120void", "\u0120remove", "Hidden", "Instruct", "ors", "(", "Feed", "back", "Question", "Attributes", "\u0120question", ",", "\u0120List", "<", "Feed", "back", "Response", "Attributes", ">", "\u0120responses", ",", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120recipients", ",", "\u0120Set", "<", "String", ">", "\u0120hidden", "Instruct", "or", "Em", "ails", ")", "\u0120{", "\u0120boolean", "\u0120no", "Change", "Required", "\u0120=", "\u0120hidden", "Instruct", "or", "Em", "ails", "\u0120==", "\u0120null", "\u0120||", "\u0120hidden", "Instruct", "or", "Em", "ails", ".", "is", "Empty", "()", "\u0120||", "\u0120question", ".", "get", "Rec", "ipient", "Type", "()", "\u0120!=", "\u0120Feedback", "Particip", "ant", "Type", ".", "IN", "STRUCT", "ORS", ";", "\u0120if", "\u0120(", "no", "Change", "Required", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120for", "\u0120(", "String", "\u0120instructor", "Email", "\u0120:", "\u0120hidden", "Instruct", "or", "Em", "ails", ")", "\u0120{", "\u0120if", "\u0120(", "rec", "ip", "ients", ".", "cont", "ains", "Key", "(", "in", "struct", "or", "Email", "))", "\u0120{", "\u0120recipients", ".", "remove", "(", "in", "struct", "or", "Email", ");", "\u0120}", "\u0120Iter", "ator", "<", "Feed", "back", "Response", "Attributes", ">", "\u0120iter", "Response", "\u0120=", "\u0120responses", ".", "iterator", "();", "\u0120while", "\u0120(", "iter", "Response", ".", "has", "Next", "())", "\u0120{", "\u0120Feedback", "Response", "Attributes", "\u0120response", "\u0120=", "\u0120iter", "Response", ".", "next", "();", "\u0120if", "\u0120(", "response", ".", "rec", "ipient", "Email", ".", "equ", "als", "(", "in", "struct", "or", "Email", "))", "\u0120{", "\u0120iter", "Response", ".", "remove", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "un", "young", "w", "ax", ",", "\u0120o", "ops", "\u0120missed", "\u0120this", ",", "\u0120but", "\u0120consider", "\u0120prefix", "ing", "\u0120this", "\u0120boolean", "\u0120with", "\u0120<", "code", ">", "is", "...", "</", "code", ">"]}
{"function": "private void cancelUpload(int localMediaId) { if (mCurrentUpload != null && mCurrentUpload.getId() == localMediaId) { cancelCurrentUpload(); } for(Iterator<MediaModel> i = mQueue.iterator(); i.hasNext();) { MediaModel mediaModel = i.next(); if (mediaModel.getId() == localMediaId) { i.remove(); } } }", "text": "nitpicking: would be nice to break from the loop here", "function_tokens": ["private", "\u0120void", "\u0120cancel", "Upload", "(", "int", "\u0120local", "Media", "Id", ")", "\u0120{", "\u0120if", "\u0120(", "m", "Current", "Upload", "\u0120!=", "\u0120null", "\u0120&&", "\u0120m", "Current", "Upload", ".", "get", "Id", "()", "\u0120==", "\u0120local", "Media", "Id", ")", "\u0120{", "\u0120cancel", "Current", "Upload", "();", "\u0120}", "\u0120for", "(", "Iterator", "<", "Media", "Model", ">", "\u0120i", "\u0120=", "\u0120m", "Queue", ".", "iterator", "();", "\u0120i", ".", "has", "Next", "();", ")", "\u0120{", "\u0120Media", "Model", "\u0120media", "Model", "\u0120=", "\u0120i", ".", "next", "();", "\u0120if", "\u0120(", "media", "Model", ".", "get", "Id", "()", "\u0120==", "\u0120local", "Media", "Id", ")", "\u0120{", "\u0120i", ".", "remove", "();", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["nit", "picking", ":", "\u0120would", "\u0120be", "\u0120nice", "\u0120to", "\u0120break", "\u0120from", "\u0120the", "\u0120loop", "\u0120here"]}
{"function": "MergingUpdater(AbstractTripleStore database) { this.database = database; String property = System.getProperty(\"outputDumps\"); outputDumps = Boolean.TRUE.toString().equals(property); id = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); }", "text": "configuration should be injected, not read from system properties in the constructor.", "function_tokens": ["Mer", "ging", "Up", "d", "ater", "(", "Abstract", "Tri", "ple", "Store", "\u0120database", ")", "\u0120{", "\u0120this", ".", "database", "\u0120=", "\u0120database", ";", "\u0120String", "\u0120property", "\u0120=", "\u0120System", ".", "get", "Property", "(\"", "output", "D", "umps", "\");", "\u0120output", "D", "umps", "\u0120=", "\u0120Boolean", ".", "TR", "UE", ".", "to", "String", "().", "equ", "als", "(", "property", ");", "\u0120id", "\u0120=", "\u0120U", "UID", ".", "random", "U", "UID", "().", "to", "String", "().", "replace", "All", "(\"", "-", "\",", "\u0120\"\"", ");", "\u0120}"], "docstring_tokens": ["config", "uration", "\u0120should", "\u0120be", "\u0120injected", ",", "\u0120not", "\u0120read", "\u0120from", "\u0120system", "\u0120properties", "\u0120in", "\u0120the", "\u0120constructor", "."]}
{"function": "protected org.spine3.server.storage.EventStorage createStorage(StorageFactory factory) { final RecordStorage<EventId> recordStorage = super.createStorage(factory); final org.spine3.server.storage.EventStorage storage = factory.createEventStorage(recordStorage); return storage; }", "text": "Let's avoid FQNs as much as we can.", "function_tokens": ["protected", "\u0120org", ".", "sp", "ine", "3", ".", "server", ".", "storage", ".", "Event", "Storage", "\u0120create", "Storage", "(", "Storage", "Factory", "\u0120factory", ")", "\u0120{", "\u0120final", "\u0120Record", "Storage", "<", "Event", "Id", ">", "\u0120record", "Storage", "\u0120=", "\u0120super", ".", "create", "Storage", "(", "f", "actory", ");", "\u0120final", "\u0120org", ".", "sp", "ine", "3", ".", "server", ".", "storage", ".", "Event", "Storage", "\u0120storage", "\u0120=", "\u0120factory", ".", "create", "Event", "Storage", "(", "record", "Storage", ");", "\u0120return", "\u0120storage", ";", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120avoid", "\u0120F", "Q", "Ns", "\u0120as", "\u0120much", "\u0120as", "\u0120we", "\u0120can", "."]}
{"function": "public int getLength() { Widget widget = getWidget(); int childCount = 0; if (widget instanceof Composite) { childCount = ((Composite) widget).getChildren().length; if (widget instanceof CTabFolder) { for (CTabItem tabItem : ((CTabFolder) widget).getItems()) { if (tabItem.isDisposed()) { System.err.println(\"CTabItem was disposed\"); break; } else { childCount++; } } } } return childCount; }", "text": "The syserr should come out.", "function_tokens": ["public", "\u0120int", "\u0120get", "Length", "()", "\u0120{", "\u0120W", "idget", "\u0120widget", "\u0120=", "\u0120get", "Widget", "();", "\u0120int", "\u0120child", "Count", "\u0120=", "\u01200", ";", "\u0120if", "\u0120(", "widget", "\u0120instance", "of", "\u0120Composite", ")", "\u0120{", "\u0120child", "Count", "\u0120=", "\u0120((", "Com", "pos", "ite", ")", "\u0120widget", ").", "get", "Children", "().", "length", ";", "\u0120if", "\u0120(", "widget", "\u0120instance", "of", "\u0120CT", "ab", "Folder", ")", "\u0120{", "\u0120for", "\u0120(", "CT", "ab", "Item", "\u0120tab", "Item", "\u0120:", "\u0120((", "CT", "ab", "Folder", ")", "\u0120widget", ").", "get", "Items", "())", "\u0120{", "\u0120if", "\u0120(", "tab", "Item", ".", "is", "Dis", "posed", "())", "\u0120{", "\u0120System", ".", "err", ".", "println", "(\"", "CT", "ab", "Item", "\u0120was", "\u0120disposed", "\");", "\u0120break", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120child", "Count", "++;", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120child", "Count", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120sy", "ser", "r", "\u0120should", "\u0120come", "\u0120out", "."]}
{"function": "static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations( org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index) { expect(entity.getId()).andReturn(GUIDS[index]).anyTimes(); expect(entity.getvds_group_id()).andReturn(GUIDS[2]).anyTimes(); expect(entity.getvm_name()).andReturn(NAMES[index]).anyTimes(); expect(entity.getvm_description()).andReturn(DESCRIPTIONS[index]).anyTimes(); expect(entity.getnum_of_cpus()).andReturn(8).anyTimes(); expect(entity.getnum_of_sockets()).andReturn(2).anyTimes(); expect(entity.getusage_mem_percent()).andReturn(Integer.valueOf(20)).anyTimes(); expect(entity.getdisplay_type()).andReturn(DisplayType.vnc).anyTimes(); expect(entity.getdisplay_secure_port()).andReturn(5900).anyTimes(); expect(entity.getnum_of_monitors()).andReturn(2).anyTimes(); expect(entity.getvm_type()).andReturn(VmType.Server).anyTimes(); expect(entity.getrun_on_vds_name()).andReturn(NAMES[NAMES.length - 1]).anyTimes(); Map<String, DiskImage> diskImageMap = new HashMap<String, DiskImage>(); diskImageMap.put(\"1\", new DiskImage()); expect(entity.getDiskMap()).andReturn(diskImageMap).anyTimes(); VmStatic vmStatic = new VmStatic(); vmStatic.setId(GUIDS[index]); vmStatic.setvm_name(NAMES[index]); expect(entity.getStaticData()).andReturn(vmStatic).anyTimes(); setUpStatisticalEntityExpectations(entity, statistics); return entity; }", "text": "this expectations relevant for your use-case only, no need for all tests to see them, please move them to your method which will extend expectations for setUpEntityExpectations()", "function_tokens": ["static", "\u0120org", ".", "ov", "irt", ".", "engine", ".", "core", ".", "common", ".", "business", "ent", "ities", ".", "VM", "\u0120set", "Up", "Entity", "Ex", "pect", "ations", "(", "\u0120org", ".", "ov", "irt", ".", "engine", ".", "core", ".", "common", ".", "business", "ent", "ities", ".", "VM", "\u0120entity", ",", "\u0120V", "m", "Statistics", "\u0120statistics", ",", "\u0120int", "\u0120index", ")", "\u0120{", "\u0120expect", "(", "entity", ".", "get", "Id", "()", ").", "and", "Return", "(", "GU", "IDS", "[", "index", "]).", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "v", "ds", "_", "group", "_", "id", "()", ").", "and", "Return", "(", "GU", "IDS", "[", "2", "]).", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "vm", "_", "name", "()", ").", "and", "Return", "(", "N", "AMES", "[", "index", "]).", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "vm", "_", "description", "()", ").", "and", "Return", "(", "DES", "CRIP", "T", "IONS", "[", "index", "]).", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "num", "_", "of", "_", "cp", "us", "()", ").", "and", "Return", "(", "8", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "num", "_", "of", "_", "s", "ockets", "()", ").", "and", "Return", "(", "2", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "usage", "_", "mem", "_", "percent", "()", ").", "and", "Return", "(", "Integer", ".", "value", "Of", "(", "20", ")).", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "display", "_", "type", "()", ").", "and", "Return", "(", "Display", "Type", ".", "v", "nc", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "display", "_", "secure", "_", "port", "()", ").", "and", "Return", "(", "59", "00", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "num", "_", "of", "_", "mon", "itors", "()", ").", "and", "Return", "(", "2", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "vm", "_", "type", "()", ").", "and", "Return", "(", "V", "m", "Type", ".", "Server", ").", "any", "Times", "();", "\u0120expect", "(", "entity", ".", "get", "run", "_", "on", "_", "v", "ds", "_", "name", "()", ").", "and", "Return", "(", "N", "AMES", "[", "N", "AMES", ".", "length", "\u0120-", "\u01201", "]).", "any", "Times", "();", "\u0120Map", "<", "String", ",", "\u0120Disk", "Image", ">", "\u0120disk", "Image", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "String", ",", "\u0120Disk", "Image", ">", "();", "\u0120disk", "Image", "Map", ".", "put", "(\"", "1", "\",", "\u0120new", "\u0120Disk", "Image", "());", "\u0120expect", "(", "entity", ".", "get", "Disk", "Map", "()", ").", "and", "Return", "(", "disk", "Image", "Map", ").", "any", "Times", "();", "\u0120V", "m", "Static", "\u0120vm", "Static", "\u0120=", "\u0120new", "\u0120V", "m", "Static", "();", "\u0120vm", "Static", ".", "set", "Id", "(", "GU", "IDS", "[", "index", "]);", "\u0120vm", "Static", ".", "set", "vm", "_", "name", "(", "N", "AMES", "[", "index", "]);", "\u0120expect", "(", "entity", ".", "get", "Static", "Data", "()", ").", "and", "Return", "(", "vm", "Static", ").", "any", "Times", "();", "\u0120set", "Up", "Stat", "istical", "Entity", "Ex", "pect", "ations", "(", "entity", ",", "\u0120statistics", ");", "\u0120return", "\u0120entity", ";", "\u0120}"], "docstring_tokens": ["this", "\u0120expectations", "\u0120relevant", "\u0120for", "\u0120your", "\u0120use", "-", "case", "\u0120only", ",", "\u0120no", "\u0120need", "\u0120for", "\u0120all", "\u0120tests", "\u0120to", "\u0120see", "\u0120them", ",", "\u0120please", "\u0120move", "\u0120them", "\u0120to", "\u0120your", "\u0120method", "\u0120which", "\u0120will", "\u0120extend", "\u0120expectations", "\u0120for", "\u0120set", "Up", "Entity", "Ex", "pect", "ations", "()"]}
{"function": "public List<String> getDirectory() throws OwException { List<String> directory = new ArrayList<String>(); OwserverPacket requestPacket = new OwserverPacket(OwserverMessageType.DIR, \"/\"); write(requestPacket); OwserverPacket returnPacket = null; do { try { returnPacket = read(false); } catch (OwException e) { logger.info(\"getDirectory may have returned incomplete result: {}\", e.getMessage()); closeOnError(); return directory; } if (returnPacket.hasPayload()) { directory.add(returnPacket.getPayloadString()); } } while ((returnPacket.isPingPacket() || returnPacket.hasPayload())); if (!returnPacket.hasControlFlag(OwserverControlFlag.PERSISTENCE)) { logger.trace(\"closing connection because persistence was denied\"); close(); } connectionErrorCounter = 0; return directory; }", "text": "Is that a software issue? Then better do WARN and include the exception as a last param.", "function_tokens": ["public", "\u0120List", "<", "String", ">", "\u0120get", "Directory", "()", "\u0120throws", "\u0120Ow", "Exception", "\u0120{", "\u0120List", "<", "String", ">", "\u0120directory", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "String", ">", "();", "\u0120Ow", "server", "P", "acket", "\u0120request", "P", "acket", "\u0120=", "\u0120new", "\u0120Ow", "server", "P", "acket", "(", "O", "w", "server", "Message", "Type", ".", "DIR", ",", "\u0120\"/", "\");", "\u0120write", "(", "request", "P", "acket", ");", "\u0120Ow", "server", "P", "acket", "\u0120return", "P", "acket", "\u0120=", "\u0120null", ";", "\u0120do", "\u0120{", "\u0120try", "\u0120{", "\u0120return", "P", "acket", "\u0120=", "\u0120read", "(", "false", ");", "\u0120}", "\u0120catch", "\u0120(", "O", "w", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "info", "(\"", "get", "Directory", "\u0120may", "\u0120have", "\u0120returned", "\u0120incomplete", "\u0120result", ":", "\u0120{}", "\",", "\u0120e", ".", "get", "Message", "());", "\u0120close", "On", "Error", "();", "\u0120return", "\u0120directory", ";", "\u0120}", "\u0120if", "\u0120(", "return", "P", "acket", ".", "has", "Pay", "load", "())", "\u0120{", "\u0120directory", ".", "add", "(", "return", "P", "acket", ".", "get", "Pay", "load", "String", "());", "\u0120}", "\u0120}", "\u0120while", "\u0120((", "return", "P", "acket", ".", "is", "Ping", "P", "acket", "()", "\u0120||", "\u0120return", "P", "acket", ".", "has", "Pay", "load", "()", "));", "\u0120if", "\u0120(!", "return", "P", "acket", ".", "has", "Control", "Flag", "(", "O", "w", "server", "Control", "Flag", ".", "P", "ERS", "IST", "ENCE", "))", "\u0120{", "\u0120logger", ".", "trace", "(\"", "cl", "osing", "\u0120connection", "\u0120because", "\u0120persistence", "\u0120was", "\u0120denied", "\");", "\u0120close", "();", "\u0120}", "\u0120connection", "Error", "Counter", "\u0120=", "\u01200", ";", "\u0120return", "\u0120directory", ";", "\u0120}"], "docstring_tokens": ["Is", "\u0120that", "\u0120a", "\u0120software", "\u0120issue", "?", "\u0120Then", "\u0120better", "\u0120do", "\u0120WARN", "\u0120and", "\u0120include", "\u0120the", "\u0120exception", "\u0120as", "\u0120a", "\u0120last", "\u0120param", "."]}
{"function": "public void start() throws Exception { synchronized (lock) { if (childrenCache != null) { return; } childrenCache = cacheFactory.make(curatorFramework, config.getContainerPath()); } ContainerCacheListener containerCacheListener = new ContainerCacheListener(); childrenCache.getListenable().addListener(containerCacheListener); try { childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT); } catch (Exception e) { synchronized (lock) { try { stop(); } catch (IOException e1) { log.error(e1, \"Exception when stopping InventoryManager that couldn't start.\"); } } throw e; } while (!containerCacheListener.doneInitializing) { Thread.sleep(2000); log.info(\"Waiting for PathChildrenCache to be completely loaded.\"); } }", "text": "can we use a CountDownLatch.await(1 minute) here instead? that way not too many logs will be printed and also it wouldn't wait any more than necessary ?", "function_tokens": ["public", "\u0120void", "\u0120start", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120synchronized", "\u0120(", "lock", ")", "\u0120{", "\u0120if", "\u0120(", "children", "Cache", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120children", "Cache", "\u0120=", "\u0120cache", "Factory", ".", "make", "(", "cur", "ator", "Fram", "ework", ",", "\u0120config", ".", "get", "Container", "Path", "());", "\u0120}", "\u0120Container", "Cache", "Listener", "\u0120container", "Cache", "Listener", "\u0120=", "\u0120new", "\u0120Container", "Cache", "Listener", "();", "\u0120children", "Cache", ".", "get", "List", "enable", "().", "add", "Listener", "(", "container", "Cache", "Listener", ");", "\u0120try", "\u0120{", "\u0120children", "Cache", ".", "start", "(", "Path", "Children", "Cache", ".", "Start", "Mode", ".", "POST", "_", "IN", "IT", "IAL", "IZ", "ED", "_", "EV", "ENT", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120synchronized", "\u0120(", "lock", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120stop", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", "1", ")", "\u0120{", "\u0120log", ".", "error", "(", "e", "1", ",", "\u0120\"", "Exception", "\u0120when", "\u0120stopping", "\u0120Inventory", "Manager", "\u0120that", "\u0120couldn", "'t", "\u0120start", ".\"", ");", "\u0120}", "\u0120}", "\u0120throw", "\u0120e", ";", "\u0120}", "\u0120while", "\u0120(!", "container", "Cache", "Listener", ".", "done", "Initial", "izing", ")", "\u0120{", "\u0120Thread", ".", "sleep", "(", "2000", ");", "\u0120log", ".", "info", "(\"", "Wa", "iting", "\u0120for", "\u0120Path", "Children", "Cache", "\u0120to", "\u0120be", "\u0120completely", "\u0120loaded", ".\"", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["can", "\u0120we", "\u0120use", "\u0120a", "\u0120Count", "Down", "L", "atch", ".", "aw", "ait", "(", "1", "\u0120minute", ")", "\u0120here", "\u0120instead", "?", "\u0120that", "\u0120way", "\u0120not", "\u0120too", "\u0120many", "\u0120logs", "\u0120will", "\u0120be", "\u0120printed", "\u0120and", "\u0120also", "\u0120it", "\u0120wouldn", "'t", "\u0120wait", "\u0120any", "\u0120more", "\u0120than", "\u0120necessary", "\u0120?"]}
{"function": "public void testDoubletonFlatbush() { List<Rectangle> items = new ArrayList<>(); Rectangle rect0 = new Rectangle(1, 1, 1, 1); items.add(rect0); Rectangle rect1 = new Rectangle(-1, -2, -1, -1); items.add(rect1); items.sort(RECTANGLE_COMPARATOR); Flatbush<Rectangle> rtree = new Flatbush<>(items.toArray(new Rectangle[] {})); List<Rectangle> allResults = findIntersections(rtree, EVERYTHING); allResults.sort(RECTANGLE_COMPARATOR); assertEquals(allResults, items); Rectangle hit0 = new Rectangle(1, 1, 2, 2); assertEquals(findIntersections(rtree, hit0), ImmutableList.of(rect0)); Rectangle hit1 = new Rectangle(-2, -2, -1, -2); assertEquals(findIntersections(rtree, hit1), ImmutableList.of(rect1)); Rectangle totalMiss = new Rectangle(10, 10, 12, 12); assertEquals(findIntersections(rtree, totalMiss), ImmutableList.of()); Rectangle marginalMiss = new Rectangle(0, 0, 0, 0); assertEquals(findIntersections(rtree, marginalMiss), ImmutableList.of()); }", "text": "use ImmutableList.of() and assertEqualsNoOrder  Rectangle rect0 = new Rectangle(1, 1, 1, 1); Rectangle rect1 = new Rectangle(-1, -2, -1, -1); List<Rectangle> items = ImmutableList.of(rect0, rect1); Flatbush<Rectangle> rtree = new Flatbush<>(items.toArray(new Rectangle[] {})); List<Rectangle> allResults = findIntersections(rtree, EVERYTHING); assertEqualsNoOrder(allResults.toArray(), items.toArray());  ditto testTwoLevelFlatbush", "function_tokens": ["public", "\u0120void", "\u0120test", "Double", "ton", "Fl", "at", "bush", "()", "\u0120{", "\u0120List", "<", "Rect", "angle", ">", "\u0120items", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120Rect", "angle", "\u0120rect", "0", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "1", ",", "\u01201", ",", "\u01201", ",", "\u01201", ");", "\u0120items", ".", "add", "(", "rect", "0", ");", "\u0120Rect", "angle", "\u0120rect", "1", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(-", "1", ",", "\u0120-", "2", ",", "\u0120-", "1", ",", "\u0120-", "1", ");", "\u0120items", ".", "add", "(", "rect", "1", ");", "\u0120items", ".", "sort", "(", "RECT", "ANG", "LE", "_", "COM", "PAR", "ATOR", ");", "\u0120Flat", "bush", "<", "Rect", "angle", ">", "\u0120r", "tree", "\u0120=", "\u0120new", "\u0120Flat", "bush", "<", ">(", "items", ".", "to", "Array", "(", "new", "\u0120Rect", "angle", "[]", "\u0120{}", "));", "\u0120List", "<", "Rect", "angle", ">", "\u0120all", "Results", "\u0120=", "\u0120find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120EVERY", "THING", ");", "\u0120all", "Results", ".", "sort", "(", "RECT", "ANG", "LE", "_", "COM", "PAR", "ATOR", ");", "\u0120assert", "Equ", "als", "(", "all", "Results", ",", "\u0120items", ");", "\u0120Rect", "angle", "\u0120hit", "0", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "1", ",", "\u01201", ",", "\u01202", ",", "\u01202", ");", "\u0120assert", "Equ", "als", "(", "find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120hit", "0", "),", "\u0120Imm", "utable", "List", ".", "of", "(", "rect", "0", "));", "\u0120Rect", "angle", "\u0120hit", "1", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(-", "2", ",", "\u0120-", "2", ",", "\u0120-", "1", ",", "\u0120-", "2", ");", "\u0120assert", "Equ", "als", "(", "find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120hit", "1", "),", "\u0120Imm", "utable", "List", ".", "of", "(", "rect", "1", "));", "\u0120Rect", "angle", "\u0120total", "Miss", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "10", ",", "\u012010", ",", "\u012012", ",", "\u012012", ");", "\u0120assert", "Equ", "als", "(", "find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120total", "Miss", "),", "\u0120Imm", "utable", "List", ".", "of", "());", "\u0120Rect", "angle", "\u0120marginal", "Miss", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "0", ",", "\u01200", ",", "\u01200", ",", "\u01200", ");", "\u0120assert", "Equ", "als", "(", "find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120marginal", "Miss", "),", "\u0120Imm", "utable", "List", ".", "of", "());", "\u0120}"], "docstring_tokens": ["use", "\u0120Imm", "utable", "List", ".", "of", "()", "\u0120and", "\u0120assert", "Equ", "als", "No", "Order", "\u0120", "\u0120Rect", "angle", "\u0120rect", "0", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "1", ",", "\u01201", ",", "\u01201", ",", "\u01201", ");", "\u0120Rect", "angle", "\u0120rect", "1", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(-", "1", ",", "\u0120-", "2", ",", "\u0120-", "1", ",", "\u0120-", "1", ");", "\u0120List", "<", "Rect", "angle", ">", "\u0120items", "\u0120=", "\u0120Imm", "utable", "List", ".", "of", "(", "rect", "0", ",", "\u0120rect", "1", ");", "\u0120Flat", "bush", "<", "Rect", "angle", ">", "\u0120r", "tree", "\u0120=", "\u0120new", "\u0120Flat", "bush", "<", ">(", "items", ".", "to", "Array", "(", "new", "\u0120Rect", "angle", "[]", "\u0120{}", "));", "\u0120List", "<", "Rect", "angle", ">", "\u0120all", "Results", "\u0120=", "\u0120find", "Inter", "sections", "(", "rt", "ree", ",", "\u0120EVERY", "THING", ");", "\u0120assert", "Equ", "als", "No", "Order", "(", "all", "Results", ".", "to", "Array", "(),", "\u0120items", ".", "to", "Array", "());", "\u0120", "\u0120d", "itto", "\u0120test", "Two", "Level", "Fl", "at", "bush"]}
{"function": "public void onDeniedPendingLockNotification() { synchronized (ZKDistributedNonblockingLock.this) { _isLocked = false; _isPreempted = true; _isPending = false; ZKDistributedNonblockingLock.this.notify(); } }", "text": "Looks like a lock can only be in one state at a time. I suggest merging these 2 booleans into an enum for the cleanness of the code and the logic.", "function_tokens": ["public", "\u0120void", "\u0120on", "Den", "ied", "P", "ending", "Lock", "Not", "ification", "()", "\u0120{", "\u0120synchronized", "\u0120(", "Z", "K", "Dist", "ributed", "Non", "blocking", "Lock", ".", "this", ")", "\u0120{", "\u0120_", "is", "L", "ocked", "\u0120=", "\u0120false", ";", "\u0120_", "is", "Pre", "empt", "ed", "\u0120=", "\u0120true", ";", "\u0120_", "is", "P", "ending", "\u0120=", "\u0120false", ";", "\u0120Z", "K", "Dist", "ributed", "Non", "blocking", "Lock", ".", "this", ".", "not", "ify", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Looks", "\u0120like", "\u0120a", "\u0120lock", "\u0120can", "\u0120only", "\u0120be", "\u0120in", "\u0120one", "\u0120state", "\u0120at", "\u0120a", "\u0120time", ".", "\u0120I", "\u0120suggest", "\u0120merging", "\u0120these", "\u01202", "\u0120bo", "ole", "ans", "\u0120into", "\u0120an", "\u0120enum", "\u0120for", "\u0120the", "\u0120clean", "ness", "\u0120of", "\u0120the", "\u0120code", "\u0120and", "\u0120the", "\u0120logic", "."]}
{"function": "public void generateExperimentalCoordinates(Vector2d firstBondVector) throws CDKException { IMolecule original = molecule; IMolecule shallowCopy = molecule.getBuilder().newInstance(IMolecule.class,molecule); for (IAtom curAtom : shallowCopy.atoms()) { if (curAtom.getSymbol().equals(\"H\")) { int bondsFromCurAtom=0; for (IBond bond : shallowCopy.bonds()) if(bond.contains (curAtom)) ++bondsFromCurAtom; if (bondsFromCurAtom < 2) { shallowCopy.removeAtomAndConnectedElectronContainers(curAtom); curAtom.setPoint2d(null); } } } molecule = shallowCopy; generateCoordinates(firstBondVector); double bondLength = GeometryTools.getBondLengthAverage(molecule); HydrogenPlacer hPlacer = new HydrogenPlacer(); molecule = original; hPlacer.placeHydrogens2D(molecule, bondLength); }", "text": "IAtomContainer.getConnectedBondsCount()? or IAtomContainer.getConnectedAtomsCount()? <LINK_0>", "function_tokens": ["public", "\u0120void", "\u0120generate", "Exper", "imental", "Co", "ord", "inates", "(", "Vector", "2", "d", "\u0120first", "B", "ond", "Vector", ")", "\u0120throws", "\u0120CD", "K", "Exception", "\u0120{", "\u0120IM", "ole", "cule", "\u0120original", "\u0120=", "\u0120molecule", ";", "\u0120IM", "ole", "cule", "\u0120shallow", "Copy", "\u0120=", "\u0120molecule", ".", "get", "Builder", "().", "new", "Instance", "(", "IM", "ole", "cule", ".", "class", ",", "m", "ole", "cule", ");", "\u0120for", "\u0120(", "I", "At", "om", "\u0120cur", "At", "om", "\u0120:", "\u0120shallow", "Copy", ".", "at", "oms", "())", "\u0120{", "\u0120if", "\u0120(", "cur", "At", "om", ".", "get", "Sy", "mbol", "().", "equ", "als", "(\"", "H", "\"))", "\u0120{", "\u0120int", "\u0120bonds", "From", "Cur", "At", "om", "=", "0", ";", "\u0120for", "\u0120(", "IB", "ond", "\u0120bond", "\u0120:", "\u0120shallow", "Copy", ".", "b", "onds", "())", "\u0120if", "(", "b", "ond", ".", "cont", "ains", "\u0120(", "cur", "At", "om", "))", "\u0120++", "b", "onds", "From", "Cur", "At", "om", ";", "\u0120if", "\u0120(", "b", "onds", "From", "Cur", "At", "om", "\u0120<", "\u01202", ")", "\u0120{", "\u0120shallow", "Copy", ".", "remove", "At", "om", "And", "Connect", "ed", "Elect", "ron", "Cont", "ainers", "(", "cur", "At", "om", ");", "\u0120cur", "At", "om", ".", "set", "Point", "2", "d", "(", "null", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120molecule", "\u0120=", "\u0120shallow", "Copy", ";", "\u0120generate", "Co", "ord", "inates", "(", "first", "B", "ond", "Vector", ");", "\u0120double", "\u0120bond", "Length", "\u0120=", "\u0120Ge", "ometry", "Tools", ".", "get", "B", "ond", "Length", "Average", "(", "m", "ole", "cule", ");", "\u0120Hyd", "rogen", "Pl", "acer", "\u0120h", "Pl", "acer", "\u0120=", "\u0120new", "\u0120Hyd", "rogen", "Pl", "acer", "();", "\u0120molecule", "\u0120=", "\u0120original", ";", "\u0120h", "Pl", "acer", ".", "place", "Hyd", "rogens", "2", "D", "(", "m", "ole", "cule", ",", "\u0120bond", "Length", ");", "\u0120}"], "docstring_tokens": ["I", "At", "om", "Container", ".", "get", "Connect", "ed", "B", "onds", "Count", "()", "?", "\u0120or", "\u0120I", "At", "om", "Container", ".", "get", "Connect", "ed", "At", "oms", "Count", "()", "?", "\u0120<", "L", "INK", "_", "0", ">"]}
{"function": "private String createBuildsStats(MemoryImprint memoryImprint, TaskListener listener, Map<String, String> parameters) { StringBuilder str = new StringBuilder(\"\"); final String rootUrl = hudson.getRootUrl(); String unsuccessfulMessage = null; Entry[] entries = memoryImprint.getEntries(); if (entries.length > 0) { str.append(\"\\n\"); for (Entry entry : entries) { AbstractBuild build = entry.getBuild(); if (build != null) { GerritTrigger trigger = GerritTrigger.getTrigger(build.getProject()); Result res = build.getResult(); String customMessage = null; str.append(\"\\n\\n\"); if (trigger.getCustomUrl() == null || trigger.getCustomUrl().isEmpty()) { str.append(rootUrl).append(entry.getBuild().getUrl()); } else { str.append(expandParameters(trigger.getCustomUrl(), build, listener, parameters)); } str.append(MESSAGE_DELIMITER); if (res == Result.SUCCESS) { customMessage = trigger.getBuildSuccessfulMessage(); } else if (res == Result.FAILURE || res == Result.ABORTED) { customMessage = trigger.getBuildFailureMessage(); } else if (res == Result.UNSTABLE) { customMessage = trigger.getBuildUnstableMessage(); } else { customMessage = trigger.getBuildFailureMessage(); } if (customMessage == null || customMessage.equals(\"\")) { str.append(res.toString()); } else { str.append(customMessage); } if (res != Result.SUCCESS) { unsuccessfulMessage = entry.getUnsuccessfulMessage(); if (null != unsuccessfulMessage && !unsuccessfulMessage.isEmpty()) { logger.trace(\"Using unsuccessful message from file.\"); str.append(\" <<<\\n\"); str.append(unsuccessfulMessage.trim()); str.append(\"\\n>>> \"); } } } } } else { logger.error(\"I got a request to create build statistics, but no entries where found!\"); } return str.toString(); }", "text": "you should use res.isWorseThan(Result.SUCCESS) instead. <LINK_0>", "function_tokens": ["private", "\u0120String", "\u0120create", "Build", "s", "Stats", "(", "Memory", "Im", "print", "\u0120memory", "Im", "print", ",", "\u0120Task", "Listener", "\u0120listener", ",", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120parameters", ")", "\u0120{", "\u0120String", "Builder", "\u0120str", "\u0120=", "\u0120new", "\u0120String", "Builder", "(\"", "\");", "\u0120final", "\u0120String", "\u0120root", "Url", "\u0120=", "\u0120h", "ud", "son", ".", "get", "Root", "Url", "();", "\u0120String", "\u0120unsuccessful", "Message", "\u0120=", "\u0120null", ";", "\u0120Entry", "[]", "\u0120entries", "\u0120=", "\u0120memory", "Im", "print", ".", "get", "Ent", "ries", "();", "\u0120if", "\u0120(", "ent", "ries", ".", "length", "\u0120>", "\u01200", ")", "\u0120{", "\u0120str", ".", "append", "(\"", "\\", "n", "\");", "\u0120for", "\u0120(", "Entry", "\u0120entry", "\u0120:", "\u0120entries", ")", "\u0120{", "\u0120Abstract", "Build", "\u0120build", "\u0120=", "\u0120entry", ".", "get", "Build", "();", "\u0120if", "\u0120(", "build", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Ger", "rit", "Trigger", "\u0120trigger", "\u0120=", "\u0120Ger", "rit", "Trigger", ".", "get", "Trigger", "(", "build", ".", "get", "Project", "());", "\u0120Result", "\u0120res", "\u0120=", "\u0120build", ".", "get", "Result", "();", "\u0120String", "\u0120custom", "Message", "\u0120=", "\u0120null", ";", "\u0120str", ".", "append", "(\"", "\\", "n", "\\", "n", "\");", "\u0120if", "\u0120(", "trigger", ".", "get", "Custom", "Url", "()", "\u0120==", "\u0120null", "\u0120||", "\u0120trigger", ".", "get", "Custom", "Url", "().", "is", "Empty", "())", "\u0120{", "\u0120str", ".", "append", "(", "root", "Url", ").", "append", "(", "entry", ".", "get", "Build", "().", "get", "Url", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120str", ".", "append", "(", "exp", "and", "Parameters", "(", "trigger", ".", "get", "Custom", "Url", "(),", "\u0120build", ",", "\u0120listener", ",", "\u0120parameters", "));", "\u0120}", "\u0120str", ".", "append", "(", "M", "ES", "SA", "GE", "_", "D", "EL", "IM", "IT", "ER", ");", "\u0120if", "\u0120(", "res", "\u0120==", "\u0120Result", ".", "SU", "CC", "ESS", ")", "\u0120{", "\u0120custom", "Message", "\u0120=", "\u0120trigger", ".", "get", "Build", "Success", "ful", "Message", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "res", "\u0120==", "\u0120Result", ".", "FA", "IL", "URE", "\u0120||", "\u0120res", "\u0120==", "\u0120Result", ".", "AB", "ORT", "ED", ")", "\u0120{", "\u0120custom", "Message", "\u0120=", "\u0120trigger", ".", "get", "Build", "Failure", "Message", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "res", "\u0120==", "\u0120Result", ".", "UN", "ST", "ABLE", ")", "\u0120{", "\u0120custom", "Message", "\u0120=", "\u0120trigger", ".", "get", "Build", "Un", "stable", "Message", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120custom", "Message", "\u0120=", "\u0120trigger", ".", "get", "Build", "Failure", "Message", "();", "\u0120}", "\u0120if", "\u0120(", "custom", "Message", "\u0120==", "\u0120null", "\u0120||", "\u0120custom", "Message", ".", "equ", "als", "(\"", "\"))", "\u0120{", "\u0120str", ".", "append", "(", "res", ".", "to", "String", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120str", ".", "append", "(", "custom", "Message", ");", "\u0120}", "\u0120if", "\u0120(", "res", "\u0120!=", "\u0120Result", ".", "SU", "CC", "ESS", ")", "\u0120{", "\u0120unsuccessful", "Message", "\u0120=", "\u0120entry", ".", "get", "Un", "successful", "Message", "();", "\u0120if", "\u0120(", "null", "\u0120!=", "\u0120unsuccessful", "Message", "\u0120&&", "\u0120!", "un", "successful", "Message", ".", "is", "Empty", "())", "\u0120{", "\u0120logger", ".", "trace", "(\"", "Using", "\u0120unsuccessful", "\u0120message", "\u0120from", "\u0120file", ".\"", ");", "\u0120str", ".", "append", "(\"", "\u0120<<", "<", "\\", "n", "\");", "\u0120str", ".", "append", "(", "un", "successful", "Message", ".", "tr", "im", "());", "\u0120str", ".", "append", "(\"", "\\", "n", ">>>", "\u0120\"", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120logger", ".", "error", "(\"", "I", "\u0120got", "\u0120a", "\u0120request", "\u0120to", "\u0120create", "\u0120build", "\u0120statistics", ",", "\u0120but", "\u0120no", "\u0120entries", "\u0120where", "\u0120found", "!\"", ");", "\u0120}", "\u0120return", "\u0120str", ".", "to", "String", "();", "\u0120}"], "docstring_tokens": ["you", "\u0120should", "\u0120use", "\u0120res", ".", "is", "W", "orse", "Th", "an", "(", "Result", ".", "SU", "CC", "ESS", ")", "\u0120instead", ".", "\u0120<", "L", "INK", "_", "0", ">"]}
{"function": "public void visitNode(Tree tree) { if (tree.is(Kind.METHOD) && isServletInit((MethodTree) tree)) { tree.accept(new AssignmentVisitor()); } else if (tree.is(Kind.VARIABLE)) { VariableTree variable = (VariableTree) tree; if (hasSemantic() && isOwnedByAServlet(variable) && !isStaticOrFinal(variable)) { issuableVariables.add(variable); } } }", "text": "checking for the semantic should be done before checking the type of the tree, as semantic is used to get the parameter type of the method.", "function_tokens": ["public", "\u0120void", "\u0120visit", "Node", "(", "Tree", "\u0120tree", ")", "\u0120{", "\u0120if", "\u0120(", "tree", ".", "is", "(", "Kind", ".", "METHOD", ")", "\u0120&&", "\u0120is", "Serv", "let", "Init", "((", "Method", "Tree", ")", "\u0120tree", "))", "\u0120{", "\u0120tree", ".", "accept", "(", "new", "\u0120Assignment", "Vis", "itor", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "tree", ".", "is", "(", "Kind", ".", "V", "AR", "IA", "BLE", "))", "\u0120{", "\u0120Variable", "Tree", "\u0120variable", "\u0120=", "\u0120(", "Variable", "Tree", ")", "\u0120tree", ";", "\u0120if", "\u0120(", "has", "Sem", "antic", "()", "\u0120&&", "\u0120is", "Own", "ed", "By", "AS", "erv", "let", "(", "variable", ")", "\u0120&&", "\u0120!", "is", "Static", "Or", "Final", "(", "variable", "))", "\u0120{", "\u0120iss", "uable", "Vari", "ables", ".", "add", "(", "variable", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["checking", "\u0120for", "\u0120the", "\u0120semantic", "\u0120should", "\u0120be", "\u0120done", "\u0120before", "\u0120checking", "\u0120the", "\u0120type", "\u0120of", "\u0120the", "\u0120tree", ",", "\u0120as", "\u0120semantic", "\u0120is", "\u0120used", "\u0120to", "\u0120get", "\u0120the", "\u0120parameter", "\u0120type", "\u0120of", "\u0120the", "\u0120method", "."]}
{"function": "public void shouldNotExpireChargesWhenAwaitingCaptureDelayIsLessThan48Hours() { String extChargeId1 = addCharge(CREATED, \"ref\", ZonedDateTime.now().minusMinutes(90), RandomIdGenerator.newId()); String extChargeId2 = addCharge(AWAITING_CAPTURE_REQUEST, \"ref\", ZonedDateTime.now().minusHours(48L).plusMinutes(1L), RandomIdGenerator.newId()); worldpayMockClient.mockCancelSuccess(); connectorRestApiClient .postChargeExpiryTask() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(\"expiry-success\", is(1)) .body(\"expiry-failed\", is(0)); connectorRestApiClient .withAccountId(accountId) .withChargeId(extChargeId1) .getCharge() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(JSON_CHARGE_KEY, is(extChargeId1)) .body(JSON_STATE_KEY, is(EXPIRED.toExternal().getStatus())); connectorRestApiClient .withAccountId(accountId) .withChargeId(extChargeId2) .getCharge() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(JSON_CHARGE_KEY, is(extChargeId2)) .body(JSON_STATE_KEY, is(AWAITING_CAPTURE_REQUEST.toExternal().getStatus())); List<String> events1 = databaseTestHelper.getInternalEvents(extChargeId1); List<String> events2 = databaseTestHelper.getInternalEvents(extChargeId2); assertTrue(isEqualCollection(events1, asList(CREATED.getValue(), EXPIRED.getValue()))); assertTrue(isEqualCollection(events2, asList(AWAITING_CAPTURE_REQUEST.getValue()))); }", "text": "not sure what role this charge is playing in the test", "function_tokens": ["public", "\u0120void", "\u0120should", "Not", "Ex", "pire", "Charges", "When", "A", "wa", "iting", "Capture", "Del", "ay", "Is", "Less", "Th", "an", "48", "Hours", "()", "\u0120{", "\u0120String", "\u0120ext", "Charge", "Id", "1", "\u0120=", "\u0120add", "Charge", "(", "CRE", "ATED", ",", "\u0120\"", "ref", "\",", "\u0120Z", "oned", "Date", "Time", ".", "now", "().", "minus", "Min", "utes", "(", "90", "),", "\u0120Random", "Id", "Gener", "ator", ".", "new", "Id", "());", "\u0120String", "\u0120ext", "Charge", "Id", "2", "\u0120=", "\u0120add", "Charge", "(", "AW", "A", "IT", "ING", "_", "CAP", "T", "URE", "_", "RE", "QUEST", ",", "\u0120\"", "ref", "\",", "\u0120Z", "oned", "Date", "Time", ".", "now", "().", "minus", "Hours", "(", "48", "L", ").", "plus", "Min", "utes", "(", "1", "L", "),", "\u0120Random", "Id", "Gener", "ator", ".", "new", "Id", "());", "\u0120world", "pay", "M", "ock", "Client", ".", "m", "ock", "C", "ancel", "Success", "();", "\u0120connector", "Rest", "A", "pi", "Client", "\u0120.", "post", "Charge", "Ex", "pir", "y", "Task", "()", "\u0120.", "status", "Code", "(", "OK", ".", "get", "Status", "Code", "())", "\u0120.", "content", "Type", "(", "JSON", ")", "\u0120.", "body", "(\"", "ex", "pir", "y", "-", "success", "\",", "\u0120is", "(", "1", "))", "\u0120.", "body", "(\"", "ex", "pir", "y", "-", "failed", "\",", "\u0120is", "(", "0", "));", "\u0120connector", "Rest", "A", "pi", "Client", "\u0120.", "with", "Account", "Id", "(", "account", "Id", ")", "\u0120.", "with", "Charge", "Id", "(", "ext", "Charge", "Id", "1", ")", "\u0120.", "get", "Charge", "()", "\u0120.", "status", "Code", "(", "OK", ".", "get", "Status", "Code", "())", "\u0120.", "content", "Type", "(", "JSON", ")", "\u0120.", "body", "(", "JSON", "_", "CHAR", "GE", "_", "KEY", ",", "\u0120is", "(", "ext", "Charge", "Id", "1", "))", "\u0120.", "body", "(", "JSON", "_", "STATE", "_", "KEY", ",", "\u0120is", "(", "EXP", "IRED", ".", "to", "External", "().", "get", "Status", "()", "));", "\u0120connector", "Rest", "A", "pi", "Client", "\u0120.", "with", "Account", "Id", "(", "account", "Id", ")", "\u0120.", "with", "Charge", "Id", "(", "ext", "Charge", "Id", "2", ")", "\u0120.", "get", "Charge", "()", "\u0120.", "status", "Code", "(", "OK", ".", "get", "Status", "Code", "())", "\u0120.", "content", "Type", "(", "JSON", ")", "\u0120.", "body", "(", "JSON", "_", "CHAR", "GE", "_", "KEY", ",", "\u0120is", "(", "ext", "Charge", "Id", "2", "))", "\u0120.", "body", "(", "JSON", "_", "STATE", "_", "KEY", ",", "\u0120is", "(", "AW", "A", "IT", "ING", "_", "CAP", "T", "URE", "_", "RE", "QUEST", ".", "to", "External", "().", "get", "Status", "()", "));", "\u0120List", "<", "String", ">", "\u0120events", "1", "\u0120=", "\u0120database", "Test", "Helper", ".", "get", "Internal", "Events", "(", "ext", "Charge", "Id", "1", ");", "\u0120List", "<", "String", ">", "\u0120events", "2", "\u0120=", "\u0120database", "Test", "Helper", ".", "get", "Internal", "Events", "(", "ext", "Charge", "Id", "2", ");", "\u0120assert", "True", "(", "is", "E", "qual", "Collection", "(", "events", "1", ",", "\u0120as", "List", "(", "CRE", "ATED", ".", "get", "Value", "(),", "\u0120EXP", "IRED", ".", "get", "Value", "()", "))", ");", "\u0120assert", "True", "(", "is", "E", "qual", "Collection", "(", "events", "2", ",", "\u0120as", "List", "(", "AW", "A", "IT", "ING", "_", "CAP", "T", "URE", "_", "RE", "QUEST", ".", "get", "Value", "()", "))", ");", "\u0120}"], "docstring_tokens": ["not", "\u0120sure", "\u0120what", "\u0120role", "\u0120this", "\u0120charge", "\u0120is", "\u0120playing", "\u0120in", "\u0120the", "\u0120test"]}
{"function": "public void updateSource(TaskSource sourceUpdate) { checkLockNotHeld(\"Can not update sources while holding the driver lock\"); checkArgument(sourceOperator.isPresent() && sourceOperator.get().getSourceId().equals(sourceUpdate.getPlanNodeId())); pendingTaskSourceUpdates.updateAndGet(current -> current == null ? sourceUpdate : current.update(sourceUpdate)); tryWithLock(() -> TRUE); }", "text": "Add a message to the checkArgument call.", "function_tokens": ["public", "\u0120void", "\u0120update", "Source", "(", "Task", "Source", "\u0120source", "Update", ")", "\u0120{", "\u0120check", "Lock", "Not", "He", "ld", "(\"", "Can", "\u0120not", "\u0120update", "\u0120sources", "\u0120while", "\u0120holding", "\u0120the", "\u0120driver", "\u0120lock", "\");", "\u0120check", "Arg", "ument", "(", "source", "Oper", "ator", ".", "is", "Present", "()", "\u0120&&", "\u0120source", "Oper", "ator", ".", "get", "().", "get", "Source", "Id", "().", "equ", "als", "(", "source", "Update", ".", "get", "Plan", "Node", "Id", "()", "));", "\u0120pending", "Task", "Source", "Up", "dates", ".", "update", "And", "Get", "(", "current", "\u0120->", "\u0120current", "\u0120==", "\u0120null", "\u0120?", "\u0120source", "Update", "\u0120:", "\u0120current", ".", "update", "(", "source", "Update", "));", "\u0120try", "With", "Lock", "(", "()", "\u0120->", "\u0120TRUE", ");", "\u0120}"], "docstring_tokens": ["Add", "\u0120a", "\u0120message", "\u0120to", "\u0120the", "\u0120check", "Arg", "ument", "\u0120call", "."]}
{"function": "protected int persistHydrant( FireHydrant indexToPersist, DataSchema schema, Interval interval, Map<String, Object> metadataElems ) { synchronized (indexToPersist) { if (indexToPersist.hasSwapped()) { log.info( \"DataSource[%s], Interval[%s], Hydrant[%s] already swapped. Ignoring request to persist.\", schema.getDataSource(), interval, indexToPersist ); return 0; } log.info( \"DataSource[%s], Interval[%s], Metadata [%s] persisting Hydrant[%s]\", schema.getDataSource(), interval, metadataElems, indexToPersist ); try { int numRows = indexToPersist.getIndex().size(); final IndexSpec indexSpec = config.getIndexSpec(); indexToPersist.getIndex().getMetadata().putAll(metadataElems); final File persistedFile = indexMerger.persist( indexToPersist.getIndex(), interval, new File(computePersistDir(schema, interval), String.valueOf(indexToPersist.getCount())), indexSpec, config.getSegmentWriteOutMediumFactory() ); indexToPersist.swapSegment( new QueryableIndexSegment(indexIO.loadIndex(persistedFile), indexToPersist.getSegmentId()) ); return numRows; } catch (IOException e) { log.makeAlert(\"dataSource[%s] -- incremental persist failed\", schema.getDataSource()) .addData(\"interval\", interval) .addData(\"count\", indexToPersist.getCount()) .emit(); throw new RuntimeException(e); } } }", "text": "Change doesn't belong to this PR", "function_tokens": ["protected", "\u0120int", "\u0120persist", "Hyd", "rant", "(", "\u0120Fire", "Hyd", "rant", "\u0120index", "To", "Pers", "ist", ",", "\u0120Data", "Sche", "ma", "\u0120schema", ",", "\u0120Inter", "val", "\u0120interval", ",", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120metadata", "Ele", "ms", "\u0120)", "\u0120{", "\u0120synchronized", "\u0120(", "index", "To", "Pers", "ist", ")", "\u0120{", "\u0120if", "\u0120(", "index", "To", "Pers", "ist", ".", "has", "Sw", "apped", "())", "\u0120{", "\u0120log", ".", "info", "(", "\u0120\"", "Data", "Source", "[", "%", "s", "],", "\u0120Inter", "val", "[", "%", "s", "],", "\u0120Hyd", "rant", "[", "%", "s", "]", "\u0120already", "\u0120swapped", ".", "\u0120Ign", "oring", "\u0120request", "\u0120to", "\u0120persist", ".\",", "\u0120schema", ".", "get", "Data", "Source", "(),", "\u0120interval", ",", "\u0120index", "To", "Pers", "ist", "\u0120);", "\u0120return", "\u01200", ";", "\u0120}", "\u0120log", ".", "info", "(", "\u0120\"", "Data", "Source", "[", "%", "s", "],", "\u0120Inter", "val", "[", "%", "s", "],", "\u0120Met", "adata", "\u0120[", "%", "s", "]", "\u0120pers", "isting", "\u0120Hyd", "rant", "[", "%", "s", "]", "\",", "\u0120schema", ".", "get", "Data", "Source", "(),", "\u0120interval", ",", "\u0120metadata", "Ele", "ms", ",", "\u0120index", "To", "Pers", "ist", "\u0120);", "\u0120try", "\u0120{", "\u0120int", "\u0120num", "R", "ows", "\u0120=", "\u0120index", "To", "Pers", "ist", ".", "get", "Index", "().", "size", "();", "\u0120final", "\u0120Index", "Spec", "\u0120index", "Spec", "\u0120=", "\u0120config", ".", "get", "Index", "Spec", "();", "\u0120index", "To", "Pers", "ist", ".", "get", "Index", "().", "get", "Met", "adata", "().", "put", "All", "(", "metadata", "Ele", "ms", ");", "\u0120final", "\u0120File", "\u0120persisted", "File", "\u0120=", "\u0120index", "Mer", "ger", ".", "pers", "ist", "(", "\u0120index", "To", "Pers", "ist", ".", "get", "Index", "(),", "\u0120interval", ",", "\u0120new", "\u0120File", "(", "comp", "ute", "Pers", "ist", "Dir", "(", "sche", "ma", ",", "\u0120interval", "),", "\u0120String", ".", "value", "Of", "(", "index", "To", "Pers", "ist", ".", "get", "Count", "())", "),", "\u0120index", "Spec", ",", "\u0120config", ".", "get", "Seg", "ment", "Write", "Out", "Medium", "Factory", "()", "\u0120);", "\u0120index", "To", "Pers", "ist", ".", "sw", "ap", "Seg", "ment", "(", "\u0120new", "\u0120Query", "able", "Index", "Seg", "ment", "(", "index", "IO", ".", "load", "Index", "(", "pers", "isted", "File", "),", "\u0120index", "To", "Pers", "ist", ".", "get", "Seg", "ment", "Id", "())", "\u0120);", "\u0120return", "\u0120num", "R", "ows", ";", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "make", "Alert", "(\"", "data", "Source", "[", "%", "s", "]", "\u0120--", "\u0120incremental", "\u0120persist", "\u0120failed", "\",", "\u0120schema", ".", "get", "Data", "Source", "())", "\u0120.", "add", "Data", "(\"", "inter", "val", "\",", "\u0120interval", ")", "\u0120.", "add", "Data", "(\"", "count", "\",", "\u0120index", "To", "Pers", "ist", ".", "get", "Count", "())", "\u0120.", "em", "it", "();", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Change", "\u0120doesn", "'t", "\u0120belong", "\u0120to", "\u0120this", "\u0120PR"]}
{"function": "private void doBuildProject(File projectLocation, IProgressMonitor monitor) throws CoreException { if (monitor.isCanceled()) { return; } try { monitor.beginTask(Messages.MSBuild_BuildProjectTask, 10); String msBuild = getMSBuildPath(); if (msBuild != null) { File csprojFile = WPProjectUtils.getCsrojFile(projectLocation); Assert.isNotNull(csprojFile); StringBuilder cmdString = new StringBuilder(msBuild); cmdString.append(\" \"); if (isRelease()) { cmdString.append(\"/p:Configuration=Release \"); } cmdString.append(csprojFile.getAbsolutePath()); ExternalProcessUtility processUtility = new ExternalProcessUtility(); if (monitor.isCanceled()) { return; } monitor.worked(1); TextDetectingStreamListener listener = new TextDetectingStreamListener( \"Build succeeded.\"); processUtility.execSync(cmdString.toString(), projectLocation, listener, listener, monitor, null, getLaunchConfiguration()); if (!listener.isTextDetected()) { throw new CoreException(new Status(IStatus.ERROR, WPCore.PLUGIN_ID, Messages.MSBuild_MSBuildError)); } } } finally { monitor.done(); } }", "text": "Needs quotes around the msbuild command", "function_tokens": ["private", "\u0120void", "\u0120do", "Build", "Project", "(", "File", "\u0120project", "Location", ",", "\u0120I", "Progress", "Monitor", "\u0120monitor", ")", "\u0120throws", "\u0120Core", "Exception", "\u0120{", "\u0120if", "\u0120(", "monitor", ".", "is", "C", "ance", "led", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120monitor", ".", "begin", "Task", "(", "Mess", "ages", ".", "MS", "Build", "_", "Build", "Project", "Task", ",", "\u012010", ");", "\u0120String", "\u0120ms", "Build", "\u0120=", "\u0120get", "MS", "Build", "Path", "();", "\u0120if", "\u0120(", "ms", "Build", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120File", "\u0120cs", "pro", "j", "File", "\u0120=", "\u0120WP", "Project", "Ut", "ils", ".", "get", "Cs", "ro", "j", "File", "(", "project", "Location", ");", "\u0120Ass", "ert", ".", "is", "Not", "Null", "(", "cs", "pro", "j", "File", ");", "\u0120String", "Builder", "\u0120cmd", "String", "\u0120=", "\u0120new", "\u0120String", "Builder", "(", "ms", "Build", ");", "\u0120cmd", "String", ".", "append", "(\"", "\u0120\"", ");", "\u0120if", "\u0120(", "is", "Release", "())", "\u0120{", "\u0120cmd", "String", ".", "append", "(\"", "/", "p", ":", "Configuration", "=", "Release", "\u0120\"", ");", "\u0120}", "\u0120cmd", "String", ".", "append", "(", "cs", "pro", "j", "File", ".", "get", "Abs", "olute", "Path", "());", "\u0120External", "Process", "Ut", "ility", "\u0120process", "Ut", "ility", "\u0120=", "\u0120new", "\u0120External", "Process", "Ut", "ility", "();", "\u0120if", "\u0120(", "monitor", ".", "is", "C", "ance", "led", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120monitor", ".", "worked", "(", "1", ");", "\u0120Text", "Detect", "ing", "Stream", "Listener", "\u0120listener", "\u0120=", "\u0120new", "\u0120Text", "Detect", "ing", "Stream", "Listener", "(", "\u0120\"", "Build", "\u0120succeeded", ".\"", ");", "\u0120process", "Ut", "ility", ".", "exec", "Sync", "(", "cmd", "String", ".", "to", "String", "(),", "\u0120project", "Location", ",", "\u0120listener", ",", "\u0120listener", ",", "\u0120monitor", ",", "\u0120null", ",", "\u0120get", "Launch", "Configuration", "());", "\u0120if", "\u0120(!", "list", "ener", ".", "is", "Text", "Det", "ected", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Core", "Exception", "(", "new", "\u0120Status", "(", "I", "Status", ".", "ERROR", ",", "\u0120W", "PC", "ore", ".", "PL", "UG", "IN", "_", "ID", ",", "\u0120Messages", ".", "MS", "Build", "_", "MS", "Build", "Error", "));", "\u0120}", "\u0120}", "\u0120}", "\u0120finally", "\u0120{", "\u0120monitor", ".", "done", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Need", "s", "\u0120quotes", "\u0120around", "\u0120the", "\u0120ms", "build", "\u0120command"]}
{"function": "private void initializeServices() { logger().debug(\"Initializing couchbase services on host: \" + enabledServices); final String services = enabledServices.stream().map(s -> { switch (s) { case KV: return \"kv\"; case QUERY: return \"n1ql\"; case INDEX: return \"index\"; case SEARCH: return \"fts\"; default: throw new IllegalStateException(\"Unknown service!\"); } }).collect(Collectors.joining(\",\")); Response response = doHttpRequest(MGMT_PORT, \"/node/controller/setupServices\", \"POST\", new FormBody.Builder() .add(\"services\", services) .build(), false ); checkSuccessfulResponse(response, \"Could not enable couchbase services\"); }", "text": "suggestion logger().debug(\"Initializing couchbase services on host: {}\", enabledServices);", "function_tokens": ["private", "\u0120void", "\u0120initialize", "Services", "()", "\u0120{", "\u0120logger", "().", "debug", "(\"", "Initial", "izing", "\u0120couch", "base", "\u0120services", "\u0120on", "\u0120host", ":", "\u0120\"", "\u0120+", "\u0120enabled", "Services", ");", "\u0120final", "\u0120String", "\u0120services", "\u0120=", "\u0120enabled", "Services", ".", "stream", "().", "map", "(", "s", "\u0120->", "\u0120{", "\u0120switch", "\u0120(", "s", ")", "\u0120{", "\u0120case", "\u0120K", "V", ":", "\u0120return", "\u0120\"", "k", "v", "\";", "\u0120case", "\u0120QU", "ERY", ":", "\u0120return", "\u0120\"", "n", "1", "ql", "\";", "\u0120case", "\u0120IND", "EX", ":", "\u0120return", "\u0120\"", "index", "\";", "\u0120case", "\u0120SE", "ARCH", ":", "\u0120return", "\u0120\"", "fts", "\";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "Unknown", "\u0120service", "!\"", ");", "\u0120}", "\u0120}", ").", "collect", "(", "Collect", "ors", ".", "joining", "(", "\",\"", "));", "\u0120Response", "\u0120response", "\u0120=", "\u0120do", "Http", "Request", "(", "MG", "MT", "_", "PORT", ",", "\u0120\"/", "node", "/", "controller", "/", "setup", "Services", "\",", "\u0120\"", "POST", "\",", "\u0120new", "\u0120Form", "Body", ".", "Builder", "()", "\u0120.", "add", "(\"", "services", "\",", "\u0120services", ")", "\u0120.", "build", "(),", "\u0120false", "\u0120);", "\u0120check", "Success", "ful", "Response", "(", "response", ",", "\u0120\"", "Could", "\u0120not", "\u0120enable", "\u0120couch", "base", "\u0120services", "\");", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120logger", "().", "debug", "(\"", "Initial", "izing", "\u0120couch", "base", "\u0120services", "\u0120on", "\u0120host", ":", "\u0120{}", "\",", "\u0120enabled", "Services", ");"]}
{"function": "public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) { Optional<Object> customHttpHeadersObject = context.getData(AZURE_REQUEST_HTTP_HEADERS_KEY); if (customHttpHeadersObject.isPresent() && customHttpHeadersObject.get() instanceof HttpHeaders) { HttpHeaders customHttpHeaders = (HttpHeaders) customHttpHeadersObject.get(); for (HttpHeader httpHeader : customHttpHeaders) { if (!Objects.isNull(httpHeader.getName()) && !Objects.isNull(httpHeader.getValue())) { context.getHttpRequest().getHeaders().put(httpHeader.getName(), httpHeader.getValue()); } } } return next.process(); }", "text": "This could be replaced with java context.getData(AZURE_REQUEST_HTTP_HEADERS_KEY).ifPresent(headers -> { // for loop over headers });", "function_tokens": ["public", "\u0120Mono", "<", "Http", "Response", ">", "\u0120process", "(", "Http", "P", "ip", "eline", "Call", "Context", "\u0120context", ",", "\u0120H", "ttp", "P", "ip", "eline", "Next", "Policy", "\u0120next", ")", "\u0120{", "\u0120Optional", "<", "Object", ">", "\u0120custom", "Http", "Head", "ers", "Object", "\u0120=", "\u0120context", ".", "get", "Data", "(", "AZ", "URE", "_", "RE", "QUEST", "_", "HTTP", "_", "HEAD", "ERS", "_", "KEY", ");", "\u0120if", "\u0120(", "custom", "Http", "Head", "ers", "Object", ".", "is", "Present", "()", "\u0120&&", "\u0120custom", "Http", "Head", "ers", "Object", ".", "get", "()", "\u0120instance", "of", "\u0120H", "ttp", "Head", "ers", ")", "\u0120{", "\u0120H", "ttp", "Head", "ers", "\u0120custom", "Http", "Head", "ers", "\u0120=", "\u0120(", "Http", "Head", "ers", ")", "\u0120custom", "Http", "Head", "ers", "Object", ".", "get", "();", "\u0120for", "\u0120(", "Http", "Header", "\u0120http", "Header", "\u0120:", "\u0120custom", "Http", "Head", "ers", ")", "\u0120{", "\u0120if", "\u0120(!", "Object", "s", ".", "is", "Null", "(", "http", "Header", ".", "get", "Name", "())", "\u0120&&", "\u0120!", "Object", "s", ".", "is", "Null", "(", "http", "Header", ".", "get", "Value", "()", "))", "\u0120{", "\u0120context", ".", "get", "Http", "Request", "().", "get", "Head", "ers", "().", "put", "(", "http", "Header", ".", "get", "Name", "(),", "\u0120http", "Header", ".", "get", "Value", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120next", ".", "process", "();", "\u0120}"], "docstring_tokens": ["This", "\u0120could", "\u0120be", "\u0120replaced", "\u0120with", "\u0120java", "\u0120context", ".", "get", "Data", "(", "AZ", "URE", "_", "RE", "QUEST", "_", "HTTP", "_", "HEAD", "ERS", "_", "KEY", ").", "if", "Present", "(", "headers", "\u0120->", "\u0120{", "\u0120//", "\u0120for", "\u0120loop", "\u0120over", "\u0120headers", "\u0120});"]}
{"function": "public ExpressionAnalysis( Map<NodeRef<Expression>, Type> expressionTypes, Map<NodeRef<Expression>, Type> expressionCoercions, Set<NodeRef<InPredicate>> subqueryInPredicates, Set<NodeRef<SubqueryExpression>> scalarSubqueries, Set<NodeRef<ExistsPredicate>> existsSubqueries, Map<NodeRef<Expression>, FieldId> columnReferences, Set<NodeRef<Expression>> typeOnlyCoercions, Set<NodeRef<QuantifiedComparisonExpression>> quantifiedComparisons, Map<NodeRef<Identifier>, LambdaArgumentDeclaration> lambdaArgumentReferences) { this.expressionTypes = new LinkedHashMap<>(requireNonNull(expressionTypes, \"expressionTypes is null\")); this.expressionCoercions = new LinkedHashMap<>(requireNonNull(expressionCoercions, \"expressionCoercions is null\")); this.typeOnlyCoercions = new LinkedHashSet<>(requireNonNull(typeOnlyCoercions, \"typeOnlyCoercions is null\")); this.columnReferences = new LinkedHashMap<>(requireNonNull(columnReferences, \"columnReferences is null\")); this.subqueryInPredicates = new LinkedHashSet<>(requireNonNull(subqueryInPredicates, \"subqueryInPredicates is null\")); this.scalarSubqueries = new LinkedHashSet<>(requireNonNull(scalarSubqueries, \"subqueryInPredicates is null\")); this.existsSubqueries = new LinkedHashSet<>(requireNonNull(existsSubqueries, \"existsSubqueries is null\")); this.quantifiedComparisons = new LinkedHashSet<>(requireNonNull(quantifiedComparisons, \"quantifiedComparisons is null\")); this.lambdaArgumentReferences = new LinkedHashMap<>(requireNonNull(lambdaArgumentReferences, \"lambdaArgumentReferences is null\")); }", "text": "wrap with unmodifiableSet in constructor and then just return field reference from get* methods.", "function_tokens": ["public", "\u0120Expression", "Analysis", "(", "\u0120Map", "<", "Node", "Ref", "<", "Exp", "ression", ">,", "\u0120Type", ">", "\u0120expression", "Types", ",", "\u0120Map", "<", "Node", "Ref", "<", "Exp", "ression", ">,", "\u0120Type", ">", "\u0120expression", "Co", "erc", "ions", ",", "\u0120Set", "<", "Node", "Ref", "<", "In", "Pred", "icate", ">>", "\u0120sub", "query", "In", "Pred", "icates", ",", "\u0120Set", "<", "Node", "Ref", "<", "Sub", "query", "Exp", "ression", ">>", "\u0120scal", "ar", "Sub", "qu", "eries", ",", "\u0120Set", "<", "Node", "Ref", "<", "Ex", "ists", "Pred", "icate", ">>", "\u0120exists", "Sub", "qu", "eries", ",", "\u0120Map", "<", "Node", "Ref", "<", "Exp", "ression", ">,", "\u0120Field", "Id", ">", "\u0120column", "References", ",", "\u0120Set", "<", "Node", "Ref", "<", "Exp", "ression", ">>", "\u0120type", "Only", "Co", "erc", "ions", ",", "\u0120Set", "<", "Node", "Ref", "<", "Quant", "ified", "Compar", "ison", "Exp", "ression", ">>", "\u0120quant", "ified", "Compar", "isons", ",", "\u0120Map", "<", "Node", "Ref", "<", "Ident", "ifier", ">,", "\u0120Lamb", "da", "Arg", "ument", "Decl", "aration", ">", "\u0120lambda", "Arg", "ument", "References", ")", "\u0120{", "\u0120this", ".", "expression", "Types", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Map", "<", ">(", "require", "Non", "Null", "(", "expression", "Types", ",", "\u0120\"", "expression", "Types", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "expression", "Co", "erc", "ions", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Map", "<", ">(", "require", "Non", "Null", "(", "expression", "Co", "erc", "ions", ",", "\u0120\"", "expression", "Co", "erc", "ions", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "type", "Only", "Co", "erc", "ions", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Set", "<", ">(", "require", "Non", "Null", "(", "type", "Only", "Co", "erc", "ions", ",", "\u0120\"", "type", "Only", "Co", "erc", "ions", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "column", "References", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Map", "<", ">(", "require", "Non", "Null", "(", "column", "References", ",", "\u0120\"", "column", "References", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "sub", "query", "In", "Pred", "icates", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Set", "<", ">(", "require", "Non", "Null", "(", "sub", "query", "In", "Pred", "icates", ",", "\u0120\"", "sub", "query", "In", "Pred", "icates", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "sc", "al", "ar", "Sub", "qu", "eries", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Set", "<", ">(", "require", "Non", "Null", "(", "sc", "al", "ar", "Sub", "qu", "eries", ",", "\u0120\"", "sub", "query", "In", "Pred", "icates", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "ex", "ists", "Sub", "qu", "eries", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Set", "<", ">(", "require", "Non", "Null", "(", "ex", "ists", "Sub", "qu", "eries", ",", "\u0120\"", "ex", "ists", "Sub", "qu", "eries", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "quant", "ified", "Compar", "isons", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Set", "<", ">(", "require", "Non", "Null", "(", "quant", "ified", "Compar", "isons", ",", "\u0120\"", "quant", "ified", "Compar", "isons", "\u0120is", "\u0120null", "\")", ");", "\u0120this", ".", "lambda", "Arg", "ument", "References", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Map", "<", ">(", "require", "Non", "Null", "(", "lambda", "Arg", "ument", "References", ",", "\u0120\"", "lambda", "Arg", "ument", "References", "\u0120is", "\u0120null", "\")", ");", "\u0120}"], "docstring_tokens": ["wrap", "\u0120with", "\u0120un", "mod", "ifiable", "Set", "\u0120in", "\u0120constructor", "\u0120and", "\u0120then", "\u0120just", "\u0120return", "\u0120field", "\u0120reference", "\u0120from", "\u0120get", "*", "\u0120methods", "."]}
{"function": "public FreeStyleProject newInstance(Branch branch) { FreeStyleProject job = new FreeStyleProject(getOwner(), branch.getEncodedName()); setBranch(job, branch); try { job.setQuietPeriod(0); } catch(IOException e) { e.printStackTrace(); } return job; }", "text": "For test stability we maintain the previous quiet period of 0. But live behavior will change.", "function_tokens": ["public", "\u0120Free", "Style", "Project", "\u0120new", "Instance", "(", "B", "ranch", "\u0120branch", ")", "\u0120{", "\u0120Free", "Style", "Project", "\u0120job", "\u0120=", "\u0120new", "\u0120Free", "Style", "Project", "(", "get", "Owner", "(),", "\u0120branch", ".", "get", "Enc", "oded", "Name", "());", "\u0120set", "B", "ranch", "(", "job", ",", "\u0120branch", ");", "\u0120try", "\u0120{", "\u0120job", ".", "set", "Qu", "iet", "Per", "iod", "(", "0", ");", "\u0120}", "\u0120catch", "(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120return", "\u0120job", ";", "\u0120}"], "docstring_tokens": ["For", "\u0120test", "\u0120stability", "\u0120we", "\u0120maintain", "\u0120the", "\u0120previous", "\u0120quiet", "\u0120period", "\u0120of", "\u01200", ".", "\u0120But", "\u0120live", "\u0120behavior", "\u0120will", "\u0120change", "."]}
{"function": "public void init(final GlusterVolumeGeoRepCreateModel model) { super.init(model); model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() { @Override public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) { if(args.propertyName.equalsIgnoreCase(\"RecommendationViolations\")) { getView().setSuggestedConfigViolations(model.getRecommendationViolations()); } else if (args.propertyName.equalsIgnoreCase(\"QueryFailed\")) { getView().setFailureMessage(model.getQueryFailureMessage()); } } }); model.getSlaveUserName().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() { @Override public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) { String slaveUser = model.getSlaveUserName() .getEntity(); getView().setUserGroupVisibility(slaveUser != null && !slaveUser .equalsIgnoreCase(ConstantsManager.getInstance().getConstants().rootUser())); } }); }", "text": "You could do this in the model itself because userGroup is already represented in model. getSlaveUserGroupName().setIsChangeable() can be used to make the ui-editor to enable or disable.", "function_tokens": ["public", "\u0120void", "\u0120init", "(", "final", "\u0120Gl", "uster", "Volume", "Ge", "o", "Rep", "Create", "Model", "\u0120model", ")", "\u0120{", "\u0120super", ".", "init", "(", "model", ");", "\u0120model", ".", "get", "Property", "Changed", "Event", "().", "add", "Listener", "(", "new", "\u0120I", "Event", "Listener", "<", "Property", "Changed", "Event", "Args", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120event", "Ra", "ised", "(", "Event", "<?", "\u0120extends", "\u0120Property", "Changed", "Event", "Args", ">", "\u0120ev", ",", "\u0120Object", "\u0120sender", ",", "\u0120Property", "Changed", "Event", "Args", "\u0120args", ")", "\u0120{", "\u0120if", "(", "args", ".", "property", "Name", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "Recommend", "ation", "Viol", "ations", "\"))", "\u0120{", "\u0120get", "View", "().", "set", "Suggest", "ed", "Config", "Viol", "ations", "(", "model", ".", "get", "Recommend", "ation", "Viol", "ations", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "args", ".", "property", "Name", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "Query", "F", "ailed", "\"))", "\u0120{", "\u0120get", "View", "().", "set", "Failure", "Message", "(", "model", ".", "get", "Query", "Failure", "Message", "());", "\u0120}", "\u0120}", "\u0120});", "\u0120model", ".", "get", "Sl", "ave", "User", "Name", "().", "get", "Entity", "Changed", "Event", "().", "add", "Listener", "(", "new", "\u0120I", "Event", "Listener", "<", "Event", "Args", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120event", "Ra", "ised", "(", "Event", "<?", "\u0120extends", "\u0120Event", "Args", ">", "\u0120ev", ",", "\u0120Object", "\u0120sender", ",", "\u0120Event", "Args", "\u0120args", ")", "\u0120{", "\u0120String", "\u0120slave", "User", "\u0120=", "\u0120model", ".", "get", "Sl", "ave", "User", "Name", "()", "\u0120.", "get", "Entity", "();", "\u0120get", "View", "().", "set", "User", "Group", "Vis", "ibility", "(", "slave", "User", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "slave", "User", "\u0120.", "equ", "als", "Ign", "ore", "Case", "(", "Const", "ants", "Manager", ".", "get", "Instance", "().", "get", "Const", "ants", "().", "root", "User", "()", "));", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["You", "\u0120could", "\u0120do", "\u0120this", "\u0120in", "\u0120the", "\u0120model", "\u0120itself", "\u0120because", "\u0120user", "Group", "\u0120is", "\u0120already", "\u0120represented", "\u0120in", "\u0120model", ".", "\u0120get", "Sl", "ave", "User", "Group", "Name", "().", "set", "Is", "Change", "able", "()", "\u0120can", "\u0120be", "\u0120used", "\u0120to", "\u0120make", "\u0120the", "\u0120u", "i", "-", "editor", "\u0120to", "\u0120enable", "\u0120or", "\u0120disable", "."]}
{"function": "public Scheduler cleanupResponseUrlDataScheduler() throws SchedulerException { return this.constructScheduler(ResponseDataCleanupJob.class, KEY_CLEANUP_JOB_THREAD_COUNT, KEY_CLEANUP_JOB_CRON_EXPRESSION, this.getDatabaseUrl(), this.databaseUsername, this.databasePassword, this.databaseDriver); }", "text": "My guess is that ResponseUrlDataCleanupJob.class should be used here in stead of ResponseDataCleanupJob.class?", "function_tokens": ["public", "\u0120Sched", "uler", "\u0120cleanup", "Response", "Url", "Data", "S", "ched", "uler", "()", "\u0120throws", "\u0120Sched", "uler", "Exception", "\u0120{", "\u0120return", "\u0120this", ".", "construct", "S", "ched", "uler", "(", "Response", "Data", "Clean", "up", "Job", ".", "class", ",", "\u0120KEY", "_", "CLE", "AN", "UP", "_", "J", "OB", "_", "TH", "READ", "_", "C", "OUNT", ",", "\u0120KEY", "_", "CLE", "AN", "UP", "_", "J", "OB", "_", "CR", "ON", "_", "EX", "PRESS", "ION", ",", "\u0120this", ".", "get", "Database", "Url", "(),", "\u0120this", ".", "database", "Us", "ername", ",", "\u0120this", ".", "database", "Password", ",", "\u0120this", ".", "database", "Driver", ");", "\u0120}"], "docstring_tokens": ["My", "\u0120guess", "\u0120is", "\u0120that", "\u0120Response", "Url", "Data", "Clean", "up", "Job", ".", "class", "\u0120should", "\u0120be", "\u0120used", "\u0120here", "\u0120in", "\u0120stead", "\u0120of", "\u0120Response", "Data", "Clean", "up", "Job", ".", "class", "?"]}
{"function": "public void generateType(final Ds3Type typeEntry) throws IOException { final Template typeTemplate = config.getTemplate(\"TypeEnumConstant.tmplt\"); final Type type = TypeConverter.toType(typeEntry); final Path outputPath = getTypeOutputPath(type); final OutputStream outStream = fileUtils.getOutputFile(outputPath); final Writer writer = new OutputStreamWriter(outStream); try { typeTemplate.process(type, writer); } catch (final NullPointerException e) { LOG.error(\"Encountered NullPointerException while processing template \" + typeTemplate.getName(), e); e.printStackTrace(); } catch (final TemplateException e) { LOG.error(\"Encountered TemplateException while processing template \" + typeTemplate.getName(), e); e.printStackTrace(); } }", "text": "Since you are appending the exception in the logging statement, you do not have to then print the stack trace. This will actually result in the stack being printing twice, depending on how the logger is configured.", "function_tokens": ["public", "\u0120void", "\u0120generate", "Type", "(", "final", "\u0120D", "s", "3", "Type", "\u0120type", "Entry", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120final", "\u0120Template", "\u0120type", "Template", "\u0120=", "\u0120config", ".", "get", "Template", "(\"", "Type", "En", "um", "Con", "stant", ".", "tm", "pl", "t", "\");", "\u0120final", "\u0120Type", "\u0120type", "\u0120=", "\u0120Type", "Con", "ver", "ter", ".", "to", "Type", "(", "type", "Entry", ");", "\u0120final", "\u0120Path", "\u0120output", "Path", "\u0120=", "\u0120get", "Type", "Output", "Path", "(", "type", ");", "\u0120final", "\u0120Output", "Stream", "\u0120out", "Stream", "\u0120=", "\u0120file", "Ut", "ils", ".", "get", "Output", "File", "(", "output", "Path", ");", "\u0120final", "\u0120Writer", "\u0120writer", "\u0120=", "\u0120new", "\u0120Output", "Stream", "Writer", "(", "out", "Stream", ");", "\u0120try", "\u0120{", "\u0120type", "Template", ".", "process", "(", "type", ",", "\u0120writer", ");", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Null", "Po", "inter", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "En", "count", "ered", "\u0120Null", "Po", "inter", "Exception", "\u0120while", "\u0120processing", "\u0120template", "\u0120\"", "\u0120+", "\u0120type", "Template", ".", "get", "Name", "(),", "\u0120e", ");", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Template", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "En", "count", "ered", "\u0120Template", "Exception", "\u0120while", "\u0120processing", "\u0120template", "\u0120\"", "\u0120+", "\u0120type", "Template", ".", "get", "Name", "(),", "\u0120e", ");", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Since", "\u0120you", "\u0120are", "\u0120app", "ending", "\u0120the", "\u0120exception", "\u0120in", "\u0120the", "\u0120logging", "\u0120statement", ",", "\u0120you", "\u0120do", "\u0120not", "\u0120have", "\u0120to", "\u0120then", "\u0120print", "\u0120the", "\u0120stack", "\u0120trace", ".", "\u0120This", "\u0120will", "\u0120actually", "\u0120result", "\u0120in", "\u0120the", "\u0120stack", "\u0120being", "\u0120printing", "\u0120twice", ",", "\u0120depending", "\u0120on", "\u0120how", "\u0120the", "\u0120logger", "\u0120is", "\u0120configured", "."]}
{"function": "private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if (!desiredColumns.isEmpty()) { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }", "text": "return before instantiating the map?", "function_tokens": ["private", "\u0120Map", "<", "Long", ",", "\u0120IS", "eg", "ment", "As", "pect", ">", "\u0120get", "As", "pects", "From", "Column", "s", "Id", "(", "List", "<", "Long", ">", "\u0120desired", "Column", "s", ")", "\u0120{", "\u0120Map", "<", "Long", ",", "\u0120IS", "eg", "ment", "As", "pect", ">", "\u0120aspects", "\u0120=", "\u0120new", "\u0120Link", "ed", "Hash", "Map", "<", ">", "();", "\u0120if", "\u0120(!", "des", "ired", "Column", "s", ".", "is", "Empty", "())", "\u0120{", "\u0120for", "\u0120(", "Long", "\u0120columns", "Id", "\u0120:", "\u0120desired", "Column", "s", ")", "\u0120{", "\u0120IS", "eg", "ment", "As", "pect", "\u0120segment", "As", "pect", "\u0120=", "\u0120f", "As", "pect", "Map", ".", "get", "(", "column", "s", "Id", ");", "\u0120if", "\u0120(", "se", "gment", "As", "pect", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120aspects", ".", "put", "(", "column", "s", "Id", ",", "\u0120segment", "As", "pect", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120aspects", ";", "\u0120}", "\u0120return", "\u0120f", "As", "pect", "Map", ";", "\u0120}"], "docstring_tokens": ["return", "\u0120before", "\u0120instant", "iating", "\u0120the", "\u0120map", "?"]}
{"function": "public String toString() { return \"KubernetesCloud '\" + name + \"' serverUrl :\" + serverUrl; }", "text": "more of a personal taste question, but why don't you like Guava MoreObjects ?", "function_tokens": ["public", "\u0120String", "\u0120to", "String", "()", "\u0120{", "\u0120return", "\u0120\"", "K", "uber", "net", "es", "Cloud", "\u0120'", "\"", "\u0120+", "\u0120name", "\u0120+", "\u0120\"'", "\u0120server", "Url", "\u0120:", "\"", "\u0120+", "\u0120server", "Url", ";", "\u0120}"], "docstring_tokens": ["more", "\u0120of", "\u0120a", "\u0120personal", "\u0120taste", "\u0120question", ",", "\u0120but", "\u0120why", "\u0120don", "'t", "\u0120you", "\u0120like", "\u0120Gu", "ava", "\u0120More", "Object", "s", "\u0120?"]}
{"function": "public int getOptimalTileWidth() { FormatTools.assertId(currentId, true, 1); RandomAccessInputStream plane = getPlane(getSeries(), 0); if (plane == null) return super.getOptimalTileWidth(); try { TiffParser tp = new TiffParser(plane); IFD ifd = tp.getFirstIFD(); return (int) ifd.getTileWidth(); } catch (FormatException e) { LOGGER.debug(\"Could not retrieve tile width\", e); } catch (IOException e) { LOGGER.debug(\"Could not retrieve tile width\", e); } finally { try { plane.close(); } catch (IOException e2) { LOGGER.debug(\"Could not close stream\", e2); } } return super.getOptimalTileWidth(); }", "text": "You can use RAIS plane2 = plane here, e.g.:  import java.io.Closeable; class C implements Closeable { public void close() { System.out.println(\"closed\"); } } public class M { public static void main(String[] args) { C c = new C(); try (C c2 = c) { System.out.println(\"done\"); } } }", "function_tokens": ["public", "\u0120int", "\u0120get", "Opt", "imal", "Tile", "Width", "()", "\u0120{", "\u0120Format", "Tools", ".", "assert", "Id", "(", "current", "Id", ",", "\u0120true", ",", "\u01201", ");", "\u0120Random", "Access", "Input", "Stream", "\u0120plane", "\u0120=", "\u0120get", "Pl", "ane", "(", "get", "Series", "(),", "\u01200", ");", "\u0120if", "\u0120(", "plane", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120super", ".", "get", "Opt", "imal", "Tile", "Width", "();", "\u0120try", "\u0120{", "\u0120Tiff", "Parser", "\u0120t", "p", "\u0120=", "\u0120new", "\u0120Tiff", "Parser", "(", "plane", ");", "\u0120IF", "D", "\u0120if", "d", "\u0120=", "\u0120t", "p", ".", "get", "First", "IF", "D", "();", "\u0120return", "\u0120(", "int", ")", "\u0120if", "d", ".", "get", "Tile", "Width", "();", "\u0120}", "\u0120catch", "\u0120(", "Format", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Could", "\u0120not", "\u0120retrieve", "\u0120tile", "\u0120width", "\",", "\u0120e", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Could", "\u0120not", "\u0120retrieve", "\u0120tile", "\u0120width", "\",", "\u0120e", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120try", "\u0120{", "\u0120plane", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", "2", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Could", "\u0120not", "\u0120close", "\u0120stream", "\",", "\u0120e", "2", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120super", ".", "get", "Opt", "imal", "Tile", "Width", "();", "\u0120}"], "docstring_tokens": ["You", "\u0120can", "\u0120use", "\u0120RA", "IS", "\u0120plane", "2", "\u0120=", "\u0120plane", "\u0120here", ",", "\u0120e", ".", "g", ".:", "\u0120", "\u0120import", "\u0120java", ".", "io", ".", "Close", "able", ";", "\u0120class", "\u0120C", "\u0120implements", "\u0120Close", "able", "\u0120{", "\u0120public", "\u0120void", "\u0120close", "()", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "closed", "\");", "\u0120}", "\u0120}", "\u0120public", "\u0120class", "\u0120M", "\u0120{", "\u0120public", "\u0120static", "\u0120void", "\u0120main", "(", "String", "[]", "\u0120args", ")", "\u0120{", "\u0120C", "\u0120c", "\u0120=", "\u0120new", "\u0120C", "();", "\u0120try", "\u0120(", "C", "\u0120c", "2", "\u0120=", "\u0120c", ")", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "done", "\");", "\u0120}", "\u0120}", "\u0120}"]}
{"function": "public void createOrLoadKey() { String keyLocation = env.getProperty(\"keyLocation\"); if (rsaJsonWebKey == null) { try { loadSavedKey(keyLocation); } catch (ClassNotFoundException | IOException e1) { logger.error(\"Key not found or error loading key. Creating new key. \", e1); try { RsaKeyUtil keyUtil = new RsaKeyUtil(); KeyPair keyPair; keyPair = keyUtil.generateKeyPair(2048); rsaJsonWebKey = (RsaJsonWebKey) PublicJsonWebKey.Factory.newPublicJwk(keyPair.getPublic()); rsaJsonWebKey.setPrivateKey(keyPair.getPrivate()); saveKey(keyLocation); } catch (JoseException e) { logger.error(\"Error creating key: \", e1); throw new RuntimeException(e); } } } }", "text": "2048 looks like a magic number", "function_tokens": ["public", "\u0120void", "\u0120create", "Or", "Load", "Key", "()", "\u0120{", "\u0120String", "\u0120key", "Location", "\u0120=", "\u0120env", ".", "get", "Property", "(\"", "key", "Location", "\");", "\u0120if", "\u0120(", "rs", "a", "J", "son", "Web", "Key", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120load", "S", "aved", "Key", "(", "key", "Location", ");", "\u0120}", "\u0120catch", "\u0120(", "Class", "Not", "Found", "Exception", "\u0120|", "\u0120IO", "Exception", "\u0120e", "1", ")", "\u0120{", "\u0120logger", ".", "error", "(\"", "Key", "\u0120not", "\u0120found", "\u0120or", "\u0120error", "\u0120loading", "\u0120key", ".", "\u0120Creating", "\u0120new", "\u0120key", ".", "\u0120\",", "\u0120e", "1", ");", "\u0120try", "\u0120{", "\u0120R", "sa", "Key", "Ut", "il", "\u0120key", "Ut", "il", "\u0120=", "\u0120new", "\u0120R", "sa", "Key", "Ut", "il", "();", "\u0120Key", "P", "air", "\u0120key", "P", "air", ";", "\u0120key", "P", "air", "\u0120=", "\u0120key", "Ut", "il", ".", "gener", "ate", "Key", "P", "air", "(", "20", "48", ");", "\u0120r", "sa", "J", "son", "Web", "Key", "\u0120=", "\u0120(", "R", "sa", "J", "son", "Web", "Key", ")", "\u0120Public", "J", "son", "Web", "Key", ".", "Factory", ".", "new", "Public", "J", "wk", "(", "key", "P", "air", ".", "get", "Public", "());", "\u0120r", "sa", "J", "son", "Web", "Key", ".", "set", "Private", "Key", "(", "key", "P", "air", ".", "get", "Private", "());", "\u0120save", "Key", "(", "key", "Location", ");", "\u0120}", "\u0120catch", "\u0120(", "Jose", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "error", "(\"", "Error", "\u0120creating", "\u0120key", ":", "\u0120\",", "\u0120e", "1", ");", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["20", "48", "\u0120looks", "\u0120like", "\u0120a", "\u0120magic", "\u0120number"]}
{"function": "public synchronized void onJobArrival(final JobEntity jobEntity) { final int numResourcesToUse = jobEntity.getNumWorkers() + jobEntity.getNumServers(); if (numAvailableResources >= numResourcesToUse) { LOG.log(Level.INFO, \"Start job {0} with {1} resources. Remaining free resources: {2}\", new Object[]{jobEntity.getJobId(), numAvailableResources, numAvailableResources - numResourcesToUse}); numAvailableResources -= numResourcesToUse; jobServerDriverFuture.get().executeJob(jobEntity); } else { LOG.log(Level.INFO, \"Put job {0} into queue\", jobEntity.getJobId()); jobWaitingQueue.add(jobEntity); } }", "text": "this code block (if in L54-L59) can be encapsulated into a method to avoid duplicate in onJobFinished(), something like boolean tryExecute() that returns whether the job execution was successful", "function_tokens": ["public", "\u0120synchronized", "\u0120void", "\u0120on", "Job", "Ar", "rival", "(", "final", "\u0120Job", "Entity", "\u0120job", "Entity", ")", "\u0120{", "\u0120final", "\u0120int", "\u0120num", "Resources", "To", "Use", "\u0120=", "\u0120job", "Entity", ".", "get", "Num", "Work", "ers", "()", "\u0120+", "\u0120job", "Entity", ".", "get", "Num", "Ser", "vers", "();", "\u0120if", "\u0120(", "num", "Available", "Resources", "\u0120>=", "\u0120num", "Resources", "To", "Use", ")", "\u0120{", "\u0120LOG", ".", "log", "(", "Level", ".", "INFO", ",", "\u0120\"", "Start", "\u0120job", "\u0120{", "0", "}", "\u0120with", "\u0120{", "1", "}", "\u0120resources", ".", "\u0120Rem", "aining", "\u0120free", "\u0120resources", ":", "\u0120{", "2", "}", "\",", "\u0120new", "\u0120Object", "[]", "{", "job", "Entity", ".", "get", "Job", "Id", "(),", "\u0120num", "Available", "Resources", ",", "\u0120num", "Available", "Resources", "\u0120-", "\u0120num", "Resources", "To", "Use", "});", "\u0120num", "Available", "Resources", "\u0120-=", "\u0120num", "Resources", "To", "Use", ";", "\u0120job", "Server", "Driver", "Future", ".", "get", "().", "execute", "Job", "(", "job", "Entity", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", ".", "log", "(", "Level", ".", "INFO", ",", "\u0120\"", "Put", "\u0120job", "\u0120{", "0", "}", "\u0120into", "\u0120queue", "\",", "\u0120job", "Entity", ".", "get", "Job", "Id", "());", "\u0120job", "Wa", "iting", "Queue", ".", "add", "(", "job", "Entity", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["this", "\u0120code", "\u0120block", "\u0120(", "if", "\u0120in", "\u0120L", "54", "-", "L", "59", ")", "\u0120can", "\u0120be", "\u0120encaps", "ulated", "\u0120into", "\u0120a", "\u0120method", "\u0120to", "\u0120avoid", "\u0120duplicate", "\u0120in", "\u0120on", "Job", "Fin", "ished", "(),", "\u0120something", "\u0120like", "\u0120boolean", "\u0120try", "Exec", "ute", "()", "\u0120that", "\u0120returns", "\u0120whether", "\u0120the", "\u0120job", "\u0120execution", "\u0120was", "\u0120successful"]}
{"function": "AuthenticatingHttpConnector(final String user, final Optional<AgentProxy> agentProxyOpt, final Optional<Path> clientCertificatePath, final Optional<Path> clientKeyPath, final EndpointIterator endpointIterator, final DefaultHttpConnector delegate, final List<Identity> identities) { if (clientCertificatePath.isPresent() ^ clientKeyPath.isPresent()) { throw new IllegalArgumentException( \"both or neither of clientCertificatePath and clientKeyPath must be specified\"); } this.user = user; this.agentProxy = agentProxyOpt; this.clientCertificatePath = clientCertificatePath; this.clientKeyPath = clientKeyPath; this.endpointIterator = endpointIterator; this.delegate = delegate; this.identities = identities; }", "text": "u fancy", "function_tokens": ["Authent", "icating", "Http", "Connector", "(", "final", "\u0120String", "\u0120user", ",", "\u0120final", "\u0120Optional", "<", "Agent", "Proxy", ">", "\u0120agent", "Proxy", "Opt", ",", "\u0120final", "\u0120Optional", "<", "Path", ">", "\u0120client", "Cert", "ificate", "Path", ",", "\u0120final", "\u0120Optional", "<", "Path", ">", "\u0120client", "Key", "Path", ",", "\u0120final", "\u0120End", "point", "Iterator", "\u0120endpoint", "Iterator", ",", "\u0120final", "\u0120Default", "Http", "Connector", "\u0120delegate", ",", "\u0120final", "\u0120List", "<", "Id", "entity", ">", "\u0120identities", ")", "\u0120{", "\u0120if", "\u0120(", "client", "Cert", "ificate", "Path", ".", "is", "Present", "()", "\u0120^", "\u0120client", "Key", "Path", ".", "is", "Present", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "both", "\u0120or", "\u0120neither", "\u0120of", "\u0120client", "Cert", "ificate", "Path", "\u0120and", "\u0120client", "Key", "Path", "\u0120must", "\u0120be", "\u0120specified", "\");", "\u0120}", "\u0120this", ".", "user", "\u0120=", "\u0120user", ";", "\u0120this", ".", "agent", "Proxy", "\u0120=", "\u0120agent", "Proxy", "Opt", ";", "\u0120this", ".", "client", "Cert", "ificate", "Path", "\u0120=", "\u0120client", "Cert", "ificate", "Path", ";", "\u0120this", ".", "client", "Key", "Path", "\u0120=", "\u0120client", "Key", "Path", ";", "\u0120this", ".", "end", "point", "Iterator", "\u0120=", "\u0120endpoint", "Iterator", ";", "\u0120this", ".", "de", "legate", "\u0120=", "\u0120delegate", ";", "\u0120this", ".", "ident", "ities", "\u0120=", "\u0120identities", ";", "\u0120}"], "docstring_tokens": ["u", "\u0120fancy"]}
{"function": "public Set<List<JavaFileScannerContext.Location>> flow(List<Integer> parameterIndices, List<Class<? extends Constraint>> domains) { Preconditions.checkArgument(!parameterIndices.isEmpty(), \"computing flow on empty symbolic value list should never happen\"); if(node == null || behavior == null) { return Collections.emptySet(); } String key = parameterIndices.stream().sorted().map(Object::toString).reduce(\"\", String::concat); String domainKey = domains.stream().map(Class::getName).sorted().reduce(\"\", String::concat); Map<String, Set<List<JavaFileScannerContext.Location>>> flowByDomain = cachedFlows.computeIfAbsent(key, k -> new HashMap<>()); return flowByDomain.computeIfAbsent(domainKey, k -> FlowComputation.flow(node, getSymbolicValues(parameterIndices), c -> true, c -> false, domains, node.programState.getLastEvaluated())); }", "text": "I'm not sure about that generating the key like this will be unique: from how I see it, if we call the method with [1,2], we will end up with the same key (\"12\") as asking for the 12th parameter with the list [12]. (I know this is pretty unlikely, but still...)", "function_tokens": ["public", "\u0120Set", "<", "List", "<", "Java", "File", "Scan", "ner", "Context", ".", "Location", ">>", "\u0120flow", "(", "List", "<", "Integer", ">", "\u0120parameter", "Ind", "ices", ",", "\u0120List", "<", "Class", "<?", "\u0120extends", "\u0120Con", "str", "aint", ">>", "\u0120domains", ")", "\u0120{", "\u0120Pre", "cond", "itions", ".", "check", "Arg", "ument", "(", "!", "param", "eter", "Ind", "ices", ".", "is", "Empty", "(),", "\u0120\"", "com", "puting", "\u0120flow", "\u0120on", "\u0120empty", "\u0120symbolic", "\u0120value", "\u0120list", "\u0120should", "\u0120never", "\u0120happen", "\");", "\u0120if", "(", "node", "\u0120==", "\u0120null", "\u0120||", "\u0120behavior", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120Collections", ".", "empty", "Set", "();", "\u0120}", "\u0120String", "\u0120key", "\u0120=", "\u0120parameter", "Ind", "ices", ".", "stream", "().", "s", "orted", "().", "map", "(", "Object", "::", "to", "String", ").", "red", "uce", "(\"", "\",", "\u0120String", "::", "con", "cat", ");", "\u0120String", "\u0120domain", "Key", "\u0120=", "\u0120domains", ".", "stream", "().", "map", "(", "Class", "::", "get", "Name", ").", "s", "orted", "().", "red", "uce", "(\"", "\",", "\u0120String", "::", "con", "cat", ");", "\u0120Map", "<", "String", ",", "\u0120Set", "<", "List", "<", "Java", "File", "Scan", "ner", "Context", ".", "Location", ">>>", "\u0120flow", "By", "Domain", "\u0120=", "\u0120cached", "Fl", "ows", ".", "comp", "ute", "If", "Abs", "ent", "(", "key", ",", "\u0120k", "\u0120->", "\u0120new", "\u0120Hash", "Map", "<", ">", "());", "\u0120return", "\u0120flow", "By", "Domain", ".", "comp", "ute", "If", "Abs", "ent", "(", "domain", "Key", ",", "\u0120k", "\u0120->", "\u0120Flow", "Com", "put", "ation", ".", "flow", "(", "node", ",", "\u0120get", "Sy", "mb", "olic", "Values", "(", "param", "eter", "Ind", "ices", "),", "\u0120c", "\u0120->", "\u0120true", ",", "\u0120c", "\u0120->", "\u0120false", ",", "\u0120domains", ",", "\u0120node", ".", "program", "State", ".", "get", "Last", "E", "val", "uated", "()", "));", "\u0120}"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120sure", "\u0120about", "\u0120that", "\u0120generating", "\u0120the", "\u0120key", "\u0120like", "\u0120this", "\u0120will", "\u0120be", "\u0120unique", ":", "\u0120from", "\u0120how", "\u0120I", "\u0120see", "\u0120it", ",", "\u0120if", "\u0120we", "\u0120call", "\u0120the", "\u0120method", "\u0120with", "\u0120[", "1", ",", "2", "],", "\u0120we", "\u0120will", "\u0120end", "\u0120up", "\u0120with", "\u0120the", "\u0120same", "\u0120key", "\u0120(\"", "12", "\")", "\u0120as", "\u0120asking", "\u0120for", "\u0120the", "\u012012", "th", "\u0120parameter", "\u0120with", "\u0120the", "\u0120list", "\u0120[", "12", "].", "\u0120(", "I", "\u0120know", "\u0120this", "\u0120is", "\u0120pretty", "\u0120unlikely", ",", "\u0120but", "\u0120still", "...)"]}
{"function": "public synchronized void handleMessageLayoutPrepare( @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg, ChannelHandlerContext ctx, @NonNull IServerRouter r) { if (!isBootstrapped(msg, ctx, r)) { return; } final long msgEpoch = msg.getPayload().getEpoch(); final long serverEpoch = getServerEpoch(); final Rank prepareRank = new Rank(msg.getPayload().getRank(), msg.getClientID()); final Rank phase1Rank = getPhase1Rank(msgEpoch); if (msgEpoch != serverEpoch) { r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch)); log.trace(\"handleMessageLayoutPrepare: Incoming message with wrong epoch, got {}, \" + \"expected {}, message was: {}\", msg.getPayload().getEpoch(), serverEpoch, msg); return; } Layout proposedLayout = getProposedLayout(msgEpoch); if (phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) { log.debug(\"handleMessageLayoutPrepare: Rejected phase 1 prepare of rank={}, \" + \"phase1Rank={}\", prepareRank, phase1Rank); r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_REJECT.payloadMsg(new LayoutPrepareResponse(phase1Rank.getRank(), proposedLayout))); } else { Rank highestProposedRank = proposedLayout == null ? new Rank(-1L, msg.getClientID()) : getPhase2Rank(msgEpoch); setPhase1Rank(prepareRank, msgEpoch); log.debug(\"handleMessageLayoutPrepare: New phase 1 rank={}\", getPhase1Rank(msgEpoch)); r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_ACK.payloadMsg(new LayoutPrepareResponse(highestProposedRank.getRank(), proposedLayout))); } }", "text": "Are these checks really necessary ? Its possible that this condition is false, at the time of the check, but becomes true immediately after the evaluation.", "function_tokens": ["public", "\u0120synchronized", "\u0120void", "\u0120handle", "Message", "Layout", "Prep", "are", "(", "\u0120@", "Non", "Null", "\u0120Cor", "fu", "Pay", "load", "Msg", "<", "Layout", "Prep", "are", "Request", ">", "\u0120msg", ",", "\u0120Channel", "Handler", "Context", "\u0120c", "tx", ",", "\u0120@", "Non", "Null", "\u0120IS", "erver", "R", "outer", "\u0120r", ")", "\u0120{", "\u0120if", "\u0120(!", "is", "Boot", "stra", "pped", "(", "msg", ",", "\u0120c", "tx", ",", "\u0120r", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120final", "\u0120long", "\u0120msg", "Ep", "och", "\u0120=", "\u0120msg", ".", "get", "Pay", "load", "().", "get", "Ep", "och", "();", "\u0120final", "\u0120long", "\u0120server", "Ep", "och", "\u0120=", "\u0120get", "Server", "Ep", "och", "();", "\u0120final", "\u0120Rank", "\u0120prepare", "Rank", "\u0120=", "\u0120new", "\u0120Rank", "(", "msg", ".", "get", "Pay", "load", "().", "get", "Rank", "(),", "\u0120msg", ".", "get", "Client", "ID", "());", "\u0120final", "\u0120Rank", "\u0120phase", "1", "Rank", "\u0120=", "\u0120get", "Phase", "1", "Rank", "(", "msg", "Ep", "och", ");", "\u0120if", "\u0120(", "msg", "Ep", "och", "\u0120!=", "\u0120server", "Ep", "och", ")", "\u0120{", "\u0120r", ".", "send", "Response", "(", "ctx", ",", "\u0120msg", ",", "\u0120new", "\u0120Cor", "fu", "Pay", "load", "Msg", "<", ">(", "Cor", "fu", "Msg", "Type", ".", "WR", "ONG", "_", "EP", "O", "CH", ",", "\u0120server", "Ep", "och", "));", "\u0120log", ".", "trace", "(\"", "handle", "Message", "Layout", "Prep", "are", ":", "\u0120In", "coming", "\u0120message", "\u0120with", "\u0120wrong", "\u0120epoch", ",", "\u0120got", "\u0120{", "},", "\u0120\"", "\u0120+", "\u0120\"", "expected", "\u0120{", "},", "\u0120message", "\u0120was", ":", "\u0120{}", "\",", "\u0120msg", ".", "get", "Pay", "load", "().", "get", "Ep", "och", "(),", "\u0120server", "Ep", "och", ",", "\u0120msg", ");", "\u0120return", ";", "\u0120}", "\u0120Layout", "\u0120proposed", "Layout", "\u0120=", "\u0120get", "Prop", "osed", "Layout", "(", "msg", "Ep", "och", ");", "\u0120if", "\u0120(", "phase", "1", "Rank", "\u0120!=", "\u0120null", "\u0120&&", "\u0120prepare", "Rank", ".", "less", "Th", "an", "E", "qual", "To", "(", "phase", "1", "Rank", "))", "\u0120{", "\u0120log", ".", "debug", "(\"", "handle", "Message", "Layout", "Prep", "are", ":", "\u0120Re", "jected", "\u0120phase", "\u01201", "\u0120prepare", "\u0120of", "\u0120rank", "={", "},", "\u0120\"", "\u0120+", "\u0120\"", "phase", "1", "Rank", "={", "}", "\",", "\u0120prepare", "Rank", ",", "\u0120phase", "1", "Rank", ");", "\u0120r", ".", "send", "Response", "(", "ctx", ",", "\u0120msg", ",", "\u0120Cor", "fu", "Msg", "Type", ".", "L", "AY", "OUT", "_", "P", "REP", "ARE", "_", "RE", "JECT", ".", "pay", "load", "Msg", "(", "new", "\u0120Layout", "Prep", "are", "Response", "(", "phase", "1", "Rank", ".", "get", "Rank", "(),", "\u0120proposed", "Layout", "))", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Rank", "\u0120highest", "Prop", "osed", "Rank", "\u0120=", "\u0120proposed", "Layout", "\u0120==", "\u0120null", "\u0120?", "\u0120new", "\u0120Rank", "(-", "1", "L", ",", "\u0120msg", ".", "get", "Client", "ID", "())", "\u0120:", "\u0120get", "Phase", "2", "Rank", "(", "msg", "Ep", "och", ");", "\u0120set", "Phase", "1", "Rank", "(", "prep", "are", "Rank", ",", "\u0120msg", "Ep", "och", ");", "\u0120log", ".", "debug", "(\"", "handle", "Message", "Layout", "Prep", "are", ":", "\u0120New", "\u0120phase", "\u01201", "\u0120rank", "={", "}", "\",", "\u0120get", "Phase", "1", "Rank", "(", "msg", "Ep", "och", "));", "\u0120r", ".", "send", "Response", "(", "ctx", ",", "\u0120msg", ",", "\u0120Cor", "fu", "Msg", "Type", ".", "L", "AY", "OUT", "_", "P", "REP", "ARE", "_", "ACK", ".", "pay", "load", "Msg", "(", "new", "\u0120Layout", "Prep", "are", "Response", "(", "highest", "Prop", "osed", "Rank", ".", "get", "Rank", "(),", "\u0120proposed", "Layout", "))", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Are", "\u0120these", "\u0120checks", "\u0120really", "\u0120necessary", "\u0120?", "\u0120Its", "\u0120possible", "\u0120that", "\u0120this", "\u0120condition", "\u0120is", "\u0120false", ",", "\u0120at", "\u0120the", "\u0120time", "\u0120of", "\u0120the", "\u0120check", ",", "\u0120but", "\u0120becomes", "\u0120true", "\u0120immediately", "\u0120after", "\u0120the", "\u0120evaluation", "."]}
{"function": "public void setSpeed(Double degreesPerSecond) { if (maxSpeed != -1 && degreesPerSecond > maxSpeed) { speed = maxSpeed; log.info(\"Trying to set speed to a value greater than max speed\"); } this.speed = degreesPerSecond; for (String controller : controllers) { ServiceInterface si = Runtime.getService(controller); if (si.isLocal()) { ((ServoController) Runtime.getService(controller)).servoSetVelocity(this); } else { send(controller, \"servoSetVelocity\", this); } } broadcastState(); }", "text": "I think we need to maintain the backwards compatibility for the old skewl setSpeed . our new proper method is setVelocity which takes a double that specifies the angular velocity of the servo that we will try to achieve.", "function_tokens": ["public", "\u0120void", "\u0120set", "Speed", "(", "Double", "\u0120degrees", "Per", "Second", ")", "\u0120{", "\u0120if", "\u0120(", "max", "Speed", "\u0120!=", "\u0120-", "1", "\u0120&&", "\u0120degrees", "Per", "Second", "\u0120>", "\u0120max", "Speed", ")", "\u0120{", "\u0120speed", "\u0120=", "\u0120max", "Speed", ";", "\u0120log", ".", "info", "(\"", "T", "rying", "\u0120to", "\u0120set", "\u0120speed", "\u0120to", "\u0120a", "\u0120value", "\u0120greater", "\u0120than", "\u0120max", "\u0120speed", "\");", "\u0120}", "\u0120this", ".", "speed", "\u0120=", "\u0120degrees", "Per", "Second", ";", "\u0120for", "\u0120(", "String", "\u0120controller", "\u0120:", "\u0120controllers", ")", "\u0120{", "\u0120Service", "Interface", "\u0120si", "\u0120=", "\u0120Runtime", ".", "get", "Service", "(", "controller", ");", "\u0120if", "\u0120(", "si", ".", "is", "Local", "())", "\u0120{", "\u0120((", "Serv", "o", "Controller", ")", "\u0120Runtime", ".", "get", "Service", "(", "controller", ")).", "serv", "o", "Set", "Vel", "ocity", "(", "this", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120send", "(", "controller", ",", "\u0120\"", "serv", "o", "Set", "Vel", "ocity", "\",", "\u0120this", ");", "\u0120}", "\u0120}", "\u0120broadcast", "State", "();", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120need", "\u0120to", "\u0120maintain", "\u0120the", "\u0120backwards", "\u0120compatibility", "\u0120for", "\u0120the", "\u0120old", "\u0120ske", "wl", "\u0120set", "Speed", "\u0120.", "\u0120our", "\u0120new", "\u0120proper", "\u0120method", "\u0120is", "\u0120set", "Vel", "ocity", "\u0120which", "\u0120takes", "\u0120a", "\u0120double", "\u0120that", "\u0120specifies", "\u0120the", "\u0120angular", "\u0120velocity", "\u0120of", "\u0120the", "\u0120serv", "o", "\u0120that", "\u0120we", "\u0120will", "\u0120try", "\u0120to", "\u0120achieve", "."]}
{"function": "private String getMemberName(String topic) { String[] topicElements = getTopicElements(topic); if (topicElements.length != 5) throw new IllegalArgumentException(\"Event creation failed, invalid topic: \" + topic); return topicElements[5]; }", "text": "Shouldn't a check for \"lower then\" not be sufficient?", "function_tokens": ["private", "\u0120String", "\u0120get", "Member", "Name", "(", "String", "\u0120topic", ")", "\u0120{", "\u0120String", "[]", "\u0120topic", "E", "lements", "\u0120=", "\u0120get", "Topic", "E", "lements", "(", "topic", ");", "\u0120if", "\u0120(", "topic", "E", "lements", ".", "length", "\u0120!=", "\u01205", ")", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Event", "\u0120creation", "\u0120failed", ",", "\u0120invalid", "\u0120topic", ":", "\u0120\"", "\u0120+", "\u0120topic", ");", "\u0120return", "\u0120topic", "E", "lements", "[", "5", "];", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120a", "\u0120check", "\u0120for", "\u0120\"", "lower", "\u0120then", "\"", "\u0120not", "\u0120be", "\u0120sufficient", "?"]}
{"function": "private int countOccurrencesInTopology(final String topologyString, final String searchPattern) { final Matcher matcher = Pattern.compile(searchPattern).matcher(topologyString); final List<String> repartitionTopicsFound = new ArrayList<>(); while (matcher.find()) { repartitionTopicsFound.add(matcher.group()); } return repartitionTopicsFound.size(); }", "text": "likewise, this one can be static", "function_tokens": ["private", "\u0120int", "\u0120count", "Occ", "ur", "rences", "In", "Top", "ology", "(", "final", "\u0120String", "\u0120top", "ology", "String", ",", "\u0120final", "\u0120String", "\u0120search", "Pattern", ")", "\u0120{", "\u0120final", "\u0120Mat", "cher", "\u0120mat", "cher", "\u0120=", "\u0120Pattern", ".", "comp", "ile", "(", "search", "Pattern", ").", "mat", "cher", "(", "top", "ology", "String", ");", "\u0120final", "\u0120List", "<", "String", ">", "\u0120rep", "art", "ition", "Topics", "Found", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120while", "\u0120(", "mat", "cher", ".", "find", "())", "\u0120{", "\u0120rep", "art", "ition", "Topics", "Found", ".", "add", "(", "mat", "cher", ".", "group", "());", "\u0120}", "\u0120return", "\u0120rep", "art", "ition", "Topics", "Found", ".", "size", "();", "\u0120}"], "docstring_tokens": ["like", "wise", ",", "\u0120this", "\u0120one", "\u0120can", "\u0120be", "\u0120static"]}
{"function": "public void run() { if (StringUtils.isNotBlank(id)) { boolean hasParent; if (vocabularyAndHasParent.get(name) == null) { String dirSchema = directoryService.getDirectorySchema(name); Schema schema = schemaManager.getSchema(dirSchema); hasParent = schema.hasField(\"parent\"); vocabularyAndHasParent.put(name, hasParent); } else { hasParent = vocabularyAndHasParent.get(name); } Session directorySession = directoryService.open(name); if (!directorySession.hasEntry(id)) { Map<String, Object> entry = new HashMap<>(); entry.put(\"id\", id); if (StringUtils.isEmpty(label)) { label = id; } entry.put(\"label\", label); if (hasParent) { entry.put(\"parent\", parent); } entry.put(\"obsolete\", obsolete); entry.put(\"ordering\", ordering); directorySession.createEntry(entry); } directorySession.close(); } }", "text": "can just do if (StringUtils.isBlank(id)) { return; } to reduce nesting level", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Bl", "ank", "(", "id", "))", "\u0120{", "\u0120boolean", "\u0120has", "Parent", ";", "\u0120if", "\u0120(", "voc", "abulary", "And", "Has", "Parent", ".", "get", "(", "name", ")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120String", "\u0120dir", "Sche", "ma", "\u0120=", "\u0120directory", "Service", ".", "get", "Directory", "Sche", "ma", "(", "name", ");", "\u0120Sche", "ma", "\u0120schema", "\u0120=", "\u0120schema", "Manager", ".", "get", "Sche", "ma", "(", "dir", "Sche", "ma", ");", "\u0120has", "Parent", "\u0120=", "\u0120schema", ".", "has", "Field", "(\"", "parent", "\");", "\u0120vocabulary", "And", "Has", "Parent", ".", "put", "(", "name", ",", "\u0120has", "Parent", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120has", "Parent", "\u0120=", "\u0120vocabulary", "And", "Has", "Parent", ".", "get", "(", "name", ");", "\u0120}", "\u0120Session", "\u0120directory", "Session", "\u0120=", "\u0120directory", "Service", ".", "open", "(", "name", ");", "\u0120if", "\u0120(!", "directory", "Session", ".", "has", "Entry", "(", "id", "))", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120entry", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120entry", ".", "put", "(\"", "id", "\",", "\u0120id", ");", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Empty", "(", "label", "))", "\u0120{", "\u0120label", "\u0120=", "\u0120id", ";", "\u0120}", "\u0120entry", ".", "put", "(\"", "label", "\",", "\u0120label", ");", "\u0120if", "\u0120(", "has", "Parent", ")", "\u0120{", "\u0120entry", ".", "put", "(\"", "parent", "\",", "\u0120parent", ");", "\u0120}", "\u0120entry", ".", "put", "(\"", "ob", "solete", "\",", "\u0120obsolete", ");", "\u0120entry", ".", "put", "(\"", "ordering", "\",", "\u0120ordering", ");", "\u0120directory", "Session", ".", "create", "Entry", "(", "entry", ");", "\u0120}", "\u0120directory", "Session", ".", "close", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["can", "\u0120just", "\u0120do", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "id", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120to", "\u0120reduce", "\u0120nesting", "\u0120level"]}
{"function": "private EntitySpec<? extends Entity> build(Topology topology, String node, Set<String> visited) { final Map<String, NodeTemplate> nodeTemplates = topology.getNodeTemplates(); final NodeTemplate nodeTemplate = nodeTemplates.get(node); visited.add(node); EntitySpec<?> spec = createSpec(node, nodeTemplate, topology); LOG.info(\"applying spec modifiers {}\", specModifiers); for (EntitySpecModifier builder : specModifiers) { builder.apply(spec, nodeTemplate, topology); } for (String child : children.get(node)) { if (!visited.contains(child)) { final EntitySpec<? extends Entity> childSpec = build(topology, child, visited); spec.child(childSpec) .configure(SoftwareProcess.CHILDREN_STARTABLE_MODE, SoftwareProcess.ChildStartableMode.BACKGROUND_LATE); } } return spec; }", "text": "This is debug at best, probably trace, and should include the spec/nodeTemplate in question. One to tweak subsequently.", "function_tokens": ["private", "\u0120Entity", "Spec", "<?", "\u0120extends", "\u0120Entity", ">", "\u0120build", "(", "Top", "ology", "\u0120top", "ology", ",", "\u0120String", "\u0120node", ",", "\u0120Set", "<", "String", ">", "\u0120visited", ")", "\u0120{", "\u0120final", "\u0120Map", "<", "String", ",", "\u0120Node", "Template", ">", "\u0120node", "Tem", "plates", "\u0120=", "\u0120top", "ology", ".", "get", "Node", "Tem", "plates", "();", "\u0120final", "\u0120Node", "Template", "\u0120node", "Template", "\u0120=", "\u0120node", "Tem", "plates", ".", "get", "(", "node", ");", "\u0120visited", ".", "add", "(", "node", ");", "\u0120Entity", "Spec", "<?", ">", "\u0120spec", "\u0120=", "\u0120create", "Spec", "(", "node", ",", "\u0120node", "Template", ",", "\u0120top", "ology", ");", "\u0120LOG", ".", "info", "(\"", "app", "lying", "\u0120spec", "\u0120modifiers", "\u0120{}", "\",", "\u0120spec", "Mod", "ifiers", ");", "\u0120for", "\u0120(", "Entity", "Spec", "Mod", "ifier", "\u0120builder", "\u0120:", "\u0120spec", "Mod", "ifiers", ")", "\u0120{", "\u0120builder", ".", "apply", "(", "spec", ",", "\u0120node", "Template", ",", "\u0120top", "ology", ");", "\u0120}", "\u0120for", "\u0120(", "String", "\u0120child", "\u0120:", "\u0120children", ".", "get", "(", "node", "))", "\u0120{", "\u0120if", "\u0120(!", "vis", "ited", ".", "cont", "ains", "(", "child", "))", "\u0120{", "\u0120final", "\u0120Entity", "Spec", "<?", "\u0120extends", "\u0120Entity", ">", "\u0120child", "Spec", "\u0120=", "\u0120build", "(", "top", "ology", ",", "\u0120child", ",", "\u0120visited", ");", "\u0120spec", ".", "child", "(", "child", "Spec", ")", "\u0120.", "config", "ure", "(", "Software", "Process", ".", "CH", "IL", "DR", "EN", "_", "STAR", "TABLE", "_", "MODE", ",", "\u0120Software", "Process", ".", "Child", "Start", "able", "Mode", ".", "BACK", "GROUND", "_", "L", "ATE", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120spec", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120debug", "\u0120at", "\u0120best", ",", "\u0120probably", "\u0120trace", ",", "\u0120and", "\u0120should", "\u0120include", "\u0120the", "\u0120spec", "/", "node", "Template", "\u0120in", "\u0120question", ".", "\u0120One", "\u0120to", "\u0120tweak", "\u0120subsequently", "."]}
{"function": "public static ReviewCompareAnnotationSupport getAnnotationSupport(Viewer contentViewer) { ReviewCompareAnnotationSupport support = (ReviewCompareAnnotationSupport) contentViewer.getData(KEY_ANNOTAION_SUPPORT); if (support == null) { if (support == null) { support = new ReviewCompareAnnotationSupport(contentViewer); contentViewer.setData(KEY_ANNOTAION_SUPPORT, support); } } return support; }", "text": "Making *really* sure it's null? ;)", "function_tokens": ["public", "\u0120static", "\u0120Review", "Compare", "An", "notation", "Support", "\u0120get", "An", "notation", "Support", "(", "View", "er", "\u0120content", "View", "er", ")", "\u0120{", "\u0120Review", "Compare", "An", "notation", "Support", "\u0120support", "\u0120=", "\u0120(", "Review", "Compare", "An", "notation", "Support", ")", "\u0120content", "View", "er", ".", "get", "Data", "(", "KEY", "_", "AN", "NOT", "A", "ION", "_", "SUP", "PORT", ");", "\u0120if", "\u0120(", "support", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "support", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120support", "\u0120=", "\u0120new", "\u0120Review", "Compare", "An", "notation", "Support", "(", "content", "View", "er", ");", "\u0120content", "View", "er", ".", "set", "Data", "(", "KEY", "_", "AN", "NOT", "A", "ION", "_", "SUP", "PORT", ",", "\u0120support", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120support", ";", "\u0120}"], "docstring_tokens": ["Making", "\u0120*", "really", "*", "\u0120sure", "\u0120it", "'s", "\u0120null", "?", "\u0120;)"]}
{"function": "private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) { if (arrayOrListType.getClass().isArray()) { return arrayOrListType.getClass().getComponentType(); } if (isList(arrayOrListType)) { ParameterizedType pt = (ParameterizedType) arrayOrListType; return pt.getActualTypeArguments()[0]; } throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\")); }", "text": "Can we add an actual exception message if we ever run into this issue in production.", "function_tokens": ["private", "\u0120static", "\u0120Type", "\u0120get", "Component", "Or", "Element", "Type", "(", "Type", "\u0120array", "Or", "List", "Type", ",", "\u0120Client", "Log", "ger", "\u0120logger", ")", "\u0120{", "\u0120if", "\u0120(", "array", "Or", "List", "Type", ".", "get", "Class", "().", "is", "Array", "())", "\u0120{", "\u0120return", "\u0120array", "Or", "List", "Type", ".", "get", "Class", "().", "get", "Component", "Type", "();", "\u0120}", "\u0120if", "\u0120(", "is", "List", "(", "array", "Or", "List", "Type", "))", "\u0120{", "\u0120Param", "eter", "ized", "Type", "\u0120pt", "\u0120=", "\u0120(", "Parameter", "ized", "Type", ")", "\u0120array", "Or", "List", "Type", ";", "\u0120return", "\u0120pt", ".", "get", "Act", "ual", "Type", "Arg", "uments", "()", "[", "0", "];", "\u0120}", "\u0120throw", "\u0120logger", ".", "log", "Exception", "As", "Error", "(", "new", "\u0120Runtime", "Exception", "(\"", "Should", "\u0120not", "\u0120be", "\u0120there", "\")", ");", "\u0120}"], "docstring_tokens": ["Can", "\u0120we", "\u0120add", "\u0120an", "\u0120actual", "\u0120exception", "\u0120message", "\u0120if", "\u0120we", "\u0120ever", "\u0120run", "\u0120into", "\u0120this", "\u0120issue", "\u0120in", "\u0120production", "."]}
{"function": "private ThriftType convertEnumTypeField(Class enumClass, String fieldName){ List<ThriftType.EnumValue> enumValues = new ArrayList<ThriftType.EnumValue>(); String enumName = enumClass.getName(); try { List enumCollection = getEnumList(enumName); for (Object enumObj : enumCollection) { ScroogeEnumDesc enumDesc = ScroogeEnumDesc.fromEnum(enumObj); enumValues.add(new ThriftType.EnumValue(enumDesc.id, enumDesc.originalName)); } return new ThriftType.EnumType(enumValues); } catch (Exception e) { throw new ScroogeSchemaConversionException(\"Can not convert enum field \" + fieldName, e); } }", "text": "are there Exceptions other than RuntimeExceptions?", "function_tokens": ["private", "\u0120Thr", "ift", "Type", "\u0120convert", "En", "um", "Type", "Field", "(", "Class", "\u0120enum", "Class", ",", "\u0120String", "\u0120field", "Name", "){", "\u0120List", "<", "Th", "rift", "Type", ".", "En", "um", "Value", ">", "\u0120enum", "Values", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Th", "rift", "Type", ".", "En", "um", "Value", ">", "();", "\u0120String", "\u0120enum", "Name", "\u0120=", "\u0120enum", "Class", ".", "get", "Name", "();", "\u0120try", "\u0120{", "\u0120List", "\u0120enum", "Collection", "\u0120=", "\u0120get", "En", "um", "List", "(", "enum", "Name", ");", "\u0120for", "\u0120(", "Object", "\u0120enum", "Obj", "\u0120:", "\u0120enum", "Collection", ")", "\u0120{", "\u0120Sc", "roo", "ge", "En", "um", "Desc", "\u0120enum", "Desc", "\u0120=", "\u0120Sc", "roo", "ge", "En", "um", "Desc", ".", "from", "En", "um", "(", "enum", "Obj", ");", "\u0120enum", "Values", ".", "add", "(", "new", "\u0120Thr", "ift", "Type", ".", "En", "um", "Value", "(", "enum", "Desc", ".", "id", ",", "\u0120enum", "Desc", ".", "original", "Name", "));", "\u0120}", "\u0120return", "\u0120new", "\u0120Thr", "ift", "Type", ".", "En", "um", "Type", "(", "enum", "Values", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Sc", "roo", "ge", "Sche", "ma", "Con", "version", "Exception", "(\"", "Can", "\u0120not", "\u0120convert", "\u0120enum", "\u0120field", "\u0120\"", "\u0120+", "\u0120field", "Name", ",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["are", "\u0120there", "\u0120Ex", "ceptions", "\u0120other", "\u0120than", "\u0120Runtime", "Ex", "ceptions", "?"]}
{"function": "public static Map<String, DbmsType> all() { Map<String, DbmsType> types = new HashMap<>(); types.put(\"ARRAY\", ARRAY); types.put(\"BIGINT\", BIGINT); types.put(\"BINARY\", BINARY); types.put(\"BOOLEAN\", BOOLEAN); types.put(\"CHARACTER\", CHARACTER); types.put(\"DATE\", DATE); types.put(\"DATETIME\", DATETIME); types.put(\"DECIMAL\", DECIMAL); types.put(\"DOUBLE\", DOUBLE); types.put(\"DOUBLE PRECISION\", DOUBLE_PRECISION); types.put(\"FLOAT\", FLOAT); types.put(\"FLOAT4\", FLOAT4); types.put(\"FLOAT8\", FLOAT8); types.put(\"INT\", INT); types.put(\"INTEGER\", INTEGER); types.put(\"NUMBER\", NUMBER); types.put(\"NUMERIC\", NUMERIC); types.put(\"OBJECT\", OBJECT); types.put(\"REAL\", REAL); types.put(\"SMALLINT\", SMALLINT); types.put(\"STRING\", STRING); types.put(\"TEXT\", TEXT); types.put(\"TIME\", TIME); types.put(\"TIMESTAMP\", TIMESTAMP); types.put(\"TIMESTAMP_LTZ\", TIMESTAMP_LTZ); types.put(\"TIMESTAMP_NTZ\", TIMESTAMP_NTZ); types.put(\"TIMESTAMP_TZ\", TIMESTAMP_TZ); types.put(\"VARBINARY\", VARBINARY); types.put(\"VARCHAR\", VARCHAR); types.put(\"VARIANT\", VARIANT); return types; }", "text": "It generates the map everytime you call all() method ? Why this map is not in a static{...} bloc code ?", "function_tokens": ["public", "\u0120static", "\u0120Map", "<", "String", ",", "\u0120D", "b", "ms", "Type", ">", "\u0120all", "()", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120D", "b", "ms", "Type", ">", "\u0120types", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120types", ".", "put", "(\"", "AR", "RAY", "\",", "\u0120AR", "RAY", ");", "\u0120types", ".", "put", "(\"", "BI", "G", "INT", "\",", "\u0120BIG", "INT", ");", "\u0120types", ".", "put", "(\"", "B", "IN", "ARY", "\",", "\u0120B", "IN", "ARY", ");", "\u0120types", ".", "put", "(\"", "B", "OO", "LE", "AN", "\",", "\u0120B", "OO", "LE", "AN", ");", "\u0120types", ".", "put", "(\"", "CHAR", "AC", "TER", "\",", "\u0120CHAR", "AC", "TER", ");", "\u0120types", ".", "put", "(\"", "D", "ATE", "\",", "\u0120D", "ATE", ");", "\u0120types", ".", "put", "(\"", "D", "AT", "ET", "IME", "\",", "\u0120D", "AT", "ET", "IME", ");", "\u0120types", ".", "put", "(\"", "DEC", "IM", "AL", "\",", "\u0120DEC", "IM", "AL", ");", "\u0120types", ".", "put", "(\"", "D", "OU", "BLE", "\",", "\u0120D", "OU", "BLE", ");", "\u0120types", ".", "put", "(\"", "D", "OU", "BLE", "\u0120PRE", "C", "ISION", "\",", "\u0120D", "OU", "BLE", "_", "P", "REC", "ISION", ");", "\u0120types", ".", "put", "(\"", "FL", "O", "AT", "\",", "\u0120FL", "O", "AT", ");", "\u0120types", ".", "put", "(\"", "FL", "O", "AT", "4", "\",", "\u0120FL", "O", "AT", "4", ");", "\u0120types", ".", "put", "(\"", "FL", "O", "AT", "8", "\",", "\u0120FL", "O", "AT", "8", ");", "\u0120types", ".", "put", "(\"", "INT", "\",", "\u0120INT", ");", "\u0120types", ".", "put", "(\"", "INT", "EG", "ER", "\",", "\u0120INT", "EG", "ER", ");", "\u0120types", ".", "put", "(\"", "NUM", "BER", "\",", "\u0120NUM", "BER", ");", "\u0120types", ".", "put", "(\"", "NUM", "ER", "IC", "\",", "\u0120NUM", "ER", "IC", ");", "\u0120types", ".", "put", "(\"", "OB", "JECT", "\",", "\u0120OB", "JECT", ");", "\u0120types", ".", "put", "(\"", "RE", "AL", "\",", "\u0120REAL", ");", "\u0120types", ".", "put", "(\"", "SM", "ALL", "INT", "\",", "\u0120SM", "ALL", "INT", ");", "\u0120types", ".", "put", "(\"", "STR", "ING", "\",", "\u0120STR", "ING", ");", "\u0120types", ".", "put", "(\"", "TEXT", "\",", "\u0120TEXT", ");", "\u0120types", ".", "put", "(\"", "TIME", "\",", "\u0120TIME", ");", "\u0120types", ".", "put", "(\"", "T", "IM", "EST", "AMP", "\",", "\u0120TIM", "EST", "AMP", ");", "\u0120types", ".", "put", "(\"", "T", "IM", "EST", "AMP", "_", "LT", "Z", "\",", "\u0120TIM", "EST", "AMP", "_", "LT", "Z", ");", "\u0120types", ".", "put", "(\"", "T", "IM", "EST", "AMP", "_", "NT", "Z", "\",", "\u0120TIM", "EST", "AMP", "_", "NT", "Z", ");", "\u0120types", ".", "put", "(\"", "T", "IM", "EST", "AMP", "_", "T", "Z", "\",", "\u0120TIM", "EST", "AMP", "_", "T", "Z", ");", "\u0120types", ".", "put", "(\"", "V", "ARB", "IN", "ARY", "\",", "\u0120V", "ARB", "IN", "ARY", ");", "\u0120types", ".", "put", "(\"", "V", "ARCH", "AR", "\",", "\u0120V", "ARCH", "AR", ");", "\u0120types", ".", "put", "(\"", "V", "ARI", "ANT", "\",", "\u0120V", "ARI", "ANT", ");", "\u0120return", "\u0120types", ";", "\u0120}"], "docstring_tokens": ["It", "\u0120generates", "\u0120the", "\u0120map", "\u0120every", "time", "\u0120you", "\u0120call", "\u0120all", "()", "\u0120method", "\u0120?", "\u0120Why", "\u0120this", "\u0120map", "\u0120is", "\u0120not", "\u0120in", "\u0120a", "\u0120static", "{", "...", "}", "\u0120bloc", "\u0120code", "\u0120?"]}
{"function": "private void restoreState(Bundle savedInstanceState) { if (savedInstanceState == null) return; boolean isInMultiSelectMode = savedInstanceState.getBoolean(BUNDLE_IN_MULTI_SELECT_MODE); if (isInMultiSelectMode) { mGridAdapter.setInMultiSelect(true); if (savedInstanceState.containsKey(BUNDLE_SELECTED_STATES)) { ArrayList<Integer> selectedItems = ListUtils.fromIntArray(savedInstanceState.getIntArray(BUNDLE_SELECTED_STATES)); mGridAdapter.setSelectedItems(selectedItems); setFilterSpinnerVisible(mGridAdapter.getSelectedItems().size() == 0); mSwipeToRefreshHelper.setEnabled(false); } } mHasRetrievedAllMedia = savedInstanceState.getBoolean(BUNDLE_HAS_RETRIEVED_ALL_MEDIA, false); mFilter = Filter.getFilter(savedInstanceState.getInt(BUNDLE_FILTER)); mEmptyViewMessageType = EmptyViewMessageType.getEnumFromString(savedInstanceState. getString(BUNDLE_EMPTY_VIEW_MESSAGE)); mIsDateFilterSet = savedInstanceState.getBoolean(BUNDLE_DATE_FILTER_SET, false); mStartDay = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_DAY); mStartMonth = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_MONTH); mStartYear = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_YEAR); mEndDay = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_DAY); mEndMonth = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_MONTH); mEndYear = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_YEAR); boolean datePickerShowing = savedInstanceState.getBoolean(BUNDLE_DATE_FILTER_VISIBLE); if (datePickerShowing) showDatePicker(); }", "text": "This leaves ActivityLauncher.newGalleryPost() unused - I think we should probably clean that up too.", "function_tokens": ["private", "\u0120void", "\u0120restore", "State", "(", "B", "undle", "\u0120saved", "Instance", "State", ")", "\u0120{", "\u0120if", "\u0120(", "s", "aved", "Instance", "State", "\u0120==", "\u0120null", ")", "\u0120return", ";", "\u0120boolean", "\u0120is", "In", "Multi", "Select", "Mode", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Boo", "lean", "(", "B", "UN", "D", "LE", "_", "IN", "_", "M", "ULT", "I", "_", "SELECT", "_", "MODE", ");", "\u0120if", "\u0120(", "is", "In", "Multi", "Select", "Mode", ")", "\u0120{", "\u0120m", "Grid", "Adapter", ".", "set", "In", "Multi", "Select", "(", "true", ");", "\u0120if", "\u0120(", "s", "aved", "Instance", "State", ".", "cont", "ains", "Key", "(", "B", "UN", "D", "LE", "_", "SELECT", "ED", "_", "ST", "ATES", "))", "\u0120{", "\u0120Array", "List", "<", "Integer", ">", "\u0120selected", "Items", "\u0120=", "\u0120List", "Ut", "ils", ".", "from", "Int", "Array", "(", "s", "aved", "Instance", "State", ".", "get", "Int", "Array", "(", "B", "UN", "D", "LE", "_", "SELECT", "ED", "_", "ST", "ATES", "));", "\u0120m", "Grid", "Adapter", ".", "set", "Se", "lected", "Items", "(", "selected", "Items", ");", "\u0120set", "Filter", "Sp", "inner", "V", "isible", "(", "m", "Grid", "Adapter", ".", "get", "Se", "lected", "Items", "().", "size", "()", "\u0120==", "\u01200", ");", "\u0120m", "Sw", "ipe", "To", "Ref", "resh", "Helper", ".", "set", "Enabled", "(", "false", ");", "\u0120}", "\u0120}", "\u0120m", "Has", "Ret", "rieved", "All", "Media", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Boo", "lean", "(", "B", "UN", "D", "LE", "_", "H", "AS", "_", "RE", "TR", "IE", "V", "ED", "_", "ALL", "_", "MED", "IA", ",", "\u0120false", ");", "\u0120m", "Filter", "\u0120=", "\u0120Filter", ".", "get", "Filter", "(", "s", "aved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "FIL", "TER", "));", "\u0120m", "Empty", "View", "Message", "Type", "\u0120=", "\u0120Empty", "View", "Message", "Type", ".", "get", "En", "um", "From", "String", "(", "s", "aved", "Instance", "State", ".", "\u0120get", "String", "(", "B", "UN", "D", "LE", "_", "EMP", "TY", "_", "VIEW", "_", "M", "ES", "SA", "GE", "));", "\u0120m", "Is", "Date", "Filter", "Set", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Boo", "lean", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "SET", ",", "\u0120false", ");", "\u0120m", "Start", "Day", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "ST", "ART", "_", "DAY", ");", "\u0120m", "Start", "Month", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "ST", "ART", "_", "MON", "TH", ");", "\u0120m", "Start", "Year", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "ST", "ART", "_", "Y", "EAR", ");", "\u0120m", "End", "Day", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "END", "_", "DAY", ");", "\u0120m", "End", "Month", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "END", "_", "MON", "TH", ");", "\u0120m", "End", "Year", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Int", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "END", "_", "Y", "EAR", ");", "\u0120boolean", "\u0120date", "P", "icker", "Sh", "owing", "\u0120=", "\u0120saved", "Instance", "State", ".", "get", "Boo", "lean", "(", "B", "UN", "D", "LE", "_", "D", "ATE", "_", "FIL", "TER", "_", "VIS", "IBLE", ");", "\u0120if", "\u0120(", "date", "P", "icker", "Sh", "owing", ")", "\u0120show", "Date", "P", "icker", "();", "\u0120}"], "docstring_tokens": ["This", "\u0120leaves", "\u0120Activity", "Laun", "cher", ".", "new", "Gallery", "Post", "()", "\u0120unused", "\u0120-", "\u0120I", "\u0120think", "\u0120we", "\u0120should", "\u0120probably", "\u0120clean", "\u0120that", "\u0120up", "\u0120too", "."]}
{"function": "public ClusterFeature get() { Cluster cluster = parent.getClusterEntity(); SupportedAdditionalClusterFeature feature = cluster.getAddtionalFeaturesSupported() .stream() .filter(f -> f.getFeature().getId().equals(asGuid(id))) .findFirst() .orElseThrow(() -> new WebApplicationException(Response.Status.NOT_FOUND)); return ClusterFeaturesMapper.map(feature.getFeature(), null); }", "text": "This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.", "function_tokens": ["public", "\u0120Cluster", "Feature", "\u0120get", "()", "\u0120{", "\u0120Cluster", "\u0120cluster", "\u0120=", "\u0120parent", ".", "get", "Cl", "uster", "Entity", "();", "\u0120Supported", "Additional", "Cl", "uster", "Feature", "\u0120feature", "\u0120=", "\u0120cluster", ".", "get", "Add", "t", "ional", "Features", "Supported", "()", "\u0120.", "stream", "()", "\u0120.", "filter", "(", "f", "\u0120->", "\u0120f", ".", "get", "Feature", "().", "get", "Id", "().", "equ", "als", "(", "as", "Gu", "id", "(", "id", ")))", "\u0120.", "find", "First", "()", "\u0120.", "or", "Else", "Throw", "(", "()", "\u0120->", "\u0120new", "\u0120Web", "Application", "Exception", "(", "Response", ".", "Status", ".", "NOT", "_", "F", "OUND", "));", "\u0120return", "\u0120Cluster", "Features", "M", "apper", ".", "map", "(", "feature", ".", "get", "Feature", "(),", "\u0120null", ");", "\u0120}"], "docstring_tokens": ["This", "\u0120code", "\u0120to", "\u0120get", "\u0120the", "\u0120feature", "\u0120is", "\u0120used", "\u0120here", "\u0120and", "\u0120in", "\u0120the", "\u0120remove", "\u0120method", ".", "\u0120I", "'d", "\u0120suggest", "\u0120to", "\u0120create", "\u0120a", "\u0120new", "\u0120Back", "end", "Cl", "uster", "Feature", "Helper", "\u0120class", "\u0120and", "\u0120put", "\u0120this", "\u0120code", "\u0120there", ".", "\u0120Then", "\u0120you", "\u0120can", "\u0120call", "\u0120it", "\u0120from", "\u0120these", "\u0120meth", "os", ".", "\u0120Look", "\u0120at", "\u0120Back", "end", "Data", "Center", "Helper", "\u0120for", "\u0120example", "."]}
{"function": "public Iterator getLocations() { return ORDERING.sortedCopy(this.storageLocations).iterator(); }", "text": "Please Specify the type properly here like Iterator<StorageLocation>.", "function_tokens": ["public", "\u0120Iter", "ator", "\u0120get", "L", "ocations", "()", "\u0120{", "\u0120return", "\u0120ORDER", "ING", ".", "s", "orted", "Copy", "(", "this", ".", "storage", "L", "ocations", ").", "iterator", "();", "\u0120}"], "docstring_tokens": ["Please", "\u0120Spec", "ify", "\u0120the", "\u0120type", "\u0120properly", "\u0120here", "\u0120like", "\u0120Iter", "ator", "<", "Storage", "Location", ">."]}
{"function": "public JarSet process() { JarSet newJars = new JarSet(); for (String p: syncProcessedPaths()) { synchronized (removedPaths) { removedPaths.add(new Path(p)); } project.getExtensionManager().pathRemoved(p); } boolean newRuntimeDetected = false; Set<String> processed = new HashSet<String>(); synchronized(this) { processed.addAll(processedPaths); } for (int i = 0; i < paths.size(); i++) { String p = paths.get(i); if(!requestForLoad(p)) continue; removedPaths.add(new Path(p)); String fileName = new File(p).getName(); if(EclipseResourceUtil.SYSTEM_JAR_SET.contains(fileName)) continue; XModelObject o = FileSystemsHelper.getLibs(model).getLibrary(p); if(o == null) continue; boolean nrd = project.getExtensionManager().setRuntimes(p, readRuntimes(o)); if(nrd) newRuntimeDetected = true; detectBeanModule(p, o, newJars); } for (FileAnyImpl s: servicesInSrc.keySet()) { IResource r = (IResource)s.getAdapter(IResource.class); if(r != null && r.exists()) { boolean nrd = project.getExtensionManager().setRuntimes(r.getFullPath().toString(), readRuntimesInService(s)); if(nrd) newRuntimeDetected = true; } } IJavaProject javaProject = EclipseResourceUtil.getJavaProject(project.getProject()); Set<String> recognizedRuntimes = CDIExtensionFactory.getInstance().getRecognizedRuntimes(javaProject); boolean nrd = project.getExtensionManager().setRuntimes(\"_recognized_\", recognizedRuntimes); if(nrd) newRuntimeDetected = true; if(newRuntimeDetected) { for (String p: processed) { String fileName = new File(p).getName(); if(EclipseResourceUtil.SYSTEM_JAR_SET.contains(fileName)) continue; XModelObject o = FileSystemsHelper.getLibs(model).getLibrary(p); if(o != null) { detectBeanModule(p, o, newJars); } } } validateProjectDependencies(); return newJars; }", "text": "Let's move \"_recognized_\" to final static variable", "function_tokens": ["public", "\u0120Jar", "Set", "\u0120process", "()", "\u0120{", "\u0120Jar", "Set", "\u0120new", "J", "ars", "\u0120=", "\u0120new", "\u0120Jar", "Set", "();", "\u0120for", "\u0120(", "String", "\u0120p", ":", "\u0120sync", "Process", "ed", "Path", "s", "())", "\u0120{", "\u0120synchronized", "\u0120(", "rem", "oved", "Path", "s", ")", "\u0120{", "\u0120removed", "Path", "s", ".", "add", "(", "new", "\u0120Path", "(", "p", "));", "\u0120}", "\u0120project", ".", "get", "Ext", "ension", "Manager", "().", "path", "Removed", "(", "p", ");", "\u0120}", "\u0120boolean", "\u0120new", "Runtime", "Det", "ected", "\u0120=", "\u0120false", ";", "\u0120Set", "<", "String", ">", "\u0120processed", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", "String", ">", "();", "\u0120synchronized", "(", "this", ")", "\u0120{", "\u0120processed", ".", "add", "All", "(", "process", "ed", "Path", "s", ");", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120paths", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120p", "\u0120=", "\u0120paths", ".", "get", "(", "i", ");", "\u0120if", "(", "!", "request", "For", "Load", "(", "p", "))", "\u0120continue", ";", "\u0120removed", "Path", "s", ".", "add", "(", "new", "\u0120Path", "(", "p", "));", "\u0120String", "\u0120file", "Name", "\u0120=", "\u0120new", "\u0120File", "(", "p", ").", "get", "Name", "();", "\u0120if", "(", "E", "clipse", "Resource", "Ut", "il", ".", "SY", "STEM", "_", "J", "AR", "_", "SET", ".", "cont", "ains", "(", "file", "Name", "))", "\u0120continue", ";", "\u0120X", "Model", "Object", "\u0120o", "\u0120=", "\u0120File", "System", "s", "Helper", ".", "get", "Lib", "s", "(", "model", ").", "get", "Library", "(", "p", ");", "\u0120if", "(", "o", "\u0120==", "\u0120null", ")", "\u0120continue", ";", "\u0120boolean", "\u0120n", "rd", "\u0120=", "\u0120project", ".", "get", "Ext", "ension", "Manager", "().", "set", "R", "unt", "imes", "(", "p", ",", "\u0120read", "R", "unt", "imes", "(", "o", "));", "\u0120if", "(", "n", "rd", ")", "\u0120new", "Runtime", "Det", "ected", "\u0120=", "\u0120true", ";", "\u0120detect", "Be", "an", "Module", "(", "p", ",", "\u0120o", ",", "\u0120new", "J", "ars", ");", "\u0120}", "\u0120for", "\u0120(", "File", "Any", "Impl", "\u0120s", ":", "\u0120services", "In", "S", "rc", ".", "key", "Set", "())", "\u0120{", "\u0120I", "Resource", "\u0120r", "\u0120=", "\u0120(", "IR", "es", "ource", ")", "s", ".", "get", "Adapter", "(", "IR", "es", "ource", ".", "class", ");", "\u0120if", "(", "r", "\u0120!=", "\u0120null", "\u0120&&", "\u0120r", ".", "ex", "ists", "())", "\u0120{", "\u0120boolean", "\u0120n", "rd", "\u0120=", "\u0120project", ".", "get", "Ext", "ension", "Manager", "().", "set", "R", "unt", "imes", "(", "r", ".", "get", "Full", "Path", "().", "to", "String", "(),", "\u0120read", "R", "unt", "imes", "In", "Service", "(", "s", "));", "\u0120if", "(", "n", "rd", ")", "\u0120new", "Runtime", "Det", "ected", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120I", "Java", "Project", "\u0120java", "Project", "\u0120=", "\u0120Eclipse", "Resource", "Ut", "il", ".", "get", "Java", "Project", "(", "project", ".", "get", "Project", "());", "\u0120Set", "<", "String", ">", "\u0120recognized", "R", "unt", "imes", "\u0120=", "\u0120CD", "IE", "xt", "ension", "Factory", ".", "get", "Instance", "().", "get", "Rec", "ogn", "ized", "R", "unt", "imes", "(", "java", "Project", ");", "\u0120boolean", "\u0120n", "rd", "\u0120=", "\u0120project", ".", "get", "Ext", "ension", "Manager", "().", "set", "R", "unt", "imes", "(\"", "_", "recogn", "ized", "_", "\",", "\u0120recognized", "R", "unt", "imes", ");", "\u0120if", "(", "n", "rd", ")", "\u0120new", "Runtime", "Det", "ected", "\u0120=", "\u0120true", ";", "\u0120if", "(", "new", "Runtime", "Det", "ected", ")", "\u0120{", "\u0120for", "\u0120(", "String", "\u0120p", ":", "\u0120processed", ")", "\u0120{", "\u0120String", "\u0120file", "Name", "\u0120=", "\u0120new", "\u0120File", "(", "p", ").", "get", "Name", "();", "\u0120if", "(", "E", "clipse", "Resource", "Ut", "il", ".", "SY", "STEM", "_", "J", "AR", "_", "SET", ".", "cont", "ains", "(", "file", "Name", "))", "\u0120continue", ";", "\u0120X", "Model", "Object", "\u0120o", "\u0120=", "\u0120File", "System", "s", "Helper", ".", "get", "Lib", "s", "(", "model", ").", "get", "Library", "(", "p", ");", "\u0120if", "(", "o", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120detect", "Be", "an", "Module", "(", "p", ",", "\u0120o", ",", "\u0120new", "J", "ars", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120validate", "Project", "D", "epend", "encies", "();", "\u0120return", "\u0120new", "J", "ars", ";", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120move", "\u0120\"_", "recogn", "ized", "_", "\"", "\u0120to", "\u0120final", "\u0120static", "\u0120variable"]}
{"function": "public CoprocessorRpcChannel coprocessorService(ServerName serverName) { return null; }", "text": "Should these throw UnsupportedExceptions?", "function_tokens": ["public", "\u0120Cop", "ro", "cess", "or", "R", "pc", "Channel", "\u0120cop", "ro", "cess", "or", "Service", "(", "Server", "Name", "\u0120server", "Name", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Should", "\u0120these", "\u0120throw", "\u0120Un", "supported", "Ex", "ceptions", "?"]}
{"function": "public static String getGatewayAliasDefaultTo(String overrideAlias) { if (StringUtils.isNotBlank(overrideAlias)) { return overrideAlias; } String alias = System.getProperty(NhincConstants.CLIENT_KEY_ALIAS); return StringUtils.isBlank(alias) ? NhincConstants.DEFAULT_CLIENT_KEY_ALIAS : alias; }", "text": "duplicate logic in getPrivateKeyAlias method().", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120get", "Gate", "way", "Alias", "Default", "To", "(", "String", "\u0120override", "Alias", ")", "\u0120{", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Bl", "ank", "(", "over", "ride", "Alias", "))", "\u0120{", "\u0120return", "\u0120override", "Alias", ";", "\u0120}", "\u0120String", "\u0120alias", "\u0120=", "\u0120System", ".", "get", "Property", "(", "N", "h", "inc", "Const", "ants", ".", "CL", "IENT", "_", "KEY", "_", "AL", "IAS", ");", "\u0120return", "\u0120String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "alias", ")", "\u0120?", "\u0120N", "h", "inc", "Const", "ants", ".", "DE", "FAULT", "_", "CL", "IENT", "_", "KEY", "_", "AL", "IAS", "\u0120:", "\u0120alias", ";", "\u0120}"], "docstring_tokens": ["du", "pl", "icate", "\u0120logic", "\u0120in", "\u0120get", "Private", "Key", "Alias", "\u0120method", "()."]}
{"function": "public String toString() { return \"exceededCount=\" + m_exceededCount + \"\\nm_armed=\" + m_armed; }", "text": "suggestion \"\\narmed=\" + m_armed;", "function_tokens": ["public", "\u0120String", "\u0120to", "String", "()", "\u0120{", "\u0120return", "\u0120\"", "ex", "ceed", "ed", "Count", "=\"", "\u0120+", "\u0120m", "_", "ex", "ceed", "ed", "Count", "\u0120+", "\u0120\"\\", "nm", "_", "armed", "=\"", "\u0120+", "\u0120m", "_", "armed", ";", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120\"\\", "n", "armed", "=\"", "\u0120+", "\u0120m", "_", "armed", ";"]}
{"function": "private void updateFileCacheSizeLimit() { boolean isAvailableSpaceLowerThanHighLimit; if(mDiskCacheIsExternal){ isAvailableSpaceLowerThanHighLimit = mStatFsHelper.testLowDiskSpace( StatFsHelper.StorageType.EXTERNAL, mDefaultCacheSizeLimit - mCacheStats.getSize()); } else{ isAvailableSpaceLowerThanHighLimit = mStatFsHelper.testLowDiskSpace( StatFsHelper.StorageType.INTERNAL, mDefaultCacheSizeLimit - mCacheStats.getSize()); } if (isAvailableSpaceLowerThanHighLimit) { mCacheSizeLimit = mLowDiskSpaceCacheSizeLimit; } else { mCacheSizeLimit = mDefaultCacheSizeLimit; } }", "text": "No need for code duplication. We can do something like:  StorageType storageType = mStorage.isExternal() ? StatFsHelper.StorageType.EXTERNAL : StatFsHelper.StorageType.INTERNAL;", "function_tokens": ["private", "\u0120void", "\u0120update", "File", "Cache", "Size", "Limit", "()", "\u0120{", "\u0120boolean", "\u0120is", "Available", "Space", "Lower", "Th", "an", "High", "Limit", ";", "\u0120if", "(", "m", "Disk", "Cache", "Is", "External", "){", "\u0120is", "Available", "Space", "Lower", "Th", "an", "High", "Limit", "\u0120=", "\u0120m", "Stat", "Fs", "Helper", ".", "test", "Low", "Disk", "Space", "(", "\u0120Stat", "Fs", "Helper", ".", "Storage", "Type", ".", "EX", "TERN", "AL", ",", "\u0120m", "Default", "Cache", "Size", "Limit", "\u0120-", "\u0120m", "Cache", "Stats", ".", "get", "Size", "());", "\u0120}", "\u0120else", "{", "\u0120is", "Available", "Space", "Lower", "Th", "an", "High", "Limit", "\u0120=", "\u0120m", "Stat", "Fs", "Helper", ".", "test", "Low", "Disk", "Space", "(", "\u0120Stat", "Fs", "Helper", ".", "Storage", "Type", ".", "IN", "TERN", "AL", ",", "\u0120m", "Default", "Cache", "Size", "Limit", "\u0120-", "\u0120m", "Cache", "Stats", ".", "get", "Size", "());", "\u0120}", "\u0120if", "\u0120(", "is", "Available", "Space", "Lower", "Th", "an", "High", "Limit", ")", "\u0120{", "\u0120m", "Cache", "Size", "Limit", "\u0120=", "\u0120m", "Low", "Disk", "Space", "Cache", "Size", "Limit", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120m", "Cache", "Size", "Limit", "\u0120=", "\u0120m", "Default", "Cache", "Size", "Limit", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["No", "\u0120need", "\u0120for", "\u0120code", "\u0120duplication", ".", "\u0120We", "\u0120can", "\u0120do", "\u0120something", "\u0120like", ":", "\u0120", "\u0120Storage", "Type", "\u0120storage", "Type", "\u0120=", "\u0120m", "Storage", ".", "is", "External", "()", "\u0120?", "\u0120Stat", "Fs", "Helper", ".", "Storage", "Type", ".", "EX", "TERN", "AL", "\u0120:", "\u0120Stat", "Fs", "Helper", ".", "Storage", "Type", ".", "IN", "TERN", "AL", ";"]}
{"function": "BufferAndBacklog pollBuffer() { synchronized (buffers) { if (isBlocked) { return null; } Buffer buffer = null; if (buffers.isEmpty()) { flushRequested = false; } while (!buffers.isEmpty()) { BufferConsumer bufferConsumer = buffers.peek().getBufferConsumer(); buffer = bufferConsumer.build(); checkState(bufferConsumer.isFinished() || buffers.size() == 1 || (buffers.size() == 2 && buffers.peekLast().getBufferConsumer().getDataType() == Buffer.DataType.RECOVERY_COMPLETION), \"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\"); if (buffers.size() == 1) { flushRequested = false; } if (bufferConsumer.isFinished()) { buffers.poll().getBufferConsumer().close(); decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer()); } if (buffer.readableBytes() > 0) { break; } buffer.recycleBuffer(); buffer = null; if (!bufferConsumer.isFinished()) { break; } } if (buffer == null) { return null; } if (buffer.getDataType().isBlockingUpstream()) { isBlocked = true; } updateStatistics(buffer); return new BufferAndBacklog( buffer, getBuffersInBacklog(), isDataAvailableUnsafe() ? getNextBufferTypeUnsafe() : Buffer.DataType.NONE, sequenceNumber++); } }", "text": "Why do we need that change here and not for aligned barriers?", "function_tokens": ["Buffer", "And", "Back", "log", "\u0120poll", "Buffer", "()", "\u0120{", "\u0120synchronized", "\u0120(", "buff", "ers", ")", "\u0120{", "\u0120if", "\u0120(", "is", "Bl", "ocked", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120Buffer", "\u0120buffer", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "buff", "ers", ".", "is", "Empty", "())", "\u0120{", "\u0120flush", "Request", "ed", "\u0120=", "\u0120false", ";", "\u0120}", "\u0120while", "\u0120(!", "buff", "ers", ".", "is", "Empty", "())", "\u0120{", "\u0120Buffer", "Consumer", "\u0120buffer", "Consumer", "\u0120=", "\u0120buffers", ".", "pe", "ek", "().", "get", "Buffer", "Consumer", "();", "\u0120buffer", "\u0120=", "\u0120buffer", "Consumer", ".", "build", "();", "\u0120check", "State", "(", "buffer", "Consumer", ".", "is", "Fin", "ished", "()", "\u0120||", "\u0120buffers", ".", "size", "()", "\u0120==", "\u01201", "\u0120||", "\u0120(", "buff", "ers", ".", "size", "()", "\u0120==", "\u01202", "\u0120&&", "\u0120buffers", ".", "pe", "ek", "Last", "().", "get", "Buffer", "Consumer", "().", "get", "Data", "Type", "()", "\u0120==", "\u0120Buffer", ".", "Data", "Type", ".", "RE", "CO", "VER", "Y", "_", "COMPLE", "TION", "),", "\u0120\"", "When", "\u0120there", "\u0120are", "\u0120multiple", "\u0120buffers", ",", "\u0120an", "\u0120unfinished", "\u0120buffer", "Consumer", "\u0120can", "\u0120not", "\u0120be", "\u0120at", "\u0120the", "\u0120head", "\u0120of", "\u0120the", "\u0120buffers", "\u0120queue", ".\"", ");", "\u0120if", "\u0120(", "buff", "ers", ".", "size", "()", "\u0120==", "\u01201", ")", "\u0120{", "\u0120flush", "Request", "ed", "\u0120=", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "buffer", "Consumer", ".", "is", "Fin", "ished", "())", "\u0120{", "\u0120buffers", ".", "poll", "().", "get", "Buffer", "Consumer", "().", "close", "();", "\u0120decrease", "Buff", "ers", "In", "Back", "log", "Un", "safe", "(", "buffer", "Consumer", ".", "is", "Buffer", "());", "\u0120}", "\u0120if", "\u0120(", "buffer", ".", "readable", "Bytes", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120break", ";", "\u0120}", "\u0120buffer", ".", "re", "cycle", "Buffer", "();", "\u0120buffer", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(!", "buffer", "Consumer", ".", "is", "Fin", "ished", "())", "\u0120{", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "buffer", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120if", "\u0120(", "buffer", ".", "get", "Data", "Type", "().", "is", "Bl", "ocking", "Up", "stream", "())", "\u0120{", "\u0120is", "Bl", "ocked", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120update", "Statistics", "(", "buffer", ");", "\u0120return", "\u0120new", "\u0120Buffer", "And", "Back", "log", "(", "\u0120buffer", ",", "\u0120get", "Buff", "ers", "In", "Back", "log", "(),", "\u0120is", "Data", "Available", "Un", "safe", "()", "\u0120?", "\u0120get", "Next", "Buffer", "Type", "Un", "safe", "()", "\u0120:", "\u0120Buffer", ".", "Data", "Type", ".", "N", "ONE", ",", "\u0120sequence", "Number", "++", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120do", "\u0120we", "\u0120need", "\u0120that", "\u0120change", "\u0120here", "\u0120and", "\u0120not", "\u0120for", "\u0120aligned", "\u0120barriers", "?"]}
{"function": "public InMemoryMessageExchangeStore(final NetworkConfig config, TokenProvider tokenProvider) { if (config == null) { throw new NullPointerException(\"Configuration must not be null\"); } if (tokenProvider == null) { throw new NullPointerException(\"TokenProvider must not be null\"); } this.tokenProvider = tokenProvider; this.config = config; this.tokenLength = config.getInt(NetworkConfig.Keys.TOKEN_SIZE_LIMIT, MAX_TOKEN_LENGTH); LOGGER.log(Level.CONFIG, \"using tokens of {0} bytes in length\", tokenLength); }", "text": "Do we still need the token length here? It seems that the TokenProvider retrieves it from the config itself, doesn't it?", "function_tokens": ["public", "\u0120In", "Memory", "Message", "Ex", "change", "Store", "(", "final", "\u0120Network", "Config", "\u0120config", ",", "\u0120Token", "Provider", "\u0120token", "Provider", ")", "\u0120{", "\u0120if", "\u0120(", "config", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Null", "Po", "inter", "Exception", "(\"", "Configuration", "\u0120must", "\u0120not", "\u0120be", "\u0120null", "\");", "\u0120}", "\u0120if", "\u0120(", "token", "Provider", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Null", "Po", "inter", "Exception", "(\"", "Token", "Provider", "\u0120must", "\u0120not", "\u0120be", "\u0120null", "\");", "\u0120}", "\u0120this", ".", "token", "Provider", "\u0120=", "\u0120token", "Provider", ";", "\u0120this", ".", "config", "\u0120=", "\u0120config", ";", "\u0120this", ".", "token", "Length", "\u0120=", "\u0120config", ".", "get", "Int", "(", "Network", "Config", ".", "Keys", ".", "TO", "KEN", "_", "SIZE", "_", "L", "IM", "IT", ",", "\u0120MAX", "_", "TO", "KEN", "_", "L", "ENGTH", ");", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "CON", "FIG", ",", "\u0120\"", "using", "\u0120tokens", "\u0120of", "\u0120{", "0", "}", "\u0120bytes", "\u0120in", "\u0120length", "\",", "\u0120token", "Length", ");", "\u0120}"], "docstring_tokens": ["Do", "\u0120we", "\u0120still", "\u0120need", "\u0120the", "\u0120token", "\u0120length", "\u0120here", "?", "\u0120It", "\u0120seems", "\u0120that", "\u0120the", "\u0120Token", "Provider", "\u0120retrie", "ves", "\u0120it", "\u0120from", "\u0120the", "\u0120config", "\u0120itself", ",", "\u0120doesn", "'t", "\u0120it", "?"]}
{"function": "public ChangeInfo format(RevisionResource rsrc) throws OrmException { ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl()); Optional<PatchSet.Id> ps = Optional.of(rsrc.getPatchSet().getId()); return format(cd, ps); }", "text": "Why should format(RevisionResource) return a ChangeInfo and not (at the very least) a RevisionInfo? Though ideally it would return a Map<String, ActionInfo>", "function_tokens": ["public", "\u0120Change", "Info", "\u0120format", "(", "Rev", "ision", "Resource", "\u0120r", "src", ")", "\u0120throws", "\u0120Or", "m", "Exception", "\u0120{", "\u0120Change", "Data", "\u0120cd", "\u0120=", "\u0120change", "Data", "Factory", ".", "create", "(", "db", ".", "get", "(),", "\u0120r", "src", ".", "get", "Control", "());", "\u0120Optional", "<", "Patch", "Set", ".", "Id", ">", "\u0120ps", "\u0120=", "\u0120Optional", ".", "of", "(", "rs", "rc", ".", "get", "Patch", "Set", "().", "get", "Id", "());", "\u0120return", "\u0120format", "(", "cd", ",", "\u0120ps", ");", "\u0120}"], "docstring_tokens": ["Why", "\u0120should", "\u0120format", "(", "Rev", "ision", "Resource", ")", "\u0120return", "\u0120a", "\u0120Change", "Info", "\u0120and", "\u0120not", "\u0120(", "at", "\u0120the", "\u0120very", "\u0120least", ")", "\u0120a", "\u0120Revision", "Info", "?", "\u0120Though", "\u0120ideally", "\u0120it", "\u0120would", "\u0120return", "\u0120a", "\u0120Map", "<", "String", ",", "\u0120Action", "Info", ">"]}
{"function": "private String putBlob(Router router, BlobProperties blobProperties, byte[] usermetadata, byte[] content, RouterOperationCallback<String> putBlobCallback) throws Exception { byte[] buf = new byte[content.length]; Utils.readBytesFromStream(new ByteArrayInputStream(content), buf, 0, content.length); ReadableStreamChannel blobDataChannel = new ByteBufferReadableStreamChannel(ByteBuffer.wrap(buf)); Future<String> putBlobFuture; if (putBlobCallback == null) { putBlobFuture = router.putBlob(blobProperties, usermetadata, blobDataChannel); } else { putBlobFuture = router.putBlob(blobProperties, usermetadata, blobDataChannel, putBlobCallback); if (!putBlobCallback.awaitCallback(1, TimeUnit.SECONDS)) { throw new IllegalStateException(\"putBlob() timed out\"); } else if (putBlobCallback.getException() != null) { verifyExceptionMatch(putBlobCallback, putBlobFuture); throw putBlobCallback.getException(); } assertTrue(\"PutBlob: Future is not done but callback has been received\", putBlobFuture.isDone()); assertEquals(\"PutBlob: Future BlobId and callback BlobId do not match\", putBlobFuture.get(), putBlobCallback.getResult()); } return putBlobFuture.get(); }", "text": "verifyExceptionMatch() blocks on future.get(), so isDone() will always be true when you're here, no? Also, if the callback was received, then we should ensure that future.get() returns immediately as well, so shouldn't it be a timed get within verifyExceptionMatch()?", "function_tokens": ["private", "\u0120String", "\u0120put", "Bl", "ob", "(", "R", "outer", "\u0120router", ",", "\u0120Bl", "ob", "Pro", "perties", "\u0120blob", "Pro", "perties", ",", "\u0120byte", "[]", "\u0120user", "metadata", ",", "\u0120byte", "[]", "\u0120content", ",", "\u0120Router", "Operation", "Callback", "<", "String", ">", "\u0120put", "Bl", "ob", "Callback", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120byte", "[]", "\u0120buf", "\u0120=", "\u0120new", "\u0120byte", "[", "content", ".", "length", "];", "\u0120Ut", "ils", ".", "read", "Bytes", "From", "Stream", "(", "new", "\u0120Byte", "Array", "Input", "Stream", "(", "content", "),", "\u0120buf", ",", "\u01200", ",", "\u0120content", ".", "length", ");", "\u0120Read", "able", "Stream", "Channel", "\u0120blob", "Data", "Channel", "\u0120=", "\u0120new", "\u0120Byte", "Buffer", "Read", "able", "Stream", "Channel", "(", "Byte", "Buffer", ".", "wrap", "(", "buf", "));", "\u0120Future", "<", "String", ">", "\u0120put", "Bl", "ob", "Future", ";", "\u0120if", "\u0120(", "put", "Bl", "ob", "Callback", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120put", "Bl", "ob", "Future", "\u0120=", "\u0120router", ".", "put", "Bl", "ob", "(", "bl", "ob", "Pro", "perties", ",", "\u0120user", "metadata", ",", "\u0120blob", "Data", "Channel", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120put", "Bl", "ob", "Future", "\u0120=", "\u0120router", ".", "put", "Bl", "ob", "(", "bl", "ob", "Pro", "perties", ",", "\u0120user", "metadata", ",", "\u0120blob", "Data", "Channel", ",", "\u0120put", "Bl", "ob", "Callback", ");", "\u0120if", "\u0120(!", "put", "Bl", "ob", "Callback", ".", "aw", "ait", "Callback", "(", "1", ",", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "put", "Bl", "ob", "()", "\u0120timed", "\u0120out", "\");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "put", "Bl", "ob", "Callback", ".", "get", "Exception", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120verify", "Exception", "Match", "(", "put", "Bl", "ob", "Callback", ",", "\u0120put", "Bl", "ob", "Future", ");", "\u0120throw", "\u0120put", "Bl", "ob", "Callback", ".", "get", "Exception", "();", "\u0120}", "\u0120assert", "True", "(\"", "Put", "Bl", "ob", ":", "\u0120Future", "\u0120is", "\u0120not", "\u0120done", "\u0120but", "\u0120callback", "\u0120has", "\u0120been", "\u0120received", "\",", "\u0120put", "Bl", "ob", "Future", ".", "is", "Done", "());", "\u0120assert", "Equ", "als", "(\"", "Put", "Bl", "ob", ":", "\u0120Future", "\u0120Bl", "ob", "Id", "\u0120and", "\u0120callback", "\u0120Bl", "ob", "Id", "\u0120do", "\u0120not", "\u0120match", "\",", "\u0120put", "Bl", "ob", "Future", ".", "get", "(),", "\u0120put", "Bl", "ob", "Callback", ".", "get", "Result", "());", "\u0120}", "\u0120return", "\u0120put", "Bl", "ob", "Future", ".", "get", "();", "\u0120}"], "docstring_tokens": ["ver", "ify", "Exception", "Match", "()", "\u0120blocks", "\u0120on", "\u0120future", ".", "get", "(),", "\u0120so", "\u0120is", "Done", "()", "\u0120will", "\u0120always", "\u0120be", "\u0120true", "\u0120when", "\u0120you", "'re", "\u0120here", ",", "\u0120no", "?", "\u0120Also", ",", "\u0120if", "\u0120the", "\u0120callback", "\u0120was", "\u0120received", ",", "\u0120then", "\u0120we", "\u0120should", "\u0120ensure", "\u0120that", "\u0120future", ".", "get", "()", "\u0120returns", "\u0120immediately", "\u0120as", "\u0120well", ",", "\u0120so", "\u0120shouldn", "'t", "\u0120it", "\u0120be", "\u0120a", "\u0120timed", "\u0120get", "\u0120within", "\u0120verify", "Exception", "Match", "()", "?"]}
{"function": "public Patient createFHIRPatient(Patient patient) { List<String> errors = new ArrayList<String>(); org.openmrs.Patient omrsPatient = FHIRPatientUtil.generateOmrsPatient(patient, errors); if (!errors.isEmpty()) { StringBuilder errorMessage = new StringBuilder(\"The request cannot be processed due to the following issues \\n\"); for (int i = 0; i < errors.size(); i++) { errorMessage.append((i + 1) + \" : \" + errors.get(i) + \"\\n\"); } throw new UnprocessableEntityException(errorMessage.toString()); } org.openmrs.api.PatientService patientService = Context.getPatientService(); omrsPatient = patientService.savePatient(omrsPatient); return FHIRPatientUtil.generatePatient(omrsPatient); }", "text": "This string should go into the messages.properties file.", "function_tokens": ["public", "\u0120Patient", "\u0120create", "FH", "IR", "Pat", "ient", "(", "Pat", "ient", "\u0120patient", ")", "\u0120{", "\u0120List", "<", "String", ">", "\u0120errors", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "String", ">", "();", "\u0120org", ".", "open", "m", "rs", ".", "Pat", "ient", "\u0120om", "rs", "Pat", "ient", "\u0120=", "\u0120F", "H", "IR", "Pat", "ient", "Ut", "il", ".", "gener", "ate", "O", "m", "rs", "Pat", "ient", "(", "patient", ",", "\u0120errors", ");", "\u0120if", "\u0120(!", "errors", ".", "is", "Empty", "())", "\u0120{", "\u0120String", "Builder", "\u0120error", "Message", "\u0120=", "\u0120new", "\u0120String", "Builder", "(\"", "The", "\u0120request", "\u0120cannot", "\u0120be", "\u0120processed", "\u0120due", "\u0120to", "\u0120the", "\u0120following", "\u0120issues", "\u0120\\", "n", "\");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120errors", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120error", "Message", ".", "append", "((", "i", "\u0120+", "\u01201", ")", "\u0120+", "\u0120\"", "\u0120:", "\u0120\"", "\u0120+", "\u0120errors", ".", "get", "(", "i", ")", "\u0120+", "\u0120\"\\", "n", "\");", "\u0120}", "\u0120throw", "\u0120new", "\u0120Un", "process", "able", "Entity", "Exception", "(", "error", "Message", ".", "to", "String", "());", "\u0120}", "\u0120org", ".", "open", "m", "rs", ".", "api", ".", "Pat", "ient", "Service", "\u0120patient", "Service", "\u0120=", "\u0120Context", ".", "get", "Pat", "ient", "Service", "();", "\u0120om", "rs", "Pat", "ient", "\u0120=", "\u0120patient", "Service", ".", "save", "Pat", "ient", "(", "om", "rs", "Pat", "ient", ");", "\u0120return", "\u0120F", "H", "IR", "Pat", "ient", "Ut", "il", ".", "gener", "ate", "Pat", "ient", "(", "om", "rs", "Pat", "ient", ");", "\u0120}"], "docstring_tokens": ["This", "\u0120string", "\u0120should", "\u0120go", "\u0120into", "\u0120the", "\u0120messages", ".", "properties", "\u0120file", "."]}
{"function": "private static void enforceTaskCountLimit(int size) { if (size > Limits.maxWorkflowTasks()) { throw new ConfigException(\"Too many for_range subtasks. Limit: \" + Limits.maxWorkflowTasks()); } }", "text": "Showing size here would help users to understand what's wrong since it's likely users don't know an actual number of tasks with step.", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120enforce", "Task", "Count", "Limit", "(", "int", "\u0120size", ")", "\u0120{", "\u0120if", "\u0120(", "size", "\u0120>", "\u0120Limits", ".", "max", "Work", "flow", "T", "asks", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Config", "Exception", "(\"", "Too", "\u0120many", "\u0120for", "_", "range", "\u0120subt", "asks", ".", "\u0120Limit", ":", "\u0120\"", "\u0120+", "\u0120Limits", ".", "max", "Work", "flow", "T", "asks", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Sh", "owing", "\u0120size", "\u0120here", "\u0120would", "\u0120help", "\u0120users", "\u0120to", "\u0120understand", "\u0120what", "'s", "\u0120wrong", "\u0120since", "\u0120it", "'s", "\u0120likely", "\u0120users", "\u0120don", "'t", "\u0120know", "\u0120an", "\u0120actual", "\u0120number", "\u0120of", "\u0120tasks", "\u0120with", "\u0120step", "."]}
{"function": "public void testAllCases() throws IOException { boolean crNewline = true; test(\"\", new String[]{}, 5); test(\"1234\\n\", new String[]{\"1234\", \"\\n\"}, 10); test(\"1234\", new String[]{\"1234\", \"\"}, 10); test(\"123\\r\\n123\\r\\nabc\\n\", new String[]{\"123\", \"\\r\\n\", \"123\", \"\\r\\n\", \"abc\", \"\\n\"}, 20); test(\"123\\r123\\r\\nabc\\n\", new String[]{\"123\", \"\\r\", \"123\", \"\\r\\n\", \"abc\", \"\\n\"}, 20); test(\"1234\\r\", new String[]{\"1234\", \"\\r\"}, 5); test(\"1234\\r\\nabc\\r\\n\", new String[]{\"1234\", \"\\r\\n\", \"abc\", \"\\r\\n\"}, 5); test( \"123456\", new String[]{\"123456\", \"\"}, 5); test( \"12345\", new String[]{\"12345\", \"\"}, 5); test( \"1234\\rA\", new String[]{\"1234\", \"\\r\", \"A\", \"\"}, 5); }", "text": "Can you repeat this same case with sizes 4 and 6 (buffer ending just before the carriage return, and just after the line feed)?", "function_tokens": ["public", "\u0120void", "\u0120test", "All", "C", "ases", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120boolean", "\u0120cr", "New", "line", "\u0120=", "\u0120true", ";", "\u0120test", "(\"", "\",", "\u0120new", "\u0120String", "[]", "{", "},", "\u01205", ");", "\u0120test", "(\"", "12", "34", "\\", "n", "\",", "\u0120new", "\u0120String", "[]", "{\"", "12", "34", "\",", "\u0120\"\\", "n", "\"},", "\u012010", ");", "\u0120test", "(\"", "12", "34", "\",", "\u0120new", "\u0120String", "[]", "{\"", "12", "34", "\",", "\u0120\"\"", "},", "\u012010", ");", "\u0120test", "(\"", "123", "\\", "r", "\\", "n", "123", "\\", "r", "\\", "n", "abc", "\\", "n", "\",", "\u0120new", "\u0120String", "[]", "{\"", "123", "\",", "\u0120\"\\", "r", "\\", "n", "\",", "\u0120\"", "123", "\",", "\u0120\"\\", "r", "\\", "n", "\",", "\u0120\"", "abc", "\",", "\u0120\"\\", "n", "\"},", "\u012020", ");", "\u0120test", "(\"", "123", "\\", "r", "123", "\\", "r", "\\", "n", "abc", "\\", "n", "\",", "\u0120new", "\u0120String", "[]", "{\"", "123", "\",", "\u0120\"\\", "r", "\",", "\u0120\"", "123", "\",", "\u0120\"\\", "r", "\\", "n", "\",", "\u0120\"", "abc", "\",", "\u0120\"\\", "n", "\"},", "\u012020", ");", "\u0120test", "(\"", "12", "34", "\\", "r", "\",", "\u0120new", "\u0120String", "[]", "{\"", "12", "34", "\",", "\u0120\"\\", "r", "\"},", "\u01205", ");", "\u0120test", "(\"", "12", "34", "\\", "r", "\\", "n", "abc", "\\", "r", "\\", "n", "\",", "\u0120new", "\u0120String", "[]", "{\"", "12", "34", "\",", "\u0120\"\\", "r", "\\", "n", "\",", "\u0120\"", "abc", "\",", "\u0120\"\\", "r", "\\", "n", "\"},", "\u01205", ");", "\u0120test", "(", "\u0120\"", "123", "456", "\",", "\u0120new", "\u0120String", "[]", "{\"", "123", "456", "\",", "\u0120\"\"", "},", "\u01205", ");", "\u0120test", "(", "\u0120\"", "123", "45", "\",", "\u0120new", "\u0120String", "[]", "{\"", "123", "45", "\",", "\u0120\"\"", "},", "\u01205", ");", "\u0120test", "(", "\u0120\"", "12", "34", "\\", "r", "A", "\",", "\u0120new", "\u0120String", "[]", "{\"", "12", "34", "\",", "\u0120\"\\", "r", "\",", "\u0120\"", "A", "\",", "\u0120\"\"", "},", "\u01205", ");", "\u0120}"], "docstring_tokens": ["Can", "\u0120you", "\u0120repeat", "\u0120this", "\u0120same", "\u0120case", "\u0120with", "\u0120sizes", "\u01204", "\u0120and", "\u01206", "\u0120(", "buffer", "\u0120ending", "\u0120just", "\u0120before", "\u0120the", "\u0120carriage", "\u0120return", ",", "\u0120and", "\u0120just", "\u0120after", "\u0120the", "\u0120line", "\u0120feed", ")?"]}
{"function": "public void stop() { log.info(\"Stopping task\"); try { writer.closeQuietly(); } finally { try { dialect.close(); } finally { dialect = null; } } }", "text": "Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?", "function_tokens": ["public", "\u0120void", "\u0120stop", "()", "\u0120{", "\u0120log", ".", "info", "(\"", "St", "opping", "\u0120task", "\");", "\u0120try", "\u0120{", "\u0120writer", ".", "close", "Qu", "iet", "ly", "();", "\u0120}", "\u0120finally", "\u0120{", "\u0120try", "\u0120{", "\u0120dialect", ".", "close", "();", "\u0120}", "\u0120finally", "\u0120{", "\u0120dialect", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Should", "\u0120we", "\u0120use", "\u0120org", ".", "apache", ".", "k", "af", "ka", ".", "common", ".", "utils", ".", "Ut", "ils", ".", "close", "Qu", "iet", "ly", "\u0120?"]}
{"function": "public void run() { SmppSession smppSession = smppClient.getSession(); if (smppSession != null && smppSession.isBound()) { try { smppSession.enquireLink(new EnquireLink(), enquireLinkTimeout); } catch (SmppTimeoutException | SmppChannelException | RecoverablePduException | UnrecoverablePduException error) { Log.warning(\"Enquire link failed, executing reconnect: \" + error); smppClient.reconnect(); } catch (InterruptedException error) { Log.info(\"Enquire link interrupted, probably killed by reconnecting\"); } } else { Log.error(\"Enquire link running while session is not connected\"); } }", "text": "Exception can be included as a separate parameter.", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120Sm", "pp", "Session", "\u0120sm", "pp", "Session", "\u0120=", "\u0120sm", "pp", "Client", ".", "get", "Session", "();", "\u0120if", "\u0120(", "sm", "pp", "Session", "\u0120!=", "\u0120null", "\u0120&&", "\u0120sm", "pp", "Session", ".", "is", "Bound", "())", "\u0120{", "\u0120try", "\u0120{", "\u0120sm", "pp", "Session", ".", "en", "quire", "Link", "(", "new", "\u0120En", "quire", "Link", "(),", "\u0120en", "quire", "Link", "Timeout", ");", "\u0120}", "\u0120catch", "\u0120(", "Sm", "pp", "Timeout", "Exception", "\u0120|", "\u0120Sm", "pp", "Channel", "Exception", "\u0120|", "\u0120Recover", "able", "P", "du", "Exception", "\u0120|", "\u0120Un", "re", "cover", "able", "P", "du", "Exception", "\u0120error", ")", "\u0120{", "\u0120Log", ".", "warning", "(\"", "En", "quire", "\u0120link", "\u0120failed", ",", "\u0120executing", "\u0120reconnect", ":", "\u0120\"", "\u0120+", "\u0120error", ");", "\u0120sm", "pp", "Client", ".", "re", "connect", "();", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120error", ")", "\u0120{", "\u0120Log", ".", "info", "(\"", "En", "quire", "\u0120link", "\u0120interrupted", ",", "\u0120probably", "\u0120killed", "\u0120by", "\u0120reconnect", "ing", "\");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Log", ".", "error", "(\"", "En", "quire", "\u0120link", "\u0120running", "\u0120while", "\u0120session", "\u0120is", "\u0120not", "\u0120connected", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["Exception", "\u0120can", "\u0120be", "\u0120included", "\u0120as", "\u0120a", "\u0120separate", "\u0120parameter", "."]}
{"function": "protected void postProcessing(boolean closeEarly) { if (sortGraph) { if (ghStorage.isCHPossible() && isCHPrepared()) throw new IllegalArgumentException(\"Sorting a prepared CHGraph is not possible yet. See #12\"); GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage); GHUtility.sortDFS(ghStorage, newGraph); logger.info(\"graph sorted (\" + getMemInfo() + \")\"); ghStorage = newGraph; } if (!hasInterpolated() && hasElevation()) { interpolateBridgesAndOrTunnels(); } initLocationIndex(); importPublicTransit(); if (lmPreparationHandler.isEnabled()) lmPreparationHandler.createPreparations(ghStorage, locationIndex); loadOrPrepareLM(closeEarly); if (chPreparationHandler.isEnabled()) chPreparationHandler.createPreparations(ghStorage); if (isCHPrepared()) { for (CHProfile profile : chPreparationHandler.getCHProfiles()) { if (!getProfileHash(profile.getProfile()).isEmpty() && !getProfileHash(profile.getProfile()).equals(\"\" + profilesByName.get(profile.getProfile()).getVersion())) throw new IllegalArgumentException(\"CH preparation of \" + profile.getProfile() + \" already exists in storage and doesn't match configuration\"); } } else { prepareCH(closeEarly); } }", "text": "Why is isEmpty() treated special here? Why is it possible for the hash to be empty?", "function_tokens": ["protected", "\u0120void", "\u0120post", "Process", "ing", "(", "bo", "olean", "\u0120close", "Early", ")", "\u0120{", "\u0120if", "\u0120(", "sort", "Graph", ")", "\u0120{", "\u0120if", "\u0120(", "gh", "Storage", ".", "is", "CH", "P", "ossible", "()", "\u0120&&", "\u0120is", "CH", "Pre", "pared", "())", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "S", "orting", "\u0120a", "\u0120prepared", "\u0120CH", "Graph", "\u0120is", "\u0120not", "\u0120possible", "\u0120yet", ".", "\u0120See", "\u0120#", "12", "\");", "\u0120Graph", "Ho", "pper", "Storage", "\u0120new", "Graph", "\u0120=", "\u0120GH", "Ut", "ility", ".", "new", "Storage", "(", "gh", "Storage", ");", "\u0120GH", "Ut", "ility", ".", "sort", "DF", "S", "(", "gh", "Storage", ",", "\u0120new", "Graph", ");", "\u0120logger", ".", "info", "(\"", "graph", "\u0120sorted", "\u0120(\"", "\u0120+", "\u0120get", "Mem", "Info", "()", "\u0120+", "\u0120\"", ")", "\");", "\u0120gh", "Storage", "\u0120=", "\u0120new", "Graph", ";", "\u0120}", "\u0120if", "\u0120(!", "has", "Inter", "pol", "ated", "()", "\u0120&&", "\u0120has", "E", "lev", "ation", "())", "\u0120{", "\u0120interpol", "ate", "B", "ridges", "And", "Or", "T", "un", "nels", "();", "\u0120}", "\u0120init", "Location", "Index", "();", "\u0120import", "Public", "Trans", "it", "();", "\u0120if", "\u0120(", "l", "m", "Pre", "par", "ation", "Handler", ".", "is", "Enabled", "())", "\u0120l", "m", "Pre", "par", "ation", "Handler", ".", "create", "Pre", "par", "ations", "(", "gh", "Storage", ",", "\u0120location", "Index", ");", "\u0120load", "Or", "Prep", "are", "LM", "(", "close", "Early", ");", "\u0120if", "\u0120(", "ch", "Pre", "par", "ation", "Handler", ".", "is", "Enabled", "())", "\u0120ch", "Pre", "par", "ation", "Handler", ".", "create", "Pre", "par", "ations", "(", "gh", "Storage", ");", "\u0120if", "\u0120(", "is", "CH", "Pre", "pared", "())", "\u0120{", "\u0120for", "\u0120(", "CH", "Profile", "\u0120profile", "\u0120:", "\u0120ch", "Pre", "par", "ation", "Handler", ".", "get", "CH", "Prof", "iles", "())", "\u0120{", "\u0120if", "\u0120(!", "get", "Profile", "Hash", "(", "profile", ".", "get", "Profile", "()", ").", "is", "Empty", "()", "\u0120&&", "\u0120!", "get", "Profile", "Hash", "(", "profile", ".", "get", "Profile", "()", ").", "equ", "als", "(\"", "\"", "\u0120+", "\u0120profiles", "By", "Name", ".", "get", "(", "profile", ".", "get", "Profile", "()", ").", "get", "Version", "()", "))", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "CH", "\u0120preparation", "\u0120of", "\u0120\"", "\u0120+", "\u0120profile", ".", "get", "Profile", "()", "\u0120+", "\u0120\"", "\u0120already", "\u0120exists", "\u0120in", "\u0120storage", "\u0120and", "\u0120doesn", "'t", "\u0120match", "\u0120configuration", "\");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120prepare", "CH", "(", "close", "Early", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120is", "\u0120is", "Empty", "()", "\u0120treated", "\u0120special", "\u0120here", "?", "\u0120Why", "\u0120is", "\u0120it", "\u0120possible", "\u0120for", "\u0120the", "\u0120hash", "\u0120to", "\u0120be", "\u0120empty", "?"]}
{"function": "private Long getFirstValidPrivateId(List<InstanceGroup> instanceGroups) { LOGGER.debug(\"Get first valid PrivateId of instanceGroups\"); long highest = instanceGroups.stream() .flatMap(ig -> ig.getAllInstanceMetaData().stream()) .filter(im -> im.getPrivateId() != null) .map(InstanceMetaData::getPrivateId) .max(Long::compare) .orElse(0L); LOGGER.debug(\"Highest privateId: {}\", highest); return highest == 0 ? 0 : highest + 1; }", "text": "so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:  return highest.isPresent() ? highest.get() + 1 : 0;  also we might have a test for this method to be sure we don't break it in the future", "function_tokens": ["private", "\u0120Long", "\u0120get", "First", "Valid", "Private", "Id", "(", "List", "<", "Instance", "Group", ">", "\u0120instance", "G", "roups", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Get", "\u0120first", "\u0120valid", "\u0120Private", "Id", "\u0120of", "\u0120instance", "G", "roups", "\");", "\u0120long", "\u0120highest", "\u0120=", "\u0120instance", "G", "roups", ".", "stream", "()", "\u0120.", "flat", "Map", "(", "ig", "\u0120->", "\u0120ig", ".", "get", "All", "Instance", "Meta", "Data", "().", "stream", "())", "\u0120.", "filter", "(", "im", "\u0120->", "\u0120im", ".", "get", "Private", "Id", "()", "\u0120!=", "\u0120null", ")", "\u0120.", "map", "(", "Instance", "Meta", "Data", "::", "get", "Private", "Id", ")", "\u0120.", "max", "(", "Long", "::", "comp", "are", ")", "\u0120.", "or", "Else", "(", "0", "L", ");", "\u0120LOG", "GER", ".", "debug", "(\"", "Hig", "hest", "\u0120private", "Id", ":", "\u0120{}", "\",", "\u0120highest", ");", "\u0120return", "\u0120highest", "\u0120==", "\u01200", "\u0120?", "\u01200", "\u0120:", "\u0120highest", "\u0120+", "\u01201", ";", "\u0120}"], "docstring_tokens": ["so", "\u0120this", "\u0120will", "\u0120produce", "\u0120invalid", "\u0120output", ".", "\u0120if", "\u0120we", "\u0120have", "\u0120highest", "\u0120ID", "\u01200", "\u0120then", "\u0120we", "\u0120will", "\u0120return", "\u01200", "\u0120as", "\u0120first", "\u0120valid", "\u0120id", ".", "\u0120this", "\u0120should", "\u0120be", "\u0120an", "\u0120Optional", "<", "Long", ">", "\u0120and", "\u0120the", "\u0120return", "\u0120look", "\u0120like", ":", "\u0120", "\u0120return", "\u0120highest", ".", "is", "Present", "()", "\u0120?", "\u0120highest", ".", "get", "()", "\u0120+", "\u01201", "\u0120:", "\u01200", ";", "\u0120", "\u0120also", "\u0120we", "\u0120might", "\u0120have", "\u0120a", "\u0120test", "\u0120for", "\u0120this", "\u0120method", "\u0120to", "\u0120be", "\u0120sure", "\u0120we", "\u0120don", "'t", "\u0120break", "\u0120it", "\u0120in", "\u0120the", "\u0120future"]}
{"function": "private void applyChanges(Sample target, Sample source) throws IOException { target.setDescription(source.getDescription()); target.setSampleType(source.getSampleType()); target.setReceivedDate(source.getReceivedDate()); target.setQcPassed(source.getQcPassed()); target.setScientificName(source.getScientificName()); target.setTaxonIdentifier(source.getTaxonIdentifier()); if (!target.getAlias().equals(source.getAlias()) && (!isDetailedSample(target) || (isDetailedSample(target) && !((SampleAdditionalInfo) target).hasNonStandardAlias()))) { validateAliasUniqueness(source.getAlias()); } target.setAlias(source.getAlias()); target.setDescription(source.getDescription()); target.setEmpty(source.isEmpty()); target.setVolume(source.getVolume()); if (!isStringBlankOrNull(source.getIdentificationBarcode())) { target.setIdentificationBarcode(source.getIdentificationBarcode()); } if (isDetailedSample(target)) { sampleAdditionalInfoService.applyChanges((SampleAdditionalInfo) target, (SampleAdditionalInfo) source); if (isIdentitySample(target)) { Identity iTarget = (Identity) target; Identity iSource = (Identity) source; iTarget.setInternalName(iSource.getInternalName()); iTarget.setExternalName(iSource.getExternalName()); } if (isTissueSample(target)) { sampleTissueService.applyChanges((SampleTissue) target, (SampleTissue) source); } if (isTissueProcessingSample(target)) { applyChanges((SampleTissueProcessing) target, (SampleTissueProcessing) source); } if (isAliquotSample(target)) { SampleAliquot saTarget = (SampleAliquot) target; SampleAliquot saSource = (SampleAliquot) source; saTarget.setSamplePurpose(saSource.getSamplePurpose()); } if (isStockSample(target)) { SampleStock ssTarget = (SampleStock) target; SampleStock ssSource = (SampleStock) source; ssTarget.setStrStatus(ssSource.getStrStatus()); ssTarget.setConcentration(ssSource.getConcentration()); ssTarget.setDNAseTreated(ssSource.getDNAseTreated()); } } }", "text": "This will prevent changing to null, which should be allowed", "function_tokens": ["private", "\u0120void", "\u0120apply", "Changes", "(", "Sample", "\u0120target", ",", "\u0120Sample", "\u0120source", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120target", ".", "set", "Description", "(", "source", ".", "get", "Description", "());", "\u0120target", ".", "set", "Sample", "Type", "(", "source", ".", "get", "Sample", "Type", "());", "\u0120target", ".", "set", "Re", "ceived", "Date", "(", "source", ".", "get", "Re", "ceived", "Date", "());", "\u0120target", ".", "set", "Q", "c", "Pass", "ed", "(", "source", ".", "get", "Q", "c", "Pass", "ed", "());", "\u0120target", ".", "set", "Scient", "ific", "Name", "(", "source", ".", "get", "Scient", "ific", "Name", "());", "\u0120target", ".", "set", "Tax", "on", "Ident", "ifier", "(", "source", ".", "get", "Tax", "on", "Ident", "ifier", "());", "\u0120if", "\u0120(!", "target", ".", "get", "Alias", "().", "equ", "als", "(", "source", ".", "get", "Alias", "())", "\u0120&&", "\u0120(!", "is", "Detailed", "Sample", "(", "target", ")", "\u0120||", "\u0120(", "is", "Detailed", "Sample", "(", "target", ")", "\u0120&&", "\u0120!", "((", "Sample", "Additional", "Info", ")", "\u0120target", ").", "has", "Non", "Standard", "Alias", "()", ")))", "\u0120{", "\u0120validate", "Alias", "Un", "iqueness", "(", "source", ".", "get", "Alias", "());", "\u0120}", "\u0120target", ".", "set", "Alias", "(", "source", ".", "get", "Alias", "());", "\u0120target", ".", "set", "Description", "(", "source", ".", "get", "Description", "());", "\u0120target", ".", "set", "Empty", "(", "source", ".", "is", "Empty", "());", "\u0120target", ".", "set", "Volume", "(", "source", ".", "get", "Volume", "());", "\u0120if", "\u0120(!", "is", "String", "Bl", "ank", "Or", "Null", "(", "source", ".", "get", "Ident", "ification", "B", "arc", "ode", "()", "))", "\u0120{", "\u0120target", ".", "set", "Ident", "ification", "B", "arc", "ode", "(", "source", ".", "get", "Ident", "ification", "B", "arc", "ode", "());", "\u0120}", "\u0120if", "\u0120(", "is", "Detailed", "Sample", "(", "target", "))", "\u0120{", "\u0120sample", "Additional", "Info", "Service", ".", "apply", "Changes", "((", "Sample", "Additional", "Info", ")", "\u0120target", ",", "\u0120(", "Sample", "Additional", "Info", ")", "\u0120source", ");", "\u0120if", "\u0120(", "is", "Id", "entity", "Sample", "(", "target", "))", "\u0120{", "\u0120Identity", "\u0120iT", "arget", "\u0120=", "\u0120(", "Id", "entity", ")", "\u0120target", ";", "\u0120Identity", "\u0120i", "Source", "\u0120=", "\u0120(", "Id", "entity", ")", "\u0120source", ";", "\u0120iT", "arget", ".", "set", "Internal", "Name", "(", "i", "Source", ".", "get", "Internal", "Name", "());", "\u0120iT", "arget", ".", "set", "External", "Name", "(", "i", "Source", ".", "get", "External", "Name", "());", "\u0120}", "\u0120if", "\u0120(", "is", "T", "issue", "Sample", "(", "target", "))", "\u0120{", "\u0120sample", "T", "issue", "Service", ".", "apply", "Changes", "((", "Sample", "T", "issue", ")", "\u0120target", ",", "\u0120(", "Sample", "T", "issue", ")", "\u0120source", ");", "\u0120}", "\u0120if", "\u0120(", "is", "T", "issue", "Process", "ing", "Sample", "(", "target", "))", "\u0120{", "\u0120apply", "Changes", "((", "Sample", "T", "issue", "Process", "ing", ")", "\u0120target", ",", "\u0120(", "Sample", "T", "issue", "Process", "ing", ")", "\u0120source", ");", "\u0120}", "\u0120if", "\u0120(", "is", "Al", "iqu", "ot", "Sample", "(", "target", "))", "\u0120{", "\u0120Sample", "Al", "iqu", "ot", "\u0120sa", "Target", "\u0120=", "\u0120(", "Sample", "Al", "iqu", "ot", ")", "\u0120target", ";", "\u0120Sample", "Al", "iqu", "ot", "\u0120sa", "Source", "\u0120=", "\u0120(", "Sample", "Al", "iqu", "ot", ")", "\u0120source", ";", "\u0120sa", "Target", ".", "set", "Sample", "Pur", "pose", "(", "sa", "Source", ".", "get", "Sample", "Pur", "pose", "());", "\u0120}", "\u0120if", "\u0120(", "is", "Stock", "Sample", "(", "target", "))", "\u0120{", "\u0120Sample", "Stock", "\u0120ss", "Target", "\u0120=", "\u0120(", "Sample", "Stock", ")", "\u0120target", ";", "\u0120Sample", "Stock", "\u0120ss", "Source", "\u0120=", "\u0120(", "Sample", "Stock", ")", "\u0120source", ";", "\u0120ss", "Target", ".", "set", "Str", "Status", "(", "ss", "Source", ".", "get", "Str", "Status", "());", "\u0120ss", "Target", ".", "set", "Con", "cent", "ration", "(", "ss", "Source", ".", "get", "Con", "cent", "ration", "());", "\u0120ss", "Target", ".", "set", "DNA", "se", "T", "reated", "(", "ss", "Source", ".", "get", "DNA", "se", "T", "reated", "());", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120will", "\u0120prevent", "\u0120changing", "\u0120to", "\u0120null", ",", "\u0120which", "\u0120should", "\u0120be", "\u0120allowed"]}
{"function": "public Node(String name, Id id) throws NodeException { Objects.requireNonNull(name); Objects.requireNonNull(id); this.mName = name; this.mId = id; }", "text": "Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.", "function_tokens": ["public", "\u0120Node", "(", "String", "\u0120name", ",", "\u0120Id", "\u0120id", ")", "\u0120throws", "\u0120Node", "Exception", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "name", ");", "\u0120Objects", ".", "require", "Non", "Null", "(", "id", ");", "\u0120this", ".", "m", "Name", "\u0120=", "\u0120name", ";", "\u0120this", ".", "m", "Id", "\u0120=", "\u0120id", ";", "\u0120}"], "docstring_tokens": ["Or", "\u0120even", "\u0120better", ",", "\u0120this", ".", "m", "Name", "\u0120=", "\u0120Objects", ".", "require", "Non", "Null", "(", "name", ");", ".", "\u0120To", "\u0120be", "\u0120check", "\u0120everywhere", "\u0120else", "."]}
{"function": "public boolean Validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = configurator.getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().AsConvertible().Integer(); getModel().getNumOfDesktops().ValidateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().ValidateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid()); getModel().setIsPoolTabValid(true); return super.Validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid(); }", "text": "Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.", "function_tokens": ["public", "\u0120boolean", "\u0120Val", "idate", "()", "\u0120{", "\u0120boolean", "\u0120is", "New", "\u0120=", "\u0120get", "Model", "().", "get", "Is", "New", "();", "\u0120int", "\u0120max", "All", "owed", "V", "ms", "\u0120=", "\u0120config", "ur", "ator", ".", "get", "Max", "V", "ms", "In", "Pool", "();", "\u0120int", "\u0120assigned", "V", "ms", "\u0120=", "\u0120get", "Model", "().", "get", "Ass", "igned", "V", "ms", "().", "As", "Con", "vert", "ible", "().", "Integer", "();", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "Val", "idate", "Entity", "(", "\u0120new", "\u0120I", "Val", "idation", "[]", "\u0120{", "\u0120new", "\u0120Not", "Empty", "Val", "idation", "(),", "\u0120new", "\u0120Length", "Val", "idation", "(", "4", "),", "\u0120new", "\u0120Integer", "Val", "idation", "(", "is", "New", "\u0120?", "\u01201", "\u0120:", "\u01200", ",", "\u0120is", "New", "\u0120?", "\u0120max", "All", "owed", "V", "ms", "\u0120:", "\u0120max", "All", "owed", "V", "ms", "\u0120-", "\u0120assigned", "V", "ms", ")", "\u0120});", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "Val", "idate", "Entity", "(", "\u0120new", "\u0120I", "Val", "idation", "[]", "\u0120{", "\u0120new", "\u0120Not", "Empty", "Val", "idation", "(),", "\u0120new", "\u0120Integer", "Val", "idation", "(", "0", ",", "\u0120assigned", "V", "ms", ")", "\u0120});", "\u0120get", "Model", "().", "set", "Is", "General", "Tab", "Valid", "(", "get", "Model", "().", "get", "Is", "General", "Tab", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Name", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "get", "Is", "Valid", "());", "\u0120get", "Model", "().", "set", "Is", "Pool", "Tab", "Valid", "(", "true", ");", "\u0120return", "\u0120super", ".", "Val", "idate", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Name", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "get", "Is", "Valid", "();", "\u0120}"], "docstring_tokens": ["Do", "\u0120we", "\u0120have", "\u0120to", "\u0120use", "\u0120the", "\u0120config", "ur", "ator", "\u0120for", "\u0120fetch", "ing", "\u0120'", "Max", "V", "ms", "In", "Pool", "'", "\u0120value", "?", "\u0120A", "\u0120lot", "\u0120of", "\u0120configuration", "\u0120values", "\u0120are", "\u0120fet", "ched", "\u0120in", "\u0120'", "V", "m", "Model", "Beh", "avior", "Base", "'", "\u0120(", "e", ".", "g", ".", "\u0120Get", "Max", "Num", "Of", "V", "m", "S", "ockets", ")", "\u0120-", "\u0120try", "\u0120to", "\u0120retrieve", "\u0120it", "\u0120once", "\u0120'", "Pool", "Model", "Beh", "avior", "Base", "'", "\u0120if", "\u0120it", "'s", "\u0120not", "\u0120too", "\u0120cumbersome", "."]}
{"function": "synchronized void flush() { if (_kafkaProducer != null) { try { CompletableFutureUtils.within(CompletableFuture.runAsync(() -> _kafkaProducer.flush()), Duration.ofMillis(_flushTimeout)).join(); } catch (CompletionException e) { Throwable cause = e.getCause(); if (cause instanceof InterruptException) { _log.warn(\"Kafka producer flush interrupted, closing producer {}.\", _kafkaProducer); shutdownProducer(); throw (InterruptException) cause; } else if (cause instanceof java.util.concurrent.TimeoutException) { _log.warn(\"Kafka producer flush timed out after {}ms. Destination topic may be unavailable.\", _flushTimeout); } throw e; } } }", "text": "CompletableFuture.runAsync() uses the common pool which isn't the best option for a potentially long blocking call like Producer.flush(). Even if we provide our own thread pool to runAsync(), the CompletableFuture we'll get won't give us a way to interrupt a Producer.flush() call that exceeds the allowed timeout, which is necessary to free up the thread-pool thread in question. This is because calling cancel(true) on a CompletableFuture returned by runAsync() only causes a cancellation exception to be propagated without interrupting the blocked thread pool. I'm afraid our only option here seems to be using an ExecutorService directly java // It's okay to use a single thread executor since flush() is synchronized ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> future = executor.submit(() -> super.flush()); try { // Block until timeout elapses future.get(_flushTimeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { ... // Interrupt the Producer.flush() call to free up the blocked thread future.cancel(true); ... }", "function_tokens": ["syn", "chron", "ized", "\u0120void", "\u0120flush", "()", "\u0120{", "\u0120if", "\u0120(_", "k", "af", "ka", "Produ", "cer", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Com", "ple", "table", "Future", "Ut", "ils", ".", "within", "(", "Com", "ple", "table", "Future", ".", "run", "Async", "(", "()", "\u0120->", "\u0120_", "k", "af", "ka", "Produ", "cer", ".", "flush", "()", "),", "\u0120Duration", ".", "of", "Mill", "is", "(_", "flush", "Timeout", ")).", "join", "();", "\u0120}", "\u0120catch", "\u0120(", "Com", "pletion", "Exception", "\u0120e", ")", "\u0120{", "\u0120Throw", "able", "\u0120cause", "\u0120=", "\u0120e", ".", "get", "Cause", "();", "\u0120if", "\u0120(", "cause", "\u0120instance", "of", "\u0120Inter", "rupt", "Exception", ")", "\u0120{", "\u0120_", "log", ".", "warn", "(\"", "K", "af", "ka", "\u0120producer", "\u0120flush", "\u0120interrupted", ",", "\u0120closing", "\u0120producer", "\u0120{}", ".\",", "\u0120_", "k", "af", "ka", "Produ", "cer", ");", "\u0120shutdown", "Produ", "cer", "();", "\u0120throw", "\u0120(", "Inter", "rupt", "Exception", ")", "\u0120cause", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "cause", "\u0120instance", "of", "\u0120java", ".", "util", ".", "con", "current", ".", "Timeout", "Exception", ")", "\u0120{", "\u0120_", "log", ".", "warn", "(\"", "K", "af", "ka", "\u0120producer", "\u0120flush", "\u0120timed", "\u0120out", "\u0120after", "\u0120{}", "ms", ".", "\u0120Destination", "\u0120topic", "\u0120may", "\u0120be", "\u0120unavailable", ".\",", "\u0120_", "flush", "Timeout", ");", "\u0120}", "\u0120throw", "\u0120e", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Com", "ple", "table", "Future", ".", "run", "Async", "()", "\u0120uses", "\u0120the", "\u0120common", "\u0120pool", "\u0120which", "\u0120isn", "'t", "\u0120the", "\u0120best", "\u0120option", "\u0120for", "\u0120a", "\u0120potentially", "\u0120long", "\u0120blocking", "\u0120call", "\u0120like", "\u0120Producer", ".", "flush", "().", "\u0120Even", "\u0120if", "\u0120we", "\u0120provide", "\u0120our", "\u0120own", "\u0120thread", "\u0120pool", "\u0120to", "\u0120run", "Async", "(),", "\u0120the", "\u0120Com", "ple", "table", "Future", "\u0120we", "'ll", "\u0120get", "\u0120won", "'t", "\u0120give", "\u0120us", "\u0120a", "\u0120way", "\u0120to", "\u0120interrupt", "\u0120a", "\u0120Producer", ".", "flush", "()", "\u0120call", "\u0120that", "\u0120exceeds", "\u0120the", "\u0120allowed", "\u0120timeout", ",", "\u0120which", "\u0120is", "\u0120necessary", "\u0120to", "\u0120free", "\u0120up", "\u0120the", "\u0120thread", "-", "pool", "\u0120thread", "\u0120in", "\u0120question", ".", "\u0120This", "\u0120is", "\u0120because", "\u0120calling", "\u0120cancel", "(", "true", ")", "\u0120on", "\u0120a", "\u0120Com", "ple", "table", "Future", "\u0120returned", "\u0120by", "\u0120run", "Async", "()", "\u0120only", "\u0120causes", "\u0120a", "\u0120cancellation", "\u0120exception", "\u0120to", "\u0120be", "\u0120propag", "ated", "\u0120without", "\u0120interrupt", "ing", "\u0120the", "\u0120blocked", "\u0120thread", "\u0120pool", ".", "\u0120I", "'m", "\u0120afraid", "\u0120our", "\u0120only", "\u0120option", "\u0120here", "\u0120seems", "\u0120to", "\u0120be", "\u0120using", "\u0120an", "\u0120Exec", "utor", "Service", "\u0120directly", "\u0120java", "\u0120//", "\u0120It", "'s", "\u0120okay", "\u0120to", "\u0120use", "\u0120a", "\u0120single", "\u0120thread", "\u0120execut", "or", "\u0120since", "\u0120flush", "()", "\u0120is", "\u0120synchronized", "\u0120Exec", "utor", "Service", "\u0120execut", "or", "\u0120=", "\u0120Exec", "ut", "ors", ".", "new", "Single", "Thread", "Exec", "utor", "();", "\u0120Future", "<?", ">", "\u0120future", "\u0120=", "\u0120execut", "or", ".", "submit", "(", "()", "\u0120->", "\u0120super", ".", "flush", "());", "\u0120try", "\u0120{", "\u0120//", "\u0120Block", "\u0120until", "\u0120timeout", "\u0120el", "apses", "\u0120future", ".", "get", "(_", "flush", "Timeout", ",", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", ");", "\u0120}", "\u0120catch", "\u0120(", "Timeout", "Exception", "\u0120e", ")", "\u0120{", "\u0120...", "\u0120//", "\u0120Inter", "rupt", "\u0120the", "\u0120Producer", ".", "flush", "()", "\u0120call", "\u0120to", "\u0120free", "\u0120up", "\u0120the", "\u0120blocked", "\u0120thread", "\u0120future", ".", "c", "ancel", "(", "true", ");", "\u0120...", "\u0120}"]}
{"function": "public void testPropertyNameOnMethodName() throws NoSuchMethodException { class Hotel { String hotelName; public String getHotelName() { return hotelName; } } Method m = Hotel.class.getDeclaredMethod(\"getHotelName\"); assertMemberValue(m, \"getHotelName\"); }", "text": "Does GSON maintain full method names or does it drop Java bean notation? I know in Jackson's case this would serialize as hotelName (possibly HotelName as I'm not completely certain about how it handles casing).", "function_tokens": ["public", "\u0120void", "\u0120test", "Property", "Name", "On", "Method", "Name", "()", "\u0120throws", "\u0120No", "Such", "Method", "Exception", "\u0120{", "\u0120class", "\u0120Hotel", "\u0120{", "\u0120String", "\u0120hotel", "Name", ";", "\u0120public", "\u0120String", "\u0120get", "Hot", "el", "Name", "()", "\u0120{", "\u0120return", "\u0120hotel", "Name", ";", "\u0120}", "\u0120}", "\u0120Method", "\u0120m", "\u0120=", "\u0120Hotel", ".", "class", ".", "get", "Decl", "ared", "Method", "(\"", "get", "Hot", "el", "Name", "\");", "\u0120assert", "Member", "Value", "(", "m", ",", "\u0120\"", "get", "Hot", "el", "Name", "\");", "\u0120}"], "docstring_tokens": ["Does", "\u0120G", "SON", "\u0120maintain", "\u0120full", "\u0120method", "\u0120names", "\u0120or", "\u0120does", "\u0120it", "\u0120drop", "\u0120Java", "\u0120bean", "\u0120notation", "?", "\u0120I", "\u0120know", "\u0120in", "\u0120Jackson", "'s", "\u0120case", "\u0120this", "\u0120would", "\u0120serial", "ize", "\u0120as", "\u0120hotel", "Name", "\u0120(", "possibly", "\u0120Hotel", "Name", "\u0120as", "\u0120I", "'m", "\u0120not", "\u0120completely", "\u0120certain", "\u0120about", "\u0120how", "\u0120it", "\u0120handles", "\u0120casing", ")."]}
{"function": "void oneParameterAndStatementUtilityConstructor() { LambdaExpr expr = new LambdaExpr(new Parameter(new UnknownType(), \"a\"), parseStatement(\"return 5;\")); assertEquals(\"a -> return 5;\", expr.toString()); }", "text": "I don't think this is valid Java code...", "function_tokens": ["void", "\u0120one", "Parameter", "And", "Statement", "Ut", "ility", "Construct", "or", "()", "\u0120{", "\u0120Lamb", "da", "Ex", "pr", "\u0120expr", "\u0120=", "\u0120new", "\u0120Lamb", "da", "Ex", "pr", "(", "new", "\u0120Param", "eter", "(", "new", "\u0120Unknown", "Type", "(),", "\u0120\"", "a", "\"),", "\u0120parse", "Statement", "(\"", "return", "\u01205", ";", "\")", ");", "\u0120assert", "Equ", "als", "(\"", "a", "\u0120->", "\u0120return", "\u01205", ";", "\",", "\u0120expr", ".", "to", "String", "());", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120this", "\u0120is", "\u0120valid", "\u0120Java", "\u0120code", "..."]}
{"function": "public void useDefaultKeyPair() throws KeyStoreException { String alias = Config.<String>GetValue(ConfigValues.CertAlias); String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl); char[] password = Config.<String>GetValue(ConfigValues.keystorePass).toCharArray(); KeyStore.PrivateKeyEntry entry; InputStream in = null; try { in = new FileInputStream(p12); KeyStore ks = KeyStore.getInstance(\"PKCS12\"); ks.load(in, password); entry = (KeyStore.PrivateKeyEntry)ks.getEntry( alias, new KeyStore.PasswordProtection(password) ); } catch (Exception e) { throw new KeyStoreException( String.format( \"Failed to get certificate entry from key store: %1$s/%2$s\", p12, alias ), e ); } finally { Arrays.fill(password, '*'); if (in != null) { try { in.close(); } catch(IOException e) { log.error(\"Cannot close key store\", e); } } } if (entry == null) { throw new KeyStoreException( String.format( \"Bad key store: %1$s/%2$s\", p12, alias ) ); } setKeyPair( new KeyPair( entry.getCertificate().getPublicKey(), entry.getPrivateKey() ) ); }", "text": "These ^ could be final.", "function_tokens": ["public", "\u0120void", "\u0120use", "Default", "Key", "P", "air", "()", "\u0120throws", "\u0120Key", "Store", "Exception", "\u0120{", "\u0120String", "\u0120alias", "\u0120=", "\u0120Config", ".<", "String", ">", "Get", "Value", "(", "Config", "Values", ".", "Cert", "Alias", ");", "\u0120String", "\u0120p", "12", "\u0120=", "\u0120Config", ".<", "String", ">", "Get", "Value", "(", "Config", "Values", ".", "key", "store", "Url", ");", "\u0120char", "[]", "\u0120password", "\u0120=", "\u0120Config", ".<", "String", ">", "Get", "Value", "(", "Config", "Values", ".", "key", "store", "Pass", ").", "to", "Char", "Array", "();", "\u0120Key", "Store", ".", "Private", "Key", "Entry", "\u0120entry", ";", "\u0120Input", "Stream", "\u0120in", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120in", "\u0120=", "\u0120new", "\u0120File", "Input", "Stream", "(", "p", "12", ");", "\u0120Key", "Store", "\u0120k", "s", "\u0120=", "\u0120Key", "Store", ".", "get", "Instance", "(\"", "PK", "CS", "12", "\");", "\u0120k", "s", ".", "load", "(", "in", ",", "\u0120password", ");", "\u0120entry", "\u0120=", "\u0120(", "Key", "Store", ".", "Private", "Key", "Entry", ")", "ks", ".", "get", "Entry", "(", "\u0120alias", ",", "\u0120new", "\u0120Key", "Store", ".", "Password", "Prot", "ection", "(", "password", ")", "\u0120);", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Key", "Store", "Exception", "(", "\u0120String", ".", "format", "(", "\u0120\"", "F", "ailed", "\u0120to", "\u0120get", "\u0120certificate", "\u0120entry", "\u0120from", "\u0120key", "\u0120store", ":", "\u0120%", "1", "$", "s", "/", "%", "2", "$", "s", "\",", "\u0120p", "12", ",", "\u0120alias", "\u0120),", "\u0120e", "\u0120);", "\u0120}", "\u0120finally", "\u0120{", "\u0120Ar", "rays", ".", "fill", "(", "password", ",", "\u0120'", "*", "');", "\u0120if", "\u0120(", "in", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120in", ".", "close", "();", "\u0120}", "\u0120catch", "(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "C", "annot", "\u0120close", "\u0120key", "\u0120store", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "entry", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Key", "Store", "Exception", "(", "\u0120String", ".", "format", "(", "\u0120\"", "Bad", "\u0120key", "\u0120store", ":", "\u0120%", "1", "$", "s", "/", "%", "2", "$", "s", "\",", "\u0120p", "12", ",", "\u0120alias", "\u0120)", "\u0120);", "\u0120}", "\u0120set", "Key", "P", "air", "(", "\u0120new", "\u0120Key", "P", "air", "(", "\u0120entry", ".", "get", "Cert", "ificate", "().", "get", "Public", "Key", "(),", "\u0120entry", ".", "get", "Private", "Key", "()", "\u0120)", "\u0120);", "\u0120}"], "docstring_tokens": ["These", "\u0120^", "\u0120could", "\u0120be", "\u0120final", "."]}
{"function": "protected void endVmCommand() { Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED); boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess(); boolean liveSnapshotRequired = isLiveSnapshotApplicable(); boolean liveSnapshotSucceeded = false; if (taskGroupSucceeded) { getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK); if (liveSnapshotRequired) { liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot); } else { if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) { logMemorySavingFailed(); getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId()); removeMemoryVolumesOfSnapshot(createdSnapshot); } } } else { if (createdSnapshot != null) { revertToActiveSnapshot(createdSnapshot.getId()); if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) { removeMemoryVolumesOfSnapshot(createdSnapshot); } } else { log.warnFormat(\"No snapshot was created for VM {0} which is in LOCKED status\", getVmId()); } } boolean archSupportSnapshot = isSnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion()); if (getParameters().isSaveMemory() && (archSupportSnapshot || !FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()))) { log.warnFormat(\"A memory snapshot was required but not created, since VM architecture does not support it.\", getVmId()); } incrementVmGeneration(); endActionOnDisks(); setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded)); getReturnValue().setEndActionTryAgain(false); }", "text": "same here (!archSupportSnapshot) ? how about extract this check to separate method like 'isMemorySnapshotSupported' that checks the cluster compatibility version and the architecture (because I see that is appears multiple times here) ?", "function_tokens": ["protected", "\u0120void", "\u0120end", "V", "m", "Command", "()", "\u0120{", "\u0120Snap", "shot", "\u0120created", "Snap", "shot", "\u0120=", "\u0120get", "Snap", "shot", "D", "ao", "().", "get", "(", "get", "V", "m", "Id", "(),", "\u0120get", "Parameters", "().", "get", "Snap", "shot", "Type", "(),", "\u0120Snap", "shot", "Status", ".", "LOCK", "ED", ");", "\u0120boolean", "\u0120task", "Group", "S", "uc", "ceed", "ed", "\u0120=", "\u0120created", "Snap", "shot", "\u0120!=", "\u0120null", "\u0120&&", "\u0120get", "Parameters", "().", "get", "Task", "Group", "Success", "();", "\u0120boolean", "\u0120live", "Snap", "shot", "Required", "\u0120=", "\u0120is", "Live", "Snap", "shot", "Applic", "able", "();", "\u0120boolean", "\u0120live", "Snap", "shot", "S", "uc", "ceed", "ed", "\u0120=", "\u0120false", ";", "\u0120if", "\u0120(", "task", "Group", "S", "uc", "ceed", "ed", ")", "\u0120{", "\u0120get", "Snap", "shot", "D", "ao", "().", "update", "Status", "(", "created", "Snap", "shot", ".", "get", "Id", "(),", "\u0120Snap", "shot", "Status", ".", "OK", ");", "\u0120if", "\u0120(", "live", "Snap", "shot", "Required", ")", "\u0120{", "\u0120live", "Snap", "shot", "S", "uc", "ceed", "ed", "\u0120=", "\u0120perform", "Live", "Snap", "shot", "(", "created", "Snap", "shot", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "get", "Parameters", "().", "is", "Save", "Memory", "()", "\u0120&&", "\u0120created", "Snap", "shot", ".", "cont", "ains", "Memory", "())", "\u0120{", "\u0120log", "Memory", "S", "aving", "F", "ailed", "();", "\u0120get", "Snap", "shot", "D", "ao", "().", "remove", "Memory", "From", "Snap", "shot", "(", "created", "Snap", "shot", ".", "get", "Id", "());", "\u0120remove", "Memory", "Vol", "umes", "Of", "Snap", "shot", "(", "created", "Snap", "shot", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "created", "Snap", "shot", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120revert", "To", "Active", "Snap", "shot", "(", "created", "Snap", "shot", ".", "get", "Id", "());", "\u0120if", "\u0120(", "get", "Parameters", "().", "is", "Save", "Memory", "()", "\u0120&&", "\u0120created", "Snap", "shot", ".", "cont", "ains", "Memory", "())", "\u0120{", "\u0120remove", "Memory", "Vol", "umes", "Of", "Snap", "shot", "(", "created", "Snap", "shot", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "warn", "Format", "(\"", "No", "\u0120snapshot", "\u0120was", "\u0120created", "\u0120for", "\u0120VM", "\u0120{", "0", "}", "\u0120which", "\u0120is", "\u0120in", "\u0120L", "OCK", "ED", "\u0120status", "\",", "\u0120get", "V", "m", "Id", "());", "\u0120}", "\u0120}", "\u0120boolean", "\u0120arch", "Support", "Snap", "shot", "\u0120=", "\u0120is", "Snap", "shot", "Supported", "By", "Arch", "itect", "ure", "(", "get", "V", "m", "().", "get", "Cl", "uster", "Arch", "(),", "\u0120get", "V", "m", "().", "get", "V", "ds", "Group", "Comp", "atibility", "Version", "());", "\u0120if", "\u0120(", "get", "Parameters", "().", "is", "Save", "Memory", "()", "\u0120&&", "\u0120(", "arch", "Support", "Snap", "shot", "\u0120||", "\u0120!", "Feature", "Supported", ".", "memory", "Snap", "shot", "(", "get", "V", "m", "().", "get", "V", "ds", "Group", "Comp", "atibility", "Version", "()", ")))", "\u0120{", "\u0120log", ".", "warn", "Format", "(\"", "A", "\u0120memory", "\u0120snapshot", "\u0120was", "\u0120required", "\u0120but", "\u0120not", "\u0120created", ",", "\u0120since", "\u0120VM", "\u0120architecture", "\u0120does", "\u0120not", "\u0120support", "\u0120it", ".\",", "\u0120get", "V", "m", "Id", "());", "\u0120}", "\u0120increment", "V", "m", "Gener", "ation", "();", "\u0120end", "Action", "On", "Dis", "ks", "();", "\u0120set", "S", "uc", "ceed", "ed", "(", "task", "Group", "S", "uc", "ceed", "ed", "\u0120&&", "\u0120(!", "live", "Snap", "shot", "Required", "\u0120||", "\u0120live", "Snap", "shot", "S", "uc", "ceed", "ed", "));", "\u0120get", "Return", "Value", "().", "set", "End", "Action", "Try", "Again", "(", "false", ");", "\u0120}"], "docstring_tokens": ["same", "\u0120here", "\u0120(!", "arch", "Support", "Snap", "shot", ")", "\u0120?", "\u0120how", "\u0120about", "\u0120extract", "\u0120this", "\u0120check", "\u0120to", "\u0120separate", "\u0120method", "\u0120like", "\u0120'", "is", "Memory", "Snap", "shot", "Supported", "'", "\u0120that", "\u0120checks", "\u0120the", "\u0120cluster", "\u0120compatibility", "\u0120version", "\u0120and", "\u0120the", "\u0120architecture", "\u0120(", "because", "\u0120I", "\u0120see", "\u0120that", "\u0120is", "\u0120appears", "\u0120multiple", "\u0120times", "\u0120here", ")", "\u0120?"]}
{"function": "public static void main(String[] args) throws Exception { Optional.ofNullable(System.getProperty(\"logback.configurationFile\")) .stream() .forEach(file -> System.err.println(\"Load logging config from \" + file)); Configuration configuration = Configuration.builder() .useWorkingDirectoryEnvProperty() .build(); LOGGER.info(\"Loading configuration {}\", configuration); GuiceJamesServer server = createServer(configuration) .combineWith(new JMXServerModule()); JamesServerMain.main(server); }", "text": "Can't we rely on System.out here because as far as I know we are not printing an error but an expected behavior.", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120main", "(", "String", "[]", "\u0120args", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Optional", ".", "of", "Null", "able", "(", "System", ".", "get", "Property", "(\"", "log", "back", ".", "config", "uration", "File", "\"))", "\u0120.", "stream", "()", "\u0120.", "for", "Each", "(", "file", "\u0120->", "\u0120System", ".", "err", ".", "println", "(\"", "Load", "\u0120logging", "\u0120config", "\u0120from", "\u0120\"", "\u0120+", "\u0120file", "));", "\u0120Configuration", "\u0120configuration", "\u0120=", "\u0120Configuration", ".", "builder", "()", "\u0120.", "use", "Working", "Directory", "En", "v", "Property", "()", "\u0120.", "build", "();", "\u0120LOG", "GER", ".", "info", "(\"", "Loading", "\u0120configuration", "\u0120{}", "\",", "\u0120configuration", ");", "\u0120Gu", "ice", "James", "Server", "\u0120server", "\u0120=", "\u0120create", "Server", "(", "config", "uration", ")", "\u0120.", "comb", "ine", "With", "(", "new", "\u0120J", "MX", "Server", "Module", "());", "\u0120James", "Server", "Main", ".", "main", "(", "server", ");", "\u0120}"], "docstring_tokens": ["Can", "'t", "\u0120we", "\u0120rely", "\u0120on", "\u0120System", ".", "out", "\u0120here", "\u0120because", "\u0120as", "\u0120far", "\u0120as", "\u0120I", "\u0120know", "\u0120we", "\u0120are", "\u0120not", "\u0120printing", "\u0120an", "\u0120error", "\u0120but", "\u0120an", "\u0120expected", "\u0120behavior", "."]}
{"function": "public String createNewProcess() { try { createProcessHierarchy(); if (Objects.nonNull(PrimeFaces.current())) { PrimeFaces.current().executeScript(\"PF('sticky-notifications').renderMessage({'summary':'\" + Helper.getTranslation(\"processSaving\") + \"','detail':'\" + Helper.getTranslation( \"youWillBeRedirected\") + \"','severity':'info'});\"); } return processListPath; } catch (DataException e) { Helper.setErrorMessage(\"errorSaving\", new Object[] {ObjectType.PROCESS.getTranslationSingular() }, logger, e); } catch (IOException | ProcessGenerationException e) { logger.error(e.getLocalizedMessage()); } return this.stayOnCurrentPage; }", "text": "suggestion if (Objects.nonNull(PrimeFaces.current()) && Objects.nonNull(FacesContext.getCurrentInstance()) {", "function_tokens": ["public", "\u0120String", "\u0120create", "New", "Process", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120create", "Process", "H", "ier", "archy", "();", "\u0120if", "\u0120(", "Object", "s", ".", "non", "Null", "(", "Prime", "F", "aces", ".", "current", "()", "))", "\u0120{", "\u0120Prime", "F", "aces", ".", "current", "().", "execute", "Script", "(\"", "PF", "('", "stick", "y", "-", "not", "ifications", "').", "render", "Message", "({", "'", "summary", "':", "'\"", "\u0120+", "\u0120Hel", "per", ".", "get", "Translation", "(\"", "process", "S", "aving", "\")", "\u0120+", "\u0120\"", "','", "detail", "':", "'\"", "\u0120+", "\u0120Hel", "per", ".", "get", "Translation", "(", "\u0120\"", "you", "Will", "Be", "Red", "irect", "ed", "\")", "\u0120+", "\u0120\"", "','", "sever", "ity", "':", "'", "info", "'", "});", "\");", "\u0120}", "\u0120return", "\u0120process", "List", "Path", ";", "\u0120}", "\u0120catch", "\u0120(", "Data", "Exception", "\u0120e", ")", "\u0120{", "\u0120Hel", "per", ".", "set", "Error", "Message", "(\"", "error", "S", "aving", "\",", "\u0120new", "\u0120Object", "[]", "\u0120{", "Object", "Type", ".", "PR", "OC", "ESS", ".", "get", "Translation", "Sing", "ular", "()", "\u0120},", "\u0120logger", ",", "\u0120e", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120|", "\u0120Process", "Gener", "ation", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "error", "(", "e", ".", "get", "Local", "ized", "Message", "());", "\u0120}", "\u0120return", "\u0120this", ".", "stay", "On", "Current", "Page", ";", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120if", "\u0120(", "Object", "s", ".", "non", "Null", "(", "Prime", "F", "aces", ".", "current", "())", "\u0120&&", "\u0120Objects", ".", "non", "Null", "(", "F", "aces", "Context", ".", "get", "Current", "Instance", "())", "\u0120{"]}
{"function": "private static void appendLib(StringBuilder classpath, String libDirName, boolean useLibJarsFormat) { File libDir = new File(libDirName); if (!libDir.exists()) { System.err.println(\"ERROR - Directory needed for classpath does not exist: \" + libDirName); System.exit(-1); } if (useLibJarsFormat) { File[] files = libDir.listFiles(); Arrays.sort(files); for (File f : files) { if (f.isFile() && f.getName().endsWith(\".jar\")) { if (classpath.length() != 0) { classpath.append(\",\"); } classpath.append(f.getAbsolutePath()); } } } else { if (classpath.length() != 0) { classpath.append(\":\"); } classpath.append(libDir + \"/*\"); } }", "text": "Should this be libDir.getAbsolutePath() like f..getAbsolutePath() above?", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120append", "Lib", "(", "String", "Builder", "\u0120class", "path", ",", "\u0120String", "\u0120lib", "Dir", "Name", ",", "\u0120boolean", "\u0120use", "Lib", "J", "ars", "Format", ")", "\u0120{", "\u0120File", "\u0120lib", "Dir", "\u0120=", "\u0120new", "\u0120File", "(", "lib", "Dir", "Name", ");", "\u0120if", "\u0120(!", "lib", "Dir", ".", "ex", "ists", "())", "\u0120{", "\u0120System", ".", "err", ".", "println", "(\"", "ERROR", "\u0120-", "\u0120Directory", "\u0120needed", "\u0120for", "\u0120class", "path", "\u0120does", "\u0120not", "\u0120exist", ":", "\u0120\"", "\u0120+", "\u0120lib", "Dir", "Name", ");", "\u0120System", ".", "exit", "(-", "1", ");", "\u0120}", "\u0120if", "\u0120(", "use", "Lib", "J", "ars", "Format", ")", "\u0120{", "\u0120File", "[]", "\u0120files", "\u0120=", "\u0120lib", "Dir", ".", "list", "Files", "();", "\u0120Ar", "rays", ".", "sort", "(", "files", ");", "\u0120for", "\u0120(", "File", "\u0120f", "\u0120:", "\u0120files", ")", "\u0120{", "\u0120if", "\u0120(", "f", ".", "is", "File", "()", "\u0120&&", "\u0120f", ".", "get", "Name", "().", "ends", "With", "(", "\".", "jar", "\"))", "\u0120{", "\u0120if", "\u0120(", "class", "path", ".", "length", "()", "\u0120!=", "\u01200", ")", "\u0120{", "\u0120class", "path", ".", "append", "(", "\",\"", ");", "\u0120}", "\u0120class", "path", ".", "append", "(", "f", ".", "get", "Abs", "olute", "Path", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "class", "path", ".", "length", "()", "\u0120!=", "\u01200", ")", "\u0120{", "\u0120class", "path", ".", "append", "(", "\":\"", ");", "\u0120}", "\u0120class", "path", ".", "append", "(", "lib", "Dir", "\u0120+", "\u0120\"/", "*", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["Should", "\u0120this", "\u0120be", "\u0120lib", "Dir", ".", "get", "Abs", "olute", "Path", "()", "\u0120like", "\u0120f", "..", "get", "Abs", "olute", "Path", "()", "\u0120above", "?"]}
{"function": "public boolean close() { synchronized (startStopLock) { if (!started.get() || executorService.isShutdown()) { LOG.info(\"Already shutdown, ignoring\"); return false; } started.set(false); executorService.shutdownNow(); final ListenableFuture<?> future = this.future; if (future != null) { if (!future.isDone() && !future.cancel(true) && !future.isDone()) { LOG.error(\"Error cancelling future for topic [%s]\", getKafkaTopic()); return false; } } if (!cacheManager.delete(factoryId)) { LOG.error(\"Error removing [%s] for topic [%s] from cache\", factoryId, getKafkaTopic()); return false; } if (consumerConnector != null) { consumerConnector.shutdown(); } return true; } }", "text": "calling stop multiple times should return true thought", "function_tokens": ["public", "\u0120boolean", "\u0120close", "()", "\u0120{", "\u0120synchronized", "\u0120(", "start", "Stop", "Lock", ")", "\u0120{", "\u0120if", "\u0120(!", "started", ".", "get", "()", "\u0120||", "\u0120execut", "or", "Service", ".", "is", "Shut", "down", "())", "\u0120{", "\u0120LOG", ".", "info", "(\"", "Already", "\u0120shutdown", ",", "\u0120ignoring", "\");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120started", ".", "set", "(", "false", ");", "\u0120execut", "or", "Service", ".", "shut", "down", "Now", "();", "\u0120final", "\u0120Listen", "able", "Future", "<?", ">", "\u0120future", "\u0120=", "\u0120this", ".", "future", ";", "\u0120if", "\u0120(", "future", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(!", "future", ".", "is", "Done", "()", "\u0120&&", "\u0120!", "future", ".", "c", "ancel", "(", "true", ")", "\u0120&&", "\u0120!", "future", ".", "is", "Done", "())", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Error", "\u0120cance", "lling", "\u0120future", "\u0120for", "\u0120topic", "\u0120[", "%", "s", "]", "\",", "\u0120get", "K", "af", "ka", "Topic", "());", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "cache", "Manager", ".", "delete", "(", "f", "actory", "Id", "))", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Error", "\u0120removing", "\u0120[", "%", "s", "]", "\u0120for", "\u0120topic", "\u0120[", "%", "s", "]", "\u0120from", "\u0120cache", "\",", "\u0120factory", "Id", ",", "\u0120get", "K", "af", "ka", "Topic", "());", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "consumer", "Connector", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120consumer", "Connector", ".", "shut", "down", "();", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["calling", "\u0120stop", "\u0120multiple", "\u0120times", "\u0120should", "\u0120return", "\u0120true", "\u0120thought"]}
{"function": "public Metadata(Map<String, String[]> metadata) { md = metadata; }", "text": "I would check for null and make a copy of the map", "function_tokens": ["public", "\u0120Met", "adata", "(", "Map", "<", "String", ",", "\u0120String", "[]", ">", "\u0120metadata", ")", "\u0120{", "\u0120md", "\u0120=", "\u0120metadata", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120would", "\u0120check", "\u0120for", "\u0120null", "\u0120and", "\u0120make", "\u0120a", "\u0120copy", "\u0120of", "\u0120the", "\u0120map"]}
{"function": "private void evaluateXPath() { Document document = getWebSourceCode().getDocument(expression.contains(\":\")); try { NodeList nodes = (NodeList) getXPathExpressionForDocument(document).evaluate(document, XPathConstants.NODESET); for (int i = 0; i < nodes.getLength(); i++) { int lineNumber = getWebSourceCode().getLineForNode(nodes.item(i)); createViolation(lineNumber); } } catch (XPathExpressionException exceptionNodeSet) { try { Boolean result = (Boolean) getXPathExpressionForDocument(document).evaluate(document, XPathConstants.BOOLEAN); if (result) { createViolation(0); } } catch (XPathExpressionException exceptionBoolean) { throw new IllegalStateException(String.format(\"Can't evaluate expression \\\"%s\\\"\", expression), exceptionBoolean); } } }", "text": "![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>", "function_tokens": ["private", "\u0120void", "\u0120evaluate", "X", "Path", "()", "\u0120{", "\u0120Document", "\u0120document", "\u0120=", "\u0120get", "Web", "Source", "Code", "().", "get", "Document", "(", "expression", ".", "cont", "ains", "(", "\":\"", "));", "\u0120try", "\u0120{", "\u0120Node", "List", "\u0120nodes", "\u0120=", "\u0120(", "Node", "List", ")", "\u0120get", "X", "Path", "Exp", "ression", "For", "Document", "(", "document", ").", "evaluate", "(", "document", ",", "\u0120XP", "ath", "Const", "ants", ".", "N", "OD", "ES", "ET", ");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120nodes", ".", "get", "Length", "();", "\u0120i", "++)", "\u0120{", "\u0120int", "\u0120line", "Number", "\u0120=", "\u0120get", "Web", "Source", "Code", "().", "get", "Line", "For", "Node", "(", "n", "odes", ".", "item", "(", "i", "));", "\u0120create", "Viol", "ation", "(", "line", "Number", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "X", "Path", "Exp", "ression", "Exception", "\u0120exception", "Node", "Set", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Boolean", "\u0120result", "\u0120=", "\u0120(", "Boo", "lean", ")", "\u0120get", "X", "Path", "Exp", "ression", "For", "Document", "(", "document", ").", "evaluate", "(", "document", ",", "\u0120XP", "ath", "Const", "ants", ".", "B", "OO", "LE", "AN", ");", "\u0120if", "\u0120(", "result", ")", "\u0120{", "\u0120create", "Viol", "ation", "(", "0", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "X", "Path", "Exp", "ression", "Exception", "\u0120exception", "Boo", "lean", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(", "String", ".", "format", "(\"", "Can", "'t", "\u0120evaluate", "\u0120expression", "\u0120\\\"", "%", "s", "\\\"", "\",", "\u0120expression", "),", "\u0120exception", "Boo", "lean", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["!", "[", "CR", "IT", "ICAL", "](", "<", "L", "INK", "_", "1", ">", "\u0120Either", "\u0120log", "\u0120or", "\u0120re", "throw", "\u0120this", "\u0120exception", ".", "\u0120[", "!", "[", "rule", "](", "<", "L", "INK", "_", "2", ">", "](", "<", "L", "INK", "_", "0", ">"]}
{"function": "protected PageableResult doGetAll(RequestContext context) throws ResponseException { return new AlreadyPaged<AutoGenerationOption>(Context.getService(IdentifierSourceService.class).getAutoGenerationOption(3), context); }", "text": "What does the 3 parameter mean?", "function_tokens": ["protected", "\u0120Page", "able", "Result", "\u0120do", "Get", "All", "(", "Request", "Context", "\u0120context", ")", "\u0120throws", "\u0120Response", "Exception", "\u0120{", "\u0120return", "\u0120new", "\u0120Already", "P", "aged", "<", "Auto", "Gener", "ation", "Option", ">(", "Context", ".", "get", "Service", "(", "Ident", "ifier", "Source", "Service", ".", "class", ").", "get", "Auto", "Gener", "ation", "Option", "(", "3", "),", "\u0120context", ");", "\u0120}"], "docstring_tokens": ["What", "\u0120does", "\u0120the", "\u01203", "\u0120parameter", "\u0120mean", "?"]}
{"function": "protected BinaryLogicalFilterPredicate(FilterPredicate left, FilterPredicate right) { Preconditions.checkNotNull(left, \"left\"); Preconditions.checkNotNull(right, \"right\"); this.left = left; this.right = right; String name = getClass().getSimpleName().toLowerCase(); this.toString = name + \"(\" + left + \", \" + right + \")\"; }", "text": "same here:  this.left = checkNotNull(left, \"left\");", "function_tokens": ["protected", "\u0120Binary", "Log", "ical", "Filter", "Pred", "icate", "(", "Filter", "Pred", "icate", "\u0120left", ",", "\u0120Filter", "Pred", "icate", "\u0120right", ")", "\u0120{", "\u0120Pre", "cond", "itions", ".", "check", "Not", "Null", "(", "left", ",", "\u0120\"", "left", "\");", "\u0120Pre", "cond", "itions", ".", "check", "Not", "Null", "(", "right", ",", "\u0120\"", "right", "\");", "\u0120this", ".", "left", "\u0120=", "\u0120left", ";", "\u0120this", ".", "right", "\u0120=", "\u0120right", ";", "\u0120String", "\u0120name", "\u0120=", "\u0120get", "Class", "().", "get", "Simple", "Name", "().", "to", "Lower", "Case", "();", "\u0120this", ".", "to", "String", "\u0120=", "\u0120name", "\u0120+", "\u0120\"", "(\"", "\u0120+", "\u0120left", "\u0120+", "\u0120\",", "\u0120\"", "\u0120+", "\u0120right", "\u0120+", "\u0120\"", ")", "\";", "\u0120}"], "docstring_tokens": ["same", "\u0120here", ":", "\u0120", "\u0120this", ".", "left", "\u0120=", "\u0120check", "Not", "Null", "(", "left", ",", "\u0120\"", "left", "\");"]}
{"function": "public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown) { enforceConnectivityInternalPermission(); enforceCrossUserPermission(userId); if (LockdownVpnTracker.isEnabled()) { return false; } synchronized (mVpns) { Vpn vpn = mVpns.get(userId); if (vpn == null) { Slog.w(TAG, \"User \" + userId + \" has no Vpn configuration\"); return false; } if (!vpn.setAlwaysOnPackage(packageName, lockdown)) { return false; } if (!startAlwaysOnVpn(userId)) { vpn.setAlwaysOnPackage(null, false); return false; } } return true; }", "text": "Shouldn't this be inside the synchronized{} block ? Also, can't this be simplified to if (!mLockdownEnabled) ?", "function_tokens": ["public", "\u0120boolean", "\u0120set", "Always", "On", "V", "pn", "Package", "(", "int", "\u0120user", "Id", ",", "\u0120String", "\u0120package", "Name", ",", "\u0120boolean", "\u0120lockdown", ")", "\u0120{", "\u0120enforce", "Connect", "ivity", "Internal", "Per", "mission", "();", "\u0120enforce", "Cross", "User", "Per", "mission", "(", "user", "Id", ");", "\u0120if", "\u0120(", "Lock", "down", "V", "pn", "Tracker", ".", "is", "Enabled", "())", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120synchronized", "\u0120(", "m", "V", "p", "ns", ")", "\u0120{", "\u0120V", "pn", "\u0120v", "pn", "\u0120=", "\u0120m", "V", "p", "ns", ".", "get", "(", "user", "Id", ");", "\u0120if", "\u0120(", "v", "pn", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120Sl", "og", ".", "w", "(", "TAG", ",", "\u0120\"", "User", "\u0120\"", "\u0120+", "\u0120user", "Id", "\u0120+", "\u0120\"", "\u0120has", "\u0120no", "\u0120V", "pn", "\u0120configuration", "\");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(!", "v", "pn", ".", "set", "Always", "On", "Package", "(", "package", "Name", ",", "\u0120lockdown", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(!", "start", "Always", "On", "V", "pn", "(", "user", "Id", "))", "\u0120{", "\u0120v", "pn", ".", "set", "Always", "On", "Package", "(", "null", ",", "\u0120false", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120this", "\u0120be", "\u0120inside", "\u0120the", "\u0120synchronized", "{", "}", "\u0120block", "\u0120?", "\u0120Also", ",", "\u0120can", "'t", "\u0120this", "\u0120be", "\u0120simplified", "\u0120to", "\u0120if", "\u0120(!", "m", "Lock", "down", "Enabled", ")", "\u0120?"]}
{"function": "private FilterExpression parseQualifierContent(QualifierType type) { if (type == QualifierType.SORT) { return parseSortKeys(); } else if (isCompoundId(type, lookAhead())) { return parseCompoundId(); } else if (isRangeOperatorToken(lookAhead())) { return parseRangeOperator(type, lookAhead()); } else if (isDateToken(lookAhead())) { return parseDateOrDateRange(type); } else if (isNumberToken(lookAhead())) { return parseNumberOrNumberRange(type); } else if (isQuotedContentToken(lookAhead())) { Token quotedContent = consume(); return parseQuotedContent(type, quotedContent); } else if (isKeywordToken(lookAhead())) { return new Qualifier(type, consume().getValue()); } else { throw new ParseException(String.format(\"Invalid content for qualifier %s: %s\", type, lookAhead())); } }", "text": "Checking for failure here leads to a non-id qualifier being used with a compound id being a parse error. Could we follow the other parse* functions and let it fail later, as a semantic error? If for some reason we want to use compound ids with other qualifiers, it would be easier.", "function_tokens": ["private", "\u0120Filter", "Exp", "ression", "\u0120parse", "Qual", "ifier", "Content", "(", "Qual", "ifier", "Type", "\u0120type", ")", "\u0120{", "\u0120if", "\u0120(", "type", "\u0120==", "\u0120Qual", "ifier", "Type", ".", "S", "ORT", ")", "\u0120{", "\u0120return", "\u0120parse", "Sort", "Keys", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Comp", "ound", "Id", "(", "type", ",", "\u0120look", "A", "head", "()", "))", "\u0120{", "\u0120return", "\u0120parse", "Comp", "ound", "Id", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Range", "Oper", "ator", "Token", "(", "look", "A", "head", "()", "))", "\u0120{", "\u0120return", "\u0120parse", "Range", "Oper", "ator", "(", "type", ",", "\u0120look", "A", "head", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Date", "Token", "(", "look", "A", "head", "()", "))", "\u0120{", "\u0120return", "\u0120parse", "Date", "Or", "Date", "Range", "(", "type", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Number", "Token", "(", "look", "A", "head", "()", "))", "\u0120{", "\u0120return", "\u0120parse", "Number", "Or", "Number", "Range", "(", "type", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Qu", "oted", "Content", "Token", "(", "look", "A", "head", "()", "))", "\u0120{", "\u0120Token", "\u0120quoted", "Content", "\u0120=", "\u0120consume", "();", "\u0120return", "\u0120parse", "Qu", "oted", "Content", "(", "type", ",", "\u0120quoted", "Content", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "is", "Key", "word", "Token", "(", "look", "A", "head", "()", "))", "\u0120{", "\u0120return", "\u0120new", "\u0120Qual", "ifier", "(", "type", ",", "\u0120consume", "().", "get", "Value", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Par", "se", "Exception", "(", "String", ".", "format", "(\"", "Invalid", "\u0120content", "\u0120for", "\u0120qualifier", "\u0120%", "s", ":", "\u0120%", "s", "\",", "\u0120type", ",", "\u0120look", "A", "head", "()", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["Check", "ing", "\u0120for", "\u0120failure", "\u0120here", "\u0120leads", "\u0120to", "\u0120a", "\u0120non", "-", "id", "\u0120qualifier", "\u0120being", "\u0120used", "\u0120with", "\u0120a", "\u0120compound", "\u0120id", "\u0120being", "\u0120a", "\u0120parse", "\u0120error", ".", "\u0120Could", "\u0120we", "\u0120follow", "\u0120the", "\u0120other", "\u0120parse", "*", "\u0120functions", "\u0120and", "\u0120let", "\u0120it", "\u0120fail", "\u0120later", ",", "\u0120as", "\u0120a", "\u0120semantic", "\u0120error", "?", "\u0120If", "\u0120for", "\u0120some", "\u0120reason", "\u0120we", "\u0120want", "\u0120to", "\u0120use", "\u0120compound", "\u0120", "ids", "\u0120with", "\u0120other", "\u0120qualifiers", ",", "\u0120it", "\u0120would", "\u0120be", "\u0120easier", "."]}
{"function": "protected Optional<DominantHandProperty> getForEntity(Entity entity) { if(!(entity instanceof EntityPlayer)) return Optional.empty(); EnumHandSide hand = ((EntityPlayer) entity).getPrimaryHand(); HandType type = (HandType) (Object) hand; return Optional.of(new DominantHandProperty(type)); }", "text": "if (, and if statements require braces.", "function_tokens": ["protected", "\u0120Optional", "<", "Domin", "ant", "Hand", "Property", ">", "\u0120get", "For", "Entity", "(", "Entity", "\u0120entity", ")", "\u0120{", "\u0120if", "(", "!", "(", "entity", "\u0120instance", "of", "\u0120Entity", "Player", "))", "\u0120return", "\u0120Optional", ".", "empty", "();", "\u0120En", "um", "Hand", "Side", "\u0120hand", "\u0120=", "\u0120((", "Entity", "Player", ")", "\u0120entity", ").", "get", "Primary", "Hand", "();", "\u0120Hand", "Type", "\u0120type", "\u0120=", "\u0120(", "Hand", "Type", ")", "\u0120(", "Object", ")", "\u0120hand", ";", "\u0120return", "\u0120Optional", ".", "of", "(", "new", "\u0120Domin", "ant", "Hand", "Property", "(", "type", "));", "\u0120}"], "docstring_tokens": ["if", "\u0120(", ",", "\u0120and", "\u0120if", "\u0120statements", "\u0120require", "\u0120braces", "."]}
{"function": "private boolean isUnregisteredDisk() { DiskImage unregisteredDisk; storagePoolId = BackendDataCenterHelper.lookupByStorageDomainId(this, storageDomainId); try { GetUnregisteredDiskQueryParameters getDiskParams = new GetUnregisteredDiskQueryParameters(guid, storageDomainId, storagePoolId); unregisteredDisk = getEntity(DiskImage.class, QueryType.GetUnregisteredDisk, getDiskParams, guid.toString()); } catch (WebApplicationException e) { if (e.getResponse().getStatus() == Response.Status.NOT_FOUND.getStatusCode()) { return false; } throw e; } return unregisteredDisk != null; }", "text": "BTW: if \"getEntity()\" either returns the result or throws a WebApplicationException exception with \"NOT_FOUND\" status, the code can be simplified to always \"return true\" at the end and no need in \"unregisteredDisk\" local variable at all.", "function_tokens": ["private", "\u0120boolean", "\u0120is", "Un", "registered", "Disk", "()", "\u0120{", "\u0120Disk", "Image", "\u0120un", "registered", "Disk", ";", "\u0120storage", "Pool", "Id", "\u0120=", "\u0120Back", "end", "Data", "Center", "Helper", ".", "look", "up", "By", "Storage", "Domain", "Id", "(", "this", ",", "\u0120storage", "Domain", "Id", ");", "\u0120try", "\u0120{", "\u0120Get", "Un", "registered", "Disk", "Query", "Parameters", "\u0120get", "Disk", "Par", "ams", "\u0120=", "\u0120new", "\u0120Get", "Un", "registered", "Disk", "Query", "Parameters", "(", "gu", "id", ",", "\u0120storage", "Domain", "Id", ",", "\u0120storage", "Pool", "Id", ");", "\u0120un", "registered", "Disk", "\u0120=", "\u0120get", "Entity", "(", "Disk", "Image", ".", "class", ",", "\u0120Query", "Type", ".", "Get", "Un", "registered", "Disk", ",", "\u0120get", "Disk", "Par", "ams", ",", "\u0120guid", ".", "to", "String", "());", "\u0120}", "\u0120catch", "\u0120(", "Web", "Application", "Exception", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(", "e", ".", "get", "Response", "().", "get", "Status", "()", "\u0120==", "\u0120Response", ".", "Status", ".", "NOT", "_", "F", "OUND", ".", "get", "Status", "Code", "())", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120throw", "\u0120e", ";", "\u0120}", "\u0120return", "\u0120un", "registered", "Disk", "\u0120!=", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["BT", "W", ":", "\u0120if", "\u0120\"", "get", "Entity", "()", "\"", "\u0120either", "\u0120returns", "\u0120the", "\u0120result", "\u0120or", "\u0120throws", "\u0120a", "\u0120Web", "Application", "Exception", "\u0120exception", "\u0120with", "\u0120\"", "NOT", "_", "F", "OUND", "\"", "\u0120status", ",", "\u0120the", "\u0120code", "\u0120can", "\u0120be", "\u0120simplified", "\u0120to", "\u0120always", "\u0120\"", "return", "\u0120true", "\"", "\u0120at", "\u0120the", "\u0120end", "\u0120and", "\u0120no", "\u0120need", "\u0120in", "\u0120\"", "un", "registered", "Disk", "\"", "\u0120local", "\u0120variable", "\u0120at", "\u0120all", "."]}
{"function": "public long getFileSize(String ext) { Long size = sizeMap.get(ext); return (size == null) ? 0 : size.longValue(); }", "text": "No parens on condition.", "function_tokens": ["public", "\u0120long", "\u0120get", "File", "Size", "(", "String", "\u0120ext", ")", "\u0120{", "\u0120Long", "\u0120size", "\u0120=", "\u0120size", "Map", ".", "get", "(", "ext", ");", "\u0120return", "\u0120(", "size", "\u0120==", "\u0120null", ")", "\u0120?", "\u01200", "\u0120:", "\u0120size", ".", "long", "Value", "();", "\u0120}"], "docstring_tokens": ["No", "\u0120p", "aren", "s", "\u0120on", "\u0120condition", "."]}
{"function": "public boolean tryAdvance(Consumer<? super BytesHandle> action) { try { FormatEntry nextEntry = getNextEntry(); if (nextEntry == null) { return false; } BytesHandle nextBytesHandle = readEntry(nextEntry); action.accept(nextBytesHandle); splitter.count++; } catch (IOException e) { e.printStackTrace(); } return true; }", "text": "The IDEs tend to generate boilerplate code that suppresses exceptions. Unless we know it is safe to suppress an exception, the best practice is to throw the exception. In this case, if we encounter an IOException, something must be wrong with the zipfile. Where the exception is a checked exception (like IOException) that's not allowed by the signature (as with the tryAdvance() method), we can rethrow it with something like throw new RuntimeException(\"Could not read ZipEntry\", e); To be clear, the same issue affects the other tryAdvance() method.", "function_tokens": ["public", "\u0120boolean", "\u0120try", "Ad", "vance", "(", "Consumer", "<?", "\u0120super", "\u0120By", "tes", "Handle", ">", "\u0120action", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Format", "Entry", "\u0120next", "Entry", "\u0120=", "\u0120get", "Next", "Entry", "();", "\u0120if", "\u0120(", "next", "Entry", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120By", "tes", "Handle", "\u0120next", "Bytes", "Handle", "\u0120=", "\u0120read", "Entry", "(", "next", "Entry", ");", "\u0120action", ".", "accept", "(", "next", "Bytes", "Handle", ");", "\u0120spl", "itter", ".", "count", "++;", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120ID", "Es", "\u0120tend", "\u0120to", "\u0120generate", "\u0120boiler", "plate", "\u0120code", "\u0120that", "\u0120supp", "resses", "\u0120exceptions", ".", "\u0120Unless", "\u0120we", "\u0120know", "\u0120it", "\u0120is", "\u0120safe", "\u0120to", "\u0120suppress", "\u0120an", "\u0120exception", ",", "\u0120the", "\u0120best", "\u0120practice", "\u0120is", "\u0120to", "\u0120throw", "\u0120the", "\u0120exception", ".", "\u0120In", "\u0120this", "\u0120case", ",", "\u0120if", "\u0120we", "\u0120encounter", "\u0120an", "\u0120IO", "Exception", ",", "\u0120something", "\u0120must", "\u0120be", "\u0120wrong", "\u0120with", "\u0120the", "\u0120zip", "file", ".", "\u0120Where", "\u0120the", "\u0120exception", "\u0120is", "\u0120a", "\u0120checked", "\u0120exception", "\u0120(", "like", "\u0120IO", "Exception", ")", "\u0120that", "'s", "\u0120not", "\u0120allowed", "\u0120by", "\u0120the", "\u0120signature", "\u0120(", "as", "\u0120with", "\u0120the", "\u0120try", "Ad", "vance", "()", "\u0120method", "),", "\u0120we", "\u0120can", "\u0120re", "throw", "\u0120it", "\u0120with", "\u0120something", "\u0120like", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Could", "\u0120not", "\u0120read", "\u0120Zip", "Entry", "\",", "\u0120e", ");", "\u0120To", "\u0120be", "\u0120clear", ",", "\u0120the", "\u0120same", "\u0120issue", "\u0120affects", "\u0120the", "\u0120other", "\u0120try", "Ad", "vance", "()", "\u0120method", "."]}
{"function": "public static ViewGroup.OnHierarchyChangeListener tryGetOnHierarchyChangeListenerHack( ViewGroup viewGroup) { if (sOnHierarchyChangeListenerField == null) { return null; } try { return (ViewGroup.OnHierarchyChangeListener)sOnHierarchyChangeListenerField.get(viewGroup); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }", "text": "This too, possibly", "function_tokens": ["public", "\u0120static", "\u0120View", "Group", ".", "On", "H", "ier", "archy", "Change", "Listener", "\u0120try", "Get", "On", "H", "ier", "archy", "Change", "Listener", "Hack", "(", "\u0120View", "Group", "\u0120view", "Group", ")", "\u0120{", "\u0120if", "\u0120(", "s", "On", "H", "ier", "archy", "Change", "Listener", "Field", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120return", "\u0120(", "View", "Group", ".", "On", "H", "ier", "archy", "Change", "Listener", ")", "s", "On", "H", "ier", "archy", "Change", "Listener", "Field", ".", "get", "(", "view", "Group", ");", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "Access", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120too", ",", "\u0120possibly"]}
{"function": "private HullConfig read(String shipName) { final HullConfig.Data configData = new HullConfig.Data(); configData.internalName = shipName; Json json = Assets.getJson(shipName); try { readProperties(json.getJsonValue(), configData); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(\"The JSON of ship \" + shipName + \" is missing, or has malformed, a required parameter\" + e.getMessage().split(\":\")[1]); } catch (SerializationException e) { throw new SerializationException(\"The JSON of ship \" + shipName + \" has invalid syntax\" + e.getMessage().split(\":\")[1]); } configData.tex = Assets.getAtlasRegion(shipName); configData.icon = Assets.getAtlasRegion(shipName + \"Icon\"); validateEngineConfig(configData); json.dispose(); return new HullConfig(configData); }", "text": "Take a look at what the error message you're splitting is :wink: (hint: it's the entire JSON file)", "function_tokens": ["private", "\u0120Hull", "Config", "\u0120read", "(", "String", "\u0120ship", "Name", ")", "\u0120{", "\u0120final", "\u0120Hull", "Config", ".", "Data", "\u0120config", "Data", "\u0120=", "\u0120new", "\u0120Hull", "Config", ".", "Data", "();", "\u0120config", "Data", ".", "internal", "Name", "\u0120=", "\u0120ship", "Name", ";", "\u0120J", "son", "\u0120json", "\u0120=", "\u0120Assets", ".", "get", "J", "son", "(", "ship", "Name", ");", "\u0120try", "\u0120{", "\u0120read", "Pro", "perties", "(", "json", ".", "get", "J", "son", "Value", "(),", "\u0120config", "Data", ");", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "Arg", "ument", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "The", "\u0120JSON", "\u0120of", "\u0120ship", "\u0120\"", "\u0120+", "\u0120ship", "Name", "\u0120+", "\u0120\"", "\u0120is", "\u0120missing", ",", "\u0120or", "\u0120has", "\u0120mal", "formed", ",", "\u0120a", "\u0120required", "\u0120parameter", "\"", "\u0120+", "\u0120e", ".", "get", "Message", "().", "split", "(", "\":\"", ")[", "1", "]);", "\u0120}", "\u0120catch", "\u0120(", "Serial", "ization", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Serial", "ization", "Exception", "(\"", "The", "\u0120JSON", "\u0120of", "\u0120ship", "\u0120\"", "\u0120+", "\u0120ship", "Name", "\u0120+", "\u0120\"", "\u0120has", "\u0120invalid", "\u0120syntax", "\"", "\u0120+", "\u0120e", ".", "get", "Message", "().", "split", "(", "\":\"", ")[", "1", "]);", "\u0120}", "\u0120config", "Data", ".", "tex", "\u0120=", "\u0120Assets", ".", "get", "At", "las", "Region", "(", "ship", "Name", ");", "\u0120config", "Data", ".", "icon", "\u0120=", "\u0120Assets", ".", "get", "At", "las", "Region", "(", "ship", "Name", "\u0120+", "\u0120\"", "Icon", "\");", "\u0120validate", "Engine", "Config", "(", "config", "Data", ");", "\u0120json", ".", "dis", "pose", "();", "\u0120return", "\u0120new", "\u0120Hull", "Config", "(", "config", "Data", ");", "\u0120}"], "docstring_tokens": ["Take", "\u0120a", "\u0120look", "\u0120at", "\u0120what", "\u0120the", "\u0120error", "\u0120message", "\u0120you", "'re", "\u0120splitting", "\u0120is", "\u0120:", "w", "ink", ":", "\u0120(", "h", "int", ":", "\u0120it", "'s", "\u0120the", "\u0120entire", "\u0120JSON", "\u0120file", ")"]}
{"function": "public ImmutableValue<Entity> leashHolder() { return new ImmutableSpongeEntityValue<>(Keys.LEASH_HOLDER, getValue()); }", "text": "This should be stored in a field.", "function_tokens": ["public", "\u0120Imm", "utable", "Value", "<", "Entity", ">", "\u0120leash", "H", "older", "()", "\u0120{", "\u0120return", "\u0120new", "\u0120Imm", "utable", "Sp", "onge", "Entity", "Value", "<", ">(", "Keys", ".", "LE", "ASH", "_", "H", "OL", "DER", ",", "\u0120get", "Value", "());", "\u0120}"], "docstring_tokens": ["This", "\u0120should", "\u0120be", "\u0120stored", "\u0120in", "\u0120a", "\u0120field", "."]}
{"function": "public int onStartCommand(@Nullable Intent intent, int flags, int startId) { if (intent != null) { if (intent.getAction() != null) { restoreQueuesAndPositionIfNecessary(); String action = intent.getAction(); switch (action) { case ACTION_TOGGLE_PAUSE: if (isPlaying()) { pause(); } else { play(); } break; case ACTION_PAUSE: pause(); break; case ACTION_PLAY: play(); break; case ACTION_PLAY_PLAYLIST: Playlist playlist = intent.getParcelableExtra(INTENT_EXTRA_PLAYLIST); int shuffleMode = intent.getIntExtra(INTENT_EXTRA_SHUFFLE_MODE, getShuffleMode()); if (playlist != null) { List<Song> playlistSongs; if (playlist instanceof AbsCustomPlaylist) { playlistSongs = ((AbsCustomPlaylist) playlist).getSongs(getApplicationContext()); } else { playlistSongs = (List<Song>) (List) PlaylistSongLoader.getPlaylistSongList(getApplicationContext(), playlist.id); } if (!playlistSongs.isEmpty()) { if (shuffleMode == SHUFFLE_MODE_SHUFFLE) { int startPosition = 0; if (!playlistSongs.isEmpty()) { startPosition = new Random().nextInt(playlistSongs.size()); } openQueue(playlistSongs, startPosition, true); setShuffleMode(shuffleMode); } else { openQueue(playlistSongs, 0, true); } } else { Toast.makeText(getApplicationContext(), R.string.playlist_is_empty, Toast.LENGTH_LONG).show(); } } else { Toast.makeText(getApplicationContext(), R.string.playlist_is_empty, Toast.LENGTH_LONG).show(); } break; case ACTION_REWIND: back(true); break; case ACTION_SKIP: playNextSong(true); break; case ACTION_STOP: case ACTION_QUIT: pendingQuit = false; quit(); break; case ACTION_PENDING_QUIT: pendingQuit = true; break; } } } return START_NOT_STICKY; }", "text": "This seems redundant.", "function_tokens": ["public", "\u0120int", "\u0120on", "Start", "Command", "(", "@", "Null", "able", "\u0120Intent", "\u0120intent", ",", "\u0120int", "\u0120flags", ",", "\u0120int", "\u0120start", "Id", ")", "\u0120{", "\u0120if", "\u0120(", "intent", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "intent", ".", "get", "Action", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120restore", "Que", "ues", "And", "Position", "If", "N", "ec", "ess", "ary", "();", "\u0120String", "\u0120action", "\u0120=", "\u0120intent", ".", "get", "Action", "();", "\u0120switch", "\u0120(", "action", ")", "\u0120{", "\u0120case", "\u0120ACTION", "_", "T", "OG", "G", "LE", "_", "PA", "USE", ":", "\u0120if", "\u0120(", "is", "Playing", "())", "\u0120{", "\u0120pause", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120play", "();", "\u0120}", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "PA", "USE", ":", "\u0120pause", "();", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "PLAY", ":", "\u0120play", "();", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "PLAY", "_", "PLAY", "LIST", ":", "\u0120Play", "list", "\u0120playlist", "\u0120=", "\u0120intent", ".", "get", "Par", "cel", "able", "Extra", "(", "INT", "ENT", "_", "EXT", "RA", "_", "PLAY", "LIST", ");", "\u0120int", "\u0120shuffle", "Mode", "\u0120=", "\u0120intent", ".", "get", "Int", "Extra", "(", "INT", "ENT", "_", "EXT", "RA", "_", "SH", "UFF", "LE", "_", "MODE", ",", "\u0120get", "Sh", "uffle", "Mode", "());", "\u0120if", "\u0120(", "play", "list", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120List", "<", "Song", ">", "\u0120playlist", "S", "ongs", ";", "\u0120if", "\u0120(", "play", "list", "\u0120instance", "of", "\u0120Abs", "Custom", "Play", "list", ")", "\u0120{", "\u0120playlist", "S", "ongs", "\u0120=", "\u0120((", "Abs", "Custom", "Play", "list", ")", "\u0120playlist", ").", "get", "S", "ongs", "(", "get", "Application", "Context", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120playlist", "S", "ongs", "\u0120=", "\u0120(", "List", "<", "Song", ">)", "\u0120(", "List", ")", "\u0120Play", "list", "Song", "Loader", ".", "get", "Play", "list", "Song", "List", "(", "get", "Application", "Context", "(),", "\u0120playlist", ".", "id", ");", "\u0120}", "\u0120if", "\u0120(!", "play", "list", "S", "ongs", ".", "is", "Empty", "())", "\u0120{", "\u0120if", "\u0120(", "sh", "uffle", "Mode", "\u0120==", "\u0120SH", "UFF", "LE", "_", "MODE", "_", "SH", "UFF", "LE", ")", "\u0120{", "\u0120int", "\u0120start", "Position", "\u0120=", "\u01200", ";", "\u0120if", "\u0120(!", "play", "list", "S", "ongs", ".", "is", "Empty", "())", "\u0120{", "\u0120start", "Position", "\u0120=", "\u0120new", "\u0120Random", "().", "next", "Int", "(", "play", "list", "S", "ongs", ".", "size", "());", "\u0120}", "\u0120open", "Queue", "(", "play", "list", "S", "ongs", ",", "\u0120start", "Position", ",", "\u0120true", ");", "\u0120set", "Sh", "uffle", "Mode", "(", "sh", "uffle", "Mode", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120open", "Queue", "(", "play", "list", "S", "ongs", ",", "\u01200", ",", "\u0120true", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "get", "Application", "Context", "(),", "\u0120R", ".", "string", ".", "play", "list", "_", "is", "_", "empty", ",", "\u0120Toast", ".", "L", "ENGTH", "_", "L", "ONG", ").", "show", "();", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "get", "Application", "Context", "(),", "\u0120R", ".", "string", ".", "play", "list", "_", "is", "_", "empty", ",", "\u0120Toast", ".", "L", "ENGTH", "_", "L", "ONG", ").", "show", "();", "\u0120}", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "RE", "WIND", ":", "\u0120back", "(", "true", ");", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "SK", "IP", ":", "\u0120play", "Next", "Song", "(", "true", ");", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "ST", "OP", ":", "\u0120case", "\u0120ACTION", "_", "QU", "IT", ":", "\u0120pending", "Qu", "it", "\u0120=", "\u0120false", ";", "\u0120quit", "();", "\u0120break", ";", "\u0120case", "\u0120ACTION", "_", "P", "END", "ING", "_", "QU", "IT", ":", "\u0120pending", "Qu", "it", "\u0120=", "\u0120true", ";", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120START", "_", "NOT", "_", "ST", "ICK", "Y", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120seems", "\u0120redundant", "."]}
{"function": "public void configurePipeline(PipelineConfigurer configurer) throws IllegalArgumentException { super.configurePipeline(configurer); if (this.config.format == null || this.config.format.isEmpty()) { throw new IllegalArgumentException(\"Format is not specified. Allowed values are DEFAULT, EXCEL, MYSQL,\" + \" RFC4180, PDL & TDF\"); } if (!this.config.format.equalsIgnoreCase(\"DEFAULT\") && !this.config.format.equalsIgnoreCase(\"EXCEL\") && !this.config.format.equalsIgnoreCase(\"MYSQL\") && !this.config.format.equalsIgnoreCase(\"RFC4180\") && !this.config.format.equalsIgnoreCase(\"TDF\") && !this.config.format.equalsIgnoreCase(\"PDL\")) { throw new IllegalArgumentException(\"Format specified is not one of the allowed values. Allowed values are \" + \"DEFAULT, EXCEL, MYSQL, RFC4180, PDL & TDF\"); } if (configurer.getStageConfigurer().getInputSchema() != null) { Schema.Field inputSchemaField = configurer.getStageConfigurer().getInputSchema().getField(config.field); if (inputSchemaField == null) { throw new IllegalArgumentException( \"Field \" + config.field + \" is not present in the input schema, it is expected\"); } else { if (!inputSchemaField.getSchema().getType().equals(Schema.Type.STRING)) { throw new IllegalArgumentException( \"Field Type \" + config.field + \" should be String\"); } } } try { Schema outputSchema = Schema.parseJson(this.config.schema); configurer.getStageConfigurer().setOutputSchema(outputSchema); } catch (IOException e) { throw new IllegalArgumentException(\"Format of schema specified is invalid. Please check the format.\"); } }", "text": "Type for Field + config.field + must be String", "function_tokens": ["public", "\u0120void", "\u0120configure", "P", "ip", "eline", "(", "P", "ip", "eline", "Config", "urer", "\u0120config", "urer", ")", "\u0120throws", "\u0120Illegal", "Arg", "ument", "Exception", "\u0120{", "\u0120super", ".", "config", "ure", "P", "ip", "eline", "(", "config", "urer", ");", "\u0120if", "\u0120(", "this", ".", "config", ".", "format", "\u0120==", "\u0120null", "\u0120||", "\u0120this", ".", "config", ".", "format", ".", "is", "Empty", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Format", "\u0120is", "\u0120not", "\u0120specified", ".", "\u0120All", "owed", "\u0120values", "\u0120are", "\u0120DE", "FAULT", ",", "\u0120EX", "C", "EL", ",", "\u0120M", "YS", "QL", ",\"", "\u0120+", "\u0120\"", "\u0120RFC", "4", "180", ",", "\u0120PD", "L", "\u0120&", "\u0120T", "DF", "\");", "\u0120}", "\u0120if", "\u0120(!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "DE", "FAULT", "\")", "\u0120&&", "\u0120!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "EX", "C", "EL", "\")", "\u0120&&", "\u0120!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "M", "YS", "QL", "\")", "\u0120&&", "\u0120!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "RFC", "4", "180", "\")", "\u0120&&", "\u0120!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "T", "DF", "\")", "\u0120&&", "\u0120!", "this", ".", "config", ".", "format", ".", "equ", "als", "Ign", "ore", "Case", "(\"", "PD", "L", "\"))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Format", "\u0120specified", "\u0120is", "\u0120not", "\u0120one", "\u0120of", "\u0120the", "\u0120allowed", "\u0120values", ".", "\u0120All", "owed", "\u0120values", "\u0120are", "\u0120\"", "\u0120+", "\u0120\"", "DE", "FAULT", ",", "\u0120EX", "C", "EL", ",", "\u0120M", "YS", "QL", ",", "\u0120RFC", "4", "180", ",", "\u0120PD", "L", "\u0120&", "\u0120T", "DF", "\");", "\u0120}", "\u0120if", "\u0120(", "config", "urer", ".", "get", "Stage", "Config", "urer", "().", "get", "Input", "Sche", "ma", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Sche", "ma", ".", "Field", "\u0120input", "Sche", "ma", "Field", "\u0120=", "\u0120config", "urer", ".", "get", "Stage", "Config", "urer", "().", "get", "Input", "Sche", "ma", "().", "get", "Field", "(", "config", ".", "field", ");", "\u0120if", "\u0120(", "input", "Sche", "ma", "Field", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "Field", "\u0120\"", "\u0120+", "\u0120config", ".", "field", "\u0120+", "\u0120\"", "\u0120is", "\u0120not", "\u0120present", "\u0120in", "\u0120the", "\u0120input", "\u0120schema", ",", "\u0120it", "\u0120is", "\u0120expected", "\");", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(!", "input", "Sche", "ma", "Field", ".", "get", "Sche", "ma", "().", "get", "Type", "().", "equ", "als", "(", "Sche", "ma", ".", "Type", ".", "STR", "ING", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "Field", "\u0120Type", "\u0120\"", "\u0120+", "\u0120config", ".", "field", "\u0120+", "\u0120\"", "\u0120should", "\u0120be", "\u0120String", "\");", "\u0120}", "\u0120}", "\u0120}", "\u0120try", "\u0120{", "\u0120Sche", "ma", "\u0120output", "Sche", "ma", "\u0120=", "\u0120Sche", "ma", ".", "parse", "J", "son", "(", "this", ".", "config", ".", "sche", "ma", ");", "\u0120config", "urer", ".", "get", "Stage", "Config", "urer", "().", "set", "Output", "Sche", "ma", "(", "output", "Sche", "ma", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Format", "\u0120of", "\u0120schema", "\u0120specified", "\u0120is", "\u0120invalid", ".", "\u0120Please", "\u0120check", "\u0120the", "\u0120format", ".\"", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Type", "\u0120for", "\u0120Field", "\u0120+", "\u0120config", ".", "field", "\u0120+", "\u0120must", "\u0120be", "\u0120String"]}
{"function": "private void applyProperties(AssociationKey associationKey, RowKey rowKey, Relationship relationship) { String[] rowKeyIndexColumnNames = associationKey.getRowKeyIndexColumnNames(); for ( int i = 0; i < rowKeyIndexColumnNames.length; i++ ) { for ( int j = 0; j < rowKey.getColumnNames().length; j++ ) { if ( rowKeyIndexColumnNames[i].equals( rowKey.getColumnNames()[j] ) ) { relationship.setProperty( rowKeyIndexColumnNames[i], rowKey.getColumnValues()[j] ); break; } } } }", "text": "Should there be RowKey#getColumnValue(String name)? This would make this code here a bit easier to grasp.", "function_tokens": ["private", "\u0120void", "\u0120apply", "Pro", "perties", "(", "Ass", "ociation", "Key", "\u0120association", "Key", ",", "\u0120Row", "Key", "\u0120row", "Key", ",", "\u0120Relationship", "\u0120relationship", ")", "\u0120{", "\u0120String", "[]", "\u0120row", "Key", "Index", "Column", "Names", "\u0120=", "\u0120association", "Key", ".", "get", "Row", "Key", "Index", "Column", "Names", "();", "\u0120for", "\u0120(", "\u0120int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120row", "Key", "Index", "Column", "Names", ".", "length", ";", "\u0120i", "++", "\u0120)", "\u0120{", "\u0120for", "\u0120(", "\u0120int", "\u0120j", "\u0120=", "\u01200", ";", "\u0120j", "\u0120<", "\u0120row", "Key", ".", "get", "Column", "Names", "().", "length", ";", "\u0120j", "++", "\u0120)", "\u0120{", "\u0120if", "\u0120(", "\u0120row", "Key", "Index", "Column", "Names", "[", "i", "].", "equ", "als", "(", "\u0120row", "Key", ".", "get", "Column", "Names", "()", "[", "j", "]", "\u0120)", "\u0120)", "\u0120{", "\u0120relationship", ".", "set", "Property", "(", "\u0120row", "Key", "Index", "Column", "Names", "[", "i", "],", "\u0120row", "Key", ".", "get", "Column", "Values", "()", "[", "j", "]", "\u0120);", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Should", "\u0120there", "\u0120be", "\u0120Row", "Key", "#", "get", "Column", "Value", "(", "String", "\u0120name", ")?", "\u0120This", "\u0120would", "\u0120make", "\u0120this", "\u0120code", "\u0120here", "\u0120a", "\u0120bit", "\u0120easier", "\u0120to", "\u0120grasp", "."]}
{"function": "private Diagnostic handleMigrationOptions() { Diagnostic migrationMismatchDiagnostic = null; VSMVersionSAXParser parser = new VSMVersionSAXParser(uri); String loadedVersion = parser.getVersion(new NullProgressMonitor()); boolean migrationIsNeeded = true; if (loadedVersion != null) { Version parsedLoadedVersion = Version.parseVersion(loadedVersion); Version lastMigrationVersion = VSMMigrationService.getInstance().getLastMigrationVersion(); boolean attemptToLoadMoreRecentVSM = lastMigrationVersion.compareTo(parsedLoadedVersion) < 0; if (attemptToLoadMoreRecentVSM) { migrationMismatchDiagnostic = new XMIException(MessageFormat.format(Messages.DescriptionResourceImpl_versionMismatchMessage, uri, parsedLoadedVersion, lastMigrationVersion)); } migrationIsNeeded = VSMMigrationService.getInstance().isMigrationNeeded(parsedLoadedVersion); } Object versionOption = this.getDefaultLoadOptions().get(AbstractSiriusMigrationService.OPTION_RESOURCE_MIGRATION_LOADEDVERSION); if (!migrationIsNeeded && versionOption != null) { removeMigrationMechanism(); } else if (migrationIsNeeded && (versionOption == null || !versionOption.equals(loadedVersion))) { DescriptionResourceImpl.addMigrationOptions(loadedVersion, this.getDefaultLoadOptions(), this.getDefaultSaveOptions()); } return migrationMismatchDiagnostic; }", "text": "Strange to use an XMIException here, which would imply something is corrupted at the XMI level, which is not the case. Especially since there is a AirdResourceVersionMismatchException defined in the same patch which implements Resource.Diagnostic.", "function_tokens": ["private", "\u0120Diagn", "ostic", "\u0120handle", "M", "igration", "Options", "()", "\u0120{", "\u0120Diagn", "ostic", "\u0120migration", "M", "ism", "atch", "Di", "agn", "ostic", "\u0120=", "\u0120null", ";", "\u0120V", "SM", "Version", "SA", "XP", "arser", "\u0120parser", "\u0120=", "\u0120new", "\u0120V", "SM", "Version", "SA", "XP", "arser", "(", "uri", ");", "\u0120String", "\u0120loaded", "Version", "\u0120=", "\u0120parser", ".", "get", "Version", "(", "new", "\u0120Null", "Progress", "Monitor", "());", "\u0120boolean", "\u0120migration", "Is", "Need", "ed", "\u0120=", "\u0120true", ";", "\u0120if", "\u0120(", "loaded", "Version", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Version", "\u0120parsed", "Load", "ed", "Version", "\u0120=", "\u0120Version", ".", "parse", "Version", "(", "loaded", "Version", ");", "\u0120Version", "\u0120last", "M", "igration", "Version", "\u0120=", "\u0120VS", "MM", "igration", "Service", ".", "get", "Instance", "().", "get", "Last", "M", "igration", "Version", "();", "\u0120boolean", "\u0120attempt", "To", "Load", "More", "Recent", "V", "SM", "\u0120=", "\u0120last", "M", "igration", "Version", ".", "comp", "are", "To", "(", "p", "ars", "ed", "Load", "ed", "Version", ")", "\u0120<", "\u01200", ";", "\u0120if", "\u0120(", "att", "empt", "To", "Load", "More", "Recent", "V", "SM", ")", "\u0120{", "\u0120migration", "M", "ism", "atch", "Di", "agn", "ostic", "\u0120=", "\u0120new", "\u0120X", "MI", "Exception", "(", "Message", "Format", ".", "format", "(", "Mess", "ages", ".", "Description", "Resource", "Impl", "_", "version", "M", "ism", "atch", "Message", ",", "\u0120ur", "i", ",", "\u0120parsed", "Load", "ed", "Version", ",", "\u0120last", "M", "igration", "Version", "));", "\u0120}", "\u0120migration", "Is", "Need", "ed", "\u0120=", "\u0120VS", "MM", "igration", "Service", ".", "get", "Instance", "().", "is", "M", "igration", "Need", "ed", "(", "p", "ars", "ed", "Load", "ed", "Version", ");", "\u0120}", "\u0120Object", "\u0120version", "Option", "\u0120=", "\u0120this", ".", "get", "Default", "Load", "Options", "().", "get", "(", "Abstract", "Sir", "ius", "M", "igration", "Service", ".", "OP", "TION", "_", "RES", "OURCE", "_", "M", "IG", "R", "ATION", "_", "LOAD", "ED", "VERSION", ");", "\u0120if", "\u0120(!", "m", "igration", "Is", "Need", "ed", "\u0120&&", "\u0120version", "Option", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120remove", "M", "igration", "Mech", "anism", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "m", "igration", "Is", "Need", "ed", "\u0120&&", "\u0120(", "version", "Option", "\u0120==", "\u0120null", "\u0120||", "\u0120!", "version", "Option", ".", "equ", "als", "(", "loaded", "Version", ")))", "\u0120{", "\u0120Description", "Resource", "Impl", ".", "add", "M", "igration", "Options", "(", "loaded", "Version", ",", "\u0120this", ".", "get", "Default", "Load", "Options", "(),", "\u0120this", ".", "get", "Default", "Save", "Options", "());", "\u0120}", "\u0120return", "\u0120migration", "M", "ism", "atch", "Di", "agn", "ostic", ";", "\u0120}"], "docstring_tokens": ["Strange", "\u0120to", "\u0120use", "\u0120an", "\u0120X", "MI", "Exception", "\u0120here", ",", "\u0120which", "\u0120would", "\u0120imply", "\u0120something", "\u0120is", "\u0120corrupted", "\u0120at", "\u0120the", "\u0120X", "MI", "\u0120level", ",", "\u0120which", "\u0120is", "\u0120not", "\u0120the", "\u0120case", ".", "\u0120Especially", "\u0120since", "\u0120there", "\u0120is", "\u0120a", "\u0120A", "ird", "Resource", "Version", "M", "ism", "atch", "Exception", "\u0120defined", "\u0120in", "\u0120the", "\u0120same", "\u0120patch", "\u0120which", "\u0120implements", "\u0120Resource", ".", "Di", "agn", "ostic", "."]}
{"function": "public <T> T get(String key, String field) { RedisConnection<byte[], byte[]> redisCommands = null; try { redisCommands = getRedisConnection(); byte[] serializedData = redisCommands.hget(key.getBytes(), field.getBytes()); T deserializeObject = new JavaSerializer().deserializeObject(serializedData); return deserializeObject; } catch (Exception e) { logger.error(\"Exception Occurred while getting a value from redis\", e); } finally { closeConnection(redisCommands); } return null; }", "text": "Catching the exception hides network- and classpath/structural problems and returns null to the caller.", "function_tokens": ["public", "\u0120<", "T", ">", "\u0120T", "\u0120get", "(", "String", "\u0120key", ",", "\u0120String", "\u0120field", ")", "\u0120{", "\u0120Red", "is", "Connection", "<", "byte", "[", "],", "\u0120byte", "[]", ">", "\u0120red", "is", "Comm", "ands", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120red", "is", "Comm", "ands", "\u0120=", "\u0120get", "Red", "is", "Connection", "();", "\u0120byte", "[]", "\u0120serial", "ized", "Data", "\u0120=", "\u0120red", "is", "Comm", "ands", ".", "h", "get", "(", "key", ".", "get", "Bytes", "(),", "\u0120field", ".", "get", "Bytes", "());", "\u0120T", "\u0120des", "erial", "ize", "Object", "\u0120=", "\u0120new", "\u0120Java", "Serial", "izer", "().", "des", "erial", "ize", "Object", "(", "serial", "ized", "Data", ");", "\u0120return", "\u0120des", "erial", "ize", "Object", ";", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "error", "(\"", "Exception", "\u0120Occ", "urred", "\u0120while", "\u0120getting", "\u0120a", "\u0120value", "\u0120from", "\u0120red", "is", "\",", "\u0120e", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120close", "Connection", "(", "red", "is", "Comm", "ands", ");", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["C", "atching", "\u0120the", "\u0120exception", "\u0120hides", "\u0120network", "-", "\u0120and", "\u0120class", "path", "/", "struct", "ural", "\u0120problems", "\u0120and", "\u0120returns", "\u0120null", "\u0120to", "\u0120the", "\u0120caller", "."]}
{"function": "public void testScaffoldSetup() throws Exception { Project project = projectHelper.createWebProject(); try (CommandController c = testHarness.createWizardController(ScaffoldSetupWizard.class, project.getRoot())) { c.initialize(); c.setValueFor(\"provider\", \"Mock Scaffold Provider\"); c.setValueFor(\"webRoot\", \"\"); Assert.assertTrue(c.isValid()); Result result = c.execute(); Assert.assertNotNull(result); } }", "text": "Is this test really testing much? It doesn't assert that the result is not a failure: !(result instanceof Failed) for instance.", "function_tokens": ["public", "\u0120void", "\u0120test", "Sc", "aff", "old", "Setup", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Project", "\u0120project", "\u0120=", "\u0120project", "Helper", ".", "create", "Web", "Project", "();", "\u0120try", "\u0120(", "Command", "Controller", "\u0120c", "\u0120=", "\u0120test", "Har", "ness", ".", "create", "W", "izard", "Controller", "(", "Sc", "aff", "old", "Setup", "W", "izard", ".", "class", ",", "\u0120project", ".", "get", "Root", "()", "))", "\u0120{", "\u0120c", ".", "initial", "ize", "();", "\u0120c", ".", "set", "Value", "For", "(\"", "prov", "ider", "\",", "\u0120\"", "M", "ock", "\u0120Sc", "aff", "old", "\u0120Provider", "\");", "\u0120c", ".", "set", "Value", "For", "(\"", "web", "Root", "\",", "\u0120\"\"", ");", "\u0120Ass", "ert", ".", "assert", "True", "(", "c", ".", "is", "Valid", "());", "\u0120Result", "\u0120result", "\u0120=", "\u0120c", ".", "execute", "();", "\u0120Ass", "ert", ".", "assert", "Not", "Null", "(", "result", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Is", "\u0120this", "\u0120test", "\u0120really", "\u0120testing", "\u0120much", "?", "\u0120It", "\u0120doesn", "'t", "\u0120assert", "\u0120that", "\u0120the", "\u0120result", "\u0120is", "\u0120not", "\u0120a", "\u0120failure", ":", "\u0120!", "(", "result", "\u0120instance", "of", "\u0120Failed", ")", "\u0120for", "\u0120instance", "."]}
{"function": "private Set<Integer> getTimeseriesLayerIds(int layerId) throws ActionException { Set<Integer> timeseriesLayerIds = new HashSet<>(); for (OskariLayer layer : mapLayerService.findAll()) { JSONObject options = layer.getOptions(); try { if (options != null && options.has(\"timeseries\")) { JSONObject timeseriesOptions = options.getJSONObject(\"timeseries\"); Integer metadataLayerId = timeseriesOptions.getJSONObject(\"metadata\").getInt(\"layer\"); if (metadataLayerId == layerId) { timeseriesLayerIds.add(layer.getId()); } } } catch (JSONException e) { throw new ActionException(\"Cannot parse layer metadata options for layer: \" + layer.getName() + \", id: \" + layer.getId()); } } return timeseriesLayerIds; }", "text": "This could throw a NPE if options has timeseries but not metadata under it.", "function_tokens": ["private", "\u0120Set", "<", "Integer", ">", "\u0120get", "Times", "eries", "Layer", "Id", "s", "(", "int", "\u0120layer", "Id", ")", "\u0120throws", "\u0120Action", "Exception", "\u0120{", "\u0120Set", "<", "Integer", ">", "\u0120times", "eries", "Layer", "Id", "s", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120for", "\u0120(", "O", "sk", "ari", "Layer", "\u0120layer", "\u0120:", "\u0120map", "Layer", "Service", ".", "find", "All", "())", "\u0120{", "\u0120JSON", "Object", "\u0120options", "\u0120=", "\u0120layer", ".", "get", "Options", "();", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "options", "\u0120!=", "\u0120null", "\u0120&&", "\u0120options", ".", "has", "(\"", "times", "eries", "\"))", "\u0120{", "\u0120JSON", "Object", "\u0120times", "eries", "Options", "\u0120=", "\u0120options", ".", "get", "JSON", "Object", "(\"", "times", "eries", "\");", "\u0120Integer", "\u0120metadata", "Layer", "Id", "\u0120=", "\u0120times", "eries", "Options", ".", "get", "JSON", "Object", "(\"", "metadata", "\").", "get", "Int", "(\"", "layer", "\");", "\u0120if", "\u0120(", "metadata", "Layer", "Id", "\u0120==", "\u0120layer", "Id", ")", "\u0120{", "\u0120times", "eries", "Layer", "Id", "s", ".", "add", "(", "layer", ".", "get", "Id", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "JSON", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Action", "Exception", "(\"", "C", "annot", "\u0120parse", "\u0120layer", "\u0120metadata", "\u0120options", "\u0120for", "\u0120layer", ":", "\u0120\"", "\u0120+", "\u0120layer", ".", "get", "Name", "()", "\u0120+", "\u0120\",", "\u0120id", ":", "\u0120\"", "\u0120+", "\u0120layer", ".", "get", "Id", "());", "\u0120}", "\u0120}", "\u0120return", "\u0120times", "eries", "Layer", "Id", "s", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120could", "\u0120throw", "\u0120a", "\u0120N", "PE", "\u0120if", "\u0120options", "\u0120has", "\u0120times", "eries", "\u0120but", "\u0120not", "\u0120metadata", "\u0120under", "\u0120it", "."]}
{"function": "public void testSignInSucceeded() { Activity mockActivty = mock(Activity.class); ActivityHelper mockActivityHelper = mock(ActivityHelper.class); FirebaseUser mockFirebaseUser = TestHelper.makeMockFirebaseUser(); IDPResponse mockIdpResponse = mock(IDPResponse.class); CredentialSignInHandler credentialSignInHandler = new CredentialSignInHandler( mockActivty, mockActivityHelper, RC_ACCOUNT_LINK, RC_SAVE_CREDENTIALS, mockIdpResponse); Context mockContext = mock(Context.class); FlowParameters mockFlowParams = mock(FlowParameters.class); Task mockTask = mock(Task.class); when(mockTask.isSuccessful()).thenReturn(true); when(mockTask.getResult()).thenReturn(new FakeAuthResult(mockFirebaseUser)); when(mockActivityHelper.getApplicationContext()).thenReturn(mockContext); when(mockActivityHelper.getFlowParams()).thenReturn(mockFlowParams); credentialSignInHandler.onComplete(mockTask); ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class); ArgumentCaptor<Integer> intCaptor = ArgumentCaptor.forClass(Integer.class); verify(mockActivty).startActivityForResult(intentCaptor.capture(), intCaptor.capture()); Intent capturedIntent = intentCaptor.getValue(); assertEquals(RC_SAVE_CREDENTIALS, (int) intCaptor.getValue()); assertEquals( SaveCredentialsActivity.class.getName(), capturedIntent.getComponent().getClassName()); assertEquals( TestConstants.EMAIL, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_EMAIL)); assertEquals( TestConstants.NAME, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_NAME)); assertEquals( TestConstants.PHOTO_URL, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_PROFILE_PICTURE_URI)); }", "text": "I think you should be able to use Tasks.forResult(new FakeAuthResult(mockFirebaseUser)) instead of a mock object without consequence here, it should be more readable.", "function_tokens": ["public", "\u0120void", "\u0120test", "Sign", "In", "S", "uc", "ceed", "ed", "()", "\u0120{", "\u0120Activity", "\u0120mock", "Activ", "ty", "\u0120=", "\u0120mock", "(", "Activity", ".", "class", ");", "\u0120Activity", "Helper", "\u0120mock", "Activity", "Helper", "\u0120=", "\u0120mock", "(", "Activity", "Helper", ".", "class", ");", "\u0120Fire", "base", "User", "\u0120mock", "Fire", "base", "User", "\u0120=", "\u0120Test", "Helper", ".", "make", "M", "ock", "Fire", "base", "User", "();", "\u0120ID", "PR", "esp", "onse", "\u0120mock", "Id", "p", "Response", "\u0120=", "\u0120mock", "(", "ID", "PR", "esp", "onse", ".", "class", ");", "\u0120C", "red", "ential", "Sign", "In", "Handler", "\u0120credential", "Sign", "In", "Handler", "\u0120=", "\u0120new", "\u0120C", "red", "ential", "Sign", "In", "Handler", "(", "\u0120mock", "Activ", "ty", ",", "\u0120mock", "Activity", "Helper", ",", "\u0120RC", "_", "ACC", "OUNT", "_", "L", "INK", ",", "\u0120RC", "_", "SA", "VE", "_", "CR", "ED", "ENT", "IAL", "S", ",", "\u0120mock", "Id", "p", "Response", ");", "\u0120Context", "\u0120mock", "Context", "\u0120=", "\u0120mock", "(", "Context", ".", "class", ");", "\u0120Flow", "Parameters", "\u0120mock", "Flow", "Par", "ams", "\u0120=", "\u0120mock", "(", "Flow", "Parameters", ".", "class", ");", "\u0120Task", "\u0120mock", "Task", "\u0120=", "\u0120mock", "(", "Task", ".", "class", ");", "\u0120when", "(", "m", "ock", "Task", ".", "is", "Success", "ful", "()", ").", "then", "Return", "(", "true", ");", "\u0120when", "(", "m", "ock", "Task", ".", "get", "Result", "()", ").", "then", "Return", "(", "new", "\u0120Fake", "Auth", "Result", "(", "m", "ock", "Fire", "base", "User", "));", "\u0120when", "(", "m", "ock", "Activity", "Helper", ".", "get", "Application", "Context", "()", ").", "then", "Return", "(", "m", "ock", "Context", ");", "\u0120when", "(", "m", "ock", "Activity", "Helper", ".", "get", "Flow", "Par", "ams", "()", ").", "then", "Return", "(", "m", "ock", "Flow", "Par", "ams", ");", "\u0120credential", "Sign", "In", "Handler", ".", "on", "Complete", "(", "m", "ock", "Task", ");", "\u0120Argument", "Capt", "or", "<", "Int", "ent", ">", "\u0120intent", "Capt", "or", "\u0120=", "\u0120Argument", "Capt", "or", ".", "for", "Class", "(", "Int", "ent", ".", "class", ");", "\u0120Argument", "Capt", "or", "<", "Integer", ">", "\u0120int", "Capt", "or", "\u0120=", "\u0120Argument", "Capt", "or", ".", "for", "Class", "(", "Integer", ".", "class", ");", "\u0120verify", "(", "m", "ock", "Activ", "ty", ").", "start", "Activity", "For", "Result", "(", "intent", "Capt", "or", ".", "capt", "ure", "(),", "\u0120int", "Capt", "or", ".", "capt", "ure", "());", "\u0120Intent", "\u0120captured", "Int", "ent", "\u0120=", "\u0120intent", "Capt", "or", ".", "get", "Value", "();", "\u0120assert", "Equ", "als", "(", "RC", "_", "SA", "VE", "_", "CR", "ED", "ENT", "IAL", "S", ",", "\u0120(", "int", ")", "\u0120int", "Capt", "or", ".", "get", "Value", "());", "\u0120assert", "Equ", "als", "(", "\u0120Save", "C", "red", "entials", "Activity", ".", "class", ".", "get", "Name", "(),", "\u0120captured", "Int", "ent", ".", "get", "Component", "().", "get", "Class", "Name", "());", "\u0120assert", "Equ", "als", "(", "\u0120Test", "Const", "ants", ".", "EMA", "IL", ",", "\u0120captured", "Int", "ent", ".", "get", "Ext", "ras", "().", "get", "String", "(", "Extra", "Const", "ants", ".", "EXT", "RA", "_", "EMA", "IL", "));", "\u0120assert", "Equ", "als", "(", "\u0120Test", "Const", "ants", ".", "NAME", ",", "\u0120captured", "Int", "ent", ".", "get", "Ext", "ras", "().", "get", "String", "(", "Extra", "Const", "ants", ".", "EXT", "RA", "_", "NAME", "));", "\u0120assert", "Equ", "als", "(", "\u0120Test", "Const", "ants", ".", "PH", "OTO", "_", "URL", ",", "\u0120captured", "Int", "ent", ".", "get", "Ext", "ras", "().", "get", "String", "(", "Extra", "Const", "ants", ".", "EXT", "RA", "_", "PRO", "FILE", "_", "P", "ICT", "URE", "_", "URI", "));", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120you", "\u0120should", "\u0120be", "\u0120able", "\u0120to", "\u0120use", "\u0120T", "asks", ".", "for", "Result", "(", "new", "\u0120Fake", "Auth", "Result", "(", "m", "ock", "Fire", "base", "User", "))", "\u0120instead", "\u0120of", "\u0120a", "\u0120mock", "\u0120object", "\u0120without", "\u0120consequence", "\u0120here", ",", "\u0120it", "\u0120should", "\u0120be", "\u0120more", "\u0120readable", "."]}
{"function": "public void testRecover() throws Exception { CountDownLatch countDownLatch = new CountDownLatch(2); final AtomicReference<Boolean> notified = new AtomicReference<Boolean>(false); NotifyListener listner = new NotifyListener() { @Override public void notify(List<URL> urls) { notified.set(Boolean.TRUE); } }; MockRegistry mockRegistry = new MockRegistry(registryUrl, countDownLatch); mockRegistry.register(serviceUrl); mockRegistry.subscribe(serviceUrl, listner); Assert.assertEquals(mockRegistry.getRegistered().size(), 1); Assert.assertEquals(mockRegistry.getSubscribed().size(), 1); mockRegistry.recover(); Assert.assertEquals(mockRegistry.getFailedSubscribed().size(), 1); Assert.assertEquals(countDownLatch.getCount(), 0); }", "text": "please fix typo listner, should be listener ?", "function_tokens": ["public", "\u0120void", "\u0120test", "Rec", "over", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Count", "Down", "L", "atch", "\u0120count", "Down", "L", "atch", "\u0120=", "\u0120new", "\u0120Count", "Down", "L", "atch", "(", "2", ");", "\u0120final", "\u0120Atomic", "Reference", "<", "Boo", "lean", ">", "\u0120notified", "\u0120=", "\u0120new", "\u0120Atomic", "Reference", "<", "Boo", "lean", ">(", "false", ");", "\u0120Not", "ify", "Listener", "\u0120list", "ner", "\u0120=", "\u0120new", "\u0120Not", "ify", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120notify", "(", "List", "<", "URL", ">", "\u0120ur", "ls", ")", "\u0120{", "\u0120notified", ".", "set", "(", "Boo", "lean", ".", "TR", "UE", ");", "\u0120}", "\u0120};", "\u0120Mock", "Reg", "istry", "\u0120mock", "Reg", "istry", "\u0120=", "\u0120new", "\u0120Mock", "Reg", "istry", "(", "reg", "istry", "Url", ",", "\u0120count", "Down", "L", "atch", ");", "\u0120mock", "Reg", "istry", ".", "register", "(", "service", "Url", ");", "\u0120mock", "Reg", "istry", ".", "sub", "scribe", "(", "service", "Url", ",", "\u0120list", "ner", ");", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "m", "ock", "Reg", "istry", ".", "get", "Registered", "().", "size", "(),", "\u01201", ");", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "m", "ock", "Reg", "istry", ".", "get", "Sub", "scribed", "().", "size", "(),", "\u01201", ");", "\u0120mock", "Reg", "istry", ".", "re", "cover", "();", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "m", "ock", "Reg", "istry", ".", "get", "F", "ailed", "Sub", "scribed", "().", "size", "(),", "\u01201", ");", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "count", "Down", "L", "atch", ".", "get", "Count", "(),", "\u01200", ");", "\u0120}"], "docstring_tokens": ["please", "\u0120fix", "\u0120typo", "\u0120list", "ner", ",", "\u0120should", "\u0120be", "\u0120listener", "\u0120?"]}
{"function": "public int compare(final Account account1, final Account account2) { if (account1.getPreferredEmail() != null && account2.getPreferredEmail() != null) { return account1.getPreferredEmail().compareTo( account2.getPreferredEmail()); } if (account1.getFullName() != null && account2.getFullName() != null) { return account1.getFullName().compareTo(account2.getFullName()); } return Integer.valueOf(account1.getId().get()).compareTo( Integer.valueOf(account2.getId().get())); }", "text": "This isn't stable, is it? We should compare email to \"\" , and the same with full name.", "function_tokens": ["public", "\u0120int", "\u0120compare", "(", "final", "\u0120Account", "\u0120account", "1", ",", "\u0120final", "\u0120Account", "\u0120account", "2", ")", "\u0120{", "\u0120if", "\u0120(", "account", "1", ".", "get", "Pre", "ferred", "Email", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120account", "2", ".", "get", "Pre", "ferred", "Email", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120account", "1", ".", "get", "Pre", "ferred", "Email", "().", "comp", "are", "To", "(", "\u0120account", "2", ".", "get", "Pre", "ferred", "Email", "());", "\u0120}", "\u0120if", "\u0120(", "account", "1", ".", "get", "Full", "Name", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120account", "2", ".", "get", "Full", "Name", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120account", "1", ".", "get", "Full", "Name", "().", "comp", "are", "To", "(", "account", "2", ".", "get", "Full", "Name", "());", "\u0120}", "\u0120return", "\u0120Integer", ".", "value", "Of", "(", "account", "1", ".", "get", "Id", "().", "get", "()", ").", "comp", "are", "To", "(", "\u0120Integer", ".", "value", "Of", "(", "account", "2", ".", "get", "Id", "().", "get", "()", "));", "\u0120}"], "docstring_tokens": ["This", "\u0120isn", "'t", "\u0120stable", ",", "\u0120is", "\u0120it", "?", "\u0120We", "\u0120should", "\u0120compare", "\u0120email", "\u0120to", "\u0120\"\"", "\u0120,", "\u0120and", "\u0120the", "\u0120same", "\u0120with", "\u0120full", "\u0120name", "."]}
{"function": "public void onNext(final AggregationMessage aggregationMessage) { final String workerId = aggregationMessage.getSourceId().toString(); final String localState = codec.decode(aggregationMessage.getData().array()); final String globalState = globalStateMachine.getCurrentState(); switch (globalState) { case STATE_INIT: break; case STATE_RUN: if (localState.equals(STATE_INIT)) { sendResponseMessage(workerId, new byte[0]); return; } break; case STATE_CLEANUP: default: throw new RuntimeException(\"Invalid state\"); } blockedWorkerIds.add(workerId); LOG.log(Level.FINE, \"Receive a synchronization message from {0}. {1} messages have been received out of {2}.\", new Object[]{workerId, blockedWorkerIds.size(), numWorkersToSync}); tryReleaseWorkers(); }", "text": "It'd be helpful to remind what's going on here, especially mentioning that _In case when a worker's local state is behind the globally synchronized state, this implies the worker is added by EM. If so, the worker is replied to continue until it reaches the global state_.", "function_tokens": ["public", "\u0120void", "\u0120on", "Next", "(", "final", "\u0120Agg", "regation", "Message", "\u0120aggregation", "Message", ")", "\u0120{", "\u0120final", "\u0120String", "\u0120worker", "Id", "\u0120=", "\u0120aggregation", "Message", ".", "get", "Source", "Id", "().", "to", "String", "();", "\u0120final", "\u0120String", "\u0120local", "State", "\u0120=", "\u0120codec", ".", "dec", "ode", "(", "agg", "regation", "Message", ".", "get", "Data", "().", "array", "());", "\u0120final", "\u0120String", "\u0120global", "State", "\u0120=", "\u0120global", "State", "Machine", ".", "get", "Current", "State", "();", "\u0120switch", "\u0120(", "global", "State", ")", "\u0120{", "\u0120case", "\u0120STATE", "_", "IN", "IT", ":", "\u0120break", ";", "\u0120case", "\u0120STATE", "_", "R", "UN", ":", "\u0120if", "\u0120(", "local", "State", ".", "equ", "als", "(", "STATE", "_", "IN", "IT", "))", "\u0120{", "\u0120send", "Response", "Message", "(", "worker", "Id", ",", "\u0120new", "\u0120byte", "[", "0", "]);", "\u0120return", ";", "\u0120}", "\u0120break", ";", "\u0120case", "\u0120STATE", "_", "CLE", "AN", "UP", ":", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Invalid", "\u0120state", "\");", "\u0120}", "\u0120blocked", "Work", "er", "Id", "s", ".", "add", "(", "worker", "Id", ");", "\u0120LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\u0120\"", "Re", "ceive", "\u0120a", "\u0120synchronization", "\u0120message", "\u0120from", "\u0120{", "0", "}.", "\u0120{", "1", "}", "\u0120messages", "\u0120have", "\u0120been", "\u0120received", "\u0120out", "\u0120of", "\u0120{", "2", "}", ".\",", "\u0120new", "\u0120Object", "[]", "{", "worker", "Id", ",", "\u0120blocked", "Work", "er", "Id", "s", ".", "size", "(),", "\u0120num", "Work", "ers", "To", "Sync", "});", "\u0120try", "Release", "Work", "ers", "();", "\u0120}"], "docstring_tokens": ["It", "'d", "\u0120be", "\u0120helpful", "\u0120to", "\u0120remind", "\u0120what", "'s", "\u0120going", "\u0120on", "\u0120here", ",", "\u0120especially", "\u0120mentioning", "\u0120that", "\u0120_", "In", "\u0120case", "\u0120when", "\u0120a", "\u0120worker", "'s", "\u0120local", "\u0120state", "\u0120is", "\u0120behind", "\u0120the", "\u0120globally", "\u0120synchronized", "\u0120state", ",", "\u0120this", "\u0120implies", "\u0120the", "\u0120worker", "\u0120is", "\u0120added", "\u0120by", "\u0120EM", ".", "\u0120If", "\u0120so", ",", "\u0120the", "\u0120worker", "\u0120is", "\u0120replied", "\u0120to", "\u0120continue", "\u0120until", "\u0120it", "\u0120reaches", "\u0120the", "\u0120global", "\u0120state", "_."]}
{"function": "public HttpMessage setProtocolVersion(HttpVersion version) { ObjectUtil.checkNotNull(version, \"version\"); this.version = version; return this; }", "text": "nit: you can merge both lines above as checkNotNull will return the given argument", "function_tokens": ["public", "\u0120H", "ttp", "Message", "\u0120set", "Prot", "ocol", "Version", "(", "Http", "Version", "\u0120version", ")", "\u0120{", "\u0120Object", "Ut", "il", ".", "check", "Not", "Null", "(", "version", ",", "\u0120\"", "version", "\");", "\u0120this", ".", "version", "\u0120=", "\u0120version", ";", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120you", "\u0120can", "\u0120merge", "\u0120both", "\u0120lines", "\u0120above", "\u0120as", "\u0120check", "Not", "Null", "\u0120will", "\u0120return", "\u0120the", "\u0120given", "\u0120argument"]}
{"function": "private void validate() { assertThat(localSegment, Objects::nonNull, () -> new AxonConfigurationException(\"The localSegment may not be null\")); assertThat(channel, Objects::nonNull, () -> new AxonConfigurationException(\"JChannel may not be null\")); assertThat(clusterName, Objects::nonNull, () -> new AxonConfigurationException(\"The clusterName may not be null\")); assertThat(serializer, Objects::nonNull, () -> new AxonConfigurationException(\"Serializer may not be null\")); assertThat(routingStrategy, Objects::nonNull, () -> new AxonConfigurationException(\"RoutingStrategy may not be null\")); assertThat(consistentHashChangeListener, Objects::nonNull, () -> new AxonConfigurationException(\"ConsistentHashChangeListener may not be null\")); }", "text": "Null values at this point should not be really reported as a property being null, but as a mandatory property for which no value was provided", "function_tokens": ["private", "\u0120void", "\u0120validate", "()", "\u0120{", "\u0120assert", "That", "(", "local", "Seg", "ment", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "The", "\u0120local", "Seg", "ment", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120assert", "That", "(", "channel", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "J", "Channel", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120assert", "That", "(", "cl", "uster", "Name", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "The", "\u0120cluster", "Name", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120assert", "That", "(", "serial", "izer", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "Serial", "izer", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120assert", "That", "(", "r", "outing", "Str", "ategy", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "R", "outing", "Str", "ategy", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120assert", "That", "(", "cons", "istent", "Hash", "Change", "Listener", ",", "\u0120Objects", "::", "non", "Null", ",", "\u0120()", "\u0120->", "\u0120new", "\u0120Ax", "on", "Configuration", "Exception", "(\"", "Cons", "istent", "Hash", "Change", "Listener", "\u0120may", "\u0120not", "\u0120be", "\u0120null", "\")", ");", "\u0120}"], "docstring_tokens": ["Null", "\u0120values", "\u0120at", "\u0120this", "\u0120point", "\u0120should", "\u0120not", "\u0120be", "\u0120really", "\u0120reported", "\u0120as", "\u0120a", "\u0120property", "\u0120being", "\u0120null", ",", "\u0120but", "\u0120as", "\u0120a", "\u0120mandatory", "\u0120property", "\u0120for", "\u0120which", "\u0120no", "\u0120value", "\u0120was", "\u0120provided"]}
{"function": "private Object unwrapBinary(Object obj, BinaryReaderHandles hnds) { if (obj instanceof BinaryObjectImpl) { BinaryObjectImpl obj0 = (BinaryObjectImpl)obj; return marsh.deserialize(BinaryHeapInputStream.create(obj0.array(), obj0.start()), hnds); } else if (obj instanceof BinaryObject ) return ((BinaryObject)obj).deserialize(); else if (BinaryUtils.knownCollection(obj)) return unwrapCollection((Collection<Objects>)obj, hnds); else if (BinaryUtils.knownMap(obj)) return unwrapMap((Map<Object, Object>)obj, hnds); else if (obj instanceof Object[]) return unwrapArray((Object[])obj, hnds); else return obj; }", "text": "Cosmetic. Extra space between BinaryObject and ).", "function_tokens": ["private", "\u0120Object", "\u0120unw", "rap", "B", "inary", "(", "Object", "\u0120obj", ",", "\u0120Binary", "Reader", "Hand", "les", "\u0120h", "nd", "s", ")", "\u0120{", "\u0120if", "\u0120(", "obj", "\u0120instance", "of", "\u0120Binary", "Object", "Impl", ")", "\u0120{", "\u0120Binary", "Object", "Impl", "\u0120obj", "0", "\u0120=", "\u0120(", "B", "inary", "Object", "Impl", ")", "obj", ";", "\u0120return", "\u0120marsh", ".", "des", "erial", "ize", "(", "B", "inary", "He", "ap", "Input", "Stream", ".", "create", "(", "obj", "0", ".", "array", "(),", "\u0120obj", "0", ".", "start", "()", "),", "\u0120h", "nd", "s", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "obj", "\u0120instance", "of", "\u0120Binary", "Object", "\u0120)", "\u0120return", "\u0120((", "B", "inary", "Object", ")", "obj", ").", "des", "erial", "ize", "();", "\u0120else", "\u0120if", "\u0120(", "B", "inary", "Ut", "ils", ".", "known", "Collection", "(", "obj", "))", "\u0120return", "\u0120unw", "rap", "Collection", "((", "Collection", "<", "Object", "s", ">)", "obj", ",", "\u0120h", "nd", "s", ");", "\u0120else", "\u0120if", "\u0120(", "B", "inary", "Ut", "ils", ".", "known", "Map", "(", "obj", "))", "\u0120return", "\u0120unw", "rap", "Map", "((", "Map", "<", "Object", ",", "\u0120Object", ">)", "obj", ",", "\u0120h", "nd", "s", ");", "\u0120else", "\u0120if", "\u0120(", "obj", "\u0120instance", "of", "\u0120Object", "[", "])", "\u0120return", "\u0120unw", "rap", "Array", "((", "Object", "[", "])", "obj", ",", "\u0120h", "nd", "s", ");", "\u0120else", "\u0120return", "\u0120obj", ";", "\u0120}"], "docstring_tokens": ["Cos", "metic", ".", "\u0120Extra", "\u0120space", "\u0120between", "\u0120Binary", "Object", "\u0120and", "\u0120)."]}
{"function": "public void put(String handle, LocalDateTime lastUsed) { storageLock.lock(); try { if (_storage == null) { throw new RuntimeException(EXCEPTION_STORAGE); } if (lastUsed == null) { _storage.put(LAST_USED.getKey(handle), (String) null); } else { String gsonStr = gson.toJson(lastUsed); _storage.put(LAST_USED.getKey(handle), gsonStr); } } finally { storageLock.unlock(); } }", "text": "do not throw RuntimeException", "function_tokens": ["public", "\u0120void", "\u0120put", "(", "String", "\u0120handle", ",", "\u0120Local", "Date", "Time", "\u0120last", "Used", ")", "\u0120{", "\u0120storage", "Lock", ".", "lock", "();", "\u0120try", "\u0120{", "\u0120if", "\u0120(_", "storage", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "EX", "CEPT", "ION", "_", "ST", "OR", "AGE", ");", "\u0120}", "\u0120if", "\u0120(", "last", "Used", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120_", "storage", ".", "put", "(", "L", "AST", "_", "US", "ED", ".", "get", "Key", "(", "handle", "),", "\u0120(", "String", ")", "\u0120null", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120g", "son", "Str", "\u0120=", "\u0120g", "son", ".", "to", "J", "son", "(", "last", "Used", ");", "\u0120_", "storage", ".", "put", "(", "L", "AST", "_", "US", "ED", ".", "get", "Key", "(", "handle", "),", "\u0120g", "son", "Str", ");", "\u0120}", "\u0120}", "\u0120finally", "\u0120{", "\u0120storage", "Lock", ".", "un", "lock", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["do", "\u0120not", "\u0120throw", "\u0120Runtime", "Exception"]}
{"function": "public ArrayList<LinkInfo> getRemoteGoToLinks() throws IOException { if (remoteGoToLinks == null) { loadAndPreflightPdf(); remoteGoToLinks = parseForLinks(PDActionRemoteGoTo.SUB_TYPE); } return remoteGoToLinks; }", "text": "List<LinkInfo> (check below for other method signatures)", "function_tokens": ["public", "\u0120Array", "List", "<", "Link", "Info", ">", "\u0120get", "Remote", "Go", "To", "Links", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "remote", "Go", "To", "Links", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120load", "And", "Pre", "flight", "P", "df", "();", "\u0120remote", "Go", "To", "Links", "\u0120=", "\u0120parse", "For", "Links", "(", "P", "DA", "ction", "Remote", "Go", "To", ".", "S", "UB", "_", "TYPE", ");", "\u0120}", "\u0120return", "\u0120remote", "Go", "To", "Links", ";", "\u0120}"], "docstring_tokens": ["List", "<", "Link", "Info", ">", "\u0120(", "check", "\u0120below", "\u0120for", "\u0120other", "\u0120method", "\u0120signatures", ")"]}
{"function": "private void breakModifies(ProgressMonitor pm) throws IOException { if (breakScore <= 0) return; ArrayList<DiffEntry> newEntries = new ArrayList<DiffEntry>(entries.size()); pm.beginTask(JGitText.get().renamesBreakingModifies, entries.size()); for (int i = 0; i < entries.size(); i++) { DiffEntry e = entries.get(i); if (e.getChangeType() == ChangeType.MODIFY) { final int score = calculateModifyScore(e); if (score < breakScore) { List<DiffEntry> tmp = DiffEntry.breakModify(e); DiffEntry del = tmp.get(0); del.score = score; deleted.add(del); added.add(tmp.get(1)); } else { newEntries.add(e); } } pm.update(1); } entries = newEntries; }", "text": "Non-modify entries should be added back onto newEntries.", "function_tokens": ["private", "\u0120void", "\u0120break", "Mod", "ifies", "(", "Progress", "Monitor", "\u0120pm", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "break", "Score", "\u0120<=", "\u01200", ")", "\u0120return", ";", "\u0120Array", "List", "<", "Diff", "Entry", ">", "\u0120new", "Ent", "ries", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Diff", "Entry", ">(", "ent", "ries", ".", "size", "());", "\u0120pm", ".", "begin", "Task", "(", "J", "G", "it", "Text", ".", "get", "().", "ren", "ames", "Breaking", "Mod", "ifies", ",", "\u0120entries", ".", "size", "());", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120entries", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120Diff", "Entry", "\u0120e", "\u0120=", "\u0120entries", ".", "get", "(", "i", ");", "\u0120if", "\u0120(", "e", ".", "get", "Change", "Type", "()", "\u0120==", "\u0120Change", "Type", ".", "MOD", "IF", "Y", ")", "\u0120{", "\u0120final", "\u0120int", "\u0120score", "\u0120=", "\u0120calculate", "Mod", "ify", "Score", "(", "e", ");", "\u0120if", "\u0120(", "score", "\u0120<", "\u0120break", "Score", ")", "\u0120{", "\u0120List", "<", "Diff", "Entry", ">", "\u0120tmp", "\u0120=", "\u0120Diff", "Entry", ".", "break", "Mod", "ify", "(", "e", ");", "\u0120Diff", "Entry", "\u0120del", "\u0120=", "\u0120tmp", ".", "get", "(", "0", ");", "\u0120del", ".", "score", "\u0120=", "\u0120score", ";", "\u0120deleted", ".", "add", "(", "del", ");", "\u0120added", ".", "add", "(", "tmp", ".", "get", "(", "1", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120new", "Ent", "ries", ".", "add", "(", "e", ");", "\u0120}", "\u0120}", "\u0120pm", ".", "update", "(", "1", ");", "\u0120}", "\u0120entries", "\u0120=", "\u0120new", "Ent", "ries", ";", "\u0120}"], "docstring_tokens": ["Non", "-", "mod", "ify", "\u0120entries", "\u0120should", "\u0120be", "\u0120added", "\u0120back", "\u0120onto", "\u0120new", "Ent", "ries", "."]}
{"function": "public void sendJsonMessage(String json) throws OperationFailedException { try { assertConnected(); org.jivesoftware.smack.packet.Message msg = new org.jivesoftware.smack.packet.Message(); msg.setType(org.jivesoftware.smack.packet.Message.Type.groupchat); msg.addExtension(new JsonMessageExtension(json)); MessageEventManager. addNotificationsRequests(msg, true, false, false, true); multiUserChat.sendMessage(msg); } catch (NotConnectedException | InterruptedException ex){ throw new OperationFailedException( \"Failed to send JSON message \" + json , OperationFailedException.GENERAL_ERROR , ex); } }", "text": "brackets don't match coding style", "function_tokens": ["public", "\u0120void", "\u0120send", "J", "son", "Message", "(", "String", "\u0120json", ")", "\u0120throws", "\u0120Operation", "F", "ailed", "Exception", "\u0120{", "\u0120try", "\u0120{", "\u0120assert", "Connect", "ed", "();", "\u0120org", ".", "j", "ives", "oft", "ware", ".", "sm", "ack", ".", "pack", "et", ".", "Message", "\u0120msg", "\u0120=", "\u0120new", "\u0120org", ".", "j", "ives", "oft", "ware", ".", "sm", "ack", ".", "pack", "et", ".", "Message", "();", "\u0120msg", ".", "set", "Type", "(", "org", ".", "j", "ives", "oft", "ware", ".", "sm", "ack", ".", "pack", "et", ".", "Message", ".", "Type", ".", "group", "chat", ");", "\u0120msg", ".", "add", "Ext", "ension", "(", "new", "\u0120J", "son", "Message", "Ext", "ension", "(", "json", "));", "\u0120Message", "Event", "Manager", ".", "\u0120add", "Not", "ifications", "Requ", "ests", "(", "msg", ",", "\u0120true", ",", "\u0120false", ",", "\u0120false", ",", "\u0120true", ");", "\u0120multi", "User", "Chat", ".", "send", "Message", "(", "msg", ");", "\u0120}", "\u0120catch", "\u0120(", "Not", "Connect", "ed", "Exception", "\u0120|", "\u0120Inter", "rupted", "Exception", "\u0120ex", "){", "\u0120throw", "\u0120new", "\u0120Operation", "F", "ailed", "Exception", "(", "\u0120\"", "F", "ailed", "\u0120to", "\u0120send", "\u0120JSON", "\u0120message", "\u0120\"", "\u0120+", "\u0120json", "\u0120,", "\u0120Operation", "F", "ailed", "Exception", ".", "GEN", "ERAL", "_", "ERROR", "\u0120,", "\u0120ex", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["br", "ackets", "\u0120don", "'t", "\u0120match", "\u0120coding", "\u0120style"]}
{"function": "public static void placeSteamOven(World world, BlockPos pos, List<ItemStack> input, List<ItemStack> output) { MultiBlockPattern pattern = TileSteamOven.patterns.get(0); Map<Character, IBlockState> blockMapping = new HashMap<Character, IBlockState>(); IBlockState base = RailcraftBlocks.getBlockMachineAlpha().getDefaultState(); IBlockState steamOven = base.withProperty(MachineProxyAlpha.VARIANT, EnumMachineAlpha.STEAM_OVEN); blockMapping.put('B', steamOven); TileEntity tile = pattern.placeStructure(world, pos, blockMapping); if (tile instanceof TileSteamOven) { TileSteamOven master = (TileSteamOven) tile; for (int slot = 0; slot < 9; slot++) { if (input != null && slot < input.size()) master.inv.setInventorySlotContents(TileSteamOven.SLOT_INPUT + slot, input.get(slot)); if (output != null && slot < output.size()) master.inv.setInventorySlotContents(TileSteamOven.SLOT_OUTPUT + slot, output.get(slot)); } } }", "text": "EnumMachineAlpha.STEAM_OVEN.getState()?", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120place", "Steam", "O", "ven", "(", "World", "\u0120world", ",", "\u0120Block", "Pos", "\u0120pos", ",", "\u0120List", "<", "Item", "Stack", ">", "\u0120input", ",", "\u0120List", "<", "Item", "Stack", ">", "\u0120output", ")", "\u0120{", "\u0120Multi", "Block", "Pattern", "\u0120pattern", "\u0120=", "\u0120Tile", "Steam", "O", "ven", ".", "pattern", "s", ".", "get", "(", "0", ");", "\u0120Map", "<", "Character", ",", "\u0120I", "Block", "State", ">", "\u0120block", "M", "apping", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "Character", ",", "\u0120I", "Block", "State", ">", "();", "\u0120I", "Block", "State", "\u0120base", "\u0120=", "\u0120Rail", "craft", "Blocks", ".", "get", "Block", "Machine", "Alpha", "().", "get", "Default", "State", "();", "\u0120I", "Block", "State", "\u0120steam", "O", "ven", "\u0120=", "\u0120base", ".", "with", "Property", "(", "Machine", "Proxy", "Alpha", ".", "V", "ARI", "ANT", ",", "\u0120En", "um", "Machine", "Alpha", ".", "STE", "AM", "_", "OV", "EN", ");", "\u0120block", "M", "apping", ".", "put", "('", "B", "',", "\u0120steam", "O", "ven", ");", "\u0120Tile", "Entity", "\u0120tile", "\u0120=", "\u0120pattern", ".", "place", "St", "ructure", "(", "world", ",", "\u0120pos", ",", "\u0120block", "M", "apping", ");", "\u0120if", "\u0120(", "tile", "\u0120instance", "of", "\u0120Tile", "Steam", "O", "ven", ")", "\u0120{", "\u0120Tile", "Steam", "O", "ven", "\u0120master", "\u0120=", "\u0120(", "Tile", "Steam", "O", "ven", ")", "\u0120tile", ";", "\u0120for", "\u0120(", "int", "\u0120slot", "\u0120=", "\u01200", ";", "\u0120slot", "\u0120<", "\u01209", ";", "\u0120slot", "++)", "\u0120{", "\u0120if", "\u0120(", "input", "\u0120!=", "\u0120null", "\u0120&&", "\u0120slot", "\u0120<", "\u0120input", ".", "size", "())", "\u0120master", ".", "inv", ".", "set", "In", "ventory", "Slot", "Contents", "(", "Tile", "Steam", "O", "ven", ".", "SL", "OT", "_", "IN", "PUT", "\u0120+", "\u0120slot", ",", "\u0120input", ".", "get", "(", "slot", "));", "\u0120if", "\u0120(", "output", "\u0120!=", "\u0120null", "\u0120&&", "\u0120slot", "\u0120<", "\u0120output", ".", "size", "())", "\u0120master", ".", "inv", ".", "set", "In", "ventory", "Slot", "Contents", "(", "Tile", "Steam", "O", "ven", ".", "SL", "OT", "_", "OU", "TP", "UT", "\u0120+", "\u0120slot", ",", "\u0120output", ".", "get", "(", "slot", "));", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["En", "um", "Machine", "Alpha", ".", "STE", "AM", "_", "OV", "EN", ".", "get", "State", "()", "?"]}
{"function": "public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (obj instanceof ErrorPage) { ErrorPage other = (ErrorPage) obj; boolean rtn = true; rtn = ObjectUtils.nullSafeEquals(getExceptionName(), other.getExceptionName()); rtn = rtn && ObjectUtils.nullSafeEquals(this.path, other.path); rtn = rtn && this.status == other.status; return rtn; } return false; }", "text": "Thanks for the suggestion. Rather than assigning rtn on 117 and then again on line 118, the two could be combined:  boolean rtn = ObjectUtils.nullSafeEquals(getExceptionName(), other.getExceptionName());", "function_tokens": ["public", "\u0120boolean", "\u0120equals", "(", "Object", "\u0120obj", ")", "\u0120{", "\u0120if", "\u0120(", "this", "\u0120==", "\u0120obj", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "obj", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "obj", "\u0120instance", "of", "\u0120Error", "Page", ")", "\u0120{", "\u0120Error", "Page", "\u0120other", "\u0120=", "\u0120(", "Error", "Page", ")", "\u0120obj", ";", "\u0120boolean", "\u0120r", "tn", "\u0120=", "\u0120true", ";", "\u0120r", "tn", "\u0120=", "\u0120Object", "Ut", "ils", ".", "null", "Safe", "Equ", "als", "(", "get", "Exception", "Name", "(),", "\u0120other", ".", "get", "Exception", "Name", "());", "\u0120r", "tn", "\u0120=", "\u0120r", "tn", "\u0120&&", "\u0120Object", "Ut", "ils", ".", "null", "Safe", "Equ", "als", "(", "this", ".", "path", ",", "\u0120other", ".", "path", ");", "\u0120r", "tn", "\u0120=", "\u0120r", "tn", "\u0120&&", "\u0120this", ".", "status", "\u0120==", "\u0120other", ".", "status", ";", "\u0120return", "\u0120r", "tn", ";", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Thanks", "\u0120for", "\u0120the", "\u0120suggestion", ".", "\u0120Rather", "\u0120than", "\u0120assigning", "\u0120r", "tn", "\u0120on", "\u0120117", "\u0120and", "\u0120then", "\u0120again", "\u0120on", "\u0120line", "\u0120118", ",", "\u0120the", "\u0120two", "\u0120could", "\u0120be", "\u0120combined", ":", "\u0120", "\u0120boolean", "\u0120r", "tn", "\u0120=", "\u0120Object", "Ut", "ils", ".", "null", "Safe", "Equ", "als", "(", "get", "Exception", "Name", "(),", "\u0120other", ".", "get", "Exception", "Name", "());"]}
{"function": "protected boolean shouldNotFilter(HttpServletRequest request) { final HttpSession session = request.getSession(false); if (session != null && !session.isNew()) { log.debug(\"User {} has a session: {}\", request.getRemoteUser(), session.getId()); log.debug(\"Max inactive interval: {}\", session.getMaxInactiveInterval()); final Instant ctime = Instant.ofEpochMilli(session.getCreationTime()); final Instant atime = Instant.ofEpochMilli(session.getLastAccessedTime()); log.debug(\"Session creation time: {}, last access time: {}\", ctime, atime); return true; } else { log.debug(\"User {} does not have a session\", request.getRemoteUser()); } return REST_API_SERVLET_PATH.equalsIgnoreCase(request.getServletPath()); }", "text": "Consider wrapping lines 47 - 49 in a log.isDebugEnabled() conditional.", "function_tokens": ["protected", "\u0120boolean", "\u0120should", "Not", "Filter", "(", "Http", "Serv", "let", "Request", "\u0120request", ")", "\u0120{", "\u0120final", "\u0120H", "ttp", "Session", "\u0120session", "\u0120=", "\u0120request", ".", "get", "Session", "(", "false", ");", "\u0120if", "\u0120(", "session", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "session", ".", "is", "New", "())", "\u0120{", "\u0120log", ".", "debug", "(\"", "User", "\u0120{}", "\u0120has", "\u0120a", "\u0120session", ":", "\u0120{}", "\",", "\u0120request", ".", "get", "Remote", "User", "(),", "\u0120session", ".", "get", "Id", "());", "\u0120log", ".", "debug", "(\"", "Max", "\u0120inactive", "\u0120interval", ":", "\u0120{}", "\",", "\u0120session", ".", "get", "Max", "In", "active", "Inter", "val", "());", "\u0120final", "\u0120Instant", "\u0120c", "time", "\u0120=", "\u0120Instant", ".", "of", "Ep", "och", "Mill", "i", "(", "session", ".", "get", "Cre", "ation", "Time", "());", "\u0120final", "\u0120Instant", "\u0120at", "ime", "\u0120=", "\u0120Instant", ".", "of", "Ep", "och", "Mill", "i", "(", "session", ".", "get", "Last", "Access", "ed", "Time", "());", "\u0120log", ".", "debug", "(\"", "Session", "\u0120creation", "\u0120time", ":", "\u0120{", "},", "\u0120last", "\u0120access", "\u0120time", ":", "\u0120{}", "\",", "\u0120c", "time", ",", "\u0120at", "ime", ");", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "debug", "(\"", "User", "\u0120{}", "\u0120does", "\u0120not", "\u0120have", "\u0120a", "\u0120session", "\",", "\u0120request", ".", "get", "Remote", "User", "());", "\u0120}", "\u0120return", "\u0120REST", "_", "API", "_", "SER", "V", "LET", "_", "PATH", ".", "equ", "als", "Ign", "ore", "Case", "(", "request", ".", "get", "Serv", "let", "Path", "());", "\u0120}"], "docstring_tokens": ["Consider", "\u0120wrapping", "\u0120lines", "\u012047", "\u0120-", "\u012049", "\u0120in", "\u0120a", "\u0120log", ".", "is", "Debug", "Enabled", "()", "\u0120conditional", "."]}
{"function": "private VolumeType getType() { if (!getStorageDomain().getStorageType().isOpenStackDomain() && getParameters().getVolumeFormat() == VolumeFormat.RAW) { return VolumeType.Preallocated; } return VolumeType.Sparse; }", "text": "This is very fragile, and will break when we add new storage type. Better check for the storage types (block or file?). Also, this change is possible only when creating volumes with vdsm supporting deferred preallocation, or it may cause very bad performance regression when creating big raw images. This is probably not the place to do these checks, we probably need to modify the code creating new volumes, or the code creating and copying volumes.", "function_tokens": ["private", "\u0120Volume", "Type", "\u0120get", "Type", "()", "\u0120{", "\u0120if", "\u0120(!", "get", "Storage", "Domain", "().", "get", "Storage", "Type", "().", "is", "Open", "Stack", "Domain", "()", "\u0120&&", "\u0120get", "Parameters", "().", "get", "Volume", "Format", "()", "\u0120==", "\u0120Volume", "Format", ".", "RAW", ")", "\u0120{", "\u0120return", "\u0120Volume", "Type", ".", "Pre", "all", "ocated", ";", "\u0120}", "\u0120return", "\u0120Volume", "Type", ".", "S", "parse", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120very", "\u0120fragile", ",", "\u0120and", "\u0120will", "\u0120break", "\u0120when", "\u0120we", "\u0120add", "\u0120new", "\u0120storage", "\u0120type", ".", "\u0120Better", "\u0120check", "\u0120for", "\u0120the", "\u0120storage", "\u0120types", "\u0120(", "block", "\u0120or", "\u0120file", "?).", "\u0120Also", ",", "\u0120this", "\u0120change", "\u0120is", "\u0120possible", "\u0120only", "\u0120when", "\u0120creating", "\u0120volumes", "\u0120with", "\u0120v", "d", "sm", "\u0120supporting", "\u0120deferred", "\u0120pre", "all", "ocation", ",", "\u0120or", "\u0120it", "\u0120may", "\u0120cause", "\u0120very", "\u0120bad", "\u0120performance", "\u0120regression", "\u0120when", "\u0120creating", "\u0120big", "\u0120raw", "\u0120images", ".", "\u0120This", "\u0120is", "\u0120probably", "\u0120not", "\u0120the", "\u0120place", "\u0120to", "\u0120do", "\u0120these", "\u0120checks", ",", "\u0120we", "\u0120probably", "\u0120need", "\u0120to", "\u0120modify", "\u0120the", "\u0120code", "\u0120creating", "\u0120new", "\u0120volumes", ",", "\u0120or", "\u0120the", "\u0120code", "\u0120creating", "\u0120and", "\u0120copying", "\u0120volumes", "."]}
{"function": "private void addVersionAndBranchTags(String remotePath, CVSTag[] tags) { TagCacheEntry entry = getTagCacheEntryFor(remotePath, true); entry.accessed(); for (int i = 0; i < tags.length; i++) { if (tags[i].getType() != CVSTag.DATE) { if (!getAllKnownTagsForParents(entry).contains(tags[i])) { removeTagFromChildrenCacheEntries(entry, tags[i], false); entry.tags.add(tags[i]); } } } }", "text": "It's not safe, because if this was the last tag for this entry, this entry will be removed, but I understand you don't like the boolean in the signature of the method. I changed the method that it always removes tags only from children and where it's necessary I added removing the tag from current entry. Should be more clear now.", "function_tokens": ["private", "\u0120void", "\u0120add", "Version", "And", "B", "ranch", "Tags", "(", "String", "\u0120remote", "Path", ",", "\u0120CV", "ST", "ag", "[]", "\u0120tags", ")", "\u0120{", "\u0120Tag", "Cache", "Entry", "\u0120entry", "\u0120=", "\u0120get", "Tag", "Cache", "Entry", "For", "(", "remote", "Path", ",", "\u0120true", ");", "\u0120entry", ".", "access", "ed", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120tags", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "tags", "[", "i", "].", "get", "Type", "()", "\u0120!=", "\u0120CV", "ST", "ag", ".", "D", "ATE", ")", "\u0120{", "\u0120if", "\u0120(!", "get", "All", "Known", "Tags", "For", "Parents", "(", "entry", ").", "cont", "ains", "(", "tags", "[", "i", "]", "))", "\u0120{", "\u0120remove", "Tag", "From", "Children", "Cache", "Ent", "ries", "(", "entry", ",", "\u0120tags", "[", "i", "],", "\u0120false", ");", "\u0120entry", ".", "tags", ".", "add", "(", "tags", "[", "i", "]);", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["It", "'s", "\u0120not", "\u0120safe", ",", "\u0120because", "\u0120if", "\u0120this", "\u0120was", "\u0120the", "\u0120last", "\u0120tag", "\u0120for", "\u0120this", "\u0120entry", ",", "\u0120this", "\u0120entry", "\u0120will", "\u0120be", "\u0120removed", ",", "\u0120but", "\u0120I", "\u0120understand", "\u0120you", "\u0120don", "'t", "\u0120like", "\u0120the", "\u0120boolean", "\u0120in", "\u0120the", "\u0120signature", "\u0120of", "\u0120the", "\u0120method", ".", "\u0120I", "\u0120changed", "\u0120the", "\u0120method", "\u0120that", "\u0120it", "\u0120always", "\u0120removes", "\u0120tags", "\u0120only", "\u0120from", "\u0120children", "\u0120and", "\u0120where", "\u0120it", "'s", "\u0120necessary", "\u0120I", "\u0120added", "\u0120removing", "\u0120the", "\u0120tag", "\u0120from", "\u0120current", "\u0120entry", ".", "\u0120Should", "\u0120be", "\u0120more", "\u0120clear", "\u0120now", "."]}
{"function": "public QueryResponse getSpecies() throws IOException { Properties properties = new Properties(); properties.load(DBAdaptorConnector.class.getResourceAsStream(\"/eva.properties\")); return setQueryResponse(archiveEvaproDbAdaptor.getSpecies(properties.getProperty(\"eva.version\"), true)); }", "text": "Is there a need to read the prop file for every request?", "function_tokens": ["public", "\u0120Query", "Response", "\u0120get", "Spe", "cies", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120Properties", "\u0120properties", "\u0120=", "\u0120new", "\u0120Properties", "();", "\u0120properties", ".", "load", "(", "DB", "Adapt", "or", "Connector", ".", "class", ".", "get", "Resource", "As", "Stream", "(\"", "/", "eva", ".", "properties", "\")", ");", "\u0120return", "\u0120set", "Query", "Response", "(", "archive", "Ev", "ap", "ro", "Db", "Adapt", "or", ".", "get", "Spe", "cies", "(", "properties", ".", "get", "Property", "(\"", "eva", ".", "version", "\"),", "\u0120true", "));", "\u0120}"], "docstring_tokens": ["Is", "\u0120there", "\u0120a", "\u0120need", "\u0120to", "\u0120read", "\u0120the", "\u0120prop", "\u0120file", "\u0120for", "\u0120every", "\u0120request", "?"]}
{"function": "void messageConsumptionCycle() { while (!killed) { long incrementedClock = 0; UpdateMessage message = null; if (!internalMessageQueue.isEmpty()) message = internalMessageQueue.removeFirst(); else synchronized (externalMessageLock) { if (!externalMessageQueue.isEmpty()) { message = takeExternalMessage(); } else { incrementedClock = ++clock; } } if (message == null) { localUpdateTermination(incrementedClock); while (message == null) { synchronized (externalMessageLock) { while (externalMessageQueue.isEmpty()) { try { externalMessageLock.wait(); } catch (InterruptedException e) { if (killed) return; } } message = takeExternalMessage(); } } } message.receiver.update(message.direction, message.updateElement, null); } }", "text": "Marking this as a high-priority functional correctness issue.", "function_tokens": ["void", "\u0120message", "Cons", "umption", "Cy", "cle", "()", "\u0120{", "\u0120while", "\u0120(!", "killed", ")", "\u0120{", "\u0120long", "\u0120incre", "mented", "Clock", "\u0120=", "\u01200", ";", "\u0120Update", "Message", "\u0120message", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(!", "internal", "Message", "Queue", ".", "is", "Empty", "())", "\u0120message", "\u0120=", "\u0120internal", "Message", "Queue", ".", "remove", "First", "();", "\u0120else", "\u0120synchronized", "\u0120(", "external", "Message", "Lock", ")", "\u0120{", "\u0120if", "\u0120(!", "external", "Message", "Queue", ".", "is", "Empty", "())", "\u0120{", "\u0120message", "\u0120=", "\u0120take", "External", "Message", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120incre", "mented", "Clock", "\u0120=", "\u0120++", "clock", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "message", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120local", "Update", "Ter", "mination", "(", "incre", "mented", "Clock", ");", "\u0120while", "\u0120(", "message", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120synchronized", "\u0120(", "external", "Message", "Lock", ")", "\u0120{", "\u0120while", "\u0120(", "external", "Message", "Queue", ".", "is", "Empty", "())", "\u0120{", "\u0120try", "\u0120{", "\u0120external", "Message", "Lock", ".", "wait", "();", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(", "killed", ")", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120message", "\u0120=", "\u0120take", "External", "Message", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120message", ".", "re", "ceiver", ".", "update", "(", "message", ".", "direction", ",", "\u0120message", ".", "update", "Element", ",", "\u0120null", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Mark", "ing", "\u0120this", "\u0120as", "\u0120a", "\u0120high", "-", "priority", "\u0120functional", "\u0120correctness", "\u0120issue", "."]}
{"function": "public boolean equals(Object o) { if (this == o) { return true; } if (o == null || o.getClass() != getClass()) { return false; } PeriodBroadcastDistributionRule that = (PeriodBroadcastDistributionRule) o; if (!Objects.equals(period, that.period)) { return false; } if (!Objects.equals(includeFuture, that.includeFuture)) { return false; } return Objects.equals(colocatedDataSources, that.colocatedDataSources); }", "text": "includeFuture can't be null. if (includeFuture != that.includeFuture)?", "function_tokens": ["public", "\u0120boolean", "\u0120equals", "(", "Object", "\u0120o", ")", "\u0120{", "\u0120if", "\u0120(", "this", "\u0120==", "\u0120o", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "o", "\u0120==", "\u0120null", "\u0120||", "\u0120o", ".", "get", "Class", "()", "\u0120!=", "\u0120get", "Class", "())", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120Period", "Broad", "cast", "Dist", "ribution", "Rule", "\u0120that", "\u0120=", "\u0120(", "Per", "iod", "Broad", "cast", "Dist", "ribution", "Rule", ")", "\u0120o", ";", "\u0120if", "\u0120(!", "Object", "s", ".", "equ", "als", "(", "period", ",", "\u0120that", ".", "period", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(!", "Object", "s", ".", "equ", "als", "(", "include", "Future", ",", "\u0120that", ".", "include", "Future", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120return", "\u0120Objects", ".", "equ", "als", "(", "col", "ocated", "Data", "Sources", ",", "\u0120that", ".", "col", "ocated", "Data", "Sources", ");", "\u0120}"], "docstring_tokens": ["include", "Future", "\u0120can", "'t", "\u0120be", "\u0120null", ".", "\u0120if", "\u0120(", "include", "Future", "\u0120!=", "\u0120that", ".", "include", "Future", ")?"]}
{"function": "protected HttpClient createHttpClient() throws Error { int port = getPort(); Lookup<AuthSchemeProvider> authSchemeProvider = null; CredentialsProvider credsProvider = new BasicCredentialsProvider(); AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME); if (user != null && user.length() > 0) { credsProvider.setCredentials( authScope, new UsernamePasswordCredentials(user, password) ); } else if (kerberos) { authSchemeProvider = RegistryBuilder.<AuthSchemeProvider>create() .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory(true)) .build(); credsProvider.setCredentials( authScope, new Credentials() { @Override public Principal getUserPrincipal() { return null; } @Override public String getPassword() { return null; } } ); } RequestConfig globalConfig = RequestConfig.custom() .setCookieSpec(CookieSpecs.IGNORE_COOKIES) .setConnectTimeout(timeout) .build(); HttpClientBuilder clientBuilder = HttpClientBuilder.create() .setConnectionManager(new BasicHttpClientConnectionManager(createConnectionSocketFactoryRegistry())) .setDefaultRequestConfig(globalConfig) .setDefaultCredentialsProvider(credsProvider) .setDefaultAuthSchemeRegistry(authSchemeProvider); if (!compress) { clientBuilder.disableContentCompression(); } return new HttpClient45(clientBuilder.build()); }", "text": "Why is this needed?", "function_tokens": ["protected", "\u0120H", "ttp", "Client", "\u0120create", "Http", "Client", "()", "\u0120throws", "\u0120Error", "\u0120{", "\u0120int", "\u0120port", "\u0120=", "\u0120get", "Port", "();", "\u0120Look", "up", "<", "Auth", "Sche", "me", "Provider", ">", "\u0120auth", "Sche", "me", "Provider", "\u0120=", "\u0120null", ";", "\u0120C", "red", "entials", "Provider", "\u0120cred", "s", "Provider", "\u0120=", "\u0120new", "\u0120Basic", "C", "red", "entials", "Provider", "();", "\u0120Auth", "Scope", "\u0120auth", "Scope", "\u0120=", "\u0120new", "\u0120Auth", "Scope", "(", "get", "Host", "(),", "\u0120port", ",", "\u0120Auth", "Scope", ".", "ANY", "_", "RE", "AL", "M", ",", "\u0120Auth", "Scope", ".", "ANY", "_", "S", "CH", "EM", "E", ");", "\u0120if", "\u0120(", "user", "\u0120!=", "\u0120null", "\u0120&&", "\u0120user", ".", "length", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120cred", "s", "Provider", ".", "set", "C", "red", "entials", "(", "\u0120auth", "Scope", ",", "\u0120new", "\u0120Username", "Password", "C", "red", "entials", "(", "user", ",", "\u0120password", ")", "\u0120);", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "ker", "ber", "os", ")", "\u0120{", "\u0120auth", "Sche", "me", "Provider", "\u0120=", "\u0120Registry", "Builder", ".<", "Auth", "Sche", "me", "Provider", ">", "create", "()", "\u0120.", "register", "(", "Auth", "Sche", "mes", ".", "SP", "N", "EG", "O", ",", "\u0120new", "\u0120SP", "Neg", "o", "Sche", "me", "Factory", "(", "true", "))", "\u0120.", "build", "();", "\u0120cred", "s", "Provider", ".", "set", "C", "red", "entials", "(", "\u0120auth", "Scope", ",", "\u0120new", "\u0120C", "red", "entials", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Principal", "\u0120get", "User", "Princ", "ipal", "()", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120String", "\u0120get", "Password", "()", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120}", "\u0120);", "\u0120}", "\u0120Request", "Config", "\u0120global", "Config", "\u0120=", "\u0120Request", "Config", ".", "custom", "()", "\u0120.", "set", "C", "ookie", "Spec", "(", "C", "ookie", "Spe", "cs", ".", "IGN", "ORE", "_", "C", "OOK", "IES", ")", "\u0120.", "set", "Connect", "Timeout", "(", "timeout", ")", "\u0120.", "build", "();", "\u0120H", "ttp", "Client", "Builder", "\u0120client", "Builder", "\u0120=", "\u0120H", "ttp", "Client", "Builder", ".", "create", "()", "\u0120.", "set", "Connection", "Manager", "(", "new", "\u0120Basic", "Http", "Client", "Connection", "Manager", "(", "create", "Connection", "Socket", "Factory", "Reg", "istry", "()", "))", "\u0120.", "set", "Default", "Request", "Config", "(", "global", "Config", ")", "\u0120.", "set", "Default", "C", "red", "entials", "Provider", "(", "c", "red", "s", "Provider", ")", "\u0120.", "set", "Default", "Auth", "Sche", "me", "Reg", "istry", "(", "auth", "Sche", "me", "Provider", ");", "\u0120if", "\u0120(!", "comp", "ress", ")", "\u0120{", "\u0120client", "Builder", ".", "disable", "Content", "Comp", "ression", "();", "\u0120}", "\u0120return", "\u0120new", "\u0120H", "ttp", "Client", "45", "(", "client", "Builder", ".", "build", "());", "\u0120}"], "docstring_tokens": ["Why", "\u0120is", "\u0120this", "\u0120needed", "?"]}
{"function": "public void bindPubSubProducer(String name, MessageChannel moduleOutputChannel, Properties properties) { validateProducerProperties(name, properties, SUPPORTED_PUBSUB_PRODUCER_PROPERTIES); RabbitPropertiesAccessor accessor = new RabbitPropertiesAccessor(properties); String exchangeName = applyPrefix(accessor.getPrefix(this.defaultPrefix), name); declareExchangeIfNotPresent(new FanoutExchange(exchangeName)); AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(determineRabbitTemplate(accessor)); endpoint.setExchangeName(exchangeName); endpoint.setRoutingKey(name); configureOutboundHandler(endpoint, accessor); doRegisterProducer(name, moduleOutputChannel, endpoint, accessor); }", "text": "Wouldn't you want this to be a TopicExchange as well, instead of a FanoutExchange?", "function_tokens": ["public", "\u0120void", "\u0120bind", "Pub", "Sub", "Produ", "cer", "(", "String", "\u0120name", ",", "\u0120Message", "Channel", "\u0120module", "Output", "Channel", ",", "\u0120Properties", "\u0120properties", ")", "\u0120{", "\u0120validate", "Produ", "cer", "Pro", "perties", "(", "name", ",", "\u0120properties", ",", "\u0120SUPPORT", "ED", "_", "PU", "BS", "UB", "_", "PR", "OD", "UC", "ER", "_", "PR", "OP", "ERT", "IES", ");", "\u0120Rabbit", "Pro", "perties", "Access", "or", "\u0120access", "or", "\u0120=", "\u0120new", "\u0120Rabbit", "Pro", "perties", "Access", "or", "(", "properties", ");", "\u0120String", "\u0120exchange", "Name", "\u0120=", "\u0120apply", "Pref", "ix", "(", "access", "or", ".", "get", "Pref", "ix", "(", "this", ".", "default", "Pref", "ix", "),", "\u0120name", ");", "\u0120declare", "Ex", "change", "If", "Not", "Present", "(", "new", "\u0120Fan", "out", "Ex", "change", "(", "ex", "change", "Name", "));", "\u0120Am", "q", "p", "Out", "bound", "End", "point", "\u0120endpoint", "\u0120=", "\u0120new", "\u0120Am", "q", "p", "Out", "bound", "End", "point", "(", "d", "eter", "mine", "R", "abbit", "Template", "(", "access", "or", "));", "\u0120endpoint", ".", "set", "Ex", "change", "Name", "(", "ex", "change", "Name", ");", "\u0120endpoint", ".", "set", "R", "outing", "Key", "(", "name", ");", "\u0120configure", "Out", "bound", "Handler", "(", "end", "point", ",", "\u0120access", "or", ");", "\u0120do", "Register", "Produ", "cer", "(", "name", ",", "\u0120module", "Output", "Channel", ",", "\u0120endpoint", ",", "\u0120access", "or", ");", "\u0120}"], "docstring_tokens": ["Would", "n", "'t", "\u0120you", "\u0120want", "\u0120this", "\u0120to", "\u0120be", "\u0120a", "\u0120Topic", "Ex", "change", "\u0120as", "\u0120well", ",", "\u0120instead", "\u0120of", "\u0120a", "\u0120Fan", "out", "Ex", "change", "?"]}
{"function": "private List<KeyRange> getRegionRowKeyRanges() throws SQLException { List<HRegionLocation> regionLocations = getRegionBoundaries(scanGrouper); List<KeyRange> regionKeyRanges = Lists.newArrayListWithExpectedSize(regionLocations.size()); for(HRegionLocation regionLocation : regionLocations){ HRegionInfo regionInfo = regionLocation.getRegionInfo(); KeyRange range = KeyRange.getKeyRange(regionInfo.getStartKey(), true, regionInfo.getEndKey(), false); regionKeyRanges.add(range); } return regionKeyRanges; }", "text": "Could you change \"for(\" to \"for (\"? Other places too.", "function_tokens": ["private", "\u0120List", "<", "Key", "Range", ">", "\u0120get", "Region", "Row", "Key", "R", "anges", "()", "\u0120throws", "\u0120SQ", "LE", "x", "ception", "\u0120{", "\u0120List", "<", "H", "Region", "Location", ">", "\u0120region", "L", "ocations", "\u0120=", "\u0120get", "Region", "Bound", "aries", "(", "scan", "G", "rou", "per", ");", "\u0120List", "<", "Key", "Range", ">", "\u0120region", "Key", "R", "anges", "\u0120=", "\u0120Lists", ".", "new", "Array", "List", "With", "Ex", "pected", "Size", "(", "region", "L", "ocations", ".", "size", "());", "\u0120for", "(", "H", "Region", "Location", "\u0120region", "Location", "\u0120:", "\u0120region", "L", "ocations", "){", "\u0120H", "Region", "Info", "\u0120region", "Info", "\u0120=", "\u0120region", "Location", ".", "get", "Region", "Info", "();", "\u0120Key", "Range", "\u0120range", "\u0120=", "\u0120Key", "Range", ".", "get", "Key", "Range", "(", "region", "Info", ".", "get", "Start", "Key", "(),", "\u0120true", ",", "\u0120region", "Info", ".", "get", "End", "Key", "(),", "\u0120false", ");", "\u0120region", "Key", "R", "anges", ".", "add", "(", "range", ");", "\u0120}", "\u0120return", "\u0120region", "Key", "R", "anges", ";", "\u0120}"], "docstring_tokens": ["Could", "\u0120you", "\u0120change", "\u0120\"", "for", "(\"", "\u0120to", "\u0120\"", "for", "\u0120(\"", "?", "\u0120Other", "\u0120places", "\u0120too", "."]}
{"function": "public void handleDelete(ActionParameters params) throws ActionException { final User user = params.getUser(); final long id = ConversionHelper.getLong(params.getRequiredParam(PARAM_ID), -1); if (!service.canModifyCategory(user, id)) { throw new ActionDeniedException(\"Tried to delete category: \" + id); } try { layerService.delete(new long [] {id}); } catch (ServiceException e) { LOG.warn(e); throw new ActionException(\"Failed to delete layers\"); } AuditLog.user(params.getClientIp(), params.getUser()) .withParam(\"id\", id) .deleted(AuditLog.ResourceType.MYPLACES_LAYER); JSONObject response = new JSONObject(); JSONHelper.putValue(response, KEY_SUCCESS, true); ResponseHelper.writeResponse(params, response); }", "text": "Prefer ActionParameters.getRequiredParamLong(PARAM_ID) instead. If the id is not a long we don't want to fail with ActionDeniedException but with a ActionParamsExcepton instead.", "function_tokens": ["public", "\u0120void", "\u0120handle", "Delete", "(", "Action", "Parameters", "\u0120params", ")", "\u0120throws", "\u0120Action", "Exception", "\u0120{", "\u0120final", "\u0120User", "\u0120user", "\u0120=", "\u0120params", ".", "get", "User", "();", "\u0120final", "\u0120long", "\u0120id", "\u0120=", "\u0120Conversion", "Helper", ".", "get", "Long", "(", "params", ".", "get", "Required", "Param", "(", "PAR", "AM", "_", "ID", "),", "\u0120-", "1", ");", "\u0120if", "\u0120(!", "service", ".", "can", "Mod", "ify", "Category", "(", "user", ",", "\u0120id", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Action", "Den", "ied", "Exception", "(\"", "T", "ried", "\u0120to", "\u0120delete", "\u0120category", ":", "\u0120\"", "\u0120+", "\u0120id", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120layer", "Service", ".", "delete", "(", "new", "\u0120long", "\u0120[]", "\u0120{", "id", "});", "\u0120}", "\u0120catch", "\u0120(", "Service", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "warn", "(", "e", ");", "\u0120throw", "\u0120new", "\u0120Action", "Exception", "(\"", "F", "ailed", "\u0120to", "\u0120delete", "\u0120layers", "\");", "\u0120}", "\u0120Audit", "Log", ".", "user", "(", "params", ".", "get", "Client", "I", "p", "(),", "\u0120params", ".", "get", "User", "())", "\u0120.", "with", "Param", "(\"", "id", "\",", "\u0120id", ")", "\u0120.", "de", "leted", "(", "Aud", "it", "Log", ".", "Resource", "Type", ".", "MY", "PL", "AC", "ES", "_", "L", "AY", "ER", ");", "\u0120JSON", "Object", "\u0120response", "\u0120=", "\u0120new", "\u0120JSON", "Object", "();", "\u0120JSON", "Helper", ".", "put", "Value", "(", "response", ",", "\u0120KEY", "_", "SU", "CC", "ESS", ",", "\u0120true", ");", "\u0120Response", "Helper", ".", "write", "Response", "(", "params", ",", "\u0120response", ");", "\u0120}"], "docstring_tokens": ["Pre", "fer", "\u0120Action", "Parameters", ".", "get", "Required", "Param", "Long", "(", "PAR", "AM", "_", "ID", ")", "\u0120instead", ".", "\u0120If", "\u0120the", "\u0120id", "\u0120is", "\u0120not", "\u0120a", "\u0120long", "\u0120we", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120fail", "\u0120with", "\u0120Action", "Den", "ied", "Exception", "\u0120but", "\u0120with", "\u0120a", "\u0120Action", "Par", "ams", "Except", "on", "\u0120instead", "."]}
{"function": "private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) { Set<LoadBalancer> loadBalancers = new HashSet<>(); Set<TargetGroup> targetGroups = new HashSet<>(); if (StackType.DATALAKE.equals(source.getType())) { LOGGER.info(\"Setting up load balancers for stack {}\", source.getName()); Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack); Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream() .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName())) .collect(Collectors.toSet()); if (!knoxGatewayGroups.isEmpty()) { LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\"); TargetGroup targetGroup = new TargetGroup(); targetGroup.setType(TargetGroupType.KNOX.name()); targetGroup.setInstanceGroups(knoxGatewayGroups); targetGroups.add(targetGroup); knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup)); } } if (!targetGroups.isEmpty()) { LoadBalancer loadBalancer = new LoadBalancer(); loadBalancer.setStack(stack); loadBalancer.setType(LoadBalancerType.PRIVATE.name()); loadBalancer.setTargetGroups(targetGroups); targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer)); loadBalancers.add(loadBalancer); } return loadBalancers; }", "text": "Should this be in an entitlement?", "function_tokens": ["private", "\u0120Set", "<", "Load", "Bal", "ancer", ">", "\u0120create", "Load", "Bal", "ancers", "(", "Stack", "V", "4", "Request", "\u0120source", ",", "\u0120Stack", "\u0120stack", ")", "\u0120{", "\u0120Set", "<", "Load", "Bal", "ancer", ">", "\u0120load", "Bal", "ancers", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120Set", "<", "Target", "Group", ">", "\u0120target", "G", "roups", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120if", "\u0120(", "Stack", "Type", ".", "D", "AT", "AL", "A", "KE", ".", "equ", "als", "(", "source", ".", "get", "Type", "()", "))", "\u0120{", "\u0120LOG", "GER", ".", "info", "(\"", "Setting", "\u0120up", "\u0120load", "\u0120bal", "ancers", "\u0120for", "\u0120stack", "\u0120{}", "\",", "\u0120source", ".", "get", "Name", "());", "\u0120Set", "<", "String", ">", "\u0120kn", "ox", "Gate", "way", "Group", "Names", "\u0120=", "\u0120load", "Bal", "ancer", "Config", "Service", ".", "get", "Kn", "ox", "Gate", "way", "G", "roups", "(", "stack", ");", "\u0120Set", "<", "Instance", "Group", ">", "\u0120kn", "ox", "Gate", "way", "G", "roups", "\u0120=", "\u0120stack", ".", "get", "Instance", "G", "roups", "().", "stream", "()", "\u0120.", "filter", "(", "ig", "\u0120->", "\u0120kn", "ox", "Gate", "way", "Group", "Names", ".", "cont", "ains", "(", "ig", ".", "get", "Group", "Name", "()", "))", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "Set", "());", "\u0120if", "\u0120(!", "kn", "ox", "Gate", "way", "G", "roups", ".", "is", "Empty", "())", "\u0120{", "\u0120LOG", "GER", ".", "info", "(\"", "Kn", "ox", "\u0120gateway", "\u0120instance", "\u0120found", ";", "\u0120enabling", "\u0120Knox", "\u0120load", "\u0120bal", "ancer", "\u0120configuration", ".\"", ");", "\u0120Target", "Group", "\u0120target", "Group", "\u0120=", "\u0120new", "\u0120Target", "Group", "();", "\u0120target", "Group", ".", "set", "Type", "(", "Target", "Group", "Type", ".", "K", "NO", "X", ".", "name", "());", "\u0120target", "Group", ".", "set", "Instance", "G", "roups", "(", "kn", "ox", "Gate", "way", "G", "roups", ");", "\u0120target", "G", "roups", ".", "add", "(", "target", "Group", ");", "\u0120kn", "ox", "Gate", "way", "G", "roups", ".", "for", "Each", "(", "ig", "\u0120->", "\u0120ig", ".", "add", "Target", "Group", "(", "target", "Group", "));", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "target", "G", "roups", ".", "is", "Empty", "())", "\u0120{", "\u0120Load", "Bal", "ancer", "\u0120load", "Bal", "ancer", "\u0120=", "\u0120new", "\u0120Load", "Bal", "ancer", "();", "\u0120load", "Bal", "ancer", ".", "set", "Stack", "(", "stack", ");", "\u0120load", "Bal", "ancer", ".", "set", "Type", "(", "Load", "Bal", "ancer", "Type", ".", "PR", "IV", "ATE", ".", "name", "());", "\u0120load", "Bal", "ancer", ".", "set", "Target", "G", "roups", "(", "target", "G", "roups", ");", "\u0120target", "G", "roups", ".", "for", "Each", "(", "tg", "\u0120->", "\u0120t", "g", ".", "set", "Load", "Bal", "ancer", "(", "load", "Bal", "ancer", "));", "\u0120load", "Bal", "ancers", ".", "add", "(", "load", "Bal", "ancer", ");", "\u0120}", "\u0120return", "\u0120load", "Bal", "ancers", ";", "\u0120}"], "docstring_tokens": ["Should", "\u0120this", "\u0120be", "\u0120in", "\u0120an", "\u0120entitlement", "?"]}
{"function": "public static void sendGeoIntent(@NonNull Activity activity, @NonNull Location location, String placeName) { String geoStr = \"geo:0,0?q=\" + location.getLatitude() + \",\" + location.getLongitude(); if (!TextUtils.isEmpty(placeName)) { geoStr += \"(\" + placeName +\")\"; } try { activity.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(geoStr))); } catch (ActivityNotFoundException e) { FeedbackUtil.showMessage(activity, R.string.error_no_maps_app); } }", "text": "If we end up going with this solution, please call Uri.encode on this appended label string (as directed in <LINK_0> Also, please add a space after the second '+' to resolve the checkstyle failure in CI.", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120send", "Ge", "o", "Int", "ent", "(", "@", "Non", "Null", "\u0120Activity", "\u0120activity", ",", "\u0120@", "Non", "Null", "\u0120Location", "\u0120location", ",", "\u0120String", "\u0120place", "Name", ")", "\u0120{", "\u0120String", "\u0120geo", "Str", "\u0120=", "\u0120\"", "ge", "o", ":", "0", ",", "0", "?", "q", "=\"", "\u0120+", "\u0120location", ".", "get", "Lat", "itude", "()", "\u0120+", "\u0120\"", ",\"", "\u0120+", "\u0120location", ".", "get", "Long", "itude", "();", "\u0120if", "\u0120(!", "Text", "Ut", "ils", ".", "is", "Empty", "(", "place", "Name", "))", "\u0120{", "\u0120geo", "Str", "\u0120+=", "\u0120\"", "(\"", "\u0120+", "\u0120place", "Name", "\u0120+", "\")", "\";", "\u0120}", "\u0120try", "\u0120{", "\u0120activity", ".", "start", "Activity", "(", "new", "\u0120Intent", "(", "Int", "ent", ".", "ACTION", "_", "VIEW", ",", "\u0120Uri", ".", "parse", "(", "ge", "o", "Str", "))", ");", "\u0120}", "\u0120catch", "\u0120(", "Activity", "Not", "Found", "Exception", "\u0120e", ")", "\u0120{", "\u0120Feedback", "Ut", "il", ".", "show", "Message", "(", "activity", ",", "\u0120R", ".", "string", ".", "error", "_", "no", "_", "maps", "_", "app", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["If", "\u0120we", "\u0120end", "\u0120up", "\u0120going", "\u0120with", "\u0120this", "\u0120solution", ",", "\u0120please", "\u0120call", "\u0120Uri", ".", "en", "code", "\u0120on", "\u0120this", "\u0120app", "ended", "\u0120label", "\u0120string", "\u0120(", "as", "\u0120directed", "\u0120in", "\u0120<", "L", "INK", "_", "0", ">", "\u0120Also", ",", "\u0120please", "\u0120add", "\u0120a", "\u0120space", "\u0120after", "\u0120the", "\u0120second", "\u0120'", "+", "'", "\u0120to", "\u0120resolve", "\u0120the", "\u0120check", "style", "\u0120failure", "\u0120in", "\u0120CI", "."]}
{"function": "protected void delete(Context context, Integer id) throws AuthorizeException { try { MetadataSchema metadataSchema = metadataSchemaService.find(context, id); if (metadataSchema == null) { throw new ResourceNotFoundException(\"metadata schema with id: \" + id + \" not found\"); } metadataSchemaService.delete(context, metadataSchema); } catch (SQLException e) { throw new RuntimeException(e.getMessage(), e); } }", "text": "Again, getMessage() should be replaced with a more informative error", "function_tokens": ["protected", "\u0120void", "\u0120delete", "(", "Context", "\u0120context", ",", "\u0120Integer", "\u0120id", ")", "\u0120throws", "\u0120Author", "ize", "Exception", "\u0120{", "\u0120try", "\u0120{", "\u0120Met", "adata", "Sche", "ma", "\u0120metadata", "Sche", "ma", "\u0120=", "\u0120metadata", "Sche", "ma", "Service", ".", "find", "(", "context", ",", "\u0120id", ");", "\u0120if", "\u0120(", "metadata", "Sche", "ma", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Not", "Found", "Exception", "(\"", "metadata", "\u0120schema", "\u0120with", "\u0120id", ":", "\u0120\"", "\u0120+", "\u0120id", "\u0120+", "\u0120\"", "\u0120not", "\u0120found", "\");", "\u0120}", "\u0120metadata", "Sche", "ma", "Service", ".", "delete", "(", "context", ",", "\u0120metadata", "Sche", "ma", ");", "\u0120}", "\u0120catch", "\u0120(", "S", "Q", "LE", "x", "ception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ".", "get", "Message", "(),", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Again", ",", "\u0120get", "Message", "()", "\u0120should", "\u0120be", "\u0120replaced", "\u0120with", "\u0120a", "\u0120more", "\u0120informative", "\u0120error"]}
{"function": "public ScoredCandidates<T> generate( T content, ResultDescription desc, EquivToTelescopeResults equivToTelescopeResults ) { DefaultScoredCandidates.Builder<T> candidates = DefaultScoredCandidates.fromSource(\"Alias\"); desc.startStage(\"Resolving aliases:\"); EquivToTelescopeComponent generatorComponent = EquivToTelescopeComponent.create(); generatorComponent.setComponentName(\"Alias Equivalence Generator\"); for (Alias alias : content.getAliases()) { desc.appendText(alias.toString()); } desc.finishStage(); Set<T> resolvedContentForAliases = content.getAliases().parallelStream() .filter(alias -> namespaceToMatch == null || alias.getNamespace().equals(namespaceToMatch)) .map(this::getLookupEntries) .flatMap(MoreStreams::stream) .map(this::getResolvedContent) .map(ResolvedContent::getAllResolvedResults) .flatMap(MoreStreams::stream) .filter(cls::isInstance) .map(cls::cast) .collect(MoreCollectors.toImmutableSet()); for (T identified : resolvedContentForAliases) { if (java.util.Objects.equals(content.getId(), identified.getId())) { continue; } if (identified.isActivelyPublished()) { candidates.addEquivalent(identified, Score.nullScore()); desc.appendText(\"Resolved %s\", identified.getCanonicalUri()); } } equivToTelescopeResults.addGeneratorResult(generatorComponent); return candidates.build(); }", "text": "Shouldn't the description be a bit more specific, e.g. which alias matched, and the stage finished at the end of the process?", "function_tokens": ["public", "\u0120Sc", "ored", "Cand", "idates", "<", "T", ">", "\u0120generate", "(", "\u0120T", "\u0120content", ",", "\u0120Result", "Description", "\u0120desc", ",", "\u0120Equ", "iv", "To", "Tel", "esc", "ope", "Results", "\u0120equ", "iv", "To", "Tel", "esc", "ope", "Results", "\u0120)", "\u0120{", "\u0120Default", "Sc", "ored", "Cand", "idates", ".", "Builder", "<", "T", ">", "\u0120candidates", "\u0120=", "\u0120Default", "Sc", "ored", "Cand", "idates", ".", "from", "Source", "(\"", "Alias", "\");", "\u0120desc", ".", "start", "Stage", "(\"", "Res", "olving", "\u0120aliases", ":\"", ");", "\u0120Equ", "iv", "To", "Tel", "esc", "ope", "Component", "\u0120generator", "Component", "\u0120=", "\u0120Equ", "iv", "To", "Tel", "esc", "ope", "Component", ".", "create", "();", "\u0120generator", "Component", ".", "set", "Component", "Name", "(\"", "Alias", "\u0120Equ", "ival", "ence", "\u0120Generator", "\");", "\u0120for", "\u0120(", "Alias", "\u0120alias", "\u0120:", "\u0120content", ".", "get", "Ali", "ases", "())", "\u0120{", "\u0120desc", ".", "append", "Text", "(", "alias", ".", "to", "String", "());", "\u0120}", "\u0120desc", ".", "fin", "ish", "Stage", "();", "\u0120Set", "<", "T", ">", "\u0120resolved", "Content", "For", "Ali", "ases", "\u0120=", "\u0120content", ".", "get", "Ali", "ases", "().", "par", "allel", "Stream", "()", "\u0120.", "filter", "(", "alias", "\u0120->", "\u0120namespace", "To", "Match", "\u0120==", "\u0120null", "\u0120||", "\u0120alias", ".", "get", "Names", "pace", "().", "equ", "als", "(", "names", "pace", "To", "Match", "))", "\u0120.", "map", "(", "this", "::", "get", "Look", "up", "Ent", "ries", ")", "\u0120.", "flat", "Map", "(", "More", "Stream", "s", "::", "stream", ")", "\u0120.", "map", "(", "this", "::", "get", "Res", "olved", "Content", ")", "\u0120.", "map", "(", "Res", "olved", "Content", "::", "get", "All", "Res", "olved", "Results", ")", "\u0120.", "flat", "Map", "(", "More", "Stream", "s", "::", "stream", ")", "\u0120.", "filter", "(", "cl", "s", "::", "is", "Instance", ")", "\u0120.", "map", "(", "cl", "s", "::", "cast", ")", "\u0120.", "collect", "(", "More", "Collect", "ors", ".", "to", "Imm", "utable", "Set", "());", "\u0120for", "\u0120(", "T", "\u0120identified", "\u0120:", "\u0120resolved", "Content", "For", "Ali", "ases", ")", "\u0120{", "\u0120if", "\u0120(", "java", ".", "util", ".", "Object", "s", ".", "equ", "als", "(", "content", ".", "get", "Id", "(),", "\u0120identified", ".", "get", "Id", "()", "))", "\u0120{", "\u0120continue", ";", "\u0120}", "\u0120if", "\u0120(", "identified", ".", "is", "Act", "ively", "Published", "())", "\u0120{", "\u0120candidates", ".", "add", "Equ", "ivalent", "(", "identified", ",", "\u0120Score", ".", "null", "Score", "());", "\u0120desc", ".", "append", "Text", "(\"", "Res", "olved", "\u0120%", "s", "\",", "\u0120identified", ".", "get", "Can", "on", "ical", "U", "ri", "());", "\u0120}", "\u0120}", "\u0120equ", "iv", "To", "Tel", "esc", "ope", "Results", ".", "add", "Gener", "ator", "Result", "(", "gener", "ator", "Component", ");", "\u0120return", "\u0120candidates", ".", "build", "();", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120the", "\u0120description", "\u0120be", "\u0120a", "\u0120bit", "\u0120more", "\u0120specific", ",", "\u0120e", ".", "g", ".", "\u0120which", "\u0120alias", "\u0120matched", ",", "\u0120and", "\u0120the", "\u0120stage", "\u0120finished", "\u0120at", "\u0120the", "\u0120end", "\u0120of", "\u0120the", "\u0120process", "?"]}
{"function": "private void updateQcowCompat() { if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) { getImage().setQcowCompat(QcowCompat.QCOW2_V2); if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) { QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), false); if (qemuImageInfo != null) { getImage().setQcowCompat(qemuImageInfo.getQcowCompat()); } imageDao.update(getImage().getImage()); } } }", "text": "consider extracting to a method as this code is similar to BaseImagesCommand. have a nice day :)", "function_tokens": ["private", "\u0120void", "\u0120update", "Q", "cow", "Compat", "()", "\u0120{", "\u0120if", "\u0120(", "get", "Image", "().", "get", "Volume", "Format", "().", "equ", "als", "(", "Volume", "Format", ".", "C", "OW", "))", "\u0120{", "\u0120get", "Image", "().", "set", "Q", "cow", "Compat", "(", "Q", "cow", "Compat", ".", "Q", "C", "OW", "2", "_", "V", "2", ");", "\u0120if", "\u0120(", "Feature", "Supported", ".", "q", "cow", "Compat", "Supported", "(", "get", "Storage", "Pool", "().", "get", "Comp", "atibility", "Version", "()", "))", "\u0120{", "\u0120Q", "em", "u", "Image", "Info", "\u0120q", "em", "u", "Image", "Info", "\u0120=", "\u0120Images", "Handler", ".", "get", "Q", "em", "u", "Image", "Info", "From", "V", "d", "sm", "(", "get", "Storage", "Pool", "().", "get", "Id", "(),", "\u0120get", "Storage", "Domain", "Id", "(),", "\u0120get", "Image", "().", "get", "Image", "().", "get", "Disk", "Id", "(),", "\u0120get", "Image", "().", "get", "Image", "Id", "(),", "\u0120false", ");", "\u0120if", "\u0120(", "q", "em", "u", "Image", "Info", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120get", "Image", "().", "set", "Q", "cow", "Compat", "(", "q", "em", "u", "Image", "Info", ".", "get", "Q", "cow", "Compat", "());", "\u0120}", "\u0120image", "D", "ao", ".", "update", "(", "get", "Image", "().", "get", "Image", "());", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["consider", "\u0120extracting", "\u0120to", "\u0120a", "\u0120method", "\u0120as", "\u0120this", "\u0120code", "\u0120is", "\u0120similar", "\u0120to", "\u0120Base", "Images", "Command", ".", "\u0120have", "\u0120a", "\u0120nice", "\u0120day", "\u0120:)"]}
{"function": "public void testNotEnoughForMultipleDiskAndDomainsFirstDomainFails() { ArrayList<DiskImage> imagesDisks = mockMultipleSourceImagesForDomain(4, STORAGE_DOMAIN_ID, 4); imagesDisks.addAll(mockMultipleSourceImagesForDomain(4, STORAGE_DOMAIN_ID2, 4)); doReturn(imagesDisks).when(cmd).getSourceImages(); mockStorageDomainDAOGetForStoragePool(15, STORAGE_DOMAIN_ID); mockStorageDomainDAOGetForStoragePool(22, STORAGE_DOMAIN_ID2); assertFalse(\"Validation should fail. First domain should not have enough free space for request.\", cmd.isEnoughSpaceToMergeSnapshots()); }", "text": "can't this be defined as a List<DiskImage> ?", "function_tokens": ["public", "\u0120void", "\u0120test", "Not", "Enough", "For", "Multiple", "Disk", "And", "Dom", "ains", "First", "Domain", "F", "ails", "()", "\u0120{", "\u0120Array", "List", "<", "Disk", "Image", ">", "\u0120images", "Dis", "ks", "\u0120=", "\u0120mock", "Multiple", "Source", "Images", "For", "Domain", "(", "4", ",", "\u0120STOR", "AGE", "_", "DOM", "AIN", "_", "ID", ",", "\u01204", ");", "\u0120images", "Dis", "ks", ".", "add", "All", "(", "m", "ock", "Multiple", "Source", "Images", "For", "Domain", "(", "4", ",", "\u0120STOR", "AGE", "_", "DOM", "AIN", "_", "ID", "2", ",", "\u01204", "));", "\u0120do", "Return", "(", "images", "Dis", "ks", ").", "when", "(", "cmd", ").", "get", "Source", "Images", "();", "\u0120mock", "Storage", "Domain", "DA", "O", "Get", "For", "Storage", "Pool", "(", "15", ",", "\u0120STOR", "AGE", "_", "DOM", "AIN", "_", "ID", ");", "\u0120mock", "Storage", "Domain", "DA", "O", "Get", "For", "Storage", "Pool", "(", "22", ",", "\u0120STOR", "AGE", "_", "DOM", "AIN", "_", "ID", "2", ");", "\u0120assert", "False", "(\"", "Val", "idation", "\u0120should", "\u0120fail", ".", "\u0120First", "\u0120domain", "\u0120should", "\u0120not", "\u0120have", "\u0120enough", "\u0120free", "\u0120space", "\u0120for", "\u0120request", ".\",", "\u0120cmd", ".", "is", "Enough", "Space", "To", "Mer", "ge", "Snap", "shots", "());", "\u0120}"], "docstring_tokens": ["can", "'t", "\u0120this", "\u0120be", "\u0120defined", "\u0120as", "\u0120a", "\u0120List", "<", "Disk", "Image", ">", "\u0120?"]}
{"function": "private boolean executeOnce(final int thisTryNumber, final int totalTriesIntended) { final Connection sshConnection = new Connection(parent.host, parent.port); try { sshConnection.connect(null, sshTimeoutMillis, 0, sshTimeoutMillis); LOGGER.info(\"SSH port is open on {}:{}\", parent.host, parent.port); return true; } catch (IOException e) { LOGGER.error(\"Failed to connect to {}:{} (try {}/{}) - {}\", parent.host, parent.port, thisTryNumber, totalTriesIntended, e.getMessage()); return false; } finally { sshConnection.close(); } }", "text": "While I agree that passing a non-zero value as the connectTimeout argument is a good idea, I don't believe that passing 0 as the readTimeout argument is a good idea. I think that passing zero anywhere will _either_ result in \"no timeout\" or \"a timeout of zero\" and both outcomes are bad (one results in non-robust code, the other results in the situation you reported & are trying to fix).", "function_tokens": ["private", "\u0120boolean", "\u0120execute", "Once", "(", "final", "\u0120int", "\u0120this", "Try", "Number", ",", "\u0120final", "\u0120int", "\u0120total", "T", "ries", "Int", "ended", ")", "\u0120{", "\u0120final", "\u0120Connection", "\u0120ssh", "Connection", "\u0120=", "\u0120new", "\u0120Connection", "(", "parent", ".", "host", ",", "\u0120parent", ".", "port", ");", "\u0120try", "\u0120{", "\u0120ssh", "Connection", ".", "connect", "(", "null", ",", "\u0120ssh", "Timeout", "Mill", "is", ",", "\u01200", ",", "\u0120ssh", "Timeout", "Mill", "is", ");", "\u0120LOG", "GER", ".", "info", "(\"", "SS", "H", "\u0120port", "\u0120is", "\u0120open", "\u0120on", "\u0120{}", ":{", "}", "\",", "\u0120parent", ".", "host", ",", "\u0120parent", ".", "port", ");", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(\"", "F", "ailed", "\u0120to", "\u0120connect", "\u0120to", "\u0120{}", ":{", "}", "\u0120(", "try", "\u0120{}", "/", "{", "})", "\u0120-", "\u0120{}", "\",", "\u0120parent", ".", "host", ",", "\u0120parent", ".", "port", ",", "\u0120this", "Try", "Number", ",", "\u0120total", "T", "ries", "Int", "ended", ",", "\u0120e", ".", "get", "Message", "());", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120finally", "\u0120{", "\u0120ssh", "Connection", ".", "close", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["While", "\u0120I", "\u0120agree", "\u0120that", "\u0120passing", "\u0120a", "\u0120non", "-", "zero", "\u0120value", "\u0120as", "\u0120the", "\u0120connect", "Timeout", "\u0120argument", "\u0120is", "\u0120a", "\u0120good", "\u0120idea", ",", "\u0120I", "\u0120don", "'t", "\u0120believe", "\u0120that", "\u0120passing", "\u01200", "\u0120as", "\u0120the", "\u0120read", "Timeout", "\u0120argument", "\u0120is", "\u0120a", "\u0120good", "\u0120idea", ".", "\u0120I", "\u0120think", "\u0120that", "\u0120passing", "\u0120zero", "\u0120anywhere", "\u0120will", "\u0120_", "either", "_", "\u0120result", "\u0120in", "\u0120\"", "no", "\u0120timeout", "\"", "\u0120or", "\u0120\"", "a", "\u0120timeout", "\u0120of", "\u0120zero", "\"", "\u0120and", "\u0120both", "\u0120outcomes", "\u0120are", "\u0120bad", "\u0120(", "one", "\u0120results", "\u0120in", "\u0120non", "-", "rob", "ust", "\u0120code", ",", "\u0120the", "\u0120other", "\u0120results", "\u0120in", "\u0120the", "\u0120situation", "\u0120you", "\u0120reported", "\u0120&", "\u0120are", "\u0120trying", "\u0120to", "\u0120fix", ")."]}
{"function": "private OnHeapValueHolder<V> invalidateInGetorComputeIfAbsent(MapWrapper<K, V> map, final K key, final ValueHolder<V> value, final Fault<V> fault, final long now) { final AtomicReference<OnHeapValueHolder<V>> toInvalidate = new AtomicReference<OnHeapValueHolder<V>>(); map.computeIfPresent(key, new BiFunction<K, OnHeapValueHolder<V>, OnHeapValueHolder<V>>() { @Override public OnHeapValueHolder<V> apply(K mappedKey, final OnHeapValueHolder<V> mappedValue) { if(mappedValue.equals(fault)) { try { toInvalidate.set(cloneValueHolder(key, value, now, Duration.ZERO, true)); } catch (LimitExceededException ex) { throw new AssertionError(\"Should have already been thrown.\"); } invalidationListener.onInvalidation(key, toInvalidate.get()); return null; } return mappedValue; } }); return toInvalidate.get(); }", "text": "That message is confusing. Just say that it should not be thrown here as sizing is not happening.", "function_tokens": ["private", "\u0120On", "He", "ap", "Value", "H", "older", "<", "V", ">", "\u0120invalid", "ate", "In", "Get", "or", "Comp", "ute", "If", "Abs", "ent", "(", "Map", "Wra", "pper", "<", "K", ",", "\u0120V", ">", "\u0120map", ",", "\u0120final", "\u0120K", "\u0120key", ",", "\u0120final", "\u0120Value", "H", "older", "<", "V", ">", "\u0120value", ",", "\u0120final", "\u0120Fault", "<", "V", ">", "\u0120fault", ",", "\u0120final", "\u0120long", "\u0120now", ")", "\u0120{", "\u0120final", "\u0120Atomic", "Reference", "<", "On", "He", "ap", "Value", "H", "older", "<", "V", ">>", "\u0120to", "Invalid", "ate", "\u0120=", "\u0120new", "\u0120Atomic", "Reference", "<", "On", "He", "ap", "Value", "H", "older", "<", "V", ">>", "();", "\u0120map", ".", "comp", "ute", "If", "Present", "(", "key", ",", "\u0120new", "\u0120Bi", "Function", "<", "K", ",", "\u0120On", "He", "ap", "Value", "H", "older", "<", "V", ">,", "\u0120On", "He", "ap", "Value", "H", "older", "<", "V", ">>", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120On", "He", "ap", "Value", "H", "older", "<", "V", ">", "\u0120apply", "(", "K", "\u0120mapped", "Key", ",", "\u0120final", "\u0120On", "He", "ap", "Value", "H", "older", "<", "V", ">", "\u0120mapped", "Value", ")", "\u0120{", "\u0120if", "(", "m", "apped", "Value", ".", "equ", "als", "(", "f", "ault", "))", "\u0120{", "\u0120try", "\u0120{", "\u0120to", "Invalid", "ate", ".", "set", "(", "clone", "Value", "H", "older", "(", "key", ",", "\u0120value", ",", "\u0120now", ",", "\u0120Duration", ".", "Z", "ERO", ",", "\u0120true", "));", "\u0120}", "\u0120catch", "\u0120(", "Limit", "Ex", "ceed", "ed", "Exception", "\u0120ex", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Ass", "ert", "ion", "Error", "(\"", "Should", "\u0120have", "\u0120already", "\u0120been", "\u0120thrown", ".\"", ");", "\u0120}", "\u0120invalid", "ation", "Listener", ".", "on", "Invalid", "ation", "(", "key", ",", "\u0120to", "Invalid", "ate", ".", "get", "());", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120return", "\u0120mapped", "Value", ";", "\u0120}", "\u0120});", "\u0120return", "\u0120to", "Invalid", "ate", ".", "get", "();", "\u0120}"], "docstring_tokens": ["That", "\u0120message", "\u0120is", "\u0120confusing", ".", "\u0120Just", "\u0120say", "\u0120that", "\u0120it", "\u0120should", "\u0120not", "\u0120be", "\u0120thrown", "\u0120here", "\u0120as", "\u0120sizing", "\u0120is", "\u0120not", "\u0120happening", "."]}
{"function": "public String toResponse() { if (selectionSet instanceof String) { return String.format( \"\\\"%s\\\":%s\", getName(), getSelectionSet().toString().equals(\"\") ? \"{\\\"edges\\\":[]}\" : getSelectionSet().toString() ); } else if (selectionSet instanceof Number) { return String.format( \"\\\"%s\\\":%s\", getName(), getSelectionSet().toString().equals(\"\") ? \"{\\\"edges\\\":[]}\" : getSelectionSet().toString() ); } else { return String.format(\"\\\"%s\\\":%s\", getName(), ((SelectionSet) getSelectionSet()).toResponse()); } }", "text": "Can we combine this case with the one above? if (selectionSet instanceof String || selectionSet instanceOf Number)", "function_tokens": ["public", "\u0120String", "\u0120to", "Response", "()", "\u0120{", "\u0120if", "\u0120(", "selection", "Set", "\u0120instance", "of", "\u0120String", ")", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(", "\u0120\"", "\\\"", "%", "s", "\\\":", "%", "s", "\",", "\u0120get", "Name", "(),", "\u0120get", "Se", "lection", "Set", "().", "to", "String", "().", "equ", "als", "(\"", "\")", "\u0120?", "\u0120\"{", "\\\"", "ed", "ges", "\\", "\":[", "]", "}\"", "\u0120:", "\u0120get", "Se", "lection", "Set", "().", "to", "String", "()", "\u0120);", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "selection", "Set", "\u0120instance", "of", "\u0120Number", ")", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(", "\u0120\"", "\\\"", "%", "s", "\\\":", "%", "s", "\",", "\u0120get", "Name", "(),", "\u0120get", "Se", "lection", "Set", "().", "to", "String", "().", "equ", "als", "(\"", "\")", "\u0120?", "\u0120\"{", "\\\"", "ed", "ges", "\\", "\":[", "]", "}\"", "\u0120:", "\u0120get", "Se", "lection", "Set", "().", "to", "String", "()", "\u0120);", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(\"", "\\\"", "%", "s", "\\\":", "%", "s", "\",", "\u0120get", "Name", "(),", "\u0120((", "Se", "lection", "Set", ")", "\u0120get", "Se", "lection", "Set", "()", ").", "to", "Response", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Can", "\u0120we", "\u0120combine", "\u0120this", "\u0120case", "\u0120with", "\u0120the", "\u0120one", "\u0120above", "?", "\u0120if", "\u0120(", "selection", "Set", "\u0120instance", "of", "\u0120String", "\u0120||", "\u0120selection", "Set", "\u0120instance", "Of", "\u0120Number", ")"]}
{"function": "public <A extends Annotation> ConstraintValidator<A, ?> getInitializedValidator(Type validatedValueType, ConstraintDescriptorImpl<A> descriptor, ConstraintValidatorFactory constraintFactory) { Contracts.assertNotNull( validatedValueType ); Contracts.assertNotNull( descriptor ); Contracts.assertNotNull( constraintFactory ); final CacheKey key = new CacheKey( descriptor.getAnnotation(), validatedValueType, constraintFactory ); if ( constraintValidatorCache.containsKey( key ) ) { @SuppressWarnings(\"unchecked\") ConstraintValidator<A, ?> constraintValidator = (ConstraintValidator<A, ?>) constraintValidatorCache.get( key ); if ( DUMMY_CONSTRAINT_VALIDATOR.equals( constraintValidator ) ) { return null; } else { log.tracef( \"Constraint validator %s found in cache.\", constraintValidator ); return constraintValidator; } } ConstraintValidatorDescriptor<A> validatorTypeDescriptor = findMatchingValidatorClass( descriptor, validatedValueType ); ConstraintValidator<A, ?> constraintValidator = createAndInitializeValidator( constraintFactory, validatorTypeDescriptor, descriptor ); if ( constraintValidator == null ) { putInitializedValidator( validatedValueType, descriptor.getAnnotation(), constraintFactory, DUMMY_CONSTRAINT_VALIDATOR ); return null; } else { putInitializedValidator( validatedValueType, descriptor.getAnnotation(), constraintFactory, constraintValidator ); return constraintValidator; } }", "text": "validatorDescriptor would be nice to be consistent with the naming a few lines below.", "function_tokens": ["public", "\u0120<", "A", "\u0120extends", "\u0120An", "notation", ">", "\u0120Con", "str", "aint", "Valid", "ator", "<", "A", ",", "\u0120?", ">", "\u0120get", "Initialized", "Valid", "ator", "(", "Type", "\u0120validated", "Value", "Type", ",", "\u0120Con", "str", "aint", "Desc", "ript", "or", "Impl", "<", "A", ">", "\u0120descriptor", ",", "\u0120Con", "str", "aint", "Valid", "ator", "Factory", "\u0120constraint", "Factory", ")", "\u0120{", "\u0120Contracts", ".", "assert", "Not", "Null", "(", "\u0120validated", "Value", "Type", "\u0120);", "\u0120Contracts", ".", "assert", "Not", "Null", "(", "\u0120descriptor", "\u0120);", "\u0120Contracts", ".", "assert", "Not", "Null", "(", "\u0120constraint", "Factory", "\u0120);", "\u0120final", "\u0120Cache", "Key", "\u0120key", "\u0120=", "\u0120new", "\u0120Cache", "Key", "(", "\u0120descriptor", ".", "get", "An", "notation", "(),", "\u0120validated", "Value", "Type", ",", "\u0120constraint", "Factory", "\u0120);", "\u0120if", "\u0120(", "\u0120constraint", "Valid", "ator", "Cache", ".", "cont", "ains", "Key", "(", "\u0120key", "\u0120)", "\u0120)", "\u0120{", "\u0120@", "Supp", "ress", "W", "arn", "ings", "(\"", "un", "checked", "\")", "\u0120Con", "str", "aint", "Valid", "ator", "<", "A", ",", "\u0120?", ">", "\u0120constraint", "Valid", "ator", "\u0120=", "\u0120(", "Con", "str", "aint", "Valid", "ator", "<", "A", ",", "\u0120?", ">)", "\u0120constraint", "Valid", "ator", "Cache", ".", "get", "(", "\u0120key", "\u0120);", "\u0120if", "\u0120(", "\u0120D", "UM", "MY", "_", "CON", "ST", "RA", "INT", "_", "VAL", "ID", "ATOR", ".", "equ", "als", "(", "\u0120constraint", "Valid", "ator", "\u0120)", "\u0120)", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "trace", "f", "(", "\u0120\"", "Con", "str", "aint", "\u0120valid", "ator", "\u0120%", "s", "\u0120found", "\u0120in", "\u0120cache", ".\",", "\u0120constraint", "Valid", "ator", "\u0120);", "\u0120return", "\u0120constraint", "Valid", "ator", ";", "\u0120}", "\u0120}", "\u0120Con", "str", "aint", "Valid", "ator", "Desc", "ript", "or", "<", "A", ">", "\u0120valid", "ator", "Type", "Desc", "ript", "or", "\u0120=", "\u0120find", "M", "atching", "Valid", "ator", "Class", "(", "\u0120descriptor", ",", "\u0120validated", "Value", "Type", "\u0120);", "\u0120Con", "str", "aint", "Valid", "ator", "<", "A", ",", "\u0120?", ">", "\u0120constraint", "Valid", "ator", "\u0120=", "\u0120create", "And", "Initial", "ize", "Valid", "ator", "(", "\u0120constraint", "Factory", ",", "\u0120valid", "ator", "Type", "Desc", "ript", "or", ",", "\u0120descriptor", "\u0120);", "\u0120if", "\u0120(", "\u0120constraint", "Valid", "ator", "\u0120==", "\u0120null", "\u0120)", "\u0120{", "\u0120put", "Initialized", "Valid", "ator", "(", "\u0120validated", "Value", "Type", ",", "\u0120descriptor", ".", "get", "An", "notation", "(),", "\u0120constraint", "Factory", ",", "\u0120D", "UM", "MY", "_", "CON", "ST", "RA", "INT", "_", "VAL", "ID", "ATOR", "\u0120);", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120put", "Initialized", "Valid", "ator", "(", "\u0120validated", "Value", "Type", ",", "\u0120descriptor", ".", "get", "An", "notation", "(),", "\u0120constraint", "Factory", ",", "\u0120constraint", "Valid", "ator", "\u0120);", "\u0120return", "\u0120constraint", "Valid", "ator", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["valid", "ator", "Desc", "ript", "or", "\u0120would", "\u0120be", "\u0120nice", "\u0120to", "\u0120be", "\u0120consistent", "\u0120with", "\u0120the", "\u0120naming", "\u0120a", "\u0120few", "\u0120lines", "\u0120below", "."]}
{"function": "private static JAXBContext initOnmsEventParameterContext() { try { return JAXBContext.newInstance(EventParms.class); } catch (JAXBException e) { e.printStackTrace(); } return null; }", "text": "Lets re-throw this as a RuntimeException instead.", "function_tokens": ["private", "\u0120static", "\u0120J", "AX", "BC", "on", "text", "\u0120init", "On", "ms", "Event", "Parameter", "Context", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120return", "\u0120J", "AX", "BC", "on", "text", ".", "new", "Instance", "(", "Event", "P", "arms", ".", "class", ");", "\u0120}", "\u0120catch", "\u0120(", "J", "AX", "B", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["L", "ets", "\u0120re", "-", "throw", "\u0120this", "\u0120as", "\u0120a", "\u0120Runtime", "Exception", "\u0120instead", "."]}
{"function": "public RemoteCounterManagerTest() { testImpl = new CounterManagerImplTest(this::allTestCounterManagers, this::log, this::cacheManager); }", "text": "fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)", "function_tokens": ["public", "\u0120Remote", "Counter", "Manager", "Test", "()", "\u0120{", "\u0120test", "Impl", "\u0120=", "\u0120new", "\u0120Counter", "Manager", "Impl", "Test", "(", "this", "::", "all", "Test", "Counter", "Man", "agers", ",", "\u0120this", "::", "log", ",", "\u0120this", "::", "cache", "Manager", ");", "\u0120}"], "docstring_tokens": ["fy", "i", ",", "\u0120you", "\u0120can", "\u0120use", "\u0120@", "Factory", "\u0120method", "\u0120to", "\u0120replace", "\u0120the", "\u0120actually", "\u0120tested", "\u0120instance", "\u0120(", "its", "\u0120methods", "\u0120have", "\u0120to", "\u0120be", "\u0120annot", "ated", "\u0120with", "\u0120@", "Test", "\u0120of", "c", ")"]}
{"function": "private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) { if (!s1.getReadName().equals(s2.getReadName())) { throw new PicardException(\"Read names do not match: \" + s1.getReadName() + \" : \" + s2.getReadName()); } catalogDuplicateDifferences(s1, s2); final AlignmentComparison comp = compareAlignmentRecords(s1, s2); switch (comp) { case UNMAPPED_BOTH: ++comparisonMetric.unmappedBoth; break; case UNMAPPED_LEFT: ++comparisonMetric.unmappedLeft; break; case UNMAPPED_RIGHT: ++comparisonMetric.unmappedRight; break; case MAPPINGS_DIFFER: ++comparisonMetric.mappingsDiffer; break; case MAPPINGS_MATCH: ++comparisonMetric.mappingsMatch; break; default: throw new PicardException(\"Unhandled comparison type: \" + comp); } }", "text": "It would be nice to move this switch into SamComparisonMetric. Or, move it into AlignmentComparison so the switch is no longer necessary, e.g. AlignmentComparison.updateMetric(SamComparisonMetric), where updateMetric() is overridden per enum member to increment the correct field.", "function_tokens": ["private", "\u0120void", "\u0120tally", "Al", "ignment", "Rec", "ords", "(", "final", "\u0120SAM", "Record", "\u0120s", "1", ",", "\u0120final", "\u0120SAM", "Record", "\u0120s", "2", ")", "\u0120{", "\u0120if", "\u0120(!", "s", "1", ".", "get", "Read", "Name", "().", "equ", "als", "(", "s", "2", ".", "get", "Read", "Name", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Picard", "Exception", "(\"", "Read", "\u0120names", "\u0120do", "\u0120not", "\u0120match", ":", "\u0120\"", "\u0120+", "\u0120s", "1", ".", "get", "Read", "Name", "()", "\u0120+", "\u0120\"", "\u0120:", "\u0120\"", "\u0120+", "\u0120s", "2", ".", "get", "Read", "Name", "());", "\u0120}", "\u0120catalog", "Du", "pl", "icate", "Diff", "erences", "(", "s", "1", ",", "\u0120s", "2", ");", "\u0120final", "\u0120Al", "ignment", "Compar", "ison", "\u0120comp", "\u0120=", "\u0120compare", "Al", "ignment", "Rec", "ords", "(", "s", "1", ",", "\u0120s", "2", ");", "\u0120switch", "\u0120(", "comp", ")", "\u0120{", "\u0120case", "\u0120UN", "M", "APP", "ED", "_", "B", "OTH", ":", "\u0120++", "com", "par", "ison", "Met", "ric", ".", "un", "m", "apped", "Both", ";", "\u0120break", ";", "\u0120case", "\u0120UN", "M", "APP", "ED", "_", "LE", "FT", ":", "\u0120++", "com", "par", "ison", "Met", "ric", ".", "un", "m", "apped", "Left", ";", "\u0120break", ";", "\u0120case", "\u0120UN", "M", "APP", "ED", "_", "R", "IGHT", ":", "\u0120++", "com", "par", "ison", "Met", "ric", ".", "un", "m", "apped", "Right", ";", "\u0120break", ";", "\u0120case", "\u0120M", "APP", "INGS", "_", "D", "IF", "FER", ":", "\u0120++", "com", "par", "ison", "Met", "ric", ".", "m", "appings", "Diff", "er", ";", "\u0120break", ";", "\u0120case", "\u0120M", "APP", "INGS", "_", "M", "ATCH", ":", "\u0120++", "com", "par", "ison", "Met", "ric", ".", "m", "appings", "Match", ";", "\u0120break", ";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Picard", "Exception", "(\"", "Un", "handled", "\u0120comparison", "\u0120type", ":", "\u0120\"", "\u0120+", "\u0120comp", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["It", "\u0120would", "\u0120be", "\u0120nice", "\u0120to", "\u0120move", "\u0120this", "\u0120switch", "\u0120into", "\u0120Sam", "Compar", "ison", "Met", "ric", ".", "\u0120Or", ",", "\u0120move", "\u0120it", "\u0120into", "\u0120Al", "ignment", "Compar", "ison", "\u0120so", "\u0120the", "\u0120switch", "\u0120is", "\u0120no", "\u0120longer", "\u0120necessary", ",", "\u0120e", ".", "g", ".", "\u0120Al", "ignment", "Compar", "ison", ".", "update", "Met", "ric", "(", "Sam", "Compar", "ison", "Met", "ric", "),", "\u0120where", "\u0120update", "Met", "ric", "()", "\u0120is", "\u0120overr", "idden", "\u0120per", "\u0120enum", "\u0120member", "\u0120to", "\u0120increment", "\u0120the", "\u0120correct", "\u0120field", "."]}
{"function": "private Message.Builder getMessageBuilder(Class<?> clazz) { try { assert supports(clazz); Method method = methodCache.get(clazz); if (method == null) { method = clazz.getMethod(\"newBuilder\"); methodCache.put(clazz, method); } return (Message.Builder) method.invoke(clazz); } catch (Exception ex) { throw new MessageConversionException( \"Invalid Protobuf Message type: no invocable newBuilder() method on \" + clazz, ex); } }", "text": "Please check [our guidelines](<LINK_0> on source code style.", "function_tokens": ["private", "\u0120Message", ".", "Builder", "\u0120get", "Message", "Builder", "(", "Class", "<?", ">", "\u0120cl", "azz", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120assert", "\u0120supports", "(", "cl", "azz", ");", "\u0120Method", "\u0120method", "\u0120=", "\u0120method", "Cache", ".", "get", "(", "cl", "azz", ");", "\u0120if", "\u0120(", "method", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120method", "\u0120=", "\u0120cl", "azz", ".", "get", "Method", "(\"", "new", "Builder", "\");", "\u0120method", "Cache", ".", "put", "(", "cl", "azz", ",", "\u0120method", ");", "\u0120}", "\u0120return", "\u0120(", "Message", ".", "Builder", ")", "\u0120method", ".", "invoke", "(", "cl", "azz", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120ex", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Message", "Con", "version", "Exception", "(", "\u0120\"", "Invalid", "\u0120Prot", "ob", "uf", "\u0120Message", "\u0120type", ":", "\u0120no", "\u0120inv", "oc", "able", "\u0120new", "Builder", "()", "\u0120method", "\u0120on", "\u0120\"", "\u0120+", "\u0120cl", "azz", ",", "\u0120ex", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120check", "\u0120[", "our", "\u0120guidelines", "](", "<", "L", "INK", "_", "0", ">", "\u0120on", "\u0120source", "\u0120code", "\u0120style", "."]}
{"function": "static String base64(byte[] data) { byte[] encodedData = Base64.getEncoder().encode(data); return new String(encodedData, StandardCharsets.UTF_8); }", "text": "@doom369 just wondering if we should call encodeToString  directly. WDYT ?", "function_tokens": ["static", "\u0120String", "\u0120base", "64", "(", "byte", "[]", "\u0120data", ")", "\u0120{", "\u0120byte", "[]", "\u0120encoded", "Data", "\u0120=", "\u0120Base", "64", ".", "get", "Enc", "oder", "().", "en", "code", "(", "data", ");", "\u0120return", "\u0120new", "\u0120String", "(", "enc", "oded", "Data", ",", "\u0120Standard", "Ch", "ars", "ets", ".", "UTF", "_", "8", ");", "\u0120}"], "docstring_tokens": ["@", "d", "oom", "369", "\u0120just", "\u0120wondering", "\u0120if", "\u0120we", "\u0120should", "\u0120call", "\u0120encode", "To", "String", "\u0120", "\u0120directly", ".", "\u0120WD", "Y", "T", "\u0120?"]}
{"function": "public void onAdd(SolApplication solApplication) { IniReader reader = new IniReader(Const.SAVE_FILE_NAME, null); String saveMajorVersion = reader.getString(\"version\", \"\").split(\"\\\\.\")[0]; String gameMajorVersion = Const.VERSION.split(\"\\\\.\")[0]; continueControl.setEnabled(SaveManager.hasPrevShip(\"prevShip.ini\") && saveMajorVersion.equals(gameMajorVersion)); }", "text": "\"prevShip.ini\" shouldn't be used here, now that you have the constant defined. In fact, I don't think the file should be passed to the save manager, as that's more of a save manager concern. I would consider moving all of this logic into the hasPrevShip function.", "function_tokens": ["public", "\u0120void", "\u0120on", "Add", "(", "Sol", "Application", "\u0120sol", "Application", ")", "\u0120{", "\u0120In", "i", "Reader", "\u0120reader", "\u0120=", "\u0120new", "\u0120In", "i", "Reader", "(", "Const", ".", "SA", "VE", "_", "FILE", "_", "NAME", ",", "\u0120null", ");", "\u0120String", "\u0120save", "Major", "Version", "\u0120=", "\u0120reader", ".", "get", "String", "(\"", "version", "\",", "\u0120\"", "\").", "split", "(\"", "\\\\", ".\")", "[", "0", "];", "\u0120String", "\u0120game", "Major", "Version", "\u0120=", "\u0120Const", ".", "VERSION", ".", "split", "(\"", "\\\\", ".\")", "[", "0", "];", "\u0120continue", "Control", ".", "set", "Enabled", "(", "Save", "Manager", ".", "has", "Prev", "Ship", "(\"", "prev", "Ship", ".", "ini", "\")", "\u0120&&", "\u0120save", "Major", "Version", ".", "equ", "als", "(", "game", "Major", "Version", "));", "\u0120}"], "docstring_tokens": ["\"", "prev", "Ship", ".", "ini", "\"", "\u0120shouldn", "'t", "\u0120be", "\u0120used", "\u0120here", ",", "\u0120now", "\u0120that", "\u0120you", "\u0120have", "\u0120the", "\u0120constant", "\u0120defined", ".", "\u0120In", "\u0120fact", ",", "\u0120I", "\u0120don", "'t", "\u0120think", "\u0120the", "\u0120file", "\u0120should", "\u0120be", "\u0120passed", "\u0120to", "\u0120the", "\u0120save", "\u0120manager", ",", "\u0120as", "\u0120that", "'s", "\u0120more", "\u0120of", "\u0120a", "\u0120save", "\u0120manager", "\u0120concern", ".", "\u0120I", "\u0120would", "\u0120consider", "\u0120moving", "\u0120all", "\u0120of", "\u0120this", "\u0120logic", "\u0120into", "\u0120the", "\u0120has", "Prev", "Ship", "\u0120function", "."]}
{"function": "public boolean execute(int retries, MapOperation mapOperation, ILogger logger) { RecordStore recordStore = mapOperation.recordStore; if (recordStore == null) { return false; } if (recordStore.getInMemoryFormat() != NATIVE || recordStore.getEvictionPolicy() == NONE) { return false; } MapContainer mapContainer = recordStore.getMapContainer(); Evictor evictor = mapContainer.getEvictor(); for (int i = 0; i < retries; i++) { if (logger.isFineEnabled()) { logger.fine(format( \"Applying forced eviction on current RecordStore (map %s, partitionId: %d)!\", mapOperation.getName(), mapOperation.getPartitionId() )); } try { evictor.forceEvict(recordStore); mapOperation.runInternal(); return true; } catch (NativeOutOfMemoryError e) { ignore(e); } } return false; }", "text": "Minor: you can extract this null check and the in-memory format/eviction policy check into a static method and invoke it from here and other implementations of ForcedEviction", "function_tokens": ["public", "\u0120boolean", "\u0120execute", "(", "int", "\u0120ret", "ries", ",", "\u0120Map", "Operation", "\u0120map", "Operation", ",", "\u0120I", "Log", "ger", "\u0120logger", ")", "\u0120{", "\u0120Record", "Store", "\u0120record", "Store", "\u0120=", "\u0120map", "Operation", ".", "record", "Store", ";", "\u0120if", "\u0120(", "record", "Store", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "record", "Store", ".", "get", "In", "Memory", "Format", "()", "\u0120!=", "\u0120NAT", "IVE", "\u0120||", "\u0120record", "Store", ".", "get", "Ev", "iction", "Policy", "()", "\u0120==", "\u0120N", "ONE", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120Map", "Container", "\u0120map", "Container", "\u0120=", "\u0120record", "Store", ".", "get", "Map", "Container", "();", "\u0120Ev", "ict", "or", "\u0120evict", "or", "\u0120=", "\u0120map", "Container", ".", "get", "Ev", "ict", "or", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120ret", "ries", ";", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "log", "ger", ".", "is", "Fine", "Enabled", "())", "\u0120{", "\u0120logger", ".", "fine", "(", "format", "(", "\u0120\"", "App", "lying", "\u0120forced", "\u0120eviction", "\u0120on", "\u0120current", "\u0120Record", "Store", "\u0120(", "map", "\u0120%", "s", ",", "\u0120partition", "Id", ":", "\u0120%", "d", ")!", "\",", "\u0120map", "Operation", ".", "get", "Name", "(),", "\u0120map", "Operation", ".", "get", "Part", "ition", "Id", "()", "\u0120));", "\u0120}", "\u0120try", "\u0120{", "\u0120evict", "or", ".", "force", "Ev", "ict", "(", "record", "Store", ");", "\u0120map", "Operation", ".", "run", "Internal", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120catch", "\u0120(", "Native", "Out", "Of", "Memory", "Error", "\u0120e", ")", "\u0120{", "\u0120ignore", "(", "e", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Minor", ":", "\u0120you", "\u0120can", "\u0120extract", "\u0120this", "\u0120null", "\u0120check", "\u0120and", "\u0120the", "\u0120in", "-", "memory", "\u0120format", "/", "ev", "iction", "\u0120policy", "\u0120check", "\u0120into", "\u0120a", "\u0120static", "\u0120method", "\u0120and", "\u0120invoke", "\u0120it", "\u0120from", "\u0120here", "\u0120and", "\u0120other", "\u0120implementations", "\u0120of", "\u0120Forced", "Ev", "iction"]}
{"function": "public void onFailure(Throwable caught) { if (hasResponse()) { GWT.log(\"HTTP \" + getResponse().getStatusCode() + \": \" + getResponse().getStatusText()); } Message message = new Message(translateCauses(caught), MessageStyle.ERROR); DisplayMessageEvent.fire(hasHandlers, message); }", "text": "you should remove this log.", "function_tokens": ["public", "\u0120void", "\u0120on", "Failure", "(", "Throw", "able", "\u0120caught", ")", "\u0120{", "\u0120if", "\u0120(", "has", "Response", "())", "\u0120{", "\u0120GW", "T", ".", "log", "(\"", "HTTP", "\u0120\"", "\u0120+", "\u0120get", "Response", "().", "get", "Status", "Code", "()", "\u0120+", "\u0120\"", ":", "\u0120\"", "\u0120+", "\u0120get", "Response", "().", "get", "Status", "Text", "());", "\u0120}", "\u0120Message", "\u0120message", "\u0120=", "\u0120new", "\u0120Message", "(", "trans", "late", "Ca", "uses", "(", "c", "aught", "),", "\u0120Message", "Style", ".", "ERROR", ");", "\u0120Display", "Message", "Event", ".", "fire", "(", "has", "Hand", "lers", ",", "\u0120message", ");", "\u0120}"], "docstring_tokens": ["you", "\u0120should", "\u0120remove", "\u0120this", "\u0120log", "."]}
{"function": "public void stop() { coapServer.stop(); if (clientRegistry instanceof Stoppable) { ((Stoppable) clientRegistry).stop(); } if (securityRegistry instanceof Stoppable) { ((Stoppable) securityRegistry).stop(); } if (observationRegistry instanceof Stoppable) { ((Stoppable) observationRegistry).stop(); } LOG.info(\"LW-M2M server stopped\"); }", "text": "we should stop the queueRequestSender ?", "function_tokens": ["public", "\u0120void", "\u0120stop", "()", "\u0120{", "\u0120co", "ap", "Server", ".", "stop", "();", "\u0120if", "\u0120(", "client", "Reg", "istry", "\u0120instance", "of", "\u0120St", "oppable", ")", "\u0120{", "\u0120((", "St", "oppable", ")", "\u0120client", "Reg", "istry", ").", "stop", "();", "\u0120}", "\u0120if", "\u0120(", "security", "Reg", "istry", "\u0120instance", "of", "\u0120St", "oppable", ")", "\u0120{", "\u0120((", "St", "oppable", ")", "\u0120security", "Reg", "istry", ").", "stop", "();", "\u0120}", "\u0120if", "\u0120(", "ob", "serv", "ation", "Reg", "istry", "\u0120instance", "of", "\u0120St", "oppable", ")", "\u0120{", "\u0120((", "St", "oppable", ")", "\u0120observation", "Reg", "istry", ").", "stop", "();", "\u0120}", "\u0120LOG", ".", "info", "(\"", "L", "W", "-", "M", "2", "M", "\u0120server", "\u0120stopped", "\");", "\u0120}"], "docstring_tokens": ["we", "\u0120should", "\u0120stop", "\u0120the", "\u0120queue", "Request", "S", "ender", "\u0120?"]}
{"function": "public void setLogFilePermission(String fileName) throws IOException { File file = new File(logRootDir, fileName).getCanonicalFile(); boolean runAsUser = ObjectReader.getBoolean(stormConf.get(SUPERVISOR_RUN_WORKER_AS_USER), false); File parent = new File(logRootDir, fileName).getParentFile(); Optional<File> mdFile = (parent == null) ? Optional.empty() : getMetadataFileForWorkerLogDir(parent); Optional<String> topoOwner = mdFile.isPresent() ? Optional.of(getTopologyOwnerFromMetadataFile(mdFile.get().getCanonicalPath())) : Optional.empty(); if (runAsUser && topoOwner.isPresent() && file.exists() && !Files.isReadable(file.toPath())) { LOG.debug(\"Setting permissions on file {} with topo-owner {}\", fileName, topoOwner); try { ClientSupervisorUtils.processLauncherAndWait(stormConf, topoOwner.get(), Lists.newArrayList(\"blob\", file.getCanonicalPath()), null, \"setup group read permissions for file: \" + fileName); } catch (IOException e) { ExceptionMeters.NUM_PERMISSION_EXCEPTIONS.mark(); throw e; } } }", "text": "The exception name is not clear", "function_tokens": ["public", "\u0120void", "\u0120set", "Log", "File", "Per", "mission", "(", "String", "\u0120file", "Name", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120File", "\u0120file", "\u0120=", "\u0120new", "\u0120File", "(", "log", "Root", "Dir", ",", "\u0120file", "Name", ").", "get", "Can", "on", "ical", "File", "();", "\u0120boolean", "\u0120run", "As", "User", "\u0120=", "\u0120Object", "Reader", ".", "get", "Boo", "lean", "(", "storm", "Conf", ".", "get", "(", "SUP", "ER", "VIS", "OR", "_", "R", "UN", "_", "WORK", "ER", "_", "AS", "_", "USER", "),", "\u0120false", ");", "\u0120File", "\u0120parent", "\u0120=", "\u0120new", "\u0120File", "(", "log", "Root", "Dir", ",", "\u0120file", "Name", ").", "get", "Parent", "File", "();", "\u0120Optional", "<", "File", ">", "\u0120md", "File", "\u0120=", "\u0120(", "parent", "\u0120==", "\u0120null", ")", "\u0120?", "\u0120Optional", ".", "empty", "()", "\u0120:", "\u0120get", "Met", "adata", "File", "For", "Work", "er", "Log", "Dir", "(", "parent", ");", "\u0120Optional", "<", "String", ">", "\u0120top", "o", "Owner", "\u0120=", "\u0120md", "File", ".", "is", "Present", "()", "\u0120?", "\u0120Optional", ".", "of", "(", "get", "Top", "ology", "Owner", "From", "Met", "adata", "File", "(", "md", "File", ".", "get", "().", "get", "Can", "on", "ical", "Path", "()", "))", "\u0120:", "\u0120Optional", ".", "empty", "();", "\u0120if", "\u0120(", "run", "As", "User", "\u0120&&", "\u0120top", "o", "Owner", ".", "is", "Present", "()", "\u0120&&", "\u0120file", ".", "ex", "ists", "()", "\u0120&&", "\u0120!", "Files", ".", "is", "Read", "able", "(", "file", ".", "to", "Path", "()", "))", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Setting", "\u0120permissions", "\u0120on", "\u0120file", "\u0120{}", "\u0120with", "\u0120top", "o", "-", "owner", "\u0120{}", "\",", "\u0120file", "Name", ",", "\u0120top", "o", "Owner", ");", "\u0120try", "\u0120{", "\u0120Client", "Super", "visor", "Ut", "ils", ".", "process", "Laun", "cher", "And", "Wait", "(", "storm", "Conf", ",", "\u0120top", "o", "Owner", ".", "get", "(),", "\u0120Lists", ".", "new", "Array", "List", "(\"", "bl", "ob", "\",", "\u0120file", ".", "get", "Can", "on", "ical", "Path", "()", "),", "\u0120null", ",", "\u0120\"", "setup", "\u0120group", "\u0120read", "\u0120permissions", "\u0120for", "\u0120file", ":", "\u0120\"", "\u0120+", "\u0120file", "Name", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120Exception", "M", "eters", ".", "NUM", "_", "PER", "M", "ISSION", "_", "EX", "CEPT", "IONS", ".", "mark", "();", "\u0120throw", "\u0120e", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["The", "\u0120exception", "\u0120name", "\u0120is", "\u0120not", "\u0120clear"]}
{"function": "private void estimateCommandsMachineName( Devfile devfile, Tool tool, KubernetesList recipeObjects) { List<Command> toolsCommands = devfile .getCommands() .stream() .filter(c -> c.getActions().get(0).getTool().equals(tool.getName())) .collect(toList()); if (toolsCommands.isEmpty()) { return; } List<Pod> pods = recipeObjects .getItems() .stream() .filter(hasMetadata -> hasMetadata instanceof Pod) .map(hasMetadata -> (Pod) hasMetadata) .collect(toList()); if (pods.size() != 1) { return; } Pod pod = pods.get(0); List<Container> containers = pod.getSpec().getContainers(); if (containers.size() != 1) { return; } Container container = containers.get(0); String machineName = Names.machineName(pod, container); toolsCommands.forEach(c -> c.getAttributes().put(MACHINE_NAME_ATTRIBUTE, machineName)); }", "text": "Could you describe why, not what?", "function_tokens": ["private", "\u0120void", "\u0120estimate", "Comm", "ands", "Machine", "Name", "(", "\u0120Dev", "file", "\u0120dev", "file", ",", "\u0120Tool", "\u0120tool", ",", "\u0120Ku", "ber", "net", "es", "List", "\u0120recipe", "Object", "s", ")", "\u0120{", "\u0120List", "<", "Command", ">", "\u0120tools", "Comm", "ands", "\u0120=", "\u0120dev", "file", "\u0120.", "get", "Comm", "ands", "()", "\u0120.", "stream", "()", "\u0120.", "filter", "(", "c", "\u0120->", "\u0120c", ".", "get", "A", "ctions", "().", "get", "(", "0", ").", "get", "Tool", "().", "equ", "als", "(", "tool", ".", "get", "Name", "()", "))", "\u0120.", "collect", "(", "to", "List", "());", "\u0120if", "\u0120(", "tools", "Comm", "ands", ".", "is", "Empty", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120List", "<", "Pod", ">", "\u0120pods", "\u0120=", "\u0120recipe", "Object", "s", "\u0120.", "get", "Items", "()", "\u0120.", "stream", "()", "\u0120.", "filter", "(", "has", "Met", "adata", "\u0120->", "\u0120has", "Met", "adata", "\u0120instance", "of", "\u0120Pod", ")", "\u0120.", "map", "(", "has", "Met", "adata", "\u0120->", "\u0120(", "Pod", ")", "\u0120has", "Met", "adata", ")", "\u0120.", "collect", "(", "to", "List", "());", "\u0120if", "\u0120(", "p", "ods", ".", "size", "()", "\u0120!=", "\u01201", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120Pod", "\u0120pod", "\u0120=", "\u0120pods", ".", "get", "(", "0", ");", "\u0120List", "<", "Container", ">", "\u0120containers", "\u0120=", "\u0120pod", ".", "get", "Spec", "().", "get", "Cont", "ainers", "();", "\u0120if", "\u0120(", "cont", "ainers", ".", "size", "()", "\u0120!=", "\u01201", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120Container", "\u0120container", "\u0120=", "\u0120containers", ".", "get", "(", "0", ");", "\u0120String", "\u0120machine", "Name", "\u0120=", "\u0120Names", ".", "machine", "Name", "(", "pod", ",", "\u0120container", ");", "\u0120tools", "Comm", "ands", ".", "for", "Each", "(", "c", "\u0120->", "\u0120c", ".", "get", "Attributes", "().", "put", "(", "M", "ACH", "INE", "_", "NAME", "_", "AT", "TR", "IB", "UTE", ",", "\u0120machine", "Name", "));", "\u0120}"], "docstring_tokens": ["Could", "\u0120you", "\u0120describe", "\u0120why", ",", "\u0120not", "\u0120what", "?"]}
{"function": "private String encrypt(String value) { try { return getStorageHelper().encrypt(mContext, value); } catch (GeneralSecurityException | IOException e) { Logger.e(TAG, \"Encryption failure\", \"\", ADALError.ENCRYPTION_FAILED, e); } return null; }", "text": "nit: space", "function_tokens": ["private", "\u0120String", "\u0120encrypt", "(", "String", "\u0120value", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120return", "\u0120get", "Storage", "Helper", "().", "enc", "rypt", "(", "m", "Context", ",", "\u0120value", ");", "\u0120}", "\u0120catch", "\u0120(", "General", "Security", "Exception", "\u0120|", "\u0120IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120Log", "ger", ".", "e", "(", "TAG", ",", "\u0120\"", "Enc", "ryption", "\u0120failure", "\",", "\u0120\"", "\",", "\u0120AD", "AL", "Error", ".", "EN", "CR", "Y", "PT", "ION", "_", "FA", "IL", "ED", ",", "\u0120e", ");", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120space"]}
{"function": "public String getBackupIdentifier() { return Const.SystemParams.ACCOUNT_ATTRIBUTES_BACKUP_LOG_MSG + this.googleId; }", "text": "Beside AccountAttributes.java, there are more *Atrributes.java need to be changed.", "function_tokens": ["public", "\u0120String", "\u0120get", "Back", "up", "Ident", "ifier", "()", "\u0120{", "\u0120return", "\u0120Const", ".", "System", "Par", "ams", ".", "ACC", "OUNT", "_", "AT", "TR", "IB", "UT", "ES", "_", "BACK", "UP", "_", "LOG", "_", "MS", "G", "\u0120+", "\u0120this", ".", "google", "Id", ";", "\u0120}"], "docstring_tokens": ["B", "es", "ide", "\u0120Account", "Attributes", ".", "java", ",", "\u0120there", "\u0120are", "\u0120more", "\u0120*", "A", "tr", "ributes", ".", "java", "\u0120need", "\u0120to", "\u0120be", "\u0120changed", "."]}
{"function": "protected static WebDriver getCurrentBrowser() { return b.getCurrentWebDriver(); }", "text": "Are you sure that \"protected static\" is ok? To me it doesn't make sense as you can't override static methods.", "function_tokens": ["protected", "\u0120static", "\u0120Web", "Driver", "\u0120get", "Current", "Browser", "()", "\u0120{", "\u0120return", "\u0120b", ".", "get", "Current", "Web", "Driver", "();", "\u0120}"], "docstring_tokens": ["Are", "\u0120you", "\u0120sure", "\u0120that", "\u0120\"", "protected", "\u0120static", "\"", "\u0120is", "\u0120ok", "?", "\u0120To", "\u0120me", "\u0120it", "\u0120doesn", "'t", "\u0120make", "\u0120sense", "\u0120as", "\u0120you", "\u0120can", "'t", "\u0120override", "\u0120static", "\u0120methods", "."]}
{"function": "public void onlineUseCase() { Assume.assumeTrue(mCameraId != null); mCamera.open(); mCamera.addOnlineUseCase(Collections.<UseCase>singletonList(mFakeUseCase)); verify(mMockOnImageAvailableListener, never()).onImageAvailable(any(ImageReader.class)); mCamera.release(); }", "text": "Rather than put this in every test, you can just put it once in the setup() method.", "function_tokens": ["public", "\u0120void", "\u0120online", "Use", "Case", "()", "\u0120{", "\u0120Ass", "ume", ".", "ass", "ume", "True", "(", "m", "Camera", "Id", "\u0120!=", "\u0120null", ");", "\u0120m", "Camera", ".", "open", "();", "\u0120m", "Camera", ".", "add", "Online", "Use", "Case", "(", "Col", "lections", ".<", "Use", "Case", ">", "sing", "leton", "List", "(", "m", "Fake", "Use", "Case", "));", "\u0120verify", "(", "m", "M", "ock", "On", "Image", "Available", "Listener", ",", "\u0120never", "()", ").", "on", "Image", "Available", "(", "any", "(", "Image", "Reader", ".", "class", "));", "\u0120m", "Camera", ".", "release", "();", "\u0120}"], "docstring_tokens": ["Rather", "\u0120than", "\u0120put", "\u0120this", "\u0120in", "\u0120every", "\u0120test", ",", "\u0120you", "\u0120can", "\u0120just", "\u0120put", "\u0120it", "\u0120once", "\u0120in", "\u0120the", "\u0120setup", "()", "\u0120method", "."]}
{"function": "protected String buildPOFipsCountryCode(PaymentWorksVendor pmwVendor, Map<String, List<PaymentWorksIsoFipsCountryItem>> paymentWorksIsoToFipsCountryMap) { String fipsCountryCode = StringUtils.EMPTY; if (paymentWorksFormModeService.shouldUseLegacyFormProcessingMode()) { String paymentWorksVendorCountryCode = findPoCountryToUse(pmwVendor); fipsCountryCode = convertFipsPoCountryOptionToFipsCountryCode(paymentWorksVendorCountryCode); if (StringUtils.isBlank(fipsCountryCode)) { LOG.error(\"buildPOFipsCountryCode, unable to find LEGACY FIPS country code for \" + paymentWorksVendorCountryCode); } } else if (paymentWorksFormModeService.shouldUseForeignFormProcessingMode()) { PaymentWorksPurchaseOrderCountryFipsOption option = PaymentWorksPurchaseOrderCountryFipsOption.findPaymentWorksPurchaseOrderCountryFipsOption(pmwVendor.getPoCountryUsCanadaAustraliaOther()); if (LOG.isDebugEnabled()) { LOG.debug(\"buildPOFipsCountryCode, new foreign form FIPS country code option: \" + option.toString()); } if (StringUtils.isNotBlank(option.fipsCountryCode)) { fipsCountryCode = option.fipsCountryCode; } else { try { fipsCountryCode = convertIsoCountryCodeToFipsCountryCode(pmwVendor.getPoCountry(), paymentWorksIsoToFipsCountryMap); } catch (NullPointerException npe) { LOG.error(\"buildPOFipsCountryCode, had and error converting '\" + pmwVendor.getPoCountry() + \"' to a FIPS code.\", npe); fipsCountryCode = StringUtils.EMPTY; } } if (StringUtils.isBlank(fipsCountryCode)) { LOG.error(\"buildPOFipsCountryCode, unable to find new foreign form FIPS country code for country code \" + pmwVendor.getPoCountry()); } } return fipsCountryCode; }", "text": "Minor typo in error message, should change from \"...had and error...\" to \"...had an error...\"", "function_tokens": ["protected", "\u0120String", "\u0120build", "PO", "F", "ips", "Country", "Code", "(", "Pay", "ment", "Works", "V", "endor", "\u0120pm", "w", "V", "endor", ",", "\u0120Map", "<", "String", ",", "\u0120List", "<", "Pay", "ment", "Works", "I", "so", "F", "ips", "Country", "Item", ">>", "\u0120payment", "Works", "I", "so", "To", "F", "ips", "Country", "Map", ")", "\u0120{", "\u0120String", "\u0120f", "ips", "Country", "Code", "\u0120=", "\u0120String", "Ut", "ils", ".", "EMP", "TY", ";", "\u0120if", "\u0120(", "payment", "Works", "Form", "Mode", "Service", ".", "should", "Use", "Leg", "acy", "Form", "Process", "ing", "Mode", "())", "\u0120{", "\u0120String", "\u0120payment", "Works", "V", "endor", "Country", "Code", "\u0120=", "\u0120find", "Po", "Country", "To", "Use", "(", "pm", "w", "V", "endor", ");", "\u0120f", "ips", "Country", "Code", "\u0120=", "\u0120convert", "F", "ips", "Po", "Country", "Option", "To", "F", "ips", "Country", "Code", "(", "payment", "Works", "V", "endor", "Country", "Code", ");", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "f", "ips", "Country", "Code", "))", "\u0120{", "\u0120LOG", ".", "error", "(\"", "build", "PO", "F", "ips", "Country", "Code", ",", "\u0120unable", "\u0120to", "\u0120find", "\u0120LEG", "ACY", "\u0120FI", "PS", "\u0120country", "\u0120code", "\u0120for", "\u0120\"", "\u0120+", "\u0120payment", "Works", "V", "endor", "Country", "Code", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "payment", "Works", "Form", "Mode", "Service", ".", "should", "Use", "Foreign", "Form", "Process", "ing", "Mode", "())", "\u0120{", "\u0120Payment", "Works", "Purchase", "Order", "Country", "F", "ips", "Option", "\u0120option", "\u0120=", "\u0120Payment", "Works", "Purchase", "Order", "Country", "F", "ips", "Option", ".", "find", "Pay", "ment", "Works", "Purchase", "Order", "Country", "F", "ips", "Option", "(", "pm", "w", "V", "endor", ".", "get", "Po", "Country", "Us", "Canada", "Australia", "Other", "());", "\u0120if", "\u0120(", "LOG", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "build", "PO", "F", "ips", "Country", "Code", ",", "\u0120new", "\u0120foreign", "\u0120form", "\u0120FI", "PS", "\u0120country", "\u0120code", "\u0120option", ":", "\u0120\"", "\u0120+", "\u0120option", ".", "to", "String", "());", "\u0120}", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Bl", "ank", "(", "option", ".", "f", "ips", "Country", "Code", "))", "\u0120{", "\u0120f", "ips", "Country", "Code", "\u0120=", "\u0120option", ".", "f", "ips", "Country", "Code", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120try", "\u0120{", "\u0120f", "ips", "Country", "Code", "\u0120=", "\u0120convert", "I", "so", "Country", "Code", "To", "F", "ips", "Country", "Code", "(", "pm", "w", "V", "endor", ".", "get", "Po", "Country", "(),", "\u0120payment", "Works", "I", "so", "To", "F", "ips", "Country", "Map", ");", "\u0120}", "\u0120catch", "\u0120(", "Null", "Po", "inter", "Exception", "\u0120n", "pe", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "build", "PO", "F", "ips", "Country", "Code", ",", "\u0120had", "\u0120and", "\u0120error", "\u0120converting", "\u0120'", "\"", "\u0120+", "\u0120pm", "w", "V", "endor", ".", "get", "Po", "Country", "()", "\u0120+", "\u0120\"'", "\u0120to", "\u0120a", "\u0120FI", "PS", "\u0120code", ".\",", "\u0120n", "pe", ");", "\u0120f", "ips", "Country", "Code", "\u0120=", "\u0120String", "Ut", "ils", ".", "EMP", "TY", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "f", "ips", "Country", "Code", "))", "\u0120{", "\u0120LOG", ".", "error", "(\"", "build", "PO", "F", "ips", "Country", "Code", ",", "\u0120unable", "\u0120to", "\u0120find", "\u0120new", "\u0120foreign", "\u0120form", "\u0120FI", "PS", "\u0120country", "\u0120code", "\u0120for", "\u0120country", "\u0120code", "\u0120\"", "\u0120+", "\u0120pm", "w", "V", "endor", ".", "get", "Po", "Country", "());", "\u0120}", "\u0120}", "\u0120return", "\u0120f", "ips", "Country", "Code", ";", "\u0120}"], "docstring_tokens": ["Minor", "\u0120typo", "\u0120in", "\u0120error", "\u0120message", ",", "\u0120should", "\u0120change", "\u0120from", "\u0120\"...", "had", "\u0120and", "\u0120error", "...\"", "\u0120to", "\u0120\"...", "had", "\u0120an", "\u0120error", "...\""]}
{"function": "public Boolean isWakeupEvent(ITmfEvent event) { String eventName = event.getName(); ITmfTrace trace = event.getTrace(); LttngEventLayout eventLayout = getProvider().getEventLayout(); String wakeupEventName = NonNullUtils.nullToEmptyString(fWakeupEventMap.get(trace)); if (wakeupEventName.equals(eventLayout.eventSchedProcessWaking()) && (eventName.equals(eventLayout.eventSchedProcessWaking()) || eventName.equals(eventLayout.eventSchedProcessWakeupNew()))) { return NonNullUtils.checkNotNull(Boolean.TRUE); } else if (wakeupEventName.equals(eventLayout.eventSchedProcessTTWU()) && eventName.equals(eventLayout.eventSchedProcessTTWU())) { return NonNullUtils.checkNotNull(Boolean.TRUE); } return NonNullUtils.checkNotNull(Boolean.FALSE); }", "text": "why not boolean? (lowercase?)", "function_tokens": ["public", "\u0120Boolean", "\u0120is", "W", "ake", "up", "Event", "(", "IT", "m", "f", "Event", "\u0120event", ")", "\u0120{", "\u0120String", "\u0120event", "Name", "\u0120=", "\u0120event", ".", "get", "Name", "();", "\u0120IT", "m", "f", "Tr", "ace", "\u0120trace", "\u0120=", "\u0120event", ".", "get", "Tr", "ace", "();", "\u0120L", "tt", "ng", "Event", "Layout", "\u0120event", "Layout", "\u0120=", "\u0120get", "Provider", "().", "get", "Event", "Layout", "();", "\u0120String", "\u0120wake", "up", "Event", "Name", "\u0120=", "\u0120Non", "Null", "Ut", "ils", ".", "null", "To", "Empty", "String", "(", "f", "W", "ake", "up", "Event", "Map", ".", "get", "(", "trace", "));", "\u0120if", "\u0120(", "wake", "up", "Event", "Name", ".", "equ", "als", "(", "event", "Layout", ".", "event", "S", "ched", "Process", "W", "aking", "())", "\u0120&&", "\u0120(", "event", "Name", ".", "equ", "als", "(", "event", "Layout", ".", "event", "S", "ched", "Process", "W", "aking", "())", "\u0120||", "\u0120event", "Name", ".", "equ", "als", "(", "event", "Layout", ".", "event", "S", "ched", "Process", "W", "ake", "up", "New", "()", ")))", "\u0120{", "\u0120return", "\u0120Non", "Null", "Ut", "ils", ".", "check", "Not", "Null", "(", "Boo", "lean", ".", "TR", "UE", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "wake", "up", "Event", "Name", ".", "equ", "als", "(", "event", "Layout", ".", "event", "S", "ched", "Process", "TT", "W", "U", "())", "\u0120&&", "\u0120event", "Name", ".", "equ", "als", "(", "event", "Layout", ".", "event", "S", "ched", "Process", "TT", "W", "U", "()", "))", "\u0120{", "\u0120return", "\u0120Non", "Null", "Ut", "ils", ".", "check", "Not", "Null", "(", "Boo", "lean", ".", "TR", "UE", ");", "\u0120}", "\u0120return", "\u0120Non", "Null", "Ut", "ils", ".", "check", "Not", "Null", "(", "Boo", "lean", ".", "F", "ALSE", ");", "\u0120}"], "docstring_tokens": ["why", "\u0120not", "\u0120boolean", "?", "\u0120(", "lower", "case", "?)"]}
{"function": "private void triggerDeveloperBan(final CertifiedProductSearchDetails updatedListing) { Scheduler scheduler; try { scheduler = getScheduler(); TriggerKey triggerId = triggerKey(\"triggerBanNow_\" + new Date().getTime(), \"triggerDeveloperBanTrigger\"); JobKey jobId = jobKey(\"Trigger Developer Ban Notification\", \"chplJobs\"); Trigger qzTrigger = newTrigger() .withIdentity(triggerId) .startNow() .forJob(jobId) .usingJobData(\"status\", updatedListing.getCurrentStatus().getStatus().getName()) .usingJobData(\"dbId\", updatedListing.getId()) .usingJobData(\"chplId\", updatedListing.getChplProductNumber()) .usingJobData(\"developer\", updatedListing.getDeveloper().getName()) .usingJobData(\"acb\", updatedListing.getCertifyingBody().get(\"name\").toString()) .usingJobData(\"changeDate\", new Date().getTime()) .usingJobData(\"firstName\", Util.getCurrentUser().getFullName()) .usingJobData(\"lastName\", Util.getCurrentUser().getFriendlyName()) .usingJobData(\"effectiveDate\", updatedListing.getCurrentStatus().getEventDate()) .usingJobData(\"openNcs\", updatedListing.getCountOpenNonconformities()) .usingJobData(\"closedNcs\", updatedListing.getCountClosedNonconformities()) .build(); scheduler.scheduleJob(qzTrigger); } catch (SchedulerException e) { LOGGER.error(\"Could not start Trigger Developer Ban\", e); } }", "text": "Does it matter that \"firstName\" and \"lastName\" are still the keys here? Probably should be full and friendly anyway?", "function_tokens": ["private", "\u0120void", "\u0120trigger", "Developer", "Ban", "(", "final", "\u0120Certified", "Product", "Search", "Details", "\u0120updated", "List", "ing", ")", "\u0120{", "\u0120Sched", "uler", "\u0120sched", "uler", ";", "\u0120try", "\u0120{", "\u0120sched", "uler", "\u0120=", "\u0120get", "S", "ched", "uler", "();", "\u0120Trigger", "Key", "\u0120trigger", "Id", "\u0120=", "\u0120trigger", "Key", "(\"", "trigger", "Ban", "Now", "_", "\"", "\u0120+", "\u0120new", "\u0120Date", "().", "get", "Time", "(),", "\u0120\"", "trigger", "Developer", "Ban", "Trigger", "\");", "\u0120Job", "Key", "\u0120job", "Id", "\u0120=", "\u0120job", "Key", "(\"", "Trigger", "\u0120Developer", "\u0120Ban", "\u0120Notification", "\",", "\u0120\"", "ch", "pl", "J", "obs", "\");", "\u0120Trigger", "\u0120q", "z", "Trigger", "\u0120=", "\u0120new", "Trigger", "()", "\u0120.", "with", "Id", "entity", "(", "trigger", "Id", ")", "\u0120.", "start", "Now", "()", "\u0120.", "for", "Job", "(", "job", "Id", ")", "\u0120.", "using", "Job", "Data", "(\"", "status", "\",", "\u0120updated", "List", "ing", ".", "get", "Current", "Status", "().", "get", "Status", "().", "get", "Name", "())", "\u0120.", "using", "Job", "Data", "(\"", "db", "Id", "\",", "\u0120updated", "List", "ing", ".", "get", "Id", "())", "\u0120.", "using", "Job", "Data", "(\"", "ch", "pl", "Id", "\",", "\u0120updated", "List", "ing", ".", "get", "Ch", "pl", "Product", "Number", "())", "\u0120.", "using", "Job", "Data", "(\"", "develop", "er", "\",", "\u0120updated", "List", "ing", ".", "get", "Developer", "().", "get", "Name", "())", "\u0120.", "using", "Job", "Data", "(\"", "ac", "b", "\",", "\u0120updated", "List", "ing", ".", "get", "Cert", "ifying", "Body", "().", "get", "(\"", "name", "\").", "to", "String", "())", "\u0120.", "using", "Job", "Data", "(\"", "change", "Date", "\",", "\u0120new", "\u0120Date", "().", "get", "Time", "())", "\u0120.", "using", "Job", "Data", "(\"", "first", "Name", "\",", "\u0120Ut", "il", ".", "get", "Current", "User", "().", "get", "Full", "Name", "())", "\u0120.", "using", "Job", "Data", "(\"", "last", "Name", "\",", "\u0120Ut", "il", ".", "get", "Current", "User", "().", "get", "Friend", "ly", "Name", "())", "\u0120.", "using", "Job", "Data", "(\"", "effective", "Date", "\",", "\u0120updated", "List", "ing", ".", "get", "Current", "Status", "().", "get", "Event", "Date", "())", "\u0120.", "using", "Job", "Data", "(\"", "open", "N", "cs", "\",", "\u0120updated", "List", "ing", ".", "get", "Count", "Open", "Non", "con", "form", "ities", "())", "\u0120.", "using", "Job", "Data", "(\"", "closed", "N", "cs", "\",", "\u0120updated", "List", "ing", ".", "get", "Count", "Cl", "osed", "Non", "con", "form", "ities", "())", "\u0120.", "build", "();", "\u0120sched", "uler", ".", "sche", "dule", "Job", "(", "q", "z", "Trigger", ");", "\u0120}", "\u0120catch", "\u0120(", "S", "ched", "uler", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(\"", "Could", "\u0120not", "\u0120start", "\u0120Trigger", "\u0120Developer", "\u0120Ban", "\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Does", "\u0120it", "\u0120matter", "\u0120that", "\u0120\"", "first", "Name", "\"", "\u0120and", "\u0120\"", "last", "Name", "\"", "\u0120are", "\u0120still", "\u0120the", "\u0120keys", "\u0120here", "?", "\u0120Probably", "\u0120should", "\u0120be", "\u0120full", "\u0120and", "\u0120friendly", "\u0120anyway", "?"]}
{"function": "protected boolean updateSelection(IStructuredSelection selection) { if (!super.updateSelection(selection)) { return false; } final IResource[][] clipboardData = new IResource[1][]; shell.getDisplay().syncExec(new Runnable() { @Override public void run() { ResourceTransfer resTransfer = ResourceTransfer.getInstance(); clipboardData[0] = (IResource[]) clipboard.getContents(resTransfer); } }); IResource[] resourceData = clipboardData[0]; boolean isProjectRes = resourceData != null && resourceData.length > 0 && resourceData[0].getType() == IResource.PROJECT; if (isProjectRes) { for (IResource element : resourceData) { if (element.getType() != IResource.PROJECT || ((IProject) element).isOpen() == false) { return false; } } return true; } if (getSelectedNonResources().size() > 0) { return false; } IResource targetResource = getTarget(); if (targetResource == null) { return false; } List<? extends IResource> selectedResources = getSelectedResources(); if (selectedResources.size() > 1) { for (IResource resource : selectedResources) { if (resource.getType() != IResource.FILE) { return false; } if (!targetResource.equals(resource.getParent())) { return false; } } } if (resourceData != null) { if (isLinked(resourceData) && targetResource.getType() != IResource.PROJECT && targetResource.getType() != IResource.FOLDER) { return false; } if (targetResource.getType() == IResource.FOLDER) { for (IResource element : resourceData) { if (targetResource.equals(element)) { return false; } } } return true; } TransferData[] transfers = clipboard.getAvailableTypes(); FileTransfer fileTransfer = FileTransfer.getInstance(); for (TransferData transfer : transfers) { if (fileTransfer.isSupportedType(transfer)) { return true; } } return false; }", "text": "rename 'resource'", "function_tokens": ["protected", "\u0120boolean", "\u0120update", "Se", "lection", "(", "I", "Struct", "ured", "Se", "lection", "\u0120selection", ")", "\u0120{", "\u0120if", "\u0120(!", "super", ".", "update", "Se", "lection", "(", "selection", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120final", "\u0120I", "Resource", "[", "][", "]", "\u0120clipboard", "Data", "\u0120=", "\u0120new", "\u0120I", "Resource", "[", "1", "][", "];", "\u0120shell", ".", "get", "Display", "().", "sync", "Exec", "(", "new", "\u0120Run", "n", "able", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120Resource", "Transfer", "\u0120res", "Transfer", "\u0120=", "\u0120Resource", "Transfer", ".", "get", "Instance", "();", "\u0120clipboard", "Data", "[", "0", "]", "\u0120=", "\u0120(", "IR", "es", "ource", "[", "])", "\u0120clipboard", ".", "get", "Contents", "(", "res", "Transfer", ");", "\u0120}", "\u0120});", "\u0120I", "Resource", "[]", "\u0120resource", "Data", "\u0120=", "\u0120clipboard", "Data", "[", "0", "];", "\u0120boolean", "\u0120is", "Project", "Res", "\u0120=", "\u0120resource", "Data", "\u0120!=", "\u0120null", "\u0120&&", "\u0120resource", "Data", ".", "length", "\u0120>", "\u01200", "\u0120&&", "\u0120resource", "Data", "[", "0", "].", "get", "Type", "()", "\u0120==", "\u0120I", "Resource", ".", "PRO", "JECT", ";", "\u0120if", "\u0120(", "is", "Project", "Res", ")", "\u0120{", "\u0120for", "\u0120(", "IR", "es", "ource", "\u0120element", "\u0120:", "\u0120resource", "Data", ")", "\u0120{", "\u0120if", "\u0120(", "element", ".", "get", "Type", "()", "\u0120!=", "\u0120I", "Resource", ".", "PRO", "JECT", "\u0120||", "\u0120((", "I", "Project", ")", "\u0120element", ").", "is", "Open", "()", "\u0120==", "\u0120false", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "get", "Se", "lected", "Non", "Resources", "().", "size", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120I", "Resource", "\u0120target", "Resource", "\u0120=", "\u0120get", "Target", "();", "\u0120if", "\u0120(", "target", "Resource", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120List", "<?", "\u0120extends", "\u0120I", "Resource", ">", "\u0120selected", "Resources", "\u0120=", "\u0120get", "Se", "lected", "Resources", "();", "\u0120if", "\u0120(", "selected", "Resources", ".", "size", "()", "\u0120>", "\u01201", ")", "\u0120{", "\u0120for", "\u0120(", "IR", "es", "ource", "\u0120resource", "\u0120:", "\u0120selected", "Resources", ")", "\u0120{", "\u0120if", "\u0120(", "resource", ".", "get", "Type", "()", "\u0120!=", "\u0120I", "Resource", ".", "FILE", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(!", "target", "Resource", ".", "equ", "als", "(", "resource", ".", "get", "Parent", "()", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "resource", "Data", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "is", "Link", "ed", "(", "resource", "Data", ")", "\u0120&&", "\u0120target", "Resource", ".", "get", "Type", "()", "\u0120!=", "\u0120I", "Resource", ".", "PRO", "JECT", "\u0120&&", "\u0120target", "Resource", ".", "get", "Type", "()", "\u0120!=", "\u0120I", "Resource", ".", "F", "OL", "DER", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "target", "Resource", ".", "get", "Type", "()", "\u0120==", "\u0120I", "Resource", ".", "F", "OL", "DER", ")", "\u0120{", "\u0120for", "\u0120(", "IR", "es", "ource", "\u0120element", "\u0120:", "\u0120resource", "Data", ")", "\u0120{", "\u0120if", "\u0120(", "target", "Resource", ".", "equ", "als", "(", "element", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120Transfer", "Data", "[]", "\u0120transfers", "\u0120=", "\u0120clipboard", ".", "get", "Available", "Types", "();", "\u0120File", "Transfer", "\u0120file", "Transfer", "\u0120=", "\u0120File", "Transfer", ".", "get", "Instance", "();", "\u0120for", "\u0120(", "Transfer", "Data", "\u0120transfer", "\u0120:", "\u0120transfers", ")", "\u0120{", "\u0120if", "\u0120(", "file", "Transfer", ".", "is", "Supported", "Type", "(", "transfer", "))", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["ren", "ame", "\u0120'", "resource", "'"]}
{"function": "public void destroyTelephonyConference() { for (Connection c : getConnections()) { notifyConferenceMembershipChanged(c); } destroy(); }", "text": "It doesn;t look like the membership of these connections have been changed yet.. Should removeTelephonyConnection be called for all of the connections first?", "function_tokens": ["public", "\u0120void", "\u0120destroy", "Tele", "phony", "Con", "ference", "()", "\u0120{", "\u0120for", "\u0120(", "Connection", "\u0120c", "\u0120:", "\u0120get", "Connect", "ions", "())", "\u0120{", "\u0120notify", "Con", "ference", "Members", "hip", "Changed", "(", "c", ");", "\u0120}", "\u0120destroy", "();", "\u0120}"], "docstring_tokens": ["It", "\u0120doesn", ";", "t", "\u0120look", "\u0120like", "\u0120the", "\u0120membership", "\u0120of", "\u0120these", "\u0120connections", "\u0120have", "\u0120been", "\u0120changed", "\u0120yet", "..", "\u0120Should", "\u0120remove", "Tele", "phony", "Connection", "\u0120be", "\u0120called", "\u0120for", "\u0120all", "\u0120of", "\u0120the", "\u0120connections", "\u0120first", "?"]}
{"function": "private long getWatermarkMs(String realtimeTableName, List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata, long bucketMs) { RealtimeToOfflineSegmentsTaskMetadata realtimeToOfflineSegmentsTaskMetadata = _clusterInfoAccessor.getMinionRealtimeToOfflineSegmentsTaskMetadata(realtimeTableName); if (realtimeToOfflineSegmentsTaskMetadata == null) { long watermarkMs; long minStartTimeMs = Long.MAX_VALUE; for (LLCRealtimeSegmentZKMetadata realtimeSegmentZKMetadata : completedSegmentsMetadata) { minStartTimeMs = Math.min(minStartTimeMs, realtimeSegmentZKMetadata.getStartTimeMs()); } watermarkMs = (minStartTimeMs / bucketMs) * bucketMs; realtimeToOfflineSegmentsTaskMetadata = new RealtimeToOfflineSegmentsTaskMetadata(realtimeTableName, watermarkMs); _clusterInfoAccessor.setRealtimeToOfflineSegmentsTaskMetadata(realtimeToOfflineSegmentsTaskMetadata); } return realtimeToOfflineSegmentsTaskMetadata.getWatermarkMs(); }", "text": "Do we want to add  Preconditions.checkState(minStartTimeMs != Long.MAX_VALUE);  to throw the exception at the same condition?", "function_tokens": ["private", "\u0120long", "\u0120get", "Water", "mark", "Ms", "(", "String", "\u0120real", "time", "Table", "Name", ",", "\u0120List", "<", "LL", "CR", "eal", "time", "Seg", "ment", "Z", "K", "Met", "adata", ">", "\u0120completed", "Seg", "ments", "Met", "adata", ",", "\u0120long", "\u0120bucket", "Ms", ")", "\u0120{", "\u0120Real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "\u0120real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "\u0120=", "\u0120_", "cl", "uster", "Info", "Access", "or", ".", "get", "Min", "ion", "Real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "(", "real", "time", "Table", "Name", ");", "\u0120if", "\u0120(", "real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120long", "\u0120water", "mark", "Ms", ";", "\u0120long", "\u0120min", "Start", "Time", "Ms", "\u0120=", "\u0120Long", ".", "MAX", "_", "VALUE", ";", "\u0120for", "\u0120(", "LL", "CR", "eal", "time", "Seg", "ment", "Z", "K", "Met", "adata", "\u0120real", "time", "Seg", "ment", "Z", "K", "Met", "adata", "\u0120:", "\u0120completed", "Seg", "ments", "Met", "adata", ")", "\u0120{", "\u0120min", "Start", "Time", "Ms", "\u0120=", "\u0120Math", ".", "min", "(", "min", "Start", "Time", "Ms", ",", "\u0120real", "time", "Seg", "ment", "Z", "K", "Met", "adata", ".", "get", "Start", "Time", "Ms", "());", "\u0120}", "\u0120water", "mark", "Ms", "\u0120=", "\u0120(", "min", "Start", "Time", "Ms", "\u0120/", "\u0120bucket", "Ms", ")", "\u0120*", "\u0120bucket", "Ms", ";", "\u0120real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "\u0120=", "\u0120new", "\u0120Real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "(", "real", "time", "Table", "Name", ",", "\u0120water", "mark", "Ms", ");", "\u0120_", "cl", "uster", "Info", "Access", "or", ".", "set", "Real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", "(", "real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", ");", "\u0120}", "\u0120return", "\u0120real", "time", "To", "Offline", "Seg", "ments", "Task", "Met", "adata", ".", "get", "Water", "mark", "Ms", "();", "\u0120}"], "docstring_tokens": ["Do", "\u0120we", "\u0120want", "\u0120to", "\u0120add", "\u0120", "\u0120Pre", "cond", "itions", ".", "check", "State", "(", "min", "Start", "Time", "Ms", "\u0120!=", "\u0120Long", ".", "MAX", "_", "VALUE", ");", "\u0120", "\u0120to", "\u0120throw", "\u0120the", "\u0120exception", "\u0120at", "\u0120the", "\u0120same", "\u0120condition", "?"]}
{"function": "private static void printTumorTypeSummary(Set<Evidence> evidences, SpreadsheetService service, WorksheetEntry entry) throws IOException, ServiceException { URL feedUrl = entry.getListFeedUrl(); if (evidences != null && service != null && entry != null) { for (Evidence evidence : evidences) { ListEntry row = new ListEntry(); setValue(row, \"Gene\", evidence.getGene().getHugoSymbol()); List<String> alterationNames = new ArrayList<>(); for (Alteration alteration : evidence.getAlterations()) { if (StringUtils.isNullOrEmpty(alteration.getName())) { alterationNames.add(alteration.getAlteration()); } else { alterationNames.add(alteration.getName()); } } setValue(row, \"Variants\", MainUtils.listToString(alterationNames, \", \")); setValue(row, \"CancerType\", getCancerType(evidence.getOncoTreeType())); setValue(row, \"Summary\", evidence.getDescription()); service.insert(feedUrl, row); } } }", "text": "Put this snippet of getting alterationNames into a function. Since the same code is used in printEvidences()", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120print", "T", "um", "or", "Type", "Summary", "(", "Set", "<", "Evidence", ">", "\u0120evid", "ences", ",", "\u0120Spread", "sheet", "Service", "\u0120service", ",", "\u0120Works", "heet", "Entry", "\u0120entry", ")", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Service", "Exception", "\u0120{", "\u0120URL", "\u0120feed", "Url", "\u0120=", "\u0120entry", ".", "get", "List", "Feed", "Url", "();", "\u0120if", "\u0120(", "ev", "idences", "\u0120!=", "\u0120null", "\u0120&&", "\u0120service", "\u0120!=", "\u0120null", "\u0120&&", "\u0120entry", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "Evidence", "\u0120evidence", "\u0120:", "\u0120evid", "ences", ")", "\u0120{", "\u0120List", "Entry", "\u0120row", "\u0120=", "\u0120new", "\u0120List", "Entry", "();", "\u0120set", "Value", "(", "row", ",", "\u0120\"", "Gene", "\",", "\u0120evidence", ".", "get", "Gene", "().", "get", "Hug", "o", "Sy", "mbol", "());", "\u0120List", "<", "String", ">", "\u0120alteration", "Names", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "\u0120(", "Al", "ter", "ation", "\u0120alteration", "\u0120:", "\u0120evidence", ".", "get", "Al", "ter", "ations", "())", "\u0120{", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Null", "Or", "Empty", "(", "alter", "ation", ".", "get", "Name", "()", "))", "\u0120{", "\u0120alteration", "Names", ".", "add", "(", "alter", "ation", ".", "get", "Al", "ter", "ation", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120alteration", "Names", ".", "add", "(", "alter", "ation", ".", "get", "Name", "());", "\u0120}", "\u0120}", "\u0120set", "Value", "(", "row", ",", "\u0120\"", "Vari", "ants", "\",", "\u0120Main", "Ut", "ils", ".", "list", "To", "String", "(", "alter", "ation", "Names", ",", "\u0120\",", "\u0120\"", "));", "\u0120set", "Value", "(", "row", ",", "\u0120\"", "C", "ancer", "Type", "\",", "\u0120get", "C", "ancer", "Type", "(", "evidence", ".", "get", "On", "co", "Tree", "Type", "()", "));", "\u0120set", "Value", "(", "row", ",", "\u0120\"", "Summary", "\",", "\u0120evidence", ".", "get", "Description", "());", "\u0120service", ".", "insert", "(", "feed", "Url", ",", "\u0120row", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Put", "\u0120this", "\u0120snippet", "\u0120of", "\u0120getting", "\u0120alteration", "Names", "\u0120into", "\u0120a", "\u0120function", ".", "\u0120Since", "\u0120the", "\u0120same", "\u0120code", "\u0120is", "\u0120used", "\u0120in", "\u0120print", "Ev", "idences", "()"]}
{"function": "public static void createProjects( final Set<ProjectRecord> projectsToCreate, final boolean open, final IWorkingSet[] selectedWorkingSets, IProgressMonitor monitor) throws InvocationTargetException, InterruptedException { IWorkspaceRunnable wsr = new IWorkspaceRunnable() { @Override public void run(IProgressMonitor actMonitor) throws CoreException { IWorkingSetManager workingSetManager = PlatformUI .getWorkbench().getWorkingSetManager(); try { actMonitor.beginTask(\"\", projectsToCreate.size() * 2 + 1); if (actMonitor.isCanceled()) throw new OperationCanceledException(); Map<IProject, File> projectsToConnect = new HashMap<>(); for (ProjectRecord projectRecord : projectsToCreate) { if (actMonitor.isCanceled()) throw new OperationCanceledException(); actMonitor.subTask(projectRecord.getProjectLabel()); IProject project = createExistingProject(projectRecord, open, SubMonitor.convert(actMonitor, 1)); if (project == null) continue; RepositoryFinder finder = new RepositoryFinder(project); finder.setFindInChildren(false); Collection<RepositoryMapping> mappings = finder .find(SubMonitor.convert(actMonitor, 1)); if (!mappings.isEmpty()) { RepositoryMapping mapping = mappings.iterator() .next(); IPath absolutePath = mapping .getGitDirAbsolutePath(); if (absolutePath != null) { projectsToConnect.put(project, absolutePath.toFile()); } } if (selectedWorkingSets != null && selectedWorkingSets.length > 0) workingSetManager.addToWorkingSets(project, selectedWorkingSets); } if (!projectsToConnect.isEmpty()) { ConnectProviderOperation connect = new ConnectProviderOperation( projectsToConnect); connect.execute(SubMonitor.convert(actMonitor, 1)); } } finally { actMonitor.done(); } } }; try { ResourcesPlugin.getWorkspace().run(wsr, monitor); } catch (OperationCanceledException e) { throw new InterruptedException(); } catch (CoreException e) { throw new InvocationTargetException(e); } }", "text": "I don't think one should convert the same monitor multiple times. Use SubMonitor progress = SubMonitor.convert(actMonitor, projectsToCreate.size() * 2 + 1); at the top and then use only progress, not actMonitor, and use progress.newChild(1) here and below.", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120create", "Project", "s", "(", "\u0120final", "\u0120Set", "<", "Project", "Record", ">", "\u0120projects", "To", "Create", ",", "\u0120final", "\u0120boolean", "\u0120open", ",", "\u0120final", "\u0120I", "Working", "Set", "[]", "\u0120selected", "Working", "S", "ets", ",", "\u0120I", "Progress", "Monitor", "\u0120monitor", ")", "\u0120throws", "\u0120Inv", "ocation", "Target", "Exception", ",", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120I", "Works", "pace", "Run", "n", "able", "\u0120w", "sr", "\u0120=", "\u0120new", "\u0120I", "Works", "pace", "Run", "n", "able", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "(", "I", "Progress", "Monitor", "\u0120act", "Monitor", ")", "\u0120throws", "\u0120Core", "Exception", "\u0120{", "\u0120I", "Working", "Set", "Manager", "\u0120working", "Set", "Manager", "\u0120=", "\u0120Platform", "UI", "\u0120.", "get", "Work", "bench", "().", "get", "Working", "Set", "Manager", "();", "\u0120try", "\u0120{", "\u0120act", "Monitor", ".", "begin", "Task", "(\"", "\",", "\u0120projects", "To", "Create", ".", "size", "()", "\u0120*", "\u01202", "\u0120+", "\u01201", ");", "\u0120if", "\u0120(", "act", "Monitor", ".", "is", "C", "ance", "led", "())", "\u0120throw", "\u0120new", "\u0120Operation", "C", "ance", "led", "Exception", "();", "\u0120Map", "<", "I", "Project", ",", "\u0120File", ">", "\u0120projects", "To", "Connect", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120for", "\u0120(", "Project", "Record", "\u0120project", "Record", "\u0120:", "\u0120projects", "To", "Create", ")", "\u0120{", "\u0120if", "\u0120(", "act", "Monitor", ".", "is", "C", "ance", "led", "())", "\u0120throw", "\u0120new", "\u0120Operation", "C", "ance", "led", "Exception", "();", "\u0120act", "Monitor", ".", "sub", "Task", "(", "project", "Record", ".", "get", "Project", "Label", "());", "\u0120I", "Project", "\u0120project", "\u0120=", "\u0120create", "Ex", "isting", "Project", "(", "project", "Record", ",", "\u0120open", ",", "\u0120Sub", "Monitor", ".", "con", "vert", "(", "act", "Monitor", ",", "\u01201", "));", "\u0120if", "\u0120(", "project", "\u0120==", "\u0120null", ")", "\u0120continue", ";", "\u0120Rep", "ository", "F", "inder", "\u0120find", "er", "\u0120=", "\u0120new", "\u0120Rep", "ository", "F", "inder", "(", "project", ");", "\u0120find", "er", ".", "set", "Find", "In", "Children", "(", "false", ");", "\u0120Collection", "<", "Rep", "ository", "M", "apping", ">", "\u0120m", "appings", "\u0120=", "\u0120find", "er", "\u0120.", "find", "(", "Sub", "Monitor", ".", "con", "vert", "(", "act", "Monitor", ",", "\u01201", "));", "\u0120if", "\u0120(!", "m", "appings", ".", "is", "Empty", "())", "\u0120{", "\u0120Rep", "ository", "M", "apping", "\u0120mapping", "\u0120=", "\u0120m", "appings", ".", "iterator", "()", "\u0120.", "next", "();", "\u0120IP", "ath", "\u0120absolute", "Path", "\u0120=", "\u0120mapping", "\u0120.", "get", "G", "it", "Dir", "Abs", "olute", "Path", "();", "\u0120if", "\u0120(", "absolute", "Path", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120projects", "To", "Connect", ".", "put", "(", "project", ",", "\u0120absolute", "Path", ".", "to", "File", "());", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "selected", "Working", "S", "ets", "\u0120!=", "\u0120null", "\u0120&&", "\u0120selected", "Working", "S", "ets", ".", "length", "\u0120>", "\u01200", ")", "\u0120working", "Set", "Manager", ".", "add", "To", "Working", "S", "ets", "(", "project", ",", "\u0120selected", "Working", "S", "ets", ");", "\u0120}", "\u0120if", "\u0120(!", "projects", "To", "Connect", ".", "is", "Empty", "())", "\u0120{", "\u0120Connect", "Provider", "Operation", "\u0120connect", "\u0120=", "\u0120new", "\u0120Connect", "Provider", "Operation", "(", "\u0120projects", "To", "Connect", ");", "\u0120connect", ".", "execute", "(", "Sub", "Monitor", ".", "con", "vert", "(", "act", "Monitor", ",", "\u01201", "));", "\u0120}", "\u0120}", "\u0120finally", "\u0120{", "\u0120act", "Monitor", ".", "done", "();", "\u0120}", "\u0120}", "\u0120};", "\u0120try", "\u0120{", "\u0120Resources", "Plugin", ".", "get", "Works", "pace", "().", "run", "(", "ws", "r", ",", "\u0120monitor", ");", "\u0120}", "\u0120catch", "\u0120(", "Operation", "C", "ance", "led", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Inter", "rupted", "Exception", "();", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Inv", "ocation", "Target", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120one", "\u0120should", "\u0120convert", "\u0120the", "\u0120same", "\u0120monitor", "\u0120multiple", "\u0120times", ".", "\u0120Use", "\u0120Sub", "Monitor", "\u0120progress", "\u0120=", "\u0120Sub", "Monitor", ".", "con", "vert", "(", "act", "Monitor", ",", "\u0120projects", "To", "Create", ".", "size", "()", "\u0120*", "\u01202", "\u0120+", "\u01201", ");", "\u0120at", "\u0120the", "\u0120top", "\u0120and", "\u0120then", "\u0120use", "\u0120only", "\u0120progress", ",", "\u0120not", "\u0120act", "Monitor", ",", "\u0120and", "\u0120use", "\u0120progress", ".", "new", "Child", "(", "1", ")", "\u0120here", "\u0120and", "\u0120below", "."]}
{"function": "private void runTearDown(Throwable exception) throws DeviceNotAvailableException { List<IMultiTargetPreparer> cleanerList = new ArrayList<>(mMultiPreparers); Collections.reverse(cleanerList); for (IMultiTargetPreparer multiCleaner : cleanerList) { if (multiCleaner.isDisabled() || multiCleaner.isTearDownDisabled()) { continue; } CLog.d(\"Running teardown Multi cleaner: %s\", multiCleaner.getClass().getSimpleName()); multiCleaner.tearDown(mModuleInvocationContext, exception); } for (int i = 0; i < mModuleInvocationContext.getDeviceConfigNames().size(); i++) { String deviceName = mModuleInvocationContext.getDeviceConfigNames().get(i); ITestDevice device = mModuleInvocationContext.getDevice(deviceName); if (i >= mPreparersPerDevice.size()) { CLog.d( \"Main configuration has more devices than the module configuration. '%s' \" + \"will not run any tear down.\", deviceName); continue; } List<ITargetPreparer> preparers = mPreparersPerDevice.get(deviceName); if (preparers == null) { CLog.w( \"Module configuration devices mismatch the main configuration \" + \"(Missing device '%s'), resolving preparers by index.\", deviceName); String key = new ArrayList<>(mPreparersPerDevice.keySet()).get(i); preparers = mPreparersPerDevice.get(key); } ListIterator<ITargetPreparer> itr = preparers.listIterator(preparers.size()); while (itr.hasPrevious()) { ITargetPreparer preparer = itr.previous(); if (preparer instanceof ITargetCleaner) { ITargetCleaner cleaner = (ITargetCleaner) preparer; if (cleaner.isDisabled() || cleaner.isTearDownDisabled()) { CLog.d(\"%s has been disabled. skipping.\", cleaner); continue; } RecoveryMode origMode = null; try { if (exception != null && exception instanceof DeviceNotAvailableException) { origMode = device.getRecoveryMode(); device.setRecoveryMode(RecoveryMode.NONE); } cleaner.tearDown( device, mModuleInvocationContext.getBuildInfo(deviceName), exception); } finally { if (origMode != null) { device.setRecoveryMode(origMode); } } } } } }", "text": "m", "function_tokens": ["private", "\u0120void", "\u0120run", "T", "ear", "Down", "(", "Throw", "able", "\u0120exception", ")", "\u0120throws", "\u0120Device", "Not", "Available", "Exception", "\u0120{", "\u0120List", "<", "IM", "ult", "i", "Target", "Prep", "arer", ">", "\u0120cleaner", "List", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">(", "m", "Multi", "Prep", "arers", ");", "\u0120Collections", ".", "reverse", "(", "clean", "er", "List", ");", "\u0120for", "\u0120(", "IM", "ult", "i", "Target", "Prep", "arer", "\u0120multi", "Clean", "er", "\u0120:", "\u0120cleaner", "List", ")", "\u0120{", "\u0120if", "\u0120(", "multi", "Clean", "er", ".", "is", "Dis", "abled", "()", "\u0120||", "\u0120multi", "Clean", "er", ".", "is", "T", "ear", "Down", "Dis", "abled", "())", "\u0120{", "\u0120continue", ";", "\u0120}", "\u0120CL", "og", ".", "d", "(\"", "Running", "\u0120te", "ard", "own", "\u0120Multi", "\u0120cleaner", ":", "\u0120%", "s", "\",", "\u0120multi", "Clean", "er", ".", "get", "Class", "().", "get", "Simple", "Name", "());", "\u0120multi", "Clean", "er", ".", "t", "ear", "Down", "(", "m", "Module", "Inv", "ocation", "Context", ",", "\u0120exception", ");", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120m", "Module", "Inv", "ocation", "Context", ".", "get", "Device", "Config", "Names", "().", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120device", "Name", "\u0120=", "\u0120m", "Module", "Inv", "ocation", "Context", ".", "get", "Device", "Config", "Names", "().", "get", "(", "i", ");", "\u0120IT", "est", "Device", "\u0120device", "\u0120=", "\u0120m", "Module", "Inv", "ocation", "Context", ".", "get", "Device", "(", "device", "Name", ");", "\u0120if", "\u0120(", "i", "\u0120>=", "\u0120m", "Prep", "arers", "Per", "Device", ".", "size", "())", "\u0120{", "\u0120CL", "og", ".", "d", "(", "\u0120\"", "Main", "\u0120configuration", "\u0120has", "\u0120more", "\u0120devices", "\u0120than", "\u0120the", "\u0120module", "\u0120configuration", ".", "\u0120'", "%", "s", "'", "\u0120\"", "\u0120+", "\u0120\"", "will", "\u0120not", "\u0120run", "\u0120any", "\u0120tear", "\u0120down", ".\",", "\u0120device", "Name", ");", "\u0120continue", ";", "\u0120}", "\u0120List", "<", "IT", "arget", "Prep", "arer", ">", "\u0120prepare", "rs", "\u0120=", "\u0120m", "Prep", "arers", "Per", "Device", ".", "get", "(", "device", "Name", ");", "\u0120if", "\u0120(", "prep", "arers", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120CL", "og", ".", "w", "(", "\u0120\"", "Module", "\u0120configuration", "\u0120devices", "\u0120mismatch", "\u0120the", "\u0120main", "\u0120configuration", "\u0120\"", "\u0120+", "\u0120\"(", "Missing", "\u0120device", "\u0120'", "%", "s", "'),", "\u0120resolving", "\u0120prepare", "rs", "\u0120by", "\u0120index", ".\",", "\u0120device", "Name", ");", "\u0120String", "\u0120key", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">(", "m", "Prep", "arers", "Per", "Device", ".", "key", "Set", "()", ").", "get", "(", "i", ");", "\u0120prepare", "rs", "\u0120=", "\u0120m", "Prep", "arers", "Per", "Device", ".", "get", "(", "key", ");", "\u0120}", "\u0120List", "Iterator", "<", "IT", "arget", "Prep", "arer", ">", "\u0120it", "r", "\u0120=", "\u0120prepare", "rs", ".", "list", "Iterator", "(", "prep", "arers", ".", "size", "());", "\u0120while", "\u0120(", "it", "r", ".", "has", "Previous", "())", "\u0120{", "\u0120IT", "arget", "Prep", "arer", "\u0120prepare", "r", "\u0120=", "\u0120it", "r", ".", "pre", "vious", "();", "\u0120if", "\u0120(", "prep", "arer", "\u0120instance", "of", "\u0120IT", "arget", "Clean", "er", ")", "\u0120{", "\u0120IT", "arget", "Clean", "er", "\u0120cleaner", "\u0120=", "\u0120(", "IT", "arget", "Clean", "er", ")", "\u0120prepare", "r", ";", "\u0120if", "\u0120(", "clean", "er", ".", "is", "Dis", "abled", "()", "\u0120||", "\u0120cleaner", ".", "is", "T", "ear", "Down", "Dis", "abled", "())", "\u0120{", "\u0120CL", "og", ".", "d", "(\"", "%", "s", "\u0120has", "\u0120been", "\u0120disabled", ".", "\u0120skipping", ".\",", "\u0120cleaner", ");", "\u0120continue", ";", "\u0120}", "\u0120Recovery", "Mode", "\u0120orig", "Mode", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "ex", "ception", "\u0120!=", "\u0120null", "\u0120&&", "\u0120exception", "\u0120instance", "of", "\u0120Device", "Not", "Available", "Exception", ")", "\u0120{", "\u0120orig", "Mode", "\u0120=", "\u0120device", ".", "get", "Rec", "overy", "Mode", "();", "\u0120device", ".", "set", "Rec", "overy", "Mode", "(", "Rec", "overy", "Mode", ".", "N", "ONE", ");", "\u0120}", "\u0120cleaner", ".", "t", "ear", "Down", "(", "\u0120device", ",", "\u0120m", "Module", "Inv", "ocation", "Context", ".", "get", "Build", "Info", "(", "device", "Name", "),", "\u0120exception", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120if", "\u0120(", "orig", "Mode", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120device", ".", "set", "Rec", "overy", "Mode", "(", "orig", "Mode", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["m"]}
{"function": "public static String md5(String str) { MessageDigest m = null; try { m = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } m.update(str.getBytes(),0,str.length()); return new BigInteger(1,m.digest()).toString(16); }", "text": "It it better to throw unchecked exception than simply print error because if error occurs then variable 'm' will be null and NullPointerException will be thrown later (line 16). try { m = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); //use logger instead throw new RuntimeException(\"No Such Algorithm: MD5\"); }", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120md", "5", "(", "String", "\u0120str", ")", "\u0120{", "\u0120Message", "Dig", "est", "\u0120m", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120m", "\u0120=", "\u0120Message", "Dig", "est", ".", "get", "Instance", "(\"", "MD", "5", "\");", "\u0120}", "\u0120catch", "\u0120(", "No", "Such", "Al", "gorithm", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120m", ".", "update", "(", "str", ".", "get", "Bytes", "(),", "0", ",", "str", ".", "length", "());", "\u0120return", "\u0120new", "\u0120Big", "Integer", "(", "1", ",", "m", ".", "dig", "est", "()", ").", "to", "String", "(", "16", ");", "\u0120}"], "docstring_tokens": ["It", "\u0120it", "\u0120better", "\u0120to", "\u0120throw", "\u0120unchecked", "\u0120exception", "\u0120than", "\u0120simply", "\u0120print", "\u0120error", "\u0120because", "\u0120if", "\u0120error", "\u0120occurs", "\u0120then", "\u0120variable", "\u0120'", "m", "'", "\u0120will", "\u0120be", "\u0120null", "\u0120and", "\u0120Null", "Po", "inter", "Exception", "\u0120will", "\u0120be", "\u0120thrown", "\u0120later", "\u0120(", "line", "\u012016", ").", "\u0120try", "\u0120{", "\u0120m", "\u0120=", "\u0120Message", "Dig", "est", ".", "get", "Instance", "(\"", "MD", "5", "\");", "\u0120}", "\u0120catch", "\u0120(", "No", "Such", "Al", "gorithm", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120//", "use", "\u0120logger", "\u0120instead", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "No", "\u0120Such", "\u0120Al", "gorithm", ":", "\u0120MD", "5", "\");", "\u0120}"]}
{"function": "public Map<K, V> removeAll(BiPredicate<? super K, ? super V> predicate) { Objects.requireNonNull(predicate, \"predicate is null\"); return filter(predicate.negate()); }", "text": "the return type should be M", "function_tokens": ["public", "\u0120Map", "<", "K", ",", "\u0120V", ">", "\u0120remove", "All", "(", "Bi", "Pred", "icate", "<?", "\u0120super", "\u0120K", ",", "\u0120?", "\u0120super", "\u0120V", ">", "\u0120predicate", ")", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "pred", "icate", ",", "\u0120\"", "pred", "icate", "\u0120is", "\u0120null", "\");", "\u0120return", "\u0120filter", "(", "pred", "icate", ".", "ne", "gate", "());", "\u0120}"], "docstring_tokens": ["the", "\u0120return", "\u0120type", "\u0120should", "\u0120be", "\u0120M"]}
{"function": "static Path getCMPath(Configuration conf, String checkSum) throws IOException, MetaException { String newFileName = checkSum; int maxLength = conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY, DFSConfigKeys.DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT); if (newFileName.length() > maxLength) { newFileName = newFileName.substring(0, maxLength-1); } return new Path(cmroot, newFileName); }", "text": "Looks like getCMPath never throw IOException or MetaException. Shall check and remove it.", "function_tokens": ["static", "\u0120Path", "\u0120get", "C", "MP", "ath", "(", "Configuration", "\u0120conf", ",", "\u0120String", "\u0120check", "Sum", ")", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Meta", "Exception", "\u0120{", "\u0120String", "\u0120new", "File", "Name", "\u0120=", "\u0120check", "Sum", ";", "\u0120int", "\u0120max", "Length", "\u0120=", "\u0120conf", ".", "get", "Int", "(", "DF", "S", "Config", "Keys", ".", "DF", "S", "_", "N", "AM", "EN", "ODE", "_", "MAX", "_", "COM", "P", "ON", "ENT", "_", "L", "ENGTH", "_", "KEY", ",", "\u0120D", "FS", "Config", "Keys", ".", "DF", "S", "_", "N", "AM", "EN", "ODE", "_", "MAX", "_", "COM", "P", "ON", "ENT", "_", "L", "ENGTH", "_", "DE", "FAULT", ");", "\u0120if", "\u0120(", "new", "File", "Name", ".", "length", "()", "\u0120>", "\u0120max", "Length", ")", "\u0120{", "\u0120new", "File", "Name", "\u0120=", "\u0120new", "File", "Name", ".", "sub", "string", "(", "0", ",", "\u0120max", "Length", "-", "1", ");", "\u0120}", "\u0120return", "\u0120new", "\u0120Path", "(", "cm", "root", ",", "\u0120new", "File", "Name", ");", "\u0120}"], "docstring_tokens": ["Looks", "\u0120like", "\u0120get", "C", "MP", "ath", "\u0120never", "\u0120throw", "\u0120IO", "Exception", "\u0120or", "\u0120Meta", "Exception", ".", "\u0120Shall", "\u0120check", "\u0120and", "\u0120remove", "\u0120it", "."]}
{"function": "public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { ApplicationEnvironmentPreparedEvent castEvent = (ApplicationEnvironmentPreparedEvent) event; String componentName = castEvent.getEnvironment().getProperty(\"info.component\"); LOG.info(\"Setting service name to {}\", componentName); CommonLogHolder.setServiceType(componentName); } if (event instanceof ApplicationFailedEvent) { LOG.info(\"Terminating default logging context\"); ((LoggerContext) LoggerFactory.getILoggerFactory()).reset(); BasicConfigurator.configureDefaultContext(); } }", "text": "Can this be overloaded to avoid the casts?", "function_tokens": ["public", "\u0120void", "\u0120on", "Application", "Event", "(", "Application", "Event", "\u0120event", ")", "\u0120{", "\u0120if", "\u0120(", "event", "\u0120instance", "of", "\u0120Application", "Environment", "Pre", "pared", "Event", ")", "\u0120{", "\u0120Application", "Environment", "Pre", "pared", "Event", "\u0120cast", "Event", "\u0120=", "\u0120(", "Application", "Environment", "Pre", "pared", "Event", ")", "\u0120event", ";", "\u0120String", "\u0120component", "Name", "\u0120=", "\u0120cast", "Event", ".", "get", "Environment", "().", "get", "Property", "(\"", "info", ".", "component", "\");", "\u0120LOG", ".", "info", "(\"", "Setting", "\u0120service", "\u0120name", "\u0120to", "\u0120{}", "\",", "\u0120component", "Name", ");", "\u0120Common", "Log", "H", "older", ".", "set", "Service", "Type", "(", "component", "Name", ");", "\u0120}", "\u0120if", "\u0120(", "event", "\u0120instance", "of", "\u0120Application", "F", "ailed", "Event", ")", "\u0120{", "\u0120LOG", ".", "info", "(\"", "Termin", "ating", "\u0120default", "\u0120logging", "\u0120context", "\");", "\u0120((", "Log", "ger", "Context", ")", "\u0120Log", "ger", "Factory", ".", "get", "IL", "og", "ger", "Factory", "()", ").", "reset", "();", "\u0120Basic", "Config", "ur", "ator", ".", "config", "ure", "Default", "Context", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Can", "\u0120this", "\u0120be", "\u0120overloaded", "\u0120to", "\u0120avoid", "\u0120the", "\u0120casts", "?"]}
{"function": "private String getBundleVersion() { ClassLoader cl = getClass().getClassLoader(); if (cl instanceof URLClassLoader) { URL url = ((URLClassLoader) cl).findResource(JarFile.MANIFEST_NAME); try { Manifest manifest = new Manifest(url.openStream()); return manifest.getMainAttributes().getValue(\"Bundle-Version\"); } catch (IOException e) { } } return null; }", "text": "url should be checked for null.", "function_tokens": ["private", "\u0120String", "\u0120get", "B", "undle", "Version", "()", "\u0120{", "\u0120Class", "Loader", "\u0120cl", "\u0120=", "\u0120get", "Class", "().", "get", "Class", "Loader", "();", "\u0120if", "\u0120(", "cl", "\u0120instance", "of", "\u0120URL", "Class", "Loader", ")", "\u0120{", "\u0120URL", "\u0120url", "\u0120=", "\u0120((", "URL", "Class", "Loader", ")", "\u0120cl", ").", "find", "Resource", "(", "Jar", "File", ".", "MAN", "IF", "EST", "_", "NAME", ");", "\u0120try", "\u0120{", "\u0120Manifest", "\u0120manifest", "\u0120=", "\u0120new", "\u0120Manifest", "(", "url", ".", "open", "Stream", "());", "\u0120return", "\u0120manifest", ".", "get", "Main", "Attributes", "().", "get", "Value", "(\"", "B", "undle", "-", "Version", "\");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["url", "\u0120should", "\u0120be", "\u0120checked", "\u0120for", "\u0120null", "."]}
{"function": "public Response ackAlert( @ApiParam(required = true, value = \"The alertId to Ack.\", allowableValues = \"An existing alertId.\") @PathParam(\"alertId\") final String alertId, @ApiParam(required = false, value = \"User acknowledging the alerts.\") @QueryParam(\"ackBy\") final String ackBy, @ApiParam(required = false, value = \"Additional notes associated with the acknowledgement.\") @QueryParam(\"ackNotes\") final String ackNotes) { try { if (!isEmpty(alertId)) { alertsService.ackAlerts(tenantId, Arrays.asList(alertId), ackBy, ackNotes); if (log.isDebugEnabled()) { log.debug(\"AlertId: \" + alertId); } return ResponseUtil.ok(); } else { return ResponseUtil.badRequest(\"AlertId required for ack\"); } } catch (Exception e) { log.debug(e.getMessage(), e); if (e.getCause() != null && e.getCause() instanceof IllegalArgumentException) { return ResponseUtil.badRequest(\"Bad arguments: \" + e.getMessage()); } return ResponseUtil.internalError(e); } }", "text": "Let's not break/change the format here. I think each annotation should go in a different line for consistency and readability. Perhaps some automatic formatting from the IDE here.", "function_tokens": ["public", "\u0120Response", "\u0120a", "ck", "Alert", "(", "\u0120@", "A", "pi", "Param", "(", "required", "\u0120=", "\u0120true", ",", "\u0120value", "\u0120=", "\u0120\"", "The", "\u0120alert", "Id", "\u0120to", "\u0120Ack", ".\",", "\u0120allowable", "Values", "\u0120=", "\u0120\"", "An", "\u0120existing", "\u0120alert", "Id", ".\")", "\u0120@", "Path", "Param", "(\"", "alert", "Id", "\")", "\u0120final", "\u0120String", "\u0120alert", "Id", ",", "\u0120@", "A", "pi", "Param", "(", "required", "\u0120=", "\u0120false", ",", "\u0120value", "\u0120=", "\u0120\"", "User", "\u0120acknowledging", "\u0120the", "\u0120alerts", ".\")", "\u0120@", "Query", "Param", "(\"", "ack", "By", "\")", "\u0120final", "\u0120String", "\u0120a", "ck", "By", ",", "\u0120@", "A", "pi", "Param", "(", "required", "\u0120=", "\u0120false", ",", "\u0120value", "\u0120=", "\u0120\"", "Additional", "\u0120notes", "\u0120associated", "\u0120with", "\u0120the", "\u0120acknowledgement", ".\")", "\u0120@", "Query", "Param", "(\"", "ack", "Notes", "\")", "\u0120final", "\u0120String", "\u0120a", "ck", "Notes", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120if", "\u0120(!", "is", "Empty", "(", "alert", "Id", "))", "\u0120{", "\u0120alerts", "Service", ".", "ack", "Alert", "s", "(", "ten", "ant", "Id", ",", "\u0120Ar", "rays", ".", "as", "List", "(", "alert", "Id", "),", "\u0120a", "ck", "By", ",", "\u0120a", "ck", "Notes", ");", "\u0120if", "\u0120(", "log", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120log", ".", "debug", "(\"", "Alert", "Id", ":", "\u0120\"", "\u0120+", "\u0120alert", "Id", ");", "\u0120}", "\u0120return", "\u0120Response", "Ut", "il", ".", "ok", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120Response", "Ut", "il", ".", "bad", "Request", "(\"", "Alert", "Id", "\u0120required", "\u0120for", "\u0120a", "ck", "\");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "debug", "(", "e", ".", "get", "Message", "(),", "\u0120e", ");", "\u0120if", "\u0120(", "e", ".", "get", "Cause", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120e", ".", "get", "Cause", "()", "\u0120instance", "of", "\u0120Illegal", "Arg", "ument", "Exception", ")", "\u0120{", "\u0120return", "\u0120Response", "Ut", "il", ".", "bad", "Request", "(\"", "Bad", "\u0120arguments", ":", "\u0120\"", "\u0120+", "\u0120e", ".", "get", "Message", "());", "\u0120}", "\u0120return", "\u0120Response", "Ut", "il", ".", "internal", "Error", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120not", "\u0120break", "/", "change", "\u0120the", "\u0120format", "\u0120here", ".", "\u0120I", "\u0120think", "\u0120each", "\u0120annotation", "\u0120should", "\u0120go", "\u0120in", "\u0120a", "\u0120different", "\u0120line", "\u0120for", "\u0120consistency", "\u0120and", "\u0120read", "ability", ".", "\u0120Perhaps", "\u0120some", "\u0120automatic", "\u0120formatting", "\u0120from", "\u0120the", "\u0120IDE", "\u0120here", "."]}
{"function": "public static String humanReadable(float bytes) { if (bytes > GB) { return String.format(\"%.03f GB\", bytes / GB); } else if (bytes > MB) { return String.format(\"%.03f MB\", bytes / MB); } else if (bytes > KB) { return String.format(\"%.03f kB\", bytes / KB); } else { return String.format(\"%.02f B\", bytes); } }", "text": "TB too?", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120human", "Read", "able", "(", "float", "\u0120bytes", ")", "\u0120{", "\u0120if", "\u0120(", "bytes", "\u0120>", "\u0120GB", ")", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(\"", "%.", "03", "f", "\u0120GB", "\",", "\u0120bytes", "\u0120/", "\u0120GB", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "bytes", "\u0120>", "\u0120MB", ")", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(\"", "%.", "03", "f", "\u0120MB", "\",", "\u0120bytes", "\u0120/", "\u0120MB", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "bytes", "\u0120>", "\u0120KB", ")", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(\"", "%.", "03", "f", "\u0120k", "B", "\",", "\u0120bytes", "\u0120/", "\u0120KB", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120String", ".", "format", "(\"", "%.", "02", "f", "\u0120B", "\",", "\u0120bytes", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["TB", "\u0120too", "?"]}
{"function": "private void reset() { if (chunk != null) { chunkedInput = new HttpChunkedInput(new RepeatedBytesInput()); request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, path); HttpUtil.setContentLength(request, totalSize); request.headers().add(RestUtils.Headers.BLOB_SIZE, totalSize); request.headers().add(RestUtils.Headers.SERVICE_ID, serviceId); request.headers().add(RestUtils.Headers.AMBRY_CONTENT_TYPE, \"application/octet-stream\"); if (targetAccountName != null) { request.headers().add(RestUtils.Headers.TARGET_ACCOUNT_NAME, targetAccountName); } if (targetContainerName != null) { request.headers().add(RestUtils.Headers.TARGET_CONTAINER_NAME, targetContainerName); } } else { if (pathList == null) { request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path); } else { request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, pathList.get(counter.getAndIncrement() % pathList.size())); } } for (Pair<String, String> headerNameValue : customHeaders) { request.headers().add(headerNameValue.getFirst(), headerNameValue.getSecond()); } chunksReceived = 0; sizeReceived = 0; lastChunkReceiveTime = 0; requestStartTime = System.currentTimeMillis(); response = null; }", "text": "Do you think it's worthwhile to check !targetAccountName.isEmpty() as well? Same for container's check.", "function_tokens": ["private", "\u0120void", "\u0120reset", "()", "\u0120{", "\u0120if", "\u0120(", "ch", "unk", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120chunk", "ed", "Input", "\u0120=", "\u0120new", "\u0120H", "ttp", "Ch", "unk", "ed", "Input", "(", "new", "\u0120Repe", "ated", "Bytes", "Input", "());", "\u0120request", "\u0120=", "\u0120new", "\u0120Default", "Http", "Request", "(", "Http", "Version", ".", "HTTP", "_", "1", "_", "1", ",", "\u0120H", "ttp", "Method", ".", "POST", ",", "\u0120path", ");", "\u0120H", "ttp", "Ut", "il", ".", "set", "Content", "Length", "(", "request", ",", "\u0120total", "Size", ");", "\u0120request", ".", "headers", "().", "add", "(", "Rest", "Ut", "ils", ".", "Head", "ers", ".", "BL", "OB", "_", "SIZE", ",", "\u0120total", "Size", ");", "\u0120request", ".", "headers", "().", "add", "(", "Rest", "Ut", "ils", ".", "Head", "ers", ".", "SER", "VICE", "_", "ID", ",", "\u0120service", "Id", ");", "\u0120request", ".", "headers", "().", "add", "(", "Rest", "Ut", "ils", ".", "Head", "ers", ".", "AM", "BR", "Y", "_", "CONT", "ENT", "_", "TYPE", ",", "\u0120\"", "application", "/", "oct", "et", "-", "stream", "\");", "\u0120if", "\u0120(", "target", "Account", "Name", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120request", ".", "headers", "().", "add", "(", "Rest", "Ut", "ils", ".", "Head", "ers", ".", "T", "ARGET", "_", "ACC", "OUNT", "_", "NAME", ",", "\u0120target", "Account", "Name", ");", "\u0120}", "\u0120if", "\u0120(", "target", "Container", "Name", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120request", ".", "headers", "().", "add", "(", "Rest", "Ut", "ils", ".", "Head", "ers", ".", "T", "ARGET", "_", "CON", "TAIN", "ER", "_", "NAME", ",", "\u0120target", "Container", "Name", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "path", "List", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120request", "\u0120=", "\u0120new", "\u0120Default", "Full", "Http", "Request", "(", "Http", "Version", ".", "HTTP", "_", "1", "_", "1", ",", "\u0120H", "ttp", "Method", ".", "GET", ",", "\u0120path", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120request", "\u0120=", "\u0120new", "\u0120Default", "Full", "Http", "Request", "(", "Http", "Version", ".", "HTTP", "_", "1", "_", "1", ",", "\u0120H", "ttp", "Method", ".", "GET", ",", "\u0120path", "List", ".", "get", "(", "counter", ".", "get", "And", "Incre", "ment", "()", "\u0120%", "\u0120path", "List", ".", "size", "()", "));", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "P", "air", "<", "String", ",", "\u0120String", ">", "\u0120header", "Name", "Value", "\u0120:", "\u0120custom", "Head", "ers", ")", "\u0120{", "\u0120request", ".", "headers", "().", "add", "(", "header", "Name", "Value", ".", "get", "First", "(),", "\u0120header", "Name", "Value", ".", "get", "Second", "());", "\u0120}", "\u0120chunks", "Re", "ceived", "\u0120=", "\u01200", ";", "\u0120size", "Re", "ceived", "\u0120=", "\u01200", ";", "\u0120last", "Ch", "unk", "Re", "ceive", "Time", "\u0120=", "\u01200", ";", "\u0120request", "Start", "Time", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120response", "\u0120=", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Do", "\u0120you", "\u0120think", "\u0120it", "'s", "\u0120worthwhile", "\u0120to", "\u0120check", "\u0120!", "target", "Account", "Name", ".", "is", "Empty", "()", "\u0120as", "\u0120well", "?", "\u0120Same", "\u0120for", "\u0120container", "'s", "\u0120check", "."]}
{"function": "private void load() { List<OnmsNode> nodes = nodeDao.findAll(); this.sparseGraph = new DirectedSparseGraph(); int counter = 0; for (OnmsNode node : nodes) { CustomVertex vertexChild = new CustomVertex(NAMESPACE, node); if (node.getParent() == null) { this.sparseGraph.addVertex(vertexChild); } else { CustomVertex vertexParent = new CustomVertex(NAMESPACE, node.getParent()); vertexChild.setParent(vertexParent); this.sparseGraph.addVertex(vertexChild); this.sparseGraph.addVertex(vertexParent); this.sparseGraph.addEdge(new AbstractEdge(NAMESPACE, String.valueOf(counter), vertexParent, vertexChild), vertexParent, vertexChild, EdgeType.DIRECTED); counter++; } } List<CustomVertex> tempVertices = new ArrayList<>(); for (CustomVertex vertex : this.sparseGraph.getVertices()) { Collection<CustomVertex> predecessors = this.sparseGraph.getPredecessors(vertex); if (predecessors.isEmpty()) { vertex.setLevel(0); tempVertices.add(vertex); tempVertices.addAll(setLevel(this.sparseGraph, vertex, 1)); } } for (CustomVertex customVertex : tempVertices) { this.addVertices(customVertex); } for (AbstractEdge abstractEdge : this.sparseGraph.getEdges()) { this.addEdges(abstractEdge); } }", "text": "Please rename to edgeId.", "function_tokens": ["private", "\u0120void", "\u0120load", "()", "\u0120{", "\u0120List", "<", "On", "ms", "Node", ">", "\u0120nodes", "\u0120=", "\u0120node", "D", "ao", ".", "find", "All", "();", "\u0120this", ".", "s", "parse", "Graph", "\u0120=", "\u0120new", "\u0120Direct", "ed", "S", "parse", "Graph", "();", "\u0120int", "\u0120counter", "\u0120=", "\u01200", ";", "\u0120for", "\u0120(", "On", "ms", "Node", "\u0120node", "\u0120:", "\u0120nodes", ")", "\u0120{", "\u0120Custom", "Ver", "tex", "\u0120vertex", "Child", "\u0120=", "\u0120new", "\u0120Custom", "Ver", "tex", "(", "N", "AMES", "P", "ACE", ",", "\u0120node", ");", "\u0120if", "\u0120(", "node", ".", "get", "Parent", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120this", ".", "s", "parse", "Graph", ".", "add", "Ver", "tex", "(", "ver", "tex", "Child", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Custom", "Ver", "tex", "\u0120vertex", "Parent", "\u0120=", "\u0120new", "\u0120Custom", "Ver", "tex", "(", "N", "AMES", "P", "ACE", ",", "\u0120node", ".", "get", "Parent", "());", "\u0120vertex", "Child", ".", "set", "Parent", "(", "ver", "tex", "Parent", ");", "\u0120this", ".", "s", "parse", "Graph", ".", "add", "Ver", "tex", "(", "ver", "tex", "Child", ");", "\u0120this", ".", "s", "parse", "Graph", ".", "add", "Ver", "tex", "(", "ver", "tex", "Parent", ");", "\u0120this", ".", "s", "parse", "Graph", ".", "add", "Edge", "(", "new", "\u0120Abstract", "Edge", "(", "N", "AMES", "P", "ACE", ",", "\u0120String", ".", "value", "Of", "(", "counter", "),", "\u0120vertex", "Parent", ",", "\u0120vertex", "Child", "),", "\u0120vertex", "Parent", ",", "\u0120vertex", "Child", ",", "\u0120Edge", "Type", ".", "DI", "RECT", "ED", ");", "\u0120counter", "++;", "\u0120}", "\u0120}", "\u0120List", "<", "Custom", "Ver", "tex", ">", "\u0120temp", "Vert", "ices", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "\u0120(", "Custom", "Ver", "tex", "\u0120vertex", "\u0120:", "\u0120this", ".", "s", "parse", "Graph", ".", "get", "Vert", "ices", "())", "\u0120{", "\u0120Collection", "<", "Custom", "Ver", "tex", ">", "\u0120predecessors", "\u0120=", "\u0120this", ".", "s", "parse", "Graph", ".", "get", "Pred", "ec", "essors", "(", "ver", "tex", ");", "\u0120if", "\u0120(", "pred", "ec", "essors", ".", "is", "Empty", "())", "\u0120{", "\u0120vertex", ".", "set", "Level", "(", "0", ");", "\u0120temp", "Vert", "ices", ".", "add", "(", "ver", "tex", ");", "\u0120temp", "Vert", "ices", ".", "add", "All", "(", "set", "Level", "(", "this", ".", "s", "parse", "Graph", ",", "\u0120vertex", ",", "\u01201", "));", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "Custom", "Ver", "tex", "\u0120custom", "Ver", "tex", "\u0120:", "\u0120temp", "Vert", "ices", ")", "\u0120{", "\u0120this", ".", "add", "Vert", "ices", "(", "custom", "Ver", "tex", ");", "\u0120}", "\u0120for", "\u0120(", "Abstract", "Edge", "\u0120abstract", "Edge", "\u0120:", "\u0120this", ".", "s", "parse", "Graph", ".", "get", "Ed", "ges", "())", "\u0120{", "\u0120this", ".", "add", "Ed", "ges", "(", "ab", "stract", "Edge", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120rename", "\u0120to", "\u0120edge", "Id", "."]}
{"function": "public ResponseDefinition execute(Admin admin, Request request, PathParams pathParams) { BrowserProxySettings browserProxySettings = admin.getOptions().browserProxySettings(); KeyStoreSettings caKeyStore = browserProxySettings.caKeyStore(); try { X509KeyStore x509KeyStore = new X509KeyStore(caKeyStore.loadStore(), caKeyStore.password().toCharArray()); X509Certificate certificate = x509KeyStore.getCertificateAuthority().certificateChain()[0]; return new ResponseDefinitionBuilder() .withStatus(HTTP_OK) .withHeader(\"Content-Type\", \"application/x-pem-file\") .withBody( \"-----BEGIN CERTIFICATE-----\\r\\n\" + BASE64_ENCODER.encodeToString(certificate.getEncoded()) + \"\\r\\n\" + \"-----END CERTIFICATE-----\" ) .build(); } catch (Exception e) { StringWriter stacktrace = new StringWriter(); e.printStackTrace(new PrintWriter(stacktrace)); return new ResponseDefinition( HTTP_INTERNAL_ERROR, \"Failed to export certificate authority cert from \" + caKeyStore.path() + \"\\r\\n\" + stacktrace ); } }", "text": "Could we just log the stacktrace, rather than sending it on the response?", "function_tokens": ["public", "\u0120Response", "Definition", "\u0120execute", "(", "Admin", "\u0120admin", ",", "\u0120Request", "\u0120request", ",", "\u0120Path", "Par", "ams", "\u0120path", "Par", "ams", ")", "\u0120{", "\u0120Browser", "Proxy", "Settings", "\u0120browser", "Proxy", "Settings", "\u0120=", "\u0120admin", ".", "get", "Options", "().", "browser", "Proxy", "Settings", "();", "\u0120Key", "Store", "Settings", "\u0120ca", "Key", "Store", "\u0120=", "\u0120browser", "Proxy", "Settings", ".", "ca", "Key", "Store", "();", "\u0120try", "\u0120{", "\u0120X", "509", "Key", "Store", "\u0120x", "509", "Key", "Store", "\u0120=", "\u0120new", "\u0120X", "509", "Key", "Store", "(", "ca", "Key", "Store", ".", "load", "Store", "(),", "\u0120ca", "Key", "Store", ".", "password", "().", "to", "Char", "Array", "());", "\u0120X", "509", "Cert", "ificate", "\u0120certificate", "\u0120=", "\u0120x", "509", "Key", "Store", ".", "get", "Cert", "ificate", "Author", "ity", "().", "cert", "ificate", "Chain", "()", "[", "0", "];", "\u0120return", "\u0120new", "\u0120Response", "Definition", "Builder", "()", "\u0120.", "with", "Status", "(", "HTTP", "_", "OK", ")", "\u0120.", "with", "Header", "(\"", "Content", "-", "Type", "\",", "\u0120\"", "application", "/", "x", "-", "p", "em", "-", "file", "\")", "\u0120.", "with", "Body", "(", "\u0120\"", "-----", "B", "EGIN", "\u0120C", "ERT", "IFIC", "ATE", "-----", "\\", "r", "\\", "n", "\"", "\u0120+", "\u0120BASE", "64", "_", "ENC", "OD", "ER", ".", "en", "code", "To", "String", "(", "cert", "ificate", ".", "get", "Enc", "oded", "())", "\u0120+", "\u0120\"\\", "r", "\\", "n", "\"", "\u0120+", "\u0120\"", "-----", "END", "\u0120C", "ERT", "IFIC", "ATE", "----", "-\"", "\u0120)", "\u0120.", "build", "();", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120String", "Writer", "\u0120stack", "trace", "\u0120=", "\u0120new", "\u0120String", "Writer", "();", "\u0120e", ".", "print", "Stack", "Tr", "ace", "(", "new", "\u0120Print", "Writer", "(", "stack", "trace", "));", "\u0120return", "\u0120new", "\u0120Response", "Definition", "(", "\u0120HTTP", "_", "IN", "TERN", "AL", "_", "ERROR", ",", "\u0120\"", "F", "ailed", "\u0120to", "\u0120export", "\u0120certificate", "\u0120authority", "\u0120cert", "\u0120from", "\u0120\"", "\u0120+", "\u0120ca", "Key", "Store", ".", "path", "()", "\u0120+", "\u0120\"\\", "r", "\\", "n", "\"", "\u0120+", "\u0120stack", "trace", "\u0120);", "\u0120}", "\u0120}"], "docstring_tokens": ["Could", "\u0120we", "\u0120just", "\u0120log", "\u0120the", "\u0120stack", "trace", ",", "\u0120rather", "\u0120than", "\u0120sending", "\u0120it", "\u0120on", "\u0120the", "\u0120response", "?"]}
{"function": "public Function<Element, LeaseElement> parser() { return (element -> { NodeList childElements = element.getElementsByTagNameNS(NAMESPACE_STRING, LEASE_LENGTH_ELEMENT_NAME); if (childElements.getLength() != 1) { LOGGER.error(\"Found \" + childElements.getLength() + \" lease-length elements. The XSD should have prevented this.\"); throw new AssertionError(\"The schema for connection-leasing element requires one and only one lease-length element\"); } Element leaseLengthElement = (Element)childElements.item(0); String leaseLengthString = leaseLengthElement.getTextContent(); LOGGER.info(\"Found lease length XML text: \" + leaseLengthString); String timeUnitString = leaseLengthElement.getAttribute(TIME_UNIT_ATTRIBUTE_NAME); LOGGER.info(\"Found lease length time unit: \" + timeUnitString); LeaseElement leaseElement = new LeaseElement(); leaseElement.setLeaseValue(leaseLengthString); leaseElement.setTimeUnit(timeUnitString); return leaseElement; }); }", "text": "can't we set these values in the constructor?", "function_tokens": ["public", "\u0120Function", "<", "Element", ",", "\u0120Le", "ase", "Element", ">", "\u0120parser", "()", "\u0120{", "\u0120return", "\u0120(", "element", "\u0120->", "\u0120{", "\u0120Node", "List", "\u0120child", "E", "lements", "\u0120=", "\u0120element", ".", "get", "E", "lements", "By", "Tag", "Name", "NS", "(", "N", "AMES", "P", "ACE", "_", "STR", "ING", ",", "\u0120LE", "ASE", "_", "L", "ENGTH", "_", "E", "LE", "MENT", "_", "NAME", ");", "\u0120if", "\u0120(", "child", "E", "lements", ".", "get", "Length", "()", "\u0120!=", "\u01201", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(\"", "Found", "\u0120\"", "\u0120+", "\u0120child", "E", "lements", ".", "get", "Length", "()", "\u0120+", "\u0120\"", "\u0120lease", "-", "length", "\u0120elements", ".", "\u0120The", "\u0120X", "SD", "\u0120should", "\u0120have", "\u0120prevented", "\u0120this", ".\"", ");", "\u0120throw", "\u0120new", "\u0120Ass", "ert", "ion", "Error", "(\"", "The", "\u0120schema", "\u0120for", "\u0120connection", "-", "leasing", "\u0120element", "\u0120requires", "\u0120one", "\u0120and", "\u0120only", "\u0120one", "\u0120lease", "-", "length", "\u0120element", "\");", "\u0120}", "\u0120Element", "\u0120lease", "Length", "Element", "\u0120=", "\u0120(", "Element", ")", "child", "E", "lements", ".", "item", "(", "0", ");", "\u0120String", "\u0120lease", "Length", "String", "\u0120=", "\u0120lease", "Length", "Element", ".", "get", "Text", "Content", "();", "\u0120LOG", "GER", ".", "info", "(\"", "Found", "\u0120lease", "\u0120length", "\u0120XML", "\u0120text", ":", "\u0120\"", "\u0120+", "\u0120lease", "Length", "String", ");", "\u0120String", "\u0120time", "Unit", "String", "\u0120=", "\u0120lease", "Length", "Element", ".", "get", "Attribute", "(", "TIME", "_", "UN", "IT", "_", "AT", "TR", "IB", "UTE", "_", "NAME", ");", "\u0120LOG", "GER", ".", "info", "(\"", "Found", "\u0120lease", "\u0120length", "\u0120time", "\u0120unit", ":", "\u0120\"", "\u0120+", "\u0120time", "Unit", "String", ");", "\u0120Le", "ase", "Element", "\u0120lease", "Element", "\u0120=", "\u0120new", "\u0120Le", "ase", "Element", "();", "\u0120lease", "Element", ".", "set", "Le", "ase", "Value", "(", "lease", "Length", "String", ");", "\u0120lease", "Element", ".", "set", "Time", "Unit", "(", "time", "Unit", "String", ");", "\u0120return", "\u0120lease", "Element", ";", "\u0120});", "\u0120}"], "docstring_tokens": ["can", "'t", "\u0120we", "\u0120set", "\u0120these", "\u0120values", "\u0120in", "\u0120the", "\u0120constructor", "?"]}
{"function": "XAResourceRegistryFile(Xid xid) throws SystemException { final String xidString = SimpleXid.of(xid).toHexString('_'); this.filePath = xaRecoveryPath.resolve(xidString); try { fileChannel = doPrivileged((PrivilegedExceptionAction<FileChannel>) () -> { final SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new FilePermission(xaRecoveryPath.toString() + File.separatorChar + '*', \"read,write\")); } xaRecoveryPath.toFile().mkdir(); return FileChannel.open(filePath, StandardOpenOption.APPEND, StandardOpenOption.CREATE_NEW); }); openFilePaths.add(xidString); fileChannel.lock(); Log.log.xaResourceRecoveryFileCreated(filePath); } catch (PrivilegedActionException e) { throw Log.log.createXAResourceRecoveryFileFailed(filePath, (IOException)e.getCause()); } catch (IOException e) { throw Log.log.createXAResourceRecoveryFileFailed(filePath, e); } }", "text": "@tadamski If you cache this FilePermission in the containing FileSystemXAResourceRecoveryRegistry object you will save a per-transaction objection creation/gc.", "function_tokens": ["X", "AR", "es", "ource", "Reg", "istry", "File", "(", "X", "id", "\u0120x", "id", ")", "\u0120throws", "\u0120System", "Exception", "\u0120{", "\u0120final", "\u0120String", "\u0120x", "id", "String", "\u0120=", "\u0120Simple", "X", "id", ".", "of", "(", "x", "id", ").", "to", "H", "ex", "String", "('", "_", "');", "\u0120this", ".", "file", "Path", "\u0120=", "\u0120x", "a", "Rec", "overy", "Path", ".", "res", "olve", "(", "x", "id", "String", ");", "\u0120try", "\u0120{", "\u0120file", "Channel", "\u0120=", "\u0120do", "Priv", "ileged", "((", "Priv", "ileged", "Exception", "Action", "<", "File", "Channel", ">)", "\u0120()", "\u0120->", "\u0120{", "\u0120final", "\u0120Security", "Manager", "\u0120sm", "\u0120=", "\u0120System", ".", "get", "Security", "Manager", "();", "\u0120if", "\u0120(", "sm", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120sm", ".", "check", "Per", "mission", "(", "new", "\u0120File", "Per", "mission", "(", "xa", "Rec", "overy", "Path", ".", "to", "String", "()", "\u0120+", "\u0120File", ".", "separ", "ator", "Char", "\u0120+", "\u0120'", "*", "',", "\u0120\"", "read", ",", "write", "\")", ");", "\u0120}", "\u0120x", "a", "Rec", "overy", "Path", ".", "to", "File", "().", "mk", "dir", "();", "\u0120return", "\u0120File", "Channel", ".", "open", "(", "file", "Path", ",", "\u0120Standard", "Open", "Option", ".", "APP", "END", ",", "\u0120Standard", "Open", "Option", ".", "CRE", "ATE", "_", "NEW", ");", "\u0120});", "\u0120open", "File", "Path", "s", ".", "add", "(", "x", "id", "String", ");", "\u0120file", "Channel", ".", "lock", "();", "\u0120Log", ".", "log", ".", "xa", "Resource", "Rec", "overy", "File", "Created", "(", "file", "Path", ");", "\u0120}", "\u0120catch", "\u0120(", "Priv", "ileged", "Action", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120Log", ".", "log", ".", "create", "X", "AR", "es", "ource", "Rec", "overy", "File", "F", "ailed", "(", "file", "Path", ",", "\u0120(", "IO", "Exception", ")", "e", ".", "get", "Cause", "());", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120Log", ".", "log", ".", "create", "X", "AR", "es", "ource", "Rec", "overy", "File", "F", "ailed", "(", "file", "Path", ",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "t", "ad", "ams", "ki", "\u0120If", "\u0120you", "\u0120cache", "\u0120this", "\u0120File", "Per", "mission", "\u0120in", "\u0120the", "\u0120containing", "\u0120File", "System", "X", "AR", "es", "ource", "Rec", "overy", "Reg", "istry", "\u0120object", "\u0120you", "\u0120will", "\u0120save", "\u0120a", "\u0120per", "-", "trans", "action", "\u0120objection", "\u0120creation", "/", "gc", "."]}
{"function": "public void fromRunnable() { Completable.fromRunnable(new Runnable() { @Override public void run() { } }) .test() .assertResult(); }", "text": "I'd increment a counter and assert its 1.", "function_tokens": ["public", "\u0120void", "\u0120from", "Run", "n", "able", "()", "\u0120{", "\u0120Com", "ple", "table", ".", "from", "Run", "n", "able", "(", "new", "\u0120Run", "n", "able", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120}", "\u0120})", "\u0120.", "test", "()", "\u0120.", "assert", "Result", "();", "\u0120}"], "docstring_tokens": ["I", "'d", "\u0120increment", "\u0120a", "\u0120counter", "\u0120and", "\u0120assert", "\u0120its", "\u01201", "."]}
{"function": "public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { HttpRequest request = (HttpRequest) e.getMessage(); ChannelBuffer content = request.getContent(); if (content.readable()) { sendMessage(MessageBuilder.withPayload(content.toString(Charset.forName(\"UTF-8\"))).build()); } writeResponse(request, e.getChannel()); }", "text": "I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??", "function_tokens": ["public", "\u0120void", "\u0120message", "Re", "ceived", "(", "Channel", "Handler", "Context", "\u0120c", "tx", ",", "\u0120Message", "Event", "\u0120e", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120H", "ttp", "Request", "\u0120request", "\u0120=", "\u0120(", "Http", "Request", ")", "\u0120e", ".", "get", "Message", "();", "\u0120Channel", "Buffer", "\u0120content", "\u0120=", "\u0120request", ".", "get", "Content", "();", "\u0120if", "\u0120(", "content", ".", "readable", "())", "\u0120{", "\u0120send", "Message", "(", "Message", "Builder", ".", "with", "Pay", "load", "(", "content", ".", "to", "String", "(", "Ch", "ars", "et", ".", "for", "Name", "(\"", "UTF", "-", "8", "\"))", ").", "build", "());", "\u0120}", "\u0120write", "Response", "(", "request", ",", "\u0120e", ".", "get", "Channel", "());", "\u0120}"], "docstring_tokens": ["I", "\u0120realize", "\u0120it", "'s", "\u0120a", "\u0120first", "\u0120cut", ",", "\u0120but", "\u0120I", "\u0120wonder", "\u0120if", "\u0120we", "\u0120should", "\u0120map", "\u0120some", "\u0120basic", "\u0120headers", "\u0120(", "method", ",", "\u0120path", "\u0120(", "uri", "),", "\u0120Accept", ")", "\u0120??"]}
{"function": "public BaseResourceReferenceDt setResource(IBaseResource theResource) { myResource = theResource; return null; }", "text": "null?", "function_tokens": ["public", "\u0120Base", "Resource", "Reference", "D", "t", "\u0120set", "Resource", "(", "IB", "ase", "Resource", "\u0120the", "Resource", ")", "\u0120{", "\u0120my", "Resource", "\u0120=", "\u0120the", "Resource", ";", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["null", "?"]}
{"function": "@Override public Frame fetch(StatementHandle h, long offset, int fetchMaxRowCount) throws NoSuchStatementException { final CalciteConnectionImpl calciteConnection = getConnection(); CalciteServerStatement stmt = calciteConnection.server.getStatement(h); final Signature signature = stmt.getSignature(); final Iterator<Object> iterator; if (stmt.getResultSet() == null) { final Iterable<Object> iterable = _createIterable(h, signature, null, null); iterator = iterable.iterator(); stmt.setResultSet(iterator); } else { iterator = stmt.getResultSet(); } final List rows = MetaImpl.collect(signature.cursorFactory, LimitIterator.of(iterator, fetchMaxRowCount), new ArrayList<List<Object>>()); boolean done = fetchMaxRowCount == 0 || rows.size() < fetchMaxRowCount; @SuppressWarnings(\"unchecked\") List<Object> rows1 = (List<Object>) rows; stmt.setResultSet(null); return new Meta.Frame(offset, done, rows1); }", "text": "This is too aggressive :( The iterator is not released after a call ended because it might not be fully read. If I'm not wrong, setting it to null would cause infinite loop when result row count is large enough.", "function_tokens": ["@", "Override", "\u0120public", "\u0120Frame", "\u0120fetch", "(", "Statement", "Handle", "\u0120h", ",", "\u0120long", "\u0120offset", ",", "\u0120int", "\u0120fetch", "Max", "Row", "Count", ")", "\u0120throws", "\u0120No", "Such", "Statement", "Exception", "\u0120{", "\u0120final", "\u0120Cal", "c", "ite", "Connection", "Impl", "\u0120calc", "ite", "Connection", "\u0120=", "\u0120get", "Connection", "();", "\u0120Cal", "c", "ite", "Server", "Statement", "\u0120st", "mt", "\u0120=", "\u0120calc", "ite", "Connection", ".", "server", ".", "get", "Statement", "(", "h", ");", "\u0120final", "\u0120Signature", "\u0120signature", "\u0120=", "\u0120st", "mt", ".", "get", "Sign", "ature", "();", "\u0120final", "\u0120Iter", "ator", "<", "Object", ">", "\u0120iterator", ";", "\u0120if", "\u0120(", "st", "mt", ".", "get", "Result", "Set", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120final", "\u0120Iter", "able", "<", "Object", ">", "\u0120iter", "able", "\u0120=", "\u0120_", "create", "Iter", "able", "(", "h", ",", "\u0120signature", ",", "\u0120null", ",", "\u0120null", ");", "\u0120iterator", "\u0120=", "\u0120iter", "able", ".", "iterator", "();", "\u0120st", "mt", ".", "set", "Result", "Set", "(", "iterator", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120iterator", "\u0120=", "\u0120st", "mt", ".", "get", "Result", "Set", "();", "\u0120}", "\u0120final", "\u0120List", "\u0120rows", "\u0120=", "\u0120Meta", "Impl", ".", "collect", "(", "sign", "ature", ".", "c", "ursor", "Factory", ",", "\u0120Limit", "Iterator", ".", "of", "(", "iterator", ",", "\u0120fetch", "Max", "Row", "Count", "),", "\u0120new", "\u0120Array", "List", "<", "List", "<", "Object", ">>", "());", "\u0120boolean", "\u0120done", "\u0120=", "\u0120fetch", "Max", "Row", "Count", "\u0120==", "\u01200", "\u0120||", "\u0120rows", ".", "size", "()", "\u0120<", "\u0120fetch", "Max", "Row", "Count", ";", "\u0120@", "Supp", "ress", "W", "arn", "ings", "(\"", "un", "checked", "\")", "\u0120List", "<", "Object", ">", "\u0120rows", "1", "\u0120=", "\u0120(", "List", "<", "Object", ">)", "\u0120rows", ";", "\u0120st", "mt", ".", "set", "Result", "Set", "(", "null", ");", "\u0120return", "\u0120new", "\u0120Meta", ".", "Frame", "(", "offset", ",", "\u0120done", ",", "\u0120rows", "1", ");", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120too", "\u0120aggressive", "\u0120:(", "\u0120The", "\u0120iterator", "\u0120is", "\u0120not", "\u0120released", "\u0120after", "\u0120a", "\u0120call", "\u0120ended", "\u0120because", "\u0120it", "\u0120might", "\u0120not", "\u0120be", "\u0120fully", "\u0120read", ".", "\u0120If", "\u0120I", "'m", "\u0120not", "\u0120wrong", ",", "\u0120setting", "\u0120it", "\u0120to", "\u0120null", "\u0120would", "\u0120cause", "\u0120infinite", "\u0120loop", "\u0120when", "\u0120result", "\u0120row", "\u0120count", "\u0120is", "\u0120large", "\u0120enough", "."]}
{"function": "public String getDeviceName() { String manufacturer = Build.MANUFACTURER; String model = Build.MODEL; String deviceName; if (model.startsWith(manufacturer)) { deviceName = StringUtils.capitalize(model); } else { deviceName = StringUtils.capitalize(manufacturer) + \" \" + model; } return deviceName == null ? \"Unknown Device\" : deviceName; }", "text": "final", "function_tokens": ["public", "\u0120String", "\u0120get", "Device", "Name", "()", "\u0120{", "\u0120String", "\u0120manufacturer", "\u0120=", "\u0120Build", ".", "MAN", "UF", "ACT", "UR", "ER", ";", "\u0120String", "\u0120model", "\u0120=", "\u0120Build", ".", "MOD", "EL", ";", "\u0120String", "\u0120device", "Name", ";", "\u0120if", "\u0120(", "model", ".", "st", "arts", "With", "(", "manufact", "urer", "))", "\u0120{", "\u0120device", "Name", "\u0120=", "\u0120String", "Ut", "ils", ".", "capital", "ize", "(", "model", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120device", "Name", "\u0120=", "\u0120String", "Ut", "ils", ".", "capital", "ize", "(", "manufact", "urer", ")", "\u0120+", "\u0120\"", "\u0120\"", "\u0120+", "\u0120model", ";", "\u0120}", "\u0120return", "\u0120device", "Name", "\u0120==", "\u0120null", "\u0120?", "\u0120\"", "Unknown", "\u0120Device", "\"", "\u0120:", "\u0120device", "Name", ";", "\u0120}"], "docstring_tokens": ["final"]}
{"function": "public BsmAdminPageEditWindow editAttribute(String key, String value) throws InterruptedException { getSelectWebElement(\"attributeList\").selectByVisibleText(key); editAttributeWindow() .value(value) .confirm(); wait.until(ExpectedConditions.elementToBeClickable(By.id(\"addAttributeButton\"))); return this; }", "text": "This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?", "function_tokens": ["public", "\u0120B", "sm", "Admin", "Page", "Edit", "Window", "\u0120edit", "Attribute", "(", "String", "\u0120key", ",", "\u0120String", "\u0120value", ")", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120get", "Select", "Web", "Element", "(\"", "attribute", "List", "\").", "select", "By", "V", "isible", "Text", "(", "key", ");", "\u0120edit", "Attribute", "Window", "()", "\u0120.", "value", "(", "value", ")", "\u0120.", "conf", "irm", "();", "\u0120wait", ".", "until", "(", "Ex", "pected", "Cond", "itions", ".", "element", "To", "Be", "Click", "able", "(", "By", ".", "id", "(\"", "add", "Attribute", "Button", "\"))", ");", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120kinda", "\u0120a", "\u0120duplicate", ",", "\u0120as", "\u0120we", "\u0120already", "\u0120wait", "\u0120in", "\u0120the", "\u0120confirm", "()", "\u0120method", "\u0120or", "\u0120is", "\u0120there", "\u0120a", "\u0120particular", "\u0120reason", "\u0120to", "\u0120wait", "\u0120again", "\u0120for", "\u0120another", "\u0120element", "?"]}
{"function": "@Test @Config(reportSdk=9) public void useOkHttpByDefault() throws Exception { Downloader downloader = Utils.createDefaultDownloader(Robolectric.application); assertThat(downloader instanceof OkHttpDownloader).isTrue(); }", "text": "Maybe change this to assertThat(downloader).isInstanceOf(OkHttpDownloader.class) ?", "function_tokens": ["@", "Test", "\u0120@", "Config", "(", "report", "S", "dk", "=", "9", ")", "\u0120public", "\u0120void", "\u0120use", "Ok", "Http", "By", "Default", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Download", "er", "\u0120download", "er", "\u0120=", "\u0120Ut", "ils", ".", "create", "Default", "Download", "er", "(", "Rob", "o", "lect", "ric", ".", "application", ");", "\u0120assert", "That", "(", "download", "er", "\u0120instance", "of", "\u0120Ok", "Http", "Download", "er", ").", "is", "True", "();", "\u0120}"], "docstring_tokens": ["Maybe", "\u0120change", "\u0120this", "\u0120to", "\u0120assert", "That", "(", "download", "er", ").", "is", "Instance", "Of", "(", "Ok", "Http", "Download", "er", ".", "class", ")", "\u0120?"]}
{"function": "public void load(@NonNull Picasso picasso, @NonNull Request request, @NonNull Callback callback) { initializeIfFirstTime(); boolean signaledCallback = false; try { BufferedSource source = Okio.buffer(Okio.source(assetManager.open(getFilePath(request)))); try { Bitmap bitmap = decodeStream(source, request); signaledCallback = true; callback.onSuccess(new Result(bitmap, DISK)); } finally { try { source.close(); } catch (IOException ignored) { } } } catch (Exception e) { if (!signaledCallback) { callback.onError(e); } } }", "text": "You have a few more of these to update", "function_tokens": ["public", "\u0120void", "\u0120load", "(", "@", "Non", "Null", "\u0120Pic", "asso", "\u0120pic", "asso", ",", "\u0120@", "Non", "Null", "\u0120Request", "\u0120request", ",", "\u0120@", "Non", "Null", "\u0120Call", "back", "\u0120callback", ")", "\u0120{", "\u0120initialize", "If", "First", "Time", "();", "\u0120boolean", "\u0120signaled", "Callback", "\u0120=", "\u0120false", ";", "\u0120try", "\u0120{", "\u0120Buff", "ered", "Source", "\u0120source", "\u0120=", "\u0120Ok", "io", ".", "buffer", "(", "Ok", "io", ".", "source", "(", "ass", "et", "Manager", ".", "open", "(", "get", "File", "Path", "(", "request", "))", "));", "\u0120try", "\u0120{", "\u0120Bit", "map", "\u0120bit", "map", "\u0120=", "\u0120decode", "Stream", "(", "source", ",", "\u0120request", ");", "\u0120signaled", "Callback", "\u0120=", "\u0120true", ";", "\u0120callback", ".", "on", "Success", "(", "new", "\u0120Result", "(", "bit", "map", ",", "\u0120DIS", "K", "));", "\u0120}", "\u0120finally", "\u0120{", "\u0120try", "\u0120{", "\u0120source", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120ignored", ")", "\u0120{", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(!", "sign", "aled", "Callback", ")", "\u0120{", "\u0120callback", ".", "on", "Error", "(", "e", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["You", "\u0120have", "\u0120a", "\u0120few", "\u0120more", "\u0120of", "\u0120these", "\u0120to", "\u0120update"]}
{"function": "public void onLiveInstanceChange(List<LiveInstance> liveInstances, NotificationContext changeContext) { try { logger.trace(\"Live instance change triggered from {} with: {}\", dcName, liveInstances); updateInstanceLiveness(liveInstances); if (!liveStateInitialized.get()) { logger.info(\"Received initial notification for live instance change from {}\", dcName); liveStateInitialized.set(true); } helixClusterManagerMetrics.liveInstanceChangeTriggerCount.inc(); } catch (Throwable t) { errorCount.incrementAndGet(); throw t; } }", "text": "trace seems too low, how often will this happen?", "function_tokens": ["public", "\u0120void", "\u0120on", "Live", "Instance", "Change", "(", "List", "<", "Live", "Instance", ">", "\u0120live", "Inst", "ances", ",", "\u0120Notification", "Context", "\u0120change", "Context", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120logger", ".", "trace", "(\"", "Live", "\u0120instance", "\u0120change", "\u0120triggered", "\u0120from", "\u0120{}", "\u0120with", ":", "\u0120{}", "\",", "\u0120dc", "Name", ",", "\u0120live", "Inst", "ances", ");", "\u0120update", "Instance", "L", "iveness", "(", "live", "Inst", "ances", ");", "\u0120if", "\u0120(!", "live", "State", "Initialized", ".", "get", "())", "\u0120{", "\u0120logger", ".", "info", "(\"", "Re", "ceived", "\u0120initial", "\u0120notification", "\u0120for", "\u0120live", "\u0120instance", "\u0120change", "\u0120from", "\u0120{}", "\",", "\u0120dc", "Name", ");", "\u0120live", "State", "Initialized", ".", "set", "(", "true", ");", "\u0120}", "\u0120hel", "ix", "Cl", "uster", "Manager", "Met", "rics", ".", "live", "Instance", "Change", "Trigger", "Count", ".", "inc", "();", "\u0120}", "\u0120catch", "\u0120(", "Throw", "able", "\u0120t", ")", "\u0120{", "\u0120error", "Count", ".", "incre", "ment", "And", "Get", "();", "\u0120throw", "\u0120t", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["trace", "\u0120seems", "\u0120too", "\u0120low", ",", "\u0120how", "\u0120often", "\u0120will", "\u0120this", "\u0120happen", "?"]}
{"function": "public EncryptionServiceImpl() { String passwordDirectory = System.getProperty(\"ddf.etc\").concat(\"/certs\"); String keysetLocation = Paths.get(passwordDirectory, KEYSET_FILE_NAME).toString(); synchronized (EncryptionServiceImpl.class) { File keysetFile = new File(keysetLocation); InputStream keysetFileInputStream = null; OutputStream keysetFileOutputStream = null; try { AeadConfig.register(); if (!keysetFile.exists()) { keysetHandle = KeysetHandle.generateNew(AeadKeyTemplates.AES128_GCM); keysetFileOutputStream = Files.newOutputStream(Paths.get(keysetLocation)); CleartextKeysetHandle.write( keysetHandle, JsonKeysetWriter.withOutputStream(keysetFileOutputStream)); } else { keysetFileInputStream = Files.newInputStream(Paths.get(keysetLocation)); keysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withInputStream(keysetFileInputStream)); } aead = AeadFactory.getPrimitive(keysetHandle); } catch (GeneralSecurityException | IOException e) { LOGGER.warn(\"Problem initializing Tink. Enable debug logging for more information.\"); LOGGER.debug(\"\", e); } finally { try { keysetFileInputStream.close(); } catch (IOException | NullPointerException ignore) { } try { keysetFileOutputStream.close(); } catch (IOException | NullPointerException ignore) { } } } }", "text": "Do a null check instead of catching the NPE. Can a try with resources be used?", "function_tokens": ["public", "\u0120Enc", "ryption", "Service", "Impl", "()", "\u0120{", "\u0120String", "\u0120password", "Directory", "\u0120=", "\u0120System", ".", "get", "Property", "(\"", "dd", "f", ".", "etc", "\").", "con", "cat", "(\"", "/", "cert", "s", "\");", "\u0120String", "\u0120keys", "et", "Location", "\u0120=", "\u0120Path", "s", ".", "get", "(", "password", "Directory", ",", "\u0120KE", "YS", "ET", "_", "FILE", "_", "NAME", ").", "to", "String", "();", "\u0120synchronized", "\u0120(", "Enc", "ryption", "Service", "Impl", ".", "class", ")", "\u0120{", "\u0120File", "\u0120keys", "et", "File", "\u0120=", "\u0120new", "\u0120File", "(", "keys", "et", "Location", ");", "\u0120Input", "Stream", "\u0120keys", "et", "File", "Input", "Stream", "\u0120=", "\u0120null", ";", "\u0120Output", "Stream", "\u0120keys", "et", "File", "Output", "Stream", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120A", "ead", "Config", ".", "register", "();", "\u0120if", "\u0120(!", "keys", "et", "File", ".", "ex", "ists", "())", "\u0120{", "\u0120keys", "et", "Handle", "\u0120=", "\u0120Keys", "et", "Handle", ".", "gener", "ate", "New", "(", "A", "ead", "Key", "Tem", "plates", ".", "A", "ES", "128", "_", "GC", "M", ");", "\u0120keys", "et", "File", "Output", "Stream", "\u0120=", "\u0120Files", ".", "new", "Output", "Stream", "(", "Path", "s", ".", "get", "(", "keys", "et", "Location", "));", "\u0120Cle", "art", "ext", "Keys", "et", "Handle", ".", "write", "(", "\u0120keys", "et", "Handle", ",", "\u0120J", "son", "Keys", "et", "Writer", ".", "with", "Output", "Stream", "(", "keys", "et", "File", "Output", "Stream", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120keys", "et", "File", "Input", "Stream", "\u0120=", "\u0120Files", ".", "new", "Input", "Stream", "(", "Path", "s", ".", "get", "(", "keys", "et", "Location", "));", "\u0120keys", "et", "Handle", "\u0120=", "\u0120Cle", "art", "ext", "Keys", "et", "Handle", ".", "read", "(", "J", "son", "Keys", "et", "Reader", ".", "with", "Input", "Stream", "(", "keys", "et", "File", "Input", "Stream", "));", "\u0120}", "\u0120a", "ead", "\u0120=", "\u0120A", "ead", "Factory", ".", "get", "Prim", "itive", "(", "keys", "et", "Handle", ");", "\u0120}", "\u0120catch", "\u0120(", "General", "Security", "Exception", "\u0120|", "\u0120IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "warn", "(\"", "Problem", "\u0120initial", "izing", "\u0120T", "ink", ".", "\u0120Enable", "\u0120debug", "\u0120logging", "\u0120for", "\u0120more", "\u0120information", ".\"", ");", "\u0120LOG", "GER", ".", "debug", "(\"", "\",", "\u0120e", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120try", "\u0120{", "\u0120keys", "et", "File", "Input", "Stream", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120|", "\u0120Null", "Po", "inter", "Exception", "\u0120ignore", ")", "\u0120{", "\u0120}", "\u0120try", "\u0120{", "\u0120keys", "et", "File", "Output", "Stream", ".", "close", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120|", "\u0120Null", "Po", "inter", "Exception", "\u0120ignore", ")", "\u0120{", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Do", "\u0120a", "\u0120null", "\u0120check", "\u0120instead", "\u0120of", "\u0120catching", "\u0120the", "\u0120N", "PE", ".", "\u0120Can", "\u0120a", "\u0120try", "\u0120with", "\u0120resources", "\u0120be", "\u0120used", "?"]}
{"function": "public static String updateOldDescription(String description) { String newDescription = \"\"; newDescription = updatePrisonerDescription(description); if (!newDescription.isEmpty()) { return newDescription; } newDescription = updateBondsmanDescription(description); if (!newDescription.isEmpty()) { return newDescription; } return \"\"; }", "text": "We can also move this up to the declaration and remove the meaningless initialization.", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120update", "Old", "Description", "(", "String", "\u0120description", ")", "\u0120{", "\u0120String", "\u0120new", "Description", "\u0120=", "\u0120\"", "\";", "\u0120new", "Description", "\u0120=", "\u0120update", "Pr", "ison", "er", "Description", "(", "description", ");", "\u0120if", "\u0120(!", "new", "Description", ".", "is", "Empty", "())", "\u0120{", "\u0120return", "\u0120new", "Description", ";", "\u0120}", "\u0120new", "Description", "\u0120=", "\u0120update", "B", "onds", "man", "Description", "(", "description", ");", "\u0120if", "\u0120(!", "new", "Description", ".", "is", "Empty", "())", "\u0120{", "\u0120return", "\u0120new", "Description", ";", "\u0120}", "\u0120return", "\u0120\"", "\";", "\u0120}"], "docstring_tokens": ["We", "\u0120can", "\u0120also", "\u0120move", "\u0120this", "\u0120up", "\u0120to", "\u0120the", "\u0120declaration", "\u0120and", "\u0120remove", "\u0120the", "\u0120meaningless", "\u0120initialization", "."]}
{"function": "public void testCacheBehaviour(){ IgniteUtils.setCurrentIgniteName(ignite.configuration().getIgniteInstanceName()); int size = rows; cacheBehaviorLogic(size); }", "text": "We dont need size variable here.", "function_tokens": ["public", "\u0120void", "\u0120test", "Cache", "Beh", "aviour", "(){", "\u0120Ign", "ite", "Ut", "ils", ".", "set", "Current", "Ign", "ite", "Name", "(", "ign", "ite", ".", "config", "uration", "().", "get", "Ign", "ite", "Instance", "Name", "());", "\u0120int", "\u0120size", "\u0120=", "\u0120rows", ";", "\u0120cache", "Beh", "avior", "Log", "ic", "(", "size", ");", "\u0120}"], "docstring_tokens": ["We", "\u0120dont", "\u0120need", "\u0120size", "\u0120variable", "\u0120here", "."]}
{"function": "private void runOneIteration() { try { LockWatchTestRuntimeConfig config = runtime.get(); if (config.namespaceToWatch().isPresent()) { LockWatchingResource lockWatcher = resource.apply(config.namespaceToWatch().get()); LockWatchRequest request = LockWatchRequest.of(config.tablesToWatch().stream() .map(TableReference::getQualifiedName) .map(LockWatchReferences::entireTable) .collect(Collectors.toSet())); LockWatchStateUpdate versionBefore = lockWatcher.getWatchState( OptionalLong.empty()); long startRegistering = System.currentTimeMillis(); lockWatcher.startWatching(request); log.info(\"Registered lock watches for keyspace {} and tables {} in {} seconds.\", SafeArg.of(\"keyspace\", config.namespaceToWatch().get()), SafeArg.of(\"tables\", config.tablesToWatch()), SafeArg.of(\"seconds\", System.currentTimeMillis() - startRegistering)); long startUpdate = System.currentTimeMillis(); LockWatchStateUpdate versionAfter = lockWatcher.getWatchState(versionBefore.lastKnownVersion()); long duration = System.currentTimeMillis() - startUpdate; if (versionAfter.success()) { Optional<LockWatchEvent> result = versionAfter.events().stream() .map(event -> event.accept(filter)) .filter(Optional::isPresent) .map(Optional::get) .findFirst(); if (!result.isPresent()) { log.info(\"Registered lock watches, but did not find any open locks. Took {} seconds\", SafeArg.of(\"duration\", duration)); } else { log.info(\"Registered lock watches, found {} open locks. Took {} seconds.\", SafeArg.of(\"numberOfWatches\", ((LockWatchOpenLocksEvent) result.get()).lockDescriptors().size()), SafeArg.of(\"duration\", duration)); } } else { log.info(\"Registered lock watches, but was unable to get an update. Last known version is {}\", SafeArg.of(\"lastKnownVersion\", versionAfter.lastKnownVersion())); } } } catch (Throwable th) { log.info(\"Failed to run a test iteration of registering lock watches\", th); } }", "text": "nit: The metric is millis, not seconds", "function_tokens": ["private", "\u0120void", "\u0120run", "One", "Iter", "ation", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120Lock", "Watch", "Test", "Runtime", "Config", "\u0120config", "\u0120=", "\u0120runtime", ".", "get", "();", "\u0120if", "\u0120(", "config", ".", "names", "pace", "To", "Watch", "().", "is", "Present", "())", "\u0120{", "\u0120Lock", "Watch", "ing", "Resource", "\u0120lock", "W", "atcher", "\u0120=", "\u0120resource", ".", "apply", "(", "config", ".", "names", "pace", "To", "Watch", "().", "get", "());", "\u0120Lock", "Watch", "Request", "\u0120request", "\u0120=", "\u0120Lock", "Watch", "Request", ".", "of", "(", "config", ".", "t", "ables", "To", "Watch", "().", "stream", "()", "\u0120.", "map", "(", "Table", "Reference", "::", "get", "Qual", "ified", "Name", ")", "\u0120.", "map", "(", "Lock", "Watch", "References", "::", "ent", "ire", "Table", ")", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "Set", "()", "));", "\u0120Lock", "Watch", "State", "Update", "\u0120version", "Before", "\u0120=", "\u0120lock", "W", "atcher", ".", "get", "Watch", "State", "(", "\u0120Optional", "Long", ".", "empty", "());", "\u0120long", "\u0120start", "Register", "ing", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120lock", "W", "atcher", ".", "start", "Watch", "ing", "(", "request", ");", "\u0120log", ".", "info", "(\"", "Registered", "\u0120lock", "\u0120watches", "\u0120for", "\u0120keys", "pace", "\u0120{}", "\u0120and", "\u0120tables", "\u0120{}", "\u0120in", "\u0120{}", "\u0120seconds", ".\",", "\u0120Safe", "Arg", ".", "of", "(\"", "keys", "pace", "\",", "\u0120config", ".", "names", "pace", "To", "Watch", "().", "get", "()", "),", "\u0120Safe", "Arg", ".", "of", "(\"", "t", "ables", "\",", "\u0120config", ".", "t", "ables", "To", "Watch", "()", "),", "\u0120Safe", "Arg", ".", "of", "(\"", "seconds", "\",", "\u0120System", ".", "current", "Time", "Mill", "is", "()", "\u0120-", "\u0120start", "Register", "ing", "));", "\u0120long", "\u0120start", "Update", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120Lock", "Watch", "State", "Update", "\u0120version", "After", "\u0120=", "\u0120lock", "W", "atcher", ".", "get", "Watch", "State", "(", "version", "Before", ".", "last", "Known", "Version", "());", "\u0120long", "\u0120duration", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "()", "\u0120-", "\u0120start", "Update", ";", "\u0120if", "\u0120(", "version", "After", ".", "success", "())", "\u0120{", "\u0120Optional", "<", "Lock", "Watch", "Event", ">", "\u0120result", "\u0120=", "\u0120version", "After", ".", "events", "().", "stream", "()", "\u0120.", "map", "(", "event", "\u0120->", "\u0120event", ".", "accept", "(", "filter", "))", "\u0120.", "filter", "(", "Optional", "::", "is", "Present", ")", "\u0120.", "map", "(", "Optional", "::", "get", ")", "\u0120.", "find", "First", "();", "\u0120if", "\u0120(!", "result", ".", "is", "Present", "())", "\u0120{", "\u0120log", ".", "info", "(\"", "Registered", "\u0120lock", "\u0120watches", ",", "\u0120but", "\u0120did", "\u0120not", "\u0120find", "\u0120any", "\u0120open", "\u0120locks", ".", "\u0120T", "ook", "\u0120{}", "\u0120seconds", "\",", "\u0120Safe", "Arg", ".", "of", "(\"", "duration", "\",", "\u0120duration", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "info", "(\"", "Registered", "\u0120lock", "\u0120watches", ",", "\u0120found", "\u0120{}", "\u0120open", "\u0120locks", ".", "\u0120T", "ook", "\u0120{}", "\u0120seconds", ".\",", "\u0120Safe", "Arg", ".", "of", "(\"", "number", "Of", "W", "atches", "\",", "\u0120((", "Lock", "Watch", "Open", "L", "ocks", "Event", ")", "\u0120result", ".", "get", "()", ").", "lock", "Desc", "ript", "ors", "().", "size", "()", "),", "\u0120Safe", "Arg", ".", "of", "(\"", "duration", "\",", "\u0120duration", "));", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "info", "(\"", "Registered", "\u0120lock", "\u0120watches", ",", "\u0120but", "\u0120was", "\u0120unable", "\u0120to", "\u0120get", "\u0120an", "\u0120update", ".", "\u0120Last", "\u0120known", "\u0120version", "\u0120is", "\u0120{}", "\",", "\u0120Safe", "Arg", ".", "of", "(\"", "last", "Known", "Version", "\",", "\u0120version", "After", ".", "last", "Known", "Version", "()", "));", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Throw", "able", "\u0120th", ")", "\u0120{", "\u0120log", ".", "info", "(\"", "F", "ailed", "\u0120to", "\u0120run", "\u0120a", "\u0120test", "\u0120iteration", "\u0120of", "\u0120registering", "\u0120lock", "\u0120watches", "\",", "\u0120th", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120The", "\u0120metric", "\u0120is", "\u0120mill", "is", ",", "\u0120not", "\u0120seconds"]}
{"function": "void preInit( FMLPreInitializationEvent event ) { if ( !Loader.isModLoaded( \"appliedenergistics2-core\" ) ) { CommonHelper.proxy.missingCoreMod(); } Stopwatch star = Stopwatch.createStarted(); this.configPath = event.getModConfigurationDirectory().getPath() + File.separator + \"AppliedEnergistics2\" + File.separator; AEConfig.instance = new AEConfig( this.configPath ); FacadeConfig.instance = new FacadeConfig( this.configPath ); AELog.info( \"Starting Pre Initialization\" ); CreativeTab.init(); if ( AEConfig.instance.isFeatureEnabled( AEFeature.Facades ) ) CreativeTabFacade.init(); if ( Platform.isClient() ) CommonHelper.proxy.init(); Registration.instance.PreInit( event ); if ( AEConfig.instance.isFeatureEnabled( AEFeature.VersionChecker ) ) { AELog.info( \"Starting VersionChecker\" ); this.startService( \"AE2 VersionChecker\", new Thread( new VersionChecker() ) ); } AELog.info( \"Pre Initialization ( ended after \" + star.elapsed( TimeUnit.MILLISECONDS ) + \"ms )\" ); }", "text": "you removed the ones on top but kept the brackets here?", "function_tokens": ["void", "\u0120pre", "Init", "(", "\u0120FML", "Pre", "Initial", "ization", "Event", "\u0120event", "\u0120)", "\u0120{", "\u0120if", "\u0120(", "\u0120!", "Loader", ".", "is", "Mod", "Load", "ed", "(", "\u0120\"", "app", "lied", "ener", "g", "istics", "2", "-", "core", "\"", "\u0120)", "\u0120)", "\u0120{", "\u0120Common", "Helper", ".", "proxy", ".", "missing", "Core", "Mod", "();", "\u0120}", "\u0120Stop", "watch", "\u0120star", "\u0120=", "\u0120Stop", "watch", ".", "create", "Start", "ed", "();", "\u0120this", ".", "config", "Path", "\u0120=", "\u0120event", ".", "get", "Mod", "Configuration", "Directory", "().", "get", "Path", "()", "\u0120+", "\u0120File", ".", "separ", "ator", "\u0120+", "\u0120\"", "App", "lied", "E", "nerg", "istics", "2", "\"", "\u0120+", "\u0120File", ".", "separ", "ator", ";", "\u0120A", "EC", "on", "fig", ".", "instance", "\u0120=", "\u0120new", "\u0120A", "EC", "on", "fig", "(", "\u0120this", ".", "config", "Path", "\u0120);", "\u0120Fac", "ade", "Config", ".", "instance", "\u0120=", "\u0120new", "\u0120Fac", "ade", "Config", "(", "\u0120this", ".", "config", "Path", "\u0120);", "\u0120A", "EL", "og", ".", "info", "(", "\u0120\"", "Starting", "\u0120Pre", "\u0120Initial", "ization", "\"", "\u0120);", "\u0120Creative", "Tab", ".", "init", "();", "\u0120if", "\u0120(", "\u0120A", "EC", "on", "fig", ".", "instance", ".", "is", "Feature", "Enabled", "(", "\u0120AE", "Feature", ".", "Fac", "ades", "\u0120)", "\u0120)", "\u0120Creative", "Tab", "Fac", "ade", ".", "init", "();", "\u0120if", "\u0120(", "\u0120Platform", ".", "is", "Client", "()", "\u0120)", "\u0120Common", "Helper", ".", "proxy", ".", "init", "();", "\u0120Registration", ".", "instance", ".", "Pre", "Init", "(", "\u0120event", "\u0120);", "\u0120if", "\u0120(", "\u0120A", "EC", "on", "fig", ".", "instance", ".", "is", "Feature", "Enabled", "(", "\u0120AE", "Feature", ".", "Version", "Check", "er", "\u0120)", "\u0120)", "\u0120{", "\u0120A", "EL", "og", ".", "info", "(", "\u0120\"", "Starting", "\u0120Version", "Check", "er", "\"", "\u0120);", "\u0120this", ".", "start", "Service", "(", "\u0120\"", "AE", "2", "\u0120Version", "Check", "er", "\",", "\u0120new", "\u0120Thread", "(", "\u0120new", "\u0120Version", "Check", "er", "()", "\u0120)", "\u0120);", "\u0120}", "\u0120A", "EL", "og", ".", "info", "(", "\u0120\"", "Pre", "\u0120Initial", "ization", "\u0120(", "\u0120ended", "\u0120after", "\u0120\"", "\u0120+", "\u0120star", ".", "el", "apsed", "(", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", "\u0120)", "\u0120+", "\u0120\"", "ms", "\u0120)", "\"", "\u0120);", "\u0120}"], "docstring_tokens": ["you", "\u0120removed", "\u0120the", "\u0120ones", "\u0120on", "\u0120top", "\u0120but", "\u0120kept", "\u0120the", "\u0120brackets", "\u0120here", "?"]}
{"function": "public static void checkValidPath(String path) throws InvalidPathException { ObjectChecker chk = new ObjectChecker() .setSafeForWindows(SystemReader.getInstance().isWindows()); byte[] bytes = Constants.encode(path); int segmentStart = 0; try { for (int i = 0; i < bytes.length; i++) { if (bytes[i] == '/') { chk.checkPathSegment(bytes, segmentStart, i); segmentStart = i + 1; } } chk.checkPathSegment(bytes, segmentStart, bytes.length); } catch (CorruptObjectException e) { throw new InvalidPathException(e.getMessage()); } }", "text": "Likewise.", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120check", "Valid", "Path", "(", "String", "\u0120path", ")", "\u0120throws", "\u0120Invalid", "Path", "Exception", "\u0120{", "\u0120Object", "Check", "er", "\u0120ch", "k", "\u0120=", "\u0120new", "\u0120Object", "Check", "er", "()", "\u0120.", "set", "Safe", "For", "Windows", "(", "System", "Reader", ".", "get", "Instance", "().", "is", "Windows", "());", "\u0120byte", "[]", "\u0120bytes", "\u0120=", "\u0120Const", "ants", ".", "en", "code", "(", "path", ");", "\u0120int", "\u0120segment", "Start", "\u0120=", "\u01200", ";", "\u0120try", "\u0120{", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120bytes", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "bytes", "[", "i", "]", "\u0120==", "\u0120'/", "')", "\u0120{", "\u0120ch", "k", ".", "check", "Path", "Seg", "ment", "(", "bytes", ",", "\u0120segment", "Start", ",", "\u0120i", ");", "\u0120segment", "Start", "\u0120=", "\u0120i", "\u0120+", "\u01201", ";", "\u0120}", "\u0120}", "\u0120ch", "k", ".", "check", "Path", "Seg", "ment", "(", "bytes", ",", "\u0120segment", "Start", ",", "\u0120bytes", ".", "length", ");", "\u0120}", "\u0120catch", "\u0120(", "Cor", "rupt", "Object", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Invalid", "Path", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Likewise", "."]}
{"function": "public static float convertLightCountsToLux(final int rawCount) { final float maxLux = 125.0f; final float maxCount = 65536.0f; final float whiteMultiplier = 2.0f; final float internalIntensity = ((float) rawCount / maxCount) * maxLux; return (whiteMultiplier * internalIntensity); }", "text": "this is possibly a breaking change for timelines. Was it tested?", "function_tokens": ["public", "\u0120static", "\u0120float", "\u0120convert", "Light", "Count", "s", "To", "L", "ux", "(", "final", "\u0120int", "\u0120raw", "Count", ")", "\u0120{", "\u0120final", "\u0120float", "\u0120max", "L", "ux", "\u0120=", "\u0120125", ".", "0", "f", ";", "\u0120final", "\u0120float", "\u0120max", "Count", "\u0120=", "\u0120655", "36", ".", "0", "f", ";", "\u0120final", "\u0120float", "\u0120white", "Mult", "ipl", "ier", "\u0120=", "\u01202", ".", "0", "f", ";", "\u0120final", "\u0120float", "\u0120internal", "Int", "ensity", "\u0120=", "\u0120((", "float", ")", "\u0120raw", "Count", "\u0120/", "\u0120max", "Count", ")", "\u0120*", "\u0120max", "L", "ux", ";", "\u0120return", "\u0120(", "white", "Mult", "ipl", "ier", "\u0120*", "\u0120internal", "Int", "ensity", ");", "\u0120}"], "docstring_tokens": ["this", "\u0120is", "\u0120possibly", "\u0120a", "\u0120breaking", "\u0120change", "\u0120for", "\u0120timelines", ".", "\u0120Was", "\u0120it", "\u0120tested", "?"]}
{"function": "private boolean getNodeMemberships(Element subscriptions) throws NodeStoreException, InterruptedException { ResultSet<NodeMembership> cur = channelManager.getNodeMemberships(node); if (channelManager.isLocalNode(node)) { subscriptions.addAttribute(XMLConstants.NODE_ATTR, node); for (NodeMembership ns : cur) { if (actorJid.toBareJID().equals(ns.getUser().toBareJID())) { Element subscription = subscriptions.addElement(XMLConstants.SUBSCRIPTION_ELEM); subscription.addAttribute(XMLConstants.NODE_ATTR, ns.getNodeId()) .addAttribute(XMLConstants.SUBSCRIPTION_ELEM, ns.getSubscription().toString()) .addAttribute(XMLConstants.JID_ATTR, ns.getUser().toBareJID()); if (null != ns.getInvitedBy() && isOwnerModerator()) { subscription.addAttribute(XMLConstants.INVITED_BY_ELEM, ns.getInvitedBy().toBareJID()); } } } } else { if (!channelManager.isCachedNode(node) || (null != requestIq.getElement().element(XMLConstants.PUBSUB_ELEM).element(XMLConstants.SET_ELEM)) && !cur.isEmpty()) { makeRemoteRequest(new JID(node.split(\"/\")[2]).getDomain()); } return false; } return true; }", "text": "This should be a not comparison, original line:  java if (false == actorJid.toBareJID().equals(ns.getUser())) {  Basically we don't want to show a subscription != 'subscribed' to anyone but the owner/admin or the user themselves.", "function_tokens": ["private", "\u0120boolean", "\u0120get", "Node", "Members", "hips", "(", "Element", "\u0120subscriptions", ")", "\u0120throws", "\u0120Node", "Store", "Exception", ",", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120Result", "Set", "<", "Node", "Members", "hip", ">", "\u0120cur", "\u0120=", "\u0120channel", "Manager", ".", "get", "Node", "Members", "hips", "(", "node", ");", "\u0120if", "\u0120(", "channel", "Manager", ".", "is", "Local", "Node", "(", "node", "))", "\u0120{", "\u0120subscriptions", ".", "add", "Attribute", "(", "X", "ML", "Const", "ants", ".", "N", "ODE", "_", "AT", "TR", ",", "\u0120node", ");", "\u0120for", "\u0120(", "Node", "Members", "hip", "\u0120ns", "\u0120:", "\u0120cur", ")", "\u0120{", "\u0120if", "\u0120(", "actor", "J", "id", ".", "to", "B", "are", "J", "ID", "().", "equ", "als", "(", "ns", ".", "get", "User", "().", "to", "B", "are", "J", "ID", "()", "))", "\u0120{", "\u0120Element", "\u0120subscription", "\u0120=", "\u0120subscriptions", ".", "add", "Element", "(", "X", "ML", "Const", "ants", ".", "SU", "BS", "CRIPTION", "_", "E", "LE", "M", ");", "\u0120subscription", ".", "add", "Attribute", "(", "X", "ML", "Const", "ants", ".", "N", "ODE", "_", "AT", "TR", ",", "\u0120ns", ".", "get", "Node", "Id", "())", "\u0120.", "add", "Attribute", "(", "X", "ML", "Const", "ants", ".", "SU", "BS", "CRIPTION", "_", "E", "LE", "M", ",", "\u0120ns", ".", "get", "Sub", "scription", "().", "to", "String", "())", "\u0120.", "add", "Attribute", "(", "X", "ML", "Const", "ants", ".", "J", "ID", "_", "AT", "TR", ",", "\u0120ns", ".", "get", "User", "().", "to", "B", "are", "J", "ID", "());", "\u0120if", "\u0120(", "null", "\u0120!=", "\u0120ns", ".", "get", "Inv", "ited", "By", "()", "\u0120&&", "\u0120is", "Owner", "Mod", "er", "ator", "())", "\u0120{", "\u0120subscription", ".", "add", "Attribute", "(", "X", "ML", "Const", "ants", ".", "IN", "V", "ITED", "_", "BY", "_", "E", "LE", "M", ",", "\u0120ns", ".", "get", "Inv", "ited", "By", "().", "to", "B", "are", "J", "ID", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(!", "channel", "Manager", ".", "is", "C", "ached", "Node", "(", "node", ")", "\u0120||", "\u0120(", "null", "\u0120!=", "\u0120request", "I", "q", ".", "get", "Element", "().", "element", "(", "X", "ML", "Const", "ants", ".", "PU", "BS", "UB", "_", "E", "LE", "M", ").", "element", "(", "X", "ML", "Const", "ants", ".", "SET", "_", "E", "LE", "M", "))", "\u0120&&", "\u0120!", "cur", ".", "is", "Empty", "())", "\u0120{", "\u0120make", "Remote", "Request", "(", "new", "\u0120J", "ID", "(", "node", ".", "split", "(\"", "/", "\")", "[", "2", "]).", "get", "Domain", "());", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120should", "\u0120be", "\u0120a", "\u0120not", "\u0120comparison", ",", "\u0120original", "\u0120line", ":", "\u0120", "\u0120java", "\u0120if", "\u0120(", "false", "\u0120==", "\u0120actor", "J", "id", ".", "to", "B", "are", "J", "ID", "().", "equ", "als", "(", "ns", ".", "get", "User", "()", "))", "\u0120{", "\u0120", "\u0120Basically", "\u0120we", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120show", "\u0120a", "\u0120subscription", "\u0120!=", "\u0120'", "sub", "scribed", "'", "\u0120to", "\u0120anyone", "\u0120but", "\u0120the", "\u0120owner", "/", "admin", "\u0120or", "\u0120the", "\u0120user", "\u0120themselves", "."]}
{"function": "public void testRestart() throws RunScriptOnNodesException { final String groupName = String.format(NAME_PREFIX, System.getProperty(\"user.name\").substring(0, 3)); Set<? extends NodeMetadata> nodes = view.getComputeService().rebootNodesMatching(inGroup(groupName)); assertTrue(nodes.size() > 0); boolean allRestarted = false; while (!allRestarted) { nodes = view.getComputeService().listNodesDetailsMatching(nameStartsWith(groupName)); for (NodeMetadata node : nodes) { if (node.getStatus() != NodeMetadata.Status.RUNNING) { allRestarted = false; try { Thread.sleep(30 * 1000); } catch (InterruptedException e) { } continue; } else { allRestarted = true; } } } assertTrue(allRestarted); view.getComputeService().destroyNodesMatching(inGroup(groupName)); }", "text": "All the above tests are already covered by the BaseComputeServiceLiveTest. You should subclass that one and try to make all tests pass without overriding its methods (as that is our compute service implementation contract). Take the [DigitalOcean](<LINK_0> one as an example.", "function_tokens": ["public", "\u0120void", "\u0120test", "Rest", "art", "()", "\u0120throws", "\u0120Run", "Script", "On", "N", "odes", "Exception", "\u0120{", "\u0120final", "\u0120String", "\u0120group", "Name", "\u0120=", "\u0120String", ".", "format", "(", "NAME", "_", "P", "REF", "IX", ",", "\u0120System", ".", "get", "Property", "(\"", "user", ".", "name", "\").", "sub", "string", "(", "0", ",", "\u01203", "));", "\u0120Set", "<?", "\u0120extends", "\u0120Node", "Met", "adata", ">", "\u0120nodes", "\u0120=", "\u0120view", ".", "get", "Comp", "ute", "Service", "().", "re", "boot", "N", "odes", "M", "atching", "(", "in", "Group", "(", "group", "Name", "));", "\u0120assert", "True", "(", "n", "odes", ".", "size", "()", "\u0120>", "\u01200", ");", "\u0120boolean", "\u0120all", "Rest", "arted", "\u0120=", "\u0120false", ";", "\u0120while", "\u0120(!", "all", "Rest", "arted", ")", "\u0120{", "\u0120nodes", "\u0120=", "\u0120view", ".", "get", "Comp", "ute", "Service", "().", "list", "N", "odes", "Details", "M", "atching", "(", "name", "St", "arts", "With", "(", "group", "Name", "));", "\u0120for", "\u0120(", "Node", "Met", "adata", "\u0120node", "\u0120:", "\u0120nodes", ")", "\u0120{", "\u0120if", "\u0120(", "node", ".", "get", "Status", "()", "\u0120!=", "\u0120Node", "Met", "adata", ".", "Status", ".", "R", "UN", "NING", ")", "\u0120{", "\u0120all", "Rest", "arted", "\u0120=", "\u0120false", ";", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "30", "\u0120*", "\u01201000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120}", "\u0120continue", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120all", "Rest", "arted", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120assert", "True", "(", "all", "Rest", "arted", ");", "\u0120view", ".", "get", "Comp", "ute", "Service", "().", "destroy", "N", "odes", "M", "atching", "(", "in", "Group", "(", "group", "Name", "));", "\u0120}"], "docstring_tokens": ["All", "\u0120the", "\u0120above", "\u0120tests", "\u0120are", "\u0120already", "\u0120covered", "\u0120by", "\u0120the", "\u0120Base", "Comp", "ute", "Service", "Live", "Test", ".", "\u0120You", "\u0120should", "\u0120subclass", "\u0120that", "\u0120one", "\u0120and", "\u0120try", "\u0120to", "\u0120make", "\u0120all", "\u0120tests", "\u0120pass", "\u0120without", "\u0120overriding", "\u0120its", "\u0120methods", "\u0120(", "as", "\u0120that", "\u0120is", "\u0120our", "\u0120compute", "\u0120service", "\u0120implementation", "\u0120contract", ").", "\u0120Take", "\u0120the", "\u0120[", "Digital", "Ocean", "](", "<", "L", "INK", "_", "0", ">", "\u0120one", "\u0120as", "\u0120an", "\u0120example", "."]}
{"function": "private void registerExternalProvidersTrustStore(DefaultHttpClient httpClient) { try { KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream inputStream = new FileInputStream( new File(EngineLocalConfig.getInstance().getExternalProvidersTrustStore().getAbsolutePath())); try { trustStore.load(inputStream, EngineLocalConfig.getInstance().getExternalProvidersTrustStorePassword().toCharArray()); } finally { inputStream.close(); } SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore); Scheme sch = new Scheme(\"https\", 443, socketFactory); httpClient.getConnectionManager().getSchemeRegistry().register(sch); } catch (Exception ex) { log.warn(\"Cannot register external providers trust store: {}\", ex.getMessage()); } }", "text": "instead you could use the try-with-resource paradigm", "function_tokens": ["private", "\u0120void", "\u0120register", "External", "Prov", "iders", "Trust", "Store", "(", "Default", "Http", "Client", "\u0120http", "Client", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Key", "Store", "\u0120trust", "Store", "\u0120=", "\u0120Key", "Store", ".", "get", "Instance", "(", "Key", "Store", ".", "get", "Default", "Type", "());", "\u0120File", "Input", "Stream", "\u0120input", "Stream", "\u0120=", "\u0120new", "\u0120File", "Input", "Stream", "(", "\u0120new", "\u0120File", "(", "Engine", "Local", "Config", ".", "get", "Instance", "().", "get", "External", "Prov", "iders", "Trust", "Store", "().", "get", "Abs", "olute", "Path", "()", "));", "\u0120try", "\u0120{", "\u0120trust", "Store", ".", "load", "(", "input", "Stream", ",", "\u0120Engine", "Local", "Config", ".", "get", "Instance", "().", "get", "External", "Prov", "iders", "Trust", "Store", "Password", "().", "to", "Char", "Array", "());", "\u0120}", "\u0120finally", "\u0120{", "\u0120input", "Stream", ".", "close", "();", "\u0120}", "\u0120SS", "LS", "ocket", "Factory", "\u0120socket", "Factory", "\u0120=", "\u0120new", "\u0120SS", "LS", "ocket", "Factory", "(", "trust", "Store", ");", "\u0120Scheme", "\u0120sch", "\u0120=", "\u0120new", "\u0120Scheme", "(\"", "https", "\",", "\u0120443", ",", "\u0120socket", "Factory", ");", "\u0120http", "Client", ".", "get", "Connection", "Manager", "().", "get", "Sche", "me", "Reg", "istry", "().", "register", "(", "sch", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120ex", ")", "\u0120{", "\u0120log", ".", "warn", "(\"", "C", "annot", "\u0120register", "\u0120external", "\u0120providers", "\u0120trust", "\u0120store", ":", "\u0120{}", "\",", "\u0120ex", ".", "get", "Message", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["instead", "\u0120you", "\u0120could", "\u0120use", "\u0120the", "\u0120try", "-", "with", "-", "resource", "\u0120paradigm"]}
{"function": "public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); TextView filesText = (TextView) view.findViewById(R.id.files_text); view.findViewById(R.id.finish_button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (activity != null) { activity.finish(); } } }); filesText.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (parent != null) { Intent intent = new Intent(Intent.ACTION_GET_CONTENT); Uri uri = Uri.parse(parent); intent.setDataAndType(uri, \"resource/folder\"); startActivity(Intent.createChooser(intent, \"Open folder\")); } } }); int numFiles = 0; Bundle args = getArguments(); if (args != null) { ArrayList<File> files = (ArrayList<File>) args.getSerializable(GeoTagImagesService.EXTRA_GEOTAGGED_FILES); numFiles = files.size(); if (files != null && numFiles > 0) { parent = files.get(0).getParent(); } } if (parent != null) { filesText.setText(String.format(getString(R.string.photos_geotagged), String.valueOf(numFiles), parent)); } else { filesText.setText(getString(R.string.no_files_geotagged)); } }", "text": "@chaviw no point checking for files being null here since you already call files.size() above.", "function_tokens": ["public", "\u0120void", "\u0120on", "View", "Created", "(", "View", "\u0120view", ",", "\u0120Bundle", "\u0120saved", "Instance", "State", ")", "\u0120{", "\u0120super", ".", "on", "View", "Created", "(", "view", ",", "\u0120saved", "Instance", "State", ");", "\u0120Text", "View", "\u0120files", "Text", "\u0120=", "\u0120(", "Text", "View", ")", "\u0120view", ".", "find", "View", "ById", "(", "R", ".", "id", ".", "files", "_", "text", ");", "\u0120view", ".", "find", "View", "ById", "(", "R", ".", "id", ".", "fin", "ish", "_", "button", ").", "set", "On", "Click", "Listener", "(", "new", "\u0120View", ".", "On", "Click", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Click", "(", "View", "\u0120v", ")", "\u0120{", "\u0120if", "\u0120(", "activity", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120activity", ".", "fin", "ish", "();", "\u0120}", "\u0120}", "\u0120});", "\u0120files", "Text", ".", "set", "On", "Click", "Listener", "(", "new", "\u0120View", ".", "On", "Click", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Click", "(", "View", "\u0120v", ")", "\u0120{", "\u0120if", "\u0120(", "parent", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Intent", "\u0120intent", "\u0120=", "\u0120new", "\u0120Intent", "(", "Int", "ent", ".", "ACTION", "_", "GET", "_", "CONT", "ENT", ");", "\u0120Uri", "\u0120ur", "i", "\u0120=", "\u0120Uri", ".", "parse", "(", "parent", ");", "\u0120intent", ".", "set", "Data", "And", "Type", "(", "uri", ",", "\u0120\"", "resource", "/", "folder", "\");", "\u0120start", "Activity", "(", "Int", "ent", ".", "create", "Cho", "oser", "(", "intent", ",", "\u0120\"", "Open", "\u0120folder", "\")", ");", "\u0120}", "\u0120}", "\u0120});", "\u0120int", "\u0120num", "Files", "\u0120=", "\u01200", ";", "\u0120Bundle", "\u0120args", "\u0120=", "\u0120get", "Arg", "uments", "();", "\u0120if", "\u0120(", "args", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Array", "List", "<", "File", ">", "\u0120files", "\u0120=", "\u0120(", "Array", "List", "<", "File", ">)", "\u0120args", ".", "get", "Serial", "izable", "(", "Ge", "o", "Tag", "Images", "Service", ".", "EXT", "RA", "_", "GE", "OT", "AG", "G", "ED", "_", "FIL", "ES", ");", "\u0120num", "Files", "\u0120=", "\u0120files", ".", "size", "();", "\u0120if", "\u0120(", "files", "\u0120!=", "\u0120null", "\u0120&&", "\u0120num", "Files", "\u0120>", "\u01200", ")", "\u0120{", "\u0120parent", "\u0120=", "\u0120files", ".", "get", "(", "0", ").", "get", "Parent", "();", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "parent", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120files", "Text", ".", "set", "Text", "(", "String", ".", "format", "(", "get", "String", "(", "R", ".", "string", ".", "photos", "_", "ge", "ot", "agged", "),", "\u0120String", ".", "value", "Of", "(", "num", "Files", "),", "\u0120parent", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120files", "Text", ".", "set", "Text", "(", "get", "String", "(", "R", ".", "string", ".", "no", "_", "files", "_", "ge", "ot", "agged", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "ch", "av", "iw", "\u0120no", "\u0120point", "\u0120checking", "\u0120for", "\u0120files", "\u0120being", "\u0120null", "\u0120here", "\u0120since", "\u0120you", "\u0120already", "\u0120call", "\u0120files", ".", "size", "()", "\u0120above", "."]}
{"function": "public Boolean attachStdin() { return (attachStdin != null) ? attachStdin : Boolean.FALSE; }", "text": "if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?", "function_tokens": ["public", "\u0120Boolean", "\u0120attach", "St", "din", "()", "\u0120{", "\u0120return", "\u0120(", "attach", "St", "din", "\u0120!=", "\u0120null", ")", "\u0120?", "\u0120attach", "St", "din", "\u0120:", "\u0120Boolean", ".", "F", "ALSE", ";", "\u0120}"], "docstring_tokens": ["if", "\u0120these", "\u0120Boolean", "\u0120methods", "\u0120can", "\u0120never", "\u0120be", "\u0120null", "\u0120why", "\u0120not", "\u0120have", "\u0120the", "\u0120return", "\u0120type", "\u0120be", "\u0120boolean", "\u0120instead", "\u0120of", "\u0120Boolean", "\u0120?"]}
{"function": "public NonTerminal(String name) { this.name = name; this.entryState = new EntryState(name + \"-entry\", this); this.exitState = new ExitState(name + \"-exit\", this); }", "text": "I still think you should throw an exception if name is null", "function_tokens": ["public", "\u0120Non", "Termin", "al", "(", "String", "\u0120name", ")", "\u0120{", "\u0120this", ".", "name", "\u0120=", "\u0120name", ";", "\u0120this", ".", "entry", "State", "\u0120=", "\u0120new", "\u0120Entry", "State", "(", "name", "\u0120+", "\u0120\"-", "entry", "\",", "\u0120this", ");", "\u0120this", ".", "exit", "State", "\u0120=", "\u0120new", "\u0120Exit", "State", "(", "name", "\u0120+", "\u0120\"-", "exit", "\",", "\u0120this", ");", "\u0120}"], "docstring_tokens": ["I", "\u0120still", "\u0120think", "\u0120you", "\u0120should", "\u0120throw", "\u0120an", "\u0120exception", "\u0120if", "\u0120name", "\u0120is", "\u0120null"]}
{"function": "public void determineNextResync(ZonedDateTime now) { this.nextResync = now.plusNanos(this.resyncPeriodInMillis * 1000000); }", "text": "Can't really understand what's going on here. We multiply by 1,000,000 a millisecond unit and add it as a nanosecond? (it would _probably_ make sense if we divided instead of multiply, but then why not just do now.plus(resyncPeriodInMillis, ChronoUnit.MILLIS))", "function_tokens": ["public", "\u0120void", "\u0120determine", "Next", "Res", "ync", "(", "Z", "oned", "Date", "Time", "\u0120now", ")", "\u0120{", "\u0120this", ".", "next", "Res", "ync", "\u0120=", "\u0120now", ".", "plus", "N", "anos", "(", "this", ".", "res", "ync", "Per", "iod", "In", "Mill", "is", "\u0120*", "\u0120100", "0000", ");", "\u0120}"], "docstring_tokens": ["Can", "'t", "\u0120really", "\u0120understand", "\u0120what", "'s", "\u0120going", "\u0120on", "\u0120here", ".", "\u0120We", "\u0120multiply", "\u0120by", "\u01201", ",", "000", ",", "000", "\u0120a", "\u0120millisec", "ond", "\u0120unit", "\u0120and", "\u0120add", "\u0120it", "\u0120as", "\u0120a", "\u0120nan", "ose", "cond", "?", "\u0120(", "it", "\u0120would", "\u0120_", "probably", "_", "\u0120make", "\u0120sense", "\u0120if", "\u0120we", "\u0120divided", "\u0120instead", "\u0120of", "\u0120multiply", ",", "\u0120but", "\u0120then", "\u0120why", "\u0120not", "\u0120just", "\u0120do", "\u0120now", ".", "plus", "(", "res", "ync", "Per", "iod", "In", "Mill", "is", ",", "\u0120Chron", "o", "Unit", ".", "M", "ILL", "IS", "))"]}
{"function": "@Test public void testArrayGetCloneRefCouples() throws Exception { Run(\"@a = array('Meow'); @b = array(@a, @a, array(@a)); @c = @b[]; msg((ref_equals(@b[0], @b[1]) && ref_equals(@b[0], @b[2][0])));\", fakePlayer); verify(fakePlayer).sendMessage(\"true\"); }", "text": "@c is not used here, I think you meant for it to be.", "function_tokens": ["@", "Test", "\u0120public", "\u0120void", "\u0120test", "Array", "Get", "Cl", "one", "Ref", "C", "ou", "ples", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Run", "(\"", "@", "a", "\u0120=", "\u0120array", "('", "Me", "ow", "');", "\u0120@", "b", "\u0120=", "\u0120array", "(", "@", "a", ",", "\u0120@", "a", ",", "\u0120array", "(", "@", "a", "));", "\u0120@", "c", "\u0120=", "\u0120@", "b", "[", "];", "\u0120msg", "((", "ref", "_", "equ", "als", "(", "@", "b", "[", "0", "],", "\u0120@", "b", "[", "1", "])", "\u0120&&", "\u0120ref", "_", "equ", "als", "(", "@", "b", "[", "0", "],", "\u0120@", "b", "[", "2", "][", "0", "]", "))", ");", "\",", "\u0120fake", "Player", ");", "\u0120verify", "(", "fake", "Player", ").", "send", "Message", "(\"", "true", "\");", "\u0120}"], "docstring_tokens": ["@", "c", "\u0120is", "\u0120not", "\u0120used", "\u0120here", ",", "\u0120I", "\u0120think", "\u0120you", "\u0120meant", "\u0120for", "\u0120it", "\u0120to", "\u0120be", "."]}
{"function": "void resizeArray(int newArraySize) { long[] newArray = new long[newArraySize]; System.arraycopy(this.array, 0, newArray, 0, this.array.length); this.array = newArray; }", "text": "I think this will fail if the new size is smaller than the current one. Could be checked with an assert (private methods).", "function_tokens": ["void", "\u0120resize", "Array", "(", "int", "\u0120new", "Array", "Size", ")", "\u0120{", "\u0120long", "[]", "\u0120new", "Array", "\u0120=", "\u0120new", "\u0120long", "[", "new", "Array", "Size", "];", "\u0120System", ".", "array", "copy", "(", "this", ".", "array", ",", "\u01200", ",", "\u0120new", "Array", ",", "\u01200", ",", "\u0120this", ".", "array", ".", "length", ");", "\u0120this", ".", "array", "\u0120=", "\u0120new", "Array", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120this", "\u0120will", "\u0120fail", "\u0120if", "\u0120the", "\u0120new", "\u0120size", "\u0120is", "\u0120smaller", "\u0120than", "\u0120the", "\u0120current", "\u0120one", ".", "\u0120Could", "\u0120be", "\u0120checked", "\u0120with", "\u0120an", "\u0120assert", "\u0120(", "private", "\u0120methods", ")."]}
{"function": "public void onResume() { super.onResume(); if (mSelectRoleShareVM.isRemoveSeleted()) { showSpinner(); mCollaborationsShareVM.deleteCollaboration(mSelectRoleShareVM.getCollaboration()); mSelectRoleShareVM.setRemoveSelected(false); } else { if (mSelectRoleShareVM.getSelectedRole().getValue() != null && mSelectRoleShareVM.getCollaboration() != null) { if (mSelectRoleShareVM.getSelectedRole().getValue() != mSelectRoleShareVM.getCollaboration().getRole()) { if (mSelectRoleShareVM.getSelectedRole().getValue() == BoxCollaboration.Role.OWNER) { AlertDialog dialog = new AlertDialog.Builder(getActivity()).setTitle(R.string.box_sharesdk_change_owner_alert_title) .setMessage(R.string.box_sharesdk_change_owner_alert_message) .setPositiveButton(android.R.string.yes, (d, which) -> { showSpinner(R.string.box_sharesdk_fetching_collaborators, R.string.boxsdk_Please_wait); mCollaborationsShareVM.updateOwner(mSelectRoleShareVM.getCollaboration()); }).setNegativeButton(android.R.string.no, (d, which) -> {}).setIcon(android.R.drawable.ic_dialog_alert).create(); dialog.show(); } else { showSpinner(); mCollaborationsShareVM.updateCollaboration(mSelectRoleShareVM.getCollaboration(), mSelectRoleShareVM.getSelectedRole().getValue()); } mSelectRoleShareVM.setSelectedRole(null); } } } if (mCollaborationsShareVM.getCollaborations().getValue() == null) { mCollaborationsShareVM.fetchItemInfo(mCollaborationsShareVM.getShareItem()); } }", "text": "removeSelected?", "function_tokens": ["public", "\u0120void", "\u0120on", "Res", "ume", "()", "\u0120{", "\u0120super", ".", "on", "Res", "ume", "();", "\u0120if", "\u0120(", "m", "Select", "Role", "Share", "VM", ".", "is", "Remove", "Se", "leted", "())", "\u0120{", "\u0120show", "Sp", "inner", "();", "\u0120m", "Coll", "abor", "ations", "Share", "VM", ".", "delete", "Coll", "abor", "ation", "(", "m", "Select", "Role", "Share", "VM", ".", "get", "Coll", "abor", "ation", "());", "\u0120m", "Select", "Role", "Share", "VM", ".", "set", "Remove", "Se", "lected", "(", "false", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "m", "Select", "Role", "Share", "VM", ".", "get", "Se", "lected", "Role", "().", "get", "Value", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120m", "Select", "Role", "Share", "VM", ".", "get", "Coll", "abor", "ation", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "m", "Select", "Role", "Share", "VM", ".", "get", "Se", "lected", "Role", "().", "get", "Value", "()", "\u0120!=", "\u0120m", "Select", "Role", "Share", "VM", ".", "get", "Coll", "abor", "ation", "().", "get", "Role", "())", "\u0120{", "\u0120if", "\u0120(", "m", "Select", "Role", "Share", "VM", ".", "get", "Se", "lected", "Role", "().", "get", "Value", "()", "\u0120==", "\u0120Box", "Coll", "abor", "ation", ".", "Role", ".", "OWN", "ER", ")", "\u0120{", "\u0120Alert", "Dialog", "\u0120dialog", "\u0120=", "\u0120new", "\u0120Alert", "Dialog", ".", "Builder", "(", "get", "Activity", "()", ").", "set", "Title", "(", "R", ".", "string", ".", "box", "_", "sh", "ares", "dk", "_", "change", "_", "owner", "_", "alert", "_", "title", ")", "\u0120.", "set", "Message", "(", "R", ".", "string", ".", "box", "_", "sh", "ares", "dk", "_", "change", "_", "owner", "_", "alert", "_", "message", ")", "\u0120.", "set", "Pos", "itive", "Button", "(", "android", ".", "R", ".", "string", ".", "yes", ",", "\u0120(", "d", ",", "\u0120which", ")", "\u0120->", "\u0120{", "\u0120show", "Sp", "inner", "(", "R", ".", "string", ".", "box", "_", "sh", "ares", "dk", "_", "f", "etch", "ing", "_", "coll", "abor", "ators", ",", "\u0120R", ".", "string", ".", "box", "sd", "k", "_", "Please", "_", "wait", ");", "\u0120m", "Coll", "abor", "ations", "Share", "VM", ".", "update", "Owner", "(", "m", "Select", "Role", "Share", "VM", ".", "get", "Coll", "abor", "ation", "());", "\u0120}", ").", "set", "Neg", "ative", "Button", "(", "android", ".", "R", ".", "string", ".", "no", ",", "\u0120(", "d", ",", "\u0120which", ")", "\u0120->", "\u0120{}", ").", "set", "Icon", "(", "android", ".", "R", ".", "draw", "able", ".", "ic", "_", "dial", "og", "_", "alert", ").", "create", "();", "\u0120dialog", ".", "show", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120show", "Sp", "inner", "();", "\u0120m", "Coll", "abor", "ations", "Share", "VM", ".", "update", "Coll", "abor", "ation", "(", "m", "Select", "Role", "Share", "VM", ".", "get", "Coll", "abor", "ation", "(),", "\u0120m", "Select", "Role", "Share", "VM", ".", "get", "Se", "lected", "Role", "().", "get", "Value", "());", "\u0120}", "\u0120m", "Select", "Role", "Share", "VM", ".", "set", "Se", "lected", "Role", "(", "null", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "m", "Coll", "abor", "ations", "Share", "VM", ".", "get", "Coll", "abor", "ations", "().", "get", "Value", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120m", "Coll", "abor", "ations", "Share", "VM", ".", "f", "etch", "Item", "Info", "(", "m", "Coll", "abor", "ations", "Share", "VM", ".", "get", "Share", "Item", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["remove", "Se", "lected", "?"]}
{"function": "void stop() { allocatorExecutor.shutdown(); try { if (!allocatorExecutor.awaitTermination(3, TimeUnit.SECONDS)) { log.warn(\"Timedout while awaiting for allocatorExecutor's termination, so force shuttingdown\"); } } catch (InterruptedException e) { log.warn(\"Got InterruptedException while awaiting termination of allocatorExecutor, so force shuttingdown\"); } allocatorExecutor.shutdownNow(); log.info(\"Stopped entry logger preallocator.\"); }", "text": "We can give some more time, like 30 seconds.", "function_tokens": ["void", "\u0120stop", "()", "\u0120{", "\u0120alloc", "ator", "Exec", "utor", ".", "shut", "down", "();", "\u0120try", "\u0120{", "\u0120if", "\u0120(!", "alloc", "ator", "Exec", "utor", ".", "aw", "ait", "Ter", "mination", "(", "3", ",", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", "))", "\u0120{", "\u0120log", ".", "warn", "(\"", "Tim", "ed", "out", "\u0120while", "\u0120awaiting", "\u0120for", "\u0120alloc", "ator", "Exec", "utor", "'s", "\u0120termination", ",", "\u0120so", "\u0120force", "\u0120shutting", "down", "\");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "(\"", "Got", "\u0120Inter", "rupted", "Exception", "\u0120while", "\u0120awaiting", "\u0120termination", "\u0120of", "\u0120alloc", "ator", "Exec", "utor", ",", "\u0120so", "\u0120force", "\u0120shutting", "down", "\");", "\u0120}", "\u0120alloc", "ator", "Exec", "utor", ".", "shut", "down", "Now", "();", "\u0120log", ".", "info", "(\"", "St", "opped", "\u0120entry", "\u0120logger", "\u0120pre", "alloc", "ator", ".\"", ");", "\u0120}"], "docstring_tokens": ["We", "\u0120can", "\u0120give", "\u0120some", "\u0120more", "\u0120time", ",", "\u0120like", "\u012030", "\u0120seconds", "."]}
{"function": "public AbstractLunAvailableSizeColumn() { super(new AbstractToggleButtonCell<LunModel>() { @Override public void onClickEvent(LunModel lunModel) { if (lunModel !=null) { lunModel.setAdditionalAvailableSizeSelected(!lunModel.isAdditionalAvailableSizeSelected()); } } @Override public void render(Context context, LunModel value, SafeHtmlBuilder sb, String id) { boolean isGrayedOut = value.getIsGrayedOut(); String inputId = id + \"_input\"; SafeHtml input = null; int additionalAvailableSizeSize = value.getAdditionalAvailableSize(); String additionalAvailableSizeSizeString = \"+ \" + additionalAvailableSizeSize + \" GB\"; if (additionalAvailableSizeSize == 0 || !value.getIsIncluded()) { input = templates.disabled(\"\", \"color:gray\", inputId); } else if (!isGrayedOut) { input = templates.disabled(\"\", \"color:black\", inputId); } else if (value.isAdditionalAvailableSizeSelected()) { input = templates.toggledDown(inputId, additionalAvailableSizeSizeString); } else { input = templates.toggledUp(inputId, additionalAvailableSizeSizeString); } sb.append(templates.span(id, input)); } }); }", "text": "redundant black line", "function_tokens": ["public", "\u0120Abstract", "L", "un", "Available", "Size", "Column", "()", "\u0120{", "\u0120super", "(", "new", "\u0120Abstract", "T", "oggle", "Button", "Cell", "<", "L", "un", "Model", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Click", "Event", "(", "L", "un", "Model", "\u0120lun", "Model", ")", "\u0120{", "\u0120if", "\u0120(", "l", "un", "Model", "\u0120!=", "null", ")", "\u0120{", "\u0120lun", "Model", ".", "set", "Additional", "Available", "Size", "Se", "lected", "(", "!", "l", "un", "Model", ".", "is", "Additional", "Available", "Size", "Se", "lected", "());", "\u0120}", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120render", "(", "Context", "\u0120context", ",", "\u0120Lun", "Model", "\u0120value", ",", "\u0120Safe", "H", "tml", "Builder", "\u0120s", "b", ",", "\u0120String", "\u0120id", ")", "\u0120{", "\u0120boolean", "\u0120is", "Gray", "ed", "Out", "\u0120=", "\u0120value", ".", "get", "Is", "Gray", "ed", "Out", "();", "\u0120String", "\u0120input", "Id", "\u0120=", "\u0120id", "\u0120+", "\u0120\"_", "input", "\";", "\u0120Safe", "H", "tml", "\u0120input", "\u0120=", "\u0120null", ";", "\u0120int", "\u0120additional", "Available", "Size", "Size", "\u0120=", "\u0120value", ".", "get", "Additional", "Available", "Size", "();", "\u0120String", "\u0120additional", "Available", "Size", "Size", "String", "\u0120=", "\u0120\"+", "\u0120\"", "\u0120+", "\u0120additional", "Available", "Size", "Size", "\u0120+", "\u0120\"", "\u0120GB", "\";", "\u0120if", "\u0120(", "add", "itional", "Available", "Size", "Size", "\u0120==", "\u01200", "\u0120||", "\u0120!", "value", ".", "get", "Is", "In", "cluded", "())", "\u0120{", "\u0120input", "\u0120=", "\u0120templates", ".", "disabled", "(\"", "\",", "\u0120\"", "color", ":", "gray", "\",", "\u0120input", "Id", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(!", "is", "Gray", "ed", "Out", ")", "\u0120{", "\u0120input", "\u0120=", "\u0120templates", ".", "disabled", "(\"", "\",", "\u0120\"", "color", ":", "black", "\",", "\u0120input", "Id", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", ".", "is", "Additional", "Available", "Size", "Se", "lected", "())", "\u0120{", "\u0120input", "\u0120=", "\u0120templates", ".", "t", "ogg", "led", "Down", "(", "input", "Id", ",", "\u0120additional", "Available", "Size", "Size", "String", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120input", "\u0120=", "\u0120templates", ".", "t", "ogg", "led", "Up", "(", "input", "Id", ",", "\u0120additional", "Available", "Size", "Size", "String", ");", "\u0120}", "\u0120s", "b", ".", "append", "(", "tem", "plates", ".", "span", "(", "id", ",", "\u0120input", "));", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["red", "und", "ant", "\u0120black", "\u0120line"]}
{"function": "public String getPendingViewAsString() { CacheTopology cacheTopology = stateTransferManager.getCacheTopology(); return (!(cacheTopology != null && cacheTopology.getPendingCH() != null)) ? \"N/A\" : cacheTopology.getPendingCH().getMembers().toString(); }", "text": "Reverse the operands to avoid negation maybe? Would look nicer.", "function_tokens": ["public", "\u0120String", "\u0120get", "P", "ending", "View", "As", "String", "()", "\u0120{", "\u0120Cache", "Top", "ology", "\u0120cache", "Top", "ology", "\u0120=", "\u0120state", "Transfer", "Manager", ".", "get", "Cache", "Top", "ology", "();", "\u0120return", "\u0120(!", "(", "cache", "Top", "ology", "\u0120!=", "\u0120null", "\u0120&&", "\u0120cache", "Top", "ology", ".", "get", "P", "ending", "CH", "()", "\u0120!=", "\u0120null", "))", "\u0120?", "\u0120\"", "N", "/", "A", "\"", "\u0120:", "\u0120cache", "Top", "ology", ".", "get", "P", "ending", "CH", "().", "get", "Members", "().", "to", "String", "();", "\u0120}"], "docstring_tokens": ["R", "ever", "se", "\u0120the", "\u0120oper", "ands", "\u0120to", "\u0120avoid", "\u0120neg", "ation", "\u0120maybe", "?", "\u0120Would", "\u0120look", "\u0120nicer", "."]}
{"function": "public void scrutinize(ItemUpdate update) { Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>(); for (Statement statement : update.getAddedStatements()){ PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId(); Value value = statement.getClaim().getMainSnak().getValue(); propertyIdValueValueMap.put(pid, value); } for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){ List<PropertyIdValue> conflictingProperties = _fetcher.getConflictsWithProperties(propertyId); if (conflictingProperties != null){ for (PropertyIdValue conflictingPid : conflictingProperties) { if (propertyIdValueValueMap.containsKey(conflictingPid) && raiseWarning(propertyId, propertyIdValueValueMap, conflictingPid)) { QAWarning issue = new QAWarning(type, propertyId.getId(), QAWarning.Severity.WARNING, 1); issue.setProperty(\"property_entity\", propertyId); issue.setProperty(\"added_property_entity\", conflictingPid); issue.setProperty(\"example_entity\", update.getItemId()); addIssue(issue); } } } } }", "text": "We need to check to check what happens with no value and some value snaks.", "function_tokens": ["public", "\u0120void", "\u0120scrutin", "ize", "(", "Item", "Update", "\u0120update", ")", "\u0120{", "\u0120Map", "<", "Property", "Id", "Value", ",", "\u0120Value", ">", "\u0120property", "Id", "Value", "Value", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120for", "\u0120(", "Statement", "\u0120statement", "\u0120:", "\u0120update", ".", "get", "Added", "Stat", "ements", "()", "){", "\u0120Property", "Id", "Value", "\u0120pid", "\u0120=", "\u0120statement", ".", "get", "Claim", "().", "get", "Main", "Sn", "ak", "().", "get", "Property", "Id", "();", "\u0120Value", "\u0120value", "\u0120=", "\u0120statement", ".", "get", "Claim", "().", "get", "Main", "Sn", "ak", "().", "get", "Value", "();", "\u0120property", "Id", "Value", "Value", "Map", ".", "put", "(", "pid", ",", "\u0120value", ");", "\u0120}", "\u0120for", "(", "Property", "Id", "Value", "\u0120property", "Id", "\u0120:", "\u0120property", "Id", "Value", "Value", "Map", ".", "key", "Set", "()", "){", "\u0120List", "<", "Property", "Id", "Value", ">", "\u0120conflicting", "Pro", "perties", "\u0120=", "\u0120_", "fet", "cher", ".", "get", "Conf", "licts", "With", "Pro", "perties", "(", "property", "Id", ");", "\u0120if", "\u0120(", "conf", "lic", "ting", "Pro", "perties", "\u0120!=", "\u0120null", "){", "\u0120for", "\u0120(", "Property", "Id", "Value", "\u0120conflicting", "P", "id", "\u0120:", "\u0120conflicting", "Pro", "perties", ")", "\u0120{", "\u0120if", "\u0120(", "property", "Id", "Value", "Value", "Map", ".", "cont", "ains", "Key", "(", "conf", "lic", "ting", "P", "id", ")", "\u0120&&", "\u0120raise", "Warning", "(", "property", "Id", ",", "\u0120property", "Id", "Value", "Value", "Map", ",", "\u0120conflicting", "P", "id", "))", "\u0120{", "\u0120Q", "AW", "arning", "\u0120issue", "\u0120=", "\u0120new", "\u0120Q", "AW", "arning", "(", "type", ",", "\u0120property", "Id", ".", "get", "Id", "(),", "\u0120Q", "AW", "arning", ".", "S", "ever", "ity", ".", "WARNING", ",", "\u01201", ");", "\u0120issue", ".", "set", "Property", "(\"", "property", "_", "entity", "\",", "\u0120property", "Id", ");", "\u0120issue", ".", "set", "Property", "(\"", "added", "_", "property", "_", "entity", "\",", "\u0120conflicting", "P", "id", ");", "\u0120issue", ".", "set", "Property", "(\"", "example", "_", "entity", "\",", "\u0120update", ".", "get", "Item", "Id", "());", "\u0120add", "Issue", "(", "issue", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["We", "\u0120need", "\u0120to", "\u0120check", "\u0120to", "\u0120check", "\u0120what", "\u0120happens", "\u0120with", "\u0120no", "\u0120value", "\u0120and", "\u0120some", "\u0120value", "\u0120sn", "aks", "."]}
{"function": "public SSLContext get() { Credentials currentCreds = checkNotNull(creds.get(), \"credential supplier returned null\"); String keyStorePassword = checkNotNull(currentCreds.credential, \"credential supplier returned null credential (should be keyStorePassword)\"); KeyManagerFactory kmf; try { kmf = KeyManagerFactory.getInstance(\"SunX509\"); kmf.init(keyStore.get(), keyStorePassword.toCharArray()); SSLContext sc = SSLContext.getInstance(\"TLS\"); sc.init(kmf.getKeyManagers(), trustManager, new SecureRandom()); System.setProperty(\"https.protocols\", \"TLSv1\"); return sc; } catch (NoSuchAlgorithmException e) { throw propagate(e); } catch (UnrecoverableKeyException e) { throw propagate(e); } catch (KeyStoreException e) { throw propagate(e); } catch (KeyManagementException e) { throw propagate(e); } }", "text": "find a better way, this is super dodgy", "function_tokens": ["public", "\u0120SSL", "Context", "\u0120get", "()", "\u0120{", "\u0120C", "red", "entials", "\u0120current", "C", "red", "s", "\u0120=", "\u0120check", "Not", "Null", "(", "c", "red", "s", ".", "get", "(),", "\u0120\"", "c", "red", "ential", "\u0120supplier", "\u0120returned", "\u0120null", "\");", "\u0120String", "\u0120key", "Store", "Password", "\u0120=", "\u0120check", "Not", "Null", "(", "current", "C", "red", "s", ".", "c", "red", "ential", ",", "\u0120\"", "c", "red", "ential", "\u0120supplier", "\u0120returned", "\u0120null", "\u0120credential", "\u0120(", "should", "\u0120be", "\u0120key", "Store", "Password", ")", "\");", "\u0120Key", "Manager", "Factory", "\u0120km", "f", ";", "\u0120try", "\u0120{", "\u0120km", "f", "\u0120=", "\u0120Key", "Manager", "Factory", ".", "get", "Instance", "(\"", "Sun", "X", "509", "\");", "\u0120km", "f", ".", "init", "(", "key", "Store", ".", "get", "(),", "\u0120key", "Store", "Password", ".", "to", "Char", "Array", "());", "\u0120SSL", "Context", "\u0120sc", "\u0120=", "\u0120SSL", "Context", ".", "get", "Instance", "(\"", "T", "LS", "\");", "\u0120sc", ".", "init", "(", "km", "f", ".", "get", "Key", "Man", "agers", "(),", "\u0120trust", "Manager", ",", "\u0120new", "\u0120Secure", "Random", "());", "\u0120System", ".", "set", "Property", "(\"", "https", ".", "prot", "ocol", "s", "\",", "\u0120\"", "T", "LS", "v", "1", "\");", "\u0120return", "\u0120sc", ";", "\u0120}", "\u0120catch", "\u0120(", "No", "Such", "Al", "gorithm", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120propagate", "(", "e", ");", "\u0120}", "\u0120catch", "\u0120(", "Un", "re", "cover", "able", "Key", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120propagate", "(", "e", ");", "\u0120}", "\u0120catch", "\u0120(", "Key", "Store", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120propagate", "(", "e", ");", "\u0120}", "\u0120catch", "\u0120(", "Key", "Management", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120propagate", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["find", "\u0120a", "\u0120better", "\u0120way", ",", "\u0120this", "\u0120is", "\u0120super", "\u0120dod", "gy"]}
{"function": "public void fromStream_user_providesToken() throws IOException { MockTokenServerTransportFactory transportFactory = new MockTokenServerTransportFactory(); transportFactory.transport.addClient(CLIENT_ID, CLIENT_SECRET); transportFactory.transport.addRefreshToken(REFRESH_TOKEN, ACCESS_TOKEN); InputStream userStream = UserCredentialsTest.writeUserStream(CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN); UserCredentials credentials = UserCredentials.fromStream(userStream, transportFactory); assertNotNull(credentials); Map<String, List<String>> metadata = credentials.getRequestMetadata(CALL_URI); TestUtils.assertContainsBearerToken(metadata, ACCESS_TOKEN); }", "text": "Fully-qualified class name not needed.", "function_tokens": ["public", "\u0120void", "\u0120from", "Stream", "_", "user", "_", "prov", "ides", "Token", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120Mock", "Token", "Server", "Trans", "port", "Factory", "\u0120transport", "Factory", "\u0120=", "\u0120new", "\u0120Mock", "Token", "Server", "Trans", "port", "Factory", "();", "\u0120transport", "Factory", ".", "trans", "port", ".", "add", "Client", "(", "CL", "IENT", "_", "ID", ",", "\u0120CLIENT", "_", "SEC", "RET", ");", "\u0120transport", "Factory", ".", "trans", "port", ".", "add", "Ref", "resh", "Token", "(", "RE", "FR", "ESH", "_", "TO", "KEN", ",", "\u0120ACC", "ESS", "_", "TO", "KEN", ");", "\u0120Input", "Stream", "\u0120user", "Stream", "\u0120=", "\u0120User", "C", "red", "entials", "Test", ".", "write", "User", "Stream", "(", "CL", "IENT", "_", "ID", ",", "\u0120CLIENT", "_", "SEC", "RET", ",", "\u0120RE", "FR", "ESH", "_", "TO", "KEN", ");", "\u0120User", "C", "red", "entials", "\u0120credentials", "\u0120=", "\u0120User", "C", "red", "entials", ".", "from", "Stream", "(", "user", "Stream", ",", "\u0120transport", "Factory", ");", "\u0120assert", "Not", "Null", "(", "c", "red", "entials", ");", "\u0120Map", "<", "String", ",", "\u0120List", "<", "String", ">>", "\u0120metadata", "\u0120=", "\u0120credentials", ".", "get", "Request", "Met", "adata", "(", "C", "ALL", "_", "URI", ");", "\u0120Test", "Ut", "ils", ".", "assert", "Cont", "ains", "Be", "arer", "Token", "(", "metadata", ",", "\u0120ACC", "ESS", "_", "TO", "KEN", ");", "\u0120}"], "docstring_tokens": ["F", "ully", "-", "qualified", "\u0120class", "\u0120name", "\u0120not", "\u0120needed", "."]}
{"function": "public void scan(HttpMessage msg, String param, String value) { if (this.inScope(Tech.Linux) || this.inScope(Tech.MacOS)) { if (matchBodyPattern(getBaseMsg(), patternSSIUnix, new StringBuilder())) { return; } if (testServerSideInclude(param, SSI_UNIX, patternSSIUnix)) { return; } if (testServerSideInclude(param, SSI_UNIX2, patternSSIUnix)) { return; } } if (this.inScope(Tech.Windows)) { if (matchBodyPattern(getBaseMsg(), patternSSIWin, new StringBuilder())) { return; } if (testServerSideInclude(param, SSI_WIN, patternSSIWin)) { return; } if (testServerSideInclude(param, SSI_WIN2, patternSSIWin)) { return; } } }", "text": "- This should be done in the previous if statement (after tech checks), to not return earlier (Windows test could still be done). Also, worth extracting a method to reduce code duplication (boolean isEvidencePresent(Pattern)?). - Since the result is not required the StringBuilder can be null.", "function_tokens": ["public", "\u0120void", "\u0120scan", "(", "Http", "Message", "\u0120msg", ",", "\u0120String", "\u0120param", ",", "\u0120String", "\u0120value", ")", "\u0120{", "\u0120if", "\u0120(", "this", ".", "in", "Scope", "(", "Tech", ".", "Linux", ")", "\u0120||", "\u0120this", ".", "in", "Scope", "(", "Tech", ".", "Mac", "OS", "))", "\u0120{", "\u0120if", "\u0120(", "match", "Body", "Pattern", "(", "get", "Base", "Msg", "(),", "\u0120pattern", "SS", "I", "Unix", ",", "\u0120new", "\u0120String", "Builder", "()", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "test", "Server", "Side", "In", "clude", "(", "param", ",", "\u0120SS", "I", "_", "UN", "IX", ",", "\u0120pattern", "SS", "I", "Unix", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "test", "Server", "Side", "In", "clude", "(", "param", ",", "\u0120SS", "I", "_", "UN", "IX", "2", ",", "\u0120pattern", "SS", "I", "Unix", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "this", ".", "in", "Scope", "(", "Tech", ".", "Windows", "))", "\u0120{", "\u0120if", "\u0120(", "match", "Body", "Pattern", "(", "get", "Base", "Msg", "(),", "\u0120pattern", "SS", "I", "Win", ",", "\u0120new", "\u0120String", "Builder", "()", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "test", "Server", "Side", "In", "clude", "(", "param", ",", "\u0120SS", "I", "_", "WIN", ",", "\u0120pattern", "SS", "I", "Win", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "test", "Server", "Side", "In", "clude", "(", "param", ",", "\u0120SS", "I", "_", "WIN", "2", ",", "\u0120pattern", "SS", "I", "Win", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["-", "\u0120This", "\u0120should", "\u0120be", "\u0120done", "\u0120in", "\u0120the", "\u0120previous", "\u0120if", "\u0120statement", "\u0120(", "after", "\u0120tech", "\u0120checks", "),", "\u0120to", "\u0120not", "\u0120return", "\u0120earlier", "\u0120(", "Windows", "\u0120test", "\u0120could", "\u0120still", "\u0120be", "\u0120done", ").", "\u0120Also", ",", "\u0120worth", "\u0120extracting", "\u0120a", "\u0120method", "\u0120to", "\u0120reduce", "\u0120code", "\u0120duplication", "\u0120(", "bo", "olean", "\u0120is", "Evidence", "Present", "(", "Pattern", ")?", ").", "\u0120-", "\u0120Since", "\u0120the", "\u0120result", "\u0120is", "\u0120not", "\u0120required", "\u0120the", "\u0120String", "Builder", "\u0120can", "\u0120be", "\u0120null", "."]}
{"function": "public void installServices(OperationContext context, ModelNode model) throws OperationFailedException { if (!context.isBooting()) return; ModelNode subsystemModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS)); if (subsystemModel.hasDefined(ProxyConfigurationResourceDefinition.WILDCARD_PATH.getKey())) { Set<String> adapterNames = new HashSet<>(); Set<LoadMetric> enabledMetrics = new HashSet<>(); for (Property property : subsystemModel.get(ProxyConfigurationResourceDefinition.WILDCARD_PATH.getKey()).asPropertyList()) { String proxyName = property.getName(); adapterNames.add(proxyName); ModelNode proxyModel = property.getValue(); ServiceTarget target = context.getServiceTarget(); ProxyConfigurationServiceConfigurator configurationBuilder = new ProxyConfigurationServiceConfigurator(proxyName); configurationBuilder.configure(context, proxyModel).build(target).install(); Set<LoadMetric> metrics = new HashSet<>(); LoadBalanceFactorProvider loadProvider = this.getLoadProvider(proxyName, metrics, context, proxyModel); enabledMetrics.addAll(metrics); String connector = CONNECTOR.resolveModelAttribute(context, proxyModel).asString(); int statusInterval = STATUS_INTERVAL.resolveModelAttribute(context, proxyModel).asInt(); new ContainerEventHandlerServiceConfigurator(proxyName, loadProvider).build(target).install(); for (ContainerEventHandlerAdapterServiceConfiguratorProvider provider : ServiceLoader.load(ContainerEventHandlerAdapterServiceConfiguratorProvider.class, ContainerEventHandlerAdapterServiceConfiguratorProvider.class.getClassLoader())) { provider.getServiceConfigurator(proxyName, connector, Duration.ofSeconds(statusInterval)).configure(context).build(target).setInitialMode(Mode.PASSIVE).install(); } } for (BoottimeHandlerProvider handler : ServiceLoader.load(BoottimeHandlerProvider.class, BoottimeHandlerProvider.class.getClassLoader())) { handler.performBoottime(context, adapterNames, enabledMetrics); } } }", "text": "Rather than iterate over the whole model twice, just use the Resource interface to nagivate through child resources once.", "function_tokens": ["public", "\u0120void", "\u0120install", "Services", "(", "Operation", "Context", "\u0120context", ",", "\u0120Model", "Node", "\u0120model", ")", "\u0120throws", "\u0120Operation", "F", "ailed", "Exception", "\u0120{", "\u0120if", "\u0120(!", "context", ".", "is", "B", "ooting", "())", "\u0120return", ";", "\u0120Model", "Node", "\u0120subsystem", "Model", "\u0120=", "\u0120Resource", ".", "Tools", ".", "read", "Model", "(", "context", ".", "read", "Resource", "(", "Path", "Address", ".", "EMP", "TY", "_", "AD", "DR", "ESS", "));", "\u0120if", "\u0120(", "sub", "system", "Model", ".", "has", "Def", "ined", "(", "Proxy", "Configuration", "Resource", "Definition", ".", "W", "IL", "DC", "ARD", "_", "PATH", ".", "get", "Key", "()", "))", "\u0120{", "\u0120Set", "<", "String", ">", "\u0120adapter", "Names", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120Set", "<", "Load", "Met", "ric", ">", "\u0120enabled", "Met", "rics", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120for", "\u0120(", "Property", "\u0120property", "\u0120:", "\u0120subsystem", "Model", ".", "get", "(", "Proxy", "Configuration", "Resource", "Definition", ".", "W", "IL", "DC", "ARD", "_", "PATH", ".", "get", "Key", "()", ").", "as", "Property", "List", "())", "\u0120{", "\u0120String", "\u0120proxy", "Name", "\u0120=", "\u0120property", ".", "get", "Name", "();", "\u0120adapter", "Names", ".", "add", "(", "proxy", "Name", ");", "\u0120Model", "Node", "\u0120proxy", "Model", "\u0120=", "\u0120property", ".", "get", "Value", "();", "\u0120Service", "Target", "\u0120target", "\u0120=", "\u0120context", ".", "get", "Service", "Target", "();", "\u0120Proxy", "Configuration", "Service", "Config", "ur", "ator", "\u0120configuration", "Builder", "\u0120=", "\u0120new", "\u0120Proxy", "Configuration", "Service", "Config", "ur", "ator", "(", "proxy", "Name", ");", "\u0120configuration", "Builder", ".", "config", "ure", "(", "context", ",", "\u0120proxy", "Model", ").", "build", "(", "target", ").", "install", "();", "\u0120Set", "<", "Load", "Met", "ric", ">", "\u0120metrics", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120Load", "Balance", "Factor", "Provider", "\u0120load", "Provider", "\u0120=", "\u0120this", ".", "get", "Load", "Provider", "(", "proxy", "Name", ",", "\u0120metrics", ",", "\u0120context", ",", "\u0120proxy", "Model", ");", "\u0120enabled", "Met", "rics", ".", "add", "All", "(", "met", "rics", ");", "\u0120String", "\u0120connector", "\u0120=", "\u0120CON", "NECT", "OR", ".", "res", "olve", "Model", "Attribute", "(", "context", ",", "\u0120proxy", "Model", ").", "as", "String", "();", "\u0120int", "\u0120status", "Inter", "val", "\u0120=", "\u0120STAT", "US", "_", "INTER", "VAL", ".", "res", "olve", "Model", "Attribute", "(", "context", ",", "\u0120proxy", "Model", ").", "as", "Int", "();", "\u0120new", "\u0120Container", "Event", "Handler", "Service", "Config", "ur", "ator", "(", "proxy", "Name", ",", "\u0120load", "Provider", ").", "build", "(", "target", ").", "install", "();", "\u0120for", "\u0120(", "Container", "Event", "Handler", "Adapter", "Service", "Config", "ur", "ator", "Provider", "\u0120provider", "\u0120:", "\u0120Service", "Loader", ".", "load", "(", "Container", "Event", "Handler", "Adapter", "Service", "Config", "ur", "ator", "Provider", ".", "class", ",", "\u0120Container", "Event", "Handler", "Adapter", "Service", "Config", "ur", "ator", "Provider", ".", "class", ".", "get", "Class", "Loader", "()", "))", "\u0120{", "\u0120provider", ".", "get", "Service", "Config", "ur", "ator", "(", "proxy", "Name", ",", "\u0120connector", ",", "\u0120Duration", ".", "of", "Second", "s", "(", "status", "Inter", "val", ")).", "config", "ure", "(", "context", ").", "build", "(", "target", ").", "set", "Initial", "Mode", "(", "Mode", ".", "PASS", "IVE", ").", "install", "();", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "Boot", "time", "Handler", "Provider", "\u0120handler", "\u0120:", "\u0120Service", "Loader", ".", "load", "(", "Boot", "time", "Handler", "Provider", ".", "class", ",", "\u0120Boot", "time", "Handler", "Provider", ".", "class", ".", "get", "Class", "Loader", "()", "))", "\u0120{", "\u0120handler", ".", "per", "form", "Boot", "time", "(", "context", ",", "\u0120adapter", "Names", ",", "\u0120enabled", "Met", "rics", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Rather", "\u0120than", "\u0120iter", "ate", "\u0120over", "\u0120the", "\u0120whole", "\u0120model", "\u0120twice", ",", "\u0120just", "\u0120use", "\u0120the", "\u0120Resource", "\u0120interface", "\u0120to", "\u0120n", "ag", "iv", "ate", "\u0120through", "\u0120child", "\u0120resources", "\u0120once", "."]}
{"function": "public void onHelpClick() { UriUtil.visitInExternalBrowser(getContext(), Uri.parse(requireContext().getString(R.string.android_app_edit_help_url))); }", "text": "Hint: FeedbackUtil.java contains numerous convenience functions for visiting specific external pages, e.g. the FAQ page, the privacy policy, etc. We can simply add another function there that goes to this page.", "function_tokens": ["public", "\u0120void", "\u0120on", "Help", "Click", "()", "\u0120{", "\u0120Uri", "Ut", "il", ".", "vis", "it", "In", "External", "Browser", "(", "get", "Context", "(),", "\u0120Uri", ".", "parse", "(", "require", "Context", "().", "get", "String", "(", "R", ".", "string", ".", "android", "_", "app", "_", "edit", "_", "help", "_", "url", "))", ");", "\u0120}"], "docstring_tokens": ["H", "int", ":", "\u0120Feedback", "Ut", "il", ".", "java", "\u0120contains", "\u0120numerous", "\u0120convenience", "\u0120functions", "\u0120for", "\u0120visiting", "\u0120specific", "\u0120external", "\u0120pages", ",", "\u0120e", ".", "g", ".", "\u0120the", "\u0120FAQ", "\u0120page", ",", "\u0120the", "\u0120privacy", "\u0120policy", ",", "\u0120etc", ".", "\u0120We", "\u0120can", "\u0120simply", "\u0120add", "\u0120another", "\u0120function", "\u0120there", "\u0120that", "\u0120goes", "\u0120to", "\u0120this", "\u0120page", "."]}
{"function": "public static Block read(final int major, InputStream inputStream) { final boolean v3OrHigher = major >= CramVersions.CRAM_v3.major; if (v3OrHigher) { inputStream = new CRC32InputStream(inputStream); } try { final BlockCompressionMethod method = BlockCompressionMethod.byId(inputStream.read()); final BlockContentType type = BlockContentType.byId(inputStream.read()); final int contentId = ITF8.readUnsignedITF8(inputStream); final int compressedSize = ITF8.readUnsignedITF8(inputStream); final int rawSize = ITF8.readUnsignedITF8(inputStream); final byte[] compressedContent = new byte[compressedSize]; InputStreamUtils.readFully(inputStream, compressedContent, 0, compressedSize); if (v3OrHigher) { final int actualChecksum = ((CRC32InputStream) inputStream).getCRC32(); final int checksum = CramInt.readInt32(inputStream); if (checksum != actualChecksum) { throw new RuntimeException(String.format(\"Block CRC32 mismatch: %04x vs %04x\", checksum, actualChecksum)); } } final byte[] uncompressedContent = ExternalCompression.uncompress(method, compressedContent); if (uncompressedContent.length != rawSize) { throw new CRAMException(String.format(\"Block uncompressed size did not match expected size: %04x vs %04x\", rawSize, uncompressedContent.length)); } switch (type) { case FILE_HEADER: return new FileHeaderBlock(method, compressedContent); case COMPRESSION_HEADER: return new CompressionHeaderBlock(method, compressedContent); case MAPPED_SLICE: return new SliceHeaderBlock(method, compressedContent); case EXTERNAL: return new ExternalDataBlock(method, compressedContent, contentId); case CORE: return new CoreDataBlock(method, compressedContent); default: throw new CRAMException(\"Unknown BlockContentType \" + type.name()); } } catch (final IOException e) { throw new RuntimeIOException(e); } }", "text": "The validation seems like a good idea, but it does seem like it would be expensive to do speculatively. Maybe we should do it lazily on \"un-compression\" instead. We'd have to retain the original size from the stream, but thats cheap.", "function_tokens": ["public", "\u0120static", "\u0120Block", "\u0120read", "(", "final", "\u0120int", "\u0120major", ",", "\u0120Input", "Stream", "\u0120input", "Stream", ")", "\u0120{", "\u0120final", "\u0120boolean", "\u0120v", "3", "Or", "Higher", "\u0120=", "\u0120major", "\u0120>=", "\u0120C", "ram", "Versions", ".", "CR", "AM", "_", "v", "3", ".", "major", ";", "\u0120if", "\u0120(", "v", "3", "Or", "Higher", ")", "\u0120{", "\u0120input", "Stream", "\u0120=", "\u0120new", "\u0120CRC", "32", "Input", "Stream", "(", "input", "Stream", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120final", "\u0120Block", "Comp", "ression", "Method", "\u0120method", "\u0120=", "\u0120Block", "Comp", "ression", "Method", ".", "by", "Id", "(", "input", "Stream", ".", "read", "());", "\u0120final", "\u0120Block", "Content", "Type", "\u0120type", "\u0120=", "\u0120Block", "Content", "Type", ".", "by", "Id", "(", "input", "Stream", ".", "read", "());", "\u0120final", "\u0120int", "\u0120content", "Id", "\u0120=", "\u0120IT", "F", "8", ".", "read", "Un", "signed", "IT", "F", "8", "(", "input", "Stream", ");", "\u0120final", "\u0120int", "\u0120compressed", "Size", "\u0120=", "\u0120IT", "F", "8", ".", "read", "Un", "signed", "IT", "F", "8", "(", "input", "Stream", ");", "\u0120final", "\u0120int", "\u0120raw", "Size", "\u0120=", "\u0120IT", "F", "8", ".", "read", "Un", "signed", "IT", "F", "8", "(", "input", "Stream", ");", "\u0120final", "\u0120byte", "[]", "\u0120compressed", "Content", "\u0120=", "\u0120new", "\u0120byte", "[", "comp", "ressed", "Size", "];", "\u0120Input", "Stream", "Ut", "ils", ".", "read", "F", "ully", "(", "input", "Stream", ",", "\u0120compressed", "Content", ",", "\u01200", ",", "\u0120compressed", "Size", ");", "\u0120if", "\u0120(", "v", "3", "Or", "Higher", ")", "\u0120{", "\u0120final", "\u0120int", "\u0120actual", "Che", "cks", "um", "\u0120=", "\u0120((", "C", "RC", "32", "Input", "Stream", ")", "\u0120input", "Stream", ").", "get", "C", "RC", "32", "();", "\u0120final", "\u0120int", "\u0120checks", "um", "\u0120=", "\u0120C", "ram", "Int", ".", "read", "Int", "32", "(", "input", "Stream", ");", "\u0120if", "\u0120(", "checks", "um", "\u0120!=", "\u0120actual", "Che", "cks", "um", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "String", ".", "format", "(\"", "Block", "\u0120CRC", "32", "\u0120mismatch", ":", "\u0120%", "04", "x", "\u0120vs", "\u0120%", "04", "x", "\",", "\u0120checks", "um", ",", "\u0120actual", "Che", "cks", "um", "));", "\u0120}", "\u0120}", "\u0120final", "\u0120byte", "[]", "\u0120uncomp", "ressed", "Content", "\u0120=", "\u0120External", "Comp", "ression", ".", "un", "comp", "ress", "(", "method", ",", "\u0120compressed", "Content", ");", "\u0120if", "\u0120(", "un", "comp", "ressed", "Content", ".", "length", "\u0120!=", "\u0120raw", "Size", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120CR", "AM", "Exception", "(", "String", ".", "format", "(\"", "Block", "\u0120uncomp", "ressed", "\u0120size", "\u0120did", "\u0120not", "\u0120match", "\u0120expected", "\u0120size", ":", "\u0120%", "04", "x", "\u0120vs", "\u0120%", "04", "x", "\",", "\u0120raw", "Size", ",", "\u0120uncomp", "ressed", "Content", ".", "length", "));", "\u0120}", "\u0120switch", "\u0120(", "type", ")", "\u0120{", "\u0120case", "\u0120FILE", "_", "HEAD", "ER", ":", "\u0120return", "\u0120new", "\u0120File", "Header", "Block", "(", "method", ",", "\u0120compressed", "Content", ");", "\u0120case", "\u0120COM", "PRESS", "ION", "_", "HEAD", "ER", ":", "\u0120return", "\u0120new", "\u0120Comp", "ression", "Header", "Block", "(", "method", ",", "\u0120compressed", "Content", ");", "\u0120case", "\u0120M", "APP", "ED", "_", "SL", "ICE", ":", "\u0120return", "\u0120new", "\u0120Sl", "ice", "Header", "Block", "(", "method", ",", "\u0120compressed", "Content", ");", "\u0120case", "\u0120EX", "TERN", "AL", ":", "\u0120return", "\u0120new", "\u0120External", "Data", "Block", "(", "method", ",", "\u0120compressed", "Content", ",", "\u0120content", "Id", ");", "\u0120case", "\u0120C", "ORE", ":", "\u0120return", "\u0120new", "\u0120Core", "Data", "Block", "(", "method", ",", "\u0120compressed", "Content", ");", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120CR", "AM", "Exception", "(\"", "Unknown", "\u0120Block", "Content", "Type", "\u0120\"", "\u0120+", "\u0120type", ".", "name", "());", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "IO", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["The", "\u0120validation", "\u0120seems", "\u0120like", "\u0120a", "\u0120good", "\u0120idea", ",", "\u0120but", "\u0120it", "\u0120does", "\u0120seem", "\u0120like", "\u0120it", "\u0120would", "\u0120be", "\u0120expensive", "\u0120to", "\u0120do", "\u0120spec", "ul", "atively", ".", "\u0120Maybe", "\u0120we", "\u0120should", "\u0120do", "\u0120it", "\u0120laz", "ily", "\u0120on", "\u0120\"", "un", "-", "comp", "ression", "\"", "\u0120instead", ".", "\u0120We", "'d", "\u0120have", "\u0120to", "\u0120retain", "\u0120the", "\u0120original", "\u0120size", "\u0120from", "\u0120the", "\u0120stream", ",", "\u0120but", "\u0120thats", "\u0120cheap", "."]}
{"function": "protected boolean validateSourceDomainsSpaceRequirements() { Map<Guid, List<DiskImage>> storageDomainsActiveImagesMap = new HashMap<>(); for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) { DiskImage diskImage = getDiskImageByImageId(parameters.getImageId()); if (diskImage.getActive()) { diskImage.getSnapshots().add(diskImage); MultiValueMapUtils.addToMap(parameters.getSourceStorageDomainId(), diskImage, storageDomainsActiveImagesMap); } } for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsActiveImagesMap.entrySet()) { Guid sourceDomainId = entry.getKey(); List<DiskImage> disksList = entry.getValue(); Guid storagePoolId = disksList.get(0).getStoragePoolId(); StorageDomain sourceDomain = getStorageDomainById(sourceDomainId, storagePoolId); if (!doesStorageDomainHasSpaceForRequest(sourceDomain, disksList)) { return false; } } return true; }", "text": "Maybe I'm being daft, but where are the CDA message being added?", "function_tokens": ["protected", "\u0120boolean", "\u0120validate", "Source", "Dom", "ains", "Space", "Requirements", "()", "\u0120{", "\u0120Map", "<", "Gu", "id", ",", "\u0120List", "<", "Disk", "Image", ">>", "\u0120storage", "Dom", "ains", "Active", "Images", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120for", "\u0120(", "Live", "M", "igrate", "Disk", "Parameters", "\u0120parameters", "\u0120:", "\u0120get", "Parameters", "().", "get", "Parameters", "List", "())", "\u0120{", "\u0120Disk", "Image", "\u0120disk", "Image", "\u0120=", "\u0120get", "Disk", "Image", "By", "Image", "Id", "(", "param", "eters", ".", "get", "Image", "Id", "());", "\u0120if", "\u0120(", "disk", "Image", ".", "get", "Active", "())", "\u0120{", "\u0120disk", "Image", ".", "get", "Snap", "shots", "().", "add", "(", "disk", "Image", ");", "\u0120Multi", "Value", "Map", "Ut", "ils", ".", "add", "To", "Map", "(", "param", "eters", ".", "get", "Source", "Storage", "Domain", "Id", "(),", "\u0120disk", "Image", ",", "\u0120storage", "Dom", "ains", "Active", "Images", "Map", ");", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "Gu", "id", ",", "\u0120List", "<", "Disk", "Image", ">>", "\u0120entry", "\u0120:", "\u0120storage", "Dom", "ains", "Active", "Images", "Map", ".", "entry", "Set", "())", "\u0120{", "\u0120Guid", "\u0120source", "Domain", "Id", "\u0120=", "\u0120entry", ".", "get", "Key", "();", "\u0120List", "<", "Disk", "Image", ">", "\u0120disks", "List", "\u0120=", "\u0120entry", ".", "get", "Value", "();", "\u0120Guid", "\u0120storage", "Pool", "Id", "\u0120=", "\u0120disks", "List", ".", "get", "(", "0", ").", "get", "Storage", "Pool", "Id", "();", "\u0120Storage", "Domain", "\u0120source", "Domain", "\u0120=", "\u0120get", "Storage", "Domain", "ById", "(", "source", "Domain", "Id", ",", "\u0120storage", "Pool", "Id", ");", "\u0120if", "\u0120(!", "does", "Storage", "Domain", "Has", "Space", "For", "Request", "(", "source", "Domain", ",", "\u0120disks", "List", "))", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["Maybe", "\u0120I", "'m", "\u0120being", "\u0120da", "ft", ",", "\u0120but", "\u0120where", "\u0120are", "\u0120the", "\u0120C", "DA", "\u0120message", "\u0120being", "\u0120added", "?"]}
{"function": "int binarySearch(K key) { int res = map.getKeyType().binarySearch(key, keys, getKeyCount(), cachedCompare); cachedCompare = (res < 0 ? -res : res) - 1; return res; }", "text": "Both old an new logic expect cachedCompare to be within the range [1, size] for cached path. The previous logic generated the cachedCompare like Java cachedCompare = res < 0 ? ~res : res + 1;  Here the Java cachedCompare = res < 0 ? ~res : res - 1;  is used. When entry isn't found ~res produces values within the range [0, size], this range is wider than the expected range, so the fallback to default may be unexpectedly used by both old and new code. When an entry is found, old res + 1 produced values within the range [1, size], it was correct. This range is expected and cachedCompare - 1 is actually used, so res + 1 - 1 = res (previous entry) was used as the starting point. When an entry is found, new res - 1 produces the values within the range [-1, size - 2], it looks like off-by-two error. So one of two paths was buggy and now both paths are buggy (suboptimal). Maybe I'm missing something, please re-check. (~something == -something - 1)", "function_tokens": ["int", "\u0120binary", "Search", "(", "K", "\u0120key", ")", "\u0120{", "\u0120int", "\u0120res", "\u0120=", "\u0120map", ".", "get", "Key", "Type", "().", "binary", "Search", "(", "key", ",", "\u0120keys", ",", "\u0120get", "Key", "Count", "(),", "\u0120cached", "Compare", ");", "\u0120cached", "Compare", "\u0120=", "\u0120(", "res", "\u0120<", "\u01200", "\u0120?", "\u0120-", "res", "\u0120:", "\u0120res", ")", "\u0120-", "\u01201", ";", "\u0120return", "\u0120res", ";", "\u0120}"], "docstring_tokens": ["Both", "\u0120old", "\u0120an", "\u0120new", "\u0120logic", "\u0120expect", "\u0120cached", "Compare", "\u0120to", "\u0120be", "\u0120within", "\u0120the", "\u0120range", "\u0120[", "1", ",", "\u0120size", "]", "\u0120for", "\u0120cached", "\u0120path", ".", "\u0120The", "\u0120previous", "\u0120logic", "\u0120generated", "\u0120the", "\u0120cached", "Compare", "\u0120like", "\u0120Java", "\u0120cached", "Compare", "\u0120=", "\u0120res", "\u0120<", "\u01200", "\u0120?", "\u0120~", "res", "\u0120:", "\u0120res", "\u0120+", "\u01201", ";", "\u0120", "\u0120Here", "\u0120the", "\u0120Java", "\u0120cached", "Compare", "\u0120=", "\u0120res", "\u0120<", "\u01200", "\u0120?", "\u0120~", "res", "\u0120:", "\u0120res", "\u0120-", "\u01201", ";", "\u0120", "\u0120is", "\u0120used", ".", "\u0120When", "\u0120entry", "\u0120isn", "'t", "\u0120found", "\u0120~", "res", "\u0120produces", "\u0120values", "\u0120within", "\u0120the", "\u0120range", "\u0120[", "0", ",", "\u0120size", "],", "\u0120this", "\u0120range", "\u0120is", "\u0120wider", "\u0120than", "\u0120the", "\u0120expected", "\u0120range", ",", "\u0120so", "\u0120the", "\u0120fall", "back", "\u0120to", "\u0120default", "\u0120may", "\u0120be", "\u0120unexpectedly", "\u0120used", "\u0120by", "\u0120both", "\u0120old", "\u0120and", "\u0120new", "\u0120code", ".", "\u0120When", "\u0120an", "\u0120entry", "\u0120is", "\u0120found", ",", "\u0120old", "\u0120res", "\u0120+", "\u01201", "\u0120produced", "\u0120values", "\u0120within", "\u0120the", "\u0120range", "\u0120[", "1", ",", "\u0120size", "],", "\u0120it", "\u0120was", "\u0120correct", ".", "\u0120This", "\u0120range", "\u0120is", "\u0120expected", "\u0120and", "\u0120cached", "Compare", "\u0120-", "\u01201", "\u0120is", "\u0120actually", "\u0120used", ",", "\u0120so", "\u0120res", "\u0120+", "\u01201", "\u0120-", "\u01201", "\u0120=", "\u0120res", "\u0120(", "pre", "vious", "\u0120entry", ")", "\u0120was", "\u0120used", "\u0120as", "\u0120the", "\u0120starting", "\u0120point", ".", "\u0120When", "\u0120an", "\u0120entry", "\u0120is", "\u0120found", ",", "\u0120new", "\u0120res", "\u0120-", "\u01201", "\u0120produces", "\u0120the", "\u0120values", "\u0120within", "\u0120the", "\u0120range", "\u0120[-", "1", ",", "\u0120size", "\u0120-", "\u01202", "],", "\u0120it", "\u0120looks", "\u0120like", "\u0120off", "-", "by", "-", "two", "\u0120error", ".", "\u0120So", "\u0120one", "\u0120of", "\u0120two", "\u0120paths", "\u0120was", "\u0120buggy", "\u0120and", "\u0120now", "\u0120both", "\u0120paths", "\u0120are", "\u0120buggy", "\u0120(", "sub", "opt", "imal", ").", "\u0120Maybe", "\u0120I", "'m", "\u0120missing", "\u0120something", ",", "\u0120please", "\u0120re", "-", "check", ".", "\u0120(~", "something", "\u0120==", "\u0120-", "something", "\u0120-", "\u01201", ")"]}
{"function": "public FluidStack drain(ForgeDirection from, FluidStack resource, boolean doDrain) { if (resource != null) { Fluid f = resource.getFluid(); if (f != null) { Fluid fluid = tank.getFluidType(); if (fluid != null && f.getID() == fluid.getID()) return tank.drain(resource.amount, doDrain); } } return null; }", "text": "wouldn't it be easier if you do this in the tank? also you can just return null here as nobody uses this as far as i know", "function_tokens": ["public", "\u0120Fl", "uid", "Stack", "\u0120drain", "(", "Forge", "D", "irection", "\u0120from", ",", "\u0120Fl", "uid", "Stack", "\u0120resource", ",", "\u0120boolean", "\u0120do", "D", "rain", ")", "\u0120{", "\u0120if", "\u0120(", "resource", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Fl", "uid", "\u0120f", "\u0120=", "\u0120resource", ".", "get", "F", "lu", "id", "();", "\u0120if", "\u0120(", "f", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Fl", "uid", "\u0120fluid", "\u0120=", "\u0120tank", ".", "get", "F", "lu", "id", "Type", "();", "\u0120if", "\u0120(", "flu", "id", "\u0120!=", "\u0120null", "\u0120&&", "\u0120f", ".", "get", "ID", "()", "\u0120==", "\u0120fluid", ".", "get", "ID", "())", "\u0120return", "\u0120tank", ".", "d", "rain", "(", "resource", ".", "amount", ",", "\u0120do", "D", "rain", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["would", "n", "'t", "\u0120it", "\u0120be", "\u0120easier", "\u0120if", "\u0120you", "\u0120do", "\u0120this", "\u0120in", "\u0120the", "\u0120tank", "?", "\u0120also", "\u0120you", "\u0120can", "\u0120just", "\u0120return", "\u0120null", "\u0120here", "\u0120as", "\u0120nobody", "\u0120uses", "\u0120this", "\u0120as", "\u0120far", "\u0120as", "\u0120i", "\u0120know"]}
{"function": "public static <K, V> List<ConsumerRecord<K, V>> waitUntilMinRecordsReceived(final Properties consumerConfig, final String topic, final int expectedNumRecords, final long waitTime) throws InterruptedException { final List<ConsumerRecord<K, V>> accumData = new ArrayList<>(); final String reason = String.format(\"Did not receive all %d records from topic %s within %d ms\", expectedNumRecords, topic, waitTime); try (final Consumer<K, V> consumer = createConsumer(consumerConfig)) { TestUtils.retryOnExceptionWithTimeout(waitTime, () -> { final List<ConsumerRecord<K, V>> readData = readRecords(topic, consumer, waitTime, expectedNumRecords); accumData.addAll(readData); assertThat(reason, accumData.size(), is(greaterThanOrEqualTo(expectedNumRecords))); }); } return accumData; }", "text": "nit: add static import? (similar elsewhere)", "function_tokens": ["public", "\u0120static", "\u0120<", "K", ",", "\u0120V", ">", "\u0120List", "<", "Consumer", "Record", "<", "K", ",", "\u0120V", ">>", "\u0120wait", "Until", "Min", "Rec", "ords", "Re", "ceived", "(", "final", "\u0120Properties", "\u0120consumer", "Config", ",", "\u0120final", "\u0120String", "\u0120topic", ",", "\u0120final", "\u0120int", "\u0120expected", "Num", "Rec", "ords", ",", "\u0120final", "\u0120long", "\u0120wait", "Time", ")", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120final", "\u0120List", "<", "Consumer", "Record", "<", "K", ",", "\u0120V", ">>", "\u0120accum", "Data", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120final", "\u0120String", "\u0120reason", "\u0120=", "\u0120String", ".", "format", "(\"", "Did", "\u0120not", "\u0120receive", "\u0120all", "\u0120%", "d", "\u0120records", "\u0120from", "\u0120topic", "\u0120%", "s", "\u0120within", "\u0120%", "d", "\u0120ms", "\",", "\u0120expected", "Num", "Rec", "ords", ",", "\u0120topic", ",", "\u0120wait", "Time", ");", "\u0120try", "\u0120(", "final", "\u0120Consumer", "<", "K", ",", "\u0120V", ">", "\u0120consumer", "\u0120=", "\u0120create", "Consumer", "(", "consumer", "Config", "))", "\u0120{", "\u0120Test", "Ut", "ils", ".", "ret", "ry", "On", "Exception", "With", "Timeout", "(", "wait", "Time", ",", "\u0120()", "\u0120->", "\u0120{", "\u0120final", "\u0120List", "<", "Consumer", "Record", "<", "K", ",", "\u0120V", ">>", "\u0120read", "Data", "\u0120=", "\u0120read", "Rec", "ords", "(", "topic", ",", "\u0120consumer", ",", "\u0120wait", "Time", ",", "\u0120expected", "Num", "Rec", "ords", ");", "\u0120accum", "Data", ".", "add", "All", "(", "read", "Data", ");", "\u0120assert", "That", "(", "reason", ",", "\u0120accum", "Data", ".", "size", "(),", "\u0120is", "(", "great", "er", "Th", "an", "Or", "E", "qual", "To", "(", "expected", "Num", "Rec", "ords", "))", ");", "\u0120});", "\u0120}", "\u0120return", "\u0120accum", "Data", ";", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120add", "\u0120static", "\u0120import", "?", "\u0120(", "similar", "\u0120elsewhere", ")"]}
{"function": "public void setImage (Image image) { checkWidget (); if ((style & SWT.SEPARATOR) != 0) return; if (image != null && image.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT); this.image = image; updateStyleBits(false); OS.InvalidateRect (handle, null, true); }", "text": "With the proposed change: updateStyleBits(image == null)", "function_tokens": ["public", "\u0120void", "\u0120set", "Image", "\u0120(", "Image", "\u0120image", ")", "\u0120{", "\u0120check", "Widget", "\u0120();", "\u0120if", "\u0120((", "style", "\u0120&", "\u0120SW", "T", ".", "SE", "PAR", "ATOR", ")", "\u0120!=", "\u01200", ")", "\u0120return", ";", "\u0120if", "\u0120(", "image", "\u0120!=", "\u0120null", "\u0120&&", "\u0120image", ".", "is", "Dis", "posed", "())", "\u0120error", "(", "SW", "T", ".", "ERROR", "_", "IN", "VAL", "ID", "_", "AR", "G", "UM", "ENT", ");", "\u0120this", ".", "image", "\u0120=", "\u0120image", ";", "\u0120update", "Style", "B", "its", "(", "false", ");", "\u0120OS", ".", "Invalid", "ate", "Rect", "\u0120(", "handle", ",", "\u0120null", ",", "\u0120true", ");", "\u0120}"], "docstring_tokens": ["With", "\u0120the", "\u0120proposed", "\u0120change", ":", "\u0120update", "Style", "B", "its", "(", "image", "\u0120==", "\u0120null", ")"]}
{"function": "public static void setupEnvironment() throws Exception { IWorkspace workspace = ResourcesPlugin.getWorkspace(); IWorkspaceDescription description = workspace.getDescription(); description.setAutoBuilding(false); workspace.setDescription(description); GitImportRepoWizard importWizard = new GitImportRepoWizard(); importWizard.openWizard(); String repoName = \"egit\"; String repoUrl = \"git://egit.eclipse.org/egit.git\"; if (!importWizard.containsRepo(repoName)) { addRepository(importWizard, repoUrl); } importWizard.selectAndCloneRepository(repoName); importWizard.waitForCreate(); waitForWorkspaceRefresh(); }", "text": "style nit: no braces around single line", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120setup", "Environment", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120I", "Works", "pace", "\u0120workspace", "\u0120=", "\u0120Resources", "Plugin", ".", "get", "Works", "pace", "();", "\u0120I", "Works", "pace", "Description", "\u0120description", "\u0120=", "\u0120workspace", ".", "get", "Description", "();", "\u0120description", ".", "set", "Auto", "Building", "(", "false", ");", "\u0120workspace", ".", "set", "Description", "(", "description", ");", "\u0120Git", "Import", "Rep", "o", "W", "izard", "\u0120import", "W", "izard", "\u0120=", "\u0120new", "\u0120Git", "Import", "Rep", "o", "W", "izard", "();", "\u0120import", "W", "izard", ".", "open", "W", "izard", "();", "\u0120String", "\u0120repo", "Name", "\u0120=", "\u0120\"", "eg", "it", "\";", "\u0120String", "\u0120repo", "Url", "\u0120=", "\u0120\"", "git", "://", "eg", "it", ".", "e", "clipse", ".", "org", "/", "eg", "it", ".", "git", "\";", "\u0120if", "\u0120(!", "import", "W", "izard", ".", "cont", "ains", "Rep", "o", "(", "re", "po", "Name", "))", "\u0120{", "\u0120add", "Rep", "ository", "(", "import", "W", "izard", ",", "\u0120repo", "Url", ");", "\u0120}", "\u0120import", "W", "izard", ".", "select", "And", "Cl", "one", "Rep", "ository", "(", "re", "po", "Name", ");", "\u0120import", "W", "izard", ".", "wait", "For", "Create", "();", "\u0120wait", "For", "Works", "pace", "Ref", "resh", "();", "\u0120}"], "docstring_tokens": ["style", "\u0120nit", ":", "\u0120no", "\u0120braces", "\u0120around", "\u0120single", "\u0120line"]}
{"function": "protected void configure() { bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName); bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()) .toInstance(new JavaScriptPlugin(fileName)); }", "text": "DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(...)", "function_tokens": ["protected", "\u0120void", "\u0120configure", "()", "\u0120{", "\u0120bind", "(", "String", ".", "class", ").", "annot", "ated", "With", "(", "Plugin", "Name", ".", "class", ").", "to", "Instance", "(", "plugin", "Name", ");", "\u0120bind", "(", "Web", "U", "i", "Plugin", ".", "class", ").", "annot", "ated", "With", "(", "Unique", "An", "notations", ".", "create", "())", "\u0120.", "to", "Instance", "(", "new", "\u0120JavaScript", "Plugin", "(", "file", "Name", "));", "\u0120}"], "docstring_tokens": ["Dynamic", "Set", ".", "bind", "(", "b", "inder", "(),", "\u0120Web", "U", "i", "Plugin", ".", "class", ").", "to", "Instance", "(", "...)"]}
{"function": "public List<QuickFilter> getQuickFilters() { return this.quickFilters; }", "text": "return quickFilters", "function_tokens": ["public", "\u0120List", "<", "Quick", "Filter", ">", "\u0120get", "Quick", "Fil", "ters", "()", "\u0120{", "\u0120return", "\u0120this", ".", "quick", "Fil", "ters", ";", "\u0120}"], "docstring_tokens": ["return", "\u0120quick", "Fil", "ters"]}
{"function": "public void startContainerWithVolumes() throws DockerException { Volume volume1 = new Volume(\"/opt/webapp1\"); Volume volume2 = new Volume(\"/opt/webapp2\"); CreateContainerResponse container = dockerClient.createContainerCmd(\"busybox\").withVolumes(volume1, volume2) .withCmd(\"true\").withBinds(new Bind(\"/src/webapp1\", volume1, ro), new Bind(\"/src/webapp2\", volume2)) .exec(); LOG.info(\"Created container {}\", container.toString()); assertThat(container.getId(), not(isEmptyString())); InspectContainerResponse inspectContainerResponse = dockerClient.inspectContainerCmd(container.getId()).exec(); assertThat(inspectContainerResponse.getConfig().getVolumes().keySet(), contains(\"/opt/webapp1\", \"/opt/webapp2\")); dockerClient.startContainerCmd(container.getId()).exec(); dockerClient.waitContainerCmd(container.getId()).exec(new WaitContainerResultCallback()).awaitStatusCode(); inspectContainerResponse = dockerClient.inspectContainerCmd(container.getId()).exec(); assertContainerHasVolumes(inspectContainerResponse, volume1, volume2); assertEquals(inspectContainerResponse.getMounts().size(), 2); assertEquals(inspectContainerResponse.getMounts().get(0).getDestination(), volume1); assertEquals(inspectContainerResponse.getMounts().get(0).getMode(), \"ro\"); assertEquals(inspectContainerResponse.getMounts().get(0).getRW(), Boolean.FALSE); assertEquals(inspectContainerResponse.getMounts().get(1).getDestination(), volume2); assertEquals(inspectContainerResponse.getMounts().get(1).getMode(), \"rw\"); assertEquals(inspectContainerResponse.getMounts().get(1).getRW(), Boolean.TRUE); }", "text": "you've change order of expected and actual (error string will be wrong in case of fail) to not repeat this mistake simply use assertThat(actual, matcherForIt()) - thats more friendly to any reviewer or maintaineer", "function_tokens": ["public", "\u0120void", "\u0120start", "Container", "With", "Vol", "umes", "()", "\u0120throws", "\u0120Docker", "Exception", "\u0120{", "\u0120Volume", "\u0120volume", "1", "\u0120=", "\u0120new", "\u0120Volume", "(\"", "/", "opt", "/", "web", "app", "1", "\");", "\u0120Volume", "\u0120volume", "2", "\u0120=", "\u0120new", "\u0120Volume", "(\"", "/", "opt", "/", "web", "app", "2", "\");", "\u0120Create", "Container", "Response", "\u0120container", "\u0120=", "\u0120docker", "Client", ".", "create", "Container", "Cmd", "(\"", "bus", "y", "box", "\").", "with", "Vol", "umes", "(", "volume", "1", ",", "\u0120volume", "2", ")", "\u0120.", "with", "Cmd", "(\"", "true", "\").", "with", "Bind", "s", "(", "new", "\u0120Bind", "(\"", "/", "src", "/", "web", "app", "1", "\",", "\u0120volume", "1", ",", "\u0120ro", "),", "\u0120new", "\u0120Bind", "(\"", "/", "src", "/", "web", "app", "2", "\",", "\u0120volume", "2", "))", "\u0120.", "exec", "();", "\u0120LOG", ".", "info", "(\"", "Created", "\u0120container", "\u0120{}", "\",", "\u0120container", ".", "to", "String", "());", "\u0120assert", "That", "(", "container", ".", "get", "Id", "(),", "\u0120not", "(", "is", "Empty", "String", "()", "));", "\u0120Inspect", "Container", "Response", "\u0120inspect", "Container", "Response", "\u0120=", "\u0120docker", "Client", ".", "ins", "pect", "Container", "Cmd", "(", "container", ".", "get", "Id", "()", ").", "exec", "();", "\u0120assert", "That", "(", "ins", "pect", "Container", "Response", ".", "get", "Config", "().", "get", "Vol", "umes", "().", "key", "Set", "(),", "\u0120contains", "(\"", "/", "opt", "/", "web", "app", "1", "\",", "\u0120\"/", "opt", "/", "web", "app", "2", "\")", ");", "\u0120docker", "Client", ".", "start", "Container", "Cmd", "(", "container", ".", "get", "Id", "()", ").", "exec", "();", "\u0120docker", "Client", ".", "wait", "Container", "Cmd", "(", "container", ".", "get", "Id", "()", ").", "exec", "(", "new", "\u0120Wait", "Container", "Result", "Callback", "()", ").", "aw", "ait", "Status", "Code", "();", "\u0120inspect", "Container", "Response", "\u0120=", "\u0120docker", "Client", ".", "ins", "pect", "Container", "Cmd", "(", "container", ".", "get", "Id", "()", ").", "exec", "();", "\u0120assert", "Container", "Has", "Vol", "umes", "(", "ins", "pect", "Container", "Response", ",", "\u0120volume", "1", ",", "\u0120volume", "2", ");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "size", "(),", "\u01202", ");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "0", ").", "get", "Dest", "ination", "(),", "\u0120volume", "1", ");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "0", ").", "get", "Mode", "(),", "\u0120\"", "ro", "\");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "0", ").", "get", "RW", "(),", "\u0120Boolean", ".", "F", "ALSE", ");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "1", ").", "get", "Dest", "ination", "(),", "\u0120volume", "2", ");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "1", ").", "get", "Mode", "(),", "\u0120\"", "rw", "\");", "\u0120assert", "Equ", "als", "(", "ins", "pect", "Container", "Response", ".", "get", "Mount", "s", "().", "get", "(", "1", ").", "get", "RW", "(),", "\u0120Boolean", ".", "TR", "UE", ");", "\u0120}"], "docstring_tokens": ["you", "'ve", "\u0120change", "\u0120order", "\u0120of", "\u0120expected", "\u0120and", "\u0120actual", "\u0120(", "error", "\u0120string", "\u0120will", "\u0120be", "\u0120wrong", "\u0120in", "\u0120case", "\u0120of", "\u0120fail", ")", "\u0120to", "\u0120not", "\u0120repeat", "\u0120this", "\u0120mistake", "\u0120simply", "\u0120use", "\u0120assert", "That", "(", "actual", ",", "\u0120mat", "cher", "For", "It", "())", "\u0120-", "\u0120thats", "\u0120more", "\u0120friendly", "\u0120to", "\u0120any", "\u0120reviewer", "\u0120or", "\u0120maintain", "eer"]}
{"function": "public ListenableFuture<?> isBlocked() { if (!finishing || !joinPagesNotNeeded.isPresent()) { return NOT_BLOCKED; } return joinPagesNotNeeded.get(); }", "text": "isn't finishing tied to joinPagesNotNeeded not being empty? Maybe just get rid of it and then then becomes return joinPagesNotNeeded.orElse(NOT_BLOCKED)", "function_tokens": ["public", "\u0120Listen", "able", "Future", "<?", ">", "\u0120is", "Bl", "ocked", "()", "\u0120{", "\u0120if", "\u0120(!", "fin", "ishing", "\u0120||", "\u0120!", "join", "Pages", "Not", "Need", "ed", ".", "is", "Present", "())", "\u0120{", "\u0120return", "\u0120NOT", "_", "BL", "OCK", "ED", ";", "\u0120}", "\u0120return", "\u0120join", "Pages", "Not", "Need", "ed", ".", "get", "();", "\u0120}"], "docstring_tokens": ["is", "n", "'t", "\u0120finishing", "\u0120tied", "\u0120to", "\u0120join", "Pages", "Not", "Need", "ed", "\u0120not", "\u0120being", "\u0120empty", "?", "\u0120Maybe", "\u0120just", "\u0120get", "\u0120rid", "\u0120of", "\u0120it", "\u0120and", "\u0120then", "\u0120then", "\u0120becomes", "\u0120return", "\u0120join", "Pages", "Not", "Need", "ed", ".", "or", "Else", "(", "NOT", "_", "BL", "OCK", "ED", ")"]}
{"function": "public ConsumerTestRuntimeEnvironment(Supplier<CuratorFramework> curatorSupplier) { this.paths = new ZookeeperPaths(\"/hermes\"); this.curatorSupplier = curatorSupplier; this.curator = curatorSupplier.get(); this.groupRepository = new ZookeeperGroupRepository(curator, objectMapper, paths); this.topicRepository = new ZookeeperTopicRepository(curator, objectMapper, paths, groupRepository); this.subscriptionRepository = new ZookeeperSubscriptionRepository(curator, objectMapper, paths, topicRepository); this.configFactory = new MutableConfigFactory().overrideProperty(CONSUMER_WORKLOAD_REBALANCE_INTERVAL, 1); this.consumersRegistry = new ConsumerNodesRegistry(curator, executorService, paths.consumersRegistryPath(), \"id\"); this.metrics = mock(HermesMetrics.class); when(metrics.timer(anyString())).thenReturn(new Timer()); try { curator.create().creatingParentsIfNeeded().forPath(\"/hermes/groups\"); consumersRegistry.start(); } catch (Exception e) { e.printStackTrace(); } }", "text": "There's a lot going on in this class, it creates subscriptions, spawns SelectiveSupervisorControllers, makes assertions. Maybe we could separate this work to different classes.", "function_tokens": ["public", "\u0120Consumer", "Test", "Runtime", "Environment", "(", "Supp", "lier", "<", "Cur", "ator", "Fram", "ework", ">", "\u0120curator", "Supp", "lier", ")", "\u0120{", "\u0120this", ".", "path", "s", "\u0120=", "\u0120new", "\u0120Zo", "oke", "eper", "Path", "s", "(\"", "/", "her", "mes", "\");", "\u0120this", ".", "cur", "ator", "Supp", "lier", "\u0120=", "\u0120curator", "Supp", "lier", ";", "\u0120this", ".", "cur", "ator", "\u0120=", "\u0120curator", "Supp", "lier", ".", "get", "();", "\u0120this", ".", "group", "Rep", "ository", "\u0120=", "\u0120new", "\u0120Zo", "oke", "eper", "Group", "Rep", "ository", "(", "cur", "ator", ",", "\u0120object", "M", "apper", ",", "\u0120paths", ");", "\u0120this", ".", "topic", "Rep", "ository", "\u0120=", "\u0120new", "\u0120Zo", "oke", "eper", "Topic", "Rep", "ository", "(", "cur", "ator", ",", "\u0120object", "M", "apper", ",", "\u0120paths", ",", "\u0120group", "Rep", "ository", ");", "\u0120this", ".", "sub", "scription", "Rep", "ository", "\u0120=", "\u0120new", "\u0120Zo", "oke", "eper", "Sub", "scription", "Rep", "ository", "(", "cur", "ator", ",", "\u0120object", "M", "apper", ",", "\u0120paths", ",", "\u0120topic", "Rep", "ository", ");", "\u0120this", ".", "config", "Factory", "\u0120=", "\u0120new", "\u0120Mut", "able", "Config", "Factory", "().", "over", "ride", "Property", "(", "CON", "S", "UM", "ER", "_", "WORK", "LOAD", "_", "RE", "B", "AL", "ANCE", "_", "INTER", "VAL", ",", "\u01201", ");", "\u0120this", ".", "cons", "umers", "Reg", "istry", "\u0120=", "\u0120new", "\u0120Consumer", "N", "odes", "Reg", "istry", "(", "cur", "ator", ",", "\u0120execut", "or", "Service", ",", "\u0120paths", ".", "cons", "umers", "Reg", "istry", "Path", "(),", "\u0120\"", "id", "\");", "\u0120this", ".", "met", "rics", "\u0120=", "\u0120mock", "(", "Her", "mes", "Met", "rics", ".", "class", ");", "\u0120when", "(", "met", "rics", ".", "timer", "(", "any", "String", "())", ").", "then", "Return", "(", "new", "\u0120Tim", "er", "());", "\u0120try", "\u0120{", "\u0120curator", ".", "create", "().", "creat", "ing", "Parents", "If", "Need", "ed", "().", "for", "Path", "(\"", "/", "her", "mes", "/", "groups", "\");", "\u0120consumers", "Reg", "istry", ".", "start", "();", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["There", "'s", "\u0120a", "\u0120lot", "\u0120going", "\u0120on", "\u0120in", "\u0120this", "\u0120class", ",", "\u0120it", "\u0120creates", "\u0120subscriptions", ",", "\u0120spawns", "\u0120Select", "ive", "Super", "visor", "Cont", "rollers", ",", "\u0120makes", "\u0120assertions", ".", "\u0120Maybe", "\u0120we", "\u0120could", "\u0120separate", "\u0120this", "\u0120work", "\u0120to", "\u0120different", "\u0120classes", "."]}
{"function": "public void testDefaults() { ConfigAssertions.assertRecordedDefaults(ConfigAssertions.recordDefaults(JsonWebTokenConfig.class) .setKey(null) .setRequiredAudience(null) .setRequiredIssuer(null)); }", "text": "Static import the assertion methods", "function_tokens": ["public", "\u0120void", "\u0120test", "Def", "aults", "()", "\u0120{", "\u0120Config", "Ass", "ert", "ions", ".", "assert", "Record", "ed", "Def", "aults", "(", "Config", "Ass", "ert", "ions", ".", "record", "Def", "aults", "(", "J", "son", "Web", "Token", "Config", ".", "class", ")", "\u0120.", "set", "Key", "(", "null", ")", "\u0120.", "set", "Required", "Aud", "ience", "(", "null", ")", "\u0120.", "set", "Required", "Iss", "uer", "(", "null", "));", "\u0120}"], "docstring_tokens": ["Static", "\u0120import", "\u0120the", "\u0120assertion", "\u0120methods"]}
{"function": "public Message[] getErrors() { Message[] messages = new Message[fErrors.size()]; int i = 0; for (String string : fErrors) { messages[i++] = new Message(string, -1); } return messages; }", "text": "rename to message", "function_tokens": ["public", "\u0120Message", "[]", "\u0120get", "Er", "rors", "()", "\u0120{", "\u0120Message", "[]", "\u0120messages", "\u0120=", "\u0120new", "\u0120Message", "[", "f", "Er", "rors", ".", "size", "()", "];", "\u0120int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120for", "\u0120(", "String", "\u0120string", "\u0120:", "\u0120f", "Er", "rors", ")", "\u0120{", "\u0120messages", "[", "i", "++", "]", "\u0120=", "\u0120new", "\u0120Message", "(", "string", ",", "\u0120-", "1", ");", "\u0120}", "\u0120return", "\u0120messages", ";", "\u0120}"], "docstring_tokens": ["ren", "ame", "\u0120to", "\u0120message"]}
{"function": "public void publishJobModelVersion(String oldVersion, String newVersion) { Stat stat = new Stat(); String currentVersion = zkClient.<String>readData(keyBuilder.getJobModelVersionPath(), stat); LOG.info(\"publishing new version: \" + newVersion + \"; oldVersion = \" + oldVersion + \"(\" + stat .getVersion() + \")\"); if (currentVersion != null && !currentVersion.equals(oldVersion)) { throw new SamzaException( \"Someone changed JobModelVersion while the leader was generating one: expected\" + oldVersion + \", got \" + currentVersion); } int dataVersion = stat.getVersion(); try { stat = zkClient.writeDataReturnStat(keyBuilder.getJobModelVersionPath(), newVersion, dataVersion); } catch (Exception e) { String msg = \"publish job model version failed for new version = \" + newVersion + \"; old version = \" + oldVersion; LOG.error(msg, e); throw new SamzaException(e); } LOG.info(\"published new version: \" + newVersion + \"; expected data version = \" + (dataVersion + 1) + \"(actual data version after update = \" + stat.getVersion() + \")\"); }", "text": "Please leave msg.", "function_tokens": ["public", "\u0120void", "\u0120publish", "Job", "Model", "Version", "(", "String", "\u0120old", "Version", ",", "\u0120String", "\u0120new", "Version", ")", "\u0120{", "\u0120Stat", "\u0120stat", "\u0120=", "\u0120new", "\u0120Stat", "();", "\u0120String", "\u0120current", "Version", "\u0120=", "\u0120z", "k", "Client", ".<", "String", ">", "read", "Data", "(", "key", "Builder", ".", "get", "Job", "Model", "Version", "Path", "(),", "\u0120stat", ");", "\u0120LOG", ".", "info", "(\"", "pub", "lishing", "\u0120new", "\u0120version", ":", "\u0120\"", "\u0120+", "\u0120new", "Version", "\u0120+", "\u0120\"", ";", "\u0120old", "Version", "\u0120=", "\u0120\"", "\u0120+", "\u0120old", "Version", "\u0120+", "\u0120\"", "(\"", "\u0120+", "\u0120stat", "\u0120.", "get", "Version", "()", "\u0120+", "\u0120\"", ")", "\");", "\u0120if", "\u0120(", "current", "Version", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "current", "Version", ".", "equ", "als", "(", "old", "Version", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Sam", "za", "Exception", "(", "\u0120\"", "Someone", "\u0120changed", "\u0120Job", "Model", "Version", "\u0120while", "\u0120the", "\u0120leader", "\u0120was", "\u0120generating", "\u0120one", ":", "\u0120expected", "\"", "\u0120+", "\u0120old", "Version", "\u0120+", "\u0120\",", "\u0120got", "\u0120\"", "\u0120+", "\u0120current", "Version", ");", "\u0120}", "\u0120int", "\u0120data", "Version", "\u0120=", "\u0120stat", ".", "get", "Version", "();", "\u0120try", "\u0120{", "\u0120stat", "\u0120=", "\u0120z", "k", "Client", ".", "write", "Data", "Return", "Stat", "(", "key", "Builder", ".", "get", "Job", "Model", "Version", "Path", "(),", "\u0120new", "Version", ",", "\u0120data", "Version", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120String", "\u0120msg", "\u0120=", "\u0120\"", "pub", "lish", "\u0120job", "\u0120model", "\u0120version", "\u0120failed", "\u0120for", "\u0120new", "\u0120version", "\u0120=", "\u0120\"", "\u0120+", "\u0120new", "Version", "\u0120+", "\u0120\"", ";", "\u0120old", "\u0120version", "\u0120=", "\u0120\"", "\u0120+", "\u0120old", "Version", ";", "\u0120LOG", ".", "error", "(", "msg", ",", "\u0120e", ");", "\u0120throw", "\u0120new", "\u0120Sam", "za", "Exception", "(", "e", ");", "\u0120}", "\u0120LOG", ".", "info", "(\"", "published", "\u0120new", "\u0120version", ":", "\u0120\"", "\u0120+", "\u0120new", "Version", "\u0120+", "\u0120\"", ";", "\u0120expected", "\u0120data", "\u0120version", "\u0120=", "\u0120\"", "\u0120+", "\u0120(", "data", "Version", "\u0120+", "\u01201", ")", "\u0120+", "\u0120\"(", "actual", "\u0120data", "\u0120version", "\u0120after", "\u0120update", "\u0120=", "\u0120\"", "\u0120+", "\u0120stat", ".", "get", "Version", "()", "\u0120+", "\u0120\"", ")", "\");", "\u0120}"], "docstring_tokens": ["Please", "\u0120leave", "\u0120msg", "."]}
{"function": "private String generateExcludes(final Iterable<String> excludes) { final StringBuilder xml = new StringBuilder(75); xml.append(\"<FindBugsFilter><Match><Or>\"); for (final String exclude : excludes) { xml.append(\"<Class name=\\\"\").append(exclude).append(\"\\\"/>\"); } xml.append(\"</Or></Match></FindBugsFilter>\"); return xml.toString(); }", "text": "yeah, this is definitely a bad idea, since exclude may be equal to, say, \"hey\" and the entire code will crash. Let's find a way to use Xembly", "function_tokens": ["private", "\u0120String", "\u0120generate", "Ex", "cludes", "(", "final", "\u0120Iter", "able", "<", "String", ">", "\u0120excludes", ")", "\u0120{", "\u0120final", "\u0120String", "Builder", "\u0120xml", "\u0120=", "\u0120new", "\u0120String", "Builder", "(", "75", ");", "\u0120xml", ".", "append", "(\"", "<", "Find", "B", "ugs", "Filter", "><", "Match", "><", "Or", ">", "\");", "\u0120for", "\u0120(", "final", "\u0120String", "\u0120exclude", "\u0120:", "\u0120excludes", ")", "\u0120{", "\u0120xml", ".", "append", "(\"", "<", "Class", "\u0120name", "=\\\"", "\").", "append", "(", "ex", "clude", ").", "append", "(\"", "\\\"", "/>", "\");", "\u0120}", "\u0120xml", ".", "append", "(\"", "</", "Or", "></", "Match", "></", "Find", "B", "ugs", "Filter", ">", "\");", "\u0120return", "\u0120xml", ".", "to", "String", "();", "\u0120}"], "docstring_tokens": ["yeah", ",", "\u0120this", "\u0120is", "\u0120definitely", "\u0120a", "\u0120bad", "\u0120idea", ",", "\u0120since", "\u0120exclude", "\u0120may", "\u0120be", "\u0120equal", "\u0120to", ",", "\u0120say", ",", "\u0120\"", "hey", "\"", "\u0120and", "\u0120the", "\u0120entire", "\u0120code", "\u0120will", "\u0120crash", ".", "\u0120Let", "'s", "\u0120find", "\u0120a", "\u0120way", "\u0120to", "\u0120use", "\u0120X", "emb", "ly"]}
{"function": "public Registration deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonNode node = p.readValueAsTree(); Registration.Builder builder = Registration.builder(); if (node.hasNonNull(\"name\")) { builder.name(node.get(\"name\").asText()); } if (node.hasNonNull(\"url\")) { String url = node.get(\"url\").asText(); builder.healthUrl(url.replaceFirst(\"/+$\", \"\") + \"/health\").managementUrl(url); } else { if (node.hasNonNull(\"healthUrl\")) { builder.healthUrl(node.get(\"healthUrl\").asText()); } if (node.hasNonNull(\"managementUrl\")) { builder.managementUrl(node.get(\"managementUrl\").asText()); } if (node.hasNonNull(\"serviceUrl\")) { builder.serviceUrl(node.get(\"serviceUrl\").asText()); } } if (node.hasNonNull(\"metadata\")) { Iterator<Map.Entry<String, JsonNode>> it = node.get(\"metadata\").fields(); while (it.hasNext()) { Map.Entry<String, JsonNode> entry = it.next(); builder.metadata(entry.getKey(), entry.getValue().asText()); } } return builder.build(); }", "text": "iirc the source is added later in the controller and not part of the request.", "function_tokens": ["public", "\u0120Registration", "\u0120des", "erial", "ize", "(", "J", "son", "Parser", "\u0120p", ",", "\u0120Des", "erial", "ization", "Context", "\u0120c", "txt", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120J", "son", "Node", "\u0120node", "\u0120=", "\u0120p", ".", "read", "Value", "As", "Tree", "();", "\u0120Registration", ".", "Builder", "\u0120builder", "\u0120=", "\u0120Registration", ".", "builder", "();", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "name", "\"))", "\u0120{", "\u0120builder", ".", "name", "(", "node", ".", "get", "(\"", "name", "\").", "as", "Text", "());", "\u0120}", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "url", "\"))", "\u0120{", "\u0120String", "\u0120url", "\u0120=", "\u0120node", ".", "get", "(\"", "url", "\").", "as", "Text", "();", "\u0120builder", ".", "health", "Url", "(", "url", ".", "replace", "First", "(\"", "/+", "$", "\",", "\u0120\"", "\")", "\u0120+", "\u0120\"/", "health", "\").", "management", "Url", "(", "url", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "health", "Url", "\"))", "\u0120{", "\u0120builder", ".", "health", "Url", "(", "node", ".", "get", "(\"", "health", "Url", "\").", "as", "Text", "());", "\u0120}", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "management", "Url", "\"))", "\u0120{", "\u0120builder", ".", "management", "Url", "(", "node", ".", "get", "(\"", "management", "Url", "\").", "as", "Text", "());", "\u0120}", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "service", "Url", "\"))", "\u0120{", "\u0120builder", ".", "service", "Url", "(", "node", ".", "get", "(\"", "service", "Url", "\").", "as", "Text", "());", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "node", ".", "has", "Non", "Null", "(\"", "metadata", "\"))", "\u0120{", "\u0120Iter", "ator", "<", "Map", ".", "Entry", "<", "String", ",", "\u0120J", "son", "Node", ">>", "\u0120it", "\u0120=", "\u0120node", ".", "get", "(\"", "metadata", "\").", "fields", "();", "\u0120while", "\u0120(", "it", ".", "has", "Next", "())", "\u0120{", "\u0120Map", ".", "Entry", "<", "String", ",", "\u0120J", "son", "Node", ">", "\u0120entry", "\u0120=", "\u0120it", ".", "next", "();", "\u0120builder", ".", "metadata", "(", "entry", ".", "get", "Key", "(),", "\u0120entry", ".", "get", "Value", "().", "as", "Text", "());", "\u0120}", "\u0120}", "\u0120return", "\u0120builder", ".", "build", "();", "\u0120}"], "docstring_tokens": ["i", "irc", "\u0120the", "\u0120source", "\u0120is", "\u0120added", "\u0120later", "\u0120in", "\u0120the", "\u0120controller", "\u0120and", "\u0120not", "\u0120part", "\u0120of", "\u0120the", "\u0120request", "."]}
{"function": "private Map<Long, Pair<String, Long>> recoverPendingLargeMessages() throws Exception { Map<Long, Pair<String, Long>> largeMessages = new HashMap<>(); List<String> filenames = largeMessagesFactory.listFiles(\"msg\"); List<Long> idList = new ArrayList<>(); for (String filename : filenames) { Long id = getLargeMessageIdFromFilename(filename); if (!largeMessagesToDelete.containsKey(id)) { idList.add(id); SequentialFile seqFile = largeMessagesFactory.createSequentialFile(filename); long size = seqFile.size(); largeMessages.put(id, new Pair<>(filename, size)); } } return largeMessages; }", "text": "you can just use a primitive long here", "function_tokens": ["private", "\u0120Map", "<", "Long", ",", "\u0120Pair", "<", "String", ",", "\u0120Long", ">>", "\u0120recover", "P", "ending", "Large", "Mess", "ages", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Map", "<", "Long", ",", "\u0120Pair", "<", "String", ",", "\u0120Long", ">>", "\u0120large", "Mess", "ages", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120List", "<", "String", ">", "\u0120fil", "en", "ames", "\u0120=", "\u0120large", "Mess", "ages", "Factory", ".", "list", "Files", "(\"", "msg", "\");", "\u0120List", "<", "Long", ">", "\u0120id", "List", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "\u0120(", "String", "\u0120filename", "\u0120:", "\u0120fil", "en", "ames", ")", "\u0120{", "\u0120Long", "\u0120id", "\u0120=", "\u0120get", "Large", "Message", "Id", "From", "Filename", "(", "filename", ");", "\u0120if", "\u0120(!", "large", "Mess", "ages", "To", "Delete", ".", "cont", "ains", "Key", "(", "id", "))", "\u0120{", "\u0120id", "List", ".", "add", "(", "id", ");", "\u0120Sequ", "ential", "File", "\u0120seq", "File", "\u0120=", "\u0120large", "Mess", "ages", "Factory", ".", "create", "Sequ", "ential", "File", "(", "filename", ");", "\u0120long", "\u0120size", "\u0120=", "\u0120seq", "File", ".", "size", "();", "\u0120large", "Mess", "ages", ".", "put", "(", "id", ",", "\u0120new", "\u0120Pair", "<", ">(", "filename", ",", "\u0120size", "));", "\u0120}", "\u0120}", "\u0120return", "\u0120large", "Mess", "ages", ";", "\u0120}"], "docstring_tokens": ["you", "\u0120can", "\u0120just", "\u0120use", "\u0120a", "\u0120primitive", "\u0120long", "\u0120here"]}
{"function": "public void setComponent(T component) { this.component = component; }", "text": "I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.", "function_tokens": ["public", "\u0120void", "\u0120set", "Component", "(", "T", "\u0120component", ")", "\u0120{", "\u0120this", ".", "component", "\u0120=", "\u0120component", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120see", "\u0120why", "\u0120you", "\u0120introduced", "\u0120mut", "ability", "\u0120here", "?", "\u0120Local", "\u0120variables", "\u0120would", "\u0120have", "\u0120worked", "\u0120just", "\u0120as", "\u0120well", ".", "\u0120If", "\u0120you", "\u0120really", "\u0120want", "\u0120that", ",", "\u0120please", "\u0120at", "\u0120least", "\u0120make", "\u0120the", "\u0120set", "ters", "\u0120package", "-", "private", "."]}
{"function": "private void activeDetailModelChanging(HasEntity<D> newValue, boolean stopRefresh) { for (HasEntity<D> oldValue : activeDetailModels) { if (oldValue != null && stopRefresh) { oldValue.setEntity(null); if (oldValue instanceof SearchableListModel) { ((SearchableListModel) oldValue).stopRefresh(); } } } if (newValue != null) { newValue.setEntity(provideDetailModelEntity(getSelectedItem())); } }", "text": "Wouldn't a top-level if (stopRefresh) guard condition be better, instead of checking it within the loop?", "function_tokens": ["private", "\u0120void", "\u0120active", "Det", "ail", "Model", "Changing", "(", "Has", "Entity", "<", "D", ">", "\u0120new", "Value", ",", "\u0120boolean", "\u0120stop", "Ref", "resh", ")", "\u0120{", "\u0120for", "\u0120(", "Has", "Entity", "<", "D", ">", "\u0120old", "Value", "\u0120:", "\u0120active", "Det", "ail", "Mod", "els", ")", "\u0120{", "\u0120if", "\u0120(", "old", "Value", "\u0120!=", "\u0120null", "\u0120&&", "\u0120stop", "Ref", "resh", ")", "\u0120{", "\u0120old", "Value", ".", "set", "Entity", "(", "null", ");", "\u0120if", "\u0120(", "old", "Value", "\u0120instance", "of", "\u0120Search", "able", "List", "Model", ")", "\u0120{", "\u0120((", "Search", "able", "List", "Model", ")", "\u0120old", "Value", ").", "stop", "Ref", "resh", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "new", "Value", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120new", "Value", ".", "set", "Entity", "(", "prov", "ide", "Det", "ail", "Model", "Entity", "(", "get", "Se", "lected", "Item", "()", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["Would", "n", "'t", "\u0120a", "\u0120top", "-", "level", "\u0120if", "\u0120(", "stop", "Ref", "resh", ")", "\u0120guard", "\u0120condition", "\u0120be", "\u0120better", ",", "\u0120instead", "\u0120of", "\u0120checking", "\u0120it", "\u0120within", "\u0120the", "\u0120loop", "?"]}
{"function": "public void findAllPaginationTest() throws Exception { context.turnOffAuthorisationSystem(); EPerson ePerson = EPersonBuilder.createEPerson(context) .withNameInMetadata(\"John\", \"Doe\") .withEmail(\"Johndoe@gmail.com\") .build(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get(\"/api/eperson/epersons\") .param(\"size\", \"1\")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath(\"$._embedded.epersons\", Matchers.contains(Matchers.anyOf( EPersonMatcher.matchEPersonOnEmail(eperson.getEmail()), EPersonMatcher.matchEPersonOnEmail(admin.getEmail()), EPersonMatcher.matchEPersonOnEmail(ePerson.getEmail()) )))) .andExpect(jsonPath(\"$._embedded.epersons\", Matchers.hasSize(1))) .andExpect(jsonPath(\"$.page.size\", is(1))) .andExpect(jsonPath(\"$.page.totalElements\", is(3))) ; getClient(token).perform(get(\"/api/eperson/epersons\") .param(\"size\", \"1\") .param(\"page\", \"1\")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath(\"$._embedded.epersons\", Matchers.contains(Matchers.anyOf( EPersonMatcher.matchEPersonOnEmail(eperson.getEmail()), EPersonMatcher.matchEPersonOnEmail(admin.getEmail()), EPersonMatcher.matchEPersonOnEmail(ePerson.getEmail()) )))) .andExpect(jsonPath(\"$._embedded.epersons\", Matchers.hasSize(1))) .andExpect(jsonPath(\"$.page.size\", is(1))) .andExpect(jsonPath(\"$.page.totalElements\", is(3))) ; getClient().perform(get(\"/api/eperson/epersons\")) .andExpect(status().isForbidden()) ; }", "text": "The variables eperson and ePerson are confusing in the same block. Could more specific names be used?", "function_tokens": ["public", "\u0120void", "\u0120find", "All", "P", "ag", "ination", "Test", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120context", ".", "turn", "Off", "Author", "isation", "System", "();", "\u0120EP", "erson", "\u0120e", "Person", "\u0120=", "\u0120EP", "erson", "Builder", ".", "create", "EP", "erson", "(", "context", ")", "\u0120.", "with", "Name", "In", "Met", "adata", "(\"", "John", "\",", "\u0120\"", "D", "oe", "\")", "\u0120.", "with", "Email", "(\"", "J", "oh", "nd", "oe", "@", "gmail", ".", "com", "\")", "\u0120.", "build", "();", "\u0120String", "\u0120token", "\u0120=", "\u0120get", "Auth", "Token", "(", "admin", ".", "get", "Email", "(),", "\u0120password", ");", "\u0120get", "Client", "(", "token", ").", "per", "form", "(", "get", "(\"", "/", "api", "/", "ep", "erson", "/", "ep", "ers", "ons", "\")", "\u0120.", "param", "(\"", "size", "\",", "\u0120\"", "1", "\"))", "\u0120.", "and", "Ex", "pect", "(", "status", "().", "is", "Ok", "())", "\u0120.", "and", "Ex", "pect", "(", "content", "().", "content", "Type", "(", "content", "Type", "))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$", "._", "embed", "ded", ".", "ep", "ers", "ons", "\",", "\u0120Mat", "chers", ".", "cont", "ains", "(", "Mat", "chers", ".", "any", "Of", "(", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "ep", "erson", ".", "get", "Email", "()", "),", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "admin", ".", "get", "Email", "()", "),", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "e", "Person", ".", "get", "Email", "())", "\u0120)", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$", "._", "embed", "ded", ".", "ep", "ers", "ons", "\",", "\u0120Mat", "chers", ".", "has", "Size", "(", "1", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$.", "page", ".", "size", "\",", "\u0120is", "(", "1", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$.", "page", ".", "total", "E", "lements", "\",", "\u0120is", "(", "3", ")))", "\u0120;", "\u0120get", "Client", "(", "token", ").", "per", "form", "(", "get", "(\"", "/", "api", "/", "ep", "erson", "/", "ep", "ers", "ons", "\")", "\u0120.", "param", "(\"", "size", "\",", "\u0120\"", "1", "\")", "\u0120.", "param", "(\"", "page", "\",", "\u0120\"", "1", "\"))", "\u0120.", "and", "Ex", "pect", "(", "status", "().", "is", "Ok", "())", "\u0120.", "and", "Ex", "pect", "(", "content", "().", "content", "Type", "(", "content", "Type", "))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$", "._", "embed", "ded", ".", "ep", "ers", "ons", "\",", "\u0120Mat", "chers", ".", "cont", "ains", "(", "Mat", "chers", ".", "any", "Of", "(", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "ep", "erson", ".", "get", "Email", "()", "),", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "admin", ".", "get", "Email", "()", "),", "\u0120EP", "erson", "Mat", "cher", ".", "match", "EP", "erson", "On", "Email", "(", "e", "Person", ".", "get", "Email", "())", "\u0120)", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$", "._", "embed", "ded", ".", "ep", "ers", "ons", "\",", "\u0120Mat", "chers", ".", "has", "Size", "(", "1", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$.", "page", ".", "size", "\",", "\u0120is", "(", "1", ")))", "\u0120.", "and", "Ex", "pect", "(", "json", "Path", "(\"", "$.", "page", ".", "total", "E", "lements", "\",", "\u0120is", "(", "3", ")))", "\u0120;", "\u0120get", "Client", "().", "per", "form", "(", "get", "(\"", "/", "api", "/", "ep", "erson", "/", "ep", "ers", "ons", "\"))", "\u0120.", "and", "Ex", "pect", "(", "status", "().", "is", "For", "bidden", "())", "\u0120;", "\u0120}"], "docstring_tokens": ["The", "\u0120variables", "\u0120ep", "erson", "\u0120and", "\u0120e", "Person", "\u0120are", "\u0120confusing", "\u0120in", "\u0120the", "\u0120same", "\u0120block", ".", "\u0120Could", "\u0120more", "\u0120specific", "\u0120names", "\u0120be", "\u0120used", "?"]}
{"function": "public void testAccessControl_studentNotExistInCourse_shouldFail() { InstructorAttributes instructor1OfCourse1 = typicalBundle.instructors.get(\"instructor1OfCourse1\"); StudentAttributes student1InCourse2 = typicalBundle.students.get(\"student1InCourse2\"); CourseAttributes typicalCourse1 = typicalBundle.courses.get(\"typicalCourse1\"); loginAsInstructor(instructor1OfCourse1.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, typicalCourse1.getId(), Const.ParamsNames.STUDENT_EMAIL, student1InCourse2.getEmail(), }; verifyCannotAccess(submissionParams); }", "text": "You should test for both instructor and student?", "function_tokens": ["public", "\u0120void", "\u0120test", "Access", "Control", "_", "student", "Not", "Ex", "ist", "In", "Course", "_", "should", "Fail", "()", "\u0120{", "\u0120Instructor", "Attributes", "\u0120instructor", "1", "Of", "Course", "1", "\u0120=", "\u0120typical", "B", "undle", ".", "in", "struct", "ors", ".", "get", "(\"", "in", "struct", "or", "1", "Of", "Course", "1", "\");", "\u0120Student", "Attributes", "\u0120student", "1", "In", "Course", "2", "\u0120=", "\u0120typical", "B", "undle", ".", "stud", "ents", ".", "get", "(\"", "student", "1", "In", "Course", "2", "\");", "\u0120Course", "Attributes", "\u0120typical", "Course", "1", "\u0120=", "\u0120typical", "B", "undle", ".", "c", "ourses", ".", "get", "(\"", "typ", "ical", "Course", "1", "\");", "\u0120login", "As", "Instruct", "or", "(", "in", "struct", "or", "1", "Of", "Course", "1", ".", "google", "Id", ");", "\u0120String", "[]", "\u0120submission", "Par", "ams", "\u0120=", "\u0120new", "\u0120String", "[]", "\u0120{", "\u0120Const", ".", "Par", "ams", "Names", ".", "C", "OUR", "SE", "_", "ID", ",", "\u0120typical", "Course", "1", ".", "get", "Id", "(),", "\u0120Const", ".", "Par", "ams", "Names", ".", "ST", "UD", "ENT", "_", "EMA", "IL", ",", "\u0120student", "1", "In", "Course", "2", ".", "get", "Email", "(),", "\u0120};", "\u0120verify", "C", "annot", "Access", "(", "sub", "mission", "Par", "ams", ");", "\u0120}"], "docstring_tokens": ["You", "\u0120should", "\u0120test", "\u0120for", "\u0120both", "\u0120instructor", "\u0120and", "\u0120student", "?"]}
{"function": "public @Nullable String resolveDeviceType(int quark, long timestamp) { return TmfStrings.cpu(); }", "text": "Should this be using TmfCpuAspect?", "function_tokens": ["public", "\u0120@", "Null", "able", "\u0120String", "\u0120resolve", "Device", "Type", "(", "int", "\u0120qu", "ark", ",", "\u0120long", "\u0120timestamp", ")", "\u0120{", "\u0120return", "\u0120T", "m", "f", "Str", "ings", ".", "cpu", "();", "\u0120}"], "docstring_tokens": ["Should", "\u0120this", "\u0120be", "\u0120using", "\u0120T", "m", "f", "C", "pu", "As", "pect", "?"]}
{"function": "public void run() { logger.info(\"System Resource: {}\", SystemResourceMonitor.create(SystemResourceMonitor.allResources).getFormattedSystemResourceUsage()); }", "text": "The create method call should be separate from the logger call.", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120logger", ".", "info", "(\"", "System", "\u0120Resource", ":", "\u0120{}", "\",", "\u0120System", "Resource", "Monitor", ".", "create", "(", "System", "Resource", "Monitor", ".", "all", "Resources", ").", "get", "Form", "atted", "System", "Resource", "Usage", "());", "\u0120}"], "docstring_tokens": ["The", "\u0120create", "\u0120method", "\u0120call", "\u0120should", "\u0120be", "\u0120separate", "\u0120from", "\u0120the", "\u0120logger", "\u0120call", "."]}
{"function": "public RangeResourceEntry remove(ResourceEntry<Long> resourceEntry) { RangeResourceEntry rangeResourceEntry = (RangeResourceEntry) resourceEntry; if (this.begin > rangeResourceEntry.getBegin()) { this.begin = rangeResourceEntry.getBegin(); } if (this.end < rangeResourceEntry.getEnd()) { this.end = rangeResourceEntry.getEnd(); } return this; }", "text": "This seems like the opposite of remove to me, since the range goes from beginning to end, if we remove from resourceEntry.begin to resourceEntry.end, then if the original begin is larger than the resourceEntry.begin and we set begin to the resourceEntry.begin, we'd be adding those ports between resourceEntry.begin and begin to the range. Similarly for end.", "function_tokens": ["public", "\u0120Range", "Resource", "Entry", "\u0120remove", "(", "Resource", "Entry", "<", "Long", ">", "\u0120resource", "Entry", ")", "\u0120{", "\u0120Range", "Resource", "Entry", "\u0120range", "Resource", "Entry", "\u0120=", "\u0120(", "Range", "Resource", "Entry", ")", "\u0120resource", "Entry", ";", "\u0120if", "\u0120(", "this", ".", "begin", "\u0120>", "\u0120range", "Resource", "Entry", ".", "get", "Begin", "())", "\u0120{", "\u0120this", ".", "begin", "\u0120=", "\u0120range", "Resource", "Entry", ".", "get", "Begin", "();", "\u0120}", "\u0120if", "\u0120(", "this", ".", "end", "\u0120<", "\u0120range", "Resource", "Entry", ".", "get", "End", "())", "\u0120{", "\u0120this", ".", "end", "\u0120=", "\u0120range", "Resource", "Entry", ".", "get", "End", "();", "\u0120}", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120seems", "\u0120like", "\u0120the", "\u0120opposite", "\u0120of", "\u0120remove", "\u0120to", "\u0120me", ",", "\u0120since", "\u0120the", "\u0120range", "\u0120goes", "\u0120from", "\u0120beginning", "\u0120to", "\u0120end", ",", "\u0120if", "\u0120we", "\u0120remove", "\u0120from", "\u0120resource", "Entry", ".", "begin", "\u0120to", "\u0120resource", "Entry", ".", "end", ",", "\u0120then", "\u0120if", "\u0120the", "\u0120original", "\u0120begin", "\u0120is", "\u0120larger", "\u0120than", "\u0120the", "\u0120resource", "Entry", ".", "begin", "\u0120and", "\u0120we", "\u0120set", "\u0120begin", "\u0120to", "\u0120the", "\u0120resource", "Entry", ".", "begin", ",", "\u0120we", "'d", "\u0120be", "\u0120adding", "\u0120those", "\u0120ports", "\u0120between", "\u0120resource", "Entry", ".", "begin", "\u0120and", "\u0120begin", "\u0120to", "\u0120the", "\u0120range", ".", "\u0120Similarly", "\u0120for", "\u0120end", "."]}
{"function": "public void secondary_no_location() throws Exception { thrown.expectMessage(\"Precise secondary location should contain at least one '^'\"); check( \"foo(); \"x = bar();\\n\" + \" TestIssue.create(\"msg1\", 1).secondary(\"Secondary message\", 3, 5, 8)); }", "text": "@vilchik-elena The message should give the line number.", "function_tokens": ["public", "\u0120void", "\u0120secondary", "_", "no", "_", "location", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120thrown", ".", "ex", "pect", "Message", "(\"", "Pre", "cise", "\u0120secondary", "\u0120location", "\u0120should", "\u0120contain", "\u0120at", "\u0120least", "\u0120one", "\u0120'", "^", "'", "\");", "\u0120check", "(", "\u0120\"", "foo", "();", "\u0120\"", "x", "\u0120=", "\u0120bar", "();", "\\", "n", "\"", "\u0120+", "\u0120\"", "\u0120Test", "Issue", ".", "create", "(\"", "msg", "1", "\",", "\u01201", ").", "secondary", "(\"", "Second", "ary", "\u0120message", "\",", "\u01203", ",", "\u01205", ",", "\u01208", "));", "\u0120}"], "docstring_tokens": ["@", "vil", "ch", "ik", "-", "el", "ena", "\u0120The", "\u0120message", "\u0120should", "\u0120give", "\u0120the", "\u0120line", "\u0120number", "."]}
{"function": "public ASN1DataFormat() { super(); this.usingIterator = false; }", "text": "Those 3 implicit super() calls could be removed.", "function_tokens": ["public", "\u0120AS", "N", "1", "Data", "Format", "()", "\u0120{", "\u0120super", "();", "\u0120this", ".", "using", "Iterator", "\u0120=", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Those", "\u01203", "\u0120implicit", "\u0120super", "()", "\u0120calls", "\u0120could", "\u0120be", "\u0120removed", "."]}
{"function": "public Long getUuid() { return new Long(artId); }", "text": "use Long.valueOf() instead of new Long() - always for performance reasons", "function_tokens": ["public", "\u0120Long", "\u0120get", "U", "uid", "()", "\u0120{", "\u0120return", "\u0120new", "\u0120Long", "(", "art", "Id", ");", "\u0120}"], "docstring_tokens": ["use", "\u0120Long", ".", "value", "Of", "()", "\u0120instead", "\u0120of", "\u0120new", "\u0120Long", "()", "\u0120-", "\u0120always", "\u0120for", "\u0120performance", "\u0120reasons"]}
{"function": "public void testCreateProcessWithLogonW() { String winDir = Kernel32Util.getEnvironmentVariable(\"WINDIR\"); if (winDir == null || !(new File(winDir).exists())) { throw new IllegalStateException(\"WINDIR environment variable did not properly resolve to a directory.\"); } STARTUPINFO si = new STARTUPINFO(); si.lpDesktop = null; PROCESS_INFORMATION results = new PROCESS_INFORMATION(); boolean result = Advapi32.INSTANCE.CreateProcessWithLogonW(\"A\" + System.currentTimeMillis(), \"localhost\", \"12345\", Advapi32.LOGON_WITH_PROFILE, new File(winDir, \"notepad.exe\").getAbsolutePath(), \"\", 0, null, \"\", si, results); assertFalse(result); assertEquals(Native.getLastError(), W32Errors.ERROR_LOGON_FAILURE); }", "text": "assertNotNull(\"No WINDIR value returned\", winDir); assertTrue(\"Specified WINDIR does not exist: \" + winDir, new File(winDir).exists());", "function_tokens": ["public", "\u0120void", "\u0120test", "Create", "Process", "With", "Log", "on", "W", "()", "\u0120{", "\u0120String", "\u0120win", "Dir", "\u0120=", "\u0120Kernel", "32", "Ut", "il", ".", "get", "Environment", "Variable", "(\"", "WIND", "IR", "\");", "\u0120if", "\u0120(", "win", "Dir", "\u0120==", "\u0120null", "\u0120||", "\u0120!", "(", "new", "\u0120File", "(", "win", "Dir", ").", "ex", "ists", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "WIND", "IR", "\u0120environment", "\u0120variable", "\u0120did", "\u0120not", "\u0120properly", "\u0120resolve", "\u0120to", "\u0120a", "\u0120directory", ".\"", ");", "\u0120}", "\u0120START", "UP", "INFO", "\u0120si", "\u0120=", "\u0120new", "\u0120START", "UP", "INFO", "();", "\u0120si", ".", "lp", "Desktop", "\u0120=", "\u0120null", ";", "\u0120PROC", "ESS", "_", "IN", "FORMATION", "\u0120results", "\u0120=", "\u0120new", "\u0120PROC", "ESS", "_", "IN", "FORMATION", "();", "\u0120boolean", "\u0120result", "\u0120=", "\u0120Adv", "api", "32", ".", "INST", "ANCE", ".", "Create", "Process", "With", "Log", "on", "W", "(\"", "A", "\"", "\u0120+", "\u0120System", ".", "current", "Time", "Mill", "is", "(),", "\u0120\"", "localhost", "\",", "\u0120\"", "123", "45", "\",", "\u0120Adv", "api", "32", ".", "LOG", "ON", "_", "W", "ITH", "_", "PRO", "FILE", ",", "\u0120new", "\u0120File", "(", "win", "Dir", ",", "\u0120\"", "not", "epad", ".", "exe", "\").", "get", "Abs", "olute", "Path", "(),", "\u0120\"", "\",", "\u01200", ",", "\u0120null", ",", "\u0120\"", "\",", "\u0120si", ",", "\u0120results", ");", "\u0120assert", "False", "(", "result", ");", "\u0120assert", "Equ", "als", "(", "Native", ".", "get", "Last", "Error", "(),", "\u0120W", "32", "Er", "rors", ".", "ERROR", "_", "LOG", "ON", "_", "FA", "IL", "URE", ");", "\u0120}"], "docstring_tokens": ["assert", "Not", "Null", "(\"", "No", "\u0120W", "IND", "IR", "\u0120value", "\u0120returned", "\",", "\u0120win", "Dir", ");", "\u0120assert", "True", "(\"", "Spec", "ified", "\u0120W", "IND", "IR", "\u0120does", "\u0120not", "\u0120exist", ":", "\u0120\"", "\u0120+", "\u0120win", "Dir", ",", "\u0120new", "\u0120File", "(", "win", "Dir", ").", "ex", "ists", "());"]}
{"function": "public void compileSuccessForBundleSparseArray() { CompileResult result = compileFiles(BundleSparseArrayCompileSuccessActivity.class); assertCompilationSuccessful(result); }", "text": "Sorry, i think i was not clear. Please add assertGeneratedClassContains() here to actually check the correct method call was generated.", "function_tokens": ["public", "\u0120void", "\u0120compile", "Success", "For", "B", "undle", "S", "parse", "Array", "()", "\u0120{", "\u0120Comp", "ile", "Result", "\u0120result", "\u0120=", "\u0120compile", "Files", "(", "B", "undle", "S", "parse", "Array", "Comp", "ile", "Success", "Activity", ".", "class", ");", "\u0120assert", "Comp", "ilation", "Success", "ful", "(", "result", ");", "\u0120}"], "docstring_tokens": ["Sorry", ",", "\u0120i", "\u0120think", "\u0120i", "\u0120was", "\u0120not", "\u0120clear", ".", "\u0120Please", "\u0120add", "\u0120assert", "Gener", "ated", "Class", "Cont", "ains", "()", "\u0120here", "\u0120to", "\u0120actually", "\u0120check", "\u0120the", "\u0120correct", "\u0120method", "\u0120call", "\u0120was", "\u0120generated", "."]}
{"function": "public ExecutionError filter(ExecutionErrorContext errorContext) { Builder errorBuilder = ExecutionError.builder().type(\"DB\").initActivityId(getInitActivityId(errorContext)); String stacktrace = getStackTrace(errorContext.getCause()); Task task = errorContext.getLastExecutedTask(); NodeInstance nodeInstance = errorContext.getLastExecutedNode(); logger.debug(\"Last executed node instance {}, last executed task {}\", nodeInstance, task); if (nodeInstance != null) { logger.debug(\"Last executed node instance {} will be used to populate error details\", nodeInstance); errorBuilder .deploymentId(((ProcessInstanceImpl)nodeInstance.getProcessInstance()).getDeploymentId()) .processInstanceId(nodeInstance.getProcessInstance().getId()) .processId(nodeInstance.getProcessInstance().getProcessId()) .activityId(nodeInstance.getId()) .activityName(nodeName(nodeInstance)); } else if (task != null) { logger.debug(\"Last executed task {} will be used to populate error details\", task); errorBuilder .deploymentId(task.getTaskData().getDeploymentId()) .processInstanceId(task.getTaskData().getProcessInstanceId()) .processId(task.getTaskData().getProcessId()) .activityId(task.getId()) .activityName(task.getName()); } return errorBuilder .message(errorContext.getCause().getMessage()) .error(stacktrace) .errorDate(new Date()) .build(); }", "text": "Would be good to have constants for the builder types, right now they are hard-coded strings like \"DB\", \"Task\". WDYT?", "function_tokens": ["public", "\u0120Execution", "Error", "\u0120filter", "(", "Exec", "ution", "Error", "Context", "\u0120error", "Context", ")", "\u0120{", "\u0120Builder", "\u0120error", "Builder", "\u0120=", "\u0120Execution", "Error", ".", "builder", "().", "type", "(\"", "DB", "\").", "init", "Activity", "Id", "(", "get", "Init", "Activity", "Id", "(", "error", "Context", "));", "\u0120String", "\u0120stack", "trace", "\u0120=", "\u0120get", "Stack", "Tr", "ace", "(", "error", "Context", ".", "get", "Cause", "());", "\u0120Task", "\u0120task", "\u0120=", "\u0120error", "Context", ".", "get", "Last", "Exec", "uted", "Task", "();", "\u0120Node", "Instance", "\u0120node", "Instance", "\u0120=", "\u0120error", "Context", ".", "get", "Last", "Exec", "uted", "Node", "();", "\u0120logger", ".", "debug", "(\"", "Last", "\u0120executed", "\u0120node", "\u0120instance", "\u0120{", "},", "\u0120last", "\u0120executed", "\u0120task", "\u0120{}", "\",", "\u0120node", "Instance", ",", "\u0120task", ");", "\u0120if", "\u0120(", "node", "Instance", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "debug", "(\"", "Last", "\u0120executed", "\u0120node", "\u0120instance", "\u0120{}", "\u0120will", "\u0120be", "\u0120used", "\u0120to", "\u0120populate", "\u0120error", "\u0120details", "\",", "\u0120node", "Instance", ");", "\u0120error", "Builder", "\u0120.", "de", "ploy", "ment", "Id", "((", "(", "Process", "Instance", "Impl", ")", "node", "Instance", ".", "get", "Process", "Instance", "()", ").", "get", "Deploy", "ment", "Id", "())", "\u0120.", "process", "Instance", "Id", "(", "node", "Instance", ".", "get", "Process", "Instance", "().", "get", "Id", "())", "\u0120.", "process", "Id", "(", "node", "Instance", ".", "get", "Process", "Instance", "().", "get", "Process", "Id", "())", "\u0120.", "activity", "Id", "(", "node", "Instance", ".", "get", "Id", "())", "\u0120.", "activity", "Name", "(", "node", "Name", "(", "node", "Instance", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "task", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "debug", "(\"", "Last", "\u0120executed", "\u0120task", "\u0120{}", "\u0120will", "\u0120be", "\u0120used", "\u0120to", "\u0120populate", "\u0120error", "\u0120details", "\",", "\u0120task", ");", "\u0120error", "Builder", "\u0120.", "de", "ploy", "ment", "Id", "(", "task", ".", "get", "Task", "Data", "().", "get", "Deploy", "ment", "Id", "())", "\u0120.", "process", "Instance", "Id", "(", "task", ".", "get", "Task", "Data", "().", "get", "Process", "Instance", "Id", "())", "\u0120.", "process", "Id", "(", "task", ".", "get", "Task", "Data", "().", "get", "Process", "Id", "())", "\u0120.", "activity", "Id", "(", "task", ".", "get", "Id", "())", "\u0120.", "activity", "Name", "(", "task", ".", "get", "Name", "());", "\u0120}", "\u0120return", "\u0120error", "Builder", "\u0120.", "message", "(", "error", "Context", ".", "get", "Cause", "().", "get", "Message", "())", "\u0120.", "error", "(", "stack", "trace", ")", "\u0120.", "error", "Date", "(", "new", "\u0120Date", "())", "\u0120.", "build", "();", "\u0120}"], "docstring_tokens": ["Would", "\u0120be", "\u0120good", "\u0120to", "\u0120have", "\u0120constants", "\u0120for", "\u0120the", "\u0120builder", "\u0120types", ",", "\u0120right", "\u0120now", "\u0120they", "\u0120are", "\u0120hard", "-", "coded", "\u0120strings", "\u0120like", "\u0120\"", "DB", "\",", "\u0120\"", "Task", "\".", "\u0120WD", "Y", "T", "?"]}
