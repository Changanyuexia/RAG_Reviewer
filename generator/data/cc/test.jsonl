{"function": "@@ -53,7 +53,7 @@ public class ProtocGapicPluginGeneratorTest { model.getFiles().stream().map(ProtoFile::getProto).collect(Collectors.toList())) // Only the file to generate a client for (don't generate dependencies) .addFileToGenerate(\"multiple_services.proto\") - .setParameter(\"language=java\") + .setParameter(\"language=java,transport=grpc\") .build(); CodeGeneratorResponse response = ProtocGeneratorMain.generate(codeGeneratorRequest);", "text": "can we also test for `transport=rest`?", "function_tokens": ["@@", "\u0120-", "53", ",", "7", "\u0120+", "53", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Prot", "oc", "G", "ap", "ic", "Plugin", "Gener", "ator", "Test", "\u0120{", "\u0120model", ".", "get", "Files", "().", "stream", "().", "map", "(", "Pro", "to", "File", "::", "get", "Pro", "to", ").", "collect", "(", "Collect", "ors", ".", "to", "List", "()", "))", "\u0120//", "\u0120Only", "\u0120the", "\u0120file", "\u0120to", "\u0120generate", "\u0120a", "\u0120client", "\u0120for", "\u0120(", "don", "'t", "\u0120generate", "\u0120dependencies", ")", "\u0120.", "add", "File", "To", "Gener", "ate", "(\"", "multiple", "_", "services", ".", "pro", "to", "\")", "\u0120-", "\u0120.", "set", "Parameter", "(\"", "language", "=", "java", "\")", "\u0120+", "\u0120.", "set", "Parameter", "(\"", "language", "=", "java", ",", "trans", "port", "=", "gr", "pc", "\")", "\u0120.", "build", "();", "\u0120Code", "Gener", "ator", "Response", "\u0120response", "\u0120=", "\u0120Prot", "oc", "Gener", "ator", "Main", ".", "gener", "ate", "(", "code", "Gener", "ator", "Request", ");"], "docstring_tokens": ["can", "\u0120we", "\u0120also", "\u0120test", "\u0120for", "\u0120`", "trans", "port", "=", "rest", "`", "?"]}
{"function": "@@ -182,7 +182,9 @@ abstract class AbstractSolrBackendFactory implements FactoryInterface */ protected function createBackend(Connector $connector) { + $config = $this->config->get($this->mainConfig); $backend = new $this->backendClass($connector); + $backend->setPageSize($config->Index->record_batch_size); $backend->setQueryBuilder($this->createQueryBuilder()); $backend->setSimilarBuilder($this->createSimilarBuilder()); if ($this->logger) {", "text": "If record_batch_size is not set in config.ini, this code will trigger a notice about an undefined value. I would suggest either wrapping the setPageSize() call in an `if (!empty(...)) {` check, or else providing a default value in the set call (i.e. `$config->Index->record_batch_size ?? 100`).", "function_tokens": ["@@", "\u0120-", "182", ",", "7", "\u0120+", "182", ",", "9", "\u0120@@", "\u0120abstract", "\u0120class", "\u0120Abstract", "Sol", "r", "Back", "end", "Factory", "\u0120implements", "\u0120Factory", "Interface", "\u0120*/", "\u0120protected", "\u0120function", "\u0120create", "Back", "end", "(", "Connector", "\u0120$", "connect", "or", ")", "\u0120{", "\u0120+", "\u0120$", "config", "\u0120=", "\u0120$", "this", "->", "config", "->", "get", "($", "this", "->", "main", "Config", ");", "\u0120$", "back", "end", "\u0120=", "\u0120new", "\u0120$", "this", "->", "back", "end", "Class", "($", "connect", "or", ");", "\u0120+", "\u0120$", "back", "end", "->", "set", "Page", "Size", "($", "config", "->", "Index", "->", "record", "_", "batch", "_", "size", ");", "\u0120$", "back", "end", "->", "set", "Query", "Builder", "($", "this", "->", "create", "Query", "Builder", "());", "\u0120$", "back", "end", "->", "set", "Similar", "Builder", "($", "this", "->", "create", "Similar", "Builder", "());", "\u0120if", "\u0120($", "this", "->", "log", "ger", ")", "\u0120{"], "docstring_tokens": ["If", "\u0120record", "_", "batch", "_", "size", "\u0120is", "\u0120not", "\u0120set", "\u0120in", "\u0120config", ".", "ini", ",", "\u0120this", "\u0120code", "\u0120will", "\u0120trigger", "\u0120a", "\u0120notice", "\u0120about", "\u0120an", "\u0120undefined", "\u0120value", ".", "\u0120I", "\u0120would", "\u0120suggest", "\u0120either", "\u0120wrapping", "\u0120the", "\u0120set", "Page", "Size", "()", "\u0120call", "\u0120in", "\u0120an", "\u0120`", "if", "\u0120(!", "empty", "(", "...", "))", "\u0120{", "`", "\u0120check", ",", "\u0120or", "\u0120else", "\u0120providing", "\u0120a", "\u0120default", "\u0120value", "\u0120in", "\u0120the", "\u0120set", "\u0120call", "\u0120(", "i", ".", "e", ".", "\u0120`", "$", "config", "->", "Index", "->", "record", "_", "batch", "_", "size", "\u0120??", "\u0120100", "`", ")."]}
{"function": "@@ -1,6 +1,6 @@ <script type=\"text/javascript\"> window.analytics||(window.analytics=[]),window.analytics.methods=[\"identify\",\"track\",\"trackLink\",\"trackForm\",\"trackClick\",\"trackSubmit\",\"page\",\"pageview\",\"ab\",\"alias\",\"ready\",\"group\",\"on\",\"once\",\"off\"],window.analytics.factory=function(t){return function(){var a=Array.prototype.slice.call(arguments);return a.unshift(t),window.analytics.push(a),window.analytics}};for(var i=0;i<window.analytics.methods.length;i++){var method=window.analytics.methods[i];window.analytics[method]=window.analytics.factory(method)}window.analytics.load=function(t){var a=document.createElement(\"script\");a.type=\"text/javascript\",a.async=!0,a.src=(\"https:\"===document.location.protocol?\"https://\":\"http://\")+\"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/\"+t+\"/analytics.min.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(a,n)},window.analytics.SNIPPET_VERSION=\"2.0.8\", - window.analytics.load(\"2nexpdgku3\"); + window.analytics.load(<%= ENV['SEGMENT_KEY']%>); window.analytics.page(); </script> ", "text": "I didn't realize we were hardcoding this, thanks for moving it to an env value.", "function_tokens": ["@@", "\u0120-", "1", ",", "6", "\u0120+", "1", ",", "6", "\u0120@@", "\u0120<", "script", "\u0120type", "=\"", "text", "/", "javascript", "\">", "\u0120window", ".", "analy", "tics", "||", "(", "window", ".", "analy", "tics", "=", "[]", "),", "window", ".", "analy", "tics", ".", "method", "s", "=", "[\"", "ident", "ify", "\",\"", "track", "\",\"", "track", "Link", "\",\"", "track", "Form", "\",\"", "track", "Click", "\",\"", "track", "Submit", "\",\"", "page", "\",\"", "page", "view", "\",\"", "ab", "\",\"", "alias", "\",\"", "ready", "\",\"", "group", "\",\"", "on", "\",\"", "once", "\",\"", "off", "\"],", "window", ".", "analy", "tics", ".", "f", "actory", "=", "function", "(", "t", "){", "return", "\u0120function", "(){", "var", "\u0120a", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arg", "uments", ");", "return", "\u0120a", ".", "un", "shift", "(", "t", "),", "window", ".", "analy", "tics", ".", "push", "(", "a", "),", "window", ".", "analy", "tics", "}}", ";", "for", "(", "var", "\u0120i", "=", "0", ";", "i", "<", "window", ".", "analy", "tics", ".", "method", "s", ".", "length", ";", "i", "++", "){", "var", "\u0120method", "=", "window", ".", "analy", "tics", ".", "method", "s", "[", "i", "];", "window", ".", "analy", "tics", "[", "method", "]=", "window", ".", "analy", "tics", ".", "f", "actory", "(", "method", ")}", "window", ".", "analy", "tics", ".", "load", "=", "function", "(", "t", "){", "var", "\u0120a", "=", "document", ".", "create", "Element", "(\"", "script", "\");", "a", ".", "type", "=\"", "text", "/", "javascript", "\",", "a", ".", "as", "ync", "=", "!", "0", ",", "a", ".", "src", "=", "(\"", "https", ":\"", "===", "document", ".", "location", ".", "prot", "ocol", "?\"", "https", "://", "\":\"", "http", "://", "\")", "+", "\"", "d", "2", "dq", "2", "ah", "tl", "5", "zl", "1", "z", ".", "cloud", "front", ".", "net", "/", "analy", "tics", ".", "js", "/", "v", "1", "/\"", "+", "t", "+", "\"", "/", "analy", "tics", ".", "min", ".", "js", "\";", "var", "\u0120n", "=", "document", ".", "get", "E", "lements", "By", "Tag", "Name", "(\"", "script", "\")", "[", "0", "];", "n", ".", "parent", "Node", ".", "insert", "Before", "(", "a", ",", "n", ")", "},", "window", ".", "analy", "tics", ".", "SN", "IPP", "ET", "_", "VERSION", "=\"", "2", ".", "0", ".", "8", "\",", "\u0120-", "\u0120window", ".", "analy", "tics", ".", "load", "(\"", "2", "nex", "pd", "g", "ku", "3", "\");", "\u0120+", "\u0120window", ".", "analy", "tics", ".", "load", "(", "<", "%", "=", "\u0120EN", "V", "['", "SE", "G", "MENT", "_", "KEY", "']", "%", ">", ");", "\u0120window", ".", "analy", "tics", ".", "page", "();", "\u0120</", "script", ">", "\u0120"], "docstring_tokens": ["I", "\u0120didn", "'t", "\u0120realize", "\u0120we", "\u0120were", "\u0120hard", "c", "oding", "\u0120this", ",", "\u0120thanks", "\u0120for", "\u0120moving", "\u0120it", "\u0120to", "\u0120an", "\u0120env", "\u0120value", "."]}
{"function": "@@ -99,7 +99,7 @@ module.exports = function fileItem (props) { } </h4> <div class=\"UppyDashboardItem-status\"> - ${file.data.size && html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`} + ${isNaN(file.data.size) ? '' : html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`} ${file.source && html`<div class=\"UppyDashboardItem-sourceIcon\"> ${acquirers.map(acquirer => { if (acquirer.id === file.source) return html`<span title=\"${props.i18n('fileSource')}: ${acquirer.name}\">${acquirer.icon()}</span>`", "text": "We are trying to support IE 10-11, so we'll need a polyfill for this one, I think.", "function_tokens": ["@@", "\u0120-", "99", ",", "7", "\u0120+", "99", ",", "7", "\u0120@@", "\u0120module", ".", "ex", "ports", "\u0120=", "\u0120function", "\u0120file", "Item", "\u0120(", "pro", "ps", ")", "\u0120{", "\u0120}", "\u0120</", "h", "4", ">", "\u0120<", "div", "\u0120class", "=\"", "U", "ppy", "Dash", "board", "Item", "-", "status", "\">", "\u0120-", "\u0120${", "file", ".", "data", ".", "size", "\u0120&&", "\u0120html", "`", "<", "div", "\u0120class", "=\"", "U", "ppy", "Dash", "board", "Item", "-", "status", "Size", "\">", "${", "pretty", "Bytes", "(", "file", ".", "data", ".", "size", ")}", "</", "div", ">", "`", "}", "\u0120+", "\u0120${", "is", "Na", "N", "(", "file", ".", "data", ".", "size", ")", "\u0120?", "\u0120''", "\u0120:", "\u0120html", "`", "<", "div", "\u0120class", "=\"", "U", "ppy", "Dash", "board", "Item", "-", "status", "Size", "\">", "${", "pretty", "Bytes", "(", "file", ".", "data", ".", "size", ")}", "</", "div", ">", "`", "}", "\u0120${", "file", ".", "source", "\u0120&&", "\u0120html", "`", "<", "div", "\u0120class", "=\"", "U", "ppy", "Dash", "board", "Item", "-", "source", "Icon", "\">", "\u0120${", "ac", "quire", "rs", ".", "map", "(", "ac", "quire", "r", "\u0120=>", "\u0120{", "\u0120if", "\u0120(", "ac", "quire", "r", ".", "id", "\u0120===", "\u0120file", ".", "source", ")", "\u0120return", "\u0120html", "`", "<", "span", "\u0120title", "=\"", "${", "pro", "ps", ".", "i", "18", "n", "('", "file", "Source", "')", "}:", "\u0120${", "ac", "quire", "r", ".", "name", "}", "\">", "${", "ac", "quire", "r", ".", "icon", "()", "}", "</", "span", ">", "`"], "docstring_tokens": ["We", "\u0120are", "\u0120trying", "\u0120to", "\u0120support", "\u0120IE", "\u012010", "-", "11", ",", "\u0120so", "\u0120we", "'ll", "\u0120need", "\u0120a", "\u0120poly", "fill", "\u0120for", "\u0120this", "\u0120one", ",", "\u0120I", "\u0120think", "."]}
{"function": "@@ -38,6 +38,9 @@ const { useSelect, useDispatch } = Data; function ResetButton( { children } ) { const postResetURL = useSelect( ( select ) => select( CORE_SITE ).getAdminURL( 'googlesitekit-splash', { notification: 'reset_success' } ) ); + const isNavigating = useSelect( ( select ) => select( CORE_LOCATION ).isNavigating() ); + const navigatingURL = useSelect( ( select ) => select( CORE_LOCATION ).getNavigateURL() ); + const [ dialogActive, setDialogActive ] = useState( false ); useEffect( () => {", "text": "It looks like there's a new `isNavigatingTo( url )` selector for this very purpose so let's use this here instead. This way we just need to use the one selector rather than two. Let's assign that to a similar-named variable here (e.g. `isNavigatingToPostResetURL`) rather than the prop it's used with.", "function_tokens": ["@@", "\u0120-", "38", ",", "6", "\u0120+", "38", ",", "9", "\u0120@@", "\u0120const", "\u0120{", "\u0120use", "Select", ",", "\u0120use", "Dispatch", "\u0120}", "\u0120=", "\u0120Data", ";", "\u0120function", "\u0120Reset", "Button", "(", "\u0120{", "\u0120children", "\u0120}", "\u0120)", "\u0120{", "\u0120const", "\u0120post", "Res", "et", "URL", "\u0120=", "\u0120use", "Select", "(", "\u0120(", "\u0120select", "\u0120)", "\u0120=>", "\u0120select", "(", "\u0120C", "ORE", "_", "S", "ITE", "\u0120).", "get", "Admin", "URL", "(", "\u0120'", "go", "og", "les", "ite", "kit", "-", "spl", "ash", "',", "\u0120{", "\u0120notification", ":", "\u0120'", "reset", "_", "success", "'", "\u0120}", "\u0120)", "\u0120);", "\u0120+", "\u0120const", "\u0120is", "Nav", "igating", "\u0120=", "\u0120use", "Select", "(", "\u0120(", "\u0120select", "\u0120)", "\u0120=>", "\u0120select", "(", "\u0120C", "ORE", "_", "LOC", "ATION", "\u0120).", "is", "Nav", "igating", "()", "\u0120);", "\u0120+", "\u0120const", "\u0120navigating", "URL", "\u0120=", "\u0120use", "Select", "(", "\u0120(", "\u0120select", "\u0120)", "\u0120=>", "\u0120select", "(", "\u0120C", "ORE", "_", "LOC", "ATION", "\u0120).", "get", "Nav", "igate", "URL", "()", "\u0120);", "\u0120+", "\u0120const", "\u0120[", "\u0120dialog", "Active", ",", "\u0120set", "Dialog", "Active", "\u0120]", "\u0120=", "\u0120use", "State", "(", "\u0120false", "\u0120);", "\u0120use", "Effect", "(", "\u0120()", "\u0120=>", "\u0120{"], "docstring_tokens": ["It", "\u0120looks", "\u0120like", "\u0120there", "'s", "\u0120a", "\u0120new", "\u0120`", "is", "Nav", "igating", "To", "(", "\u0120url", "\u0120)", "`", "\u0120selector", "\u0120for", "\u0120this", "\u0120very", "\u0120purpose", "\u0120so", "\u0120let", "'s", "\u0120use", "\u0120this", "\u0120here", "\u0120instead", ".", "\u0120This", "\u0120way", "\u0120we", "\u0120just", "\u0120need", "\u0120to", "\u0120use", "\u0120the", "\u0120one", "\u0120selector", "\u0120rather", "\u0120than", "\u0120two", ".", "\u0120Let", "'s", "\u0120assign", "\u0120that", "\u0120to", "\u0120a", "\u0120similar", "-", "named", "\u0120variable", "\u0120here", "\u0120(", "e", ".", "g", ".", "\u0120`", "is", "Nav", "igating", "To", "Post", "Res", "et", "URL", "`", ")", "\u0120rather", "\u0120than", "\u0120the", "\u0120prop", "\u0120it", "'s", "\u0120used", "\u0120with", "."]}
{"function": "@@ -29,8 +29,8 @@ namespace lbann { -void im2col(const Mat& im, - Mat& col, +void im2col(const AbsMat& im, + AbsMat& col, const int num_channels, const int im_num_dims, const int * im_dims,", "text": "I think im2col should only accommodate CPUMat.", "function_tokens": ["@@", "\u0120-", "29", ",", "8", "\u0120+", "29", ",", "8", "\u0120@@", "\u0120namespace", "\u0120lb", "ann", "\u0120{", "\u0120-", "void", "\u0120im", "2", "col", "(", "const", "\u0120Mat", "&", "\u0120im", ",", "\u0120-", "\u0120Mat", "&", "\u0120col", ",", "\u0120+", "void", "\u0120im", "2", "col", "(", "const", "\u0120Abs", "Mat", "&", "\u0120im", ",", "\u0120+", "\u0120Abs", "Mat", "&", "\u0120col", ",", "\u0120const", "\u0120int", "\u0120num", "_", "ch", "annels", ",", "\u0120const", "\u0120int", "\u0120im", "_", "num", "_", "d", "ims", ",", "\u0120const", "\u0120int", "\u0120*", "\u0120im", "_", "d", "ims", ","], "docstring_tokens": ["I", "\u0120think", "\u0120im", "2", "col", "\u0120should", "\u0120only", "\u0120accommodate", "\u0120CPU", "Mat", "."]}
{"function": "@@ -24,6 +24,8 @@ from google.cloud.forseti.notifier.notifiers import cscc_notifier from google.cloud.forseti.notifier.notifiers.inventory_summary import InventorySummary from google.cloud.forseti.services.inventory.storage import DataAccess from google.cloud.forseti.services.scanner import dao as scanner_dao +from google.cloud.forseti.common.util.email.email_factory import EmailFactory +from google.cloud.forseti.notifier.notifiers import email_violations # pylint: enable=line-too-long ", "text": "alpha sort the imports", "function_tokens": ["@@", "\u0120-", "24", ",", "6", "\u0120+", "24", ",", "8", "\u0120@@", "\u0120from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "not", "ifier", ".", "not", "ifiers", "\u0120import", "\u0120cs", "cc", "_", "not", "ifier", "\u0120from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "not", "ifier", ".", "not", "ifiers", ".", "inventory", "_", "summary", "\u0120import", "\u0120Inventory", "Summary", "\u0120from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "services", ".", "inventory", ".", "storage", "\u0120import", "\u0120Data", "Access", "\u0120from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "services", ".", "scan", "ner", "\u0120import", "\u0120d", "ao", "\u0120as", "\u0120scanner", "_", "d", "ao", "\u0120+", "from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "common", ".", "util", ".", "email", ".", "email", "_", "f", "actory", "\u0120import", "\u0120Email", "Factory", "\u0120+", "from", "\u0120google", ".", "cloud", ".", "f", "orset", "i", ".", "not", "ifier", ".", "not", "ifiers", "\u0120import", "\u0120email", "_", "viol", "ations", "\u0120#", "\u0120p", "yl", "int", ":", "\u0120enable", "=", "line", "-", "too", "-", "long", "\u0120"], "docstring_tokens": ["alpha", "\u0120sort", "\u0120the", "\u0120imports"]}
{"function": "@@ -1067,7 +1067,7 @@ fpga_result mmio_error(struct RASCommandLine *rasCmdLine) if ( rasCmdLine->function >0 ) function = rasCmdLine->bus; - snprintf(sysfs_path, sizeof(sysfs_path), + snprintf_s_iiii(sysfs_path, sizeof(sysfs_path), DEVICEID_PATH,0,bus,device,function); result = sysfs_read_u64(sysfs_path, &value);", "text": "Can you explain why is this necessary? Is `snprintf()` with four integer arguments unsafe?", "function_tokens": ["@@", "\u0120-", "10", "67", ",", "7", "\u0120+", "10", "67", ",", "7", "\u0120@@", "\u0120f", "p", "ga", "_", "result", "\u0120mm", "io", "_", "error", "(", "struct", "\u0120R", "AS", "Command", "Line", "\u0120*", "ras", "Cmd", "Line", ")", "\u0120if", "\u0120(", "\u0120r", "as", "Cmd", "Line", "->", "function", "\u0120>", "0", "\u0120)", "\u0120function", "\u0120=", "\u0120r", "as", "Cmd", "Line", "->", "bus", ";", "\u0120-", "\u0120sn", "printf", "(", "sys", "fs", "_", "path", ",", "\u0120sizeof", "(", "sys", "fs", "_", "path", "),", "\u0120+", "\u0120sn", "printf", "_", "s", "_", "ii", "ii", "(", "sys", "fs", "_", "path", ",", "\u0120sizeof", "(", "sys", "fs", "_", "path", "),", "\u0120DE", "VICE", "ID", "_", "PATH", ",", "0", ",", "bus", ",", "device", ",", "function", ");", "\u0120result", "\u0120=", "\u0120sys", "fs", "_", "read", "_", "u", "64", "(", "sys", "fs", "_", "path", ",", "\u0120&", "value", ");"], "docstring_tokens": ["Can", "\u0120you", "\u0120explain", "\u0120why", "\u0120is", "\u0120this", "\u0120necessary", "?", "\u0120Is", "\u0120`", "sn", "printf", "()", "`", "\u0120with", "\u0120four", "\u0120integer", "\u0120arguments", "\u0120unsafe", "?"]}
{"function": "@@ -219,7 +219,19 @@ def internal_keyDownEvent(vkCode,scanCode,extended,injected): for k in range(256): keyStates[k]=ctypes.windll.user32.GetKeyState(k) charBuf=ctypes.create_unicode_buffer(5) + # First try getting the keyboard layout from the thread with the focus (input thread) hkl=ctypes.windll.user32.GetKeyboardLayout(focus.windowThreadID) + if not hkl: + log.debug(\"Failed to fetch keyboard layout from focus, trying layout from last detected change\") + # Some threads, such as for Windows consoles + # Do not allow getKeyboardLayout to work. + # Therefore, use the cached keyboard layout from the last inputLangChange detected by NVDA + # on the foreground object. + hkl = getattr(api.getForegroundObject(), '_lastDetectedKeyboardLayoutChange', 0) + if not hkl: + log.debug(\"No layout cached, falling back to layout of NVDA main thread\") + # As a last resort, use the keyboard layout of NVDA's main thread. + hkl = ctypes.windll.user32.GetKeyboardLayout(core.mainThreadId) # In previous Windows builds, calling ToUnicodeEx would destroy keyboard buffer state and therefore cause the app to not produce the right WM_CHAR message. # However, ToUnicodeEx now can take a new flag of 0x4, which stops it from destroying keyboard state, thus allowing us to safely call it here. res=ctypes.windll.user32.ToUnicodeEx(vkCode,scanCode,keyStates,charBuf,len(charBuf),0x4,hkl)", "text": "How likely would it be that the keyboard layout for the NVDA main thread differs from the keyboard layout of the currently focused app?", "function_tokens": ["@@", "\u0120-", "219", ",", "7", "\u0120+", "219", ",", "19", "\u0120@@", "\u0120def", "\u0120internal", "_", "key", "Down", "Event", "(", "v", "k", "Code", ",", "scan", "Code", ",", "ext", "ended", ",", "in", "jected", "):", "\u0120for", "\u0120k", "\u0120in", "\u0120range", "(", "256", "):", "\u0120key", "States", "[", "k", "]=", "ct", "ypes", ".", "wind", "ll", ".", "user", "32", ".", "Get", "Key", "State", "(", "k", ")", "\u0120char", "B", "uf", "=", "ct", "ypes", ".", "create", "_", "unic", "ode", "_", "buffer", "(", "5", ")", "\u0120+", "\u0120#", "\u0120First", "\u0120try", "\u0120getting", "\u0120the", "\u0120keyboard", "\u0120layout", "\u0120from", "\u0120the", "\u0120thread", "\u0120with", "\u0120the", "\u0120focus", "\u0120(", "input", "\u0120thread", ")", "\u0120h", "kl", "=", "ct", "ypes", ".", "wind", "ll", ".", "user", "32", ".", "Get", "Key", "board", "Layout", "(", "focus", ".", "window", "Thread", "ID", ")", "\u0120+", "\u0120if", "\u0120not", "\u0120h", "kl", ":", "\u0120+", "\u0120log", ".", "debug", "(\"", "F", "ailed", "\u0120to", "\u0120fetch", "\u0120keyboard", "\u0120layout", "\u0120from", "\u0120focus", ",", "\u0120trying", "\u0120layout", "\u0120from", "\u0120last", "\u0120detected", "\u0120change", "\")", "\u0120+", "\u0120#", "\u0120Some", "\u0120threads", ",", "\u0120such", "\u0120as", "\u0120for", "\u0120Windows", "\u0120consoles", "\u0120+", "\u0120#", "\u0120Do", "\u0120not", "\u0120allow", "\u0120get", "Key", "board", "Layout", "\u0120to", "\u0120work", ".", "\u0120+", "\u0120#", "\u0120Therefore", ",", "\u0120use", "\u0120the", "\u0120cached", "\u0120keyboard", "\u0120layout", "\u0120from", "\u0120the", "\u0120last", "\u0120input", "L", "ang", "Change", "\u0120detected", "\u0120by", "\u0120NV", "DA", "\u0120+", "\u0120#", "\u0120on", "\u0120the", "\u0120foreground", "\u0120object", ".", "\u0120+", "\u0120h", "kl", "\u0120=", "\u0120get", "attr", "(", "api", ".", "get", "Fore", "ground", "Object", "(),", "\u0120'", "_", "last", "Det", "ected", "Key", "board", "Layout", "Change", "',", "\u01200", ")", "\u0120+", "\u0120if", "\u0120not", "\u0120h", "kl", ":", "\u0120+", "\u0120log", ".", "debug", "(\"", "No", "\u0120layout", "\u0120cached", ",", "\u0120falling", "\u0120back", "\u0120to", "\u0120layout", "\u0120of", "\u0120NV", "DA", "\u0120main", "\u0120thread", "\")", "\u0120+", "\u0120#", "\u0120As", "\u0120a", "\u0120last", "\u0120resort", ",", "\u0120use", "\u0120the", "\u0120keyboard", "\u0120layout", "\u0120of", "\u0120NV", "DA", "'s", "\u0120main", "\u0120thread", ".", "\u0120+", "\u0120h", "kl", "\u0120=", "\u0120c", "types", ".", "wind", "ll", ".", "user", "32", ".", "Get", "Key", "board", "Layout", "(", "core", ".", "main", "Thread", "Id", ")", "\u0120#", "\u0120In", "\u0120previous", "\u0120Windows", "\u0120builds", ",", "\u0120calling", "\u0120To", "Un", "ic", "ode", "Ex", "\u0120would", "\u0120destroy", "\u0120keyboard", "\u0120buffer", "\u0120state", "\u0120and", "\u0120therefore", "\u0120cause", "\u0120the", "\u0120app", "\u0120to", "\u0120not", "\u0120produce", "\u0120the", "\u0120right", "\u0120WM", "_", "CHAR", "\u0120message", ".", "\u0120#", "\u0120However", ",", "\u0120To", "Un", "ic", "ode", "Ex", "\u0120now", "\u0120can", "\u0120take", "\u0120a", "\u0120new", "\u0120flag", "\u0120of", "\u01200", "x", "4", ",", "\u0120which", "\u0120stops", "\u0120it", "\u0120from", "\u0120destroying", "\u0120keyboard", "\u0120state", ",", "\u0120thus", "\u0120allowing", "\u0120us", "\u0120to", "\u0120safely", "\u0120call", "\u0120it", "\u0120here", ".", "\u0120res", "=", "ct", "ypes", ".", "wind", "ll", ".", "user", "32", ".", "To", "Un", "ic", "ode", "Ex", "(", "v", "k", "Code", ",", "scan", "Code", ",", "key", "States", ",", "char", "B", "uf", ",", "len", "(", "char", "B", "uf", "),", "0", "x", "4", ",", "h", "kl", ")"], "docstring_tokens": ["How", "\u0120likely", "\u0120would", "\u0120it", "\u0120be", "\u0120that", "\u0120the", "\u0120keyboard", "\u0120layout", "\u0120for", "\u0120the", "\u0120NV", "DA", "\u0120main", "\u0120thread", "\u0120differs", "\u0120from", "\u0120the", "\u0120keyboard", "\u0120layout", "\u0120of", "\u0120the", "\u0120currently", "\u0120focused", "\u0120app", "?"]}
{"function": "@@ -198,6 +198,10 @@ class Driver extends webdriver.WebDriver { * @return {!Driver} A new driver instance. */ static createSession(options, service = getDefaultService()) { + if (!service) { + service = getDefaultService(); + } + let client = service.start().then(url => new http.HttpClient(url)); let executor = new http.Executor(client); ", "text": "Would you mind removing the default parameter above? (I doubt I'll ever use defaults again since you still have to protect against callers explicitly passing `null` or `undefined`)", "function_tokens": ["@@", "\u0120-", "198", ",", "6", "\u0120+", "198", ",", "10", "\u0120@@", "\u0120class", "\u0120Driver", "\u0120extends", "\u0120web", "driver", ".", "Web", "Driver", "\u0120{", "\u0120*", "\u0120@", "return", "\u0120{", "!", "Driver", "}", "\u0120A", "\u0120new", "\u0120driver", "\u0120instance", ".", "\u0120*/", "\u0120static", "\u0120create", "Session", "(", "options", ",", "\u0120service", "\u0120=", "\u0120get", "Default", "Service", "())", "\u0120{", "\u0120+", "\u0120if", "\u0120(!", "service", ")", "\u0120{", "\u0120+", "\u0120service", "\u0120=", "\u0120get", "Default", "Service", "();", "\u0120+", "\u0120}", "\u0120+", "\u0120let", "\u0120client", "\u0120=", "\u0120service", ".", "start", "().", "then", "(", "url", "\u0120=>", "\u0120new", "\u0120http", ".", "Http", "Client", "(", "url", "));", "\u0120let", "\u0120execut", "or", "\u0120=", "\u0120new", "\u0120http", ".", "Exec", "utor", "(", "client", ");", "\u0120"], "docstring_tokens": ["Would", "\u0120you", "\u0120mind", "\u0120removing", "\u0120the", "\u0120default", "\u0120parameter", "\u0120above", "?", "\u0120(", "I", "\u0120doubt", "\u0120I", "'ll", "\u0120ever", "\u0120use", "\u0120defaults", "\u0120again", "\u0120since", "\u0120you", "\u0120still", "\u0120have", "\u0120to", "\u0120protect", "\u0120against", "\u0120call", "ers", "\u0120explicitly", "\u0120passing", "\u0120`", "null", "`", "\u0120or", "\u0120`", "und", "efined", "`", ")"]}
{"function": "@@ -2186,7 +2186,7 @@ class WebElement { if (!this.driver_.fileDetector_) { return this.schedule_( new command.Command(command.Name.SEND_KEYS_TO_ELEMENT). - setParameter('text', keys). + setParameter('text', keys.then(keys => keys.join(''))). setParameter('value', keys), 'WebElement.sendKeys()'); }", "text": "Also update line 2205 below", "function_tokens": ["@@", "\u0120-", "2", "186", ",", "7", "\u0120+", "2", "186", ",", "7", "\u0120@@", "\u0120class", "\u0120Web", "Element", "\u0120{", "\u0120if", "\u0120(!", "this", ".", "driver", "_.", "file", "Det", "ector", "_", ")", "\u0120{", "\u0120return", "\u0120this", ".", "sche", "dule", "_(", "\u0120new", "\u0120command", ".", "Command", "(", "command", ".", "Name", ".", "S", "END", "_", "KE", "YS", "_", "TO", "_", "E", "LE", "MENT", ").", "\u0120-", "\u0120set", "Parameter", "('", "text", "',", "\u0120keys", ").", "\u0120+", "\u0120set", "Parameter", "('", "text", "',", "\u0120keys", ".", "then", "(", "keys", "\u0120=>", "\u0120keys", ".", "join", "(", "''", "))", ").", "\u0120set", "Parameter", "('", "value", "',", "\u0120keys", "),", "\u0120'", "Web", "Element", ".", "send", "Keys", "()", "');", "\u0120}"], "docstring_tokens": ["Also", "\u0120update", "\u0120line", "\u0120220", "5", "\u0120below"]}
{"function": "@@ -39,6 +39,7 @@ func (p *Provisioner) ProvisionHostPath(opts pvController.VolumeOptions, volumeC name := opts.PVName stgType := volumeConfig.GetStorageType() saName := getOpenEBSServiceAccountName() + shared := volumeConfig.GetSharedMountValue() path, err := volumeConfig.GetPath() if err != nil {", "text": "n_: It is a good practice to name the variable to indicate what they contain. In this case since `shared` is supposed to have boolean, calling it: `isShared` can help in the readability of the code.", "function_tokens": ["@@", "\u0120-", "39", ",", "6", "\u0120+", "39", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "p", "\u0120*", "Pro", "vision", "er", ")", "\u0120Provision", "Host", "Path", "(", "op", "ts", "\u0120p", "v", "Controller", ".", "Volume", "Options", ",", "\u0120volume", "C", "\u0120name", "\u0120:=", "\u0120opt", "s", ".", "P", "V", "Name", "\u0120st", "g", "Type", "\u0120:=", "\u0120volume", "Config", ".", "Get", "Storage", "Type", "()", "\u0120sa", "Name", "\u0120:=", "\u0120get", "Open", "E", "BS", "Service", "Account", "Name", "()", "\u0120+", "\u0120shared", "\u0120:=", "\u0120volume", "Config", ".", "Get", "Sh", "ared", "Mount", "Value", "()", "\u0120path", ",", "\u0120err", "\u0120:=", "\u0120volume", "Config", ".", "Get", "Path", "()", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{"], "docstring_tokens": ["n", "_", ":", "\u0120It", "\u0120is", "\u0120a", "\u0120good", "\u0120practice", "\u0120to", "\u0120name", "\u0120the", "\u0120variable", "\u0120to", "\u0120indicate", "\u0120what", "\u0120they", "\u0120contain", ".", "\u0120In", "\u0120this", "\u0120case", "\u0120since", "\u0120`", "shared", "`", "\u0120is", "\u0120supposed", "\u0120to", "\u0120have", "\u0120boolean", ",", "\u0120calling", "\u0120it", ":", "\u0120`", "is", "Sh", "ared", "`", "\u0120can", "\u0120help", "\u0120in", "\u0120the", "\u0120read", "ability", "\u0120of", "\u0120the", "\u0120code", "."]}
{"function": "@@ -85,7 +85,10 @@ export class ManualColumnFreeze extends BasePlugin { } /** - * Freezes the given column (add it to fixed columns). + * Freezes the specified column (i.e. adds it to fixed columns). + * + * `freezeColumn()` doesn't re-render the table, + * so you need to call the `render()` method afterward. * * @param {number} column Visual column index. */", "text": "I suppose it's a false-positive error. Maybe there is a way to configure the `eslint-*` package to accept `i.e. .... lower case` syntax  ", "function_tokens": ["@@", "\u0120-", "85", ",", "7", "\u0120+", "85", ",", "10", "\u0120@@", "\u0120export", "\u0120class", "\u0120Manual", "Column", "Free", "ze", "\u0120extends", "\u0120Base", "Plugin", "\u0120{", "\u0120}", "\u0120/**", "\u0120-", "\u0120*", "\u0120Free", "zes", "\u0120the", "\u0120given", "\u0120column", "\u0120(", "add", "\u0120it", "\u0120to", "\u0120fixed", "\u0120columns", ").", "\u0120+", "\u0120*", "\u0120Free", "zes", "\u0120the", "\u0120specified", "\u0120column", "\u0120(", "i", ".", "e", ".", "\u0120adds", "\u0120it", "\u0120to", "\u0120fixed", "\u0120columns", ").", "\u0120+", "\u0120*", "\u0120+", "\u0120*", "\u0120`", "free", "ze", "Column", "()", "`", "\u0120doesn", "'t", "\u0120re", "-", "render", "\u0120the", "\u0120table", ",", "\u0120+", "\u0120*", "\u0120so", "\u0120you", "\u0120need", "\u0120to", "\u0120call", "\u0120the", "\u0120`", "render", "()", "`", "\u0120method", "\u0120afterward", ".", "\u0120*", "\u0120*", "\u0120@", "param", "\u0120{", "number", "}", "\u0120column", "\u0120Visual", "\u0120column", "\u0120index", ".", "\u0120*/"], "docstring_tokens": ["I", "\u0120suppose", "\u0120it", "'s", "\u0120a", "\u0120false", "-", "positive", "\u0120error", ".", "\u0120Maybe", "\u0120there", "\u0120is", "\u0120a", "\u0120way", "\u0120to", "\u0120configure", "\u0120the", "\u0120`", "es", "l", "int", "-", "*", "`", "\u0120package", "\u0120to", "\u0120accept", "\u0120`", "i", ".", "e", ".", "\u0120....", "\u0120lower", "\u0120case", "`", "\u0120syntax", "\u0120", "\u0120"]}
{"function": "@@ -133,7 +133,7 @@ namespace OpenTelemetry.Trace private void RunGetRequestedDataOtherSampler(Activity activity) { ActivityContext parentContext; - if (string.IsNullOrEmpty(activity.ParentId)) + if (string.IsNullOrEmpty(activity.ParentId) || activity.ParentSpanId.ToHexString().Equals(\"0000000000000000\")) { parentContext = default; }", "text": "this maynot be a perf issue, if ToHexString() is not actually allocating a string, but returns the caches string value. to be confirmed.", "function_tokens": ["@@", "\u0120-", "133", ",", "7", "\u0120+", "133", ",", "7", "\u0120@@", "\u0120namespace", "\u0120Open", "Tele", "metry", ".", "Tr", "ace", "\u0120private", "\u0120void", "\u0120Run", "Get", "Request", "ed", "Data", "Other", "Sam", "pler", "(", "Activity", "\u0120activity", ")", "\u0120{", "\u0120Activity", "Context", "\u0120parent", "Context", ";", "\u0120-", "\u0120if", "\u0120(", "string", ".", "Is", "Null", "Or", "Empty", "(", "activity", ".", "Parent", "Id", "))", "\u0120+", "\u0120if", "\u0120(", "string", ".", "Is", "Null", "Or", "Empty", "(", "activity", ".", "Parent", "Id", ")", "\u0120||", "\u0120activity", ".", "Parent", "Sp", "an", "Id", ".", "To", "H", "ex", "String", "().", "Equ", "als", "(\"", "0000000000000000", "\"))", "\u0120{", "\u0120parent", "Context", "\u0120=", "\u0120default", ";", "\u0120}"], "docstring_tokens": ["this", "\u0120may", "not", "\u0120be", "\u0120a", "\u0120perf", "\u0120issue", ",", "\u0120if", "\u0120To", "H", "ex", "String", "()", "\u0120is", "\u0120not", "\u0120actually", "\u0120all", "ocating", "\u0120a", "\u0120string", ",", "\u0120but", "\u0120returns", "\u0120the", "\u0120caches", "\u0120string", "\u0120value", ".", "\u0120to", "\u0120be", "\u0120confirmed", "."]}
{"function": "@@ -114,11 +114,16 @@ func (w *watcher) run(ctx context.Context, provider imageprovider.Provider, inte updates = append(updates, u...) } if len(updates) == 0 { - w.logger.Info(\"no image to be updated\") + w.logger.Info(\"no image to be updated\", + zap.String(\"image-provider\", provider.Name()), + ) continue } if err := update(updates); err != nil { - w.logger.Error(\"failed to update image\", zap.Error(err)) + w.logger.Error(\"failed to update image\", zap.String(\"image-provider\", + provider.Name()), + zap.Error(err), + ) continue } }", "text": "`zap.String(\"image-provider\", provider.Name())` should be in a same line.", "function_tokens": ["@@", "\u0120-", "114", ",", "11", "\u0120+", "114", ",", "16", "\u0120@@", "\u0120func", "\u0120(", "w", "\u0120*", "w", "atcher", ")", "\u0120run", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120provider", "\u0120image", "prov", "ider", ".", "Provider", ",", "\u0120int", "e", "\u0120updates", "\u0120=", "\u0120append", "(", "up", "dates", ",", "\u0120u", "...)", "\u0120}", "\u0120if", "\u0120len", "(", "up", "dates", ")", "\u0120==", "\u01200", "\u0120{", "\u0120-", "\u0120w", ".", "log", "ger", ".", "Info", "(\"", "no", "\u0120image", "\u0120to", "\u0120be", "\u0120updated", "\")", "\u0120+", "\u0120w", ".", "log", "ger", ".", "Info", "(\"", "no", "\u0120image", "\u0120to", "\u0120be", "\u0120updated", "\",", "\u0120+", "\u0120z", "ap", ".", "String", "(\"", "image", "-", "prov", "ider", "\",", "\u0120provider", ".", "Name", "()", "),", "\u0120+", "\u0120)", "\u0120continue", "\u0120}", "\u0120if", "\u0120err", "\u0120:=", "\u0120update", "(", "up", "dates", ");", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120-", "\u0120w", ".", "log", "ger", ".", "Error", "(\"", "failed", "\u0120to", "\u0120update", "\u0120image", "\",", "\u0120z", "ap", ".", "Error", "(", "err", "))", "\u0120+", "\u0120w", ".", "log", "ger", ".", "Error", "(\"", "failed", "\u0120to", "\u0120update", "\u0120image", "\",", "\u0120z", "ap", ".", "String", "(\"", "image", "-", "prov", "ider", "\",", "\u0120+", "\u0120provider", ".", "Name", "()", "),", "\u0120+", "\u0120z", "ap", ".", "Error", "(", "err", "),", "\u0120+", "\u0120)", "\u0120continue", "\u0120}", "\u0120}"], "docstring_tokens": ["`", "z", "ap", ".", "String", "(\"", "image", "-", "prov", "ider", "\",", "\u0120provider", ".", "Name", "())", "`", "\u0120should", "\u0120be", "\u0120in", "\u0120a", "\u0120same", "\u0120line", "."]}
{"function": "@@ -1,8 +1,6 @@ /*exported DqElement */ function truncate(str, maxLength) { - 'use strict'; - maxLength = maxLength || 300; if (str.length > maxLength) {", "text": "Why this deletion?", "function_tokens": ["@@", "\u0120-", "1", ",", "8", "\u0120+", "1", ",", "6", "\u0120@@", "\u0120/*", "ex", "ported", "\u0120D", "q", "Element", "\u0120*/", "\u0120function", "\u0120trunc", "ate", "(", "str", ",", "\u0120max", "Length", ")", "\u0120{", "\u0120-", "\u0120'", "use", "\u0120strict", "';", "\u0120-", "\u0120max", "Length", "\u0120=", "\u0120max", "Length", "\u0120||", "\u0120300", ";", "\u0120if", "\u0120(", "str", ".", "length", "\u0120>", "\u0120max", "Length", ")", "\u0120{"], "docstring_tokens": ["Why", "\u0120this", "\u0120deletion", "?"]}
{"function": "@@ -419,7 +419,10 @@ class S3KeyTest(unittest.TestCase): remote_metadata = check._get_remote_metadata() # TODO: investigate whether encoding ' ' as '%20' makes sense - self.assertEqual(check.cache_control, 'public,%20max-age=500') + self.assertIn( + check.cache_control, + ('public,%20max-age=500', 'public, max-age=500') + ) self.assertEqual(remote_metadata['cache-control'], 'public,%20max-age=500') self.assertEqual(check.get_metadata('test-plus'), 'A plus (+)') self.assertEqual(check.content_disposition, 'filename=Sch%C3%B6ne%20Zeit.txt')", "text": "This change looks unrelated to the CL description?", "function_tokens": ["@@", "\u0120-", "419", ",", "7", "\u0120+", "419", ",", "10", "\u0120@@", "\u0120class", "\u0120S", "3", "Key", "Test", "(", "un", "itt", "est", ".", "Test", "Case", "):", "\u0120remote", "_", "metadata", "\u0120=", "\u0120check", "._", "get", "_", "remote", "_", "metadata", "()", "\u0120#", "\u0120TOD", "O", ":", "\u0120investigate", "\u0120whether", "\u0120encoding", "\u0120'", "\u0120'", "\u0120as", "\u0120'", "%", "20", "'", "\u0120makes", "\u0120sense", "\u0120-", "\u0120self", ".", "assert", "E", "qual", "(", "check", ".", "cache", "_", "control", ",", "\u0120'", "public", ",", "%", "20", "max", "-", "age", "=", "500", "')", "\u0120+", "\u0120self", ".", "assert", "In", "(", "\u0120+", "\u0120check", ".", "cache", "_", "control", ",", "\u0120+", "\u0120('", "public", ",", "%", "20", "max", "-", "age", "=", "500", "',", "\u0120'", "public", ",", "\u0120max", "-", "age", "=", "500", "')", "\u0120+", "\u0120)", "\u0120self", ".", "assert", "E", "qual", "(", "remote", "_", "metadata", "['", "cache", "-", "control", "'", "],", "\u0120'", "public", ",", "%", "20", "max", "-", "age", "=", "500", "')", "\u0120self", ".", "assert", "E", "qual", "(", "check", ".", "get", "_", "metadata", "('", "test", "-", "plus", "'),", "\u0120'", "A", "\u0120plus", "\u0120(+", ")", "')", "\u0120self", ".", "assert", "E", "qual", "(", "check", ".", "content", "_", "dis", "position", ",", "\u0120'", "filename", "=", "Sch", "%", "C", "3", "%", "B", "6", "ne", "%", "20", "Ze", "it", ".", "txt", "')"], "docstring_tokens": ["This", "\u0120change", "\u0120looks", "\u0120unrelated", "\u0120to", "\u0120the", "\u0120CL", "\u0120description", "?"]}
{"function": "@@ -18,7 +18,7 @@ class DedupTest : public QueryTestBase { void SetUp() override { QueryTestBase::SetUp(); } }; -#define DEDUP_RESUTL_CHECK(inputName, outputName, sentence, expected) \\ +#define DEDUP_RESULT_CHECK(inputName, outputName, sentence, expected) \\ do { \\ qctx_->symTable()->newVariable(outputName); \\ auto yieldSentence = getYieldSentence(sentence, qctx_.get()); \\", "text": "I'm not certain that `res`+`utl` isn't a thing.", "function_tokens": ["@@", "\u0120-", "18", ",", "7", "\u0120+", "18", ",", "7", "\u0120@@", "\u0120class", "\u0120Ded", "up", "Test", "\u0120:", "\u0120public", "\u0120Query", "Test", "Base", "\u0120{", "\u0120void", "\u0120Set", "Up", "()", "\u0120override", "\u0120{", "\u0120Query", "Test", "Base", "::", "Set", "Up", "();", "\u0120}", "\u0120};", "\u0120-", "#", "define", "\u0120D", "ED", "UP", "_", "RES", "UT", "L", "_", "CHECK", "(", "input", "Name", ",", "\u0120output", "Name", ",", "\u0120sentence", ",", "\u0120expected", ")", "\u0120\\", "\u0120+#", "define", "\u0120D", "ED", "UP", "_", "RES", "ULT", "_", "CHECK", "(", "input", "Name", ",", "\u0120output", "Name", ",", "\u0120sentence", ",", "\u0120expected", ")", "\u0120\\", "\u0120do", "\u0120{", "\u0120\\", "\u0120q", "ctx", "_", "->", "sym", "Table", "()", "->", "new", "Variable", "(", "output", "Name", ");", "\u0120\\", "\u0120auto", "\u0120yield", "Sent", "ence", "\u0120=", "\u0120get", "Y", "ield", "Sent", "ence", "(", "sent", "ence", ",", "\u0120q", "ctx", "_.", "get", "());", "\u0120\\"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120certain", "\u0120that", "\u0120`", "res", "`", "+", "`", "ut", "l", "`", "\u0120isn", "'t", "\u0120a", "\u0120thing", "."]}
{"function": "@@ -182,6 +182,7 @@ public class FetchActiveFlowDao { + \" LEFT JOIN \" + \" executors et ON ex.executor_id = et.id\" + \" WHERE ex.status NOT IN (\" + + Status.EXECUTION_STOPPED.getNumVal() + \", \" + Status.SUCCEEDED.getNumVal() + \", \" + Status.KILLED.getNumVal() + \", \" + Status.FAILED.getNumVal() + \")\";", "text": "This method can cause bugs. Why don't you use list of finalize statuses and then use join by comma and that will give you correct value. Use Apache Commons Lang library List<Integer> list = Arrays.asList(1,2,3,4,5,6,7); String str = org.apache.commons.lang.StringUtils.join(list, \",\"); You can use it at multiple places shown in this diff.", "function_tokens": ["@@", "\u0120-", "182", ",", "6", "\u0120+", "182", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120F", "etch", "Active", "Flow", "D", "ao", "\u0120{", "\u0120+", "\u0120\"", "\u0120LE", "FT", "\u0120JO", "IN", "\u0120\"", "\u0120+", "\u0120\"", "\u0120execut", "ors", "\u0120et", "\u0120ON", "\u0120ex", ".", "exec", "utor", "_", "id", "\u0120=", "\u0120et", ".", "id", "\"", "\u0120+", "\u0120\"", "\u0120WHERE", "\u0120ex", ".", "status", "\u0120NOT", "\u0120IN", "\u0120(\"", "\u0120+", "\u0120+", "\u0120Status", ".", "EX", "EC", "UTION", "_", "ST", "OP", "P", "ED", ".", "get", "Num", "Val", "()", "\u0120+", "\u0120\",", "\u0120\"", "\u0120+", "\u0120Status", ".", "SU", "CC", "EED", "ED", ".", "get", "Num", "Val", "()", "\u0120+", "\u0120\",", "\u0120\"", "\u0120+", "\u0120Status", ".", "K", "ILL", "ED", ".", "get", "Num", "Val", "()", "\u0120+", "\u0120\",", "\u0120\"", "\u0120+", "\u0120Status", ".", "FA", "IL", "ED", ".", "get", "Num", "Val", "()", "\u0120+", "\u0120\"", ")", "\";"], "docstring_tokens": ["This", "\u0120method", "\u0120can", "\u0120cause", "\u0120bugs", ".", "\u0120Why", "\u0120don", "'t", "\u0120you", "\u0120use", "\u0120list", "\u0120of", "\u0120final", "ize", "\u0120stat", "uses", "\u0120and", "\u0120then", "\u0120use", "\u0120join", "\u0120by", "\u0120comma", "\u0120and", "\u0120that", "\u0120will", "\u0120give", "\u0120you", "\u0120correct", "\u0120value", ".", "\u0120Use", "\u0120Apache", "\u0120Commons", "\u0120Lang", "\u0120library", "\u0120List", "<", "Integer", ">", "\u0120list", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ");", "\u0120String", "\u0120str", "\u0120=", "\u0120org", ".", "apache", ".", "comm", "ons", ".", "lang", ".", "String", "Ut", "ils", ".", "join", "(", "list", ",", "\u0120\"", ",\"", ");", "\u0120You", "\u0120can", "\u0120use", "\u0120it", "\u0120at", "\u0120multiple", "\u0120places", "\u0120shown", "\u0120in", "\u0120this", "\u0120diff", "."]}
{"function": "@@ -23,7 +23,10 @@ void wlr_input_device_init(struct wlr_input_device *dev, } void wlr_input_device_destroy(struct wlr_input_device *dev) { - if (!dev) return; + if (!dev) { + return; + } + if (dev->_device) { switch (dev->type) { case WLR_INPUT_DEVICE_KEYBOARD:", "text": "Merge with next condition", "function_tokens": ["@@", "\u0120-", "23", ",", "7", "\u0120+", "23", ",", "10", "\u0120@@", "\u0120void", "\u0120w", "lr", "_", "input", "_", "device", "_", "init", "(", "struct", "\u0120w", "lr", "_", "input", "_", "device", "\u0120*", "dev", ",", "\u0120}", "\u0120void", "\u0120w", "lr", "_", "input", "_", "device", "_", "destroy", "(", "struct", "\u0120w", "lr", "_", "input", "_", "device", "\u0120*", "dev", ")", "\u0120{", "\u0120-", "\u0120if", "\u0120(!", "dev", ")", "\u0120return", ";", "\u0120+", "\u0120if", "\u0120(!", "dev", ")", "\u0120{", "\u0120+", "\u0120return", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120if", "\u0120(", "dev", "->", "_", "device", ")", "\u0120{", "\u0120switch", "\u0120(", "dev", "->", "type", ")", "\u0120{", "\u0120case", "\u0120W", "LR", "_", "IN", "PUT", "_", "DE", "VICE", "_", "KEY", "BO", "ARD", ":"], "docstring_tokens": ["Mer", "ge", "\u0120with", "\u0120next", "\u0120condition"]}
{"function": "@@ -348,6 +348,7 @@ type appResourcesGetter interface { type taskDeployer interface { DeployTask(input *deploy.CreateTaskResourcesInput, opts ...cloudformation.StackOption) error + DeleteTask(task deploy.TaskStackInfo) error } type taskRunner interface {", "text": "Maybe add it when it is used.", "function_tokens": ["@@", "\u0120-", "348", ",", "6", "\u0120+", "348", ",", "7", "\u0120@@", "\u0120type", "\u0120app", "Resources", "Get", "ter", "\u0120interface", "\u0120{", "\u0120type", "\u0120task", "Deploy", "er", "\u0120interface", "\u0120{", "\u0120Deploy", "Task", "(", "input", "\u0120*", "de", "ploy", ".", "Create", "Task", "Resources", "Input", ",", "\u0120opt", "s", "\u0120...", "cloud", "formation", ".", "Stack", "Option", ")", "\u0120error", "\u0120+", "\u0120Delete", "Task", "(", "task", "\u0120deploy", ".", "Task", "Stack", "Info", ")", "\u0120error", "\u0120}", "\u0120type", "\u0120task", "Runner", "\u0120interface", "\u0120{"], "docstring_tokens": ["Maybe", "\u0120add", "\u0120it", "\u0120when", "\u0120it", "\u0120is", "\u0120used", "."]}
{"function": "@@ -36,3 +36,17 @@ TWO_ENABLED = {'scanners': [ {'name': 'cloudsql_acl', 'enabled': False}, {'name': 'iam_policy', 'enabled': True} ]} + +NONEXIST_ENABLED = {'scanners': [ + {'name': 'bigquery', 'enabled': False}, + {'name': 'bucket_acl', 'enabled': True}, + {'name': 'cloudsql_acl', 'enabled': False}, + {'name': 'non_exist_scanner', 'enabled': True} +]} + +ALL_EXIST = {'scanners': [ + {'name': 'bigquery', 'enabled': True}, + {'name': 'bucket_acl', 'enabled': True}, + {'name': 'cloudsql_acl', 'enabled': True}, + {'name': 'iam_policy', 'enabled': True} +]}", "text": "More clear naming: NONEXISTENT_ENABLED", "function_tokens": ["@@", "\u0120-", "36", ",", "3", "\u0120+", "36", ",", "17", "\u0120@@", "\u0120TWO", "_", "EN", "AB", "LED", "\u0120=", "\u0120{", "'", "sc", "anners", "':", "\u0120[", "\u0120{", "'", "name", "':", "\u0120'", "cloud", "sql", "_", "acl", "',", "\u0120'", "enabled", "':", "\u0120False", "},", "\u0120{", "'", "name", "':", "\u0120'", "iam", "_", "policy", "',", "\u0120'", "enabled", "':", "\u0120True", "}", "\u0120]", "}", "\u0120+", "\u0120+", "N", "ON", "EX", "IST", "_", "EN", "AB", "LED", "\u0120=", "\u0120{", "'", "sc", "anners", "':", "\u0120[", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "big", "query", "',", "\u0120'", "enabled", "':", "\u0120False", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "buck", "et", "_", "acl", "',", "\u0120'", "enabled", "':", "\u0120True", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "cloud", "sql", "_", "acl", "',", "\u0120'", "enabled", "':", "\u0120False", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "non", "_", "exist", "_", "scan", "ner", "',", "\u0120'", "enabled", "':", "\u0120True", "}", "\u0120+", "]}", "\u0120+", "\u0120+", "ALL", "_", "EX", "IST", "\u0120=", "\u0120{", "'", "sc", "anners", "':", "\u0120[", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "big", "query", "',", "\u0120'", "enabled", "':", "\u0120True", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "buck", "et", "_", "acl", "',", "\u0120'", "enabled", "':", "\u0120True", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "cloud", "sql", "_", "acl", "',", "\u0120'", "enabled", "':", "\u0120True", "},", "\u0120+", "\u0120{", "'", "name", "':", "\u0120'", "iam", "_", "policy", "',", "\u0120'", "enabled", "':", "\u0120True", "}", "\u0120+", "]}"], "docstring_tokens": ["More", "\u0120clear", "\u0120naming", ":", "\u0120NON", "EX", "IST", "ENT", "_", "EN", "AB", "LED"]}
{"function": "@@ -282,10 +282,10 @@ public class TypeUtil { switch (from.typeId()) { case INTEGER: - return to == Types.LongType.get(); + return to.equals(Types.LongType.get()); case FLOAT: - return to == Types.DoubleType.get(); + return to.equals(Types.DoubleType.get()); case DECIMAL: Types.DecimalType fromDecimal = (Types.DecimalType) from;", "text": "why is this change necessary?", "function_tokens": ["@@", "\u0120-", "282", ",", "10", "\u0120+", "282", ",", "10", "\u0120@@", "\u0120public", "\u0120class", "\u0120Type", "Ut", "il", "\u0120{", "\u0120switch", "\u0120(", "from", ".", "type", "Id", "())", "\u0120{", "\u0120case", "\u0120INT", "EG", "ER", ":", "\u0120-", "\u0120return", "\u0120to", "\u0120==", "\u0120Types", ".", "Long", "Type", ".", "get", "();", "\u0120+", "\u0120return", "\u0120to", ".", "equ", "als", "(", "Types", ".", "Long", "Type", ".", "get", "());", "\u0120case", "\u0120FL", "O", "AT", ":", "\u0120-", "\u0120return", "\u0120to", "\u0120==", "\u0120Types", ".", "Double", "Type", ".", "get", "();", "\u0120+", "\u0120return", "\u0120to", ".", "equ", "als", "(", "Types", ".", "Double", "Type", ".", "get", "());", "\u0120case", "\u0120DEC", "IM", "AL", ":", "\u0120Types", ".", "Dec", "imal", "Type", "\u0120from", "Dec", "imal", "\u0120=", "\u0120(", "Types", ".", "Dec", "imal", "Type", ")", "\u0120from", ";"], "docstring_tokens": ["why", "\u0120is", "\u0120this", "\u0120change", "\u0120necessary", "?"]}
{"function": "@@ -178,9 +178,8 @@ public class SchemaTypeTable implements ImportTypeTable, SchemaTypeFormatter { @Override public String getFullNameFor(TypeModel type) { - // TODO(andrealin): Remove this hack when null response types are implemented. - if (type == null) { - return \"nullFullName\"; + if (type.isEmptyType()) { + return \"java.lang.Void\"; } if (type instanceof DiscoveryRequestType) { Method method = ((DiscoveryRequestType) type).parentMethod().getDiscoMethod();", "text": "make a SchemaTypeNameConverter.getTypeNameForEmptyType() and call that here.", "function_tokens": ["@@", "\u0120-", "178", ",", "9", "\u0120+", "178", ",", "8", "\u0120@@", "\u0120public", "\u0120class", "\u0120Sche", "ma", "Type", "Table", "\u0120implements", "\u0120Import", "Type", "Table", ",", "\u0120Sche", "ma", "Type", "Form", "atter", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120String", "\u0120get", "Full", "Name", "For", "(", "Type", "Model", "\u0120type", ")", "\u0120{", "\u0120-", "\u0120//", "\u0120TOD", "O", "(", "and", "real", "in", "):", "\u0120Remove", "\u0120this", "\u0120hack", "\u0120when", "\u0120null", "\u0120response", "\u0120types", "\u0120are", "\u0120implemented", ".", "\u0120-", "\u0120if", "\u0120(", "type", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120-", "\u0120return", "\u0120\"", "null", "Full", "Name", "\";", "\u0120+", "\u0120if", "\u0120(", "type", ".", "is", "Empty", "Type", "())", "\u0120{", "\u0120+", "\u0120return", "\u0120\"", "java", ".", "lang", ".", "V", "oid", "\";", "\u0120}", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Discovery", "Request", "Type", ")", "\u0120{", "\u0120Method", "\u0120method", "\u0120=", "\u0120((", "D", "iscovery", "Request", "Type", ")", "\u0120type", ").", "parent", "Method", "().", "get", "D", "isco", "Method", "();"], "docstring_tokens": ["make", "\u0120a", "\u0120Sche", "ma", "Type", "Name", "Con", "ver", "ter", ".", "get", "Type", "Name", "For", "Empty", "Type", "()", "\u0120and", "\u0120call", "\u0120that", "\u0120here", "."]}
{"function": "@@ -26,7 +26,10 @@ class TinyMCELanguage extends AbstractSmartyPlugin public function __construct(Request $request) { - $this->locale = $request->getSession()->getLang()->getLocale(); + if($request->getSession() != null) + $this->locale = $request->getSession()->getLang()->getLocale(); + else + $this->locale = Lang::getDefaultLanguage()->getLocale(); } public function guessTinyMCELanguage($params, \\Smarty_Internal_Template $template)", "text": "Use braces on your conditional structures please", "function_tokens": ["@@", "\u0120-", "26", ",", "7", "\u0120+", "26", ",", "10", "\u0120@@", "\u0120class", "\u0120Tiny", "MC", "EL", "anguage", "\u0120extends", "\u0120Abstract", "Sm", "arty", "Plugin", "\u0120public", "\u0120function", "\u0120__", "construct", "(", "Request", "\u0120$", "request", ")", "\u0120{", "\u0120-", "\u0120$", "this", "->", "loc", "ale", "\u0120=", "\u0120$", "request", "->", "get", "Session", "()", "->", "get", "L", "ang", "()", "->", "get", "Loc", "ale", "();", "\u0120+", "\u0120if", "($", "request", "->", "get", "Session", "()", "\u0120!=", "\u0120null", ")", "\u0120+", "\u0120$", "this", "->", "loc", "ale", "\u0120=", "\u0120$", "request", "->", "get", "Session", "()", "->", "get", "L", "ang", "()", "->", "get", "Loc", "ale", "();", "\u0120+", "\u0120else", "\u0120+", "\u0120$", "this", "->", "loc", "ale", "\u0120=", "\u0120Lang", "::", "get", "Default", "Language", "()", "->", "get", "Loc", "ale", "();", "\u0120}", "\u0120public", "\u0120function", "\u0120guess", "T", "iny", "MC", "EL", "anguage", "($", "params", ",", "\u0120\\", "Sm", "arty", "_", "Internal", "_", "Template", "\u0120$", "template", ")"], "docstring_tokens": ["Use", "\u0120braces", "\u0120on", "\u0120your", "\u0120conditional", "\u0120structures", "\u0120please"]}
{"function": "@@ -16,6 +16,7 @@ DECLARE_string(u); DECLARE_string(p); +DEFINE_bool(enable_history, false, \"Whether to force saving the command history\"); namespace nebula { namespace graph {", "text": "Great God, I have a question. This \".nebula_history\" file is used to save history commands. Is there a file size limit? When the file is large, does it take a long time to start initialization (loadHistory)? How did you think about this? Thx.", "function_tokens": ["@@", "\u0120-", "16", ",", "6", "\u0120+", "16", ",", "7", "\u0120@@", "\u0120DEC", "L", "ARE", "_", "string", "(", "u", ");", "\u0120DEC", "L", "ARE", "_", "string", "(", "p", ");", "\u0120+", "DE", "FINE", "_", "bool", "(", "enable", "_", "history", ",", "\u0120false", ",", "\u0120\"", "Whether", "\u0120to", "\u0120force", "\u0120saving", "\u0120the", "\u0120command", "\u0120history", "\");", "\u0120namespace", "\u0120neb", "ula", "\u0120{", "\u0120namespace", "\u0120graph", "\u0120{"], "docstring_tokens": ["Great", "\u0120God", ",", "\u0120I", "\u0120have", "\u0120a", "\u0120question", ".", "\u0120This", "\u0120\".", "ne", "b", "ula", "_", "history", "\"", "\u0120file", "\u0120is", "\u0120used", "\u0120to", "\u0120save", "\u0120history", "\u0120commands", ".", "\u0120Is", "\u0120there", "\u0120a", "\u0120file", "\u0120size", "\u0120limit", "?", "\u0120When", "\u0120the", "\u0120file", "\u0120is", "\u0120large", ",", "\u0120does", "\u0120it", "\u0120take", "\u0120a", "\u0120long", "\u0120time", "\u0120to", "\u0120start", "\u0120initialization", "\u0120(", "load", "History", ")?", "\u0120How", "\u0120did", "\u0120you", "\u0120think", "\u0120about", "\u0120this", "?", "\u0120Th", "x", "."]}
{"function": "@@ -1004,8 +1004,9 @@ static void parseRecord (tokenInfo *const token) */ if (!isType (token, TOKEN_OPEN_PAREN)) readToken (token); + if (!isType (token, TOKEN_OPEN_PAREN)) + return; - Assert (isType (token, TOKEN_OPEN_PAREN)); do { if (isType (token, TOKEN_COMMA) ||", "text": "Isn't this the same check as two lines above?", "function_tokens": ["@@", "\u0120-", "100", "4", ",", "8", "\u0120+", "100", "4", ",", "9", "\u0120@@", "\u0120static", "\u0120void", "\u0120parse", "Record", "\u0120(", "token", "Info", "\u0120*", "const", "\u0120token", ")", "\u0120*/", "\u0120if", "\u0120(!", "is", "Type", "\u0120(", "token", ",", "\u0120TO", "KEN", "_", "OP", "EN", "_", "PAR", "EN", "))", "\u0120read", "Token", "\u0120(", "token", ");", "\u0120+", "\u0120if", "\u0120(!", "is", "Type", "\u0120(", "token", ",", "\u0120TO", "KEN", "_", "OP", "EN", "_", "PAR", "EN", "))", "\u0120+", "\u0120return", ";", "\u0120-", "\u0120Ass", "ert", "\u0120(", "is", "Type", "\u0120(", "token", ",", "\u0120TO", "KEN", "_", "OP", "EN", "_", "PAR", "EN", "));", "\u0120do", "\u0120{", "\u0120if", "\u0120(", "is", "Type", "\u0120(", "token", ",", "\u0120TO", "KEN", "_", "COM", "MA", ")", "\u0120||"], "docstring_tokens": ["Isn", "'t", "\u0120this", "\u0120the", "\u0120same", "\u0120check", "\u0120as", "\u0120two", "\u0120lines", "\u0120above", "?"]}
{"function": "@@ -18,8 +18,11 @@ from mitmproxy import io from mitmproxy import log from mitmproxy import version from mitmproxy import optmanager +from mitmproxy import options import mitmproxy.tools.web.master # noqa +CONFIG_PATH = os.path.join(options.CA_DIR, 'config.yaml') + def flow_to_json(flow: mitmproxy.flow.Flow) -> dict: \"\"\"", "text": "Don't redefine, just import the existing one in `cmdline.py`. :)", "function_tokens": ["@@", "\u0120-", "18", ",", "8", "\u0120+", "18", ",", "11", "\u0120@@", "\u0120from", "\u0120mit", "m", "proxy", "\u0120import", "\u0120io", "\u0120from", "\u0120mit", "m", "proxy", "\u0120import", "\u0120log", "\u0120from", "\u0120mit", "m", "proxy", "\u0120import", "\u0120version", "\u0120from", "\u0120mit", "m", "proxy", "\u0120import", "\u0120opt", "manager", "\u0120+", "from", "\u0120mit", "m", "proxy", "\u0120import", "\u0120options", "\u0120import", "\u0120mit", "m", "proxy", ".", "tools", ".", "web", ".", "master", "\u0120#", "\u0120no", "qa", "\u0120+", "CON", "FIG", "_", "PATH", "\u0120=", "\u0120os", ".", "path", ".", "join", "(", "options", ".", "CA", "_", "DIR", ",", "\u0120'", "config", ".", "y", "aml", "')", "\u0120+", "\u0120def", "\u0120flow", "_", "to", "_", "json", "(", "flow", ":", "\u0120mit", "m", "proxy", ".", "flow", ".", "Flow", ")", "\u0120->", "\u0120dict", ":", "\u0120\"\"\""], "docstring_tokens": ["Don", "'t", "\u0120redef", "ine", ",", "\u0120just", "\u0120import", "\u0120the", "\u0120existing", "\u0120one", "\u0120in", "\u0120`", "cmd", "line", ".", "py", "`.", "\u0120:)"]}
{"function": "@@ -92,7 +92,8 @@ module Mongoid # # @since 2.0.0.rc.7 def process_attribute(name, value) - if store_as = aliased_fields.invert[name.to_s] + responds = respond_to?(\"#{name}=\") + if !responds && store_as = aliased_fields.invert[name.to_s] name = store_as end responds = respond_to?(\"#{name}=\")", "text": "why not call `respond_to?(\"#{name}=\")` from the `if` line?", "function_tokens": ["@@", "\u0120-", "92", ",", "7", "\u0120+", "92", ",", "8", "\u0120@@", "\u0120module", "\u0120Mong", "oid", "\u0120#", "\u0120#", "\u0120@", "since", "\u01202", ".", "0", ".", "0", ".", "rc", ".", "7", "\u0120def", "\u0120process", "_", "attribute", "(", "name", ",", "\u0120value", ")", "\u0120-", "\u0120if", "\u0120store", "_", "as", "\u0120=", "\u0120ali", "ased", "_", "fields", ".", "in", "vert", "[", "name", ".", "to", "_", "s", "]", "\u0120+", "\u0120responds", "\u0120=", "\u0120respond", "_", "to", "?", "(\"", "#", "{", "name", "}", "=\"", ")", "\u0120+", "\u0120if", "\u0120!", "respond", "s", "\u0120&&", "\u0120store", "_", "as", "\u0120=", "\u0120ali", "ased", "_", "fields", ".", "in", "vert", "[", "name", ".", "to", "_", "s", "]", "\u0120name", "\u0120=", "\u0120store", "_", "as", "\u0120end", "\u0120responds", "\u0120=", "\u0120respond", "_", "to", "?", "(\"", "#", "{", "name", "}", "=\"", ")"], "docstring_tokens": ["why", "\u0120not", "\u0120call", "\u0120`", "respond", "_", "to", "?", "(\"", "#", "{", "name", "}", "=\"", ")", "`", "\u0120from", "\u0120the", "\u0120`", "if", "`", "\u0120line", "?"]}
{"function": "@@ -215,7 +215,8 @@ public final class BlazeCidrLauncher extends CidrLauncher { workingDir = workspaceRootDirectory; } - GeneralCommandLine commandLine = new GeneralCommandLine(runner.executableToDebug.getPath()); + GeneralCommandLine commandLine = new GeneralCommandLine(runner.executableToDebug.getPath()) + .withWorkDirectory(workingDir); commandLine.addParameters(handlerState.getExeFlagsState().getFlagsForExternalProcesses()); commandLine.addParameters(handlerState.getTestArgs());", "text": "This was properly set above as `<target>.runfiles/<workspace_name>` (with a fallback to workspace root dir) but never used past this line.", "function_tokens": ["@@", "\u0120-", "215", ",", "7", "\u0120+", "215", ",", "8", "\u0120@@", "\u0120public", "\u0120final", "\u0120class", "\u0120Blaze", "C", "id", "r", "Laun", "cher", "\u0120extends", "\u0120C", "id", "r", "Laun", "cher", "\u0120{", "\u0120working", "Dir", "\u0120=", "\u0120workspace", "Root", "Directory", ";", "\u0120}", "\u0120-", "\u0120General", "Command", "Line", "\u0120command", "Line", "\u0120=", "\u0120new", "\u0120General", "Command", "Line", "(", "runner", ".", "exec", "utable", "To", "Debug", ".", "get", "Path", "());", "\u0120+", "\u0120General", "Command", "Line", "\u0120command", "Line", "\u0120=", "\u0120new", "\u0120General", "Command", "Line", "(", "runner", ".", "exec", "utable", "To", "Debug", ".", "get", "Path", "())", "\u0120+", "\u0120.", "with", "Work", "Directory", "(", "working", "Dir", ");", "\u0120command", "Line", ".", "add", "Parameters", "(", "handler", "State", ".", "get", "Ex", "e", "Flags", "State", "().", "get", "Flags", "For", "External", "Process", "es", "());", "\u0120command", "Line", ".", "add", "Parameters", "(", "handler", "State", ".", "get", "Test", "Args", "());"], "docstring_tokens": ["This", "\u0120was", "\u0120properly", "\u0120set", "\u0120above", "\u0120as", "\u0120`", "<", "target", ">.", "run", "files", "/", "<", "works", "pace", "_", "name", ">", "`", "\u0120(", "with", "\u0120a", "\u0120fall", "back", "\u0120to", "\u0120workspace", "\u0120root", "\u0120dir", ")", "\u0120but", "\u0120never", "\u0120used", "\u0120past", "\u0120this", "\u0120line", "."]}
{"function": "@@ -0,0 +1,13 @@ +using System; +using System.Collections.Generic; +using System.Linq; +using System.Text; +using System.Threading.Tasks; +using MvvmCross.Core.Views; + +namespace MvvmCross.Uwp.Attributes +{ + public class MvxPagePresentationAttribute : MvxBasePresentationAttribute + { + } +}", "text": "Are all these namespaces required for this attribute?", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "13", "\u0120@@", "\u0120+", "using", "\u0120System", ";", "\u0120+", "using", "\u0120System", ".", "Col", "lections", ".", "Generic", ";", "\u0120+", "using", "\u0120System", ".", "Lin", "q", ";", "\u0120+", "using", "\u0120System", ".", "Text", ";", "\u0120+", "using", "\u0120System", ".", "Thread", "ing", ".", "T", "asks", ";", "\u0120+", "using", "\u0120M", "v", "vm", "Cross", ".", "Core", ".", "View", "s", ";", "\u0120+", "\u0120+", "names", "pace", "\u0120M", "v", "vm", "Cross", ".", "U", "wp", ".", "Attributes", "\u0120+", "{", "\u0120+", "\u0120public", "\u0120class", "\u0120M", "v", "x", "Page", "Present", "ation", "Attribute", "\u0120:", "\u0120M", "v", "x", "Base", "Present", "ation", "Attribute", "\u0120+", "\u0120{", "\u0120+", "\u0120}", "\u0120+", "}"], "docstring_tokens": ["Are", "\u0120all", "\u0120these", "\u0120names", "paces", "\u0120required", "\u0120for", "\u0120this", "\u0120attribute", "?"]}
{"function": "@@ -53,9 +53,12 @@ module Beaker result.stdout << std_out result.stderr << std_err result.exit_code = status.exitstatus + @logger.info(result.stdout) + @logger.info(result.stderr) end rescue => e result.stderr << e.inspect + @logger.info(result.stderr) result.exit_code = 1 end ", "text": "Given this may be used and printed in other ways, isn't `debug` more appropriate?", "function_tokens": ["@@", "\u0120-", "53", ",", "9", "\u0120+", "53", ",", "12", "\u0120@@", "\u0120module", "\u0120Be", "aker", "\u0120result", ".", "std", "out", "\u0120<<", "\u0120std", "_", "out", "\u0120result", ".", "st", "der", "r", "\u0120<<", "\u0120std", "_", "err", "\u0120result", ".", "exit", "_", "code", "\u0120=", "\u0120status", ".", "exit", "status", "\u0120+", "\u0120@", "log", "ger", ".", "info", "(", "result", ".", "std", "out", ")", "\u0120+", "\u0120@", "log", "ger", ".", "info", "(", "result", ".", "st", "der", "r", ")", "\u0120end", "\u0120rescue", "\u0120=>", "\u0120e", "\u0120result", ".", "st", "der", "r", "\u0120<<", "\u0120e", ".", "ins", "pect", "\u0120+", "\u0120@", "log", "ger", ".", "info", "(", "result", ".", "st", "der", "r", ")", "\u0120result", ".", "exit", "_", "code", "\u0120=", "\u01201", "\u0120end", "\u0120"], "docstring_tokens": ["Given", "\u0120this", "\u0120may", "\u0120be", "\u0120used", "\u0120and", "\u0120printed", "\u0120in", "\u0120other", "\u0120ways", ",", "\u0120isn", "'t", "\u0120`", "debug", "`", "\u0120more", "\u0120appropriate", "?"]}
{"function": "@@ -540,3 +540,7 @@ func (s *blockDiskStore) remove(id kbfsblock.ID) error { } return err } + +func (s blockDiskStore) clear() error { + return ioutil.RemoveAll(s.dir) +}", "text": "Looks like this is unused? Did you mean to call it when clearing the block journal?", "function_tokens": ["@@", "\u0120-", "540", ",", "3", "\u0120+", "540", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "s", "\u0120*", "block", "Disk", "Store", ")", "\u0120remove", "(", "id", "\u0120kb", "fs", "block", ".", "ID", ")", "\u0120error", "\u0120{", "\u0120}", "\u0120return", "\u0120err", "\u0120}", "\u0120+", "\u0120+", "func", "\u0120(", "s", "\u0120block", "Disk", "Store", ")", "\u0120clear", "()", "\u0120error", "\u0120{", "\u0120+", "\u0120return", "\u0120i", "out", "il", ".", "Remove", "All", "(", "s", ".", "dir", ")", "\u0120+", "}"], "docstring_tokens": ["Looks", "\u0120like", "\u0120this", "\u0120is", "\u0120unused", "?", "\u0120Did", "\u0120you", "\u0120mean", "\u0120to", "\u0120call", "\u0120it", "\u0120when", "\u0120clearing", "\u0120the", "\u0120block", "\u0120journal", "?"]}
{"function": "@@ -117,8 +117,10 @@ public class ExecutorManager extends EventHandler implements public ExecutorManager(Props props, ExecutorLoader loader, Map<String, Alerter> alters) throws ExecutorManagerException { + alerters = alters; azkProps = props; this.executorLoader = loader; + this.setupExecutors(); this.loadRunningFlows(); ", "text": "why named alters? how about this.alerts = alerts?", "function_tokens": ["@@", "\u0120-", "117", ",", "8", "\u0120+", "117", ",", "10", "\u0120@@", "\u0120public", "\u0120class", "\u0120Exec", "utor", "Manager", "\u0120extends", "\u0120Event", "Handler", "\u0120implements", "\u0120public", "\u0120Exec", "utor", "Manager", "(", "Pro", "ps", "\u0120props", ",", "\u0120Exec", "utor", "Loader", "\u0120loader", ",", "\u0120Map", "<", "String", ",", "\u0120Al", "er", "ter", ">", "\u0120alters", ")", "\u0120throws", "\u0120Exec", "utor", "Manager", "Exception", "\u0120{", "\u0120+", "\u0120al", "er", "ters", "\u0120=", "\u0120alters", ";", "\u0120az", "k", "Pro", "ps", "\u0120=", "\u0120props", ";", "\u0120this", ".", "exec", "utor", "Loader", "\u0120=", "\u0120loader", ";", "\u0120+", "\u0120this", ".", "setup", "Exec", "ut", "ors", "();", "\u0120this", ".", "load", "Running", "Fl", "ows", "();", "\u0120"], "docstring_tokens": ["why", "\u0120named", "\u0120alters", "?", "\u0120how", "\u0120about", "\u0120this", ".", "alert", "s", "\u0120=", "\u0120alerts", "?"]}
{"function": "@@ -1549,7 +1549,7 @@ func (js *jetStream) processStreamLeaderChange(mset *stream, isLeader bool) { resp.Error = jsError(err) s.sendAPIErrResponse(client, acc, subject, reply, _EMPTY_, s.jsonResponse(&resp)) } else { - resp.StreamInfo = &StreamInfo{Created: mset.createdTime(), State: mset.state(), Config: mset.config(), Cluster: js.clusterInfo(mset.raftGroup())} + resp.StreamInfo = &StreamInfo{Created: mset.createdTime(), State: mset.state(), Config: mset.config(), Cluster: js.clusterInfo(mset.raftGroup()), Sources: mset.sourcesInfo(), Mirror: mset.mirrorInfo()} s.sendAPIResponse(client, acc, subject, reply, _EMPTY_, s.jsonResponse(&resp)) if node := mset.raftNode(); node != nil { mset.sendCreateAdvisory()", "text": "not sure if this has to be here or not tbh", "function_tokens": ["@@", "\u0120-", "15", "49", ",", "7", "\u0120+", "15", "49", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "js", "\u0120*", "jet", "Stream", ")", "\u0120process", "Stream", "Leader", "Change", "(", "ms", "et", "\u0120*", "stream", ",", "\u0120is", "Leader", "\u0120bool", ")", "\u0120{", "\u0120resp", ".", "Error", "\u0120=", "\u0120js", "Error", "(", "err", ")", "\u0120s", ".", "send", "API", "Er", "r", "Response", "(", "client", ",", "\u0120acc", ",", "\u0120subject", ",", "\u0120reply", ",", "\u0120_", "EMP", "TY", "_", ",", "\u0120s", ".", "json", "Response", "(&", "resp", "))", "\u0120}", "\u0120else", "\u0120{", "\u0120-", "\u0120resp", ".", "Stream", "Info", "\u0120=", "\u0120&", "Stream", "Info", "{", "Created", ":", "\u0120m", "set", ".", "created", "Time", "(),", "\u0120State", ":", "\u0120m", "set", ".", "state", "(),", "\u0120Config", ":", "\u0120m", "set", ".", "config", "(),", "\u0120Cluster", ":", "\u0120js", ".", "cl", "uster", "Info", "(", "ms", "et", ".", "raft", "Group", "())", "}", "\u0120+", "\u0120resp", ".", "Stream", "Info", "\u0120=", "\u0120&", "Stream", "Info", "{", "Created", ":", "\u0120m", "set", ".", "created", "Time", "(),", "\u0120State", ":", "\u0120m", "set", ".", "state", "(),", "\u0120Config", ":", "\u0120m", "set", ".", "config", "(),", "\u0120Cluster", ":", "\u0120js", ".", "cl", "uster", "Info", "(", "ms", "et", ".", "raft", "Group", "()", "),", "\u0120Sources", ":", "\u0120m", "set", ".", "s", "ources", "Info", "(),", "\u0120Mirror", ":", "\u0120m", "set", ".", "mir", "ror", "Info", "()", "}", "\u0120s", ".", "send", "AP", "IR", "esp", "onse", "(", "client", ",", "\u0120acc", ",", "\u0120subject", ",", "\u0120reply", ",", "\u0120_", "EMP", "TY", "_", ",", "\u0120s", ".", "json", "Response", "(&", "resp", "))", "\u0120if", "\u0120node", "\u0120:=", "\u0120m", "set", ".", "raft", "Node", "();", "\u0120node", "\u0120!=", "\u0120nil", "\u0120{", "\u0120m", "set", ".", "send", "Create", "Ad", "visory", "()"], "docstring_tokens": ["not", "\u0120sure", "\u0120if", "\u0120this", "\u0120has", "\u0120to", "\u0120be", "\u0120here", "\u0120or", "\u0120not", "\u0120t", "bh"]}
{"function": "@@ -72,7 +72,12 @@ func newHarnessUsingAutodelete(ctx context.Context, t *testing.T) (drivertest.Ha } func (h *harness) CreateTopic(ctx context.Context, testName string) (dt driver.Topic, cleanup func(), err error) { + // Keep the topic entity name under 50 characters as per Azure limits. + // See https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-quotas topicName := fmt.Sprintf(\"%s-topic-%d\", sanitize(testName), atomic.AddUint32(&h.numTopics, 1)) + if len(topicName) > 50 { + topicName = topicName[:50] + } createTopic(ctx, topicName, h.ns, nil) ", "text": "There's a better fix for this in #1741, which should replace this.", "function_tokens": ["@@", "\u0120-", "72", ",", "7", "\u0120+", "72", ",", "12", "\u0120@@", "\u0120func", "\u0120new", "Har", "ness", "Using", "Aut", "ode", "lete", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120t", "\u0120*", "testing", ".", "T", ")", "\u0120(", "dri", "vert", "est", ".", "Ha", "\u0120}", "\u0120func", "\u0120(", "h", "\u0120*", "har", "ness", ")", "\u0120Create", "Topic", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120test", "Name", "\u0120string", ")", "\u0120(", "dt", "\u0120driver", ".", "Topic", ",", "\u0120cleanup", "\u0120func", "(),", "\u0120err", "\u0120error", ")", "\u0120{", "\u0120+", "\u0120//", "\u0120Keep", "\u0120the", "\u0120topic", "\u0120entity", "\u0120name", "\u0120under", "\u012050", "\u0120characters", "\u0120as", "\u0120per", "\u0120Azure", "\u0120limits", ".", "\u0120+", "\u0120//", "\u0120See", "\u0120https", "://", "docs", ".", "microsoft", ".", "com", "/", "en", "-", "us", "/", "az", "ure", "/", "service", "-", "bus", "-", "mess", "aging", "/", "service", "-", "bus", "-", "qu", "ot", "as", "\u0120topic", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "%", "s", "-", "topic", "-", "%", "d", "\",", "\u0120san", "it", "ize", "(", "test", "Name", "),", "\u0120atomic", ".", "Add", "U", "int", "32", "(&", "h", ".", "num", "Topics", ",", "\u01201", "))", "\u0120+", "\u0120if", "\u0120len", "(", "topic", "Name", ")", "\u0120>", "\u012050", "\u0120{", "\u0120+", "\u0120topic", "Name", "\u0120=", "\u0120topic", "Name", "[", ":", "50", "]", "\u0120+", "\u0120}", "\u0120create", "Topic", "(", "ctx", ",", "\u0120topic", "Name", ",", "\u0120h", ".", "ns", ",", "\u0120nil", ")", "\u0120"], "docstring_tokens": ["There", "'s", "\u0120a", "\u0120better", "\u0120fix", "\u0120for", "\u0120this", "\u0120in", "\u0120#", "17", "41", ",", "\u0120which", "\u0120should", "\u0120replace", "\u0120this", "."]}
{"function": "@@ -63,7 +63,7 @@ func (s *StreamMock) Close() error { func TestHandshake(t *testing.T) { logger := logging.New(ioutil.Discard, 0) info := Info{ - Address: \"node1\", + Address: []byte(\"node1\"), NetworkID: 0, Light: false, }", "text": "Use swarm.Address not []byte as type, and construct it from actual byteslice or use swarm.NewAddress if it is constructed from hex-encoded string.", "function_tokens": ["@@", "\u0120-", "63", ",", "7", "\u0120+", "63", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "s", "\u0120*", "Stream", "M", "ock", ")", "\u0120Close", "()", "\u0120error", "\u0120{", "\u0120func", "\u0120Test", "Hand", "shake", "(", "t", "\u0120*", "testing", ".", "T", ")", "\u0120{", "\u0120logger", "\u0120:=", "\u0120logging", ".", "New", "(", "i", "out", "il", ".", "Disc", "ard", ",", "\u01200", ")", "\u0120info", "\u0120:=", "\u0120Info", "{", "\u0120-", "\u0120Address", ":", "\u0120\"", "node", "1", "\",", "\u0120+", "\u0120Address", ":", "\u0120[]", "byte", "(\"", "node", "1", "\"),", "\u0120Network", "ID", ":", "\u01200", ",", "\u0120Light", ":", "\u0120false", ",", "\u0120}"], "docstring_tokens": ["Use", "\u0120swarm", ".", "Address", "\u0120not", "\u0120[]", "byte", "\u0120as", "\u0120type", ",", "\u0120and", "\u0120construct", "\u0120it", "\u0120from", "\u0120actual", "\u0120bytes", "l", "ice", "\u0120or", "\u0120use", "\u0120swarm", ".", "New", "Address", "\u0120if", "\u0120it", "\u0120is", "\u0120constructed", "\u0120from", "\u0120hex", "-", "enc", "oded", "\u0120string", "."]}
{"function": "@@ -80,8 +80,9 @@ func TestFSRepoInit(t *testing.T) { dir, err := ioutil.TempDir(\"\", \"\") assert.NoError(t, err) - - defer os.RemoveAll(dir) + defer func() { + require.NoError(t, os.RemoveAll(dir)) + }() t.Log(\"init FSRepo\") assert.NoError(t, InitFSRepo(dir, config.NewDefaultConfig()))", "text": "It would be worth factoring this out to a function, but you don't have to do that here.", "function_tokens": ["@@", "\u0120-", "80", ",", "8", "\u0120+", "80", ",", "9", "\u0120@@", "\u0120func", "\u0120Test", "FS", "Rep", "o", "Init", "(", "t", "\u0120*", "testing", ".", "T", ")", "\u0120{", "\u0120dir", ",", "\u0120err", "\u0120:=", "\u0120i", "out", "il", ".", "Temp", "Dir", "(\"", "\",", "\u0120\"", "\")", "\u0120assert", ".", "No", "Error", "(", "t", ",", "\u0120err", ")", "\u0120-", "\u0120-", "\u0120defer", "\u0120os", ".", "Remove", "All", "(", "dir", ")", "\u0120+", "\u0120defer", "\u0120func", "()", "\u0120{", "\u0120+", "\u0120require", ".", "No", "Error", "(", "t", ",", "\u0120os", ".", "Remove", "All", "(", "dir", "))", "\u0120+", "\u0120}", "()", "\u0120t", ".", "Log", "(\"", "init", "\u0120FS", "Rep", "o", "\")", "\u0120assert", ".", "No", "Error", "(", "t", ",", "\u0120Init", "FS", "Rep", "o", "(", "dir", ",", "\u0120config", ".", "New", "Default", "Config", "()", "))"], "docstring_tokens": ["It", "\u0120would", "\u0120be", "\u0120worth", "\u0120fact", "oring", "\u0120this", "\u0120out", "\u0120to", "\u0120a", "\u0120function", ",", "\u0120but", "\u0120you", "\u0120don", "'t", "\u0120have", "\u0120to", "\u0120do", "\u0120that", "\u0120here", "."]}
{"function": "@@ -0,0 +1,15 @@ +package com.fsck.k9.message.html; + +/** + * General framework to handle uris when parsing. Allows different handling depending on the scheme identifier. + */ +public interface UriParser { + /** + * Parse and linkify scheme specific uri beginning from given position. The result will be written to given buffer. + * @param text String to parse uri from. + * @param startPos Position where uri starts (first letter of scheme). + * @param outputBuffer Buffer where linkified variant of uri is written to. + * @return Index where parsed uri ends (first non-uri letter). Should be startPos or smaller if no valid uri was found. + */ + int linkifyUri(String text, int startPos, StringBuffer outputBuffer); +}", "text": "There's no need for `final` in interfaces.", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "15", "\u0120@@", "\u0120+", "package", "\u0120com", ".", "fs", "ck", ".", "k", "9", ".", "message", ".", "html", ";", "\u0120+", "\u0120+", "/**", "\u0120+", "\u0120*", "\u0120General", "\u0120framework", "\u0120to", "\u0120handle", "\u0120ur", "is", "\u0120when", "\u0120parsing", ".", "\u0120Allows", "\u0120different", "\u0120handling", "\u0120depending", "\u0120on", "\u0120the", "\u0120scheme", "\u0120identifier", ".", "\u0120+", "\u0120*/", "\u0120+", "public", "\u0120interface", "\u0120Uri", "Parser", "\u0120{", "\u0120+", "\u0120/**", "\u0120+", "\u0120*", "\u0120Par", "se", "\u0120and", "\u0120link", "ify", "\u0120scheme", "\u0120specific", "\u0120ur", "i", "\u0120beginning", "\u0120from", "\u0120given", "\u0120position", ".", "\u0120The", "\u0120result", "\u0120will", "\u0120be", "\u0120written", "\u0120to", "\u0120given", "\u0120buffer", ".", "\u0120+", "\u0120*", "\u0120@", "param", "\u0120text", "\u0120String", "\u0120to", "\u0120parse", "\u0120ur", "i", "\u0120from", ".", "\u0120+", "\u0120*", "\u0120@", "param", "\u0120start", "Pos", "\u0120Position", "\u0120where", "\u0120ur", "i", "\u0120starts", "\u0120(", "first", "\u0120letter", "\u0120of", "\u0120scheme", ").", "\u0120+", "\u0120*", "\u0120@", "param", "\u0120output", "Buffer", "\u0120Buffer", "\u0120where", "\u0120link", "ified", "\u0120variant", "\u0120of", "\u0120ur", "i", "\u0120is", "\u0120written", "\u0120to", ".", "\u0120+", "\u0120*", "\u0120@", "return", "\u0120Index", "\u0120where", "\u0120parsed", "\u0120ur", "i", "\u0120ends", "\u0120(", "first", "\u0120non", "-", "uri", "\u0120letter", ").", "\u0120Should", "\u0120be", "\u0120start", "Pos", "\u0120or", "\u0120smaller", "\u0120if", "\u0120no", "\u0120valid", "\u0120ur", "i", "\u0120was", "\u0120found", ".", "\u0120+", "\u0120*/", "\u0120+", "\u0120int", "\u0120link", "ify", "U", "ri", "(", "String", "\u0120text", ",", "\u0120int", "\u0120start", "Pos", ",", "\u0120String", "Buffer", "\u0120output", "Buffer", ");", "\u0120+", "}"], "docstring_tokens": ["There", "'s", "\u0120no", "\u0120need", "\u0120for", "\u0120`", "final", "`", "\u0120in", "\u0120interfaces", "."]}
{"function": "@@ -101,6 +101,9 @@ namespace Datadog.Trace.OpenTracing case DatadogTags.ServiceName: Span.ServiceName = value; return this; + case DatadogTags.ServiceVersion: + Span.SetTag(Tags.Version, value); + return this; } if (key == global::OpenTracing.Tag.Tags.Error.Key)", "text": "Isn't this case handled as a custom tag in `Span.SetTag()` below? This switch is only for special tags that actually set `Span` properties.", "function_tokens": ["@@", "\u0120-", "101", ",", "6", "\u0120+", "101", ",", "9", "\u0120@@", "\u0120namespace", "\u0120Dat", "ad", "og", ".", "Tr", "ace", ".", "Open", "Tr", "acing", "\u0120case", "\u0120Dat", "ad", "og", "Tags", ".", "Service", "Name", ":", "\u0120Span", ".", "Service", "Name", "\u0120=", "\u0120value", ";", "\u0120return", "\u0120this", ";", "\u0120+", "\u0120case", "\u0120Dat", "ad", "og", "Tags", ".", "Service", "Version", ":", "\u0120+", "\u0120Span", ".", "Set", "Tag", "(", "Tags", ".", "Version", ",", "\u0120value", ");", "\u0120+", "\u0120return", "\u0120this", ";", "\u0120}", "\u0120if", "\u0120(", "key", "\u0120==", "\u0120global", "::", "Open", "Tr", "acing", ".", "Tag", ".", "Tags", ".", "Error", ".", "Key", ")"], "docstring_tokens": ["Isn", "'t", "\u0120this", "\u0120case", "\u0120handled", "\u0120as", "\u0120a", "\u0120custom", "\u0120tag", "\u0120in", "\u0120`", "Sp", "an", ".", "Set", "Tag", "()", "`", "\u0120below", "?", "\u0120This", "\u0120switch", "\u0120is", "\u0120only", "\u0120for", "\u0120special", "\u0120tags", "\u0120that", "\u0120actually", "\u0120set", "\u0120`", "Sp", "an", "`", "\u0120properties", "."]}
{"function": "@@ -681,7 +681,6 @@ class Quitter: @cmdutils.argument('session', completion=miscmodels.session) def quit(self, save=False, session=None): \"\"\"Quit qutebrowser. - Args: save: When given, save the open windows even if auto_save.session is turned off.", "text": "This shouldn't be changed.", "function_tokens": ["@@", "\u0120-", "681", ",", "7", "\u0120+", "681", ",", "6", "\u0120@@", "\u0120class", "\u0120Qu", "itter", ":", "\u0120@", "cmd", "utils", ".", "argument", "('", "session", "',", "\u0120completion", "=", "misc", "models", ".", "session", ")", "\u0120def", "\u0120quit", "(", "self", ",", "\u0120save", "=", "False", ",", "\u0120session", "=", "None", "):", "\u0120\"\"\"", "Qu", "it", "\u0120q", "ute", "browser", ".", "\u0120-", "\u0120Ar", "gs", ":", "\u0120save", ":", "\u0120When", "\u0120given", ",", "\u0120save", "\u0120the", "\u0120open", "\u0120windows", "\u0120even", "\u0120if", "\u0120auto", "_", "save", ".", "session", "\u0120is", "\u0120turned", "\u0120off", "."], "docstring_tokens": ["This", "\u0120shouldn", "'t", "\u0120be", "\u0120changed", "."]}
{"function": "@@ -1,5 +1,5 @@ ## This file is part of Invenio. -## Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 CERN. +## Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2014 CERN. ## ## Invenio is free software; you can redistribute it and/or ## modify it under the terms of the GNU General Public License as", "text": "This one is important `2: I102 copyright year is outdated, expected 2014 but got 2012`", "function_tokens": ["@@", "\u0120-", "1", ",", "5", "\u0120+", "1", ",", "5", "\u0120@@", "\u0120##", "\u0120This", "\u0120file", "\u0120is", "\u0120part", "\u0120of", "\u0120In", "ven", "io", ".", "\u0120-", "##", "\u0120Copyright", "\u0120(", "C", ")", "\u01202004", ",", "\u01202005", ",", "\u01202006", ",", "\u01202007", ",", "\u01202008", ",", "\u01202009", ",", "\u01202010", ",", "\u01202011", ",", "\u01202012", "\u0120C", "ERN", ".", "\u0120+", "##", "\u0120Copyright", "\u0120(", "C", ")", "\u01202004", ",", "\u01202005", ",", "\u01202006", ",", "\u01202007", ",", "\u01202008", ",", "\u01202009", ",", "\u01202010", ",", "\u01202011", ",", "\u01202012", ",", "\u01202014", "\u0120C", "ERN", ".", "\u0120##", "\u0120##", "\u0120In", "ven", "io", "\u0120is", "\u0120free", "\u0120software", ";", "\u0120you", "\u0120can", "\u0120redist", "ribute", "\u0120it", "\u0120and", "/", "or", "\u0120##", "\u0120modify", "\u0120it", "\u0120under", "\u0120the", "\u0120terms", "\u0120of", "\u0120the", "\u0120GNU", "\u0120General", "\u0120Public", "\u0120License", "\u0120as"], "docstring_tokens": ["This", "\u0120one", "\u0120is", "\u0120important", "\u0120`", "2", ":", "\u0120I", "102", "\u0120copyright", "\u0120year", "\u0120is", "\u0120outdated", ",", "\u0120expected", "\u01202014", "\u0120but", "\u0120got", "\u01202012", "`"]}
{"function": "@@ -32,6 +32,8 @@ import java.util.Map; import java.util.Optional; import java.util.Set; import java.util.concurrent.TimeoutException; +import java.util.function.BiConsumer; +import java.util.function.Consumer; import com.google.common.collect.Lists; import com.google.common.collect.Maps;", "text": "Are these imports needed (BiConsumer and Consumer)? If they are unused imports, then precommit will fail.", "function_tokens": ["@@", "\u0120-", "32", ",", "6", "\u0120+", "32", ",", "8", "\u0120@@", "\u0120import", "\u0120java", ".", "util", ".", "Map", ";", "\u0120import", "\u0120java", ".", "util", ".", "Optional", ";", "\u0120import", "\u0120java", ".", "util", ".", "Set", ";", "\u0120import", "\u0120java", ".", "util", ".", "con", "current", ".", "Timeout", "Exception", ";", "\u0120+", "import", "\u0120java", ".", "util", ".", "function", ".", "Bi", "Consumer", ";", "\u0120+", "import", "\u0120java", ".", "util", ".", "function", ".", "Consumer", ";", "\u0120import", "\u0120com", ".", "google", ".", "common", ".", "collect", ".", "L", "ists", ";", "\u0120import", "\u0120com", ".", "google", ".", "common", ".", "collect", ".", "Maps", ";"], "docstring_tokens": ["Are", "\u0120these", "\u0120imports", "\u0120needed", "\u0120(", "Bi", "Consumer", "\u0120and", "\u0120Consumer", ")?", "\u0120If", "\u0120they", "\u0120are", "\u0120unused", "\u0120imports", ",", "\u0120then", "\u0120pre", "commit", "\u0120will", "\u0120fail", "."]}
{"function": "@@ -0,0 +1,10 @@ +class TraceDestroyerJob < ApplicationJob + queue_as :default + + def perform(trace) + trace.destroy + rescue StandardError => ex + logger.info ex.to_s + ex.backtrace.each { |l| logger.info l } + end +end", "text": "Why are we catching and logging exceptions? By doing that we make it look like the job has succeeded and it will be removed from the queue - if we didn't do that then it would stay queued...", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "10", "\u0120@@", "\u0120+", "class", "\u0120Trace", "Destroy", "er", "Job", "\u0120<", "\u0120Application", "Job", "\u0120+", "\u0120queue", "_", "as", "\u0120:", "default", "\u0120+", "\u0120+", "\u0120def", "\u0120perform", "(", "trace", ")", "\u0120+", "\u0120trace", ".", "destroy", "\u0120+", "\u0120rescue", "\u0120Standard", "Error", "\u0120=>", "\u0120ex", "\u0120+", "\u0120logger", ".", "info", "\u0120ex", ".", "to", "_", "s", "\u0120+", "\u0120ex", ".", "back", "trace", ".", "each", "\u0120{", "\u0120|", "l", "|", "\u0120logger", ".", "info", "\u0120l", "\u0120}", "\u0120+", "\u0120end", "\u0120+", "end"], "docstring_tokens": ["Why", "\u0120are", "\u0120we", "\u0120catching", "\u0120and", "\u0120logging", "\u0120exceptions", "?", "\u0120By", "\u0120doing", "\u0120that", "\u0120we", "\u0120make", "\u0120it", "\u0120look", "\u0120like", "\u0120the", "\u0120job", "\u0120has", "\u0120succeeded", "\u0120and", "\u0120it", "\u0120will", "\u0120be", "\u0120removed", "\u0120from", "\u0120the", "\u0120queue", "\u0120-", "\u0120if", "\u0120we", "\u0120didn", "'t", "\u0120do", "\u0120that", "\u0120then", "\u0120it", "\u0120would", "\u0120stay", "\u0120que", "ued", "..."]}
{"function": "@@ -90,14 +90,11 @@ class CartController extends FrontBaseController */ public function indexAction(Request $request) { - $cart = $this->cartFacade->getCartOfCurrentCustomer(); - - if ($cart->isEmpty()) { - $this->cartFacade->cleanAdditionalData(); - } + $cart = $this->cartFacade->findCartOfCurrentCustomer(); + $cartItems = $cart === null ? [] : $cart->getItems(); $cartFormData = ['quantities' => []]; - foreach ($cart->getItems() as $cartItem) { + foreach ($cartItems as $cartItem) { $cartFormData['quantities'][$cartItem->getId()] = $cartItem->getQuantity(); } ", "text": "If there are `@param` tags in docblock, there should be `@return` tag also. (applies for a whole file)", "function_tokens": ["@@", "\u0120-", "90", ",", "14", "\u0120+", "90", ",", "11", "\u0120@@", "\u0120class", "\u0120Cart", "Controller", "\u0120extends", "\u0120Front", "Base", "Controller", "\u0120*/", "\u0120public", "\u0120function", "\u0120index", "Action", "(", "Request", "\u0120$", "request", ")", "\u0120{", "\u0120-", "\u0120$", "cart", "\u0120=", "\u0120$", "this", "->", "cart", "Fac", "ade", "->", "get", "Cart", "Of", "Current", "Customer", "();", "\u0120-", "\u0120-", "\u0120if", "\u0120($", "cart", "->", "is", "Empty", "())", "\u0120{", "\u0120-", "\u0120$", "this", "->", "cart", "Fac", "ade", "->", "clean", "Additional", "Data", "();", "\u0120-", "\u0120}", "\u0120+", "\u0120$", "cart", "\u0120=", "\u0120$", "this", "->", "cart", "Fac", "ade", "->", "find", "Cart", "Of", "Current", "Customer", "();", "\u0120+", "\u0120$", "cart", "Items", "\u0120=", "\u0120$", "cart", "\u0120===", "\u0120null", "\u0120?", "\u0120[]", "\u0120:", "\u0120$", "cart", "->", "get", "Items", "();", "\u0120$", "cart", "Form", "Data", "\u0120=", "\u0120['", "quant", "ities", "'", "\u0120=>", "\u0120[]", "];", "\u0120-", "\u0120fore", "ach", "\u0120($", "cart", "->", "get", "Items", "()", "\u0120as", "\u0120$", "cart", "Item", ")", "\u0120{", "\u0120+", "\u0120fore", "ach", "\u0120($", "cart", "Items", "\u0120as", "\u0120$", "cart", "Item", ")", "\u0120{", "\u0120$", "cart", "Form", "Data", "['", "quant", "ities", "'", "][", "$", "cart", "Item", "->", "get", "Id", "()", "]", "\u0120=", "\u0120$", "cart", "Item", "->", "get", "Quantity", "();", "\u0120}", "\u0120"], "docstring_tokens": ["If", "\u0120there", "\u0120are", "\u0120`", "@", "param", "`", "\u0120tags", "\u0120in", "\u0120doc", "block", ",", "\u0120there", "\u0120should", "\u0120be", "\u0120`", "@", "return", "`", "\u0120tag", "\u0120also", ".", "\u0120(", "app", "lies", "\u0120for", "\u0120a", "\u0120whole", "\u0120file", ")"]}
{"function": "@@ -34,7 +34,8 @@ public enum BesuMetricCategory implements MetricCategory { PRUNER(\"pruner\"), RPC(\"rpc\"), SYNCHRONIZER(\"synchronizer\"), - TRANSACTION_POOL(\"transaction_pool\"); + TRANSACTION_POOL(\"transaction_pool\"), + VALIDATORS(\"validators\"); private static final Optional<String> BESU_PREFIX = Optional.of(\"besu_\"); public static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES;", "text": "Is the concept of validators exclusive to IBFT2? I wonder if this category should be more explicitly linked to IBFT2.", "function_tokens": ["@@", "\u0120-", "34", ",", "7", "\u0120+", "34", ",", "8", "\u0120@@", "\u0120public", "\u0120enum", "\u0120Bes", "u", "Met", "ric", "Category", "\u0120implements", "\u0120Met", "ric", "Category", "\u0120{", "\u0120PR", "UN", "ER", "(\"", "pr", "uner", "\"),", "\u0120RPC", "(\"", "r", "pc", "\"),", "\u0120SY", "N", "CHR", "ON", "IZ", "ER", "(\"", "syn", "chron", "izer", "\"),", "\u0120-", "\u0120TRANS", "ACTION", "_", "PO", "OL", "(\"", "trans", "action", "_", "pool", "\");", "\u0120+", "\u0120TRANS", "ACTION", "_", "PO", "OL", "(\"", "trans", "action", "_", "pool", "\"),", "\u0120+", "\u0120VAL", "ID", "AT", "ORS", "(\"", "valid", "ators", "\");", "\u0120private", "\u0120static", "\u0120final", "\u0120Optional", "<", "String", ">", "\u0120B", "ES", "U", "_", "P", "REF", "IX", "\u0120=", "\u0120Optional", ".", "of", "(\"", "bes", "u", "_", "\");", "\u0120public", "\u0120static", "\u0120final", "\u0120Set", "<", "Met", "ric", "Category", ">", "\u0120DE", "FAULT", "_", "MET", "RIC", "_", "C", "ATE", "G", "OR", "IES", ";"], "docstring_tokens": ["Is", "\u0120the", "\u0120concept", "\u0120of", "\u0120valid", "ators", "\u0120exclusive", "\u0120to", "\u0120IB", "FT", "2", "?", "\u0120I", "\u0120wonder", "\u0120if", "\u0120this", "\u0120category", "\u0120should", "\u0120be", "\u0120more", "\u0120explicitly", "\u0120linked", "\u0120to", "\u0120IB", "FT", "2", "."]}
{"function": "@@ -14,9 +14,7 @@ */ package org.hyperledger.besu.tests.acceptance.dsl.account; -import org.hyperledger.besu.crypto.SECP256K1.KeyPair; -import org.hyperledger.besu.crypto.SECP256K1.PrivateKey; -import org.hyperledger.besu.crypto.SECP256K1.PublicKey; +import org.hyperledger.besu.crypto.*; import org.hyperledger.besu.ethereum.core.Address; import org.hyperledger.besu.ethereum.core.Hash; import org.hyperledger.besu.tests.acceptance.dsl.blockchain.Amount;", "text": "Spotless is configured to reject star imports. Please replace with explicit imports.", "function_tokens": ["@@", "\u0120-", "14", ",", "9", "\u0120+", "14", ",", "7", "\u0120@@", "\u0120*/", "\u0120package", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "tests", ".", "accept", "ance", ".", "d", "sl", ".", "account", ";", "\u0120-", "import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "crypt", "o", ".", "SEC", "P", "256", "K", "1", ".", "Key", "P", "air", ";", "\u0120-", "import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "crypt", "o", ".", "SEC", "P", "256", "K", "1", ".", "Private", "Key", ";", "\u0120-", "import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "crypt", "o", ".", "SEC", "P", "256", "K", "1", ".", "Public", "Key", ";", "\u0120+", "import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "crypt", "o", ".*", ";", "\u0120import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "et", "here", "um", ".", "core", ".", "Address", ";", "\u0120import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "et", "here", "um", ".", "core", ".", "Hash", ";", "\u0120import", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "tests", ".", "accept", "ance", ".", "d", "sl", ".", "block", "chain", ".", "Amount", ";"], "docstring_tokens": ["Spot", "less", "\u0120is", "\u0120configured", "\u0120to", "\u0120reject", "\u0120star", "\u0120imports", ".", "\u0120Please", "\u0120replace", "\u0120with", "\u0120explicit", "\u0120imports", "."]}
{"function": "@@ -115,6 +115,8 @@ void SYCLInternal::initialize(const sycl::device& d) { m_maxThreadsPerSM = d.template get_info<sycl::info::device::max_work_group_size>(); + m_maxShmemPerBlock = + d.template get_info<sycl::info::device::local_mem_size>(); m_indirectKernelMem.reset(*m_queue); m_indirectReducerMem.reset(*m_queue); } else {", "text": "Remind me why you are using CUDA vocabulary when naming these variables.", "function_tokens": ["@@", "\u0120-", "115", ",", "6", "\u0120+", "115", ",", "8", "\u0120@@", "\u0120void", "\u0120SY", "CL", "Internal", "::", "initial", "ize", "(", "const", "\u0120sy", "cl", "::", "device", "&", "\u0120d", ")", "\u0120{", "\u0120m", "_", "max", "Thread", "s", "Per", "SM", "\u0120=", "\u0120d", ".", "template", "\u0120get", "_", "info", "<", "sy", "cl", "::", "info", "::", "device", "::", "max", "_", "work", "_", "group", "_", "size", ">", "();", "\u0120+", "\u0120m", "_", "max", "Sh", "mem", "Per", "Block", "\u0120=", "\u0120+", "\u0120d", ".", "template", "\u0120get", "_", "info", "<", "sy", "cl", "::", "info", "::", "device", "::", "local", "_", "mem", "_", "size", ">", "();", "\u0120m", "_", "ind", "irect", "K", "ernel", "Mem", ".", "reset", "(*", "m", "_", "queue", ");", "\u0120m", "_", "ind", "irect", "Red", "ucer", "Mem", ".", "reset", "(*", "m", "_", "queue", ");", "\u0120}", "\u0120else", "\u0120{"], "docstring_tokens": ["Rem", "ind", "\u0120me", "\u0120why", "\u0120you", "\u0120are", "\u0120using", "\u0120CU", "DA", "\u0120vocabulary", "\u0120when", "\u0120naming", "\u0120these", "\u0120variables", "."]}
{"function": "@@ -898,6 +898,16 @@ public final class DBReader { } final LongIntMap feedCounters = adapter.getFeedCounters(feedIds); + int feedFilter = UserPreferences.getFeedFilter(); + if (feedFilter == UserPreferences.FEED_FILTER_COUNTER_ZERO) { + for (int i = 0; i < feeds.size(); i++) { + if (feedCounters.get(feeds.get(i).getId()) <= 0) { + feedCounters.delete(feeds.get(i).getId()); + feeds.remove(i); + } + } + } + Comparator<Feed> comparator; int feedOrder = UserPreferences.getFeedOrder(); if (feedOrder == UserPreferences.FEED_ORDER_COUNTER) {", "text": "Please turn the iteration order around (instead of `0...size` to `size...0`). The reason is that this sometimes skips indices when removing an item. You can therefore end up with feeds that have counter 0 and are still displayed.", "function_tokens": ["@@", "\u0120-", "8", "98", ",", "6", "\u0120+", "8", "98", ",", "16", "\u0120@@", "\u0120public", "\u0120final", "\u0120class", "\u0120DB", "Reader", "\u0120{", "\u0120}", "\u0120final", "\u0120Long", "Int", "Map", "\u0120feed", "C", "ounters", "\u0120=", "\u0120adapter", ".", "get", "Feed", "C", "ounters", "(", "feed", "Id", "s", ");", "\u0120+", "\u0120int", "\u0120feed", "Filter", "\u0120=", "\u0120User", "Pref", "erences", ".", "get", "Feed", "Filter", "();", "\u0120+", "\u0120if", "\u0120(", "feed", "Filter", "\u0120==", "\u0120User", "Pref", "erences", ".", "FE", "ED", "_", "FIL", "TER", "_", "C", "OUN", "TER", "_", "Z", "ERO", ")", "\u0120{", "\u0120+", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120feeds", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120+", "\u0120if", "\u0120(", "feed", "C", "ounters", ".", "get", "(", "feed", "s", ".", "get", "(", "i", ").", "get", "Id", "())", "\u0120<=", "\u01200", ")", "\u0120{", "\u0120+", "\u0120feed", "C", "ounters", ".", "delete", "(", "feed", "s", ".", "get", "(", "i", ").", "get", "Id", "());", "\u0120+", "\u0120feeds", ".", "remove", "(", "i", ");", "\u0120+", "\u0120}", "\u0120+", "\u0120}", "\u0120+", "\u0120}", "\u0120+", "\u0120Compar", "ator", "<", "Feed", ">", "\u0120compar", "ator", ";", "\u0120int", "\u0120feed", "Order", "\u0120=", "\u0120User", "Pref", "erences", ".", "get", "Feed", "Order", "();", "\u0120if", "\u0120(", "feed", "Order", "\u0120==", "\u0120User", "Pref", "erences", ".", "FE", "ED", "_", "ORD", "ER", "_", "C", "OUN", "TER", ")", "\u0120{"], "docstring_tokens": ["Please", "\u0120turn", "\u0120the", "\u0120iteration", "\u0120order", "\u0120around", "\u0120(", "instead", "\u0120of", "\u0120`", "0", "...", "size", "`", "\u0120to", "\u0120`", "size", "...", "0", "`", ").", "\u0120The", "\u0120reason", "\u0120is", "\u0120that", "\u0120this", "\u0120sometimes", "\u0120sk", "ips", "\u0120indices", "\u0120when", "\u0120removing", "\u0120an", "\u0120item", ".", "\u0120You", "\u0120can", "\u0120therefore", "\u0120end", "\u0120up", "\u0120with", "\u0120feeds", "\u0120that", "\u0120have", "\u0120counter", "\u01200", "\u0120and", "\u0120are", "\u0120still", "\u0120displayed", "."]}
{"function": "@@ -620,7 +620,7 @@ def execute_reentrant_pipeline(pipeline, typed_environment, throw_on_error, reen def get_subset_pipeline(pipeline, solid_subset): check.inst_param(pipeline, 'pipeline', PipelineDefinition) check.opt_list_param(solid_subset, 'solid_subset', of_type=str) - return pipeline if solid_subset is None else build_sub_pipeline(pipeline, solid_subset) + return pipeline if not solid_subset else build_sub_pipeline(pipeline, solid_subset) def create_typed_environment(pipeline, environment=None):", "text": "this is a behavior change. solid_subset=[] represents an empty pipeline where as solid_subset=None is the full pipeline", "function_tokens": ["@@", "\u0120-", "620", ",", "7", "\u0120+", "620", ",", "7", "\u0120@@", "\u0120def", "\u0120execute", "_", "re", "ent", "rant", "_", "p", "ip", "eline", "(", "p", "ip", "eline", ",", "\u0120typed", "_", "environment", ",", "\u0120throw", "_", "on", "_", "error", ",", "\u0120re", "en", "\u0120def", "\u0120get", "_", "sub", "set", "_", "p", "ip", "eline", "(", "p", "ip", "eline", ",", "\u0120solid", "_", "sub", "set", "):", "\u0120check", ".", "inst", "_", "param", "(", "p", "ip", "eline", ",", "\u0120'", "p", "ip", "eline", "',", "\u0120Pipeline", "Definition", ")", "\u0120check", ".", "opt", "_", "list", "_", "param", "(", "solid", "_", "sub", "set", ",", "\u0120'", "solid", "_", "sub", "set", "',", "\u0120of", "_", "type", "=", "str", ")", "\u0120-", "\u0120return", "\u0120pipeline", "\u0120if", "\u0120solid", "_", "sub", "set", "\u0120is", "\u0120None", "\u0120else", "\u0120build", "_", "sub", "_", "p", "ip", "eline", "(", "p", "ip", "eline", ",", "\u0120solid", "_", "sub", "set", ")", "\u0120+", "\u0120return", "\u0120pipeline", "\u0120if", "\u0120not", "\u0120solid", "_", "sub", "set", "\u0120else", "\u0120build", "_", "sub", "_", "p", "ip", "eline", "(", "p", "ip", "eline", ",", "\u0120solid", "_", "sub", "set", ")", "\u0120def", "\u0120create", "_", "ty", "ped", "_", "environment", "(", "p", "ip", "eline", ",", "\u0120environment", "=", "None", "):"], "docstring_tokens": ["this", "\u0120is", "\u0120a", "\u0120behavior", "\u0120change", ".", "\u0120solid", "_", "sub", "set", "=", "[]", "\u0120represents", "\u0120an", "\u0120empty", "\u0120pipeline", "\u0120where", "\u0120as", "\u0120solid", "_", "sub", "set", "=", "None", "\u0120is", "\u0120the", "\u0120full", "\u0120pipeline"]}
{"function": "@@ -318,8 +318,7 @@ Licensed under the MIT License. See License.txt in the project root for license { foreach (var unmatchedSetting in CustomSettings.Keys) { - Logger.LogError(new ArgumentException(unmatchedSetting), - Resources.ParameterIsNotValid, unmatchedSetting); + Logger.LogWarning(Resources.ParameterIsNotValid, unmatchedSetting); } } ErrorManager.ThrowErrors();", "text": "this is a breaking change, any specific reason you want to do this?", "function_tokens": ["@@", "\u0120-", "318", ",", "8", "\u0120+", "318", ",", "7", "\u0120@@", "\u0120Licensed", "\u0120under", "\u0120the", "\u0120MIT", "\u0120License", ".", "\u0120See", "\u0120License", ".", "txt", "\u0120in", "\u0120the", "\u0120project", "\u0120root", "\u0120for", "\u0120license", "\u0120{", "\u0120fore", "ach", "\u0120(", "var", "\u0120unmatched", "Setting", "\u0120in", "\u0120Custom", "Settings", ".", "Keys", ")", "\u0120{", "\u0120-", "\u0120Log", "ger", ".", "Log", "Error", "(", "new", "\u0120Argument", "Exception", "(", "un", "matched", "Setting", "),", "\u0120-", "\u0120Resources", ".", "Parameter", "Is", "Not", "Valid", ",", "\u0120unmatched", "Setting", ");", "\u0120+", "\u0120Log", "ger", ".", "Log", "Warning", "(", "Resources", ".", "Parameter", "Is", "Not", "Valid", ",", "\u0120unmatched", "Setting", ");", "\u0120}", "\u0120}", "\u0120Error", "Manager", ".", "Throw", "Er", "rors", "();"], "docstring_tokens": ["this", "\u0120is", "\u0120a", "\u0120breaking", "\u0120change", ",", "\u0120any", "\u0120specific", "\u0120reason", "\u0120you", "\u0120want", "\u0120to", "\u0120do", "\u0120this", "?"]}
{"function": "@@ -91,6 +91,8 @@ type nodeChainReader interface { GetTipSetStateRoot(tsKey types.SortedCidSet) (cid.Cid, error) HeadEvents() *ps.PubSub Load(context.Context) error + PutTipSetAndState(context.Context, *chain.TipSetAndState) error + SetHead(context.Context, types.TipSet) error Stop() } ", "text": "Blocking: we still want read write separation. Node functions should absolutely not write to the chain store and the interface should reflect that. Only the syncer should have this capability in production code. It should be no problem to keep casting chainForTest to a read-write interface, or doing other function decomposition and automatic casting tricks.", "function_tokens": ["@@", "\u0120-", "91", ",", "6", "\u0120+", "91", ",", "8", "\u0120@@", "\u0120type", "\u0120node", "Chain", "Reader", "\u0120interface", "\u0120{", "\u0120Get", "Tip", "Set", "State", "Root", "(", "ts", "Key", "\u0120types", ".", "S", "orted", "C", "id", "Set", ")", "\u0120(", "c", "id", ".", "C", "id", ",", "\u0120error", ")", "\u0120Head", "Events", "()", "\u0120*", "ps", ".", "Pub", "Sub", "\u0120Load", "(", "context", ".", "Context", ")", "\u0120error", "\u0120+", "\u0120Put", "Tip", "Set", "And", "State", "(", "context", ".", "Context", ",", "\u0120*", "chain", ".", "Tip", "Set", "And", "State", ")", "\u0120error", "\u0120+", "\u0120Set", "Head", "(", "context", ".", "Context", ",", "\u0120types", ".", "Tip", "Set", ")", "\u0120error", "\u0120Stop", "()", "\u0120}", "\u0120"], "docstring_tokens": ["Bl", "ocking", ":", "\u0120we", "\u0120still", "\u0120want", "\u0120read", "\u0120write", "\u0120separation", ".", "\u0120Node", "\u0120functions", "\u0120should", "\u0120absolutely", "\u0120not", "\u0120write", "\u0120to", "\u0120the", "\u0120chain", "\u0120store", "\u0120and", "\u0120the", "\u0120interface", "\u0120should", "\u0120reflect", "\u0120that", ".", "\u0120Only", "\u0120the", "\u0120syn", "cer", "\u0120should", "\u0120have", "\u0120this", "\u0120capability", "\u0120in", "\u0120production", "\u0120code", ".", "\u0120It", "\u0120should", "\u0120be", "\u0120no", "\u0120problem", "\u0120to", "\u0120keep", "\u0120casting", "\u0120chain", "For", "Test", "\u0120to", "\u0120a", "\u0120read", "-", "write", "\u0120interface", ",", "\u0120or", "\u0120doing", "\u0120other", "\u0120function", "\u0120decom", "position", "\u0120and", "\u0120automatic", "\u0120casting", "\u0120tricks", "."]}
{"function": "@@ -22,7 +22,8 @@ const ( minimalPrefetchWorkerQueueSize int = 1 testBlockRetrievalWorkerQueueSize int = 5 testPrefetchWorkerQueueSize int = 1 - defaultOnDemandRequestPriority int = 100 + defaultOnDemandRequestPriority int = 1<<30 - 1 + lowestTriggerPrefetchPriority int = 1 // Channel buffer size can be big because we use the empty struct. workerQueueSize int = 1<<31 - 1 )", "text": "The PR description says the lowest on-demand request priority is `2^30`. Why the `-1` here?", "function_tokens": ["@@", "\u0120-", "22", ",", "7", "\u0120+", "22", ",", "8", "\u0120@@", "\u0120const", "\u0120(", "\u0120minimal", "Pref", "etch", "Work", "er", "Queue", "Size", "\u0120int", "\u0120=", "\u01201", "\u0120test", "Block", "Ret", "ri", "eval", "Work", "er", "Queue", "Size", "\u0120int", "\u0120=", "\u01205", "\u0120test", "Pref", "etch", "Work", "er", "Queue", "Size", "\u0120int", "\u0120=", "\u01201", "\u0120-", "\u0120default", "On", "Demand", "Request", "Prior", "ity", "\u0120int", "\u0120=", "\u0120100", "\u0120+", "\u0120default", "On", "Demand", "Request", "Prior", "ity", "\u0120int", "\u0120=", "\u01201", "<<", "30", "\u0120-", "\u01201", "\u0120+", "\u0120lowest", "Trigger", "Pref", "etch", "Prior", "ity", "\u0120int", "\u0120=", "\u01201", "\u0120//", "\u0120Channel", "\u0120buffer", "\u0120size", "\u0120can", "\u0120be", "\u0120big", "\u0120because", "\u0120we", "\u0120use", "\u0120the", "\u0120empty", "\u0120struct", ".", "\u0120worker", "Queue", "Size", "\u0120int", "\u0120=", "\u01201", "<<", "31", "\u0120-", "\u01201", "\u0120)"], "docstring_tokens": ["The", "\u0120PR", "\u0120description", "\u0120says", "\u0120the", "\u0120lowest", "\u0120on", "-", "demand", "\u0120request", "\u0120priority", "\u0120is", "\u0120`", "2", "^", "30", "`.", "\u0120Why", "\u0120the", "\u0120`", "-", "1", "`", "\u0120here", "?"]}
{"function": "@@ -609,6 +609,14 @@ bool Game::removeCreature(Creature* creature, bool isLogout/* = true*/) return true; } +void Game::executeDeath(uint32_t creatureId) +{ + Creature* creature = getCreatureByID(creatureId); + if (creature && !creature->isRemoved() && creature->getHealth() < 1) { + creature->onDeath(); + } +} + void Game::playerMoveThing(uint32_t playerId, const Position& fromPos, uint16_t spriteId, uint8_t fromStackPos, const Position& toPos, uint8_t count) {", "text": "checking health again? I think it is not necessary.", "function_tokens": ["@@", "\u0120-", "609", ",", "6", "\u0120+", "609", ",", "14", "\u0120@@", "\u0120bool", "\u0120Game", "::", "remove", "Creat", "ure", "(", "Creat", "ure", "*", "\u0120creature", ",", "\u0120bool", "\u0120is", "Log", "out", "/*", "\u0120=", "\u0120true", "*/", ")", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120+", "void", "\u0120Game", "::", "execute", "Death", "(", "uint", "32", "_", "t", "\u0120creature", "Id", ")", "\u0120+", "{", "\u0120+", "\u0120Creature", "*", "\u0120creature", "\u0120=", "\u0120get", "Creat", "ure", "By", "ID", "(", "creat", "ure", "Id", ");", "\u0120+", "\u0120if", "\u0120(", "creat", "ure", "\u0120&&", "\u0120!", "creat", "ure", "->", "is", "Removed", "()", "\u0120&&", "\u0120creature", "->", "get", "Health", "()", "\u0120<", "\u01201", ")", "\u0120{", "\u0120+", "\u0120creature", "->", "on", "Death", "();", "\u0120+", "\u0120}", "\u0120+", "}", "\u0120+", "\u0120void", "\u0120Game", "::", "player", "Move", "T", "hing", "(", "uint", "32", "_", "t", "\u0120player", "Id", ",", "\u0120const", "\u0120Position", "&", "\u0120from", "Pos", ",", "\u0120uint", "16", "_", "t", "\u0120sprite", "Id", ",", "\u0120uint", "8", "_", "t", "\u0120from", "Stack", "Pos", ",", "\u0120const", "\u0120Position", "&", "\u0120to", "Pos", ",", "\u0120uint", "8", "_", "t", "\u0120count", ")", "\u0120{"], "docstring_tokens": ["checking", "\u0120health", "\u0120again", "?", "\u0120I", "\u0120think", "\u0120it", "\u0120is", "\u0120not", "\u0120necessary", "."]}
{"function": "@@ -442,7 +442,18 @@ configRetry: log.Infof(\"Starting the Typha connection\") err := typhaConnection.Start(context.Background()) if err != nil { - log.WithError(err).Fatal(\"Failed to connect to Typha\") + log.WithError(err).Error(\"Failed to connect to Typha. Retrying...\") + startTime := time.Now() + for err != nil && time.Since(startTime) < 30*time.Second { + // Set Ready to false and Live to true when unable to connect to typha + healthAggregator.Report(healthName, &health.HealthReport{Live: true, Ready: false}) + err = typhaConnection.Start(context.Background()) + log.WithError(err).Debug(\"Retrying to start Typha\") + time.Sleep(1 * time.Second) + } + if err != nil { + log.WithError(err).Fatal(\"Failed to connect to Typha\") + } } go func() { typhaConnection.Finished.Wait()", "text": "Need an `if err == nil {break}` above this line so that we don't log/sleep if the retry succeeds.", "function_tokens": ["@@", "\u0120-", "442", ",", "7", "\u0120+", "442", ",", "18", "\u0120@@", "\u0120config", "Ret", "ry", ":", "\u0120log", ".", "Inf", "of", "(\"", "Starting", "\u0120the", "\u0120Ty", "pha", "\u0120connection", "\")", "\u0120err", "\u0120:=", "\u0120ty", "pha", "Connection", ".", "Start", "(", "context", ".", "Background", "())", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120-", "\u0120log", ".", "With", "Error", "(", "err", ").", "F", "atal", "(\"", "F", "ailed", "\u0120to", "\u0120connect", "\u0120to", "\u0120Ty", "pha", "\")", "\u0120+", "\u0120log", ".", "With", "Error", "(", "err", ").", "Error", "(\"", "F", "ailed", "\u0120to", "\u0120connect", "\u0120to", "\u0120Ty", "pha", ".", "\u0120Ret", "rying", "...\"", ")", "\u0120+", "\u0120start", "Time", "\u0120:=", "\u0120time", ".", "Now", "()", "\u0120+", "\u0120for", "\u0120err", "\u0120!=", "\u0120nil", "\u0120&&", "\u0120time", ".", "Since", "(", "start", "Time", ")", "\u0120<", "\u012030", "*", "time", ".", "Second", "\u0120{", "\u0120+", "\u0120//", "\u0120Set", "\u0120Ready", "\u0120to", "\u0120false", "\u0120and", "\u0120Live", "\u0120to", "\u0120true", "\u0120when", "\u0120unable", "\u0120to", "\u0120connect", "\u0120to", "\u0120ty", "pha", "\u0120+", "\u0120health", "Agg", "reg", "ator", ".", "Report", "(", "health", "Name", ",", "\u0120&", "health", ".", "Health", "Report", "{", "Live", ":", "\u0120true", ",", "\u0120Ready", ":", "\u0120false", "})", "\u0120+", "\u0120err", "\u0120=", "\u0120ty", "pha", "Connection", ".", "Start", "(", "context", ".", "Background", "())", "\u0120+", "\u0120log", ".", "With", "Error", "(", "err", ").", "Debug", "(\"", "Ret", "rying", "\u0120to", "\u0120start", "\u0120Ty", "pha", "\")", "\u0120+", "\u0120time", ".", "Sleep", "(", "1", "\u0120*", "\u0120time", ".", "Second", ")", "\u0120+", "\u0120}", "\u0120+", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120+", "\u0120log", ".", "With", "Error", "(", "err", ").", "F", "atal", "(\"", "F", "ailed", "\u0120to", "\u0120connect", "\u0120to", "\u0120Ty", "pha", "\")", "\u0120+", "\u0120}", "\u0120}", "\u0120go", "\u0120func", "()", "\u0120{", "\u0120ty", "pha", "Connection", ".", "Fin", "ished", ".", "Wait", "()"], "docstring_tokens": ["Need", "\u0120an", "\u0120`", "if", "\u0120err", "\u0120==", "\u0120nil", "\u0120{", "break", "}", "`", "\u0120above", "\u0120this", "\u0120line", "\u0120so", "\u0120that", "\u0120we", "\u0120don", "'t", "\u0120log", "/", "sleep", "\u0120if", "\u0120the", "\u0120ret", "ry", "\u0120succeeds", "."]}
{"function": "@@ -0,0 +1,18 @@ +'use strict'; + +const assert = require('assert'); + +class ProvidedPromise { + set Promise(lib) { + assert.ok(typeof lib === 'function', `mongodb.Promise must be a function, got ${lib}`); + this._promise = lib; + } + get Promise() { + return this._promise; + } +} + +const provided = new ProvidedPromise(); +provided.Promise = global.Promise; + +module.exports = provided;", "text": "to reiterate my point above, this class is not the actual provided Promise, but rather something a user can provide a Promise to/with. I think a name like `PromiseProvider` is more appropriate.", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "18", "\u0120@@", "\u0120+", "'", "use", "\u0120strict", "';", "\u0120+", "\u0120+", "const", "\u0120assert", "\u0120=", "\u0120require", "('", "assert", "');", "\u0120+", "\u0120+", "class", "\u0120Provided", "Prom", "ise", "\u0120{", "\u0120+", "\u0120set", "\u0120Promise", "(", "lib", ")", "\u0120{", "\u0120+", "\u0120assert", ".", "ok", "(", "type", "of", "\u0120lib", "\u0120===", "\u0120'", "function", "',", "\u0120`", "mong", "od", "b", ".", "Prom", "ise", "\u0120must", "\u0120be", "\u0120a", "\u0120function", ",", "\u0120got", "\u0120${", "lib", "}", "`", ");", "\u0120+", "\u0120this", "._", "prom", "ise", "\u0120=", "\u0120lib", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120get", "\u0120Promise", "()", "\u0120{", "\u0120+", "\u0120return", "\u0120this", "._", "prom", "ise", ";", "\u0120+", "\u0120}", "\u0120+", "}", "\u0120+", "\u0120+", "const", "\u0120provided", "\u0120=", "\u0120new", "\u0120Provided", "Prom", "ise", "();", "\u0120+", "provided", ".", "Prom", "ise", "\u0120=", "\u0120global", ".", "Prom", "ise", ";", "\u0120+", "\u0120+", "module", ".", "ex", "ports", "\u0120=", "\u0120provided", ";"], "docstring_tokens": ["to", "\u0120reiterate", "\u0120my", "\u0120point", "\u0120above", ",", "\u0120this", "\u0120class", "\u0120is", "\u0120not", "\u0120the", "\u0120actual", "\u0120provided", "\u0120Promise", ",", "\u0120but", "\u0120rather", "\u0120something", "\u0120a", "\u0120user", "\u0120can", "\u0120provide", "\u0120a", "\u0120Promise", "\u0120to", "/", "with", ".", "\u0120I", "\u0120think", "\u0120a", "\u0120name", "\u0120like", "\u0120`", "Prom", "ise", "Provider", "`", "\u0120is", "\u0120more", "\u0120appropriate", "."]}
{"function": "@@ -738,6 +738,12 @@ func addDep(s *scope, args []pyObject) pyObject { dep := core.ParseBuildLabelContext(string(args[1].(pyString)), s.pkg) exported := args[2].IsTruthy() target.AddMaybeExportedDependency(dep, exported, false, false) + // Queue this dependency if it'll be needed. + if target.State() > core.Inactive { + err := s.state.QueueTarget(dep, target.Label, true, false) + s.Assert(err == nil, \"%s\", err) + } + // TODO(peterebden): Do we even need the following any more? s.pkg.MarkTargetModified(target) return None }", "text": "I guess we can only call this from a post-build function, but we might need to check that this target is to be built? I guess target A depends on B which has a post build. We `plz build :B` which adds C as a dep of A. Won't we queue C to be built even though it only needs to build if A needs to be built? That's kinda why I approached this the way I did. I trust you've thought about this but would be good to understand this a bit better.", "function_tokens": ["@@", "\u0120-", "7", "38", ",", "6", "\u0120+", "7", "38", ",", "12", "\u0120@@", "\u0120func", "\u0120add", "Dep", "(", "s", "\u0120*", "scope", ",", "\u0120args", "\u0120[]", "py", "Object", ")", "\u0120py", "Object", "\u0120{", "\u0120dep", "\u0120:=", "\u0120core", ".", "Par", "se", "Build", "Label", "Context", "(", "string", "(", "args", "[", "1", "].", "(", "py", "String", ")),", "\u0120s", ".", "pkg", ")", "\u0120exported", "\u0120:=", "\u0120args", "[", "2", "].", "Is", "Truth", "y", "()", "\u0120target", ".", "Add", "Maybe", "Ex", "ported", "D", "epend", "ency", "(", "dep", ",", "\u0120exported", ",", "\u0120false", ",", "\u0120false", ")", "\u0120+", "\u0120//", "\u0120Que", "ue", "\u0120this", "\u0120dependency", "\u0120if", "\u0120it", "'ll", "\u0120be", "\u0120needed", ".", "\u0120+", "\u0120if", "\u0120target", ".", "State", "()", "\u0120>", "\u0120core", ".", "In", "active", "\u0120{", "\u0120+", "\u0120err", "\u0120:=", "\u0120s", ".", "state", ".", "Queue", "Target", "(", "dep", ",", "\u0120target", ".", "Label", ",", "\u0120true", ",", "\u0120false", ")", "\u0120+", "\u0120s", ".", "Ass", "ert", "(", "err", "\u0120==", "\u0120nil", ",", "\u0120\"%", "s", "\",", "\u0120err", ")", "\u0120+", "\u0120}", "\u0120+", "\u0120//", "\u0120TOD", "O", "(", "pet", "ere", "b", "den", "):", "\u0120Do", "\u0120we", "\u0120even", "\u0120need", "\u0120the", "\u0120following", "\u0120any", "\u0120more", "?", "\u0120s", ".", "pkg", ".", "Mark", "Target", "Mod", "ified", "(", "target", ")", "\u0120return", "\u0120None", "\u0120}"], "docstring_tokens": ["I", "\u0120guess", "\u0120we", "\u0120can", "\u0120only", "\u0120call", "\u0120this", "\u0120from", "\u0120a", "\u0120post", "-", "build", "\u0120function", ",", "\u0120but", "\u0120we", "\u0120might", "\u0120need", "\u0120to", "\u0120check", "\u0120that", "\u0120this", "\u0120target", "\u0120is", "\u0120to", "\u0120be", "\u0120built", "?", "\u0120I", "\u0120guess", "\u0120target", "\u0120A", "\u0120depends", "\u0120on", "\u0120B", "\u0120which", "\u0120has", "\u0120a", "\u0120post", "\u0120build", ".", "\u0120We", "\u0120`", "pl", "z", "\u0120build", "\u0120:", "B", "`", "\u0120which", "\u0120adds", "\u0120C", "\u0120as", "\u0120a", "\u0120dep", "\u0120of", "\u0120A", ".", "\u0120Won", "'t", "\u0120we", "\u0120queue", "\u0120C", "\u0120to", "\u0120be", "\u0120built", "\u0120even", "\u0120though", "\u0120it", "\u0120only", "\u0120needs", "\u0120to", "\u0120build", "\u0120if", "\u0120A", "\u0120needs", "\u0120to", "\u0120be", "\u0120built", "?", "\u0120That", "'s", "\u0120kinda", "\u0120why", "\u0120I", "\u0120approached", "\u0120this", "\u0120the", "\u0120way", "\u0120I", "\u0120did", ".", "\u0120I", "\u0120trust", "\u0120you", "'ve", "\u0120thought", "\u0120about", "\u0120this", "\u0120but", "\u0120would", "\u0120be", "\u0120good", "\u0120to", "\u0120understand", "\u0120this", "\u0120a", "\u0120bit", "\u0120better", "."]}
{"function": "@@ -123,7 +123,7 @@ def sndrcv(pks, pkt, timeout = None, inter = 0, verbose=None, chainCC=0, retry=0 if remaintime <= 0: break r = None - if arch.FREEBSD or arch.DARWIN: + if not (pks.__class__.__name__ == 'StreamSocket') and (arch.FREEBSD or arch.DARWIN): inp, out, err = select(inmask,[],[], 0.05) if len(inp) == 0 or pks in inp: r = pks.nonblock_recv()", "text": "You should use `isinstance()` instead of comparing the class name to a string.", "function_tokens": ["@@", "\u0120-", "123", ",", "7", "\u0120+", "123", ",", "7", "\u0120@@", "\u0120def", "\u0120s", "nd", "rc", "v", "(", "p", "ks", ",", "\u0120p", "kt", ",", "\u0120timeout", "\u0120=", "\u0120None", ",", "\u0120inter", "\u0120=", "\u01200", ",", "\u0120verb", "ose", "=", "None", ",", "\u0120chain", "CC", "=", "0", ",", "\u0120ret", "ry", "=", "0", "\u0120if", "\u0120remain", "time", "\u0120<=", "\u01200", ":", "\u0120break", "\u0120r", "\u0120=", "\u0120None", "\u0120-", "\u0120if", "\u0120arch", ".", "FREE", "BSD", "\u0120or", "\u0120arch", ".", "D", "AR", "WIN", ":", "\u0120+", "\u0120if", "\u0120not", "\u0120(", "p", "ks", ".", "__", "class", "__", ".", "__", "name", "__", "\u0120==", "\u0120'", "Stream", "Socket", "')", "\u0120and", "\u0120(", "arch", ".", "FREE", "BSD", "\u0120or", "\u0120arch", ".", "D", "AR", "WIN", "):", "\u0120in", "p", ",", "\u0120out", ",", "\u0120err", "\u0120=", "\u0120select", "(", "in", "mask", ",[", "],[", "],", "\u01200", ".", "05", ")", "\u0120if", "\u0120len", "(", "in", "p", ")", "\u0120==", "\u01200", "\u0120or", "\u0120p", "ks", "\u0120in", "\u0120in", "p", ":", "\u0120r", "\u0120=", "\u0120p", "ks", ".", "non", "block", "_", "rec", "v", "()"], "docstring_tokens": ["You", "\u0120should", "\u0120use", "\u0120`", "is", "instance", "()", "`", "\u0120instead", "\u0120of", "\u0120comparing", "\u0120the", "\u0120class", "\u0120name", "\u0120to", "\u0120a", "\u0120string", "."]}
{"function": "@@ -15,6 +15,11 @@ axe.utils.isHidden = function isHidden(el, recursed) { return false; } + // do not exclude `video` or `audio` el's + if ([`VIDEO`, `AUDIO`].includes(el.nodeName.toUpperCase())) { + return false; + } + // 11 === Node.DOCUMENT_FRAGMENT_NODE if (el.nodeType === 11) { el = el.host; // grab the host Node", "text": "Why should audio and video elements always return `false` for `isHidden`?", "function_tokens": ["@@", "\u0120-", "15", ",", "6", "\u0120+", "15", ",", "11", "\u0120@@", "\u0120axe", ".", "utils", ".", "is", "Hidden", "\u0120=", "\u0120function", "\u0120is", "Hidden", "(", "el", ",", "\u0120rec", "ursed", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120+", "\u0120//", "\u0120do", "\u0120not", "\u0120exclude", "\u0120`", "video", "`", "\u0120or", "\u0120`", "audio", "`", "\u0120el", "'s", "\u0120+", "\u0120if", "\u0120([", "`", "VIDEO", "`,", "\u0120`", "AUD", "IO", "`", "].", "includes", "(", "el", ".", "node", "Name", ".", "to", "U", "pper", "Case", "()", "))", "\u0120{", "\u0120+", "\u0120return", "\u0120false", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120//", "\u012011", "\u0120===", "\u0120Node", ".", "DOC", "UM", "ENT", "_", "F", "RAG", "MENT", "_", "N", "ODE", "\u0120if", "\u0120(", "el", ".", "node", "Type", "\u0120===", "\u012011", ")", "\u0120{", "\u0120el", "\u0120=", "\u0120el", ".", "host", ";", "\u0120//", "\u0120grab", "\u0120the", "\u0120host", "\u0120Node"], "docstring_tokens": ["Why", "\u0120should", "\u0120audio", "\u0120and", "\u0120video", "\u0120elements", "\u0120always", "\u0120return", "\u0120`", "false", "`", "\u0120for", "\u0120`", "is", "Hidden", "`", "?"]}
{"function": "@@ -27,7 +27,7 @@ namespace Playground.Core Mvx.IoCProvider.RegisterSingleton<IMvxTextProvider>(new TextProviderBuilder().TextProvider); - RegisterAppStart<RootViewModel>(); + // RegisterAppStart<RootViewModel>(); } /// <summary>", "text": "This obviously won't work for all the other platforms.", "function_tokens": ["@@", "\u0120-", "27", ",", "7", "\u0120+", "27", ",", "7", "\u0120@@", "\u0120namespace", "\u0120Play", "ground", ".", "Core", "\u0120M", "v", "x", ".", "I", "o", "C", "Provider", ".", "Register", "Sing", "leton", "<", "IM", "v", "x", "Text", "Provider", ">(", "new", "\u0120Text", "Provider", "Builder", "().", "Text", "Provider", ");", "\u0120-", "\u0120Register", "App", "Start", "<", "Root", "View", "Model", ">", "();", "\u0120+", "\u0120//", "\u0120Register", "App", "Start", "<", "Root", "View", "Model", ">", "();", "\u0120}", "\u0120///", "\u0120<", "summary", ">"], "docstring_tokens": ["This", "\u0120obviously", "\u0120won", "'t", "\u0120work", "\u0120for", "\u0120all", "\u0120the", "\u0120other", "\u0120platforms", "."]}
{"function": "@@ -15,7 +15,7 @@ public class ManipulationTest extends BasicJBehaveTest { @Override public InjectableStepsFactory stepsFactory() { - Map<String, Object> state = new HashMap<String, Object>(); + Map<String, Object> state = new HashMap<>(); return new InstanceStepsFactory(configuration(), new SharedSteps(state),", "text": "Isn't he diamond operator Java7+?", "function_tokens": ["@@", "\u0120-", "15", ",", "7", "\u0120+", "15", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Manip", "ulation", "Test", "\u0120extends", "\u0120Basic", "J", "Be", "have", "Test", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120In", "ject", "able", "Step", "s", "Factory", "\u0120steps", "Factory", "()", "\u0120{", "\u0120-", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120state", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "String", ",", "\u0120Object", ">", "();", "\u0120+", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120state", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120return", "\u0120new", "\u0120Inst", "ance", "Step", "s", "Factory", "(", "config", "uration", "(),", "\u0120new", "\u0120Shared", "Step", "s", "(", "state", "),"], "docstring_tokens": ["Isn", "'t", "\u0120he", "\u0120diamond", "\u0120operator", "\u0120Java", "7", "+", "?"]}
{"function": "@@ -159,6 +159,17 @@ public final class Require { return number; } + public static double positive(String argName, double number, String message) { + if (number <= 0) { + if (message == null) { + throw new IllegalArgumentException(argName + \" must be greater than 0\"); + } else { + throw new IllegalArgumentException(message); + } + } + return number; + } + public static int positive(String argName, Integer number) { return positive(argName, number, null); }", "text": "Prefer adding a second `positive(String, double)` that delegates down to this three-param version. Using `null` in code is generally Not A Great Idea, and it looks ugly.", "function_tokens": ["@@", "\u0120-", "159", ",", "6", "\u0120+", "159", ",", "17", "\u0120@@", "\u0120public", "\u0120final", "\u0120class", "\u0120Requ", "ire", "\u0120{", "\u0120return", "\u0120number", ";", "\u0120}", "\u0120+", "\u0120public", "\u0120static", "\u0120double", "\u0120positive", "(", "String", "\u0120arg", "Name", ",", "\u0120double", "\u0120number", ",", "\u0120String", "\u0120message", ")", "\u0120{", "\u0120+", "\u0120if", "\u0120(", "number", "\u0120<=", "\u01200", ")", "\u0120{", "\u0120+", "\u0120if", "\u0120(", "message", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120+", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "arg", "Name", "\u0120+", "\u0120\"", "\u0120must", "\u0120be", "\u0120greater", "\u0120than", "\u01200", "\");", "\u0120+", "\u0120}", "\u0120else", "\u0120{", "\u0120+", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "message", ");", "\u0120+", "\u0120}", "\u0120+", "\u0120}", "\u0120+", "\u0120return", "\u0120number", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120public", "\u0120static", "\u0120int", "\u0120positive", "(", "String", "\u0120arg", "Name", ",", "\u0120Integer", "\u0120number", ")", "\u0120{", "\u0120return", "\u0120positive", "(", "arg", "Name", ",", "\u0120number", ",", "\u0120null", ");", "\u0120}"], "docstring_tokens": ["Pre", "fer", "\u0120adding", "\u0120a", "\u0120second", "\u0120`", "positive", "(", "String", ",", "\u0120double", ")", "`", "\u0120that", "\u0120delegates", "\u0120down", "\u0120to", "\u0120this", "\u0120three", "-", "param", "\u0120version", ".", "\u0120Using", "\u0120`", "null", "`", "\u0120in", "\u0120code", "\u0120is", "\u0120generally", "\u0120Not", "\u0120A", "\u0120Great", "\u0120Idea", ",", "\u0120and", "\u0120it", "\u0120looks", "\u0120ugly", "."]}
{"function": "@@ -474,7 +474,7 @@ func (rule removeCount) Name() string { func (rule removeCount) Pattern() plan.Pattern { return plan.Pat(universe.CountKind, plan.Any()) } -func (rule removeCount) Rewrite(ctx context.Context, node plan.Node) (plan.Node, bool, error) { +func (rule removeCount) Rewrite(ctx context.Context, node plan.Node, nextNodeId *int) (plan.Node, bool, error) { return node.Predecessors()[0], true, nil } ", "text": "This pattern, where we add a new parameter without using it, often indicates to me that we've got a leaky interface or abstraction. I see this pattern _a lot_ in this patch, so wondering you have thoughts about it.", "function_tokens": ["@@", "\u0120-", "474", ",", "7", "\u0120+", "474", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "rule", "\u0120remove", "Count", ")", "\u0120Name", "()", "\u0120string", "\u0120{", "\u0120func", "\u0120(", "rule", "\u0120remove", "Count", ")", "\u0120Pattern", "()", "\u0120plan", ".", "Pattern", "\u0120{", "\u0120return", "\u0120plan", ".", "Pat", "(", "un", "iverse", ".", "Count", "Kind", ",", "\u0120plan", ".", "Any", "())", "\u0120}", "\u0120-", "func", "\u0120(", "rule", "\u0120remove", "Count", ")", "\u0120Rew", "rite", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120node", "\u0120plan", ".", "Node", ")", "\u0120(", "plan", ".", "Node", ",", "\u0120bool", ",", "\u0120error", ")", "\u0120{", "\u0120+", "func", "\u0120(", "rule", "\u0120remove", "Count", ")", "\u0120Rew", "rite", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120node", "\u0120plan", ".", "Node", ",", "\u0120next", "Node", "Id", "\u0120*", "int", ")", "\u0120(", "plan", ".", "Node", ",", "\u0120bool", ",", "\u0120error", ")", "\u0120{", "\u0120return", "\u0120node", ".", "Pred", "ec", "essors", "()", "[", "0", "],", "\u0120true", ",", "\u0120nil", "\u0120}", "\u0120"], "docstring_tokens": ["This", "\u0120pattern", ",", "\u0120where", "\u0120we", "\u0120add", "\u0120a", "\u0120new", "\u0120parameter", "\u0120without", "\u0120using", "\u0120it", ",", "\u0120often", "\u0120indicates", "\u0120to", "\u0120me", "\u0120that", "\u0120we", "'ve", "\u0120got", "\u0120a", "\u0120leak", "y", "\u0120interface", "\u0120or", "\u0120abstraction", ".", "\u0120I", "\u0120see", "\u0120this", "\u0120pattern", "\u0120_", "a", "\u0120lot", "_", "\u0120in", "\u0120this", "\u0120patch", ",", "\u0120so", "\u0120wondering", "\u0120you", "\u0120have", "\u0120thoughts", "\u0120about", "\u0120it", "."]}
{"function": "@@ -164,10 +164,13 @@ func WriteWordpressConfig(wordpressConfig *WordpressConfig, filePath string) err return err } - // Ensure target directory is writable. + // Ensure target directory exists and is writeable dir := filepath.Dir(filePath) - err = os.Chmod(dir, 0755) - if err != nil { + if err = os.Chmod(dir, 0755); os.IsNotExist(err) { + if err = os.MkdirAll(dir, 0755); err != nil { + return err + } + } else if err != nil { return err } ", "text": "This seems like an improved pattern :)", "function_tokens": ["@@", "\u0120-", "164", ",", "10", "\u0120+", "164", ",", "13", "\u0120@@", "\u0120func", "\u0120Write", "Word", "press", "Config", "(", "wordpress", "Config", "\u0120*", "Word", "press", "Config", ",", "\u0120file", "Path", "\u0120string", ")", "\u0120err", "\u0120return", "\u0120err", "\u0120}", "\u0120-", "\u0120//", "\u0120Ensure", "\u0120target", "\u0120directory", "\u0120is", "\u0120writ", "able", ".", "\u0120+", "\u0120//", "\u0120Ensure", "\u0120target", "\u0120directory", "\u0120exists", "\u0120and", "\u0120is", "\u0120write", "able", "\u0120dir", "\u0120:=", "\u0120file", "path", ".", "Dir", "(", "file", "Path", ")", "\u0120-", "\u0120err", "\u0120=", "\u0120os", ".", "Ch", "mod", "(", "dir", ",", "\u01200", "755", ")", "\u0120-", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120+", "\u0120if", "\u0120err", "\u0120=", "\u0120os", ".", "Ch", "mod", "(", "dir", ",", "\u01200", "755", ");", "\u0120os", ".", "Is", "Not", "Ex", "ist", "(", "err", ")", "\u0120{", "\u0120+", "\u0120if", "\u0120err", "\u0120=", "\u0120os", ".", "M", "k", "dir", "All", "(", "dir", ",", "\u01200", "755", ");", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120+", "\u0120return", "\u0120err", "\u0120+", "\u0120}", "\u0120+", "\u0120}", "\u0120else", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120return", "\u0120err", "\u0120}", "\u0120"], "docstring_tokens": ["This", "\u0120seems", "\u0120like", "\u0120an", "\u0120improved", "\u0120pattern", "\u0120:)"]}
{"function": "@@ -127,16 +127,16 @@ class UserController < ApplicationController # valid OpenID and one the user has control over before saving # it as a password equivalent for the user. session[:new_user_settings] = params - openid_verify(params[:user][:openid_url], @user) + federated_verify(params[:user][:openid_url], @user) else update_user(@user, params) end - elsif using_open_id? + elsif using_federated_login? # The redirect from the OpenID provider reenters here # again and we need to pass the parameters through to # the open_id_authentication function settings = session.delete(:new_user_settings) - openid_verify(nil, @user) do |user| + federated_verify(nil, @user) do |user| update_user(user, settings) end end", "text": "`open_id_authentication` is no longer the name of the function, and it's not OpenID specific", "function_tokens": ["@@", "\u0120-", "127", ",", "16", "\u0120+", "127", ",", "16", "\u0120@@", "\u0120class", "\u0120User", "Controller", "\u0120<", "\u0120Application", "Controller", "\u0120#", "\u0120valid", "\u0120Open", "ID", "\u0120and", "\u0120one", "\u0120the", "\u0120user", "\u0120has", "\u0120control", "\u0120over", "\u0120before", "\u0120saving", "\u0120#", "\u0120it", "\u0120as", "\u0120a", "\u0120password", "\u0120equivalent", "\u0120for", "\u0120the", "\u0120user", ".", "\u0120session", "[", ":", "new", "_", "user", "_", "settings", "]", "\u0120=", "\u0120params", "\u0120-", "\u0120open", "id", "_", "ver", "ify", "(", "params", "[", ":", "user", "][", ":", "open", "id", "_", "url", "],", "\u0120@", "user", ")", "\u0120+", "\u0120feder", "ated", "_", "ver", "ify", "(", "params", "[", ":", "user", "][", ":", "open", "id", "_", "url", "],", "\u0120@", "user", ")", "\u0120else", "\u0120update", "_", "user", "(", "@", "user", ",", "\u0120params", ")", "\u0120end", "\u0120-", "\u0120el", "s", "if", "\u0120using", "_", "open", "_", "id", "?", "\u0120+", "\u0120el", "s", "if", "\u0120using", "_", "f", "eder", "ated", "_", "login", "?", "\u0120#", "\u0120The", "\u0120redirect", "\u0120from", "\u0120the", "\u0120Open", "ID", "\u0120provider", "\u0120re", "ent", "ers", "\u0120here", "\u0120#", "\u0120again", "\u0120and", "\u0120we", "\u0120need", "\u0120to", "\u0120pass", "\u0120the", "\u0120parameters", "\u0120through", "\u0120to", "\u0120#", "\u0120the", "\u0120open", "_", "id", "_", "authent", "ication", "\u0120function", "\u0120settings", "\u0120=", "\u0120session", ".", "delete", "(", ":", "new", "_", "user", "_", "settings", ")", "\u0120-", "\u0120open", "id", "_", "ver", "ify", "(", "nil", ",", "\u0120@", "user", ")", "\u0120do", "\u0120|", "user", "|", "\u0120+", "\u0120feder", "ated", "_", "ver", "ify", "(", "nil", ",", "\u0120@", "user", ")", "\u0120do", "\u0120|", "user", "|", "\u0120update", "_", "user", "(", "user", ",", "\u0120settings", ")", "\u0120end", "\u0120end"], "docstring_tokens": ["`", "open", "_", "id", "_", "authent", "ication", "`", "\u0120is", "\u0120no", "\u0120longer", "\u0120the", "\u0120name", "\u0120of", "\u0120the", "\u0120function", ",", "\u0120and", "\u0120it", "'s", "\u0120not", "\u0120Open", "ID", "\u0120specific"]}
{"function": "@@ -243,10 +243,10 @@ void rai_qt::accounts::refresh_wallet_balance () balance = balance + (this->wallet.node.ledger.account_balance (transaction, key)); pending = pending + (this->wallet.node.ledger.account_pending (transaction, key)); } - auto final_text (std::string (\"Wallet balance (XRB): \") + wallet.format_balance (balance)); + auto final_text (std::string (\"Balance: \") + wallet.format_balance (balance)); if (!pending.is_zero ()) { - final_text += \"\\nWallet pending: \" + wallet.format_balance (pending); + final_text += \"\\nPending: \" + wallet.format_balance (pending); } wallet_balance_label->setText (QString (final_text.c_str ())); this->wallet.node.alarm.add (std::chrono::system_clock::now () + std::chrono::seconds (60), [this]() {", "text": "This didn't require corresponding changes to the test case(s)?", "function_tokens": ["@@", "\u0120-", "243", ",", "10", "\u0120+", "243", ",", "10", "\u0120@@", "\u0120void", "\u0120r", "ai", "_", "qt", "::", "account", "s", "::", "ref", "resh", "_", "wallet", "_", "balance", "\u0120()", "\u0120balance", "\u0120=", "\u0120balance", "\u0120+", "\u0120(", "this", "->", "wallet", ".", "node", ".", "led", "ger", ".", "account", "_", "balance", "\u0120(", "trans", "action", ",", "\u0120key", "));", "\u0120pending", "\u0120=", "\u0120pending", "\u0120+", "\u0120(", "this", "->", "wallet", ".", "node", ".", "led", "ger", ".", "account", "_", "p", "ending", "\u0120(", "trans", "action", ",", "\u0120key", "));", "\u0120}", "\u0120-", "\u0120auto", "\u0120final", "_", "text", "\u0120(", "std", "::", "string", "\u0120(\"", "Wallet", "\u0120balance", "\u0120(", "X", "RB", "):", "\u0120\"", ")", "\u0120+", "\u0120wallet", ".", "format", "_", "balance", "\u0120(", "balance", "));", "\u0120+", "\u0120auto", "\u0120final", "_", "text", "\u0120(", "std", "::", "string", "\u0120(\"", "Balance", ":", "\u0120\"", ")", "\u0120+", "\u0120wallet", ".", "format", "_", "balance", "\u0120(", "balance", "));", "\u0120if", "\u0120(!", "p", "ending", ".", "is", "_", "zero", "\u0120())", "\u0120{", "\u0120-", "\u0120final", "_", "text", "\u0120+=", "\u0120\"\\", "n", "Wallet", "\u0120pending", ":", "\u0120\"", "\u0120+", "\u0120wallet", ".", "format", "_", "balance", "\u0120(", "p", "ending", ");", "\u0120+", "\u0120final", "_", "text", "\u0120+=", "\u0120\"\\", "n", "P", "ending", ":", "\u0120\"", "\u0120+", "\u0120wallet", ".", "format", "_", "balance", "\u0120(", "p", "ending", ");", "\u0120}", "\u0120wallet", "_", "balance", "_", "label", "->", "set", "Text", "\u0120(", "Q", "String", "\u0120(", "final", "_", "text", ".", "c", "_", "str", "\u0120())", ");", "\u0120this", "->", "wallet", ".", "node", ".", "al", "arm", ".", "add", "\u0120(", "std", "::", "chron", "o", "::", "system", "_", "clock", "::", "now", "\u0120()", "\u0120+", "\u0120std", "::", "chron", "o", "::", "seconds", "\u0120(", "60", "),", "\u0120[", "this", "]", "()", "\u0120{"], "docstring_tokens": ["This", "\u0120didn", "'t", "\u0120require", "\u0120corresponding", "\u0120changes", "\u0120to", "\u0120the", "\u0120test", "\u0120case", "(", "s", ")?"]}
{"function": "@@ -509,6 +509,7 @@ type TaskConfig struct { Count Count `yaml:\"count\"` ExecuteCommand ExecuteCommand `yaml:\"exec\"` Variables map[string]string `yaml:\"variables\"` + EnvFile string `yaml:\"env_file\"` Secrets map[string]string `yaml:\"secrets\"` Storage Storage `yaml:\"storage\"` }", "text": "A question! I think `string` totally works, but what do you think of `*string` for consistency?", "function_tokens": ["@@", "\u0120-", "509", ",", "6", "\u0120+", "509", ",", "7", "\u0120@@", "\u0120type", "\u0120Task", "Config", "\u0120struct", "\u0120{", "\u0120Count", "\u0120Count", "\u0120`", "y", "aml", ":\"", "count", "\"", "`", "\u0120Exec", "ute", "Command", "\u0120Exec", "ute", "Command", "\u0120`", "y", "aml", ":\"", "exec", "\"", "`", "\u0120Vari", "ables", "\u0120map", "[", "string", "]", "string", "\u0120`", "y", "aml", ":\"", "vari", "ables", "\"", "`", "\u0120+", "\u0120En", "v", "File", "\u0120string", "\u0120`", "y", "aml", ":\"", "env", "_", "file", "\"", "`", "\u0120Secrets", "\u0120map", "[", "string", "]", "string", "\u0120`", "y", "aml", ":\"", "sec", "rets", "\"", "`", "\u0120Storage", "\u0120Storage", "\u0120`", "y", "aml", ":\"", "storage", "\"", "`", "\u0120}"], "docstring_tokens": ["A", "\u0120question", "!", "\u0120I", "\u0120think", "\u0120`", "string", "`", "\u0120totally", "\u0120works", ",", "\u0120but", "\u0120what", "\u0120do", "\u0120you", "\u0120think", "\u0120of", "\u0120`", "*", "string", "`", "\u0120for", "\u0120consistency", "?"]}
{"function": "@@ -25,6 +25,12 @@ import ( metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\" ) +const ( + AnnotationClusterInfrastructureReady = \"aws.cluster.sigs.k8s.io/infrastructure-ready\" + AnnotationControlPlaneReady = \"aws.cluster.sigs.k8s.io/control-plane-ready\" + ValueReady = \"true\" +) + // AWSResourceReference is a reference to a specific AWS resource by ID, ARN, or filters. // Only one of ID, ARN or Filters may be specified. Specifying more than one will result in // a validation error.", "text": "Should this be: `aws.infrastructure.cluster.sigs.k8s.io` instead?", "function_tokens": ["@@", "\u0120-", "25", ",", "6", "\u0120+", "25", ",", "12", "\u0120@@", "\u0120import", "\u0120(", "\u0120met", "av", "1", "\u0120\"", "k", "8", "s", ".", "io", "/", "ap", "im", "ach", "inery", "/", "pkg", "/", "ap", "is", "/", "meta", "/", "v", "1", "\"", "\u0120)", "\u0120+", "const", "\u0120(", "\u0120+", "\u0120An", "notation", "Cl", "uster", "Inf", "rastructure", "Ready", "\u0120=", "\u0120\"", "aws", ".", "cl", "uster", ".", "s", "igs", ".", "k", "8", "s", ".", "io", "/", "inf", "rastructure", "-", "ready", "\"", "\u0120+", "\u0120An", "notation", "Control", "Pl", "ane", "Ready", "\u0120=", "\u0120\"", "aws", ".", "cl", "uster", ".", "s", "igs", ".", "k", "8", "s", ".", "io", "/", "control", "-", "plane", "-", "ready", "\"", "\u0120+", "\u0120Value", "Ready", "\u0120=", "\u0120\"", "true", "\"", "\u0120+", ")", "\u0120+", "\u0120//", "\u0120AWS", "Resource", "Reference", "\u0120is", "\u0120a", "\u0120reference", "\u0120to", "\u0120a", "\u0120specific", "\u0120AWS", "\u0120resource", "\u0120by", "\u0120ID", ",", "\u0120AR", "N", ",", "\u0120or", "\u0120filters", ".", "\u0120//", "\u0120Only", "\u0120one", "\u0120of", "\u0120ID", ",", "\u0120AR", "N", "\u0120or", "\u0120Fil", "ters", "\u0120may", "\u0120be", "\u0120specified", ".", "\u0120Spec", "ifying", "\u0120more", "\u0120than", "\u0120one", "\u0120will", "\u0120result", "\u0120in", "\u0120//", "\u0120a", "\u0120validation", "\u0120error", "."], "docstring_tokens": ["Should", "\u0120this", "\u0120be", ":", "\u0120`", "aws", ".", "inf", "rastructure", ".", "cl", "uster", ".", "s", "igs", ".", "k", "8", "s", ".", "io", "`", "\u0120instead", "?"]}
{"function": "@@ -142,7 +142,7 @@ void PairLubricate::compute(int eflag, int vflag) Ef[2][2] = h_rate[2]/domain->zprd; Ef[0][1] = Ef[1][0] = 0.5 * h_rate[5]/domain->yprd; Ef[0][2] = Ef[2][0] = 0.5 * h_rate[4]/domain->zprd; - Ef[1][2] = Ef[2][1] = 0.5 * h_rate[3]/domain->zprd; + Ef[1][2] = Ef[2][1] = 0.5 * h_rate[3]/domain->xprd; // copy updated velocity/omega/angmom to the ghost particles // no need to do this if not shearing since comm->ghost_velocity is set", "text": "Not clear on why this change is correct.", "function_tokens": ["@@", "\u0120-", "142", ",", "7", "\u0120+", "142", ",", "7", "\u0120@@", "\u0120void", "\u0120Pair", "L", "ubric", "ate", "::", "comp", "ute", "(", "int", "\u0120e", "flag", ",", "\u0120int", "\u0120v", "flag", ")", "\u0120E", "f", "[", "2", "][", "2", "]", "\u0120=", "\u0120h", "_", "rate", "[", "2", "]", "/", "domain", "->", "z", "pr", "d", ";", "\u0120E", "f", "[", "0", "][", "1", "]", "\u0120=", "\u0120E", "f", "[", "1", "][", "0", "]", "\u0120=", "\u01200", ".", "5", "\u0120*", "\u0120h", "_", "rate", "[", "5", "]", "/", "domain", "->", "y", "pr", "d", ";", "\u0120E", "f", "[", "0", "][", "2", "]", "\u0120=", "\u0120E", "f", "[", "2", "][", "0", "]", "\u0120=", "\u01200", ".", "5", "\u0120*", "\u0120h", "_", "rate", "[", "4", "]", "/", "domain", "->", "z", "pr", "d", ";", "\u0120-", "\u0120E", "f", "[", "1", "][", "2", "]", "\u0120=", "\u0120E", "f", "[", "2", "][", "1", "]", "\u0120=", "\u01200", ".", "5", "\u0120*", "\u0120h", "_", "rate", "[", "3", "]", "/", "domain", "->", "z", "pr", "d", ";", "\u0120+", "\u0120E", "f", "[", "1", "][", "2", "]", "\u0120=", "\u0120E", "f", "[", "2", "][", "1", "]", "\u0120=", "\u01200", ".", "5", "\u0120*", "\u0120h", "_", "rate", "[", "3", "]", "/", "domain", "->", "x", "pr", "d", ";", "\u0120//", "\u0120copy", "\u0120updated", "\u0120velocity", "/", "ome", "ga", "/", "ang", "mom", "\u0120to", "\u0120the", "\u0120ghost", "\u0120particles", "\u0120//", "\u0120no", "\u0120need", "\u0120to", "\u0120do", "\u0120this", "\u0120if", "\u0120not", "\u0120she", "aring", "\u0120since", "\u0120comm", "->", "ghost", "_", "vel", "ocity", "\u0120is", "\u0120set"], "docstring_tokens": ["Not", "\u0120clear", "\u0120on", "\u0120why", "\u0120this", "\u0120change", "\u0120is", "\u0120correct", "."]}
{"function": "@@ -193,5 +193,10 @@ public final class ByteBuffersIndexInput extends IndexInput implements RandomAcc if (in == null) { throw new AlreadyClosedException(\"Already closed.\"); } - } + } + + @Override + public boolean isMMapped() { + return true; + } }", "text": "Hi Simon. Whether this should return true depends on what byte buffers are used? The same applies to ByteBufferIndexInput, actually... I don't think you can generally tell whether the ByteBuffers the input operates on come from a mmap call or from somewhere else (even direct buffers don't have to be a result of mmap).", "function_tokens": ["@@", "\u0120-", "193", ",", "5", "\u0120+", "193", ",", "10", "\u0120@@", "\u0120public", "\u0120final", "\u0120class", "\u0120Byte", "Buff", "ers", "Index", "Input", "\u0120extends", "\u0120Index", "Input", "\u0120implements", "\u0120Random", "Acc", "\u0120if", "\u0120(", "in", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Already", "Cl", "osed", "Exception", "(\"", "Already", "\u0120closed", ".\"", ");", "\u0120}", "\u0120-", "\u0120}", "\u0120+", "\u0120}", "\u0120+", "\u0120+", "\u0120@", "Override", "\u0120+", "\u0120public", "\u0120boolean", "\u0120is", "MM", "apped", "()", "\u0120{", "\u0120+", "\u0120return", "\u0120true", ";", "\u0120+", "\u0120}", "\u0120}"], "docstring_tokens": ["Hi", "\u0120Simon", ".", "\u0120Whether", "\u0120this", "\u0120should", "\u0120return", "\u0120true", "\u0120depends", "\u0120on", "\u0120what", "\u0120byte", "\u0120buffers", "\u0120are", "\u0120used", "?", "\u0120The", "\u0120same", "\u0120applies", "\u0120to", "\u0120Byte", "Buffer", "Index", "Input", ",", "\u0120actually", "...", "\u0120I", "\u0120don", "'t", "\u0120think", "\u0120you", "\u0120can", "\u0120generally", "\u0120tell", "\u0120whether", "\u0120the", "\u0120Byte", "Buff", "ers", "\u0120the", "\u0120input", "\u0120operates", "\u0120on", "\u0120come", "\u0120from", "\u0120a", "\u0120mm", "ap", "\u0120call", "\u0120or", "\u0120from", "\u0120somewhere", "\u0120else", "\u0120(", "even", "\u0120direct", "\u0120buffers", "\u0120don", "'t", "\u0120have", "\u0120to", "\u0120be", "\u0120a", "\u0120result", "\u0120of", "\u0120mm", "ap", ")."]}
{"function": "@@ -54,6 +54,7 @@ storiesOf( 'PageSpeed Insights Module/Settings', module ) decorators: [ withRegistry, ], + padding: 0, } ) .add( 'View, open with all settings', ( args, { registry } ) => { return <Settings isOpen={ true } registry={ registry } />;", "text": "All stories in this file also need to have the default padding.", "function_tokens": ["@@", "\u0120-", "54", ",", "6", "\u0120+", "54", ",", "7", "\u0120@@", "\u0120stories", "Of", "(", "\u0120'", "Page", "Speed", "\u0120Ins", "ights", "\u0120Module", "/", "Settings", "',", "\u0120module", "\u0120)", "\u0120decor", "ators", ":", "\u0120[", "\u0120with", "Reg", "istry", ",", "\u0120],", "\u0120+", "\u0120padding", ":", "\u01200", ",", "\u0120}", "\u0120)", "\u0120.", "add", "(", "\u0120'", "View", ",", "\u0120open", "\u0120with", "\u0120all", "\u0120settings", "',", "\u0120(", "\u0120args", ",", "\u0120{", "\u0120registry", "\u0120}", "\u0120)", "\u0120=>", "\u0120{", "\u0120return", "\u0120<", "Settings", "\u0120is", "Open", "={", "\u0120true", "\u0120}", "\u0120registry", "={", "\u0120registry", "\u0120}", "\u0120/>", ";"], "docstring_tokens": ["All", "\u0120stories", "\u0120in", "\u0120this", "\u0120file", "\u0120also", "\u0120need", "\u0120to", "\u0120have", "\u0120the", "\u0120default", "\u0120padding", "."]}
{"function": "@@ -804,8 +804,10 @@ static void subsurface_handle_place_above(struct wl_client *client, return; } + assert(sibling->parent == subsurface->parent); + wl_list_remove(&subsurface->parent_pending_link); - wl_list_insert(&sibling->parent_pending_link, + wl_list_insert(sibling->parent_pending_link.prev, &subsurface->parent_pending_link); subsurface->reordered = true;", "text": "I don't think these asserts are necessary, because `subsurface_find_sibling` already searches in the parent. Or am I missing something?", "function_tokens": ["@@", "\u0120-", "804", ",", "8", "\u0120+", "804", ",", "10", "\u0120@@", "\u0120static", "\u0120void", "\u0120subs", "ur", "face", "_", "handle", "_", "place", "_", "above", "(", "struct", "\u0120w", "l", "_", "client", "\u0120*", "client", ",", "\u0120return", ";", "\u0120}", "\u0120+", "\u0120assert", "(", "s", "ibling", "->", "parent", "\u0120==", "\u0120subs", "ur", "face", "->", "parent", ");", "\u0120+", "\u0120w", "l", "_", "list", "_", "remove", "(&", "sub", "surface", "->", "parent", "_", "p", "ending", "_", "link", ");", "\u0120-", "\u0120w", "l", "_", "list", "_", "insert", "(&", "s", "ibling", "->", "parent", "_", "p", "ending", "_", "link", ",", "\u0120+", "\u0120w", "l", "_", "list", "_", "insert", "(", "s", "ibling", "->", "parent", "_", "p", "ending", "_", "link", ".", "prev", ",", "\u0120&", "sub", "surface", "->", "parent", "_", "p", "ending", "_", "link", ");", "\u0120subs", "ur", "face", "->", "re", "ordered", "\u0120=", "\u0120true", ";"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120these", "\u0120asserts", "\u0120are", "\u0120necessary", ",", "\u0120because", "\u0120`", "sub", "surface", "_", "find", "_", "s", "ibling", "`", "\u0120already", "\u0120searches", "\u0120in", "\u0120the", "\u0120parent", ".", "\u0120Or", "\u0120am", "\u0120I", "\u0120missing", "\u0120something", "?"]}
{"function": "@@ -0,0 +1,15 @@ +class Episode < ActiveRecord::Base + attr_accessible :title, :duration, :file, :description, :published_on, :notes, + :old_url, :file_size + + validates_presence_of :title, :duration, :file, :file_size, :description, + :published_on + + def self.published + where(\"published_on <= ?\", Date.today).order('published_on desc') + end + + def full_title + \"Episode #{id}: #{title}\" + end +end", "text": "Should this be `number` instead of `id`?", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "15", "\u0120@@", "\u0120+", "class", "\u0120Episode", "\u0120<", "\u0120Active", "Record", "::", "Base", "\u0120+", "\u0120att", "r", "_", "accessible", "\u0120:", "title", ",", "\u0120:", "duration", ",", "\u0120:", "file", ",", "\u0120:", "description", ",", "\u0120:", "published", "_", "on", ",", "\u0120:", "notes", ",", "\u0120+", "\u0120:", "old", "_", "url", ",", "\u0120:", "file", "_", "size", "\u0120+", "\u0120+", "\u0120valid", "ates", "_", "pres", "ence", "_", "of", "\u0120:", "title", ",", "\u0120:", "duration", ",", "\u0120:", "file", ",", "\u0120:", "file", "_", "size", ",", "\u0120:", "description", ",", "\u0120+", "\u0120:", "published", "_", "on", "\u0120+", "\u0120+", "\u0120def", "\u0120self", ".", "published", "\u0120+", "\u0120where", "(\"", "published", "_", "on", "\u0120<=", "\u0120?", "\",", "\u0120Date", ".", "today", ").", "order", "('", "published", "_", "on", "\u0120desc", "')", "\u0120+", "\u0120end", "\u0120+", "\u0120+", "\u0120def", "\u0120full", "_", "title", "\u0120+", "\u0120\"", "Episode", "\u0120#", "{", "id", "}:", "\u0120#", "{", "title", "}\"", "\u0120+", "\u0120end", "\u0120+", "end"], "docstring_tokens": ["Should", "\u0120this", "\u0120be", "\u0120`", "number", "`", "\u0120instead", "\u0120of", "\u0120`", "id", "`", "?"]}
{"function": "@@ -1569,12 +1569,11 @@ NATable *BindWA::getNATable(CorrName& corrName, ((QualifiedName&)(table->getTableName())).setIsVolatile(TRUE); } - // For now, do not allow access through the Trafodion external name created for - // the HIVE object unless the inDDL flag is set. inDDL is set for drop - // table and SHOWDDL statements. - // TDB - may want to merge the Trafodion version with the HIVE version. - // TDB - similar operation may be needed for external HBase tables - if ((table) && (table->isExternalTable() && (! bindWA->inDDL()))) + // For now, don't allow access through the Trafodion external name created for + // native HIVE or HBASE objects unless the allowExternalTables flag is set. + // allowExternalTables is set for drop table and SHOWDDL statements. + // TDB - may want to merge the Trafodion version with the native version. + if ((table) && (table->isExternalTable() && (! bindWA->allowExternalTables()))) { *CmpCommon::diags() << DgSqlCode(-4258) << DgTableName(table->getTableName().getQualifiedNameAsAnsiString());", "text": "I have forgotten why we thought this restriction is necessary. A user registers a Hive/HBase table with us but is not able to use the table with the registered name in DML. Will UPDATE STATs will be on the original name too (and update stats code will find out registered name and use it for Table_uid?). This was the registration concept is almost like an internal implementation idea, at some point could even be done by some utility program for all existing Hive/hBase tables, and the user need not be aware of it? I am struggling with a user would want to register a table, if they cannot use it by that name.", "function_tokens": ["@@", "\u0120-", "15", "69", ",", "12", "\u0120+", "15", "69", ",", "11", "\u0120@@", "\u0120NAT", "able", "\u0120*", "Bind", "WA", "::", "get", "NAT", "able", "(", "Cor", "r", "Name", "&", "\u0120cor", "r", "Name", ",", "\u0120((", "Qual", "ified", "Name", "&", ")(", "table", "->", "get", "Table", "Name", "())", ").", "set", "Is", "Vol", "atile", "(", "TR", "UE", ");", "\u0120}", "\u0120-", "\u0120//", "\u0120For", "\u0120now", ",", "\u0120do", "\u0120not", "\u0120allow", "\u0120access", "\u0120through", "\u0120the", "\u0120Tra", "f", "od", "ion", "\u0120external", "\u0120name", "\u0120created", "\u0120for", "\u0120-", "\u0120//", "\u0120the", "\u0120H", "IVE", "\u0120object", "\u0120unless", "\u0120the", "\u0120in", "DD", "L", "\u0120flag", "\u0120is", "\u0120set", ".", "\u0120in", "DD", "L", "\u0120is", "\u0120set", "\u0120for", "\u0120drop", "\u0120-", "\u0120//", "\u0120table", "\u0120and", "\u0120SHOW", "DD", "L", "\u0120statements", ".", "\u0120-", "\u0120//", "\u0120T", "DB", "\u0120-", "\u0120may", "\u0120want", "\u0120to", "\u0120merge", "\u0120the", "\u0120Tra", "f", "od", "ion", "\u0120version", "\u0120with", "\u0120the", "\u0120H", "IVE", "\u0120version", ".", "\u0120-", "\u0120//", "\u0120T", "DB", "\u0120-", "\u0120similar", "\u0120operation", "\u0120may", "\u0120be", "\u0120needed", "\u0120for", "\u0120external", "\u0120H", "Base", "\u0120tables", "\u0120-", "\u0120if", "\u0120((", "table", ")", "\u0120&&", "\u0120(", "table", "->", "is", "External", "Table", "()", "\u0120&&", "\u0120(!", "\u0120bind", "WA", "->", "in", "DD", "L", "()", ")))", "\u0120+", "\u0120//", "\u0120For", "\u0120now", ",", "\u0120don", "'t", "\u0120allow", "\u0120access", "\u0120through", "\u0120the", "\u0120Tra", "f", "od", "ion", "\u0120external", "\u0120name", "\u0120created", "\u0120for", "\u0120+", "\u0120//", "\u0120native", "\u0120H", "IVE", "\u0120or", "\u0120HB", "ASE", "\u0120objects", "\u0120unless", "\u0120the", "\u0120allow", "External", "T", "ables", "\u0120flag", "\u0120is", "\u0120set", ".", "\u0120+", "\u0120//", "\u0120allow", "External", "T", "ables", "\u0120is", "\u0120set", "\u0120for", "\u0120drop", "\u0120table", "\u0120and", "\u0120SHOW", "DD", "L", "\u0120statements", ".", "\u0120+", "\u0120//", "\u0120T", "DB", "\u0120-", "\u0120may", "\u0120want", "\u0120to", "\u0120merge", "\u0120the", "\u0120Tra", "f", "od", "ion", "\u0120version", "\u0120with", "\u0120the", "\u0120native", "\u0120version", ".", "\u0120+", "\u0120if", "\u0120((", "table", ")", "\u0120&&", "\u0120(", "table", "->", "is", "External", "Table", "()", "\u0120&&", "\u0120(!", "\u0120bind", "WA", "->", "allow", "External", "T", "ables", "()", ")))", "\u0120{", "\u0120*", "C", "mp", "Common", "::", "di", "ags", "()", "\u0120<<", "\u0120D", "g", "S", "ql", "Code", "(-", "4", "258", ")", "\u0120<<", "\u0120D", "g", "Table", "Name", "(", "table", "->", "get", "Table", "Name", "().", "get", "Qual", "ified", "Name", "As", "An", "si", "String", "());"], "docstring_tokens": ["I", "\u0120have", "\u0120forgotten", "\u0120why", "\u0120we", "\u0120thought", "\u0120this", "\u0120restriction", "\u0120is", "\u0120necessary", ".", "\u0120A", "\u0120user", "\u0120registers", "\u0120a", "\u0120Hive", "/", "H", "Base", "\u0120table", "\u0120with", "\u0120us", "\u0120but", "\u0120is", "\u0120not", "\u0120able", "\u0120to", "\u0120use", "\u0120the", "\u0120table", "\u0120with", "\u0120the", "\u0120registered", "\u0120name", "\u0120in", "\u0120D", "ML", ".", "\u0120Will", "\u0120UPDATE", "\u0120STAT", "s", "\u0120will", "\u0120be", "\u0120on", "\u0120the", "\u0120original", "\u0120name", "\u0120too", "\u0120(", "and", "\u0120update", "\u0120stats", "\u0120code", "\u0120will", "\u0120find", "\u0120out", "\u0120registered", "\u0120name", "\u0120and", "\u0120use", "\u0120it", "\u0120for", "\u0120Table", "_", "uid", "?).", "\u0120This", "\u0120was", "\u0120the", "\u0120registration", "\u0120concept", "\u0120is", "\u0120almost", "\u0120like", "\u0120an", "\u0120internal", "\u0120implementation", "\u0120idea", ",", "\u0120at", "\u0120some", "\u0120point", "\u0120could", "\u0120even", "\u0120be", "\u0120done", "\u0120by", "\u0120some", "\u0120utility", "\u0120program", "\u0120for", "\u0120all", "\u0120existing", "\u0120Hive", "/", "h", "Base", "\u0120tables", ",", "\u0120and", "\u0120the", "\u0120user", "\u0120need", "\u0120not", "\u0120be", "\u0120aware", "\u0120of", "\u0120it", "?", "\u0120I", "\u0120am", "\u0120struggling", "\u0120with", "\u0120a", "\u0120user", "\u0120would", "\u0120want", "\u0120to", "\u0120register", "\u0120a", "\u0120table", ",", "\u0120if", "\u0120they", "\u0120cannot", "\u0120use", "\u0120it", "\u0120by", "\u0120that", "\u0120name", "."]}
{"function": "@@ -40,6 +40,18 @@ struct ase_cfg_t *cfg; +int app2sim_alloc_rx; // app2sim mesaage queue in RX mode +int sim2app_alloc_tx; // sim2app mesaage queue in TX mode +int app2sim_mmioreq_rx; // MMIO Request path +int sim2app_mmiorsp_tx; // MMIO Response path +int app2sim_umsg_rx; // UMSG message queue in RX mode +int app2sim_portctrl_req_rx; // Port Control messages in Rx mode +int app2sim_dealloc_rx; +int sim2app_dealloc_tx; +int sim2app_portctrl_rsp_tx; +int sim2app_intr_request_tx; +int intr_event_fds[MAX_USR_INTRS]; + int glbl_test_cmplt_cnt; // Keeps the number of session_deinits received volatile int sockserver_kill;", "text": "Should most of these non-globals be static?", "function_tokens": ["@@", "\u0120-", "40", ",", "6", "\u0120+", "40", ",", "18", "\u0120@@", "\u0120struct", "\u0120a", "se", "_", "cfg", "_", "t", "\u0120*", "cfg", ";", "\u0120+", "int", "\u0120app", "2", "sim", "_", "alloc", "_", "rx", ";", "\u0120//", "\u0120app", "2", "sim", "\u0120mes", "a", "age", "\u0120queue", "\u0120in", "\u0120RX", "\u0120mode", "\u0120+", "int", "\u0120sim", "2", "app", "_", "alloc", "_", "tx", ";", "\u0120//", "\u0120sim", "2", "app", "\u0120mes", "a", "age", "\u0120queue", "\u0120in", "\u0120TX", "\u0120mode", "\u0120+", "int", "\u0120app", "2", "sim", "_", "mm", "i", "ore", "q", "_", "rx", ";", "\u0120//", "\u0120M", "MI", "O", "\u0120Request", "\u0120path", "\u0120+", "int", "\u0120sim", "2", "app", "_", "mm", "iors", "p", "_", "tx", ";", "\u0120//", "\u0120M", "MI", "O", "\u0120Response", "\u0120path", "\u0120+", "int", "\u0120app", "2", "sim", "_", "ums", "g", "_", "rx", ";", "\u0120//", "\u0120U", "MS", "G", "\u0120message", "\u0120queue", "\u0120in", "\u0120RX", "\u0120mode", "\u0120+", "int", "\u0120app", "2", "sim", "_", "port", "ctrl", "_", "req", "_", "rx", ";", "\u0120//", "\u0120Port", "\u0120Control", "\u0120messages", "\u0120in", "\u0120Rx", "\u0120mode", "\u0120+", "int", "\u0120app", "2", "sim", "_", "de", "alloc", "_", "rx", ";", "\u0120+", "int", "\u0120sim", "2", "app", "_", "de", "alloc", "_", "tx", ";", "\u0120+", "int", "\u0120sim", "2", "app", "_", "port", "ctrl", "_", "r", "sp", "_", "tx", ";", "\u0120+", "int", "\u0120sim", "2", "app", "_", "int", "r", "_", "request", "_", "tx", ";", "\u0120+", "int", "\u0120intr", "_", "event", "_", "f", "ds", "[", "MAX", "_", "US", "R", "_", "IN", "TR", "S", "];", "\u0120+", "\u0120int", "\u0120gl", "bl", "_", "test", "_", "cm", "pl", "t", "_", "c", "nt", ";", "\u0120//", "\u0120Keep", "s", "\u0120the", "\u0120number", "\u0120of", "\u0120session", "_", "de", "in", "its", "\u0120received", "\u0120volatile", "\u0120int", "\u0120socks", "erver", "_", "kill", ";"], "docstring_tokens": ["Should", "\u0120most", "\u0120of", "\u0120these", "\u0120non", "-", "gl", "ob", "als", "\u0120be", "\u0120static", "?"]}
{"function": "@@ -14,6 +14,14 @@ class TestFakerName < Test::Unit::TestCase assert @tester.name_with_middle.match(/(\\w+\\.? ?){3,4}/) end + def test_first_name + assert @tester.first_name.match(/(\\w+\\.? ?){3,4}/) + end + + def test_last_name + assert @tester.last_name.match(/(\\w+\\.? ?){3,4}/) + end + def test_prefix assert @tester.prefix.match(/[A-Z][a-z]+\\.?/) end", "text": "Please do not approve PRs without tests!!!!", "function_tokens": ["@@", "\u0120-", "14", ",", "6", "\u0120+", "14", ",", "14", "\u0120@@", "\u0120class", "\u0120Test", "F", "aker", "Name", "\u0120<", "\u0120Test", "::", "Unit", "::", "Test", "Case", "\u0120assert", "\u0120@", "tes", "ter", ".", "name", "_", "with", "_", "middle", ".", "match", "(", "/(", "\\", "w", "+", "\\.", "?", "\u0120?", "){", "3", ",", "4", "}", "/)", "\u0120end", "\u0120+", "\u0120def", "\u0120test", "_", "first", "_", "name", "\u0120+", "\u0120assert", "\u0120@", "tes", "ter", ".", "first", "_", "name", ".", "match", "(", "/(", "\\", "w", "+", "\\.", "?", "\u0120?", "){", "3", ",", "4", "}", "/)", "\u0120+", "\u0120end", "\u0120+", "\u0120+", "\u0120def", "\u0120test", "_", "last", "_", "name", "\u0120+", "\u0120assert", "\u0120@", "tes", "ter", ".", "last", "_", "name", ".", "match", "(", "/(", "\\", "w", "+", "\\.", "?", "\u0120?", "){", "3", ",", "4", "}", "/)", "\u0120+", "\u0120end", "\u0120+", "\u0120def", "\u0120test", "_", "prefix", "\u0120assert", "\u0120@", "tes", "ter", ".", "prefix", ".", "match", "(", "/", "[", "A", "-", "Z", "][", "a", "-", "z", "]+", "\\.", "?", "/)", "\u0120end"], "docstring_tokens": ["Please", "\u0120do", "\u0120not", "\u0120approve", "\u0120PR", "s", "\u0120without", "\u0120tests", "!!!!"]}
{"function": "@@ -48,7 +48,7 @@ class WebEngineView(QWebEngineView): else: profile = webenginesettings.default_profile page = WebEnginePage(theme_color=theme_color, profile=profile, - parent=self) + parent=self, win_id=win_id) self.setPage(page) def shutdown(self):", "text": "Now that you handle this in `webenginetab.py` you can undo all the changes in this file.", "function_tokens": ["@@", "\u0120-", "48", ",", "7", "\u0120+", "48", ",", "7", "\u0120@@", "\u0120class", "\u0120Web", "Engine", "View", "(", "Q", "Web", "Engine", "View", "):", "\u0120else", ":", "\u0120profile", "\u0120=", "\u0120web", "eng", "ines", "ettings", ".", "default", "_", "profile", "\u0120page", "\u0120=", "\u0120Web", "Engine", "Page", "(", "theme", "_", "color", "=", "theme", "_", "color", ",", "\u0120profile", "=", "profile", ",", "\u0120-", "\u0120parent", "=", "self", ")", "\u0120+", "\u0120parent", "=", "self", ",", "\u0120win", "_", "id", "=", "win", "_", "id", ")", "\u0120self", ".", "set", "Page", "(", "page", ")", "\u0120def", "\u0120shutdown", "(", "self", "):"], "docstring_tokens": ["Now", "\u0120that", "\u0120you", "\u0120handle", "\u0120this", "\u0120in", "\u0120`", "web", "eng", "inet", "ab", ".", "py", "`", "\u0120you", "\u0120can", "\u0120undo", "\u0120all", "\u0120the", "\u0120changes", "\u0120in", "\u0120this", "\u0120file", "."]}
{"function": "@@ -30,7 +30,11 @@ import org.springframework.context.annotation.AnnotationConfigApplicationContext public class JavaFXApplication extends Application { public static void main(String[] args) { - Application.launch(JavaFXApplication.class); + try { + Application.launch(JavaFXApplication.class); + } catch (Exception e) { + e.printStackTrace(); + } } @Override", "text": "I think we should log the exception to a log file instead of printing it. The current behavior (not catching the exception) should lead to an automatic print of the exception to the terminal/console.", "function_tokens": ["@@", "\u0120-", "30", ",", "7", "\u0120+", "30", ",", "11", "\u0120@@", "\u0120import", "\u0120org", ".", "spring", "framework", ".", "context", ".", "ann", "otation", ".", "An", "notation", "Config", "Application", "Context", "\u0120public", "\u0120class", "\u0120Java", "FX", "Application", "\u0120extends", "\u0120Application", "\u0120{", "\u0120public", "\u0120static", "\u0120void", "\u0120main", "(", "String", "[]", "\u0120args", ")", "\u0120{", "\u0120-", "\u0120Application", ".", "launch", "(", "Java", "FX", "Application", ".", "class", ");", "\u0120+", "\u0120try", "\u0120{", "\u0120+", "\u0120Application", ".", "launch", "(", "Java", "FX", "Application", ".", "class", ");", "\u0120+", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120+", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120+", "\u0120}", "\u0120}", "\u0120@", "Override"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120should", "\u0120log", "\u0120the", "\u0120exception", "\u0120to", "\u0120a", "\u0120log", "\u0120file", "\u0120instead", "\u0120of", "\u0120printing", "\u0120it", ".", "\u0120The", "\u0120current", "\u0120behavior", "\u0120(", "not", "\u0120catching", "\u0120the", "\u0120exception", ")", "\u0120should", "\u0120lead", "\u0120to", "\u0120an", "\u0120automatic", "\u0120print", "\u0120of", "\u0120the", "\u0120exception", "\u0120to", "\u0120the", "\u0120terminal", "/", "console", "."]}
{"function": "@@ -57,7 +57,7 @@ func (r *Helper) Apply(obj []byte) (ApplyResult, error) { if err != nil { r.logger.WithError(err). WithField(\"stdout\", ioStreams.Out.(*bytes.Buffer).String()). - WithField(\"stderr\", ioStreams.ErrOut.(*bytes.Buffer).String()).Error(\"running the apply command failed\") + WithField(\"stderr\", ioStreams.ErrOut.(*bytes.Buffer).String()).Warn(\"running the apply command failed\") return \"\", err } return changeTracker.GetResult(), nil", "text": "These changes to the resource helpers have some more far-reaching implications as they also affect calls made in hive-operator, I believe. It's probably OK still, though. Ideally, the resource helper would not be the one doing the logging, since it cannot know the severity, but that is well beyond something that we should tackle for this PR. I would rather have the hive-operator log warnings than have the syncsetinstance controller log errors.", "function_tokens": ["@@", "\u0120-", "57", ",", "7", "\u0120+", "57", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "r", "\u0120*", "Helper", ")", "\u0120Apply", "(", "obj", "\u0120[]", "byte", ")", "\u0120(", "Apply", "Result", ",", "\u0120error", ")", "\u0120{", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120r", ".", "log", "ger", ".", "With", "Error", "(", "err", ").", "\u0120With", "Field", "(\"", "std", "out", "\",", "\u0120io", "Stream", "s", ".", "Out", ".(", "*", "bytes", ".", "Buffer", ").", "String", "()", ").", "\u0120-", "\u0120With", "Field", "(\"", "st", "der", "r", "\",", "\u0120io", "Stream", "s", ".", "Er", "r", "Out", ".(", "*", "bytes", ".", "Buffer", ").", "String", "()", ").", "Error", "(\"", "running", "\u0120the", "\u0120apply", "\u0120command", "\u0120failed", "\")", "\u0120+", "\u0120With", "Field", "(\"", "st", "der", "r", "\",", "\u0120io", "Stream", "s", ".", "Er", "r", "Out", ".(", "*", "bytes", ".", "Buffer", ").", "String", "()", ").", "W", "arn", "(\"", "running", "\u0120the", "\u0120apply", "\u0120command", "\u0120failed", "\")", "\u0120return", "\u0120\"", "\",", "\u0120err", "\u0120}", "\u0120return", "\u0120change", "Tracker", ".", "Get", "Result", "(),", "\u0120nil"], "docstring_tokens": ["These", "\u0120changes", "\u0120to", "\u0120the", "\u0120resource", "\u0120helpers", "\u0120have", "\u0120some", "\u0120more", "\u0120far", "-", "reaching", "\u0120implications", "\u0120as", "\u0120they", "\u0120also", "\u0120affect", "\u0120calls", "\u0120made", "\u0120in", "\u0120hive", "-", "operator", ",", "\u0120I", "\u0120believe", ".", "\u0120It", "'s", "\u0120probably", "\u0120OK", "\u0120still", ",", "\u0120though", ".", "\u0120Ideally", ",", "\u0120the", "\u0120resource", "\u0120helper", "\u0120would", "\u0120not", "\u0120be", "\u0120the", "\u0120one", "\u0120doing", "\u0120the", "\u0120logging", ",", "\u0120since", "\u0120it", "\u0120cannot", "\u0120know", "\u0120the", "\u0120severity", ",", "\u0120but", "\u0120that", "\u0120is", "\u0120well", "\u0120beyond", "\u0120something", "\u0120that", "\u0120we", "\u0120should", "\u0120tackle", "\u0120for", "\u0120this", "\u0120PR", ".", "\u0120I", "\u0120would", "\u0120rather", "\u0120have", "\u0120the", "\u0120hive", "-", "operator", "\u0120log", "\u0120warnings", "\u0120than", "\u0120have", "\u0120the", "\u0120sync", "set", "instance", "\u0120controller", "\u0120log", "\u0120errors", "."]}
{"function": "@@ -167,7 +167,7 @@ class ExportCategoryTableMap extends TableMap */ public function buildRelations() { - $this->addRelation('Export', '\\\\Thelia\\\\Model\\\\Export', RelationMap::ONE_TO_MANY, array('id' => 'export_category_id', ), 'CASCADE', 'RESTRICT', 'Exports'); + $this->addRelation('Export', '\\\\Thelia\\\\Model\\\\Export', RelationMap::ONE_TO_MANY, array('id' => 'export_category_id', ), null, null, 'Exports'); $this->addRelation('ExportCategoryI18n', '\\\\Thelia\\\\Model\\\\ExportCategoryI18n', RelationMap::ONE_TO_MANY, array('id' => 'id', ), 'CASCADE', null, 'ExportCategoryI18ns'); } // buildRelations() ", "text": "do you really want to change the behavior on foreign key ?", "function_tokens": ["@@", "\u0120-", "167", ",", "7", "\u0120+", "167", ",", "7", "\u0120@@", "\u0120class", "\u0120Export", "Category", "Table", "Map", "\u0120extends", "\u0120Table", "Map", "\u0120*/", "\u0120public", "\u0120function", "\u0120build", "Relations", "()", "\u0120{", "\u0120-", "\u0120$", "this", "->", "add", "Rel", "ation", "('", "Export", "',", "\u0120'", "\\\\", "The", "lia", "\\\\", "Model", "\\\\", "Export", "',", "\u0120Rel", "ation", "Map", "::", "ONE", "_", "TO", "_", "MAN", "Y", ",", "\u0120array", "('", "id", "'", "\u0120=>", "\u0120'", "export", "_", "category", "_", "id", "',", "\u0120),", "\u0120'", "C", "ASC", "ADE", "',", "\u0120'", "RES", "TR", "ICT", "',", "\u0120'", "Ex", "ports", "');", "\u0120+", "\u0120$", "this", "->", "add", "Rel", "ation", "('", "Export", "',", "\u0120'", "\\\\", "The", "lia", "\\\\", "Model", "\\\\", "Export", "',", "\u0120Rel", "ation", "Map", "::", "ONE", "_", "TO", "_", "MAN", "Y", ",", "\u0120array", "('", "id", "'", "\u0120=>", "\u0120'", "export", "_", "category", "_", "id", "',", "\u0120),", "\u0120null", ",", "\u0120null", ",", "\u0120'", "Ex", "ports", "');", "\u0120$", "this", "->", "add", "Rel", "ation", "('", "Export", "Category", "I", "18", "n", "',", "\u0120'", "\\\\", "The", "lia", "\\\\", "Model", "\\\\", "Export", "Category", "I", "18", "n", "',", "\u0120Rel", "ation", "Map", "::", "ONE", "_", "TO", "_", "MAN", "Y", ",", "\u0120array", "('", "id", "'", "\u0120=>", "\u0120'", "id", "',", "\u0120),", "\u0120'", "C", "ASC", "ADE", "',", "\u0120null", ",", "\u0120'", "Export", "Category", "I", "18", "ns", "');", "\u0120}", "\u0120//", "\u0120build", "Relations", "()", "\u0120"], "docstring_tokens": ["do", "\u0120you", "\u0120really", "\u0120want", "\u0120to", "\u0120change", "\u0120the", "\u0120behavior", "\u0120on", "\u0120foreign", "\u0120key", "\u0120?"]}
{"function": "@@ -183,7 +183,8 @@ void event_batch_destroy (struct event_batch *batch) if (batch->f) (void)flux_future_wait_for (batch->f, -1); if (batch->state_trans) { - event_publish_state (batch->event, batch->state_trans); + if (json_array_size (batch->state_trans) > 0) + event_publish_state (batch->event, batch->state_trans); json_decref (batch->state_trans); } if (batch->responses) {", "text": "Looks like my bad. Thanks for fixing!", "function_tokens": ["@@", "\u0120-", "183", ",", "7", "\u0120+", "183", ",", "8", "\u0120@@", "\u0120void", "\u0120event", "_", "batch", "_", "destroy", "\u0120(", "struct", "\u0120event", "_", "batch", "\u0120*", "batch", ")", "\u0120if", "\u0120(", "batch", "->", "f", ")", "\u0120(", "void", ")", "f", "lux", "_", "future", "_", "wait", "_", "for", "\u0120(", "batch", "->", "f", ",", "\u0120-", "1", ");", "\u0120if", "\u0120(", "batch", "->", "state", "_", "trans", ")", "\u0120{", "\u0120-", "\u0120event", "_", "pub", "lish", "_", "state", "\u0120(", "batch", "->", "event", ",", "\u0120batch", "->", "state", "_", "trans", ");", "\u0120+", "\u0120if", "\u0120(", "json", "_", "array", "_", "size", "\u0120(", "batch", "->", "state", "_", "trans", ")", "\u0120>", "\u01200", ")", "\u0120+", "\u0120event", "_", "pub", "lish", "_", "state", "\u0120(", "batch", "->", "event", ",", "\u0120batch", "->", "state", "_", "trans", ");", "\u0120json", "_", "dec", "ref", "\u0120(", "batch", "->", "state", "_", "trans", ");", "\u0120}", "\u0120if", "\u0120(", "batch", "->", "respons", "es", ")", "\u0120{"], "docstring_tokens": ["Looks", "\u0120like", "\u0120my", "\u0120bad", ".", "\u0120Thanks", "\u0120for", "\u0120fixing", "!"]}
{"function": "@@ -82,6 +82,7 @@ class Command: no_cmd_split: If true, ';;' to split sub-commands is ignored. backend: Which backend the command works with (or None if it works with both) + no_replace_variables: Whether or not to replace variables like {url} _qute_args: The saved data from @cmdutils.argument _needs_js: Whether the command needs javascript enabled _modes: The modes the command can be executed in.", "text": "I think \"Don't replace variables ...\" would be cleaner.", "function_tokens": ["@@", "\u0120-", "82", ",", "6", "\u0120+", "82", ",", "7", "\u0120@@", "\u0120class", "\u0120Command", ":", "\u0120no", "_", "cmd", "_", "split", ":", "\u0120If", "\u0120true", ",", "\u0120'", ";;", "'", "\u0120to", "\u0120split", "\u0120sub", "-", "comm", "ands", "\u0120is", "\u0120ignored", ".", "\u0120backend", ":", "\u0120Which", "\u0120backend", "\u0120the", "\u0120command", "\u0120works", "\u0120with", "\u0120(", "or", "\u0120None", "\u0120if", "\u0120it", "\u0120works", "\u0120with", "\u0120both", ")", "\u0120+", "\u0120no", "_", "replace", "_", "vari", "ables", ":", "\u0120Whether", "\u0120or", "\u0120not", "\u0120to", "\u0120replace", "\u0120variables", "\u0120like", "\u0120{", "url", "}", "\u0120_", "q", "ute", "_", "args", ":", "\u0120The", "\u0120saved", "\u0120data", "\u0120from", "\u0120@", "cmd", "utils", ".", "argument", "\u0120_", "needs", "_", "js", ":", "\u0120Whether", "\u0120the", "\u0120command", "\u0120needs", "\u0120javascript", "\u0120enabled", "\u0120_", "m", "odes", ":", "\u0120The", "\u0120modes", "\u0120the", "\u0120command", "\u0120can", "\u0120be", "\u0120executed", "\u0120in", "."], "docstring_tokens": ["I", "\u0120think", "\u0120\"", "Don", "'t", "\u0120replace", "\u0120variables", "\u0120...\"", "\u0120would", "\u0120be", "\u0120cleaner", "."]}
{"function": "@@ -82,8 +82,7 @@ class MPLPlot(DimensionedPlot): sublabel_size = param.Number(default=18, doc=\"\"\" Size of optional subfigure label.\"\"\") - projection = param.ObjectSelector(default=None, - objects=['3d', 'polar', None], doc=\"\"\" + projection = param.Parameter(default=None, doc=\"\"\" The projection of the plot axis, default of None is equivalent to 2D plot, '3d' and 'polar' are also supported.\"\"\") ", "text": "Do you validate the possible strings? I've not read the code below but we should make sure if a string is supplied it is validate...", "function_tokens": ["@@", "\u0120-", "82", ",", "8", "\u0120+", "82", ",", "7", "\u0120@@", "\u0120class", "\u0120MP", "L", "Plot", "(", "Dim", "ension", "ed", "Plot", "):", "\u0120sub", "label", "_", "size", "\u0120=", "\u0120param", ".", "Number", "(", "default", "=", "18", ",", "\u0120doc", "=\"", "\"\"", "\u0120Size", "\u0120of", "\u0120optional", "\u0120sub", "figure", "\u0120label", ".\"\"", "\")", "\u0120-", "\u0120projection", "\u0120=", "\u0120param", ".", "Object", "Select", "or", "(", "default", "=", "None", ",", "\u0120-", "\u0120objects", "=", "['", "3", "d", "',", "\u0120'", "p", "olar", "',", "\u0120None", "],", "\u0120doc", "=\"", "\"\"", "\u0120+", "\u0120projection", "\u0120=", "\u0120param", ".", "Parameter", "(", "default", "=", "None", ",", "\u0120doc", "=\"", "\"\"", "\u0120The", "\u0120projection", "\u0120of", "\u0120the", "\u0120plot", "\u0120axis", ",", "\u0120default", "\u0120of", "\u0120None", "\u0120is", "\u0120equivalent", "\u0120to", "\u01202", "D", "\u0120plot", ",", "\u0120'", "3", "d", "'", "\u0120and", "\u0120'", "p", "olar", "'", "\u0120are", "\u0120also", "\u0120supported", ".\"\"", "\")", "\u0120"], "docstring_tokens": ["Do", "\u0120you", "\u0120validate", "\u0120the", "\u0120possible", "\u0120strings", "?", "\u0120I", "'ve", "\u0120not", "\u0120read", "\u0120the", "\u0120code", "\u0120below", "\u0120but", "\u0120we", "\u0120should", "\u0120make", "\u0120sure", "\u0120if", "\u0120a", "\u0120string", "\u0120is", "\u0120supplied", "\u0120it", "\u0120is", "\u0120validate", "..."]}
{"function": "@@ -40,13 +40,11 @@ func AddDiskImportSteps(w *daisy.Workflow, dataDiskInfos []ovfutils.DiskInfo) { for i, dataDiskInfo := range dataDiskInfos { dataDiskIndex := i + 1 dataDiskFilePath := dataDiskInfo.FilePath - diskNames = append( - diskNames, - fmt.Sprintf(\"%v-data-disk-%v\", w.Vars[\"instance_name\"].Value, dataDiskIndex)) + diskNames = append(diskNames, generateDataDiskName(w.Vars[\"instance_name\"].Value, dataDiskIndex)) setupDataDiskStepName := fmt.Sprintf(\"setup-data-disk-%v\", dataDiskIndex) - diskImporterDiskName := fmt.Sprintf(\"disk-importer-%v\", dataDiskIndex) - scratchDiskDiskName := fmt.Sprintf(\"disk-importer-scratch-%v-%v\", dataDiskIndex, w.Vars[\"instance_name\"].Value) + diskImporterDiskName := fmt.Sprintf(\"disk-importer-%v-%v\", dataDiskIndex, w.ID()) + scratchDiskDiskName := fmt.Sprintf(\"disk-importer-scratch-%v-%v\", dataDiskIndex, w.ID()) setupDataDiskStep := daisy.NewStepDefaultTimeout(setupDataDiskStepName, w) setupDataDiskStep.CreateDisks = &daisy.CreateDisks{", "text": "I'd recommend using generateDataDiskName here as well -- might as well benefit from the safety that it gives to protect yourself from future changes to w.ID().", "function_tokens": ["@@", "\u0120-", "40", ",", "13", "\u0120+", "40", ",", "11", "\u0120@@", "\u0120func", "\u0120Add", "Disk", "Import", "Step", "s", "(", "w", "\u0120*", "da", "isy", ".", "Work", "flow", ",", "\u0120data", "Disk", "Inf", "os", "\u0120[]", "ov", "f", "utils", ".", "Disk", "Info", ")", "\u0120{", "\u0120for", "\u0120i", ",", "\u0120data", "Disk", "Info", "\u0120:=", "\u0120range", "\u0120data", "Disk", "Inf", "os", "\u0120{", "\u0120data", "Disk", "Index", "\u0120:=", "\u0120i", "\u0120+", "\u01201", "\u0120data", "Disk", "File", "Path", "\u0120:=", "\u0120data", "Disk", "Info", ".", "File", "Path", "\u0120-", "\u0120disk", "Names", "\u0120=", "\u0120append", "(", "\u0120-", "\u0120disk", "Names", ",", "\u0120-", "\u0120fmt", ".", "S", "printf", "(\"", "%", "v", "-", "data", "-", "disk", "-", "%", "v", "\",", "\u0120w", ".", "V", "ars", "[\"", "instance", "_", "name", "\"", "].", "Value", ",", "\u0120data", "Disk", "Index", "))", "\u0120+", "\u0120disk", "Names", "\u0120=", "\u0120append", "(", "disk", "Names", ",", "\u0120generate", "Data", "Disk", "Name", "(", "w", ".", "V", "ars", "[\"", "instance", "_", "name", "\"", "].", "Value", ",", "\u0120data", "Disk", "Index", "))", "\u0120setup", "Data", "Disk", "Step", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "setup", "-", "data", "-", "disk", "-", "%", "v", "\",", "\u0120data", "Disk", "Index", ")", "\u0120-", "\u0120disk", "Im", "porter", "Disk", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "disk", "-", "im", "porter", "-", "%", "v", "\",", "\u0120data", "Disk", "Index", ")", "\u0120-", "\u0120scratch", "Disk", "Disk", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "disk", "-", "im", "porter", "-", "sc", "ratch", "-", "%", "v", "-", "%", "v", "\",", "\u0120data", "Disk", "Index", ",", "\u0120w", ".", "V", "ars", "[\"", "instance", "_", "name", "\"", "].", "Value", ")", "\u0120+", "\u0120disk", "Im", "porter", "Disk", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "disk", "-", "im", "porter", "-", "%", "v", "-", "%", "v", "\",", "\u0120data", "Disk", "Index", ",", "\u0120w", ".", "ID", "())", "\u0120+", "\u0120scratch", "Disk", "Disk", "Name", "\u0120:=", "\u0120fmt", ".", "S", "printf", "(\"", "disk", "-", "im", "porter", "-", "sc", "ratch", "-", "%", "v", "-", "%", "v", "\",", "\u0120data", "Disk", "Index", ",", "\u0120w", ".", "ID", "())", "\u0120setup", "Data", "Disk", "Step", "\u0120:=", "\u0120da", "isy", ".", "New", "Step", "Default", "Timeout", "(", "setup", "Data", "Disk", "Step", "Name", ",", "\u0120w", ")", "\u0120setup", "Data", "Disk", "Step", ".", "Create", "Dis", "ks", "\u0120=", "\u0120&", "da", "isy", ".", "Create", "Dis", "ks", "{"], "docstring_tokens": ["I", "'d", "\u0120recommend", "\u0120using", "\u0120generate", "Data", "Disk", "Name", "\u0120here", "\u0120as", "\u0120well", "\u0120--", "\u0120might", "\u0120as", "\u0120well", "\u0120benefit", "\u0120from", "\u0120the", "\u0120safety", "\u0120that", "\u0120it", "\u0120gives", "\u0120to", "\u0120protect", "\u0120yourself", "\u0120from", "\u0120future", "\u0120changes", "\u0120to", "\u0120w", ".", "ID", "()."]}
{"function": "@@ -29,6 +29,11 @@ import java.util.Map; * @param <F> the concrete Java class of a ContentFile instance. */ public interface ContentFile<F> { + /** + * Returns the ordinal position of the file in a manifest, or null if it was not read from a manifest. + */ + Long pos(); + /** * Returns id of the partition spec used for partition metadata. */", "text": "qq: do we want to include anything in the name to indicate that it is a position in the manifest?", "function_tokens": ["@@", "\u0120-", "29", ",", "6", "\u0120+", "29", ",", "11", "\u0120@@", "\u0120import", "\u0120java", ".", "util", ".", "Map", ";", "\u0120*", "\u0120@", "param", "\u0120<", "F", ">", "\u0120the", "\u0120concrete", "\u0120Java", "\u0120class", "\u0120of", "\u0120a", "\u0120Content", "File", "\u0120instance", ".", "\u0120*/", "\u0120public", "\u0120interface", "\u0120Content", "File", "<", "F", ">", "\u0120{", "\u0120+", "\u0120/**", "\u0120+", "\u0120*", "\u0120Returns", "\u0120the", "\u0120ord", "inal", "\u0120position", "\u0120of", "\u0120the", "\u0120file", "\u0120in", "\u0120a", "\u0120manifest", ",", "\u0120or", "\u0120null", "\u0120if", "\u0120it", "\u0120was", "\u0120not", "\u0120read", "\u0120from", "\u0120a", "\u0120manifest", ".", "\u0120+", "\u0120*/", "\u0120+", "\u0120Long", "\u0120pos", "();", "\u0120+", "\u0120/**", "\u0120*", "\u0120Returns", "\u0120id", "\u0120of", "\u0120the", "\u0120partition", "\u0120spec", "\u0120used", "\u0120for", "\u0120partition", "\u0120metadata", ".", "\u0120*/"], "docstring_tokens": ["qq", ":", "\u0120do", "\u0120we", "\u0120want", "\u0120to", "\u0120include", "\u0120anything", "\u0120in", "\u0120the", "\u0120name", "\u0120to", "\u0120indicate", "\u0120that", "\u0120it", "\u0120is", "\u0120a", "\u0120position", "\u0120in", "\u0120the", "\u0120manifest", "?"]}
{"function": "@@ -969,8 +969,11 @@ public class VRBrowserActivity extends PlatformActivity implements WidgetManager GleanMetricsService.stopImmersive(); Handler handler = new Handler(Looper.getMainLooper()); handler.postDelayed(() -> { - mWindows.resumeCompositor(); - Log.d(LOGTAG, \"Compositor Resumed\"); + if (!mWindows.isPaused()) { + Log.d(LOGTAG, \"Compositor resume begin\"); + mWindows.resumeCompositor(); + Log.d(LOGTAG, \"Compositor resume end\"); + } }, 20); } ", "text": "These logs should probably use the `LOGTAG`", "function_tokens": ["@@", "\u0120-", "969", ",", "8", "\u0120+", "969", ",", "11", "\u0120@@", "\u0120public", "\u0120class", "\u0120VR", "Browser", "Activity", "\u0120extends", "\u0120Platform", "Activity", "\u0120implements", "\u0120W", "idget", "Manager", "\u0120G", "lean", "Met", "rics", "Service", ".", "stop", "Imm", "ersive", "();", "\u0120Handler", "\u0120handler", "\u0120=", "\u0120new", "\u0120Handler", "(", "Lo", "oper", ".", "get", "Main", "Lo", "oper", "());", "\u0120handler", ".", "post", "Del", "ayed", "(", "()", "\u0120->", "\u0120{", "\u0120-", "\u0120m", "Windows", ".", "res", "ume", "Com", "pos", "itor", "();", "\u0120-", "\u0120Log", ".", "d", "(", "LOG", "TAG", ",", "\u0120\"", "Com", "pos", "itor", "\u0120Res", "umed", "\");", "\u0120+", "\u0120if", "\u0120(!", "m", "Windows", ".", "is", "Pa", "used", "())", "\u0120{", "\u0120+", "\u0120Log", ".", "d", "(", "LOG", "TAG", ",", "\u0120\"", "Com", "pos", "itor", "\u0120resume", "\u0120begin", "\");", "\u0120+", "\u0120m", "Windows", ".", "res", "ume", "Com", "pos", "itor", "();", "\u0120+", "\u0120Log", ".", "d", "(", "LOG", "TAG", ",", "\u0120\"", "Com", "pos", "itor", "\u0120resume", "\u0120end", "\");", "\u0120+", "\u0120}", "\u0120},", "\u012020", ");", "\u0120}", "\u0120"], "docstring_tokens": ["These", "\u0120logs", "\u0120should", "\u0120probably", "\u0120use", "\u0120the", "\u0120`", "LOG", "TAG", "`"]}
{"function": "@@ -28,10 +28,10 @@ import ( \"github.com/mysteriumnetwork/node/core/connection\" \"github.com/mysteriumnetwork/node/services/wireguard\" \"github.com/mysteriumnetwork/node/services/wireguard/key\" - \"github.com/mysteriumnetwork/wireguard-go/device\" - \"github.com/mysteriumnetwork/wireguard-go/tun\" \"github.com/pkg/errors\" \"github.com/rs/zerolog/log\" + \"golang.zx2c4.com/wireguard/device\" + \"golang.zx2c4.com/wireguard/tun\" ) const (", "text": "From this, it was clear, that we are using our version of wireguard-go. And now it looks like we are using original packages which is confusing.", "function_tokens": ["@@", "\u0120-", "28", ",", "10", "\u0120+", "28", ",", "10", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "connection", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "services", "/", "wire", "guard", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "services", "/", "wire", "guard", "/", "key", "\"", "\u0120-", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "wire", "guard", "-", "go", "/", "device", "\"", "\u0120-", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "wire", "guard", "-", "go", "/", "tun", "\"", "\u0120\"", "github", ".", "com", "/", "pkg", "/", "errors", "\"", "\u0120\"", "github", ".", "com", "/", "rs", "/", "zer", "olog", "/", "log", "\"", "\u0120+", "\u0120\"", "g", "ol", "ang", ".", "zx", "2", "c", "4", ".", "com", "/", "wire", "guard", "/", "device", "\"", "\u0120+", "\u0120\"", "g", "ol", "ang", ".", "zx", "2", "c", "4", ".", "com", "/", "wire", "guard", "/", "tun", "\"", "\u0120)", "\u0120const", "\u0120("], "docstring_tokens": ["From", "\u0120this", ",", "\u0120it", "\u0120was", "\u0120clear", ",", "\u0120that", "\u0120we", "\u0120are", "\u0120using", "\u0120our", "\u0120version", "\u0120of", "\u0120wire", "guard", "-", "go", ".", "\u0120And", "\u0120now", "\u0120it", "\u0120looks", "\u0120like", "\u0120we", "\u0120are", "\u0120using", "\u0120original", "\u0120packages", "\u0120which", "\u0120is", "\u0120confusing", "."]}
{"function": "@@ -43,7 +43,7 @@ namespace Nethermind.JsonRpc public static ResultWrapper<T> Fail(Exception e) { - return new() { Result = Result.Fail(e.ToString()), ErrorCode = ErrorCodes.InternalError}; + return new() { Result = Result.Fail(e.Message), ErrorCode = ErrorCodes.InternalError}; } public static ResultWrapper<T> Fail(string error, int errorCode, T outputData)", "text": "Any particular reason for this? This potentially will make harder to investigate users issues", "function_tokens": ["@@", "\u0120-", "43", ",", "7", "\u0120+", "43", ",", "7", "\u0120@@", "\u0120namespace", "\u0120Nether", "mind", ".", "J", "son", "R", "pc", "\u0120public", "\u0120static", "\u0120Result", "Wra", "pper", "<", "T", ">", "\u0120Fail", "(", "Exception", "\u0120e", ")", "\u0120{", "\u0120-", "\u0120return", "\u0120new", "()", "\u0120{", "\u0120Result", "\u0120=", "\u0120Result", ".", "Fail", "(", "e", ".", "To", "String", "()", "),", "\u0120Error", "Code", "\u0120=", "\u0120Error", "C", "odes", ".", "Internal", "Error", "};", "\u0120+", "\u0120return", "\u0120new", "()", "\u0120{", "\u0120Result", "\u0120=", "\u0120Result", ".", "Fail", "(", "e", ".", "Message", "),", "\u0120Error", "Code", "\u0120=", "\u0120Error", "C", "odes", ".", "Internal", "Error", "};", "\u0120}", "\u0120public", "\u0120static", "\u0120Result", "Wra", "pper", "<", "T", ">", "\u0120Fail", "(", "string", "\u0120error", ",", "\u0120int", "\u0120error", "Code", ",", "\u0120T", "\u0120output", "Data", ")"], "docstring_tokens": ["Any", "\u0120particular", "\u0120reason", "\u0120for", "\u0120this", "?", "\u0120This", "\u0120potentially", "\u0120will", "\u0120make", "\u0120harder", "\u0120to", "\u0120investigate", "\u0120users", "\u0120issues"]}
{"function": "@@ -999,7 +999,8 @@ Blockly.BlockSvg.prototype.updatePreviews = function(closestConnection, // grayed-out blocks instead of highlighting the connection; for compatibility // with Web Blockly the name \"highlightedConnection\" will still be used. if (Blockly.highlightedConnection_ && - Blockly.highlightedConnection_ != closestConnection) { + (Blockly.highlightedConnection_ != closestConnection || + Blockly.localConnection_ != localConnection)) { if (Blockly.insertionMarker_ && Blockly.insertionMarkerConnection_) { Blockly.BlockSvg.disconnectInsertionMarker(); }", "text": "Do you also need to check if Blockly.localConnection_ is non-null?", "function_tokens": ["@@", "\u0120-", "999", ",", "7", "\u0120+", "999", ",", "8", "\u0120@@", "\u0120Block", "ly", ".", "Block", "S", "vg", ".", "prototype", ".", "update", "Pre", "views", "\u0120=", "\u0120function", "(", "cl", "os", "est", "Connection", ",", "\u0120//", "\u0120gray", "ed", "-", "out", "\u0120blocks", "\u0120instead", "\u0120of", "\u0120highlighting", "\u0120the", "\u0120connection", ";", "\u0120for", "\u0120compatibility", "\u0120//", "\u0120with", "\u0120Web", "\u0120Block", "ly", "\u0120the", "\u0120name", "\u0120\"", "high", "light", "ed", "Connection", "\"", "\u0120will", "\u0120still", "\u0120be", "\u0120used", ".", "\u0120if", "\u0120(", "Block", "ly", ".", "high", "light", "ed", "Connection", "_", "\u0120&&", "\u0120-", "\u0120Block", "ly", ".", "high", "light", "ed", "Connection", "_", "\u0120!=", "\u0120closest", "Connection", ")", "\u0120{", "\u0120+", "\u0120(", "Block", "ly", ".", "high", "light", "ed", "Connection", "_", "\u0120!=", "\u0120closest", "Connection", "\u0120||", "\u0120+", "\u0120Block", "ly", ".", "local", "Connection", "_", "\u0120!=", "\u0120local", "Connection", "))", "\u0120{", "\u0120if", "\u0120(", "Block", "ly", ".", "insert", "ion", "Mark", "er", "_", "\u0120&&", "\u0120Block", "ly", ".", "insert", "ion", "Mark", "er", "Connection", "_", ")", "\u0120{", "\u0120Block", "ly", ".", "Block", "S", "vg", ".", "dis", "connect", "Insert", "ion", "Mark", "er", "();", "\u0120}"], "docstring_tokens": ["Do", "\u0120you", "\u0120also", "\u0120need", "\u0120to", "\u0120check", "\u0120if", "\u0120Block", "ly", ".", "local", "Connection", "_", "\u0120is", "\u0120non", "-", "null", "?"]}
{"function": "@@ -1,5 +1,6 @@ module RSpec module Core + # Internal container for global non-configuration data class World include RSpec::Core::Hooks", "text": "Not really a container, and it's not just about non-config data, not sure of a better description, @myronmarston ?", "function_tokens": ["@@", "\u0120-", "1", ",", "5", "\u0120+", "1", ",", "6", "\u0120@@", "\u0120module", "\u0120R", "Spec", "\u0120module", "\u0120Core", "\u0120+", "\u0120#", "\u0120Internal", "\u0120container", "\u0120for", "\u0120global", "\u0120non", "-", "config", "uration", "\u0120data", "\u0120class", "\u0120World", "\u0120include", "\u0120R", "Spec", "::", "Core", "::", "H", "ooks"], "docstring_tokens": ["Not", "\u0120really", "\u0120a", "\u0120container", ",", "\u0120and", "\u0120it", "'s", "\u0120not", "\u0120just", "\u0120about", "\u0120non", "-", "config", "\u0120data", ",", "\u0120not", "\u0120sure", "\u0120of", "\u0120a", "\u0120better", "\u0120description", ",", "\u0120@", "my", "ron", "mar", "ston", "\u0120?"]}
{"function": "@@ -3,6 +3,8 @@ const { basename } = require('./path-utils'); const shim = require('./shim').default; const JoplinError = require('./JoplinError').default; const { Buffer } = require('buffer'); +const { Readable } = require('stream').Readable; +const { GetObjectCommand, ListObjectsV2Command, HeadObjectCommand, PutObjectCommand, DeleteObjectCommand, DeleteObjectsCommand } = require(\"@aws-sdk/client-s3\"); const S3_MAX_DELETES = 1000; ", "text": "The desktop app will load this fine. on iOS I get `TypeError: undefined is not an object (evaluating '_$$_REQUIRE(_dependencyMap[8], \"stream\").Readable.Readable')` if I change it to `const Readable = require('stream').Readable;` or `const { Readable } = require('stream');` I get undefined errors from the stream on iOS: `[TypeError: stream.on is not a function. (In 'stream.on(\"data\", function (chunk) { return chunks.push(chunk); })', 'stream.on' is undefined)]` What am I missing?", "function_tokens": ["@@", "\u0120-", "3", ",", "6", "\u0120+", "3", ",", "8", "\u0120@@", "\u0120const", "\u0120{", "\u0120bas", "ename", "\u0120}", "\u0120=", "\u0120require", "(", "'.", "/", "path", "-", "utils", "');", "\u0120const", "\u0120sh", "im", "\u0120=", "\u0120require", "(", "'.", "/", "sh", "im", "').", "default", ";", "\u0120const", "\u0120J", "op", "lin", "Error", "\u0120=", "\u0120require", "(", "'.", "/", "J", "op", "lin", "Error", "').", "default", ";", "\u0120const", "\u0120{", "\u0120Buffer", "\u0120}", "\u0120=", "\u0120require", "('", "buffer", "');", "\u0120+", "const", "\u0120{", "\u0120Read", "able", "\u0120}", "\u0120=", "\u0120require", "('", "stream", "').", "Read", "able", ";", "\u0120+", "const", "\u0120{", "\u0120Get", "Object", "Command", ",", "\u0120List", "Object", "s", "V", "2", "Command", ",", "\u0120Head", "Object", "Command", ",", "\u0120Put", "Object", "Command", ",", "\u0120Delete", "Object", "Command", ",", "\u0120Delete", "Object", "s", "Command", "\u0120}", "\u0120=", "\u0120require", "(\"", "@", "aws", "-", "sd", "k", "/", "client", "-", "s", "3", "\");", "\u0120const", "\u0120S", "3", "_", "MAX", "_", "DE", "LET", "ES", "\u0120=", "\u01201000", ";", "\u0120"], "docstring_tokens": ["The", "\u0120desktop", "\u0120app", "\u0120will", "\u0120load", "\u0120this", "\u0120fine", ".", "\u0120on", "\u0120iOS", "\u0120I", "\u0120get", "\u0120`", "Type", "Error", ":", "\u0120undefined", "\u0120is", "\u0120not", "\u0120an", "\u0120object", "\u0120(", "eval", "uating", "\u0120'", "_", "$$", "_", "RE", "QUIRE", "(_", "depend", "ency", "Map", "[", "8", "],", "\u0120\"", "stream", "\").", "Read", "able", ".", "Read", "able", "')", "`", "\u0120if", "\u0120I", "\u0120change", "\u0120it", "\u0120to", "\u0120`", "const", "\u0120Read", "able", "\u0120=", "\u0120require", "('", "stream", "').", "Read", "able", ";", "`", "\u0120or", "\u0120`", "const", "\u0120{", "\u0120Read", "able", "\u0120}", "\u0120=", "\u0120require", "('", "stream", "');", "`", "\u0120I", "\u0120get", "\u0120undefined", "\u0120errors", "\u0120from", "\u0120the", "\u0120stream", "\u0120on", "\u0120iOS", ":", "\u0120`", "[", "Type", "Error", ":", "\u0120stream", ".", "on", "\u0120is", "\u0120not", "\u0120a", "\u0120function", ".", "\u0120(", "In", "\u0120'", "stream", ".", "on", "(\"", "data", "\",", "\u0120function", "\u0120(", "ch", "unk", ")", "\u0120{", "\u0120return", "\u0120chunks", ".", "push", "(", "ch", "unk", ");", "\u0120})", "',", "\u0120'", "stream", ".", "on", "'", "\u0120is", "\u0120undefined", ")]", "`", "\u0120What", "\u0120am", "\u0120I", "\u0120missing", "?"]}
{"function": "@@ -93,7 +93,9 @@ func (m *MockStorer) Put(ctx context.Context, mode storage.ModePut, chs ...swarm po := swarm.Proximity(ch.Address().Bytes(), m.baseAddress) m.bins[po]++ } - m.store[ch.Address().String()] = ch.Data() + b := make([]byte, len(ch.Data())) + copy(b, ch.Data()) + m.store[ch.Address().String()] = b m.modePut[ch.Address().String()] = mode // pin chunks if needed", "text": "this is needed since the chunk feeder shares memory across calls to the pipeline. this is in order to avoid multiple allocations. this change mimics the behavior of shed and localstore, and copies the data from the call into the in-memory store", "function_tokens": ["@@", "\u0120-", "93", ",", "7", "\u0120+", "93", ",", "9", "\u0120@@", "\u0120func", "\u0120(", "m", "\u0120*", "M", "ock", "St", "orer", ")", "\u0120Put", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120mode", "\u0120storage", ".", "Mode", "Put", ",", "\u0120ch", "s", "\u0120...", "sw", "arm", "\u0120po", "\u0120:=", "\u0120swarm", ".", "Pro", "x", "imity", "(", "ch", ".", "Address", "().", "Bytes", "(),", "\u0120m", ".", "base", "Address", ")", "\u0120m", ".", "b", "ins", "[", "po", "]", "++", "\u0120}", "\u0120-", "\u0120m", ".", "store", "[", "ch", ".", "Address", "().", "String", "()", "]", "\u0120=", "\u0120ch", ".", "Data", "()", "\u0120+", "\u0120b", "\u0120:=", "\u0120make", "(", "[]", "byte", ",", "\u0120len", "(", "ch", ".", "Data", "()", "))", "\u0120+", "\u0120copy", "(", "b", ",", "\u0120ch", ".", "Data", "())", "\u0120+", "\u0120m", ".", "store", "[", "ch", ".", "Address", "().", "String", "()", "]", "\u0120=", "\u0120b", "\u0120m", ".", "mode", "Put", "[", "ch", ".", "Address", "().", "String", "()", "]", "\u0120=", "\u0120mode", "\u0120//", "\u0120pin", "\u0120chunks", "\u0120if", "\u0120needed"], "docstring_tokens": ["this", "\u0120is", "\u0120needed", "\u0120since", "\u0120the", "\u0120chunk", "\u0120feed", "er", "\u0120shares", "\u0120memory", "\u0120across", "\u0120calls", "\u0120to", "\u0120the", "\u0120pipeline", ".", "\u0120this", "\u0120is", "\u0120in", "\u0120order", "\u0120to", "\u0120avoid", "\u0120multiple", "\u0120allocations", ".", "\u0120this", "\u0120change", "\u0120mim", "ics", "\u0120the", "\u0120behavior", "\u0120of", "\u0120shed", "\u0120and", "\u0120local", "store", ",", "\u0120and", "\u0120copies", "\u0120the", "\u0120data", "\u0120from", "\u0120the", "\u0120call", "\u0120into", "\u0120the", "\u0120in", "-", "memory", "\u0120store"]}
{"function": "@@ -42,6 +42,10 @@ import ( \"go.uber.org/yarpc/yarpcerrors\" ) +func init() { + opentracing.SetGlobalTracer(nil) +} + func TestHandlerSuccess(t *testing.T) { mockCtrl := gomock.NewController(t) defer mockCtrl.Finish()", "text": "wut. We can do this at the beginning of tests if we want right? Why are we depending on init?", "function_tokens": ["@@", "\u0120-", "42", ",", "6", "\u0120+", "42", ",", "10", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "go", ".", "uber", ".", "org", "/", "y", "arp", "c", "/", "y", "arp", "cer", "rors", "\"", "\u0120)", "\u0120+", "func", "\u0120init", "()", "\u0120{", "\u0120+", "\u0120op", "ent", "r", "acing", ".", "Set", "Global", "Tr", "acer", "(", "nil", ")", "\u0120+", "}", "\u0120+", "\u0120func", "\u0120Test", "Handler", "Success", "(", "t", "\u0120*", "testing", ".", "T", ")", "\u0120{", "\u0120mock", "Ctrl", "\u0120:=", "\u0120g", "om", "ock", ".", "New", "Controller", "(", "t", ")", "\u0120defer", "\u0120mock", "Ctrl", ".", "Finish", "()"], "docstring_tokens": ["w", "ut", ".", "\u0120We", "\u0120can", "\u0120do", "\u0120this", "\u0120at", "\u0120the", "\u0120beginning", "\u0120of", "\u0120tests", "\u0120if", "\u0120we", "\u0120want", "\u0120right", "?", "\u0120Why", "\u0120are", "\u0120we", "\u0120depending", "\u0120on", "\u0120init", "?"]}
{"function": "@@ -1403,9 +1403,12 @@ func (c *client) processConnect(arg []byte) error { c.mu.Lock() acc := c.acc c.mu.Unlock() + srv.mu.Lock() if acc != nil && acc != srv.gacc { + srv.mu.Unlock() return ErrTooManyAccountConnections } + srv.mu.Unlock() } c.authViolation() return ErrAuthentication", "text": "Same trick here IMO.", "function_tokens": ["@@", "\u0120-", "14", "03", ",", "9", "\u0120+", "14", "03", ",", "12", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120*", "client", ")", "\u0120process", "Connect", "(", "arg", "\u0120[]", "byte", ")", "\u0120error", "\u0120{", "\u0120c", ".", "mu", ".", "Lock", "()", "\u0120acc", "\u0120:=", "\u0120c", ".", "acc", "\u0120c", ".", "mu", ".", "Un", "lock", "()", "\u0120+", "\u0120sr", "v", ".", "mu", ".", "Lock", "()", "\u0120if", "\u0120acc", "\u0120!=", "\u0120nil", "\u0120&&", "\u0120acc", "\u0120!=", "\u0120sr", "v", ".", "g", "acc", "\u0120{", "\u0120+", "\u0120sr", "v", ".", "mu", ".", "Un", "lock", "()", "\u0120return", "\u0120Err", "Too", "Many", "Account", "Connect", "ions", "\u0120}", "\u0120+", "\u0120sr", "v", ".", "mu", ".", "Un", "lock", "()", "\u0120}", "\u0120c", ".", "auth", "Viol", "ation", "()", "\u0120return", "\u0120Err", "Authent", "ication"], "docstring_tokens": ["Same", "\u0120trick", "\u0120here", "\u0120IM", "O", "."]}
{"function": "@@ -108,10 +108,11 @@ module Selenium def initialize(source, duration, x, y, element: nil, origin: nil) super(source) + @duration = duration * 1000 @x_offset = x @y_offset = y - @origin = element || origin + @origin = origin || POINTER end def type", "text": "Should be `@origin = element || origin || POINTER`", "function_tokens": ["@@", "\u0120-", "108", ",", "10", "\u0120+", "108", ",", "11", "\u0120@@", "\u0120module", "\u0120Sel", "enium", "\u0120def", "\u0120initialize", "(", "source", ",", "\u0120duration", ",", "\u0120x", ",", "\u0120y", ",", "\u0120element", ":", "\u0120nil", ",", "\u0120origin", ":", "\u0120nil", ")", "\u0120super", "(", "source", ")", "\u0120+", "\u0120@", "duration", "\u0120=", "\u0120duration", "\u0120*", "\u01201000", "\u0120@", "x", "_", "offset", "\u0120=", "\u0120x", "\u0120@", "y", "_", "offset", "\u0120=", "\u0120y", "\u0120-", "\u0120@", "origin", "\u0120=", "\u0120element", "\u0120||", "\u0120origin", "\u0120+", "\u0120@", "origin", "\u0120=", "\u0120origin", "\u0120||", "\u0120PO", "INTER", "\u0120end", "\u0120def", "\u0120type"], "docstring_tokens": ["Should", "\u0120be", "\u0120`", "@", "origin", "\u0120=", "\u0120element", "\u0120||", "\u0120origin", "\u0120||", "\u0120PO", "INTER", "`"]}
{"function": "@@ -50,11 +50,14 @@ func NewUpgradeCStorSPCJob() *cobra.Command { Long: cstorSPCUpgradeCmdHelpText, Example: `upgrade cstor-spc --spc-name <spc-name>`, Run: func(cmd *cobra.Command, args []string) { + util.CheckErr(options.RunCStorSPCUpgradeChecks(cmd, args), util.Fatal) options.resourceKind = \"storagePoolClaim\" - util.CheckErr(options.RunPreFlightChecks(cmd), util.Fatal) - util.CheckErr(options.RunCStorSPCUpgradeChecks(cmd), util.Fatal) - util.CheckErr(options.InitializeDefaults(cmd), util.Fatal) - util.CheckErr(options.RunCStorSPCUpgrade(cmd), util.Fatal) + if options.cstorSPC.spcName != \"\" { + singleCstorSPCUpgrade(cmd) + } + if len(args) != 0 { + bulkCstorSPCUpgrade(cmd, args) + } }, } ", "text": "this example needs a fix?", "function_tokens": ["@@", "\u0120-", "50", ",", "11", "\u0120+", "50", ",", "14", "\u0120@@", "\u0120func", "\u0120New", "Upgrade", "C", "St", "or", "SP", "C", "Job", "()", "\u0120*", "c", "ob", "ra", ".", "Command", "\u0120{", "\u0120Long", ":", "\u0120c", "st", "or", "SP", "C", "Upgrade", "Cmd", "Help", "Text", ",", "\u0120Example", ":", "\u0120`", "up", "grade", "\u0120c", "st", "or", "-", "sp", "c", "\u0120--", "sp", "c", "-", "name", "\u0120<", "sp", "c", "-", "name", ">", "`,", "\u0120Run", ":", "\u0120func", "(", "cmd", "\u0120*", "c", "ob", "ra", ".", "Command", ",", "\u0120args", "\u0120[]", "string", ")", "\u0120{", "\u0120+", "\u0120util", ".", "Check", "Er", "r", "(", "options", ".", "Run", "C", "St", "or", "SP", "C", "Upgrade", "Che", "cks", "(", "cmd", ",", "\u0120args", "),", "\u0120util", ".", "F", "atal", ")", "\u0120options", ".", "resource", "Kind", "\u0120=", "\u0120\"", "storage", "Pool", "Claim", "\"", "\u0120-", "\u0120util", ".", "Check", "Er", "r", "(", "options", ".", "Run", "Pre", "Flight", "Che", "cks", "(", "cmd", "),", "\u0120util", ".", "F", "atal", ")", "\u0120-", "\u0120util", ".", "Check", "Er", "r", "(", "options", ".", "Run", "C", "St", "or", "SP", "C", "Upgrade", "Che", "cks", "(", "cmd", "),", "\u0120util", ".", "F", "atal", ")", "\u0120-", "\u0120util", ".", "Check", "Er", "r", "(", "options", ".", "Initial", "ize", "Def", "aults", "(", "cmd", "),", "\u0120util", ".", "F", "atal", ")", "\u0120-", "\u0120util", ".", "Check", "Er", "r", "(", "options", ".", "Run", "C", "St", "or", "SP", "C", "Upgrade", "(", "cmd", "),", "\u0120util", ".", "F", "atal", ")", "\u0120+", "\u0120if", "\u0120options", ".", "c", "st", "or", "SP", "C", ".", "sp", "c", "Name", "\u0120!=", "\u0120\"\"", "\u0120{", "\u0120+", "\u0120single", "C", "st", "or", "SP", "C", "Upgrade", "(", "cmd", ")", "\u0120+", "\u0120}", "\u0120+", "\u0120if", "\u0120len", "(", "args", ")", "\u0120!=", "\u01200", "\u0120{", "\u0120+", "\u0120bulk", "C", "st", "or", "SP", "C", "Upgrade", "(", "cmd", ",", "\u0120args", ")", "\u0120+", "\u0120}", "\u0120},", "\u0120}", "\u0120"], "docstring_tokens": ["this", "\u0120example", "\u0120needs", "\u0120a", "\u0120fix", "?"]}
{"function": "@@ -248,9 +248,9 @@ static void close(struct roots_view *view) { struct wlr_xdg_surface *surface = view->xdg_surface; struct wlr_xdg_popup *popup = NULL; wl_list_for_each(popup, &surface->popups, link) { - wlr_xdg_surface_send_close(popup->base); + wlr_xdg_popup_destroy(popup->base); } - wlr_xdg_surface_send_close(surface); + wlr_xdg_toplevel_send_close(surface); } static void destroy(struct roots_view *view) {", "text": "Is it safe to assume this surface is a toplevel?", "function_tokens": ["@@", "\u0120-", "248", ",", "9", "\u0120+", "248", ",", "9", "\u0120@@", "\u0120static", "\u0120void", "\u0120close", "(", "struct", "\u0120roots", "_", "view", "\u0120*", "view", ")", "\u0120{", "\u0120struct", "\u0120w", "lr", "_", "xd", "g", "_", "surface", "\u0120*", "surface", "\u0120=", "\u0120view", "->", "xd", "g", "_", "surface", ";", "\u0120struct", "\u0120w", "lr", "_", "xd", "g", "_", "pop", "up", "\u0120*", "pop", "up", "\u0120=", "\u0120NULL", ";", "\u0120w", "l", "_", "list", "_", "for", "_", "each", "(", "pop", "up", ",", "\u0120&", "surface", "->", "pop", "ups", ",", "\u0120link", ")", "\u0120{", "\u0120-", "\u0120w", "lr", "_", "xd", "g", "_", "surface", "_", "send", "_", "close", "(", "pop", "up", "->", "base", ");", "\u0120+", "\u0120w", "lr", "_", "xd", "g", "_", "pop", "up", "_", "destroy", "(", "pop", "up", "->", "base", ");", "\u0120}", "\u0120-", "\u0120w", "lr", "_", "xd", "g", "_", "surface", "_", "send", "_", "close", "(", "surface", ");", "\u0120+", "\u0120w", "lr", "_", "xd", "g", "_", "t", "ople", "vel", "_", "send", "_", "close", "(", "surface", ");", "\u0120}", "\u0120static", "\u0120void", "\u0120destroy", "(", "struct", "\u0120roots", "_", "view", "\u0120*", "view", ")", "\u0120{"], "docstring_tokens": ["Is", "\u0120it", "\u0120safe", "\u0120to", "\u0120assume", "\u0120this", "\u0120surface", "\u0120is", "\u0120a", "\u0120to", "ple", "vel", "?"]}
{"function": "@@ -225,6 +225,16 @@ projCtx pj_ctx_alloc() return new (std::nothrow) projCtx_t(*pj_get_default_ctx()); } +/************************************************************************/ +/* pj_ctx_clone() */ +/************************************************************************/ + +projCtx pj_ctx_clone( projCtx ctx ) + +{ + return new (std::nothrow) projCtx_t(*ctx); +} + /************************************************************************/ /* pj_ctx_free() */ /************************************************************************/", "text": "we don't need that function", "function_tokens": ["@@", "\u0120-", "225", ",", "6", "\u0120+", "225", ",", "16", "\u0120@@", "\u0120pro", "j", "C", "tx", "\u0120p", "j", "_", "ctx", "_", "alloc", "()", "\u0120return", "\u0120new", "\u0120(", "std", "::", "n", "oth", "row", ")", "\u0120pro", "j", "C", "tx", "_", "t", "(*", "p", "j", "_", "get", "_", "default", "_", "ctx", "());", "\u0120}", "\u0120+", "/", "********************************", "********************************", "********", "/", "\u0120+", "/*", "\u0120p", "j", "_", "ctx", "_", "clone", "()", "\u0120*/", "\u0120+", "/", "********************************", "********************************", "********", "/", "\u0120+", "\u0120+", "pro", "j", "C", "tx", "\u0120p", "j", "_", "ctx", "_", "clone", "(", "\u0120pro", "j", "C", "tx", "\u0120c", "tx", "\u0120)", "\u0120+", "\u0120+", "{", "\u0120+", "\u0120return", "\u0120new", "\u0120(", "std", "::", "n", "oth", "row", ")", "\u0120pro", "j", "C", "tx", "_", "t", "(*", "ctx", ");", "\u0120+", "}", "\u0120+", "\u0120/", "********************************", "********************************", "********", "/", "\u0120/*", "\u0120p", "j", "_", "ctx", "_", "free", "()", "\u0120*/", "\u0120/", "********************************", "********************************", "********", "/"], "docstring_tokens": ["we", "\u0120don", "'t", "\u0120need", "\u0120that", "\u0120function"]}
{"function": "@@ -72,6 +72,13 @@ public enum Platform { } }, + WIN10(\"windows 10\", \"win10\") { + @Override + public Platform family() { + return WINDOWS; + } + }, + MAC(\"mac\", \"darwin\", \"os x\") {}, SNOW_LEOPARD(\"snow leopard\", \"os x 10.6\") {", "text": "we'll also have to think about adding \"Windows Server 2014\" or whatever they come up with later.", "function_tokens": ["@@", "\u0120-", "72", ",", "6", "\u0120+", "72", ",", "13", "\u0120@@", "\u0120public", "\u0120enum", "\u0120Platform", "\u0120{", "\u0120}", "\u0120},", "\u0120+", "\u0120WIN", "10", "(\"", "windows", "\u012010", "\",", "\u0120\"", "win", "10", "\")", "\u0120{", "\u0120+", "\u0120@", "Override", "\u0120+", "\u0120public", "\u0120Platform", "\u0120family", "()", "\u0120{", "\u0120+", "\u0120return", "\u0120W", "IND", "OWS", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120},", "\u0120+", "\u0120MAC", "(\"", "mac", "\",", "\u0120\"", "dar", "win", "\",", "\u0120\"", "os", "\u0120x", "\")", "\u0120{", "},", "\u0120SN", "OW", "_", "LE", "OP", "ARD", "(\"", "s", "now", "\u0120le", "opard", "\",", "\u0120\"", "os", "\u0120x", "\u012010", ".", "6", "\")", "\u0120{"], "docstring_tokens": ["we", "'ll", "\u0120also", "\u0120have", "\u0120to", "\u0120think", "\u0120about", "\u0120adding", "\u0120\"", "Windows", "\u0120Server", "\u01202014", "\"", "\u0120or", "\u0120whatever", "\u0120they", "\u0120come", "\u0120up", "\u0120with", "\u0120later", "."]}
{"function": "@@ -35,6 +35,9 @@ public interface ExecutorLoader { Map<Integer, Pair<ExecutionReference, ExecutableFlow>> fetchActiveFlows() throws ExecutorManagerException; + Pair<ExecutionReference, ExecutableFlow> fetchActiveFlowByExecId(int execId) + throws ExecutorManagerException; + List<ExecutableFlow> fetchFlowHistory(int skip, int num) throws ExecutorManagerException; ", "text": "curious do we have an API to fetch an inactive flow?", "function_tokens": ["@@", "\u0120-", "35", ",", "6", "\u0120+", "35", ",", "9", "\u0120@@", "\u0120public", "\u0120interface", "\u0120Exec", "utor", "Loader", "\u0120{", "\u0120Map", "<", "Integer", ",", "\u0120Pair", "<", "Exec", "ution", "Reference", ",", "\u0120Exec", "utable", "Flow", ">>", "\u0120fetch", "Active", "Fl", "ows", "()", "\u0120throws", "\u0120Exec", "utor", "Manager", "Exception", ";", "\u0120+", "\u0120Pair", "<", "Exec", "ution", "Reference", ",", "\u0120Exec", "utable", "Flow", ">", "\u0120fetch", "Active", "Flow", "By", "Exec", "Id", "(", "int", "\u0120exec", "Id", ")", "\u0120+", "\u0120throws", "\u0120Exec", "utor", "Manager", "Exception", ";", "\u0120+", "\u0120List", "<", "Exec", "utable", "Flow", ">", "\u0120fetch", "Flow", "History", "(", "int", "\u0120skip", ",", "\u0120int", "\u0120num", ")", "\u0120throws", "\u0120Exec", "utor", "Manager", "Exception", ";", "\u0120"], "docstring_tokens": ["c", "urious", "\u0120do", "\u0120we", "\u0120have", "\u0120an", "\u0120API", "\u0120to", "\u0120fetch", "\u0120an", "\u0120inactive", "\u0120flow", "?"]}
{"function": "@@ -116,10 +116,6 @@ function upgradeToVNodes(arr, offset) { if (Array.isArray(obj)) { upgradeToVNodes(obj); } - else if (obj && typeof obj==='object' && !isValidElement(obj) && ((obj.props && obj.type) || obj.text!=null)) { - if (obj.text) continue; - arr[i] = createElement(obj.type, obj.props, obj.props.children); - } } } ", "text": "This branch is not needed anymore because every `vnode` that passes through `h` in compat or core will have the `$$typeof`-property now .", "function_tokens": ["@@", "\u0120-", "116", ",", "10", "\u0120+", "116", ",", "6", "\u0120@@", "\u0120function", "\u0120upgrade", "To", "V", "N", "odes", "(", "arr", ",", "\u0120offset", ")", "\u0120{", "\u0120if", "\u0120(", "Array", ".", "is", "Array", "(", "obj", "))", "\u0120{", "\u0120upgrade", "To", "V", "N", "odes", "(", "obj", ");", "\u0120}", "\u0120-", "\u0120else", "\u0120if", "\u0120(", "obj", "\u0120&&", "\u0120type", "of", "\u0120obj", "==", "='", "object", "'", "\u0120&&", "\u0120!", "is", "Valid", "Element", "(", "obj", ")", "\u0120&&", "\u0120((", "obj", ".", "pro", "ps", "\u0120&&", "\u0120obj", ".", "type", ")", "\u0120||", "\u0120obj", ".", "text", "!", "=", "null", "))", "\u0120{", "\u0120-", "\u0120if", "\u0120(", "obj", ".", "text", ")", "\u0120continue", ";", "\u0120-", "\u0120arr", "[", "i", "]", "\u0120=", "\u0120create", "Element", "(", "obj", ".", "type", ",", "\u0120obj", ".", "pro", "ps", ",", "\u0120obj", ".", "pro", "ps", ".", "children", ");", "\u0120-", "\u0120}", "\u0120}", "\u0120}", "\u0120"], "docstring_tokens": ["This", "\u0120branch", "\u0120is", "\u0120not", "\u0120needed", "\u0120anymore", "\u0120because", "\u0120every", "\u0120`", "v", "node", "`", "\u0120that", "\u0120passes", "\u0120through", "\u0120`", "h", "`", "\u0120in", "\u0120compat", "\u0120or", "\u0120core", "\u0120will", "\u0120have", "\u0120the", "\u0120`", "$$", "type", "of", "`", "-", "property", "\u0120now", "\u0120."]}
{"function": "@@ -0,0 +1,16 @@ +const { getComposedParent } = axe.commons.dom; + +function shouldMatchElement(el) { + if (!el) { + return true; + } + const ariaHiddenValue = el.getAttribute('aria-hidden') + ? el.getAttribute('aria-hidden') + : null; + if (ariaHiddenValue === null) { + return shouldMatchElement(getComposedParent(el)); + } + return false; +} + +return shouldMatchElement(getComposedParent(node));", "text": "Did you mean to use `hasAttribute`? You shouldn't. This does not improve performance and it messes with the readability.", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "16", "\u0120@@", "\u0120+", "const", "\u0120{", "\u0120get", "Comp", "osed", "Parent", "\u0120}", "\u0120=", "\u0120axe", ".", "comm", "ons", ".", "dom", ";", "\u0120+", "\u0120+", "function", "\u0120should", "Match", "Element", "(", "el", ")", "\u0120{", "\u0120+", "\u0120if", "\u0120(!", "el", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120true", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120const", "\u0120a", "ria", "Hidden", "Value", "\u0120=", "\u0120el", ".", "get", "Attribute", "('", "aria", "-", "hidden", "')", "\u0120+", "\u0120?", "\u0120el", ".", "get", "Attribute", "('", "aria", "-", "hidden", "')", "\u0120+", "\u0120:", "\u0120null", ";", "\u0120+", "\u0120if", "\u0120(", "aria", "Hidden", "Value", "\u0120===", "\u0120null", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120should", "Match", "Element", "(", "get", "Comp", "osed", "Parent", "(", "el", "));", "\u0120+", "\u0120}", "\u0120+", "\u0120return", "\u0120false", ";", "\u0120+", "}", "\u0120+", "\u0120+", "return", "\u0120should", "Match", "Element", "(", "get", "Comp", "osed", "Parent", "(", "node", "));"], "docstring_tokens": ["Did", "\u0120you", "\u0120mean", "\u0120to", "\u0120use", "\u0120`", "has", "Attribute", "`", "?", "\u0120You", "\u0120shouldn", "'t", ".", "\u0120This", "\u0120does", "\u0120not", "\u0120improve", "\u0120performance", "\u0120and", "\u0120it", "\u0120mess", "es", "\u0120with", "\u0120the", "\u0120read", "ability", "."]}
{"function": "@@ -37,13 +37,14 @@ import pytest import py.path # pylint: disable=no-name-in-module import helpers.stubs as stubsmod +from helpers.utils import CallbackChecker from qutebrowser.config import config, configdata, configtypes, configexc from qutebrowser.utils import objreg, standarddir from qutebrowser.browser.webkit import cookies from qutebrowser.misc import savemanager, sql from qutebrowser.keyinput import modeman -from PyQt5.QtCore import pyqtSignal, QEvent, QSize, Qt, QObject +from PyQt5.QtCore import QEvent, QSize, Qt from PyQt5.QtGui import QKeyEvent from PyQt5.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout from PyQt5.QtNetwork import QNetworkCookieJar", "text": "Please import modules and not classes (except for Qt stuff).", "function_tokens": ["@@", "\u0120-", "37", ",", "13", "\u0120+", "37", ",", "14", "\u0120@@", "\u0120import", "\u0120py", "test", "\u0120import", "\u0120py", ".", "path", "\u0120#", "\u0120p", "yl", "int", ":", "\u0120disable", "=", "no", "-", "name", "-", "in", "-", "module", "\u0120import", "\u0120helpers", ".", "st", "ubs", "\u0120as", "\u0120stub", "s", "mod", "\u0120+", "from", "\u0120helpers", ".", "utils", "\u0120import", "\u0120Call", "back", "Check", "er", "\u0120from", "\u0120q", "ute", "browser", ".", "config", "\u0120import", "\u0120config", ",", "\u0120config", "data", ",", "\u0120config", "types", ",", "\u0120config", "exc", "\u0120from", "\u0120q", "ute", "browser", ".", "utils", "\u0120import", "\u0120obj", "reg", ",", "\u0120standard", "dir", "\u0120from", "\u0120q", "ute", "browser", ".", "browser", ".", "webkit", "\u0120import", "\u0120cookies", "\u0120from", "\u0120q", "ute", "browser", ".", "misc", "\u0120import", "\u0120save", "manager", ",", "\u0120sql", "\u0120from", "\u0120q", "ute", "browser", ".", "key", "input", "\u0120import", "\u0120mod", "eman", "\u0120-", "from", "\u0120Py", "Q", "t", "5", ".", "Q", "t", "Core", "\u0120import", "\u0120py", "qt", "Sign", "al", ",", "\u0120Q", "Event", ",", "\u0120Q", "Size", ",", "\u0120Qt", ",", "\u0120Q", "Object", "\u0120+", "from", "\u0120Py", "Q", "t", "5", ".", "Q", "t", "Core", "\u0120import", "\u0120Q", "Event", ",", "\u0120Q", "Size", ",", "\u0120Qt", "\u0120from", "\u0120Py", "Q", "t", "5", ".", "Q", "t", "Gu", "i", "\u0120import", "\u0120Q", "Key", "Event", "\u0120from", "\u0120Py", "Q", "t", "5", ".", "Q", "t", "W", "id", "gets", "\u0120import", "\u0120Q", "Widget", ",", "\u0120Q", "H", "Box", "Layout", ",", "\u0120Q", "V", "Box", "Layout", "\u0120from", "\u0120Py", "Q", "t", "5", ".", "Q", "t", "Network", "\u0120import", "\u0120Q", "Network", "C", "ookie", "Jar"], "docstring_tokens": ["Please", "\u0120import", "\u0120modules", "\u0120and", "\u0120not", "\u0120classes", "\u0120(", "except", "\u0120for", "\u0120Qt", "\u0120stuff", ")."]}
{"function": "@@ -20,6 +20,11 @@ public class DummyJavaNode extends AbstractJavaNode { super(id); } + @Override + public void setImage(String image) { + super.setImage(image); + } + @Override public Object jjtAccept(JavaParserVisitor visitor, Object data) { return data;", "text": "Hm... why do we have a \"DummyJavaNode\" in src/main? Looks like, this should have gone into src/test....", "function_tokens": ["@@", "\u0120-", "20", ",", "6", "\u0120+", "20", ",", "11", "\u0120@@", "\u0120public", "\u0120class", "\u0120D", "ummy", "Java", "Node", "\u0120extends", "\u0120Abstract", "Java", "Node", "\u0120{", "\u0120super", "(", "id", ");", "\u0120}", "\u0120+", "\u0120@", "Override", "\u0120+", "\u0120public", "\u0120void", "\u0120set", "Image", "(", "String", "\u0120image", ")", "\u0120{", "\u0120+", "\u0120super", ".", "set", "Image", "(", "image", ");", "\u0120+", "\u0120}", "\u0120+", "\u0120@", "Override", "\u0120public", "\u0120Object", "\u0120j", "j", "t", "Accept", "(", "Java", "Parser", "Vis", "itor", "\u0120visitor", ",", "\u0120Object", "\u0120data", ")", "\u0120{", "\u0120return", "\u0120data", ";"], "docstring_tokens": ["H", "m", "...", "\u0120why", "\u0120do", "\u0120we", "\u0120have", "\u0120a", "\u0120\"", "D", "ummy", "Java", "Node", "\"", "\u0120in", "\u0120src", "/", "main", "?", "\u0120Looks", "\u0120like", ",", "\u0120this", "\u0120should", "\u0120have", "\u0120gone", "\u0120into", "\u0120src", "/", "test", "...."]}
{"function": "@@ -14,6 +14,7 @@ See the License for the specific language governing permissions and limitations under the License. */ +// Package v1alpha1 package v1alpha1 // CasKey is used for all cas specific annotation keys", "text": "This seems meaningless. If we cannot add any info let us remove this.", "function_tokens": ["@@", "\u0120-", "14", ",", "6", "\u0120+", "14", ",", "7", "\u0120@@", "\u0120See", "\u0120the", "\u0120License", "\u0120for", "\u0120the", "\u0120specific", "\u0120language", "\u0120governing", "\u0120permissions", "\u0120and", "\u0120limitations", "\u0120under", "\u0120the", "\u0120License", ".", "\u0120*/", "\u0120+", "//", "\u0120Package", "\u0120v", "1", "alpha", "1", "\u0120package", "\u0120v", "1", "alpha", "1", "\u0120//", "\u0120Cas", "Key", "\u0120is", "\u0120used", "\u0120for", "\u0120all", "\u0120cas", "\u0120specific", "\u0120annotation", "\u0120keys"], "docstring_tokens": ["This", "\u0120seems", "\u0120meaningless", ".", "\u0120If", "\u0120we", "\u0120cannot", "\u0120add", "\u0120any", "\u0120info", "\u0120let", "\u0120us", "\u0120remove", "\u0120this", "."]}
{"function": "@@ -493,6 +493,14 @@ func (c *Container) GetLabels() map[string]string { return c.labels } +// GetPorts gets the ports for a container +func (c *Container) GetPorts() []PortBinding { + c.lock.RLock() + defer c.lock.RUnlock() + + return c.Ports +} + // HealthStatusShouldBeReported returns true if the health check is defined in // the task definition func (c *Container) HealthStatusShouldBeReported() bool {", "text": "Can you rename `Ports` to `PortsUnsafe`?", "function_tokens": ["@@", "\u0120-", "493", ",", "6", "\u0120+", "493", ",", "14", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120*", "Container", ")", "\u0120Get", "Lab", "els", "()", "\u0120map", "[", "string", "]", "string", "\u0120{", "\u0120return", "\u0120c", ".", "lab", "els", "\u0120}", "\u0120+", "//", "\u0120Get", "P", "orts", "\u0120gets", "\u0120the", "\u0120ports", "\u0120for", "\u0120a", "\u0120container", "\u0120+", "func", "\u0120(", "c", "\u0120*", "Container", ")", "\u0120Get", "P", "orts", "()", "\u0120[]", "Port", "B", "inding", "\u0120{", "\u0120+", "\u0120c", ".", "lock", ".", "RL", "ock", "()", "\u0120+", "\u0120defer", "\u0120c", ".", "lock", ".", "R", "Un", "lock", "()", "\u0120+", "\u0120+", "\u0120return", "\u0120c", ".", "P", "orts", "\u0120+", "}", "\u0120+", "\u0120//", "\u0120Health", "Status", "Should", "Be", "Rep", "orted", "\u0120returns", "\u0120true", "\u0120if", "\u0120the", "\u0120health", "\u0120check", "\u0120is", "\u0120defined", "\u0120in", "\u0120//", "\u0120the", "\u0120task", "\u0120definition", "\u0120func", "\u0120(", "c", "\u0120*", "Container", ")", "\u0120Health", "Status", "Should", "Be", "Rep", "orted", "()", "\u0120bool", "\u0120{"], "docstring_tokens": ["Can", "\u0120you", "\u0120rename", "\u0120`", "P", "orts", "`", "\u0120to", "\u0120`", "P", "orts", "Un", "safe", "`", "?"]}
{"function": "@@ -0,0 +1,10 @@ +module ReturnToHelper + def make_return_to(name, path) + sig = OpenSSL::HMAC.digest( + OpenSSL::Digest::SHA256.new, + Rails.application.secrets.secret_key_base, + name + \"$\" + path + ) + {name: name, path: path, sig: Base64.urlsafe_encode64(sig)} + end +end", "text": "This feels like it could be moved out to your first gem!", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "10", "\u0120@@", "\u0120+", "module", "\u0120Return", "To", "Helper", "\u0120+", "\u0120def", "\u0120make", "_", "return", "_", "to", "(", "name", ",", "\u0120path", ")", "\u0120+", "\u0120sig", "\u0120=", "\u0120Open", "SSL", "::", "HM", "AC", ".", "dig", "est", "(", "\u0120+", "\u0120Open", "SSL", "::", "Dig", "est", "::", "SHA", "256", ".", "new", ",", "\u0120+", "\u0120Rails", ".", "application", ".", "sec", "rets", ".", "secret", "_", "key", "_", "base", ",", "\u0120+", "\u0120name", "\u0120+", "\u0120\"$", "\"", "\u0120+", "\u0120path", "\u0120+", "\u0120)", "\u0120+", "\u0120{", "name", ":", "\u0120name", ",", "\u0120path", ":", "\u0120path", ",", "\u0120sig", ":", "\u0120Base", "64", ".", "url", "safe", "_", "en", "code", "64", "(", "s", "ig", ")}", "\u0120+", "\u0120end", "\u0120+", "end"], "docstring_tokens": ["This", "\u0120feels", "\u0120like", "\u0120it", "\u0120could", "\u0120be", "\u0120moved", "\u0120out", "\u0120to", "\u0120your", "\u0120first", "\u0120gem", "!"]}
{"function": "@@ -44,7 +44,7 @@ public abstract class NewSessionQueue implements HasReadyState { public abstract boolean offerFirst(HttpRequest request, RequestId requestId); - public abstract Optional<HttpRequest> poll(); + public abstract Optional<HttpRequest> poll(RequestId requestId); public abstract int clear(); ", "text": "The expected behaviour for `poll` would be to match what `Deque` does, which is: > Retrieves and removes the head of the queue represented by this deque As such, you shouldn't need the `RequestId` here.", "function_tokens": ["@@", "\u0120-", "44", ",", "7", "\u0120+", "44", ",", "7", "\u0120@@", "\u0120public", "\u0120abstract", "\u0120class", "\u0120New", "Session", "Queue", "\u0120implements", "\u0120Has", "Ready", "State", "\u0120{", "\u0120public", "\u0120abstract", "\u0120boolean", "\u0120offer", "First", "(", "Http", "Request", "\u0120request", ",", "\u0120Request", "Id", "\u0120request", "Id", ");", "\u0120-", "\u0120public", "\u0120abstract", "\u0120Optional", "<", "Http", "Request", ">", "\u0120poll", "();", "\u0120+", "\u0120public", "\u0120abstract", "\u0120Optional", "<", "Http", "Request", ">", "\u0120poll", "(", "Request", "Id", "\u0120request", "Id", ");", "\u0120public", "\u0120abstract", "\u0120int", "\u0120clear", "();", "\u0120"], "docstring_tokens": ["The", "\u0120expected", "\u0120behaviour", "\u0120for", "\u0120`", "poll", "`", "\u0120would", "\u0120be", "\u0120to", "\u0120match", "\u0120what", "\u0120`", "De", "que", "`", "\u0120does", ",", "\u0120which", "\u0120is", ":", "\u0120>", "\u0120Ret", "rie", "ves", "\u0120and", "\u0120removes", "\u0120the", "\u0120head", "\u0120of", "\u0120the", "\u0120queue", "\u0120represented", "\u0120by", "\u0120this", "\u0120de", "que", "\u0120As", "\u0120such", ",", "\u0120you", "\u0120shouldn", "'t", "\u0120need", "\u0120the", "\u0120`", "Request", "Id", "`", "\u0120here", "."]}
{"function": "@@ -7,4 +7,17 @@ axe.utils.toArray = function (thing) { 'use strict'; return Array.prototype.slice.call(thing); -}; +}; + + +/** + * Creates an array without duplicate values from 2 array inputs + * @param {Array} arr1 First array + * @param {Array} arr2 Second array + * @return {Array} + */ +axe.utils.uniqueArray = (arr1, arr2) => { + return arr1.concat(arr2).filter((elem, pos, arr) => { + return arr.indexOf(elem) === pos; + }); +};", "text": "This is super minor, but it'd be nice if this iterated over an arbitrary number of array inputs.", "function_tokens": ["@@", "\u0120-", "7", ",", "4", "\u0120+", "7", ",", "17", "\u0120@@", "\u0120axe", ".", "utils", ".", "to", "Array", "\u0120=", "\u0120function", "\u0120(", "thing", ")", "\u0120{", "\u0120'", "use", "\u0120strict", "';", "\u0120return", "\u0120Array", ".", "prototype", ".", "slice", ".", "call", "(", "thing", ");", "\u0120-", "};", "\u0120+", "};", "\u0120+", "\u0120+", "\u0120+", "/**", "\u0120+", "\u0120*", "\u0120Creat", "es", "\u0120an", "\u0120array", "\u0120without", "\u0120duplicate", "\u0120values", "\u0120from", "\u01202", "\u0120array", "\u0120inputs", "\u0120+", "\u0120*", "\u0120@", "param", "\u0120{", "Array", "}", "\u0120arr", "1", "\u0120First", "\u0120array", "\u0120+", "\u0120*", "\u0120@", "param", "\u0120{", "Array", "}", "\u0120arr", "2", "\u0120Second", "\u0120array", "\u0120+", "\u0120*", "\u0120@", "return", "\u0120{", "Array", "}", "\u0120+", "\u0120*/", "\u0120+", "axe", ".", "utils", ".", "unique", "Array", "\u0120=", "\u0120(", "arr", "1", ",", "\u0120arr", "2", ")", "\u0120=>", "\u0120{", "\u0120+", "\u0120return", "\u0120arr", "1", ".", "con", "cat", "(", "arr", "2", ").", "filter", "((", "e", "lem", ",", "\u0120pos", ",", "\u0120arr", ")", "\u0120=>", "\u0120{", "\u0120+", "\u0120return", "\u0120arr", ".", "index", "Of", "(", "e", "lem", ")", "\u0120===", "\u0120pos", ";", "\u0120+", "\u0120});", "\u0120+", "};"], "docstring_tokens": ["This", "\u0120is", "\u0120super", "\u0120minor", ",", "\u0120but", "\u0120it", "'d", "\u0120be", "\u0120nice", "\u0120if", "\u0120this", "\u0120iter", "ated", "\u0120over", "\u0120an", "\u0120arbitrary", "\u0120number", "\u0120of", "\u0120array", "\u0120inputs", "."]}
{"function": "@@ -1676,9 +1676,10 @@ _tmain(int argc, TCHAR *targv[]) } # ifdef UNIX /* i#1676: detect whether under gdb */ - _snprintf(buf, BUFFER_SIZE_ELEMENTS(buf), \"/proc/%d/exe\", getppid()); - NULL_TERMINATE_BUFFER(buf); - i = readlink(buf, buf, BUFFER_SIZE_ELEMENTS(buf)); + char path_buf[MAXIMUM_PATH]; + _snprintf(path_buf, BUFFER_SIZE_ELEMENTS(path_buf), \"/proc/%d/exe\", getppid()); + NULL_TERMINATE_BUFFER(path_buf); + i = readlink(path_buf, buf, BUFFER_SIZE_ELEMENTS(buf)); if (i > 0) { if (i < BUFFER_SIZE_ELEMENTS(buf)) buf[i] = '\\0';", "text": "What is the problem here? The commit message has strange wording \"readlink is defined with restrict pointers\": do you mean \"restricted\"? Is that a well-defined language term? I'm not sure what it means.", "function_tokens": ["@@", "\u0120-", "16", "76", ",", "9", "\u0120+", "16", "76", ",", "10", "\u0120@@", "\u0120_", "t", "main", "(", "int", "\u0120arg", "c", ",", "\u0120T", "CHAR", "\u0120*", "t", "arg", "v", "[", "])", "\u0120}", "\u0120#", "\u0120if", "def", "\u0120UN", "IX", "\u0120/*", "\u0120i", "#", "16", "76", ":", "\u0120detect", "\u0120whether", "\u0120under", "\u0120g", "db", "\u0120*/", "\u0120-", "\u0120_", "sn", "printf", "(", "buf", ",", "\u0120BU", "FFER", "_", "SIZE", "_", "E", "LE", "MENTS", "(", "buf", "),", "\u0120\"/", "proc", "/", "%", "d", "/", "exe", "\",", "\u0120get", "pp", "id", "());", "\u0120-", "\u0120NULL", "_", "TER", "MIN", "ATE", "_", "BU", "FFER", "(", "buf", ");", "\u0120-", "\u0120i", "\u0120=", "\u0120read", "link", "(", "buf", ",", "\u0120buf", ",", "\u0120BU", "FFER", "_", "SIZE", "_", "E", "LE", "MENTS", "(", "buf", "));", "\u0120+", "\u0120char", "\u0120path", "_", "buf", "[", "MAX", "IM", "UM", "_", "PATH", "];", "\u0120+", "\u0120_", "sn", "printf", "(", "path", "_", "buf", ",", "\u0120BU", "FFER", "_", "SIZE", "_", "E", "LE", "MENTS", "(", "path", "_", "buf", "),", "\u0120\"/", "proc", "/", "%", "d", "/", "exe", "\",", "\u0120get", "pp", "id", "());", "\u0120+", "\u0120NULL", "_", "TER", "MIN", "ATE", "_", "BU", "FFER", "(", "path", "_", "buf", ");", "\u0120+", "\u0120i", "\u0120=", "\u0120read", "link", "(", "path", "_", "buf", ",", "\u0120buf", ",", "\u0120BU", "FFER", "_", "SIZE", "_", "E", "LE", "MENTS", "(", "buf", "));", "\u0120if", "\u0120(", "i", "\u0120>", "\u01200", ")", "\u0120{", "\u0120if", "\u0120(", "i", "\u0120<", "\u0120BU", "FFER", "_", "SIZE", "_", "E", "LE", "MENTS", "(", "buf", "))", "\u0120buf", "[", "i", "]", "\u0120=", "\u0120'", "\\", "0", "';"], "docstring_tokens": ["What", "\u0120is", "\u0120the", "\u0120problem", "\u0120here", "?", "\u0120The", "\u0120commit", "\u0120message", "\u0120has", "\u0120strange", "\u0120wording", "\u0120\"", "read", "link", "\u0120is", "\u0120defined", "\u0120with", "\u0120restrict", "\u0120pointers", "\":", "\u0120do", "\u0120you", "\u0120mean", "\u0120\"", "restricted", "\"?", "\u0120Is", "\u0120that", "\u0120a", "\u0120well", "-", "defined", "\u0120language", "\u0120term", "?", "\u0120I", "'m", "\u0120not", "\u0120sure", "\u0120what", "\u0120it", "\u0120means", "."]}
{"function": "@@ -17,6 +17,7 @@ package com.google.api.codegen.util.ruby; import com.google.api.codegen.util.Name; import com.google.api.codegen.util.NameFormatter; import com.google.api.codegen.util.NamePath; +import com.google.common.collect.ImmutableSet; /** * The NameFormatter for Ruby.", "text": "Why are we not wrapping here?", "function_tokens": ["@@", "\u0120-", "17", ",", "6", "\u0120+", "17", ",", "7", "\u0120@@", "\u0120package", "\u0120com", ".", "google", ".", "api", ".", "code", "gen", ".", "util", ".", "ruby", ";", "\u0120import", "\u0120com", ".", "google", ".", "api", ".", "code", "gen", ".", "util", ".", "Name", ";", "\u0120import", "\u0120com", ".", "google", ".", "api", ".", "code", "gen", ".", "util", ".", "Name", "Form", "atter", ";", "\u0120import", "\u0120com", ".", "google", ".", "api", ".", "code", "gen", ".", "util", ".", "Name", "Path", ";", "\u0120+", "import", "\u0120com", ".", "google", ".", "common", ".", "collect", ".", "Imm", "utable", "Set", ";", "\u0120/**", "\u0120*", "\u0120The", "\u0120Name", "Form", "atter", "\u0120for", "\u0120Ruby", "."], "docstring_tokens": ["Why", "\u0120are", "\u0120we", "\u0120not", "\u0120wrapping", "\u0120here", "?"]}
{"function": "@@ -2,12 +2,10 @@ namespace Shopsys\\FrameworkBundle\\Model\\Product\\Filter; -use Shopsys\\FrameworkBundle\\Model\\Product\\Parameter\\Parameter; - class ParameterFilterData { /** - * @var \\Shopsys\\FrameworkBundle\\Model\\Product\\Parameter\\Parameter + * @var \\Shopsys\\FrameworkBundle\\Model\\Product\\Parameter\\Parameter|null */ public $parameter; ", "text": "I though that all data objects are being unified in the fashion where all default values are initialized in constructor, are not they?", "function_tokens": ["@@", "\u0120-", "2", ",", "12", "\u0120+", "2", ",", "10", "\u0120@@", "\u0120namespace", "\u0120Sh", "ops", "ys", "\\", "Fram", "ework", "B", "undle", "\\", "Model", "\\", "Product", "\\", "Filter", ";", "\u0120-", "use", "\u0120Sh", "ops", "ys", "\\", "Fram", "ework", "B", "undle", "\\", "Model", "\\", "Product", "\\", "Parameter", "\\", "Parameter", ";", "\u0120-", "\u0120class", "\u0120Param", "eter", "Filter", "Data", "\u0120{", "\u0120/**", "\u0120-", "\u0120*", "\u0120@", "var", "\u0120\\", "Sh", "ops", "ys", "\\", "Fram", "ework", "B", "undle", "\\", "Model", "\\", "Product", "\\", "Parameter", "\\", "Parameter", "\u0120+", "\u0120*", "\u0120@", "var", "\u0120\\", "Sh", "ops", "ys", "\\", "Fram", "ework", "B", "undle", "\\", "Model", "\\", "Product", "\\", "Parameter", "\\", "Parameter", "|", "null", "\u0120*/", "\u0120public", "\u0120$", "param", "eter", ";", "\u0120"], "docstring_tokens": ["I", "\u0120though", "\u0120that", "\u0120all", "\u0120data", "\u0120objects", "\u0120are", "\u0120being", "\u0120unified", "\u0120in", "\u0120the", "\u0120fashion", "\u0120where", "\u0120all", "\u0120default", "\u0120values", "\u0120are", "\u0120initialized", "\u0120in", "\u0120constructor", ",", "\u0120are", "\u0120not", "\u0120they", "?"]}
{"function": "@@ -22,16 +22,16 @@ var sourceHashes = map[string]string{ \"libflux/flux-core/src/ast/flatbuffers/mod.rs\": \"00c75dc1da14487953a4a017616fb8a237fe3da437c876f1328532dd7906f015\", \"libflux/flux-core/src/ast/flatbuffers/monotype.rs\": \"4e82aae8e7edb8e230302241fe702ece9ae84fc708003c24709c2ea944cfaae8\", \"libflux/flux-core/src/ast/flatbuffers/tests.rs\": \"ea85b78049f0c3d79daedcf9e171ccb00d0a596d1a643aa218590c99e6b160bc\", - \"libflux/flux-core/src/ast/mod.rs\": \"676e22d24cd7a97525688ed391a980d08b4bee40c5b5067d187f3ae6d66210ca\", + \"libflux/flux-core/src/ast/mod.rs\": \"29b25b75a01cf1e1ac2b52d99b91986cec32011dc55af1ffd7f145838fce858d\", \"libflux/flux-core/src/ast/tests.rs\": \"bc7f77d569d8bbd4b9d00653f48bacd47eed46f53024dce836d3c8bbb6a80555\", \"libflux/flux-core/src/ast/walk/mod.rs\": \"e8a03023d7426bcf6dfdb1a61ac3263f5cf9194a595a1584dff7c899d06562f1\", \"libflux/flux-core/src/ast/walk/tests.rs\": \"f7b2d7dd5643bb795a86c04b6979b136b0de46b52b213caff094aed6d204a05d\", \"libflux/flux-core/src/formatter/mod.rs\": \"945736a4ad87adb6a3f359b6f2da6e5492b3cb0efd282e277303e2acae137763\", \"libflux/flux-core/src/formatter/tests.rs\": \"b0a10998a65fc4b54a8f68b3a0ed186d8548ba3d7638f911eb188d2ce485206f\", \"libflux/flux-core/src/lib.rs\": \"d19b7054e07f234c107d457030a0031374c123fe14a84a5b8e35537d138bac7a\", - \"libflux/flux-core/src/parser/mod.rs\": \"e3f11fe29f47271b5c04accc2d7efa35e1dc62c6de036bf0cc0cccda5e4742e8\", + \"libflux/flux-core/src/parser/mod.rs\": \"daf24b2c439f4c7a6f138e2b25064a205aee73bb6cffc898df22dd0c962ca5df\", \"libflux/flux-core/src/parser/strconv.rs\": \"748c82f6efc2eafaafb872db5b4185ce29aafa8f03ba02c4b84f4a9614e832d2\", - \"libflux/flux-core/src/parser/tests.rs\": \"e3a7c9222f90323a7ea9b319bd84f96f66c6f115af6d199a0da332c894713ae4\", + \"libflux/flux-core/src/parser/tests.rs\": \"43a1e5d3de85d76da2107544e417f583a1f66c20910286285b9645a309c42425\", \"libflux/flux-core/src/scanner/mod.rs\": \"2e15c9e0a73d0936d2eaeec030b636786db6dbe7aab673045de3a3e815c49f8a\", \"libflux/flux-core/src/scanner/scanner.rl\": \"530c062363b66daded3c521af44111b99ffee0eeb2a12ccffa8b8f349002d852\", \"libflux/flux-core/src/scanner/scanner_generated.rs\": \"d65dcc216ccbb88d8f2e261a994ba2789075e434cb7a0f5e39e390bee2821e5b\",", "text": "Does this file actually need to be committed to git? Having to run `make generate` is rather tedious on each PR and it conflicts easily.", "function_tokens": ["@@", "\u0120-", "22", ",", "16", "\u0120+", "22", ",", "16", "\u0120@@", "\u0120var", "\u0120source", "H", "ashes", "\u0120=", "\u0120map", "[", "string", "]", "string", "{", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "flat", "buff", "ers", "/", "mod", ".", "rs", "\":", "\u0120\"", "00", "c", "75", "dc", "1", "da", "14", "48", "79", "53", "a", "4", "a", "01", "76", "16", "fb", "8", "a", "237", "fe", "3", "da", "437", "c", "8", "76", "f", "13", "285", "32", "dd", "79", "06", "f", "015", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "flat", "buff", "ers", "/", "mon", "otype", ".", "rs", "\":", "\u0120\"", "4", "e", "82", "a", "ae", "8", "e", "7", "ed", "b", "8", "e", "230", "302", "241", "fe", "702", "e", "ce", "9", "ae", "84", "fc", "70", "800", "3", "c", "24", "709", "c", "2", "ea", "9", "44", "cf", "a", "ae", "8", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "flat", "buff", "ers", "/", "tests", ".", "rs", "\":", "\u0120\"", "ea", "85", "b", "780", "49", "f", "0", "c", "3", "d", "79", "da", "ed", "cf", "9", "e", "171", "cc", "b", "00", "d", "0", "a", "596", "d", "1", "a", "643", "aa", "218", "590", "c", "99", "e", "6", "b", "160", "bc", "\",", "\u0120-", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "mod", ".", "rs", "\":", "\u0120\"", "676", "e", "22", "d", "24", "cd", "7", "a", "975", "25", "688", "ed", "391", "a", "980", "d", "08", "b", "4", "bee", "40", "c", "5", "b", "50", "67", "d", "187", "f", "3", "ae", "6", "d", "66", "210", "ca", "\",", "\u0120+", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "mod", ".", "rs", "\":", "\u0120\"", "29", "b", "25", "b", "75", "a", "01", "cf", "1", "e", "1", "ac", "2", "b", "52", "d", "99", "b", "9", "1986", "ce", "c", "3", "2011", "dc", "55", "af", "1", "ff", "d", "7", "f", "14", "58", "38", "f", "ce", "8", "58", "d", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "tests", ".", "rs", "\":", "\u0120\"", "bc", "7", "f", "77", "d", "5", "69", "d", "8", "bb", "d", "4", "b", "9", "d", "00", "653", "f", "48", "b", "ac", "d", "47", "eed", "46", "f", "530", "24", "d", "ce", "8", "36", "d", "3", "c", "8", "bb", "b", "6", "a", "80", "555", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "walk", "/", "mod", ".", "rs", "\":", "\u0120\"", "e", "8", "a", "030", "23", "d", "74", "26", "b", "cf", "6", "df", "db", "1", "a", "61", "ac", "3", "263", "f", "5", "cf", "9", "194", "a", "595", "a", "15", "84", "d", "ff", "7", "c", "899", "d", "0", "65", "62", "f", "1", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "ast", "/", "walk", "/", "tests", ".", "rs", "\":", "\u0120\"", "f", "7", "b", "2", "d", "7", "dd", "5", "643", "bb", "795", "a", "86", "c", "04", "b", "69", "79", "b", "136", "b", "0", "de", "46", "b", "52", "b", "213", "c", "aff", "09", "4", "aed", "6", "d", "204", "a", "05", "d", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "form", "atter", "/", "mod", ".", "rs", "\":", "\u0120\"", "9", "457", "36", "a", "4", "ad", "87", "ad", "b", "6", "a", "3", "f", "359", "b", "6", "f", "2", "da", "6", "e", "5", "492", "b", "3", "cb", "0", "ef", "d", "282", "e", "277", "303", "e", "2", "ac", "ae", "13", "77", "63", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "form", "atter", "/", "tests", ".", "rs", "\":", "\u0120\"", "b", "0", "a", "10", "998", "a", "65", "fc", "4", "b", "54", "a", "8", "f", "68", "b", "3", "a", "0", "ed", "186", "d", "85", "48", "ba", "3", "d", "76", "38", "f", "911", "eb", "188", "d", "2", "ce", "485", "206", "f", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "lib", ".", "rs", "\":", "\u0120\"", "d", "19", "b", "70", "54", "e", "07", "f", "234", "c", "107", "d", "45", "70", "30", "a", "003", "13", "74", "c", "123", "fe", "14", "a", "84", "a", "5", "b", "8", "e", "355", "37", "d", "138", "b", "ac", "7", "a", "\",", "\u0120-", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "parser", "/", "mod", ".", "rs", "\":", "\u0120\"", "e", "3", "f", "11", "fe", "29", "f", "47", "271", "b", "5", "c", "04", "ac", "cc", "2", "d", "7", "ef", "a", "35", "e", "1", "dc", "62", "c", "6", "de", "036", "bf", "0", "cc", "0", "cc", "c", "da", "5", "e", "47", "42", "e", "8", "\",", "\u0120+", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "parser", "/", "mod", ".", "rs", "\":", "\u0120\"", "d", "af", "24", "b", "2", "c", "439", "f", "4", "c", "7", "a", "6", "f", "138", "e", "2", "b", "250", "64", "a", "205", "a", "ee", "73", "bb", "6", "c", "ff", "c", "8", "98", "df", "22", "dd", "0", "c", "96", "2", "ca", "5", "df", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "parser", "/", "str", "conv", ".", "rs", "\":", "\u0120\"", "748", "c", "82", "f", "6", "ef", "c", "2", "e", "afa", "af", "b", "8", "72", "db", "5", "b", "4", "185", "ce", "29", "a", "afa", "8", "f", "03", "ba", "02", "c", "4", "b", "84", "f", "4", "a", "96", "14", "e", "8", "32", "d", "2", "\",", "\u0120-", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "parser", "/", "tests", ".", "rs", "\":", "\u0120\"", "e", "3", "a", "7", "c", "9", "222", "f", "9", "03", "23", "a", "7", "ea", "9", "b", "319", "bd", "84", "f", "96", "f", "66", "c", "6", "f", "115", "af", "6", "d", "199", "a", "0", "da", "332", "c", "89", "47", "13", "ae", "4", "\",", "\u0120+", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "parser", "/", "tests", ".", "rs", "\":", "\u0120\"", "43", "a", "1", "e", "5", "d", "3", "de", "85", "d", "76", "da", "210", "75", "44", "e", "417", "f", "583", "a", "1", "f", "66", "c", "209", "10", "286", "285", "b", "96", "45", "a", "309", "c", "424", "25", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "scan", "ner", "/", "mod", ".", "rs", "\":", "\u0120\"", "2", "e", "15", "c", "9", "e", "0", "a", "73", "d", "09", "36", "d", "2", "e", "ae", "ec", "030", "b", "6", "36", "786", "db", "6", "d", "be", "7", "a", "ab", "67", "30", "45", "de", "3", "a", "3", "e", "815", "c", "49", "f", "8", "a", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "scan", "ner", "/", "scan", "ner", ".", "rl", "\":", "\u0120\"", "530", "c", "06", "23", "63", "b", "66", "d", "aded", "3", "c", "5", "21", "af", "44", "111", "b", "99", "ffee", "0", "ee", "b", "2", "a", "12", "cc", "ff", "a", "8", "b", "8", "f", "34", "900", "2", "d", "8", "52", "\",", "\u0120\"", "lib", "f", "lux", "/", "f", "lux", "-", "core", "/", "src", "/", "scan", "ner", "/", "scan", "ner", "_", "generated", ".", "rs", "\":", "\u0120\"", "d", "65", "d", "cc", "216", "cc", "bb", "88", "d", "8", "f", "2", "e", "261", "a", "994", "ba", "278", "90", "75", "e", "434", "cb", "7", "a", "0", "f", "5", "e", "39", "e", "390", "bee", "28", "21", "e", "5", "b", "\","], "docstring_tokens": ["Does", "\u0120this", "\u0120file", "\u0120actually", "\u0120need", "\u0120to", "\u0120be", "\u0120committed", "\u0120to", "\u0120git", "?", "\u0120Having", "\u0120to", "\u0120run", "\u0120`", "make", "\u0120generate", "`", "\u0120is", "\u0120rather", "\u0120tedious", "\u0120on", "\u0120each", "\u0120PR", "\u0120and", "\u0120it", "\u0120conflicts", "\u0120easily", "."]}
{"function": "@@ -440,18 +440,6 @@ func parseConfig(loc location.Location, opts options.Options) (interface{}, erro cfg.ProjectID = os.Getenv(\"GOOGLE_PROJECT_ID\") } - if cfg.JSONKeyPath == \"\" { - if path := os.Getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"); path != \"\" { - // Check read access - if _, err := ioutil.ReadFile(path); err != nil { - return nil, errors.Fatalf(\"Failed to read google credential from file %v: %v\", path, err) - } - cfg.JSONKeyPath = path - } else { - return nil, errors.Fatal(\"No credential file path is set\") - } - } - if err := opts.Apply(loc.Scheme, &cfg); err != nil { return nil, err }", "text": "We don't need this anymore, as Google's library handles various auth mechanisms for us. We'll be less explicit about why we're failing but we gain support for several authentication methods- swings and roundabouts!", "function_tokens": ["@@", "\u0120-", "440", ",", "18", "\u0120+", "440", ",", "6", "\u0120@@", "\u0120func", "\u0120parse", "Config", "(", "loc", "\u0120location", ".", "Location", ",", "\u0120opt", "s", "\u0120options", ".", "Options", ")", "\u0120(", "interface", "{", "},", "\u0120er", "ro", "\u0120cf", "g", ".", "Project", "ID", "\u0120=", "\u0120os", ".", "Get", "env", "(\"", "G", "OO", "G", "LE", "_", "PRO", "JECT", "_", "ID", "\")", "\u0120}", "\u0120-", "\u0120if", "\u0120cf", "g", ".", "JSON", "Key", "Path", "\u0120==", "\u0120\"\"", "\u0120{", "\u0120-", "\u0120if", "\u0120path", "\u0120:=", "\u0120os", ".", "Get", "env", "(\"", "G", "OO", "G", "LE", "_", "AP", "PLIC", "ATION", "_", "CR", "ED", "ENT", "IAL", "S", "\");", "\u0120path", "\u0120!=", "\u0120\"\"", "\u0120{", "\u0120-", "\u0120//", "\u0120Check", "\u0120read", "\u0120access", "\u0120-", "\u0120if", "\u0120_", ",", "\u0120err", "\u0120:=", "\u0120i", "out", "il", ".", "Read", "File", "(", "path", ");", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120-", "\u0120return", "\u0120nil", ",", "\u0120errors", ".", "Fat", "alf", "(\"", "F", "ailed", "\u0120to", "\u0120read", "\u0120google", "\u0120credential", "\u0120from", "\u0120file", "\u0120%", "v", ":", "\u0120%", "v", "\",", "\u0120path", ",", "\u0120err", ")", "\u0120-", "\u0120}", "\u0120-", "\u0120cf", "g", ".", "JSON", "Key", "Path", "\u0120=", "\u0120path", "\u0120-", "\u0120}", "\u0120else", "\u0120{", "\u0120-", "\u0120return", "\u0120nil", ",", "\u0120errors", ".", "F", "atal", "(\"", "No", "\u0120credential", "\u0120file", "\u0120path", "\u0120is", "\u0120set", "\")", "\u0120-", "\u0120}", "\u0120-", "\u0120}", "\u0120-", "\u0120if", "\u0120err", "\u0120:=", "\u0120opt", "s", ".", "Apply", "(", "loc", ".", "Sche", "me", ",", "\u0120&", "cfg", ");", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120return", "\u0120nil", ",", "\u0120err", "\u0120}"], "docstring_tokens": ["We", "\u0120don", "'t", "\u0120need", "\u0120this", "\u0120anymore", ",", "\u0120as", "\u0120Google", "'s", "\u0120library", "\u0120handles", "\u0120various", "\u0120auth", "\u0120mechanisms", "\u0120for", "\u0120us", ".", "\u0120We", "'ll", "\u0120be", "\u0120less", "\u0120explicit", "\u0120about", "\u0120why", "\u0120we", "'re", "\u0120failing", "\u0120but", "\u0120we", "\u0120gain", "\u0120support", "\u0120for", "\u0120several", "\u0120authentication", "\u0120methods", "-", "\u0120swings", "\u0120and", "\u0120round", "abouts", "!"]}
{"function": "@@ -1,11 +1,12 @@ package plugin type Config struct { - SocketPath string `yaml:\"path\"` - Volumes VolumesConfig `yaml:\"volume\"` + SocketDir string `yaml:\"socket_dir\" default:\"/run/docker/plugins\"` + Volumes VolumesConfig `yaml:\"volume\"` + GPUs map[string]map[string]string `yaml:\"GPUs\"` } type VolumesConfig struct { - Root string + Root string `yaml:\"root\" default:\"/var/lib/docker-volumes\"` Volumes map[string]map[string]string }", "text": "No need to speficy attribute here. Moreover in yaml it is default to use lowercase names.", "function_tokens": ["@@", "\u0120-", "1", ",", "11", "\u0120+", "1", ",", "12", "\u0120@@", "\u0120package", "\u0120plugin", "\u0120type", "\u0120Config", "\u0120struct", "\u0120{", "\u0120-", "\u0120Socket", "Path", "\u0120string", "\u0120`", "y", "aml", ":\"", "path", "\"", "`", "\u0120-", "\u0120Vol", "umes", "\u0120Vol", "umes", "Config", "\u0120`", "y", "aml", ":\"", "volume", "\"", "`", "\u0120+", "\u0120Socket", "Dir", "\u0120string", "\u0120`", "y", "aml", ":\"", "socket", "_", "dir", "\"", "\u0120default", ":\"", "/", "run", "/", "docker", "/", "plugins", "\"", "`", "\u0120+", "\u0120Vol", "umes", "\u0120Vol", "umes", "Config", "\u0120`", "y", "aml", ":\"", "volume", "\"", "`", "\u0120+", "\u0120GPUs", "\u0120map", "[", "string", "]", "map", "[", "string", "]", "string", "\u0120`", "y", "aml", ":\"", "GPU", "s", "\"", "`", "\u0120}", "\u0120type", "\u0120Vol", "umes", "Config", "\u0120struct", "\u0120{", "\u0120-", "\u0120Root", "\u0120string", "\u0120+", "\u0120Root", "\u0120string", "\u0120`", "y", "aml", ":\"", "root", "\"", "\u0120default", ":\"", "/", "var", "/", "lib", "/", "docker", "-", "vol", "umes", "\"", "`", "\u0120Vol", "umes", "\u0120map", "[", "string", "]", "map", "[", "string", "]", "string", "\u0120}"], "docstring_tokens": ["No", "\u0120need", "\u0120to", "\u0120spe", "f", "icy", "\u0120attribute", "\u0120here", ".", "\u0120Moreover", "\u0120in", "\u0120y", "aml", "\u0120it", "\u0120is", "\u0120default", "\u0120to", "\u0120use", "\u0120lower", "case", "\u0120names", "."]}
{"function": "@@ -8,10 +8,12 @@ using System; using System.Collections.Generic; using System.Globalization; using System.IO; +using System.Linq; using System.Net; using System.Net.Http; using System.Text; using System.Threading; +using System.Threading.Tasks; using Task = System.Threading.Tasks.Task; namespace Microsoft.DotNet.Build.CloudTestTasks", "text": "In general I'm a trying to understand the reason behind this PR. Looks like if a blob (name) already exists we check if the contents are identical? In what scenarios this is not the case? When we want to publish a package/asset that has changed but still we want to use the same version?", "function_tokens": ["@@", "\u0120-", "8", ",", "10", "\u0120+", "8", ",", "12", "\u0120@@", "\u0120using", "\u0120System", ";", "\u0120using", "\u0120System", ".", "Col", "lections", ".", "Generic", ";", "\u0120using", "\u0120System", ".", "Global", "ization", ";", "\u0120using", "\u0120System", ".", "IO", ";", "\u0120+", "using", "\u0120System", ".", "Lin", "q", ";", "\u0120using", "\u0120System", ".", "Net", ";", "\u0120using", "\u0120System", ".", "Net", ".", "Http", ";", "\u0120using", "\u0120System", ".", "Text", ";", "\u0120using", "\u0120System", ".", "Thread", "ing", ";", "\u0120+", "using", "\u0120System", ".", "Thread", "ing", ".", "T", "asks", ";", "\u0120using", "\u0120Task", "\u0120=", "\u0120System", ".", "Thread", "ing", ".", "T", "asks", ".", "Task", ";", "\u0120namespace", "\u0120Microsoft", ".", "D", "ot", "Net", ".", "Build", ".", "Cloud", "Test", "T", "asks"], "docstring_tokens": ["In", "\u0120general", "\u0120I", "'m", "\u0120a", "\u0120trying", "\u0120to", "\u0120understand", "\u0120the", "\u0120reason", "\u0120behind", "\u0120this", "\u0120PR", ".", "\u0120Looks", "\u0120like", "\u0120if", "\u0120a", "\u0120blob", "\u0120(", "name", ")", "\u0120already", "\u0120exists", "\u0120we", "\u0120check", "\u0120if", "\u0120the", "\u0120contents", "\u0120are", "\u0120identical", "?", "\u0120In", "\u0120what", "\u0120scenarios", "\u0120this", "\u0120is", "\u0120not", "\u0120the", "\u0120case", "?", "\u0120When", "\u0120we", "\u0120want", "\u0120to", "\u0120publish", "\u0120a", "\u0120package", "/", "ass", "et", "\u0120that", "\u0120has", "\u0120changed", "\u0120but", "\u0120still", "\u0120we", "\u0120want", "\u0120to", "\u0120use", "\u0120the", "\u0120same", "\u0120version", "?"]}
{"function": "@@ -151,7 +151,9 @@ class BlacklistRuleBook(bre.BaseRuleBook): lists: first one is IP addresses, second one is network blocks \"\"\" - data = urllib2.urlopen(url).read() + req = urllib2.build_opener() + req.addheaders = [('User-Agent', 'Forseti blacklist rules engine agent')] + data = req.open(url).read() ip_addresses = re.findall(r'^[0-9]+(?:\\.[0-9]+){3}$', data, re.M) netblocks = re.findall(r'^[0-9]+(?:\\.[0-9]+){0,3}/[0-9]{1,2}$', data, re.M)", "text": "Can rename `req` to be `opener`, since that is the object, and it wraps `req` internally?", "function_tokens": ["@@", "\u0120-", "151", ",", "7", "\u0120+", "151", ",", "9", "\u0120@@", "\u0120class", "\u0120Black", "list", "Rule", "Book", "(", "bre", ".", "Base", "Rule", "Book", "):", "\u0120lists", ":", "\u0120first", "\u0120one", "\u0120is", "\u0120IP", "\u0120addresses", ",", "\u0120second", "\u0120one", "\u0120is", "\u0120network", "\u0120blocks", "\u0120\"\"\"", "\u0120-", "\u0120data", "\u0120=", "\u0120ur", "ll", "ib", "2", ".", "url", "open", "(", "url", ").", "read", "()", "\u0120+", "\u0120req", "\u0120=", "\u0120ur", "ll", "ib", "2", ".", "build", "_", "op", "ener", "()", "\u0120+", "\u0120req", ".", "add", "headers", "\u0120=", "\u0120[", "('", "User", "-", "Agent", "',", "\u0120'", "F", "orset", "i", "\u0120blacklist", "\u0120rules", "\u0120engine", "\u0120agent", "')", "]", "\u0120+", "\u0120data", "\u0120=", "\u0120req", ".", "open", "(", "url", ").", "read", "()", "\u0120ip", "_", "add", "resses", "\u0120=", "\u0120re", ".", "find", "all", "(", "r", "'", "^", "[", "0", "-", "9", "]", "+(", "?", ":\\", ".[", "0", "-", "9", "]+", "){", "3", "}", "$", "',", "\u0120data", ",", "\u0120re", ".", "M", ")", "\u0120net", "blocks", "\u0120=", "\u0120re", ".", "find", "all", "(", "r", "'", "^", "[", "0", "-", "9", "]", "+(", "?", ":\\", ".[", "0", "-", "9", "]+", "){", "0", ",", "3", "}", "/", "[", "0", "-", "9", "]", "{", "1", ",", "2", "}", "$", "',", "\u0120data", ",", "\u0120re", ".", "M", ")"], "docstring_tokens": ["Can", "\u0120rename", "\u0120`", "req", "`", "\u0120to", "\u0120be", "\u0120`", "op", "ener", "`,", "\u0120since", "\u0120that", "\u0120is", "\u0120the", "\u0120object", ",", "\u0120and", "\u0120it", "\u0120wraps", "\u0120`", "req", "`", "\u0120internally", "?"]}
{"function": "@@ -1405,6 +1405,8 @@ def getFormatFieldSpeech(attrs,attrsCache=None,formatConfig=None,unit=None,extra linePrefix=attrs.get(\"line-prefix\") if linePrefix: textList.append(linePrefix) + breakpoint=attrs.get(\"breakpoint\") + if breakpoint: textList.append(breakpoint) if attrsCache is not None: attrsCache.clear() attrsCache.update(attrs)", "text": "@MichaelDCurran, thoughts on adding a breakpoint format field attribute? It seems almost app specific, but I guess it does seem odd abusing line-prefix. Is there any more generic concept here?", "function_tokens": ["@@", "\u0120-", "14", "05", ",", "6", "\u0120+", "14", "05", ",", "8", "\u0120@@", "\u0120def", "\u0120get", "Format", "Field", "Spe", "ech", "(", "att", "rs", ",", "att", "rs", "Cache", "=", "None", ",", "format", "Config", "=", "None", ",", "unit", "=", "None", ",", "extra", "\u0120line", "Pref", "ix", "=", "att", "rs", ".", "get", "(\"", "line", "-", "prefix", "\")", "\u0120if", "\u0120line", "Pref", "ix", ":", "\u0120text", "List", ".", "append", "(", "line", "Pref", "ix", ")", "\u0120+", "\u0120break", "point", "=", "att", "rs", ".", "get", "(\"", "break", "point", "\")", "\u0120+", "\u0120if", "\u0120break", "point", ":", "\u0120text", "List", ".", "append", "(", "break", "point", ")", "\u0120if", "\u0120att", "rs", "Cache", "\u0120is", "\u0120not", "\u0120None", ":", "\u0120att", "rs", "Cache", ".", "clear", "()", "\u0120att", "rs", "Cache", ".", "update", "(", "att", "rs", ")"], "docstring_tokens": ["@", "Michael", "DC", "ur", "ran", ",", "\u0120thoughts", "\u0120on", "\u0120adding", "\u0120a", "\u0120break", "point", "\u0120format", "\u0120field", "\u0120attribute", "?", "\u0120It", "\u0120seems", "\u0120almost", "\u0120app", "\u0120specific", ",", "\u0120but", "\u0120I", "\u0120guess", "\u0120it", "\u0120does", "\u0120seem", "\u0120odd", "\u0120abusing", "\u0120line", "-", "prefix", ".", "\u0120Is", "\u0120there", "\u0120any", "\u0120more", "\u0120generic", "\u0120concept", "\u0120here", "?"]}
{"function": "@@ -539,7 +539,10 @@ class WebElement(object): @property def rect(self): \"\"\"A dictionary with the size and location of the element.\"\"\" - return self._execute(Command.GET_ELEMENT_RECT)['value'] + if self._w3c: + return self._execute(Command.GET_ELEMENT_RECT)['value'] + else: + return self.size, self.location @property def screenshot_as_base64(self):", "text": "This would return a tuple of two dictionaries. You need to combine them and return a dictionary", "function_tokens": ["@@", "\u0120-", "5", "39", ",", "7", "\u0120+", "5", "39", ",", "10", "\u0120@@", "\u0120class", "\u0120Web", "Element", "(", "object", "):", "\u0120@", "property", "\u0120def", "\u0120rect", "(", "self", "):", "\u0120\"\"\"", "A", "\u0120dictionary", "\u0120with", "\u0120the", "\u0120size", "\u0120and", "\u0120location", "\u0120of", "\u0120the", "\u0120element", ".\"", "\"\"", "\u0120-", "\u0120return", "\u0120self", "._", "execute", "(", "Command", ".", "GET", "_", "E", "LE", "MENT", "_", "RECT", ")", "['", "value", "']", "\u0120+", "\u0120if", "\u0120self", "._", "w", "3", "c", ":", "\u0120+", "\u0120return", "\u0120self", "._", "execute", "(", "Command", ".", "GET", "_", "E", "LE", "MENT", "_", "RECT", ")", "['", "value", "']", "\u0120+", "\u0120else", ":", "\u0120+", "\u0120return", "\u0120self", ".", "size", ",", "\u0120self", ".", "location", "\u0120@", "property", "\u0120def", "\u0120screenshot", "_", "as", "_", "base", "64", "(", "self", "):"], "docstring_tokens": ["This", "\u0120would", "\u0120return", "\u0120a", "\u0120tuple", "\u0120of", "\u0120two", "\u0120diction", "aries", ".", "\u0120You", "\u0120need", "\u0120to", "\u0120combine", "\u0120them", "\u0120and", "\u0120return", "\u0120a", "\u0120dictionary"]}
{"function": "@@ -7,10 +7,14 @@ import ( \"errors\" \"fmt\" + \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/archer\" + \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/manifest\" + \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/store/secretsmanager\" \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/store/ssm\" \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/term/color\" \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/term/log\" \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/term/prompt\" + \"github.com/aws/amazon-ecs-cli-v2/internal/pkg/workspace\" \"github.com/spf13/cobra\" )", "text": "What do you think of moving the example to the help text of the prompt? and the prompt itself can be \"What is your application's GitHub repository URL?\"", "function_tokens": ["@@", "\u0120-", "7", ",", "10", "\u0120+", "7", ",", "14", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "errors", "\"", "\u0120\"", "f", "mt", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "ar", "cher", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "man", "ifest", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "store", "/", "sec", "rets", "manager", "\"", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "store", "/", "ss", "m", "\"", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "term", "/", "color", "\"", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "term", "/", "log", "\"", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "term", "/", "prom", "pt", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "aws", "/", "amazon", "-", "ec", "s", "-", "cli", "-", "v", "2", "/", "internal", "/", "pkg", "/", "works", "pace", "\"", "\u0120\"", "github", ".", "com", "/", "sp", "f", "13", "/", "c", "ob", "ra", "\"", "\u0120)"], "docstring_tokens": ["What", "\u0120do", "\u0120you", "\u0120think", "\u0120of", "\u0120moving", "\u0120the", "\u0120example", "\u0120to", "\u0120the", "\u0120help", "\u0120text", "\u0120of", "\u0120the", "\u0120prompt", "?", "\u0120and", "\u0120the", "\u0120prompt", "\u0120itself", "\u0120can", "\u0120be", "\u0120\"", "What", "\u0120is", "\u0120your", "\u0120application", "'s", "\u0120GitHub", "\u0120repository", "\u0120URL", "?\""]}
{"function": "@@ -58,9 +58,12 @@ public class TracerTest { public void shouldBeAbleToCreateATracer() { List<SpanData> allSpans = new ArrayList<>(); Tracer tracer = createTracer(allSpans); + long timeStamp = 1593493828L; try (Span span = tracer.getCurrentContext().createSpan(\"parent\")) { span.setAttribute(\"cheese\", \"gouda\"); + span.addEvent(\"Grating cheese\"); + span.addEvent(\"Melting cheese\", timeStamp); span.setStatus(Status.NOT_FOUND); } ", "text": "Break out tests for events into their own tests rather than placing them in other ones. That makes it easier for us to figure out where problems lie and to do a TDD-driven implementation over new APIs.", "function_tokens": ["@@", "\u0120-", "58", ",", "9", "\u0120+", "58", ",", "12", "\u0120@@", "\u0120public", "\u0120class", "\u0120Tr", "acer", "Test", "\u0120{", "\u0120public", "\u0120void", "\u0120should", "Be", "A", "ble", "To", "Create", "AT", "rac", "er", "()", "\u0120{", "\u0120List", "<", "Sp", "an", "Data", ">", "\u0120all", "Sp", "ans", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120Tr", "acer", "\u0120tr", "acer", "\u0120=", "\u0120create", "Tr", "acer", "(", "all", "Sp", "ans", ");", "\u0120+", "\u0120long", "\u0120time", "St", "amp", "\u0120=", "\u0120159", "349", "38", "28", "L", ";", "\u0120try", "\u0120(", "Sp", "an", "\u0120span", "\u0120=", "\u0120tr", "acer", ".", "get", "Current", "Context", "().", "create", "Sp", "an", "(\"", "parent", "\"))", "\u0120{", "\u0120span", ".", "set", "Attribute", "(\"", "che", "ese", "\",", "\u0120\"", "g", "oud", "a", "\");", "\u0120+", "\u0120span", ".", "add", "Event", "(\"", "Gr", "ating", "\u0120cheese", "\");", "\u0120+", "\u0120span", ".", "add", "Event", "(\"", "Mel", "ting", "\u0120cheese", "\",", "\u0120time", "St", "amp", ");", "\u0120span", ".", "set", "Status", "(", "Status", ".", "NOT", "_", "F", "OUND", ");", "\u0120}", "\u0120"], "docstring_tokens": ["Break", "\u0120out", "\u0120tests", "\u0120for", "\u0120events", "\u0120into", "\u0120their", "\u0120own", "\u0120tests", "\u0120rather", "\u0120than", "\u0120placing", "\u0120them", "\u0120in", "\u0120other", "\u0120ones", ".", "\u0120That", "\u0120makes", "\u0120it", "\u0120easier", "\u0120for", "\u0120us", "\u0120to", "\u0120figure", "\u0120out", "\u0120where", "\u0120problems", "\u0120lie", "\u0120and", "\u0120to", "\u0120do", "\u0120a", "\u0120TD", "D", "-", "driven", "\u0120implementation", "\u0120over", "\u0120new", "\u0120APIs", "."]}
{"function": "@@ -266,7 +266,7 @@ bool parse_it(Iterator &first, Iterator last, RDKit::RWMol &mol) { } else { if (!parse_atom_labels(first, last, mol)) return false; } - } else if ((first + 9) < last && + } else if (std::distance(first, last) > 9 && std::string(first, first + 9) == \"atomProp:\") { first += 9; if (!parse_atom_props(first, last, mol)) return false;", "text": "Nice use of std::distance. I'm a bit worried about first += 9 though.", "function_tokens": ["@@", "\u0120-", "266", ",", "7", "\u0120+", "266", ",", "7", "\u0120@@", "\u0120bool", "\u0120parse", "_", "it", "(", "Iterator", "\u0120&", "first", ",", "\u0120Iter", "ator", "\u0120last", ",", "\u0120RD", "Kit", "::", "R", "WM", "ol", "\u0120&", "mol", ")", "\u0120{", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(!", "parse", "_", "atom", "_", "lab", "els", "(", "first", ",", "\u0120last", ",", "\u0120mol", "))", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120-", "\u0120}", "\u0120else", "\u0120if", "\u0120((", "first", "\u0120+", "\u01209", ")", "\u0120<", "\u0120last", "\u0120&&", "\u0120+", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "std", "::", "distance", "(", "first", ",", "\u0120last", ")", "\u0120>", "\u01209", "\u0120&&", "\u0120std", "::", "string", "(", "first", ",", "\u0120first", "\u0120+", "\u01209", ")", "\u0120==", "\u0120\"", "atom", "Prop", ":", "\")", "\u0120{", "\u0120first", "\u0120+=", "\u01209", ";", "\u0120if", "\u0120(!", "parse", "_", "atom", "_", "pro", "ps", "(", "first", ",", "\u0120last", ",", "\u0120mol", "))", "\u0120return", "\u0120false", ";"], "docstring_tokens": ["Nice", "\u0120use", "\u0120of", "\u0120std", "::", "distance", ".", "\u0120I", "'m", "\u0120a", "\u0120bit", "\u0120worried", "\u0120about", "\u0120first", "\u0120+=", "\u01209", "\u0120though", "."]}
{"function": "@@ -578,8 +578,9 @@ func (c *Operator) syncNodeEndpoints(ctx context.Context) error { ObjectMeta: metav1.ObjectMeta{ Name: c.kubeletObjectName, Labels: c.config.Labels.Merge(map[string]string{ - \"k8s-app\": \"kubelet\", - \"app.kubernetes.io/name\": \"kubelet\", + \"k8s-app\": \"kubelet\", + \"app.kubernetes.io/name\": \"kubelet\", + \"app.kubernetes.io/part-of\": \"prometheus-operator\", }), }, Subsets: []v1.EndpointSubset{", "text": "Shouldn't this be `app.kubernetes.io/managed-by` as prometheus-operator manages this resource, but this resource isn't a part of prometheus-operator?", "function_tokens": ["@@", "\u0120-", "578", ",", "8", "\u0120+", "578", ",", "9", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120*", "Oper", "ator", ")", "\u0120sync", "Node", "End", "points", "(", "ctx", "\u0120context", ".", "Context", ")", "\u0120error", "\u0120{", "\u0120Object", "Meta", ":", "\u0120met", "av", "1", ".", "Object", "Meta", "{", "\u0120Name", ":", "\u0120c", ".", "k", "ube", "let", "Object", "Name", ",", "\u0120Lab", "els", ":", "\u0120c", ".", "config", ".", "Lab", "els", ".", "Mer", "ge", "(", "map", "[", "string", "]", "string", "{", "\u0120-", "\u0120\"", "k", "8", "s", "-", "app", "\":", "\u0120\"", "k", "ube", "let", "\",", "\u0120-", "\u0120\"", "app", ".", "k", "uber", "net", "es", ".", "io", "/", "name", "\":", "\u0120\"", "k", "ube", "let", "\",", "\u0120+", "\u0120\"", "k", "8", "s", "-", "app", "\":", "\u0120\"", "k", "ube", "let", "\",", "\u0120+", "\u0120\"", "app", ".", "k", "uber", "net", "es", ".", "io", "/", "name", "\":", "\u0120\"", "k", "ube", "let", "\",", "\u0120+", "\u0120\"", "app", ".", "k", "uber", "net", "es", ".", "io", "/", "part", "-", "of", "\":", "\u0120\"", "prom", "etheus", "-", "operator", "\",", "\u0120}", "),", "\u0120},", "\u0120Sub", "sets", ":", "\u0120[]", "v", "1", ".", "End", "point", "Sub", "set", "{"], "docstring_tokens": ["Should", "n", "'t", "\u0120this", "\u0120be", "\u0120`", "app", ".", "k", "uber", "net", "es", ".", "io", "/", "managed", "-", "by", "`", "\u0120as", "\u0120prom", "etheus", "-", "operator", "\u0120manages", "\u0120this", "\u0120resource", ",", "\u0120but", "\u0120this", "\u0120resource", "\u0120isn", "'t", "\u0120a", "\u0120part", "\u0120of", "\u0120prom", "etheus", "-", "operator", "?"]}
{"function": "@@ -41,8 +41,9 @@ namespace Datadog.Trace.ClrProfiler if (parent != null && parent.Type == SpanTypes.Http && - parent.GetTag(Tags.HttpMethod).Equals(httpMethod, StringComparison.OrdinalIgnoreCase) && - parent.GetTag(Tags.HttpUrl).Equals(UriHelpers.CleanUri(requestUri, removeScheme: false, tryRemoveIds: false), StringComparison.OrdinalIgnoreCase)) + parent.GetTag(Tags.InstrumentationName) != null && + httpMethod.Equals(parent.GetTag(Tags.HttpMethod), StringComparison.OrdinalIgnoreCase) && + UriHelpers.CleanUri(requestUri, removeScheme: false, tryRemoveIds: false).Equals(parent.GetTag(Tags.HttpUrl), StringComparison.OrdinalIgnoreCase)) { // we are already instrumenting this, // don't instrument nested methods that belong to the same stacktrace", "text": "As long as we're being extra-vigilant about NREs, should we check that `httpMethod` and `requestUri` are not null?", "function_tokens": ["@@", "\u0120-", "41", ",", "8", "\u0120+", "41", ",", "9", "\u0120@@", "\u0120namespace", "\u0120Dat", "ad", "og", ".", "Tr", "ace", ".", "Cl", "r", "Prof", "iler", "\u0120if", "\u0120(", "parent", "\u0120!=", "\u0120null", "\u0120&&", "\u0120parent", ".", "Type", "\u0120==", "\u0120Span", "Types", ".", "Http", "\u0120&&", "\u0120-", "\u0120parent", ".", "Get", "Tag", "(", "Tags", ".", "Http", "Method", ").", "Equ", "als", "(", "http", "Method", ",", "\u0120String", "Compar", "ison", ".", "Ord", "inal", "Ign", "ore", "Case", ")", "\u0120&&", "\u0120-", "\u0120parent", ".", "Get", "Tag", "(", "Tags", ".", "Http", "Url", ").", "Equ", "als", "(", "U", "ri", "Hel", "pers", ".", "Clean", "U", "ri", "(", "request", "U", "ri", ",", "\u0120remove", "Sche", "me", ":", "\u0120false", ",", "\u0120try", "Remove", "Id", "s", ":", "\u0120false", "),", "\u0120String", "Compar", "ison", ".", "Ord", "inal", "Ign", "ore", "Case", "))", "\u0120+", "\u0120parent", ".", "Get", "Tag", "(", "Tags", ".", "In", "strument", "ation", "Name", ")", "\u0120!=", "\u0120null", "\u0120&&", "\u0120+", "\u0120http", "Method", ".", "Equ", "als", "(", "parent", ".", "Get", "Tag", "(", "Tags", ".", "Http", "Method", "),", "\u0120String", "Compar", "ison", ".", "Ord", "inal", "Ign", "ore", "Case", ")", "\u0120&&", "\u0120+", "\u0120Uri", "Hel", "pers", ".", "Clean", "U", "ri", "(", "request", "U", "ri", ",", "\u0120remove", "Sche", "me", ":", "\u0120false", ",", "\u0120try", "Remove", "Id", "s", ":", "\u0120false", ").", "Equ", "als", "(", "parent", ".", "Get", "Tag", "(", "Tags", ".", "Http", "Url", "),", "\u0120String", "Compar", "ison", ".", "Ord", "inal", "Ign", "ore", "Case", "))", "\u0120{", "\u0120//", "\u0120we", "\u0120are", "\u0120already", "\u0120instrument", "ing", "\u0120this", ",", "\u0120//", "\u0120don", "'t", "\u0120instrument", "\u0120nested", "\u0120methods", "\u0120that", "\u0120belong", "\u0120to", "\u0120the", "\u0120same", "\u0120stack", "trace"], "docstring_tokens": ["As", "\u0120long", "\u0120as", "\u0120we", "'re", "\u0120being", "\u0120extra", "-", "v", "igil", "ant", "\u0120about", "\u0120N", "RE", "s", ",", "\u0120should", "\u0120we", "\u0120check", "\u0120that", "\u0120`", "http", "Method", "`", "\u0120and", "\u0120`", "request", "U", "ri", "`", "\u0120are", "\u0120not", "\u0120null", "?"]}
{"function": "@@ -19,6 +19,7 @@ import ( \"github.com/iotexproject/iotex-core/cli/ioctl/cmd/node\" \"github.com/iotexproject/iotex-core/cli/ioctl/cmd/update\" \"github.com/iotexproject/iotex-core/cli/ioctl/cmd/version\" + xrc20 \"github.com/iotexproject/iotex-core/cli/ioctl/cmd/xrc20\" ) // RootCmd represents the base command when called without any subcommands", "text": "No need to have `xrc20` alias", "function_tokens": ["@@", "\u0120-", "19", ",", "6", "\u0120+", "19", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "cli", "/", "io", "ctl", "/", "cmd", "/", "node", "\"", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "cli", "/", "io", "ctl", "/", "cmd", "/", "update", "\"", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "cli", "/", "io", "ctl", "/", "cmd", "/", "version", "\"", "\u0120+", "\u0120x", "rc", "20", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "cli", "/", "io", "ctl", "/", "cmd", "/", "x", "rc", "20", "\"", "\u0120)", "\u0120//", "\u0120Root", "Cmd", "\u0120represents", "\u0120the", "\u0120base", "\u0120command", "\u0120when", "\u0120called", "\u0120without", "\u0120any", "\u0120sub", "comm", "ands"], "docstring_tokens": ["No", "\u0120need", "\u0120to", "\u0120have", "\u0120`", "x", "rc", "20", "`", "\u0120alias"]}
{"function": "@@ -172,6 +172,19 @@ def define_environment_cls(pipeline_def): ) +def context_cls_inst(pipeline_def): + check.inst_param(pipeline_def, 'pipeline_def', PipelineDefinition) + pipeline_name = camelcase(pipeline_def.name) + return SystemNamedDict( + name='{pipeline_name}.Context'.format(pipeline_name=pipeline_name), + fields={ + 'context': define_maybe_optional_selector_field( + define_context_context_cls(pipeline_name, pipeline_def.context_definitions) + ) + }, + ).inst() + + def define_expectations_config_cls(name): check.str_param(name, 'name') ", "text": "the naming convention I'm been adopting if `_type` for instances of these classes. So maybe `context_config_type` is a better name for this fn", "function_tokens": ["@@", "\u0120-", "172", ",", "6", "\u0120+", "172", ",", "19", "\u0120@@", "\u0120def", "\u0120define", "_", "environment", "_", "cl", "s", "(", "p", "ip", "eline", "_", "def", "):", "\u0120)", "\u0120+", "def", "\u0120context", "_", "cl", "s", "_", "inst", "(", "p", "ip", "eline", "_", "def", "):", "\u0120+", "\u0120check", ".", "inst", "_", "param", "(", "p", "ip", "eline", "_", "def", ",", "\u0120'", "p", "ip", "eline", "_", "def", "',", "\u0120Pipeline", "Definition", ")", "\u0120+", "\u0120pipeline", "_", "name", "\u0120=", "\u0120camel", "case", "(", "p", "ip", "eline", "_", "def", ".", "name", ")", "\u0120+", "\u0120return", "\u0120System", "N", "amed", "D", "ict", "(", "\u0120+", "\u0120name", "='", "{", "p", "ip", "eline", "_", "name", "}.", "Context", "'.", "format", "(", "p", "ip", "eline", "_", "name", "=", "p", "ip", "eline", "_", "name", "),", "\u0120+", "\u0120fields", "={", "\u0120+", "\u0120'", "context", "':", "\u0120define", "_", "maybe", "_", "optional", "_", "select", "or", "_", "field", "(", "\u0120+", "\u0120define", "_", "context", "_", "context", "_", "cl", "s", "(", "p", "ip", "eline", "_", "name", ",", "\u0120pipeline", "_", "def", ".", "context", "_", "def", "initions", ")", "\u0120+", "\u0120)", "\u0120+", "\u0120},", "\u0120+", "\u0120).", "inst", "()", "\u0120+", "\u0120+", "\u0120def", "\u0120define", "_", "ex", "pect", "ations", "_", "config", "_", "cl", "s", "(", "name", "):", "\u0120check", ".", "str", "_", "param", "(", "name", ",", "\u0120'", "name", "')", "\u0120"], "docstring_tokens": ["the", "\u0120naming", "\u0120convention", "\u0120I", "'m", "\u0120been", "\u0120adopting", "\u0120if", "\u0120`", "_", "type", "`", "\u0120for", "\u0120instances", "\u0120of", "\u0120these", "\u0120classes", ".", "\u0120So", "\u0120maybe", "\u0120`", "context", "_", "config", "_", "type", "`", "\u0120is", "\u0120a", "\u0120better", "\u0120name", "\u0120for", "\u0120this", "\u0120fn"]}
{"function": "@@ -54,6 +54,7 @@ public class BlockMiner<C, M extends AbstractBlockCreator<C>> implements Runnabl private final ProtocolSchedule<C> protocolSchedule; private final Subscribers<MinedBlockObserver> observers; private final AbstractBlockScheduler scheduler; + private Boolean gpuMining = false; public BlockMiner( final Function<BlockHeader, M> blockCreatorFactory,", "text": "Don't call it GPU mining, call it `externalMining`, here and throughout.", "function_tokens": ["@@", "\u0120-", "54", ",", "6", "\u0120+", "54", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Block", "M", "iner", "<", "C", ",", "\u0120M", "\u0120extends", "\u0120Abstract", "Block", "Creat", "or", "<", "C", ">>", "\u0120implements", "\u0120Run", "n", "abl", "\u0120private", "\u0120final", "\u0120Protocol", "Sche", "dule", "<", "C", ">", "\u0120protocol", "Sche", "dule", ";", "\u0120private", "\u0120final", "\u0120Sub", "scrib", "ers", "<", "M", "ined", "Block", "Obs", "erver", ">", "\u0120observers", ";", "\u0120private", "\u0120final", "\u0120Abstract", "Block", "S", "ched", "uler", "\u0120sched", "uler", ";", "\u0120+", "\u0120private", "\u0120Boolean", "\u0120g", "pu", "M", "ining", "\u0120=", "\u0120false", ";", "\u0120public", "\u0120Block", "M", "iner", "(", "\u0120final", "\u0120Function", "<", "Block", "Header", ",", "\u0120M", ">", "\u0120block", "Creat", "or", "Factory", ","], "docstring_tokens": ["Don", "'t", "\u0120call", "\u0120it", "\u0120GPU", "\u0120mining", ",", "\u0120call", "\u0120it", "\u0120`", "external", "M", "ining", "`,", "\u0120here", "\u0120and", "\u0120throughout", "."]}
{"function": "@@ -252,6 +252,15 @@ return [ | folder - a folder prefix for storing all generated files inside. | path - the public path relative to the application base URL, | or you can specify a full URL path. + | + | For the 'media' resource you can also specify: + | + | imageMaxWidth - Resize all media manager image uploads to be + | within this with (in pixels, 0 = ignore) + | imageMaxHeight - Resize all media manager image uploads to be + | within this height (in pixels, 0 = ignore) + | imageQuality - Set this quality to all media manager image uploads + | (1-100) */ 'storage' => [", "text": "`within this with` typo, should be `within this width`", "function_tokens": ["@@", "\u0120-", "252", ",", "6", "\u0120+", "252", ",", "15", "\u0120@@", "\u0120return", "\u0120[", "\u0120|", "\u0120folder", "\u0120-", "\u0120a", "\u0120folder", "\u0120prefix", "\u0120for", "\u0120storing", "\u0120all", "\u0120generated", "\u0120files", "\u0120inside", ".", "\u0120|", "\u0120path", "\u0120-", "\u0120the", "\u0120public", "\u0120path", "\u0120relative", "\u0120to", "\u0120the", "\u0120application", "\u0120base", "\u0120URL", ",", "\u0120|", "\u0120or", "\u0120you", "\u0120can", "\u0120specify", "\u0120a", "\u0120full", "\u0120URL", "\u0120path", ".", "\u0120+", "\u0120|", "\u0120+", "\u0120|", "\u0120For", "\u0120the", "\u0120'", "media", "'", "\u0120resource", "\u0120you", "\u0120can", "\u0120also", "\u0120specify", ":", "\u0120+", "\u0120|", "\u0120+", "\u0120|", "\u0120image", "Max", "Width", "\u0120-", "\u0120Res", "ize", "\u0120all", "\u0120media", "\u0120manager", "\u0120image", "\u0120upload", "s", "\u0120to", "\u0120be", "\u0120+", "\u0120|", "\u0120within", "\u0120this", "\u0120with", "\u0120(", "in", "\u0120pixels", ",", "\u01200", "\u0120=", "\u0120ignore", ")", "\u0120+", "\u0120|", "\u0120image", "Max", "Height", "\u0120-", "\u0120Res", "ize", "\u0120all", "\u0120media", "\u0120manager", "\u0120image", "\u0120upload", "s", "\u0120to", "\u0120be", "\u0120+", "\u0120|", "\u0120within", "\u0120this", "\u0120height", "\u0120(", "in", "\u0120pixels", ",", "\u01200", "\u0120=", "\u0120ignore", ")", "\u0120+", "\u0120|", "\u0120image", "Quality", "\u0120-", "\u0120Set", "\u0120this", "\u0120quality", "\u0120to", "\u0120all", "\u0120media", "\u0120manager", "\u0120image", "\u0120upload", "s", "\u0120+", "\u0120|", "\u0120(", "1", "-", "100", ")", "\u0120*/", "\u0120'", "storage", "'", "\u0120=>", "\u0120["], "docstring_tokens": ["`", "within", "\u0120this", "\u0120with", "`", "\u0120typo", ",", "\u0120should", "\u0120be", "\u0120`", "within", "\u0120this", "\u0120width", "`"]}
{"function": "@@ -22,10 +22,12 @@ import ( ) // Prometheus defines a Prometheus deployment. +// +k8s:openapi-gen=true type Prometheus struct { metav1.TypeMeta `json:\",inline\"` // Standard object\u2019s metadata. More info: // https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata + // +k8s:openapi-gen=false metav1.ObjectMeta `json:\"metadata,omitempty\"` // Specification of the desired behavior of the Prometheus cluster. More info: // https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status", "text": "how come this is false?", "function_tokens": ["@@", "\u0120-", "22", ",", "10", "\u0120+", "22", ",", "12", "\u0120@@", "\u0120import", "\u0120(", "\u0120)", "\u0120//", "\u0120Prometheus", "\u0120defines", "\u0120a", "\u0120Prometheus", "\u0120deployment", ".", "\u0120+", "//", "\u0120+", "k", "8", "s", ":", "open", "api", "-", "gen", "=", "true", "\u0120type", "\u0120Prometheus", "\u0120struct", "\u0120{", "\u0120met", "av", "1", ".", "Type", "Meta", "\u0120`", "json", ":", "\",", "inline", "\"", "`", "\u0120//", "\u0120Standard", "\u0120object", "\u00e2\u0122", "\u013b", "s", "\u0120metadata", ".", "\u0120More", "\u0120info", ":", "\u0120//", "\u0120https", "://", "github", ".", "com", "/", "k", "uber", "net", "es", "/", "community", "/", "bl", "ob", "/", "master", "/", "cont", "ribut", "ors", "/", "de", "vel", "/", "api", "-", "con", "ventions", ".", "md", "#", "metadata", "\u0120+", "\u0120//", "\u0120+", "k", "8", "s", ":", "open", "api", "-", "gen", "=", "false", "\u0120met", "av", "1", ".", "Object", "Meta", "\u0120`", "json", ":\"", "metadata", ",", "om", "it", "empty", "\"", "`", "\u0120//", "\u0120Spec", "ification", "\u0120of", "\u0120the", "\u0120desired", "\u0120behavior", "\u0120of", "\u0120the", "\u0120Prometheus", "\u0120cluster", ".", "\u0120More", "\u0120info", ":", "\u0120//", "\u0120https", "://", "github", ".", "com", "/", "k", "uber", "net", "es", "/", "community", "/", "bl", "ob", "/", "master", "/", "cont", "ribut", "ors", "/", "de", "vel", "/", "api", "-", "con", "ventions", ".", "md", "#", "spec", "-", "and", "-", "status"], "docstring_tokens": ["how", "\u0120come", "\u0120this", "\u0120is", "\u0120false", "?"]}
{"function": "@@ -24,6 +24,19 @@ function node_require(module) { return require(module); } +function typeOf(obj) { + return ({}).toString.call(obj).match(/\\s(\\w+)/)[1].toLowerCase(); +} + +function checkTypes(args, types) { + args = [].slice.call(args); + for (var i = 0; i < types.length; ++i) { + if (typeOf(args[i]) !== types[i]) { + throw new TypeError('param ' + i + ' must be of type ' + types[i]); + } + } +} + const performFetch = typeof fetch === 'undefined' ? node_require('node-fetch') : fetch; const url_parse = require('url-parse');", "text": "How about `Object.prototype.toString`? Or using the `typeof` operator?", "function_tokens": ["@@", "\u0120-", "24", ",", "6", "\u0120+", "24", ",", "19", "\u0120@@", "\u0120function", "\u0120node", "_", "require", "(", "module", ")", "\u0120{", "\u0120return", "\u0120require", "(", "module", ");", "\u0120}", "\u0120+", "function", "\u0120type", "Of", "(", "obj", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120({", "}", ").", "to", "String", ".", "call", "(", "obj", ").", "match", "(", "/", "\\", "s", "(\\", "w", "+", ")/", ")[", "1", "].", "to", "Lower", "Case", "();", "\u0120+", "}", "\u0120+", "\u0120+", "function", "\u0120check", "Types", "(", "args", ",", "\u0120types", ")", "\u0120{", "\u0120+", "\u0120args", "\u0120=", "\u0120[", "].", "slice", ".", "call", "(", "args", ");", "\u0120+", "\u0120for", "\u0120(", "var", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120types", ".", "length", ";", "\u0120++", "i", ")", "\u0120{", "\u0120+", "\u0120if", "\u0120(", "type", "Of", "(", "args", "[", "i", "])", "\u0120!", "==", "\u0120types", "[", "i", "])", "\u0120{", "\u0120+", "\u0120throw", "\u0120new", "\u0120Type", "Error", "('", "param", "\u0120'", "\u0120+", "\u0120i", "\u0120+", "\u0120'", "\u0120must", "\u0120be", "\u0120of", "\u0120type", "\u0120'", "\u0120+", "\u0120types", "[", "i", "]);", "\u0120+", "\u0120}", "\u0120+", "\u0120}", "\u0120+", "}", "\u0120+", "\u0120const", "\u0120perform", "F", "etch", "\u0120=", "\u0120type", "of", "\u0120fetch", "\u0120===", "\u0120'", "und", "efined", "'", "\u0120?", "\u0120node", "_", "require", "('", "node", "-", "f", "etch", "')", "\u0120:", "\u0120fetch", ";", "\u0120const", "\u0120url", "_", "parse", "\u0120=", "\u0120require", "('", "url", "-", "parse", "');"], "docstring_tokens": ["How", "\u0120about", "\u0120`", "Object", ".", "prototype", ".", "to", "String", "`", "?", "\u0120Or", "\u0120using", "\u0120the", "\u0120`", "type", "of", "`", "\u0120operator", "?"]}
{"function": "@@ -83,6 +83,7 @@ type ReporterKBPKI struct { notifySyncBuffer chan *keybase1.FSPathSyncStatus suppressCh chan time.Duration canceler func() + ctx context.Context } // NewReporterKBPKI creates a new ReporterKBPKI.", "text": "I know @jzila suggested this, but I disagree: you're really not supposed to save a context in a struct. Can you get by with just saving the `Done()` channel instead? The `ctx` should continue to be passed around explicitly.", "function_tokens": ["@@", "\u0120-", "83", ",", "6", "\u0120+", "83", ",", "7", "\u0120@@", "\u0120type", "\u0120Reporter", "K", "BP", "KI", "\u0120struct", "\u0120{", "\u0120notify", "Sync", "Buffer", "\u0120ch", "an", "\u0120*", "key", "base", "1", ".", "F", "SP", "ath", "Sync", "Status", "\u0120suppress", "Ch", "\u0120ch", "an", "\u0120time", ".", "Duration", "\u0120can", "celer", "\u0120func", "()", "\u0120+", "\u0120c", "tx", "\u0120context", ".", "Context", "\u0120}", "\u0120//", "\u0120New", "Rep", "orter", "K", "BP", "KI", "\u0120creates", "\u0120a", "\u0120new", "\u0120Reporter", "K", "BP", "KI", "."], "docstring_tokens": ["I", "\u0120know", "\u0120@", "j", "z", "ila", "\u0120suggested", "\u0120this", ",", "\u0120but", "\u0120I", "\u0120disagree", ":", "\u0120you", "'re", "\u0120really", "\u0120not", "\u0120supposed", "\u0120to", "\u0120save", "\u0120a", "\u0120context", "\u0120in", "\u0120a", "\u0120struct", ".", "\u0120Can", "\u0120you", "\u0120get", "\u0120by", "\u0120with", "\u0120just", "\u0120saving", "\u0120the", "\u0120`", "Done", "()", "`", "\u0120channel", "\u0120instead", "?", "\u0120The", "\u0120`", "ctx", "`", "\u0120should", "\u0120continue", "\u0120to", "\u0120be", "\u0120passed", "\u0120around", "\u0120explicitly", "."]}
{"function": "@@ -12,12 +12,7 @@ namespace Microsoft.AspNet.Server.Kestrel.Networking { IsWindows = PlatformApis.IsWindows; - var isDarwinMono = -#if DNX451 - IsWindows ? false : PlatformApis.IsDarwin; -#else - false; -#endif + var isDarwinMono = !IsWindows && PlatformApis.IsDarwin; if (isDarwinMono) {", "text": "This check isn't right though.", "function_tokens": ["@@", "\u0120-", "12", ",", "12", "\u0120+", "12", ",", "7", "\u0120@@", "\u0120namespace", "\u0120Microsoft", ".", "As", "p", "Net", ".", "Server", ".", "K", "est", "rel", ".", "Net", "working", "\u0120{", "\u0120Is", "Windows", "\u0120=", "\u0120Platform", "Ap", "is", ".", "Is", "Windows", ";", "\u0120-", "\u0120var", "\u0120is", "Dar", "win", "Mon", "o", "\u0120=", "\u0120-", "#", "if", "\u0120DN", "X", "451", "\u0120-", "\u0120Is", "Windows", "\u0120?", "\u0120false", "\u0120:", "\u0120Platform", "Ap", "is", ".", "Is", "Dar", "win", ";", "\u0120-", "#", "else", "\u0120-", "\u0120false", ";", "\u0120-", "#", "endif", "\u0120+", "\u0120var", "\u0120is", "Dar", "win", "Mon", "o", "\u0120=", "\u0120!", "Is", "Windows", "\u0120&&", "\u0120Platform", "Ap", "is", ".", "Is", "Dar", "win", ";", "\u0120if", "\u0120(", "is", "Dar", "win", "Mon", "o", ")", "\u0120{"], "docstring_tokens": ["This", "\u0120check", "\u0120isn", "'t", "\u0120right", "\u0120though", "."]}
{"function": "@@ -96,6 +96,8 @@ public abstract class DynamicLangXApiView implements ViewModel { return missingDefaultServiceAddress() || missingDefaultServiceScopes(); } + public abstract String codeGenVersion(); + @Override public String resourceRoot() { return SnippetSetRunner.SNIPPET_RESOURCE_ROOT;", "text": "maybe `toolkitVersion` instead? It doesn't necessarily have to be called that in the generated code, but in the view model classes, I think it makes it clearer that it is the version of toolkit itself.", "function_tokens": ["@@", "\u0120-", "96", ",", "6", "\u0120+", "96", ",", "8", "\u0120@@", "\u0120public", "\u0120abstract", "\u0120class", "\u0120Dynamic", "L", "ang", "X", "A", "pi", "View", "\u0120implements", "\u0120View", "Model", "\u0120{", "\u0120return", "\u0120missing", "Default", "Service", "Address", "()", "\u0120||", "\u0120missing", "Default", "Service", "Sc", "opes", "();", "\u0120}", "\u0120+", "\u0120public", "\u0120abstract", "\u0120String", "\u0120code", "Gen", "Version", "();", "\u0120+", "\u0120@", "Override", "\u0120public", "\u0120String", "\u0120resource", "Root", "()", "\u0120{", "\u0120return", "\u0120Sn", "ipp", "et", "Set", "Runner", ".", "SN", "IPP", "ET", "_", "RES", "OURCE", "_", "RO", "OT", ";"], "docstring_tokens": ["maybe", "\u0120`", "tool", "kit", "Version", "`", "\u0120instead", "?", "\u0120It", "\u0120doesn", "'t", "\u0120necessarily", "\u0120have", "\u0120to", "\u0120be", "\u0120called", "\u0120that", "\u0120in", "\u0120the", "\u0120generated", "\u0120code", ",", "\u0120but", "\u0120in", "\u0120the", "\u0120view", "\u0120model", "\u0120classes", ",", "\u0120I", "\u0120think", "\u0120it", "\u0120makes", "\u0120it", "\u0120clearer", "\u0120that", "\u0120it", "\u0120is", "\u0120the", "\u0120version", "\u0120of", "\u0120tool", "kit", "\u0120itself", "."]}
{"function": "@@ -230,15 +230,13 @@ module.exports = class XHRUpload extends Plugin { const body = opts.getResponseData(xhr.responseText, xhr) const uploadURL = body[opts.responseUrlFieldName] - const response = { + const uploadResp = { status: ev.target.status, body, uploadURL } - this.uppy.setFileState(file.id, { response }) - - this.uppy.emit('upload-success', file, body, uploadURL) + this.uppy.emit('upload-success', file, uploadResp) if (uploadURL) { this.uppy.log(`Download ${file.name} from ${file.uploadURL}`)", "text": "the response data was added intentionally in #612, i think we could keep the `setFileState` stuff here as a special case, at least for now ", "function_tokens": ["@@", "\u0120-", "230", ",", "15", "\u0120+", "230", ",", "13", "\u0120@@", "\u0120module", ".", "ex", "ports", "\u0120=", "\u0120class", "\u0120X", "HR", "Upload", "\u0120extends", "\u0120Plugin", "\u0120{", "\u0120const", "\u0120body", "\u0120=", "\u0120opt", "s", ".", "get", "Response", "Data", "(", "x", "hr", ".", "response", "Text", ",", "\u0120x", "hr", ")", "\u0120const", "\u0120upload", "URL", "\u0120=", "\u0120body", "[", "op", "ts", ".", "response", "Url", "Field", "Name", "]", "\u0120-", "\u0120const", "\u0120response", "\u0120=", "\u0120{", "\u0120+", "\u0120const", "\u0120upload", "Resp", "\u0120=", "\u0120{", "\u0120status", ":", "\u0120ev", ".", "target", ".", "status", ",", "\u0120body", ",", "\u0120upload", "URL", "\u0120}", "\u0120-", "\u0120this", ".", "upp", "y", ".", "set", "File", "State", "(", "file", ".", "id", ",", "\u0120{", "\u0120response", "\u0120})", "\u0120-", "\u0120-", "\u0120this", ".", "upp", "y", ".", "em", "it", "('", "upload", "-", "success", "',", "\u0120file", ",", "\u0120body", ",", "\u0120upload", "URL", ")", "\u0120+", "\u0120this", ".", "upp", "y", ".", "em", "it", "('", "upload", "-", "success", "',", "\u0120file", ",", "\u0120upload", "Resp", ")", "\u0120if", "\u0120(", "upload", "URL", ")", "\u0120{", "\u0120this", ".", "upp", "y", ".", "log", "(", "`", "Download", "\u0120${", "file", ".", "name", "}", "\u0120from", "\u0120${", "file", ".", "upload", "URL", "}", "`", ")"], "docstring_tokens": ["the", "\u0120response", "\u0120data", "\u0120was", "\u0120added", "\u0120intentionally", "\u0120in", "\u0120#", "612", ",", "\u0120i", "\u0120think", "\u0120we", "\u0120could", "\u0120keep", "\u0120the", "\u0120`", "set", "File", "State", "`", "\u0120stuff", "\u0120here", "\u0120as", "\u0120a", "\u0120special", "\u0120case", ",", "\u0120at", "\u0120least", "\u0120for", "\u0120now", "\u0120"]}
{"function": "@@ -134,7 +134,7 @@ func (s *stream) Read(p []byte) (int, error) { } else { select { case <-s.readChan: - case <-time.After(deadline.Sub(time.Now())): + case <-time.After(time.Until(deadline)): } } s.mutex.Lock()", "text": "This isn't really easy to read.", "function_tokens": ["@@", "\u0120-", "134", ",", "7", "\u0120+", "134", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "s", "\u0120*", "stream", ")", "\u0120Read", "(", "p", "\u0120[]", "byte", ")", "\u0120(", "int", ",", "\u0120error", ")", "\u0120{", "\u0120}", "\u0120else", "\u0120{", "\u0120select", "\u0120{", "\u0120case", "\u0120<-", "s", ".", "read", "Chan", ":", "\u0120-", "\u0120case", "\u0120<-", "time", ".", "After", "(", "dead", "line", ".", "Sub", "(", "time", ".", "Now", "())", "):", "\u0120+", "\u0120case", "\u0120<-", "time", ".", "After", "(", "time", ".", "Until", "(", "dead", "line", ")", "):", "\u0120}", "\u0120}", "\u0120s", ".", "mut", "ex", ".", "Lock", "()"], "docstring_tokens": ["This", "\u0120isn", "'t", "\u0120really", "\u0120easy", "\u0120to", "\u0120read", "."]}
{"function": "@@ -123,7 +123,7 @@ func (c *CStorVolumeReplicaController) cVREventHandler(operation common.QueueOpe err := volumereplica.DeleteVolume(fullVolName) if err != nil { - glog.Errorf(\"Error in deleting volume %q: %s\", cVR.ObjectMeta.Name,err) + glog.Errorf(\"Error in deleting volume %q: %s\", cVR.ObjectMeta.Name, err) c.recorder.Event(cVR, corev1.EventTypeWarning, string(common.FailureDestroy), string(common.MessageResourceFailDestroy)) return string(apis.CVRStatusDeletionFailed), err }", "text": "This line changed due to go formatting. Format was not there earlier.", "function_tokens": ["@@", "\u0120-", "123", ",", "7", "\u0120+", "123", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120*", "C", "St", "or", "Volume", "Repl", "ica", "Controller", ")", "\u0120c", "V", "RE", "vent", "Handler", "(", "operation", "\u0120common", ".", "Queue", "O", "pe", "\u0120err", "\u0120:=", "\u0120vol", "um", "ere", "pl", "ica", ".", "Delete", "Volume", "(", "full", "Vol", "Name", ")", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120-", "\u0120gl", "og", ".", "Error", "f", "(\"", "Error", "\u0120in", "\u0120deleting", "\u0120volume", "\u0120%", "q", ":", "\u0120%", "s", "\",", "\u0120c", "VR", ".", "Object", "Meta", ".", "Name", ",", "err", ")", "\u0120+", "\u0120gl", "og", ".", "Error", "f", "(\"", "Error", "\u0120in", "\u0120deleting", "\u0120volume", "\u0120%", "q", ":", "\u0120%", "s", "\",", "\u0120c", "VR", ".", "Object", "Meta", ".", "Name", ",", "\u0120err", ")", "\u0120c", ".", "rec", "order", ".", "Event", "(", "c", "VR", ",", "\u0120core", "v", "1", ".", "Event", "Type", "Warning", ",", "\u0120string", "(", "common", ".", "Failure", "Destroy", "),", "\u0120string", "(", "common", ".", "Message", "Resource", "Fail", "Destroy", "))", "\u0120return", "\u0120string", "(", "ap", "is", ".", "C", "VR", "Status", "De", "let", "ion", "F", "ailed", "),", "\u0120err", "\u0120}"], "docstring_tokens": ["This", "\u0120line", "\u0120changed", "\u0120due", "\u0120to", "\u0120go", "\u0120formatting", ".", "\u0120Format", "\u0120was", "\u0120not", "\u0120there", "\u0120earlier", "."]}
{"function": "@@ -28,13 +28,13 @@ type staticUpstream struct { Path string Interval time.Duration } + Without string } // NewStaticUpstreams parses the configuration input and sets up // static upstreams for the proxy middleware. func NewStaticUpstreams(c parse.Dispenser) ([]Upstream, error) { var upstreams []Upstream - for c.Next() { upstream := &staticUpstream{ from: \"\",", "text": "The name \"Without\" in code is a little nebulous. Maybe something more descriptive like TrimPrefix or StripPrefix or WithoutPathPrefix or something like that. (Thoughts?)", "function_tokens": ["@@", "\u0120-", "28", ",", "13", "\u0120+", "28", ",", "13", "\u0120@@", "\u0120type", "\u0120static", "Up", "stream", "\u0120struct", "\u0120{", "\u0120Path", "\u0120string", "\u0120Inter", "val", "\u0120time", ".", "Duration", "\u0120}", "\u0120+", "\u0120Without", "\u0120string", "\u0120}", "\u0120//", "\u0120New", "Static", "Up", "stream", "s", "\u0120pars", "es", "\u0120the", "\u0120configuration", "\u0120input", "\u0120and", "\u0120sets", "\u0120up", "\u0120//", "\u0120static", "\u0120upstream", "s", "\u0120for", "\u0120the", "\u0120proxy", "\u0120middle", "ware", ".", "\u0120func", "\u0120New", "Static", "Up", "stream", "s", "(", "c", "\u0120parse", ".", "Dis", "p", "enser", ")", "\u0120(", "[]", "Up", "stream", ",", "\u0120error", ")", "\u0120{", "\u0120var", "\u0120upstream", "s", "\u0120[]", "Up", "stream", "\u0120-", "\u0120for", "\u0120c", ".", "Next", "()", "\u0120{", "\u0120upstream", "\u0120:=", "\u0120&", "static", "Up", "stream", "{", "\u0120from", ":", "\u0120\"", "\","], "docstring_tokens": ["The", "\u0120name", "\u0120\"", "Without", "\"", "\u0120in", "\u0120code", "\u0120is", "\u0120a", "\u0120little", "\u0120neb", "ulous", ".", "\u0120Maybe", "\u0120something", "\u0120more", "\u0120descriptive", "\u0120like", "\u0120Tr", "im", "Pref", "ix", "\u0120or", "\u0120Strip", "Pref", "ix", "\u0120or", "\u0120Without", "Path", "Pref", "ix", "\u0120or", "\u0120something", "\u0120like", "\u0120that", ".", "\u0120(", "Though", "ts", "?)"]}
{"function": "@@ -254,6 +254,12 @@ public class MoveIT { linkDataset.then().assertThat() .statusCode(OK.getStatusCode()); + // A dataset cannot be linked to the same dataverse again. + Response tryToLinkAgain = UtilIT.linkDataset(datasetPid, dataverse2Alias, superuserApiToken); + tryToLinkAgain.prettyPrint(); + tryToLinkAgain.then().assertThat() + .statusCode(FORBIDDEN.getStatusCode()); + Response getLinksBefore = UtilIT.getDatasetLinks(datasetPid, superuserApiToken); getLinksBefore.prettyPrint(); getLinksBefore.then().assertThat()", "text": "is this test in the move tests? I see what you mean then - it works, but I wonder if we won't lose track that it's being tested here.", "function_tokens": ["@@", "\u0120-", "254", ",", "6", "\u0120+", "254", ",", "12", "\u0120@@", "\u0120public", "\u0120class", "\u0120Move", "IT", "\u0120{", "\u0120link", "Dat", "as", "et", ".", "then", "().", "assert", "That", "()", "\u0120.", "status", "Code", "(", "OK", ".", "get", "Status", "Code", "());", "\u0120+", "\u0120//", "\u0120A", "\u0120dataset", "\u0120cannot", "\u0120be", "\u0120linked", "\u0120to", "\u0120the", "\u0120same", "\u0120data", "verse", "\u0120again", ".", "\u0120+", "\u0120Response", "\u0120try", "To", "Link", "Again", "\u0120=", "\u0120Ut", "il", "IT", ".", "link", "Dat", "as", "et", "(", "dat", "as", "et", "P", "id", ",", "\u0120data", "verse", "2", "Alias", ",", "\u0120super", "user", "A", "pi", "Token", ");", "\u0120+", "\u0120try", "To", "Link", "Again", ".", "pretty", "Print", "();", "\u0120+", "\u0120try", "To", "Link", "Again", ".", "then", "().", "assert", "That", "()", "\u0120+", "\u0120.", "status", "Code", "(", "FOR", "B", "ID", "DEN", ".", "get", "Status", "Code", "());", "\u0120+", "\u0120Response", "\u0120get", "Links", "Before", "\u0120=", "\u0120Ut", "il", "IT", ".", "get", "Dat", "as", "et", "Links", "(", "dat", "as", "et", "P", "id", ",", "\u0120super", "user", "A", "pi", "Token", ");", "\u0120get", "Links", "Before", ".", "pretty", "Print", "();", "\u0120get", "Links", "Before", ".", "then", "().", "assert", "That", "()"], "docstring_tokens": ["is", "\u0120this", "\u0120test", "\u0120in", "\u0120the", "\u0120move", "\u0120tests", "?", "\u0120I", "\u0120see", "\u0120what", "\u0120you", "\u0120mean", "\u0120then", "\u0120-", "\u0120it", "\u0120works", ",", "\u0120but", "\u0120I", "\u0120wonder", "\u0120if", "\u0120we", "\u0120won", "'t", "\u0120lose", "\u0120track", "\u0120that", "\u0120it", "'s", "\u0120being", "\u0120tested", "\u0120here", "."]}
{"function": "@@ -368,5 +368,8 @@ type Instance struct { EBSOptimized *bool `json:\"ebsOptimized\"` // The tags associated with the instance. - Tags map[string]string `json:\"tag\"` + Tags map[string]string `json:\"tags\"` + + // The security groups associated with the instance. + SecurityGroups map[string]string `json:\"securityGroups\"` }", "text": "I'm not sure if this wanted to be `json:\"tags\"` (which I'd set in my PR) or `json:\"tag\"` that someone elses PR had set. Given that the rest of the fields had their JSON field name set to the same as the struct field name, I opted for `tags`.", "function_tokens": ["@@", "\u0120-", "368", ",", "5", "\u0120+", "368", ",", "8", "\u0120@@", "\u0120type", "\u0120Inst", "ance", "\u0120struct", "\u0120{", "\u0120E", "BS", "Opt", "im", "ized", "\u0120*", "bool", "\u0120`", "json", ":\"", "e", "bs", "Opt", "im", "ized", "\"", "`", "\u0120//", "\u0120The", "\u0120tags", "\u0120associated", "\u0120with", "\u0120the", "\u0120instance", ".", "\u0120-", "\u0120Tags", "\u0120map", "[", "string", "]", "string", "\u0120`", "json", ":\"", "tag", "\"", "`", "\u0120+", "\u0120Tags", "\u0120map", "[", "string", "]", "string", "\u0120`", "json", ":\"", "tags", "\"", "`", "\u0120+", "\u0120+", "\u0120//", "\u0120The", "\u0120security", "\u0120groups", "\u0120associated", "\u0120with", "\u0120the", "\u0120instance", ".", "\u0120+", "\u0120Security", "G", "roups", "\u0120map", "[", "string", "]", "string", "\u0120`", "json", ":\"", "security", "G", "roups", "\"", "`", "\u0120}"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120sure", "\u0120if", "\u0120this", "\u0120wanted", "\u0120to", "\u0120be", "\u0120`", "json", ":\"", "tags", "\"", "`", "\u0120(", "which", "\u0120I", "'d", "\u0120set", "\u0120in", "\u0120my", "\u0120PR", ")", "\u0120or", "\u0120`", "json", ":\"", "tag", "\"", "`", "\u0120that", "\u0120someone", "\u0120el", "ses", "\u0120PR", "\u0120had", "\u0120set", ".", "\u0120Given", "\u0120that", "\u0120the", "\u0120rest", "\u0120of", "\u0120the", "\u0120fields", "\u0120had", "\u0120their", "\u0120JSON", "\u0120field", "\u0120name", "\u0120set", "\u0120to", "\u0120the", "\u0120same", "\u0120as", "\u0120the", "\u0120struct", "\u0120field", "\u0120name", ",", "\u0120I", "\u0120opted", "\u0120for", "\u0120`", "tags", "`."]}
{"function": "@@ -47,6 +47,11 @@ module Ncr message: \"must be three letters or numbers\" }, allow_blank: true + scope :for_fiscal_year, lambda { |year| + range = self.class.range_for_fiscal_year(year) + where(created_at: range[:start_time]...range[:end_time]) + } + def self.all_system_approver_emails [ self.ba61_tier1_budget_mailbox,", "text": "since the logic here and in `Proposal` is exactly the same, do you think it makes sense for us to include it elsewhere? I am not opposed to duplicated code when it makes sense, but the reason I first identified this was that I was looking for code in NCR::WorkOrder that was not specific to Work Orders. Seems like fiscal year logic might be helpful for reporting for other clients. In that case, we'd want this scope on those client data classes as well. Might be wrong to include this in the FiscalYear mixin, but it does seem like it should be outside of Proposal and WorkOrder. Does that make sense?", "function_tokens": ["@@", "\u0120-", "47", ",", "6", "\u0120+", "47", ",", "11", "\u0120@@", "\u0120module", "\u0120N", "cr", "\u0120message", ":", "\u0120\"", "must", "\u0120be", "\u0120three", "\u0120letters", "\u0120or", "\u0120numbers", "\"", "\u0120},", "\u0120allow", "_", "blank", ":", "\u0120true", "\u0120+", "\u0120scope", "\u0120:", "for", "_", "f", "iscal", "_", "year", ",", "\u0120lambda", "\u0120{", "\u0120|", "year", "|", "\u0120+", "\u0120range", "\u0120=", "\u0120self", ".", "class", ".", "range", "_", "for", "_", "f", "iscal", "_", "year", "(", "year", ")", "\u0120+", "\u0120where", "(", "created", "_", "at", ":", "\u0120range", "[", ":", "start", "_", "time", "]", "...", "range", "[", ":", "end", "_", "time", "])", "\u0120+", "\u0120}", "\u0120+", "\u0120def", "\u0120self", ".", "all", "_", "system", "_", "appro", "ver", "_", "em", "ails", "\u0120[", "\u0120self", ".", "ba", "61", "_", "tier", "1", "_", "budget", "_", "mail", "box", ","], "docstring_tokens": ["since", "\u0120the", "\u0120logic", "\u0120here", "\u0120and", "\u0120in", "\u0120`", "Prop", "osal", "`", "\u0120is", "\u0120exactly", "\u0120the", "\u0120same", ",", "\u0120do", "\u0120you", "\u0120think", "\u0120it", "\u0120makes", "\u0120sense", "\u0120for", "\u0120us", "\u0120to", "\u0120include", "\u0120it", "\u0120elsewhere", "?", "\u0120I", "\u0120am", "\u0120not", "\u0120opposed", "\u0120to", "\u0120dupl", "icated", "\u0120code", "\u0120when", "\u0120it", "\u0120makes", "\u0120sense", ",", "\u0120but", "\u0120the", "\u0120reason", "\u0120I", "\u0120first", "\u0120identified", "\u0120this", "\u0120was", "\u0120that", "\u0120I", "\u0120was", "\u0120looking", "\u0120for", "\u0120code", "\u0120in", "\u0120NC", "R", "::", "Work", "Order", "\u0120that", "\u0120was", "\u0120not", "\u0120specific", "\u0120to", "\u0120Work", "\u0120Orders", ".", "\u0120Seems", "\u0120like", "\u0120fiscal", "\u0120year", "\u0120logic", "\u0120might", "\u0120be", "\u0120helpful", "\u0120for", "\u0120reporting", "\u0120for", "\u0120other", "\u0120clients", ".", "\u0120In", "\u0120that", "\u0120case", ",", "\u0120we", "'d", "\u0120want", "\u0120this", "\u0120scope", "\u0120on", "\u0120those", "\u0120client", "\u0120data", "\u0120classes", "\u0120as", "\u0120well", ".", "\u0120Might", "\u0120be", "\u0120wrong", "\u0120to", "\u0120include", "\u0120this", "\u0120in", "\u0120the", "\u0120Fiscal", "Year", "\u0120mix", "in", ",", "\u0120but", "\u0120it", "\u0120does", "\u0120seem", "\u0120like", "\u0120it", "\u0120should", "\u0120be", "\u0120outside", "\u0120of", "\u0120Pro", "posal", "\u0120and", "\u0120Work", "Order", ".", "\u0120Does", "\u0120that", "\u0120make", "\u0120sense", "?"]}
{"function": "@@ -42,6 +42,11 @@ class InfluxWriterSubscriber(object): self.time = 0 + def on_connection_closed(self, connection, reply_code, reply_text): + self.log.info('RabbitMQ connection got closed!') + self.connection.add_timeout(5, self.connect_to_rabbitmq) + + @staticmethod def static_callback(ch, method, properties, body, obj): return obj.callback(ch, method, properties, body)", "text": "there is no static method as a go between -- how does this work?", "function_tokens": ["@@", "\u0120-", "42", ",", "6", "\u0120+", "42", ",", "11", "\u0120@@", "\u0120class", "\u0120Inf", "lux", "Writer", "Sub", "sc", "riber", "(", "object", "):", "\u0120self", ".", "time", "\u0120=", "\u01200", "\u0120+", "\u0120def", "\u0120on", "_", "connection", "_", "closed", "(", "self", ",", "\u0120connection", ",", "\u0120reply", "_", "code", ",", "\u0120reply", "_", "text", "):", "\u0120+", "\u0120self", ".", "log", ".", "info", "('", "R", "abbit", "MQ", "\u0120connection", "\u0120got", "\u0120closed", "!", "')", "\u0120+", "\u0120self", ".", "connection", ".", "add", "_", "timeout", "(", "5", ",", "\u0120self", ".", "connect", "_", "to", "_", "r", "abbit", "m", "q", ")", "\u0120+", "\u0120+", "\u0120@", "static", "method", "\u0120def", "\u0120static", "_", "callback", "(", "ch", ",", "\u0120method", ",", "\u0120properties", ",", "\u0120body", ",", "\u0120obj", "):", "\u0120return", "\u0120obj", ".", "callback", "(", "ch", ",", "\u0120method", ",", "\u0120properties", ",", "\u0120body", ")"], "docstring_tokens": ["there", "\u0120is", "\u0120no", "\u0120static", "\u0120method", "\u0120as", "\u0120a", "\u0120go", "\u0120between", "\u0120--", "\u0120how", "\u0120does", "\u0120this", "\u0120work", "?"]}
{"function": "@@ -0,0 +1,8 @@ +# frozen_string_literal: true +# encoding: utf-8 + +class StringifiedSymbol + include Mongoid::Document + store_in collection: \"stringified_symbols\", client: :other + field :stringified_symbol, type: StringifiedSymbol +end", "text": "Can you please change the name of this class to be something else?", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "8", "\u0120@@", "\u0120+#", "\u0120frozen", "_", "string", "_", "lit", "eral", ":", "\u0120true", "\u0120+#", "\u0120encoding", ":", "\u0120ut", "f", "-", "8", "\u0120+", "\u0120+", "class", "\u0120String", "ified", "Sy", "mbol", "\u0120+", "\u0120include", "\u0120Mong", "oid", "::", "Document", "\u0120+", "\u0120store", "_", "in", "\u0120collection", ":", "\u0120\"", "string", "ified", "_", "sy", "mb", "ols", "\",", "\u0120client", ":", "\u0120:", "other", "\u0120+", "\u0120field", "\u0120:", "string", "ified", "_", "sy", "mbol", ",", "\u0120type", ":", "\u0120String", "ified", "Sy", "mbol", "\u0120+", "end"], "docstring_tokens": ["Can", "\u0120you", "\u0120please", "\u0120change", "\u0120the", "\u0120name", "\u0120of", "\u0120this", "\u0120class", "\u0120to", "\u0120be", "\u0120something", "\u0120else", "?"]}
{"function": "@@ -403,7 +403,7 @@ size_t h2o_strstr(const char *haysack, size_t haysack_len, const char *needle, s } /* note: returns a zero-width match as well */ -const char *h2o_next_token(h2o_iovec_t *iter, int separator, size_t *element_len, h2o_iovec_t *value) +const char *h2o_next_token(h2o_iovec_t *iter, int separator, size_t *element_len, h2o_iovec_t *value, int coma_separator) { const char *cur = iter->base, *end = iter->base + iter->len, *token_start, *token_end; ", "text": "I think we might prefer generalizing the interface rather than creating an exception. Current design of `h2o_next_token` assumes the input to be a comma-separated list, and allows the caller to specify a different separator when parsing a nested list. As I understand, what we are trying to attain in this PR is to have a way of parsing a flat list of semicolon-separated list. Assuming that is the case, I think it would be better to change the API of the function to accept two separators (i.e. inner and outer), where for our existing use-cases `outer` would be `,`.", "function_tokens": ["@@", "\u0120-", "403", ",", "7", "\u0120+", "403", ",", "7", "\u0120@@", "\u0120size", "_", "t", "\u0120h", "2", "o", "_", "str", "str", "(", "const", "\u0120char", "\u0120*", "h", "ays", "ack", ",", "\u0120size", "_", "t", "\u0120h", "ays", "ack", "_", "len", ",", "\u0120const", "\u0120char", "\u0120*", "need", "le", ",", "\u0120s", "\u0120}", "\u0120/*", "\u0120note", ":", "\u0120returns", "\u0120a", "\u0120zero", "-", "width", "\u0120match", "\u0120as", "\u0120well", "\u0120*/", "\u0120-", "const", "\u0120char", "\u0120*", "h", "2", "o", "_", "next", "_", "token", "(", "h", "2", "o", "_", "i", "ove", "c", "_", "t", "\u0120*", "iter", ",", "\u0120int", "\u0120separ", "ator", ",", "\u0120size", "_", "t", "\u0120*", "element", "_", "len", ",", "\u0120h", "2", "o", "_", "i", "ove", "c", "_", "t", "\u0120*", "value", ")", "\u0120+", "const", "\u0120char", "\u0120*", "h", "2", "o", "_", "next", "_", "token", "(", "h", "2", "o", "_", "i", "ove", "c", "_", "t", "\u0120*", "iter", ",", "\u0120int", "\u0120separ", "ator", ",", "\u0120size", "_", "t", "\u0120*", "element", "_", "len", ",", "\u0120h", "2", "o", "_", "i", "ove", "c", "_", "t", "\u0120*", "value", ",", "\u0120int", "\u0120coma", "_", "separ", "ator", ")", "\u0120{", "\u0120const", "\u0120char", "\u0120*", "cur", "\u0120=", "\u0120iter", "->", "base", ",", "\u0120*", "end", "\u0120=", "\u0120iter", "->", "base", "\u0120+", "\u0120iter", "->", "len", ",", "\u0120*", "token", "_", "start", ",", "\u0120*", "token", "_", "end", ";", "\u0120"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120might", "\u0120prefer", "\u0120general", "izing", "\u0120the", "\u0120interface", "\u0120rather", "\u0120than", "\u0120creating", "\u0120an", "\u0120exception", ".", "\u0120Current", "\u0120design", "\u0120of", "\u0120`", "h", "2", "o", "_", "next", "_", "token", "`", "\u0120assumes", "\u0120the", "\u0120input", "\u0120to", "\u0120be", "\u0120a", "\u0120comma", "-", "separ", "ated", "\u0120list", ",", "\u0120and", "\u0120allows", "\u0120the", "\u0120caller", "\u0120to", "\u0120specify", "\u0120a", "\u0120different", "\u0120separ", "ator", "\u0120when", "\u0120parsing", "\u0120a", "\u0120nested", "\u0120list", ".", "\u0120As", "\u0120I", "\u0120understand", ",", "\u0120what", "\u0120we", "\u0120are", "\u0120trying", "\u0120to", "\u0120attain", "\u0120in", "\u0120this", "\u0120PR", "\u0120is", "\u0120to", "\u0120have", "\u0120a", "\u0120way", "\u0120of", "\u0120parsing", "\u0120a", "\u0120flat", "\u0120list", "\u0120of", "\u0120sem", "icol", "on", "-", "separ", "ated", "\u0120list", ".", "\u0120Assuming", "\u0120that", "\u0120is", "\u0120the", "\u0120case", ",", "\u0120I", "\u0120think", "\u0120it", "\u0120would", "\u0120be", "\u0120better", "\u0120to", "\u0120change", "\u0120the", "\u0120API", "\u0120of", "\u0120the", "\u0120function", "\u0120to", "\u0120accept", "\u0120two", "\u0120separ", "ators", "\u0120(", "i", ".", "e", ".", "\u0120inner", "\u0120and", "\u0120outer", "),", "\u0120where", "\u0120for", "\u0120our", "\u0120existing", "\u0120use", "-", "cases", "\u0120`", "outer", "`", "\u0120would", "\u0120be", "\u0120`", ",", "`."]}
{"function": "@@ -43,8 +43,8 @@ namespace Nethermind.Blockchain { private const long LowestInsertedBodyNumberDbEntryAddress = 0; private const int CacheSize = 64; - private readonly ICache<Keccak, Block> _blockCache = new LruCacheWithRecycling<Keccak, Block>(CacheSize, CacheSize, \"blocks\"); - private readonly ICache<Keccak, BlockHeader> _headerCache = new LruCacheWithRecycling<Keccak, BlockHeader>(CacheSize, CacheSize, \"headers\"); + private readonly ICache<Keccak, Block> _blockCache = new LruCache<Keccak, Block>(CacheSize, CacheSize, \"blocks\"); + private readonly ICache<Keccak, BlockHeader> _headerCache = new LruCache<Keccak, BlockHeader>(CacheSize, CacheSize, \"headers\"); private const int BestKnownSearchLimit = 256_000_000; ", "text": "why not recycling? I Lru cache now recycling?", "function_tokens": ["@@", "\u0120-", "43", ",", "8", "\u0120+", "43", ",", "8", "\u0120@@", "\u0120namespace", "\u0120Nether", "mind", ".", "Block", "chain", "\u0120{", "\u0120private", "\u0120const", "\u0120long", "\u0120Low", "est", "Insert", "ed", "Body", "Number", "Db", "Entry", "Address", "\u0120=", "\u01200", ";", "\u0120private", "\u0120const", "\u0120int", "\u0120Cache", "Size", "\u0120=", "\u012064", ";", "\u0120-", "\u0120private", "\u0120read", "only", "\u0120IC", "ache", "<", "Ke", "cc", "ak", ",", "\u0120Block", ">", "\u0120_", "block", "Cache", "\u0120=", "\u0120new", "\u0120L", "ru", "Cache", "With", "Rec", "y", "cling", "<", "Ke", "cc", "ak", ",", "\u0120Block", ">(", "Cache", "Size", ",", "\u0120Cache", "Size", ",", "\u0120\"", "blocks", "\");", "\u0120-", "\u0120private", "\u0120read", "only", "\u0120IC", "ache", "<", "Ke", "cc", "ak", ",", "\u0120Block", "Header", ">", "\u0120_", "header", "Cache", "\u0120=", "\u0120new", "\u0120L", "ru", "Cache", "With", "Rec", "y", "cling", "<", "Ke", "cc", "ak", ",", "\u0120Block", "Header", ">(", "Cache", "Size", ",", "\u0120Cache", "Size", ",", "\u0120\"", "headers", "\");", "\u0120+", "\u0120private", "\u0120read", "only", "\u0120IC", "ache", "<", "Ke", "cc", "ak", ",", "\u0120Block", ">", "\u0120_", "block", "Cache", "\u0120=", "\u0120new", "\u0120L", "ru", "Cache", "<", "Ke", "cc", "ak", ",", "\u0120Block", ">(", "Cache", "Size", ",", "\u0120Cache", "Size", ",", "\u0120\"", "blocks", "\");", "\u0120+", "\u0120private", "\u0120read", "only", "\u0120IC", "ache", "<", "Ke", "cc", "ak", ",", "\u0120Block", "Header", ">", "\u0120_", "header", "Cache", "\u0120=", "\u0120new", "\u0120L", "ru", "Cache", "<", "Ke", "cc", "ak", ",", "\u0120Block", "Header", ">(", "Cache", "Size", ",", "\u0120Cache", "Size", ",", "\u0120\"", "headers", "\");", "\u0120private", "\u0120const", "\u0120int", "\u0120Best", "Known", "Search", "Limit", "\u0120=", "\u0120256", "_", "000", "_", "000", ";", "\u0120"], "docstring_tokens": ["why", "\u0120not", "\u0120recycling", "?", "\u0120I", "\u0120L", "ru", "\u0120cache", "\u0120now", "\u0120recycling", "?"]}
{"function": "@@ -69,7 +69,7 @@ func (consumer *createConsumer) Consume(requestPtr interface{}) (response interf issuerID := consumer.peerID if request.ConsumerInfo != nil { issuerID = request.ConsumerInfo.IssuerID - if request.ConsumerInfo.PaymentVersion == PaymentVersionV2 { + if request.ConsumerInfo.PaymentVersion == PaymentVersionV3 { indicateNewVersion = true } } else {", "text": "Why it is now called `PaymentVersionV3`?", "function_tokens": ["@@", "\u0120-", "69", ",", "7", "\u0120+", "69", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "consumer", "\u0120*", "create", "Consumer", ")", "\u0120Cons", "ume", "(", "request", "Ptr", "\u0120interface", "{", "})", "\u0120(", "response", "\u0120interf", "\u0120issuer", "ID", "\u0120:=", "\u0120consumer", ".", "peer", "ID", "\u0120if", "\u0120request", ".", "Consumer", "Info", "\u0120!=", "\u0120nil", "\u0120{", "\u0120issuer", "ID", "\u0120=", "\u0120request", ".", "Consumer", "Info", ".", "Iss", "uer", "ID", "\u0120-", "\u0120if", "\u0120request", ".", "Consumer", "Info", ".", "Pay", "ment", "Version", "\u0120==", "\u0120Payment", "Version", "V", "2", "\u0120{", "\u0120+", "\u0120if", "\u0120request", ".", "Consumer", "Info", ".", "Pay", "ment", "Version", "\u0120==", "\u0120Payment", "Version", "V", "3", "\u0120{", "\u0120indicate", "New", "Version", "\u0120=", "\u0120true", "\u0120}", "\u0120}", "\u0120else", "\u0120{"], "docstring_tokens": ["Why", "\u0120it", "\u0120is", "\u0120now", "\u0120called", "\u0120`", "Pay", "ment", "Version", "V", "3", "`", "?"]}
{"function": "@@ -165,7 +165,7 @@ func (dc *DownstreamController) syncSecret() { } nodes := dc.lc.SecretNodes(secret.Namespace, secret.Name) - klog.Infof(\"there are %d nodes need to sync secret, operation: %s\", len(nodes), e.Type) + klog.V(4).Infof(\"there are %d nodes need to sync secret, operation: %s\", len(nodes), e.Type) for _, n := range nodes { msg := model.NewMessage(\"\") msg.SetResourceVersion(secret.ResourceVersion)", "text": "changed for debug purpose?", "function_tokens": ["@@", "\u0120-", "165", ",", "7", "\u0120+", "165", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "dc", "\u0120*", "Down", "stream", "Controller", ")", "\u0120sync", "Secret", "()", "\u0120{", "\u0120}", "\u0120nodes", "\u0120:=", "\u0120dc", ".", "lc", ".", "Secret", "N", "odes", "(", "secret", ".", "Names", "pace", ",", "\u0120secret", ".", "Name", ")", "\u0120-", "\u0120k", "log", ".", "Inf", "of", "(\"", "there", "\u0120are", "\u0120%", "d", "\u0120nodes", "\u0120need", "\u0120to", "\u0120sync", "\u0120secret", ",", "\u0120operation", ":", "\u0120%", "s", "\",", "\u0120len", "(", "n", "odes", "),", "\u0120e", ".", "Type", ")", "\u0120+", "\u0120k", "log", ".", "V", "(", "4", ").", "Inf", "of", "(\"", "there", "\u0120are", "\u0120%", "d", "\u0120nodes", "\u0120need", "\u0120to", "\u0120sync", "\u0120secret", ",", "\u0120operation", ":", "\u0120%", "s", "\",", "\u0120len", "(", "n", "odes", "),", "\u0120e", ".", "Type", ")", "\u0120for", "\u0120_", ",", "\u0120n", "\u0120:=", "\u0120range", "\u0120nodes", "\u0120{", "\u0120msg", "\u0120:=", "\u0120model", ".", "New", "Message", "(\"", "\")", "\u0120msg", ".", "Set", "Resource", "Version", "(", "secret", ".", "Resource", "Version", ")"], "docstring_tokens": ["changed", "\u0120for", "\u0120debug", "\u0120purpose", "?"]}
{"function": "@@ -46,6 +46,13 @@ namespace OpenTelemetry /// <inheritdoc /> public abstract override void OnEnd(T data); + internal override void SetParentProvider(BaseProvider parentProvider) + { + base.SetParentProvider(parentProvider); + + this.exporter.ParentProvider = parentProvider; + } + /// <inheritdoc /> protected override bool OnShutdown(int timeoutMilliseconds) {", "text": "@cijothomas I needed a way to set the Exporter.ParentProvider when the Processor's gets set. Internal to SDK though.", "function_tokens": ["@@", "\u0120-", "46", ",", "6", "\u0120+", "46", ",", "13", "\u0120@@", "\u0120namespace", "\u0120Open", "Tele", "metry", "\u0120///", "\u0120<", "in", "her", "it", "doc", "\u0120/>", "\u0120public", "\u0120abstract", "\u0120override", "\u0120void", "\u0120On", "End", "(", "T", "\u0120data", ");", "\u0120+", "\u0120internal", "\u0120override", "\u0120void", "\u0120Set", "Parent", "Provider", "(", "Base", "Provider", "\u0120parent", "Provider", ")", "\u0120+", "\u0120{", "\u0120+", "\u0120base", ".", "Set", "Parent", "Provider", "(", "parent", "Provider", ");", "\u0120+", "\u0120+", "\u0120this", ".", "ex", "porter", ".", "Parent", "Provider", "\u0120=", "\u0120parent", "Provider", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120///", "\u0120<", "in", "her", "it", "doc", "\u0120/>", "\u0120protected", "\u0120override", "\u0120bool", "\u0120On", "Shut", "down", "(", "int", "\u0120timeout", "Mill", "isec", "onds", ")", "\u0120{"], "docstring_tokens": ["@", "ci", "j", "oth", "omas", "\u0120I", "\u0120needed", "\u0120a", "\u0120way", "\u0120to", "\u0120set", "\u0120the", "\u0120Ex", "porter", ".", "Parent", "Provider", "\u0120when", "\u0120the", "\u0120Processor", "'s", "\u0120gets", "\u0120set", ".", "\u0120Internal", "\u0120to", "\u0120SDK", "\u0120though", "."]}
{"function": "@@ -31,9 +31,13 @@ inline extractor::RoadClassification roadClass(const ConnectedRoad &road, return graph.GetEdgeData(road.eid).flags.road_classification; } -inline bool isRampClass(EdgeID eid, const util::NodeBasedDynamicGraph &node_based_graph) +inline bool isRampClass(EdgeID eid, + const util::NodeBasedDynamicGraph &node_based_graph, + bool from_motorway = true) { - return node_based_graph.GetEdgeData(eid).flags.road_classification.IsRampClass(); + return node_based_graph.GetEdgeData(eid).flags.road_classification.IsRampClass() || + (from_motorway && + node_based_graph.GetEdgeData(eid).flags.road_classification.IsLinkClass()); } } // namespace", "text": "Talking through this scenario with @srividyacb and she's wondering if there should also be a check of `(from_trunk && node_based_graph.GetEdgeData(eid).flags.road_classification.IsLinkClass())` as highways with trunk classifications can also have this scenario.", "function_tokens": ["@@", "\u0120-", "31", ",", "9", "\u0120+", "31", ",", "13", "\u0120@@", "\u0120inline", "\u0120extract", "or", "::", "Road", "Class", "ification", "\u0120road", "Class", "(", "const", "\u0120Connect", "ed", "Road", "\u0120&", "road", ",", "\u0120return", "\u0120graph", ".", "Get", "Edge", "Data", "(", "road", ".", "e", "id", ").", "flags", ".", "road", "_", "class", "ification", ";", "\u0120}", "\u0120-", "inline", "\u0120bool", "\u0120is", "R", "amp", "Class", "(", "Edge", "ID", "\u0120e", "id", ",", "\u0120const", "\u0120util", "::", "Node", "Based", "Dynamic", "Graph", "\u0120&", "node", "_", "based", "_", "graph", ")", "\u0120+", "inline", "\u0120bool", "\u0120is", "R", "amp", "Class", "(", "Edge", "ID", "\u0120e", "id", ",", "\u0120+", "\u0120const", "\u0120util", "::", "Node", "Based", "Dynamic", "Graph", "\u0120&", "node", "_", "based", "_", "graph", ",", "\u0120+", "\u0120bool", "\u0120from", "_", "m", "otor", "way", "\u0120=", "\u0120true", ")", "\u0120{", "\u0120-", "\u0120return", "\u0120node", "_", "based", "_", "graph", ".", "Get", "Edge", "Data", "(", "e", "id", ").", "flags", ".", "road", "_", "class", "ification", ".", "Is", "R", "amp", "Class", "();", "\u0120+", "\u0120return", "\u0120node", "_", "based", "_", "graph", ".", "Get", "Edge", "Data", "(", "e", "id", ").", "flags", ".", "road", "_", "class", "ification", ".", "Is", "R", "amp", "Class", "()", "\u0120||", "\u0120+", "\u0120(", "from", "_", "m", "otor", "way", "\u0120&&", "\u0120+", "\u0120node", "_", "based", "_", "graph", ".", "Get", "Edge", "Data", "(", "e", "id", ").", "flags", ".", "road", "_", "class", "ification", ".", "Is", "Link", "Class", "());", "\u0120}", "\u0120}", "\u0120//", "\u0120namespace"], "docstring_tokens": ["Talking", "\u0120through", "\u0120this", "\u0120scenario", "\u0120with", "\u0120@", "s", "riv", "idy", "ac", "b", "\u0120and", "\u0120she", "'s", "\u0120wondering", "\u0120if", "\u0120there", "\u0120should", "\u0120also", "\u0120be", "\u0120a", "\u0120check", "\u0120of", "\u0120`", "(", "from", "_", "tr", "unk", "\u0120&&", "\u0120node", "_", "based", "_", "graph", ".", "Get", "Edge", "Data", "(", "e", "id", ").", "flags", ".", "road", "_", "class", "ification", ".", "Is", "Link", "Class", "())", "`", "\u0120as", "\u0120highways", "\u0120with", "\u0120trunk", "\u0120class", "ifications", "\u0120can", "\u0120also", "\u0120have", "\u0120this", "\u0120scenario", "."]}
{"function": "@@ -13,7 +13,7 @@ module Beaker :q_verify_packages => ENV['q_verify_packages'] || 'y', :q_puppet_symlinks_install => 'y', :q_puppetagent_certname => host, - :q_puppetagent_server => master, + :q_puppetagent_server => master_certname, # Disable database, console, and master by default # This will be overridden by other blocks being merged in.", "text": "where does `master_certname` come from?", "function_tokens": ["@@", "\u0120-", "13", ",", "7", "\u0120+", "13", ",", "7", "\u0120@@", "\u0120module", "\u0120Be", "aker", "\u0120:", "q", "_", "ver", "ify", "_", "packages", "\u0120=>", "\u0120EN", "V", "['", "q", "_", "ver", "ify", "_", "packages", "']", "\u0120||", "\u0120'", "y", "',", "\u0120:", "q", "_", "p", "uppet", "_", "sym", "links", "_", "install", "\u0120=>", "\u0120'", "y", "',", "\u0120:", "q", "_", "p", "uppet", "agent", "_", "cert", "name", "\u0120=>", "\u0120host", ",", "\u0120-", "\u0120:", "q", "_", "p", "uppet", "agent", "_", "server", "\u0120=>", "\u0120master", ",", "\u0120+", "\u0120:", "q", "_", "p", "uppet", "agent", "_", "server", "\u0120=>", "\u0120master", "_", "cert", "name", ",", "\u0120#", "\u0120Disable", "\u0120database", ",", "\u0120console", ",", "\u0120and", "\u0120master", "\u0120by", "\u0120default", "\u0120#", "\u0120This", "\u0120will", "\u0120be", "\u0120overr", "idden", "\u0120by", "\u0120other", "\u0120blocks", "\u0120being", "\u0120merged", "\u0120in", "."], "docstring_tokens": ["where", "\u0120does", "\u0120`", "master", "_", "cert", "name", "`", "\u0120come", "\u0120from", "?"]}
{"function": "@@ -1,5 +1,7 @@ from .resnet import ResNet, make_res_layer from .resnext import ResNeXt from .ssd_vgg import SSDVGG +from .hrnet import HRNet -__all__ = ['ResNet', 'make_res_layer', 'ResNeXt', 'SSDVGG'] +__all__ = ['ResNet', 'make_res_layer', 'ResNeXt', 'SSDVGG', + 'HRNet']", "text": "The line breaking is unnecessary.", "function_tokens": ["@@", "\u0120-", "1", ",", "5", "\u0120+", "1", ",", "7", "\u0120@@", "\u0120from", "\u0120.", "res", "net", "\u0120import", "\u0120Res", "Net", ",", "\u0120make", "_", "res", "_", "layer", "\u0120from", "\u0120.", "res", "next", "\u0120import", "\u0120Res", "Ne", "X", "t", "\u0120from", "\u0120.", "ss", "d", "_", "v", "gg", "\u0120import", "\u0120SSD", "V", "GG", "\u0120+", "from", "\u0120.", "hr", "net", "\u0120import", "\u0120HR", "Net", "\u0120-", "__", "all", "__", "\u0120=", "\u0120['", "Res", "Net", "',", "\u0120'", "make", "_", "res", "_", "layer", "',", "\u0120'", "Res", "Ne", "X", "t", "',", "\u0120'", "SS", "D", "V", "GG", "']", "\u0120+", "__", "all", "__", "\u0120=", "\u0120['", "Res", "Net", "',", "\u0120'", "make", "_", "res", "_", "layer", "',", "\u0120'", "Res", "Ne", "X", "t", "',", "\u0120'", "SS", "D", "V", "GG", "',", "\u0120+", "\u0120'", "HR", "Net", "']"], "docstring_tokens": ["The", "\u0120line", "\u0120breaking", "\u0120is", "\u0120unnecessary", "."]}
{"function": "@@ -28,7 +28,7 @@ void DatasetLoader::SetHeader(const char* filename) { // get column names if (io_config_.has_header) { std::string first_line = text_reader.first_line(); - feature_names_ = Common::Split(first_line.c_str(), \"\\t ,\"); + feature_names_ = Common::Split(first_line.c_str(), \"\\t,\"); } // load label idx first", "text": "why not enable split by space here ?", "function_tokens": ["@@", "\u0120-", "28", ",", "7", "\u0120+", "28", ",", "7", "\u0120@@", "\u0120void", "\u0120Dat", "as", "et", "Loader", "::", "Set", "Header", "(", "const", "\u0120char", "*", "\u0120filename", ")", "\u0120{", "\u0120//", "\u0120get", "\u0120column", "\u0120names", "\u0120if", "\u0120(", "io", "_", "config", "_.", "has", "_", "header", ")", "\u0120{", "\u0120std", "::", "string", "\u0120first", "_", "line", "\u0120=", "\u0120text", "_", "reader", ".", "first", "_", "line", "();", "\u0120-", "\u0120feature", "_", "names", "_", "\u0120=", "\u0120Common", "::", "Split", "(", "first", "_", "line", ".", "c", "_", "str", "(),", "\u0120\"\\", "t", "\u0120,\"", ");", "\u0120+", "\u0120feature", "_", "names", "_", "\u0120=", "\u0120Common", "::", "Split", "(", "first", "_", "line", ".", "c", "_", "str", "(),", "\u0120\"\\", "t", ",\"", ");", "\u0120}", "\u0120//", "\u0120load", "\u0120label", "\u0120id", "x", "\u0120first"], "docstring_tokens": ["why", "\u0120not", "\u0120enable", "\u0120split", "\u0120by", "\u0120space", "\u0120here", "\u0120?"]}
{"function": "@@ -1076,7 +1076,8 @@ fpga_result mmio_error(struct RASCommandLine *rasCmdLine) return result; } - if(value != FPGA_INTEGRATED_DEVICEID) { + if( (value != FPGA_INTEGRATED_DEVICEID) || + (value != FPGA_DISCRETE_DEVICEID) ) { FPGA_ERR(\"Failed to read Device id\"); return FPGA_NOT_SUPPORTED; }", "text": "Shouldn't the operator be && ?", "function_tokens": ["@@", "\u0120-", "10", "76", ",", "7", "\u0120+", "10", "76", ",", "8", "\u0120@@", "\u0120f", "p", "ga", "_", "result", "\u0120mm", "io", "_", "error", "(", "struct", "\u0120R", "AS", "Command", "Line", "\u0120*", "ras", "Cmd", "Line", ")", "\u0120return", "\u0120result", ";", "\u0120}", "\u0120-", "\u0120if", "(", "value", "\u0120!=", "\u0120F", "PG", "A", "_", "INT", "EG", "R", "ATED", "_", "DE", "VICE", "ID", ")", "\u0120{", "\u0120+", "\u0120if", "(", "\u0120(", "value", "\u0120!=", "\u0120F", "PG", "A", "_", "INT", "EG", "R", "ATED", "_", "DE", "VICE", "ID", ")", "\u0120||", "\u0120+", "\u0120(", "value", "\u0120!=", "\u0120F", "PG", "A", "_", "DIS", "CRE", "TE", "_", "DE", "VICE", "ID", ")", "\u0120)", "\u0120{", "\u0120F", "PG", "A", "_", "ER", "R", "(\"", "F", "ailed", "\u0120to", "\u0120read", "\u0120Device", "\u0120id", "\");", "\u0120return", "\u0120F", "PG", "A", "_", "NOT", "_", "SUP", "PORT", "ED", ";", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120the", "\u0120operator", "\u0120be", "\u0120&&", "\u0120?"]}
{"function": "@@ -161,6 +161,17 @@ module Beaker FileUtils.rm_rf(@vagrant_path) end + #snapshotting depends on https://github.com/scalefactory/vagrant-multiprovider-snap + def take_snapshot(host,snapshot_name) + @logger.debug \"Creating snapshot of #{host}\" + vagrant_cmd(\"snap take #{host} --name=#{snapshot_name}\") + end + + def restore_snapshot(host,snapshot_name) + @logger.debug \"Restoring snapshot of #{host}\" + vagrant_cmd(\"snap rollback #{host} --name=#{snapshot_name}\") + end + def vagrant_cmd(args) Dir.chdir(@vagrant_path) do exit_status = 1", "text": "My best guess is that you want to use host.name in these parts to get the name of the host ?", "function_tokens": ["@@", "\u0120-", "161", ",", "6", "\u0120+", "161", ",", "17", "\u0120@@", "\u0120module", "\u0120Be", "aker", "\u0120File", "Ut", "ils", ".", "rm", "_", "rf", "(", "@", "vag", "rant", "_", "path", ")", "\u0120end", "\u0120+", "\u0120#", "snap", "shot", "ting", "\u0120depends", "\u0120on", "\u0120https", "://", "github", ".", "com", "/", "sc", "al", "ef", "actory", "/", "vag", "rant", "-", "mult", "ip", "rov", "ider", "-", "snap", "\u0120+", "\u0120def", "\u0120take", "_", "snap", "shot", "(", "host", ",", "snap", "shot", "_", "name", ")", "\u0120+", "\u0120@", "log", "ger", ".", "debug", "\u0120\"", "Creating", "\u0120snapshot", "\u0120of", "\u0120#", "{", "host", "}\"", "\u0120+", "\u0120vag", "rant", "_", "cmd", "(\"", "snap", "\u0120take", "\u0120#", "{", "host", "}", "\u0120--", "name", "=#", "{", "snap", "shot", "_", "name", "}", "\")", "\u0120+", "\u0120end", "\u0120+", "\u0120+", "\u0120def", "\u0120restore", "_", "snap", "shot", "(", "host", ",", "snap", "shot", "_", "name", ")", "\u0120+", "\u0120@", "log", "ger", ".", "debug", "\u0120\"", "Rest", "oring", "\u0120snapshot", "\u0120of", "\u0120#", "{", "host", "}\"", "\u0120+", "\u0120vag", "rant", "_", "cmd", "(\"", "snap", "\u0120roll", "back", "\u0120#", "{", "host", "}", "\u0120--", "name", "=#", "{", "snap", "shot", "_", "name", "}", "\")", "\u0120+", "\u0120end", "\u0120+", "\u0120def", "\u0120vag", "rant", "_", "cmd", "(", "args", ")", "\u0120Dir", ".", "ch", "dir", "(", "@", "vag", "rant", "_", "path", ")", "\u0120do", "\u0120exit", "_", "status", "\u0120=", "\u01201"], "docstring_tokens": ["My", "\u0120best", "\u0120guess", "\u0120is", "\u0120that", "\u0120you", "\u0120want", "\u0120to", "\u0120use", "\u0120host", ".", "name", "\u0120in", "\u0120these", "\u0120parts", "\u0120to", "\u0120get", "\u0120the", "\u0120name", "\u0120of", "\u0120the", "\u0120host", "\u0120?"]}
{"function": "@@ -270,13 +270,6 @@ func (n *Node) UnmarshalBinary(data []byte) error { n.entry = append([]byte{}, data[nodeHeaderSize:nodeHeaderSize+refBytesSize]...) offset := nodeHeaderSize + refBytesSize // skip entry - // Currently we don't persist the root nodeType when we marshal the manifest, as a result - // the root nodeType information is lost on Unmarshal. This causes issues when we want to - // perform a path 'Walk' on the root. If there is more than 1 fork, the root node type - // is an edge, so we will deduce this information from index byte array - if !bytes.Equal(data[offset:offset+32], make([]byte, 32)) { - n.nodeType = nodeTypeEdge - } n.forks = make(map[byte]*fork) bb := &bitsForBytes{} bb.fromBytes(data[offset:])", "text": "IMO this edge case handling could remain here, just instead of overwriting the `n.nodeType`, the `makeEdgeType` method of `n` should be called, so `n.nodeType = nodeTypeEdge` -> `n.makeEdge()`", "function_tokens": ["@@", "\u0120-", "270", ",", "13", "\u0120+", "270", ",", "6", "\u0120@@", "\u0120func", "\u0120(", "n", "\u0120*", "Node", ")", "\u0120Un", "m", "arsh", "al", "B", "inary", "(", "data", "\u0120[]", "byte", ")", "\u0120error", "\u0120{", "\u0120n", ".", "entry", "\u0120=", "\u0120append", "(", "[]", "byte", "{", "},", "\u0120data", "[", "node", "Header", "Size", ":", "node", "Header", "Size", "+", "ref", "Bytes", "Size", "]", "...)", "\u0120offset", "\u0120:=", "\u0120node", "Header", "Size", "\u0120+", "\u0120ref", "Bytes", "Size", "\u0120//", "\u0120skip", "\u0120entry", "\u0120-", "\u0120//", "\u0120Currently", "\u0120we", "\u0120don", "'t", "\u0120persist", "\u0120the", "\u0120root", "\u0120node", "Type", "\u0120when", "\u0120we", "\u0120marsh", "al", "\u0120the", "\u0120manifest", ",", "\u0120as", "\u0120a", "\u0120result", "\u0120-", "\u0120//", "\u0120the", "\u0120root", "\u0120node", "Type", "\u0120information", "\u0120is", "\u0120lost", "\u0120on", "\u0120Un", "m", "arsh", "al", ".", "\u0120This", "\u0120causes", "\u0120issues", "\u0120when", "\u0120we", "\u0120want", "\u0120to", "\u0120-", "\u0120//", "\u0120perform", "\u0120a", "\u0120path", "\u0120'", "Walk", "'", "\u0120on", "\u0120the", "\u0120root", ".", "\u0120If", "\u0120there", "\u0120is", "\u0120more", "\u0120than", "\u01201", "\u0120fork", ",", "\u0120the", "\u0120root", "\u0120node", "\u0120type", "\u0120-", "\u0120//", "\u0120is", "\u0120an", "\u0120edge", ",", "\u0120so", "\u0120we", "\u0120will", "\u0120ded", "uce", "\u0120this", "\u0120information", "\u0120from", "\u0120index", "\u0120byte", "\u0120array", "\u0120-", "\u0120if", "\u0120!", "bytes", ".", "E", "qual", "(", "data", "[", "offset", ":", "offset", "+", "32", "],", "\u0120make", "(", "[]", "byte", ",", "\u012032", "))", "\u0120{", "\u0120-", "\u0120n", ".", "node", "Type", "\u0120=", "\u0120node", "Type", "Edge", "\u0120-", "\u0120}", "\u0120n", ".", "for", "ks", "\u0120=", "\u0120make", "(", "map", "[", "byte", "]", "*", "fork", ")", "\u0120b", "b", "\u0120:=", "\u0120&", "bits", "For", "Bytes", "{", "}", "\u0120b", "b", ".", "from", "Bytes", "(", "data", "[", "offset", ":", "])"], "docstring_tokens": ["IM", "O", "\u0120this", "\u0120edge", "\u0120case", "\u0120handling", "\u0120could", "\u0120remain", "\u0120here", ",", "\u0120just", "\u0120instead", "\u0120of", "\u0120overw", "rit", "ing", "\u0120the", "\u0120`", "n", ".", "node", "Type", "`,", "\u0120the", "\u0120`", "make", "Edge", "Type", "`", "\u0120method", "\u0120of", "\u0120`", "n", "`", "\u0120should", "\u0120be", "\u0120called", ",", "\u0120so", "\u0120`", "n", ".", "node", "Type", "\u0120=", "\u0120node", "Type", "Edge", "`", "\u0120->", "\u0120`", "n", ".", "make", "Edge", "()", "`"]}
{"function": "@@ -205,9 +205,10 @@ public class DownloadService extends Service { Log.d(TAG, \"Service shutting down\"); isRunning = false; + boolean showAutoDownloadReport = UserPreferences.showAutoDownloadReport(); if (ClientConfig.downloadServiceCallbacks.shouldCreateReport() - && UserPreferences.showDownloadReport()) { - notificationManager.updateReport(reportQueue); + && (UserPreferences.showDownloadReport() || showAutoDownloadReport)) { + notificationManager.updateReport(reportQueue, showAutoDownloadReport); reportQueue.clear(); } ", "text": "Just wondering... The two kinds of notifications are now quite different (Channel, text, maybe even icon). Would it make sense to extract the auto download notification to a new class instead of handling everything in the existing `notificationManager`? I have not checked if this will lead to a lot of code duplication, though.", "function_tokens": ["@@", "\u0120-", "205", ",", "9", "\u0120+", "205", ",", "10", "\u0120@@", "\u0120public", "\u0120class", "\u0120Download", "Service", "\u0120extends", "\u0120Service", "\u0120{", "\u0120Log", ".", "d", "(", "TAG", ",", "\u0120\"", "Service", "\u0120shutting", "\u0120down", "\");", "\u0120is", "Running", "\u0120=", "\u0120false", ";", "\u0120+", "\u0120boolean", "\u0120show", "Auto", "Download", "Report", "\u0120=", "\u0120User", "Pref", "erences", ".", "show", "Auto", "Download", "Report", "();", "\u0120if", "\u0120(", "Client", "Config", ".", "download", "Service", "Call", "backs", ".", "should", "Create", "Report", "()", "\u0120-", "\u0120&&", "\u0120User", "Pref", "erences", ".", "show", "Download", "Report", "())", "\u0120{", "\u0120-", "\u0120notification", "Manager", ".", "update", "Report", "(", "report", "Queue", ");", "\u0120+", "\u0120&&", "\u0120(", "User", "Pref", "erences", ".", "show", "Download", "Report", "()", "\u0120||", "\u0120show", "Auto", "Download", "Report", "))", "\u0120{", "\u0120+", "\u0120notification", "Manager", ".", "update", "Report", "(", "report", "Queue", ",", "\u0120show", "Auto", "Download", "Report", ");", "\u0120report", "Queue", ".", "clear", "();", "\u0120}", "\u0120"], "docstring_tokens": ["Just", "\u0120wondering", "...", "\u0120The", "\u0120two", "\u0120kinds", "\u0120of", "\u0120notifications", "\u0120are", "\u0120now", "\u0120quite", "\u0120different", "\u0120(", "Channel", ",", "\u0120text", ",", "\u0120maybe", "\u0120even", "\u0120icon", ").", "\u0120Would", "\u0120it", "\u0120make", "\u0120sense", "\u0120to", "\u0120extract", "\u0120the", "\u0120auto", "\u0120download", "\u0120notification", "\u0120to", "\u0120a", "\u0120new", "\u0120class", "\u0120instead", "\u0120of", "\u0120handling", "\u0120everything", "\u0120in", "\u0120the", "\u0120existing", "\u0120`", "not", "ification", "Manager", "`", "?", "\u0120I", "\u0120have", "\u0120not", "\u0120checked", "\u0120if", "\u0120this", "\u0120will", "\u0120lead", "\u0120to", "\u0120a", "\u0120lot", "\u0120of", "\u0120code", "\u0120duplication", ",", "\u0120though", "."]}
{"function": "@@ -140,3 +140,11 @@ func (c *Call) RoutingDelegate() string { } return c.ic.req.RoutingDelegate } + +// Features returns the RequestFeatures for this request. +func (c *Call) Features() transport.RequestFeatures { + if c == nil { + return transport.RequestFeatures{} + } + return c.ic.req.Features +}", "text": "Do we need to put this on the Call? We only need the API communication between the Encoding and the Transports which is currently done through the Transport.Request. The Call is used by users right?", "function_tokens": ["@@", "\u0120-", "140", ",", "3", "\u0120+", "140", ",", "11", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120*", "Call", ")", "\u0120R", "outing", "De", "legate", "()", "\u0120string", "\u0120{", "\u0120}", "\u0120return", "\u0120c", ".", "ic", ".", "req", ".", "R", "outing", "De", "legate", "\u0120}", "\u0120+", "\u0120+", "//", "\u0120Features", "\u0120returns", "\u0120the", "\u0120Request", "Features", "\u0120for", "\u0120this", "\u0120request", ".", "\u0120+", "func", "\u0120(", "c", "\u0120*", "Call", ")", "\u0120Features", "()", "\u0120transport", ".", "Request", "Features", "\u0120{", "\u0120+", "\u0120if", "\u0120c", "\u0120==", "\u0120nil", "\u0120{", "\u0120+", "\u0120return", "\u0120transport", ".", "Request", "Features", "{", "}", "\u0120+", "\u0120}", "\u0120+", "\u0120return", "\u0120c", ".", "ic", ".", "req", ".", "Features", "\u0120+", "}"], "docstring_tokens": ["Do", "\u0120we", "\u0120need", "\u0120to", "\u0120put", "\u0120this", "\u0120on", "\u0120the", "\u0120Call", "?", "\u0120We", "\u0120only", "\u0120need", "\u0120the", "\u0120API", "\u0120communication", "\u0120between", "\u0120the", "\u0120Enc", "oding", "\u0120and", "\u0120the", "\u0120Trans", "ports", "\u0120which", "\u0120is", "\u0120currently", "\u0120done", "\u0120through", "\u0120the", "\u0120Transport", ".", "Request", ".", "\u0120The", "\u0120Call", "\u0120is", "\u0120used", "\u0120by", "\u0120users", "\u0120right", "?"]}
{"function": "@@ -1202,3 +1202,15 @@ L: } return filtered } + +func (a *WebAPI) GenerateAPIKey(ctx context.Context, req *webservice.GenerateAPIKeyRequest) (*webservice.GenerateAPIKeyResponse, error) { + return nil, status.Error(codes.Unimplemented, \"\") +} + +func (a *WebAPI) DisableAPIKey(ctx context.Context, req *webservice.DisableAPIKeyRequest) (*webservice.DisableAPIKeyResponse, error) { + return nil, status.Error(codes.Unimplemented, \"\") +} + +func (a *WebAPI) ListAPIKeys(ctx context.Context, req *webservice.ListAPIKeysRequest) (*webservice.ListAPIKeysResponse, error) { + return nil, status.Error(codes.Unimplemented, \"\") +}", "text": "`ctx` is unused in GenerateAPIKey", "function_tokens": ["@@", "\u0120-", "12", "02", ",", "3", "\u0120+", "12", "02", ",", "15", "\u0120@@", "\u0120L", ":", "\u0120}", "\u0120return", "\u0120filtered", "\u0120}", "\u0120+", "\u0120+", "func", "\u0120(", "a", "\u0120*", "Web", "API", ")", "\u0120Gener", "ate", "API", "Key", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120req", "\u0120*", "we", "bs", "erv", "ice", ".", "Gener", "ate", "API", "Key", "Request", ")", "\u0120(*", "we", "bs", "erv", "ice", ".", "Gener", "ate", "API", "Key", "Response", ",", "\u0120error", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120nil", ",", "\u0120status", ".", "Error", "(", "codes", ".", "Un", "im", "ple", "mented", ",", "\u0120\"", "\")", "\u0120+", "}", "\u0120+", "\u0120+", "func", "\u0120(", "a", "\u0120*", "Web", "API", ")", "\u0120Disable", "API", "Key", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120req", "\u0120*", "we", "bs", "erv", "ice", ".", "Disable", "API", "Key", "Request", ")", "\u0120(*", "we", "bs", "erv", "ice", ".", "Disable", "API", "Key", "Response", ",", "\u0120error", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120nil", ",", "\u0120status", ".", "Error", "(", "codes", ".", "Un", "im", "ple", "mented", ",", "\u0120\"", "\")", "\u0120+", "}", "\u0120+", "\u0120+", "func", "\u0120(", "a", "\u0120*", "Web", "API", ")", "\u0120List", "API", "Keys", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120req", "\u0120*", "we", "bs", "erv", "ice", ".", "List", "API", "Keys", "Request", ")", "\u0120(*", "we", "bs", "erv", "ice", ".", "List", "API", "Keys", "Response", ",", "\u0120error", ")", "\u0120{", "\u0120+", "\u0120return", "\u0120nil", ",", "\u0120status", ".", "Error", "(", "codes", ".", "Un", "im", "ple", "mented", ",", "\u0120\"", "\")", "\u0120+", "}"], "docstring_tokens": ["`", "ctx", "`", "\u0120is", "\u0120unused", "\u0120in", "\u0120Gener", "ate", "API", "Key"]}
{"function": "@@ -75,6 +75,7 @@ type ( func NewBlockDAO(indexers []BlockIndexer, cfg config.DB) BlockDAO { blkStore, err := filedao.NewFileDAO(cfg) if err != nil { + log.L().Fatal(err.Error(), zap.Any(\"cfg\", cfg)) return nil } return createBlockDAO(blkStore, indexers, cfg)", "text": "Can you judge the type of error?", "function_tokens": ["@@", "\u0120-", "75", ",", "6", "\u0120+", "75", ",", "7", "\u0120@@", "\u0120type", "\u0120(", "\u0120func", "\u0120New", "Block", "DA", "O", "(", "index", "ers", "\u0120[]", "Block", "Index", "er", ",", "\u0120cf", "g", "\u0120config", ".", "DB", ")", "\u0120Block", "DA", "O", "\u0120{", "\u0120bl", "k", "Store", ",", "\u0120err", "\u0120:=", "\u0120filed", "ao", ".", "New", "File", "DA", "O", "(", "cfg", ")", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120+", "\u0120log", ".", "L", "().", "F", "atal", "(", "err", ".", "Error", "(),", "\u0120z", "ap", ".", "Any", "(\"", "cfg", "\",", "\u0120cf", "g", "))", "\u0120return", "\u0120nil", "\u0120}", "\u0120return", "\u0120create", "Block", "DA", "O", "(", "bl", "k", "Store", ",", "\u0120index", "ers", ",", "\u0120cf", "g", ")"], "docstring_tokens": ["Can", "\u0120you", "\u0120judge", "\u0120the", "\u0120type", "\u0120of", "\u0120error", "?"]}
{"function": "@@ -204,7 +204,7 @@ class GridInterface(DictInterface): if edges and not isedges: data = cls._infer_interval_breaks(data) elif not edges and isedges: - data = np.convolve(data, [0.5, 0.5], 'valid') + data = data[:-1] + np.diff(data)/2. return data ", "text": "Much simpler than a weird and confusing ``convolve`` call!", "function_tokens": ["@@", "\u0120-", "204", ",", "7", "\u0120+", "204", ",", "7", "\u0120@@", "\u0120class", "\u0120Grid", "Interface", "(", "D", "ict", "Interface", "):", "\u0120if", "\u0120edges", "\u0120and", "\u0120not", "\u0120is", "ed", "ges", ":", "\u0120data", "\u0120=", "\u0120cl", "s", "._", "in", "fer", "_", "inter", "val", "_", "breaks", "(", "data", ")", "\u0120el", "if", "\u0120not", "\u0120edges", "\u0120and", "\u0120is", "ed", "ges", ":", "\u0120-", "\u0120data", "\u0120=", "\u0120np", ".", "conv", "olve", "(", "data", ",", "\u0120[", "0", ".", "5", ",", "\u01200", ".", "5", "],", "\u0120'", "valid", "')", "\u0120+", "\u0120data", "\u0120=", "\u0120data", "[", ":-", "1", "]", "\u0120+", "\u0120np", ".", "diff", "(", "data", ")/", "2", ".", "\u0120return", "\u0120data", "\u0120"], "docstring_tokens": ["Much", "\u0120simpler", "\u0120than", "\u0120a", "\u0120weird", "\u0120and", "\u0120confusing", "\u0120``", "conv", "olve", "``", "\u0120call", "!"]}
{"function": "@@ -739,8 +739,8 @@ describe('suspense', () => { expect(scratch.innerHTML).to.eql( `<div>Hello first 2</div><div>Hello second 2</div>` ); - expect(Suspender1.prototype.render).to.have.been.calledThrice; - expect(Suspender2.prototype.render).to.have.been.calledThrice; + expect(Suspender1.prototype.render).to.have.been.calledTwice; + expect(Suspender2.prototype.render).to.have.been.calledTwice; }); }); });", "text": "Huh, this seems weird to me... Surely the suspenders render was called again in order to get the new `<div>Hello second 2</div>` output... Imma take a peak at these tests to understand what's going on", "function_tokens": ["@@", "\u0120-", "7", "39", ",", "8", "\u0120+", "7", "39", ",", "8", "\u0120@@", "\u0120describe", "('", "susp", "ense", "',", "\u0120()", "\u0120=>", "\u0120{", "\u0120expect", "(", "sc", "ratch", ".", "inner", "HTML", ").", "to", ".", "e", "ql", "(", "\u0120`", "<", "div", ">", "Hello", "\u0120first", "\u01202", "</", "div", "><", "div", ">", "Hello", "\u0120second", "\u01202", "</", "div", ">", "`", "\u0120);", "\u0120-", "\u0120expect", "(", "S", "usp", "ender", "1", ".", "prototype", ".", "render", ").", "to", ".", "have", ".", "been", ".", "called", "Th", "rice", ";", "\u0120-", "\u0120expect", "(", "S", "usp", "ender", "2", ".", "prototype", ".", "render", ").", "to", ".", "have", ".", "been", ".", "called", "Th", "rice", ";", "\u0120+", "\u0120expect", "(", "S", "usp", "ender", "1", ".", "prototype", ".", "render", ").", "to", ".", "have", ".", "been", ".", "called", "Tw", "ice", ";", "\u0120+", "\u0120expect", "(", "S", "usp", "ender", "2", ".", "prototype", ".", "render", ").", "to", ".", "have", ".", "been", ".", "called", "Tw", "ice", ";", "\u0120});", "\u0120});", "\u0120});"], "docstring_tokens": ["Huh", ",", "\u0120this", "\u0120seems", "\u0120weird", "\u0120to", "\u0120me", "...", "\u0120Surely", "\u0120the", "\u0120susp", "enders", "\u0120render", "\u0120was", "\u0120called", "\u0120again", "\u0120in", "\u0120order", "\u0120to", "\u0120get", "\u0120the", "\u0120new", "\u0120`", "<", "div", ">", "Hello", "\u0120second", "\u01202", "</", "div", ">", "`", "\u0120output", "...", "\u0120Im", "ma", "\u0120take", "\u0120a", "\u0120peak", "\u0120at", "\u0120these", "\u0120tests", "\u0120to", "\u0120understand", "\u0120what", "'s", "\u0120going", "\u0120on"]}
{"function": "@@ -80,6 +80,10 @@ class ApplicationController < ActionController::Base def failed_destroy_error(obj, obj_name) \"#{_('Could not delete the %{o}.') % {o: obj_name}} #{errors_to_s(obj)}\" end + + def success_message(obj_name, action) + \"#{_('Successfully %{action} your %{object}.') % {object: obj_name, action: action}}\" + end private # Override rails default render action to look for a branded version of a", "text": "Since this is just a helper function to create text, perhaps this could live in a helper? I noticed that we have a few other error/message creators in the application controller as well, but I think this type of function should be re-factored to be part of a helper.", "function_tokens": ["@@", "\u0120-", "80", ",", "6", "\u0120+", "80", ",", "10", "\u0120@@", "\u0120class", "\u0120Application", "Controller", "\u0120<", "\u0120Action", "Controller", "::", "Base", "\u0120def", "\u0120failed", "_", "destroy", "_", "error", "(", "obj", ",", "\u0120obj", "_", "name", ")", "\u0120\"#", "{", "_", "('", "Could", "\u0120not", "\u0120delete", "\u0120the", "\u0120%", "{", "o", "}", ".'", ")", "\u0120%", "\u0120{", "o", ":", "\u0120obj", "_", "name", "}}", "\u0120#", "{", "errors", "_", "to", "_", "s", "(", "obj", ")", "}\"", "\u0120end", "\u0120+", "\u0120+", "\u0120def", "\u0120success", "_", "message", "(", "obj", "_", "name", ",", "\u0120action", ")", "\u0120+", "\u0120\"#", "{", "_", "('", "Success", "fully", "\u0120%", "{", "action", "}", "\u0120your", "\u0120%", "{", "object", "}", ".'", ")", "\u0120%", "\u0120{", "object", ":", "\u0120obj", "_", "name", ",", "\u0120action", ":", "\u0120action", "}}", "\"", "\u0120+", "\u0120end", "\u0120private", "\u0120#", "\u0120Over", "ride", "\u0120rails", "\u0120default", "\u0120render", "\u0120action", "\u0120to", "\u0120look", "\u0120for", "\u0120a", "\u0120branded", "\u0120version", "\u0120of", "\u0120a"], "docstring_tokens": ["Since", "\u0120this", "\u0120is", "\u0120just", "\u0120a", "\u0120helper", "\u0120function", "\u0120to", "\u0120create", "\u0120text", ",", "\u0120perhaps", "\u0120this", "\u0120could", "\u0120live", "\u0120in", "\u0120a", "\u0120helper", "?", "\u0120I", "\u0120noticed", "\u0120that", "\u0120we", "\u0120have", "\u0120a", "\u0120few", "\u0120other", "\u0120error", "/", "message", "\u0120creators", "\u0120in", "\u0120the", "\u0120application", "\u0120controller", "\u0120as", "\u0120well", ",", "\u0120but", "\u0120I", "\u0120think", "\u0120this", "\u0120type", "\u0120of", "\u0120function", "\u0120should", "\u0120be", "\u0120re", "-", "fact", "ored", "\u0120to", "\u0120be", "\u0120part", "\u0120of", "\u0120a", "\u0120helper", "."]}
{"function": "@@ -92,7 +92,7 @@ evaluation=10.0 - ((float(5 * error + warning + refactor + convention) / stateme # Template used to display messages. This is a python new-style format string # used to format the message information. See doc for all details -#msg-template= +msg-template=[{msg_id}] {path}:{line:3d}:{column}: {msg} [SPELLING]", "text": "Will this mess up parsing the messages by other editors? (vscode, vim ...)", "function_tokens": ["@@", "\u0120-", "92", ",", "7", "\u0120+", "92", ",", "7", "\u0120@@", "\u0120evaluation", "=", "10", ".", "0", "\u0120-", "\u0120((", "float", "(", "5", "\u0120*", "\u0120error", "\u0120+", "\u0120warning", "\u0120+", "\u0120ref", "actor", "\u0120+", "\u0120convention", ")", "\u0120/", "\u0120stat", "eme", "\u0120#", "\u0120Template", "\u0120used", "\u0120to", "\u0120display", "\u0120messages", ".", "\u0120This", "\u0120is", "\u0120a", "\u0120python", "\u0120new", "-", "style", "\u0120format", "\u0120string", "\u0120#", "\u0120used", "\u0120to", "\u0120format", "\u0120the", "\u0120message", "\u0120information", ".", "\u0120See", "\u0120doc", "\u0120for", "\u0120all", "\u0120details", "\u0120-", "#", "msg", "-", "template", "=", "\u0120+", "msg", "-", "template", "=[", "{", "msg", "_", "id", "}", "]", "\u0120{", "path", "}", ":{", "line", ":", "3", "d", "}", ":{", "column", "}:", "\u0120{", "msg", "}", "\u0120[", "SP", "ELL", "ING", "]"], "docstring_tokens": ["Will", "\u0120this", "\u0120mess", "\u0120up", "\u0120parsing", "\u0120the", "\u0120messages", "\u0120by", "\u0120other", "\u0120editors", "?", "\u0120(", "v", "sc", "ode", ",", "\u0120vim", "\u0120...", ")"]}
{"function": "@@ -1,4 +1,3 @@ -# Set up gems listed in the Gemfile. -ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__) +ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__) -require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE']) +require 'bundler/setup' # Set up gems listed in the Gemfile.", "text": "Style/StringLiterals: Prefer double-quoted strings unless you need single quotes to avoid extra backslashes for escaping.", "function_tokens": ["@@", "\u0120-", "1", ",", "4", "\u0120+", "1", ",", "3", "\u0120@@", "\u0120-", "#", "\u0120Set", "\u0120up", "\u0120gems", "\u0120listed", "\u0120in", "\u0120the", "\u0120Gem", "file", ".", "\u0120-", "EN", "V", "['", "B", "UN", "D", "LE", "_", "G", "EM", "FILE", "']", "\u0120||", "=", "\u0120File", ".", "exp", "and", "_", "path", "('", "../", "../", "G", "em", "file", "',", "\u0120__", "FILE", "__", ")", "\u0120+", "EN", "V", "['", "B", "UN", "D", "LE", "_", "G", "EM", "FILE", "']", "\u0120||", "=", "\u0120File", ".", "exp", "and", "_", "path", "('", "../", "G", "em", "file", "',", "\u0120__", "dir", "__", ")", "\u0120-", "require", "\u0120'", "b", "und", "ler", "/", "setup", "'", "\u0120if", "\u0120File", ".", "ex", "ists", "?", "(", "EN", "V", "['", "B", "UN", "D", "LE", "_", "G", "EM", "FILE", "'", "])", "\u0120+", "require", "\u0120'", "b", "und", "ler", "/", "setup", "'", "\u0120#", "\u0120Set", "\u0120up", "\u0120gems", "\u0120listed", "\u0120in", "\u0120the", "\u0120Gem", "file", "."], "docstring_tokens": ["Style", "/", "String", "Liter", "als", ":", "\u0120Pre", "fer", "\u0120double", "-", "qu", "oted", "\u0120strings", "\u0120unless", "\u0120you", "\u0120need", "\u0120single", "\u0120quotes", "\u0120to", "\u0120avoid", "\u0120extra", "\u0120back", "sl", "ashes", "\u0120for", "\u0120escaping", "."]}
{"function": "@@ -28,8 +28,13 @@ namespace Microsoft.AspNet.Server.Kestrel.Filter _filteredStream = filteredStream; _socketInputStream = new SocketInputStream(SocketInput); - _filteredStream.CopyToAsync(_socketInputStream).ContinueWith((task, state) => + var block = memory.Lease(); + // Use pooled block for copy + _filteredStream.CopyToAsync(_socketInputStream, block).ContinueWith((task, state) => { + var returnedBlock = task.Result; + returnedBlock.Pool?.Return(returnedBlock); + ((FilteredStreamAdapter)state).OnStreamClose(task); }, this); }", "text": "Why can the pool be null?", "function_tokens": ["@@", "\u0120-", "28", ",", "8", "\u0120+", "28", ",", "13", "\u0120@@", "\u0120namespace", "\u0120Microsoft", ".", "As", "p", "Net", ".", "Server", ".", "K", "est", "rel", ".", "Filter", "\u0120_", "fil", "tered", "Stream", "\u0120=", "\u0120filtered", "Stream", ";", "\u0120_", "socket", "Input", "Stream", "\u0120=", "\u0120new", "\u0120Socket", "Input", "Stream", "(", "Socket", "Input", ");", "\u0120-", "\u0120_", "fil", "tered", "Stream", ".", "Copy", "To", "Async", "(_", "socket", "Input", "Stream", ").", "Continue", "With", "((", "task", ",", "\u0120state", ")", "\u0120=>", "\u0120+", "\u0120var", "\u0120block", "\u0120=", "\u0120memory", ".", "Le", "ase", "();", "\u0120+", "\u0120//", "\u0120Use", "\u0120pooled", "\u0120block", "\u0120for", "\u0120copy", "\u0120+", "\u0120_", "fil", "tered", "Stream", ".", "Copy", "To", "Async", "(_", "socket", "Input", "Stream", ",", "\u0120block", ").", "Continue", "With", "((", "task", ",", "\u0120state", ")", "\u0120=>", "\u0120{", "\u0120+", "\u0120var", "\u0120returned", "Block", "\u0120=", "\u0120task", ".", "Result", ";", "\u0120+", "\u0120returned", "Block", ".", "Pool", "?", ".", "Return", "(", "return", "ed", "Block", ");", "\u0120+", "\u0120((", "Fil", "tered", "Stream", "Adapter", ")", "state", ").", "On", "Stream", "Close", "(", "task", ");", "\u0120},", "\u0120this", ");", "\u0120}"], "docstring_tokens": ["Why", "\u0120can", "\u0120the", "\u0120pool", "\u0120be", "\u0120null", "?"]}
{"function": "@@ -74,6 +74,15 @@ class ToggleButton(ia2Web.Ia2Web): return states +class PresentationalList(ia2Web.Ia2Web): + \"\"\" Ensures that lists like UL, DL and OL always have the readonly state.\"\"\" + + def _get_states(self): + states = super().states + states.add(controlTypes.STATE_READONLY) + return states + + def findExtraOverlayClasses(obj, clsList): \"\"\"Determine the most appropriate class(es) for Chromium objects. This works similarly to L{NVDAObjects.NVDAObject.findOverlayClasses} except that it never calls any other findOverlayClasses method.", "text": "It might be good to have a note here: > work-around for issue #7562 allowing us to differentiate presentational lists from interactive lists (such as of size greater 1 and ARIA list boxes). In firefox, this is possible by the presence of a read-only state, even in content editable.", "function_tokens": ["@@", "\u0120-", "74", ",", "6", "\u0120+", "74", ",", "15", "\u0120@@", "\u0120class", "\u0120Toggle", "Button", "(", "ia", "2", "Web", ".", "I", "a", "2", "Web", "):", "\u0120return", "\u0120states", "\u0120+", "class", "\u0120Present", "ational", "List", "(", "ia", "2", "Web", ".", "I", "a", "2", "Web", "):", "\u0120+", "\u0120\"\"\"", "\u0120Ens", "ures", "\u0120that", "\u0120lists", "\u0120like", "\u0120UL", ",", "\u0120DL", "\u0120and", "\u0120OL", "\u0120always", "\u0120have", "\u0120the", "\u0120read", "only", "\u0120state", ".\"", "\"\"", "\u0120+", "\u0120+", "\u0120def", "\u0120_", "get", "_", "states", "(", "self", "):", "\u0120+", "\u0120states", "\u0120=", "\u0120super", "().", "states", "\u0120+", "\u0120states", ".", "add", "(", "control", "Types", ".", "STATE", "_", "READ", "ON", "LY", ")", "\u0120+", "\u0120return", "\u0120states", "\u0120+", "\u0120+", "\u0120def", "\u0120find", "Extra", "Over", "lay", "Class", "es", "(", "obj", ",", "\u0120cl", "s", "List", "):", "\u0120\"\"\"", "D", "eter", "mine", "\u0120the", "\u0120most", "\u0120appropriate", "\u0120class", "(", "es", ")", "\u0120for", "\u0120Chrom", "ium", "\u0120objects", ".", "\u0120This", "\u0120works", "\u0120similarly", "\u0120to", "\u0120L", "{", "NV", "DA", "Object", "s", ".", "NV", "DA", "Object", ".", "find", "Over", "lay", "Class", "es", "}", "\u0120except", "\u0120that", "\u0120it", "\u0120never", "\u0120calls", "\u0120any", "\u0120other", "\u0120find", "Over", "lay", "Class", "es", "\u0120method", "."], "docstring_tokens": ["It", "\u0120might", "\u0120be", "\u0120good", "\u0120to", "\u0120have", "\u0120a", "\u0120note", "\u0120here", ":", "\u0120>", "\u0120work", "-", "around", "\u0120for", "\u0120issue", "\u0120#", "75", "62", "\u0120allowing", "\u0120us", "\u0120to", "\u0120differentiate", "\u0120present", "ational", "\u0120lists", "\u0120from", "\u0120interactive", "\u0120lists", "\u0120(", "such", "\u0120as", "\u0120of", "\u0120size", "\u0120greater", "\u01201", "\u0120and", "\u0120AR", "IA", "\u0120list", "\u0120boxes", ").", "\u0120In", "\u0120fire", "fox", ",", "\u0120this", "\u0120is", "\u0120possible", "\u0120by", "\u0120the", "\u0120presence", "\u0120of", "\u0120a", "\u0120read", "-", "only", "\u0120state", ",", "\u0120even", "\u0120in", "\u0120content", "\u0120edit", "able", "."]}
{"function": "@@ -66,16 +66,16 @@ import java.util.Set; * the current node) may be queried. * */ -class DigraphNode implements Cloneable, Serializable { +class DigraphNode<E> implements Cloneable, Serializable { /** The data associated with this node. */ - protected Object data; + protected E data; /** * A <code>Set</code> of neighboring nodes pointed to by this * node. */ - protected Set outNodes = new HashSet(); + protected Set<DigraphNode<E>> outNodes = new HashSet<>(); /** The in-degree of the node. */ protected int inDegree = 0;", "text": "This set of changes is the one part of this that I'm not completely sure is valid. Can someone look over this to make sure I got the E's right?", "function_tokens": ["@@", "\u0120-", "66", ",", "16", "\u0120+", "66", ",", "16", "\u0120@@", "\u0120import", "\u0120java", ".", "util", ".", "Set", ";", "\u0120*", "\u0120the", "\u0120current", "\u0120node", ")", "\u0120may", "\u0120be", "\u0120quer", "ied", ".", "\u0120*", "\u0120*/", "\u0120-", "class", "\u0120Dig", "raph", "Node", "\u0120implements", "\u0120Clone", "able", ",", "\u0120Serial", "izable", "\u0120{", "\u0120+", "class", "\u0120Dig", "raph", "Node", "<", "E", ">", "\u0120implements", "\u0120Clone", "able", ",", "\u0120Serial", "izable", "\u0120{", "\u0120/**", "\u0120The", "\u0120data", "\u0120associated", "\u0120with", "\u0120this", "\u0120node", ".", "\u0120*/", "\u0120-", "\u0120protected", "\u0120Object", "\u0120data", ";", "\u0120+", "\u0120protected", "\u0120E", "\u0120data", ";", "\u0120/**", "\u0120*", "\u0120A", "\u0120<", "code", ">", "Set", "</", "code", ">", "\u0120of", "\u0120neighboring", "\u0120nodes", "\u0120pointed", "\u0120to", "\u0120by", "\u0120this", "\u0120*", "\u0120node", ".", "\u0120*/", "\u0120-", "\u0120protected", "\u0120Set", "\u0120out", "N", "odes", "\u0120=", "\u0120new", "\u0120Hash", "Set", "();", "\u0120+", "\u0120protected", "\u0120Set", "<", "Dig", "raph", "Node", "<", "E", ">>", "\u0120out", "N", "odes", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120/**", "\u0120The", "\u0120in", "-", "degree", "\u0120of", "\u0120the", "\u0120node", ".", "\u0120*/", "\u0120protected", "\u0120int", "\u0120in", "D", "eg", "ree", "\u0120=", "\u01200", ";"], "docstring_tokens": ["This", "\u0120set", "\u0120of", "\u0120changes", "\u0120is", "\u0120the", "\u0120one", "\u0120part", "\u0120of", "\u0120this", "\u0120that", "\u0120I", "'m", "\u0120not", "\u0120completely", "\u0120sure", "\u0120is", "\u0120valid", ".", "\u0120Can", "\u0120someone", "\u0120look", "\u0120over", "\u0120this", "\u0120to", "\u0120make", "\u0120sure", "\u0120I", "\u0120got", "\u0120the", "\u0120E", "'s", "\u0120right", "?"]}
{"function": "@@ -282,8 +282,12 @@ void nano::bootstrap_attempt_legacy::request_push (nano::unique_lock<std::mutex> void nano::bootstrap_attempt_legacy::add_frontier (nano::pull_info const & pull_a) { nano::pull_info pull (pull_a); - nano::lock_guard<std::mutex> lock (mutex); - frontier_pulls.push_back (pull); + // Prevent incorrent or malicious pulls with frontier 0 insertion + if (!pull.head.is_zero ()) + { + nano::lock_guard<std::mutex> lock (mutex); + frontier_pulls.push_back (pull); + } } void nano::bootstrap_attempt_legacy::add_bulk_push_target (nano::block_hash const & head, nano::block_hash const & end)", "text": "There doesn't seem to be a reason to copy this here.", "function_tokens": ["@@", "\u0120-", "282", ",", "8", "\u0120+", "282", ",", "12", "\u0120@@", "\u0120void", "\u0120nano", "::", "boot", "strap", "_", "att", "empt", "_", "leg", "acy", "::", "request", "_", "push", "\u0120(", "n", "ano", "::", "unique", "_", "lock", "<", "std", "::", "mut", "ex", ">", "\u0120void", "\u0120nano", "::", "boot", "strap", "_", "att", "empt", "_", "leg", "acy", "::", "add", "_", "front", "ier", "\u0120(", "n", "ano", "::", "pull", "_", "info", "\u0120const", "\u0120&", "\u0120pull", "_", "a", ")", "\u0120{", "\u0120nano", "::", "pull", "_", "info", "\u0120pull", "\u0120(", "pull", "_", "a", ");", "\u0120-", "\u0120nano", "::", "lock", "_", "guard", "<", "std", "::", "mut", "ex", ">", "\u0120lock", "\u0120(", "mut", "ex", ");", "\u0120-", "\u0120frontier", "_", "pull", "s", ".", "push", "_", "back", "\u0120(", "pull", ");", "\u0120+", "\u0120//", "\u0120Prevent", "\u0120incor", "rent", "\u0120or", "\u0120malicious", "\u0120pulls", "\u0120with", "\u0120frontier", "\u01200", "\u0120insertion", "\u0120+", "\u0120if", "\u0120(!", "pull", ".", "head", ".", "is", "_", "zero", "\u0120())", "\u0120+", "\u0120{", "\u0120+", "\u0120nano", "::", "lock", "_", "guard", "<", "std", "::", "mut", "ex", ">", "\u0120lock", "\u0120(", "mut", "ex", ");", "\u0120+", "\u0120frontier", "_", "pull", "s", ".", "push", "_", "back", "\u0120(", "pull", ");", "\u0120+", "\u0120}", "\u0120}", "\u0120void", "\u0120nano", "::", "boot", "strap", "_", "att", "empt", "_", "leg", "acy", "::", "add", "_", "b", "ulk", "_", "push", "_", "target", "\u0120(", "n", "ano", "::", "block", "_", "hash", "\u0120const", "\u0120&", "\u0120head", ",", "\u0120nano", "::", "block", "_", "hash", "\u0120const", "\u0120&", "\u0120end", ")"], "docstring_tokens": ["There", "\u0120doesn", "'t", "\u0120seem", "\u0120to", "\u0120be", "\u0120a", "\u0120reason", "\u0120to", "\u0120copy", "\u0120this", "\u0120here", "."]}
{"function": "@@ -1774,6 +1774,7 @@ std::string h2o_raw_tracer::bpf_text() { #include <linux/sched.h> #include <linux/limits.h> +#include \"include/h2o/ebpf.h\" #define STR_LEN 64 ", "text": "We've avoided including h2o headers in BPF programs because it's a runtime dependency. However, IIRC, this is because h2olog was maintained in the separate repository so that h2olog did not know where h2o was installed. Now h2olog can use `H2O_ROOT`, we should add it to BCC's `cflags` in order to include h2o headers in BPF programs.", "function_tokens": ["@@", "\u0120-", "17", "74", ",", "6", "\u0120+", "17", "74", ",", "7", "\u0120@@", "\u0120std", "::", "string", "\u0120h", "2", "o", "_", "raw", "_", "tr", "acer", "::", "bp", "f", "_", "text", "()", "\u0120{", "\u0120#", "include", "\u0120<", "linux", "/", "sc", "hed", ".", "h", ">", "\u0120#", "include", "\u0120<", "linux", "/", "limits", ".", "h", ">", "\u0120+#", "include", "\u0120\"", "include", "/", "h", "2", "o", "/", "eb", "p", "f", ".", "h", "\"", "\u0120#", "define", "\u0120STR", "_", "L", "EN", "\u012064", "\u0120"], "docstring_tokens": ["We", "'ve", "\u0120avoided", "\u0120including", "\u0120h", "2", "o", "\u0120headers", "\u0120in", "\u0120BP", "F", "\u0120programs", "\u0120because", "\u0120it", "'s", "\u0120a", "\u0120runtime", "\u0120dependency", ".", "\u0120However", ",", "\u0120II", "RC", ",", "\u0120this", "\u0120is", "\u0120because", "\u0120h", "2", "olog", "\u0120was", "\u0120maintained", "\u0120in", "\u0120the", "\u0120separate", "\u0120repository", "\u0120so", "\u0120that", "\u0120h", "2", "olog", "\u0120did", "\u0120not", "\u0120know", "\u0120where", "\u0120h", "2", "o", "\u0120was", "\u0120installed", ".", "\u0120Now", "\u0120h", "2", "olog", "\u0120can", "\u0120use", "\u0120`", "H", "2", "O", "_", "RO", "OT", "`,", "\u0120we", "\u0120should", "\u0120add", "\u0120it", "\u0120to", "\u0120BCC", "'s", "\u0120`", "c", "flags", "`", "\u0120in", "\u0120order", "\u0120to", "\u0120include", "\u0120h", "2", "o", "\u0120headers", "\u0120in", "\u0120BP", "F", "\u0120programs", "."]}
{"function": "@@ -170,6 +170,10 @@ type ThanosRulerSpec struct { // Note: Currently only the CAFile, CertFile, and KeyFile fields are supported. // Maps to the '--grpc-server-tls-*' CLI args. GRPCServerTLSConfig *TLSConfig `json:\"grpcServerTlsConfig,omitempty\"` + // The external Query URL the Thanos Ruler will set in the 'Source' field + // of all alerts. + // Maps to the '--alert.query-url' CLI arg. + AlertQueryURL string `json:\"alertQueryUrl,omitempty\"` } // ThanosRulerStatus is the most recent observed status of the ThanosRuler. Read-only. Not", "text": "I think the docstring here should include the CLI arg `--alert.query-url` just to make it clear to users which setting this uses.", "function_tokens": ["@@", "\u0120-", "170", ",", "6", "\u0120+", "170", ",", "10", "\u0120@@", "\u0120type", "\u0120Than", "os", "R", "uler", "Spec", "\u0120struct", "\u0120{", "\u0120//", "\u0120Note", ":", "\u0120Currently", "\u0120only", "\u0120the", "\u0120CA", "File", ",", "\u0120Cert", "File", ",", "\u0120and", "\u0120Key", "File", "\u0120fields", "\u0120are", "\u0120supported", ".", "\u0120//", "\u0120Maps", "\u0120to", "\u0120the", "\u0120'", "--", "gr", "pc", "-", "server", "-", "t", "ls", "-", "*", "'", "\u0120CLI", "\u0120args", ".", "\u0120GR", "PC", "Server", "T", "LS", "Config", "\u0120*", "T", "LS", "Config", "\u0120`", "json", ":\"", "gr", "pc", "Server", "T", "ls", "Config", ",", "om", "it", "empty", "\"", "`", "\u0120+", "\u0120//", "\u0120The", "\u0120external", "\u0120Query", "\u0120URL", "\u0120the", "\u0120Than", "os", "\u0120Ruler", "\u0120will", "\u0120set", "\u0120in", "\u0120the", "\u0120'", "Source", "'", "\u0120field", "\u0120+", "\u0120//", "\u0120of", "\u0120all", "\u0120alerts", ".", "\u0120+", "\u0120//", "\u0120Maps", "\u0120to", "\u0120the", "\u0120'", "--", "alert", ".", "query", "-", "url", "'", "\u0120CLI", "\u0120arg", ".", "\u0120+", "\u0120Alert", "Query", "URL", "\u0120string", "\u0120`", "json", ":\"", "alert", "Query", "Url", ",", "om", "it", "empty", "\"", "`", "\u0120}", "\u0120//", "\u0120Than", "os", "R", "uler", "Status", "\u0120is", "\u0120the", "\u0120most", "\u0120recent", "\u0120observed", "\u0120status", "\u0120of", "\u0120the", "\u0120Than", "os", "R", "uler", ".", "\u0120Read", "-", "only", ".", "\u0120Not"], "docstring_tokens": ["I", "\u0120think", "\u0120the", "\u0120doc", "string", "\u0120here", "\u0120should", "\u0120include", "\u0120the", "\u0120CLI", "\u0120arg", "\u0120`", "--", "alert", ".", "query", "-", "url", "`", "\u0120just", "\u0120to", "\u0120make", "\u0120it", "\u0120clear", "\u0120to", "\u0120users", "\u0120which", "\u0120setting", "\u0120this", "\u0120uses", "."]}
{"function": "@@ -224,9 +224,7 @@ func (m *ipipManager) CompleteDeferredWork() error { for _, ip := range m.activeHostnameToIP { members = append(members, ip) } - for _, ip := range m.externalNodeCIDRs { - members = append(members, ip) - } + members = append(members, m.externalNodeCIDRs...) m.ipsetsDataplane.AddOrReplaceIPSet(m.ipSetMetadata, members) m.ipSetInSync = true }", "text": "Same change just above?", "function_tokens": ["@@", "\u0120-", "224", ",", "9", "\u0120+", "224", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "m", "\u0120*", "ip", "ip", "Manager", ")", "\u0120Complete", "Def", "erred", "Work", "()", "\u0120error", "\u0120{", "\u0120for", "\u0120_", ",", "\u0120ip", "\u0120:=", "\u0120range", "\u0120m", ".", "active", "Host", "name", "To", "IP", "\u0120{", "\u0120members", "\u0120=", "\u0120append", "(", "members", ",", "\u0120ip", ")", "\u0120}", "\u0120-", "\u0120for", "\u0120_", ",", "\u0120ip", "\u0120:=", "\u0120range", "\u0120m", ".", "external", "Node", "C", "ID", "Rs", "\u0120{", "\u0120-", "\u0120members", "\u0120=", "\u0120append", "(", "members", ",", "\u0120ip", ")", "\u0120-", "\u0120}", "\u0120+", "\u0120members", "\u0120=", "\u0120append", "(", "members", ",", "\u0120m", ".", "external", "Node", "C", "ID", "Rs", "...)", "\u0120m", ".", "ips", "ets", "Data", "plane", ".", "Add", "Or", "Re", "place", "IPS", "et", "(", "m", ".", "ip", "Set", "Met", "adata", ",", "\u0120members", ")", "\u0120m", ".", "ip", "Set", "In", "Sync", "\u0120=", "\u0120true", "\u0120}"], "docstring_tokens": ["Same", "\u0120change", "\u0120just", "\u0120above", "?"]}
{"function": "@@ -511,4 +511,14 @@ describe('services_SearchEngine', function() { expect((await engine.search('\"- [ ]\"', { searchType: SearchEngine.SEARCH_TYPE_BASIC })).length).toBe(1); expect((await engine.search('\"[ ]\"', { searchType: SearchEngine.SEARCH_TYPE_BASIC })).length).toBe(2); })); + + it('should not mistake cyrillic \"l\" for latin \"n\"', asyncTest(async () => { + const n1 = await Note.save({ title: 'latin n', body: 'n' }); + const n2 = await Note.save({ title: 'cyrillic l', body: '\u043b' }); + + await engine.syncTables(); + + expect((await engine.search('n')).length).toBe(1); + expect((await engine.search('\u043b')).length).toBe(1); + })); });", "text": "Could you check the result content rather than just the number of search results please? For example with this test if the search engine suddenly starts returning \"latin n\" for both queries, we won't know about it.", "function_tokens": ["@@", "\u0120-", "511", ",", "4", "\u0120+", "511", ",", "14", "\u0120@@", "\u0120describe", "('", "services", "_", "Search", "Engine", "',", "\u0120function", "()", "\u0120{", "\u0120expect", "((", "aw", "ait", "\u0120engine", ".", "search", "('", "\"-", "\u0120[", "\u0120]", "\"", "',", "\u0120{", "\u0120search", "Type", ":", "\u0120Search", "Engine", ".", "SE", "ARCH", "_", "TYPE", "_", "B", "AS", "IC", "\u0120}", ")).", "length", ").", "to", "Be", "(", "1", ");", "\u0120expect", "((", "aw", "ait", "\u0120engine", ".", "search", "('", "\"[", "\u0120]", "\"", "',", "\u0120{", "\u0120search", "Type", ":", "\u0120Search", "Engine", ".", "SE", "ARCH", "_", "TYPE", "_", "B", "AS", "IC", "\u0120}", ")).", "length", ").", "to", "Be", "(", "2", ");", "\u0120}", "));", "\u0120+", "\u0120+", "\u0120it", "('", "should", "\u0120not", "\u0120mistake", "\u0120c", "yr", "ill", "ic", "\u0120\"", "l", "\"", "\u0120for", "\u0120lat", "in", "\u0120\"", "n", "\"", "',", "\u0120async", "Test", "(", "as", "ync", "\u0120()", "\u0120=>", "\u0120{", "\u0120+", "\u0120const", "\u0120n", "1", "\u0120=", "\u0120await", "\u0120Note", ".", "save", "({", "\u0120title", ":", "\u0120'", "l", "atin", "\u0120n", "',", "\u0120body", ":", "\u0120'", "n", "'", "\u0120});", "\u0120+", "\u0120const", "\u0120n", "2", "\u0120=", "\u0120await", "\u0120Note", ".", "save", "({", "\u0120title", ":", "\u0120'", "cy", "rill", "ic", "\u0120l", "',", "\u0120body", ":", "\u0120'", "\u00d0\u00bb", "'", "\u0120});", "\u0120+", "\u0120+", "\u0120await", "\u0120engine", ".", "sync", "T", "ables", "();", "\u0120+", "\u0120+", "\u0120expect", "((", "aw", "ait", "\u0120engine", ".", "search", "('", "n", "')", ").", "length", ").", "to", "Be", "(", "1", ");", "\u0120+", "\u0120expect", "((", "aw", "ait", "\u0120engine", ".", "search", "('", "\u00d0\u00bb", "')", ").", "length", ").", "to", "Be", "(", "1", ");", "\u0120+", "\u0120}", "));", "\u0120});"], "docstring_tokens": ["Could", "\u0120you", "\u0120check", "\u0120the", "\u0120result", "\u0120content", "\u0120rather", "\u0120than", "\u0120just", "\u0120the", "\u0120number", "\u0120of", "\u0120search", "\u0120results", "\u0120please", "?", "\u0120For", "\u0120example", "\u0120with", "\u0120this", "\u0120test", "\u0120if", "\u0120the", "\u0120search", "\u0120engine", "\u0120suddenly", "\u0120starts", "\u0120returning", "\u0120\"", "l", "atin", "\u0120n", "\"", "\u0120for", "\u0120both", "\u0120queries", ",", "\u0120we", "\u0120won", "'t", "\u0120know", "\u0120about", "\u0120it", "."]}
{"function": "@@ -47,9 +47,10 @@ const ( otherDomainID = \"spiffe://otherdomain.test\" - serverID = \"spiffe://example.org/spire/server\" - agentID = \"spiffe://example.org/spire/agent/test/id\" - workloadID = \"spiffe://example.org/workload\" + serverID = \"spiffe://example.org/spire/server\" + agentID = \"spiffe://example.org/spire/agent/test/id\" + agentlessID = \"spiffe://example.org/test/id\" + workloadID = \"spiffe://example.org/workload\" // used to cancel stream operations on test failure instead of blocking the // full go test timeout period (i.e. 10 minutes)", "text": "nit: I think that `workloadID` should suffice for this test... that's what we'd be issuing anyways", "function_tokens": ["@@", "\u0120-", "47", ",", "9", "\u0120+", "47", ",", "10", "\u0120@@", "\u0120const", "\u0120(", "\u0120other", "Domain", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "other", "domain", ".", "test", "\"", "\u0120-", "\u0120server", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "sp", "ire", "/", "server", "\"", "\u0120-", "\u0120agent", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "sp", "ire", "/", "agent", "/", "test", "/", "id", "\"", "\u0120-", "\u0120workload", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "work", "load", "\"", "\u0120+", "\u0120server", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "sp", "ire", "/", "server", "\"", "\u0120+", "\u0120agent", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "sp", "ire", "/", "agent", "/", "test", "/", "id", "\"", "\u0120+", "\u0120agent", "less", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "test", "/", "id", "\"", "\u0120+", "\u0120workload", "ID", "\u0120=", "\u0120\"", "sp", "iffe", "://", "example", ".", "org", "/", "work", "load", "\"", "\u0120//", "\u0120used", "\u0120to", "\u0120cancel", "\u0120stream", "\u0120operations", "\u0120on", "\u0120test", "\u0120failure", "\u0120instead", "\u0120of", "\u0120blocking", "\u0120the", "\u0120//", "\u0120full", "\u0120go", "\u0120test", "\u0120timeout", "\u0120period", "\u0120(", "i", ".", "e", ".", "\u012010", "\u0120minutes", ")"], "docstring_tokens": ["nit", ":", "\u0120I", "\u0120think", "\u0120that", "\u0120`", "work", "load", "ID", "`", "\u0120should", "\u0120suffice", "\u0120for", "\u0120this", "\u0120test", "...", "\u0120that", "'s", "\u0120what", "\u0120we", "'d", "\u0120be", "\u0120issuing", "\u0120anyways"]}
{"function": "@@ -1,4 +1,4 @@ -require 'spec_helper' +require 'rails_helper' feature 'Admin manages mentors' do scenario 'creating a new mentor' do", "text": "Prefer double-quoted strings unless you need single quotes to avoid extra backslashes for escaping.", "function_tokens": ["@@", "\u0120-", "1", ",", "4", "\u0120+", "1", ",", "4", "\u0120@@", "\u0120-", "require", "\u0120'", "spec", "_", "hel", "per", "'", "\u0120+", "require", "\u0120'", "ra", "ils", "_", "hel", "per", "'", "\u0120feature", "\u0120'", "Admin", "\u0120manages", "\u0120mentors", "'", "\u0120do", "\u0120scenario", "\u0120'", "creat", "ing", "\u0120a", "\u0120new", "\u0120mentor", "'", "\u0120do"], "docstring_tokens": ["Pre", "fer", "\u0120double", "-", "qu", "oted", "\u0120strings", "\u0120unless", "\u0120you", "\u0120need", "\u0120single", "\u0120quotes", "\u0120to", "\u0120avoid", "\u0120extra", "\u0120back", "sl", "ashes", "\u0120for", "\u0120escaping", "."]}
{"function": "@@ -204,11 +204,7 @@ public class ClassTypeResolver extends JavaParserVisitorAdapter { if (className != null) { populateClassName(node, className); } - } catch (ClassNotFoundException e) { - if (LOG.isLoggable(Level.FINE)) { - LOG.log(Level.FINE, \"Could not find class \" + className + \", due to: \" + e); - } - } catch (NoClassDefFoundError e) { + } catch (ClassNotFoundException | NoClassDefFoundError e) { if (LOG.isLoggable(Level.FINE)) { LOG.log(Level.FINE, \"Could not find class \" + className + \", due to: \" + e); }", "text": "We should have a rule to detect identical catch branches", "function_tokens": ["@@", "\u0120-", "204", ",", "11", "\u0120+", "204", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Class", "Type", "Res", "olver", "\u0120extends", "\u0120Java", "Parser", "Vis", "itor", "Adapter", "\u0120{", "\u0120if", "\u0120(", "class", "Name", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120populate", "Class", "Name", "(", "node", ",", "\u0120class", "Name", ");", "\u0120}", "\u0120-", "\u0120}", "\u0120catch", "\u0120(", "Class", "Not", "Found", "Exception", "\u0120e", ")", "\u0120{", "\u0120-", "\u0120if", "\u0120(", "LOG", ".", "is", "L", "ogg", "able", "(", "Level", ".", "FINE", "))", "\u0120{", "\u0120-", "\u0120LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\u0120\"", "Could", "\u0120not", "\u0120find", "\u0120class", "\u0120\"", "\u0120+", "\u0120class", "Name", "\u0120+", "\u0120\",", "\u0120due", "\u0120to", ":", "\u0120\"", "\u0120+", "\u0120e", ");", "\u0120-", "\u0120}", "\u0120-", "\u0120}", "\u0120catch", "\u0120(", "No", "Class", "Def", "Found", "Error", "\u0120e", ")", "\u0120{", "\u0120+", "\u0120}", "\u0120catch", "\u0120(", "Class", "Not", "Found", "Exception", "\u0120|", "\u0120No", "Class", "Def", "Found", "Error", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(", "LOG", ".", "is", "L", "ogg", "able", "(", "Level", ".", "FINE", "))", "\u0120{", "\u0120LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\u0120\"", "Could", "\u0120not", "\u0120find", "\u0120class", "\u0120\"", "\u0120+", "\u0120class", "Name", "\u0120+", "\u0120\",", "\u0120due", "\u0120to", ":", "\u0120\"", "\u0120+", "\u0120e", ");", "\u0120}"], "docstring_tokens": ["We", "\u0120should", "\u0120have", "\u0120a", "\u0120rule", "\u0120to", "\u0120detect", "\u0120identical", "\u0120catch", "\u0120branches"]}
{"function": "@@ -28,10 +28,6 @@ namespace Microsoft.DotNet.Build.Tasks.Feed public bool PublishFlatContainer { get; set; } - public int RetryAttempts { get; set; } = 5; - - public int RetryDelayInSeconds { get; set; } = 30; - public int MaxClients { get; set; } = 8; public bool SkipCreateContainer { get; set; } = false;", "text": "remove these from the targets file.", "function_tokens": ["@@", "\u0120-", "28", ",", "10", "\u0120+", "28", ",", "6", "\u0120@@", "\u0120namespace", "\u0120Microsoft", ".", "D", "ot", "Net", ".", "Build", ".", "T", "asks", ".", "Feed", "\u0120public", "\u0120bool", "\u0120Pub", "lish", "Fl", "at", "Container", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120-", "\u0120public", "\u0120int", "\u0120Ret", "ry", "Attempts", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u01205", ";", "\u0120-", "\u0120-", "\u0120public", "\u0120int", "\u0120Ret", "ry", "Del", "ay", "In", "Second", "s", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u012030", ";", "\u0120-", "\u0120public", "\u0120int", "\u0120Max", "Cl", "ients", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u01208", ";", "\u0120public", "\u0120bool", "\u0120Skip", "Create", "Container", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u0120false", ";"], "docstring_tokens": ["remove", "\u0120these", "\u0120from", "\u0120the", "\u0120targets", "\u0120file", "."]}
{"function": "@@ -11,14 +11,13 @@ import ( \"time\" \"github.com/ethersphere/bee/pkg/addressbook\" + \"github.com/ethersphere/bee/pkg/bzz\" \"github.com/ethersphere/bee/pkg/hive/pb\" \"github.com/ethersphere/bee/pkg/logging\" \"github.com/ethersphere/bee/pkg/p2p\" \"github.com/ethersphere/bee/pkg/p2p/protobuf\" \"github.com/ethersphere/bee/pkg/storage\" \"github.com/ethersphere/bee/pkg/swarm\" - - ma \"github.com/multiformats/go-multiaddr\" ) const (", "text": "now that we have the signature in the hive messages, it might be that this must be drastically reduced, since there are limits on the protobuf reader/writers i believe", "function_tokens": ["@@", "\u0120-", "11", ",", "14", "\u0120+", "11", ",", "13", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "time", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "address", "book", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "b", "zz", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "h", "ive", "/", "pb", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "log", "ging", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "p", "2", "p", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "p", "2", "p", "/", "prot", "ob", "uf", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "storage", "\"", "\u0120\"", "github", ".", "com", "/", "ether", "sp", "here", "/", "bee", "/", "pkg", "/", "sw", "arm", "\"", "\u0120-", "\u0120-", "\u0120ma", "\u0120\"", "github", ".", "com", "/", "mult", "iform", "ats", "/", "go", "-", "multi", "addr", "\"", "\u0120)", "\u0120const", "\u0120("], "docstring_tokens": ["now", "\u0120that", "\u0120we", "\u0120have", "\u0120the", "\u0120signature", "\u0120in", "\u0120the", "\u0120hive", "\u0120messages", ",", "\u0120it", "\u0120might", "\u0120be", "\u0120that", "\u0120this", "\u0120must", "\u0120be", "\u0120drastically", "\u0120reduced", ",", "\u0120since", "\u0120there", "\u0120are", "\u0120limits", "\u0120on", "\u0120the", "\u0120prot", "ob", "uf", "\u0120reader", "/", "writers", "\u0120i", "\u0120believe"]}
{"function": "@@ -35,11 +35,12 @@ NAMESPACE_PACKAGES = [ REQUIRED_PACKAGES = [ # Installation related. 'anytree==2.4.3', - 'google-api-python-client==1.7.7', - 'google-auth==1.6.2', + 'google-api-python-client==1.7.10', + 'google-auth==1.6.3', 'google-auth-httplib2==0.0.3', 'Jinja2==2.10.1', 'jmespath==0.9.3', + 'mailjet-rest==1.3.3', 'netaddr==0.7.19', 'pyyaml==4.2b4', 'python-graph-core==1.8.2',", "text": "I recommend that we move this to be optional, as other users might not need it. Can you look at `OPTIONAL_PACKAGES` section, around line 68?", "function_tokens": ["@@", "\u0120-", "35", ",", "11", "\u0120+", "35", ",", "12", "\u0120@@", "\u0120N", "AMES", "P", "ACE", "_", "P", "ACK", "AGES", "\u0120=", "\u0120[", "\u0120RE", "QU", "IRED", "_", "P", "ACK", "AGES", "\u0120=", "\u0120[", "\u0120#", "\u0120Installation", "\u0120related", ".", "\u0120'", "any", "tree", "==", "2", ".", "4", ".", "3", "',", "\u0120-", "\u0120'", "google", "-", "api", "-", "python", "-", "client", "==", "1", ".", "7", ".", "7", "',", "\u0120-", "\u0120'", "google", "-", "auth", "==", "1", ".", "6", ".", "2", "',", "\u0120+", "\u0120'", "google", "-", "api", "-", "python", "-", "client", "==", "1", ".", "7", ".", "10", "',", "\u0120+", "\u0120'", "google", "-", "auth", "==", "1", ".", "6", ".", "3", "',", "\u0120'", "google", "-", "auth", "-", "htt", "pl", "ib", "2", "==", "0", ".", "0", ".", "3", "',", "\u0120'", "J", "in", "ja", "2", "==", "2", ".", "10", ".", "1", "',", "\u0120'", "j", "mes", "path", "==", "0", ".", "9", ".", "3", "',", "\u0120+", "\u0120'", "mail", "jet", "-", "rest", "==", "1", ".", "3", ".", "3", "',", "\u0120'", "net", "addr", "==", "0", ".", "7", ".", "19", "',", "\u0120'", "py", "y", "aml", "==", "4", ".", "2", "b", "4", "',", "\u0120'", "python", "-", "graph", "-", "core", "==", "1", ".", "8", ".", "2", "',"], "docstring_tokens": ["I", "\u0120recommend", "\u0120that", "\u0120we", "\u0120move", "\u0120this", "\u0120to", "\u0120be", "\u0120optional", ",", "\u0120as", "\u0120other", "\u0120users", "\u0120might", "\u0120not", "\u0120need", "\u0120it", ".", "\u0120Can", "\u0120you", "\u0120look", "\u0120at", "\u0120`", "OP", "TION", "AL", "_", "P", "ACK", "AGES", "`", "\u0120section", ",", "\u0120around", "\u0120line", "\u012068", "?"]}
{"function": "@@ -8,10 +8,7 @@ package javaslang.control; import javaslang.Serializables; import org.junit.Test; -import java.util.Iterator; -import java.util.NoSuchElementException; -import java.util.Objects; -import java.util.Optional; +import java.util.*; import static org.assertj.core.api.Assertions.assertThat; ", "text": "I usually set idea to never use wildcard import such as `import java.util.*;` Now i use setting from javaslang standard.", "function_tokens": ["@@", "\u0120-", "8", ",", "10", "\u0120+", "8", ",", "7", "\u0120@@", "\u0120package", "\u0120j", "av", "as", "lang", ".", "control", ";", "\u0120import", "\u0120j", "av", "as", "lang", ".", "Serial", "iz", "ables", ";", "\u0120import", "\u0120org", ".", "j", "unit", ".", "Test", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Iterator", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "No", "Such", "Element", "Exception", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Object", "s", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Optional", ";", "\u0120+", "import", "\u0120java", ".", "util", ".*", ";", "\u0120import", "\u0120static", "\u0120org", ".", "assert", "j", ".", "core", ".", "api", ".", "Ass", "ert", "ions", ".", "assert", "That", ";", "\u0120"], "docstring_tokens": ["I", "\u0120usually", "\u0120set", "\u0120idea", "\u0120to", "\u0120never", "\u0120use", "\u0120wild", "card", "\u0120import", "\u0120such", "\u0120as", "\u0120`", "import", "\u0120java", ".", "util", ".*", ";", "`", "\u0120Now", "\u0120i", "\u0120use", "\u0120setting", "\u0120from", "\u0120j", "av", "as", "lang", "\u0120standard", "."]}
{"function": "@@ -29,7 +29,9 @@ module Beaker v_file << \" v.vm.box = '#{host['box']}'\\n\" v_file << \" v.vm.box_url = '#{host['box_url']}'\\n\" unless host['box_url'].nil? v_file << \" v.vm.base_mac = '#{randmac}'\\n\" - v_file << \" v.vm.network :private_network, ip: \\\"#{host['ip'].to_s}\\\", :netmask => \\\"#{host['netmask'] ||= \"255.255.0.0\"}\\\"\\n\" + host['ips'].each do |ip| + v_file << \" v.vm.network :private_network, ip: \\\"#{ip.to_s}\\\", :netmask => \\\"#{host['netmask'] ||= \"255.255.0.0\"}\\\"\\n\" + end if host['disk_path'] v_file << \" v.vm.provider :virtualbox do |vb|\\n\"", "text": "Where is host['ips'] coming from?", "function_tokens": ["@@", "\u0120-", "29", ",", "7", "\u0120+", "29", ",", "9", "\u0120@@", "\u0120module", "\u0120Be", "aker", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "box", "\u0120=", "\u0120'", "#", "{", "host", "['", "box", "']", "}", "'", "\\", "n", "\"", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "box", "_", "url", "\u0120=", "\u0120'", "#", "{", "host", "['", "box", "_", "url", "']", "}", "'", "\\", "n", "\"", "\u0120unless", "\u0120host", "['", "box", "_", "url", "'", "].", "nil", "?", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "base", "_", "mac", "\u0120=", "\u0120'", "#", "{", "rand", "mac", "}", "'", "\\", "n", "\"", "\u0120-", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "network", "\u0120:", "private", "_", "network", ",", "\u0120ip", ":", "\u0120\\\"", "#", "{", "host", "['", "ip", "'", "].", "to", "_", "s", "}\\", "\",", "\u0120:", "net", "mask", "\u0120=>", "\u0120\\\"", "#", "{", "host", "['", "net", "mask", "']", "\u0120||", "=", "\u0120\"", "255", ".", "255", ".", "0", ".", "0", "\"}", "\\\"", "\\", "n", "\"", "\u0120+", "\u0120host", "['", "ips", "'", "].", "each", "\u0120do", "\u0120|", "ip", "|", "\u0120+", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "network", "\u0120:", "private", "_", "network", ",", "\u0120ip", ":", "\u0120\\\"", "#", "{", "ip", ".", "to", "_", "s", "}\\", "\",", "\u0120:", "net", "mask", "\u0120=>", "\u0120\\\"", "#", "{", "host", "['", "net", "mask", "']", "\u0120||", "=", "\u0120\"", "255", ".", "255", ".", "0", ".", "0", "\"}", "\\\"", "\\", "n", "\"", "\u0120+", "\u0120end", "\u0120if", "\u0120host", "['", "disk", "_", "path", "']", "\u0120v", "_", "file", "\u0120<<", "\u0120\"", "\u0120v", ".", "vm", ".", "prov", "ider", "\u0120:", "virtual", "box", "\u0120do", "\u0120|", "v", "b", "|", "\\", "n", "\""], "docstring_tokens": ["Where", "\u0120is", "\u0120host", "['", "ips", "']", "\u0120coming", "\u0120from", "?"]}
{"function": "@@ -3,14 +3,7 @@ package userns -import ( - \"strings\" - - \"github.com/opencontainers/runc/libcontainer/user\" -) - -func FuzzUIDMap(data []byte) int { - uidmap, _ := user.ParseIDMap(strings.NewReader(string(data))) - _ = uidMapInUserNS(uidmap) +func FuzzUIDMap(uidmap []byte) int { + _ = uidMapInUserNS(string(uidmap)) return 1 }", "text": "oh! missed a `:` here; let me fix that; also can get rid of the intermediate variable", "function_tokens": ["@@", "\u0120-", "3", ",", "14", "\u0120+", "3", ",", "7", "\u0120@@", "\u0120package", "\u0120us", "ern", "s", "\u0120-", "import", "\u0120(", "\u0120-", "\u0120\"", "strings", "\"", "\u0120-", "\u0120-", "\u0120\"", "github", ".", "com", "/", "open", "cont", "ainers", "/", "run", "c", "/", "lib", "container", "/", "user", "\"", "\u0120-", ")", "\u0120-", "\u0120-", "func", "\u0120F", "uzz", "UID", "Map", "(", "data", "\u0120[]", "byte", ")", "\u0120int", "\u0120{", "\u0120-", "\u0120u", "id", "map", ",", "\u0120_", "\u0120:=", "\u0120user", ".", "Par", "se", "ID", "Map", "(", "strings", ".", "New", "Reader", "(", "string", "(", "data", ")))", "\u0120-", "\u0120_", "\u0120=", "\u0120u", "id", "Map", "In", "User", "NS", "(", "uid", "map", ")", "\u0120+", "func", "\u0120F", "uzz", "UID", "Map", "(", "uid", "map", "\u0120[]", "byte", ")", "\u0120int", "\u0120{", "\u0120+", "\u0120_", "\u0120=", "\u0120u", "id", "Map", "In", "User", "NS", "(", "string", "(", "uid", "map", "))", "\u0120return", "\u01201", "\u0120}"], "docstring_tokens": ["oh", "!", "\u0120missed", "\u0120a", "\u0120`", ":", "`", "\u0120here", ";", "\u0120let", "\u0120me", "\u0120fix", "\u0120that", ";", "\u0120also", "\u0120can", "\u0120get", "\u0120rid", "\u0120of", "\u0120the", "\u0120intermediate", "\u0120variable"]}
{"function": "@@ -1,6 +1,8 @@ describe \"Display status text\" do let(:proposal) { FactoryGirl.create(:proposal, :with_parallel_approvers) } before do + proposal.approvers.first.update(first_name: \"Uniquely\", last_name: \"Named\") + proposal.approvers.second.update(first_name: \"Onlyof\", last_name: \"Itskind\") login_as(proposal.requester) end ", "text": "Is this necessary?", "function_tokens": ["@@", "\u0120-", "1", ",", "6", "\u0120+", "1", ",", "8", "\u0120@@", "\u0120describe", "\u0120\"", "Display", "\u0120status", "\u0120text", "\"", "\u0120do", "\u0120let", "(", ":", "pro", "posal", ")", "\u0120{", "\u0120Factory", "Girl", ".", "create", "(", ":", "pro", "posal", ",", "\u0120:", "with", "_", "par", "allel", "_", "appro", "vers", ")", "\u0120}", "\u0120before", "\u0120do", "\u0120+", "\u0120proposal", ".", "appro", "vers", ".", "first", ".", "update", "(", "first", "_", "name", ":", "\u0120\"", "Unique", "ly", "\",", "\u0120last", "_", "name", ":", "\u0120\"", "N", "amed", "\")", "\u0120+", "\u0120proposal", ".", "appro", "vers", ".", "second", ".", "update", "(", "first", "_", "name", ":", "\u0120\"", "Only", "of", "\",", "\u0120last", "_", "name", ":", "\u0120\"", "Its", "kind", "\")", "\u0120login", "_", "as", "(", "pro", "posal", ".", "requ", "ester", ")", "\u0120end", "\u0120"], "docstring_tokens": ["Is", "\u0120this", "\u0120necessary", "?"]}
{"function": "@@ -1,8 +1,16 @@ -import React from 'react'; +import React, {Component} from 'react'; import 'element-theme-default'; import {i18n} from 'element-react'; import locale from 'element-react/src/locale/lang/en'; +import storage from './utils/storage'; +import logo from './utils/logo'; +import {makeLogin, isTokenExpire} from './utils/login'; + +import Header from './components/Header'; +import Footer from './components/Footer'; +import LoginModal from './components/Login'; + i18n.use(locale); import Route from './router';", "text": "I'd create a different method for each render section.", "function_tokens": ["@@", "\u0120-", "1", ",", "8", "\u0120+", "1", ",", "16", "\u0120@@", "\u0120-", "import", "\u0120React", "\u0120from", "\u0120'", "react", "';", "\u0120+", "import", "\u0120React", ",", "\u0120{", "Component", "}", "\u0120from", "\u0120'", "react", "';", "\u0120import", "\u0120'", "element", "-", "theme", "-", "default", "';", "\u0120import", "\u0120{", "i", "18", "n", "}", "\u0120from", "\u0120'", "element", "-", "react", "';", "\u0120import", "\u0120locale", "\u0120from", "\u0120'", "element", "-", "react", "/", "src", "/", "loc", "ale", "/", "lang", "/", "en", "';", "\u0120+", "import", "\u0120storage", "\u0120from", "\u0120'", "./", "utils", "/", "storage", "';", "\u0120+", "import", "\u0120logo", "\u0120from", "\u0120'", "./", "utils", "/", "log", "o", "';", "\u0120+", "import", "\u0120{", "make", "Login", ",", "\u0120is", "Token", "Ex", "pire", "}", "\u0120from", "\u0120'", "./", "utils", "/", "login", "';", "\u0120+", "\u0120+", "import", "\u0120Header", "\u0120from", "\u0120'", "./", "comp", "onents", "/", "Header", "';", "\u0120+", "import", "\u0120Foot", "er", "\u0120from", "\u0120'", "./", "comp", "onents", "/", "Foot", "er", "';", "\u0120+", "import", "\u0120Login", "Mod", "al", "\u0120from", "\u0120'", "./", "comp", "onents", "/", "Login", "';", "\u0120+", "\u0120i", "18", "n", ".", "use", "(", "loc", "ale", ");", "\u0120import", "\u0120Route", "\u0120from", "\u0120'", "./", "rou", "ter", "';"], "docstring_tokens": ["I", "'d", "\u0120create", "\u0120a", "\u0120different", "\u0120method", "\u0120for", "\u0120each", "\u0120render", "\u0120section", "."]}
{"function": "@@ -23,6 +23,8 @@ public class EstimateGasOperationTracer implements OperationTracer { private Gas sStoreStipendNeeded = Gas.ZERO; + private boolean isReverted = false; + @Override public void traceExecution( final MessageFrame frame, final OperationTracer.ExecuteOperation executeOperation) {", "text": "Instead of storing the revert flag in the tracer is it possible to use org.hyperledger.besu.ethereum.mainnet.TransactionProcessor.Result#getRevertReason? (via org.hyperledger.besu.ethereum.transaction.TransactionSimulatorResult#getResult)? If a TX reverts without a reason do we get an empty revert reason or a revert reason with zero bytes?", "function_tokens": ["@@", "\u0120-", "23", ",", "6", "\u0120+", "23", ",", "8", "\u0120@@", "\u0120public", "\u0120class", "\u0120Est", "imate", "Gas", "Operation", "Tr", "acer", "\u0120implements", "\u0120Operation", "Tr", "acer", "\u0120{", "\u0120private", "\u0120Gas", "\u0120s", "Store", "St", "ip", "end", "Need", "ed", "\u0120=", "\u0120Gas", ".", "Z", "ERO", ";", "\u0120+", "\u0120private", "\u0120boolean", "\u0120is", "R", "ever", "ted", "\u0120=", "\u0120false", ";", "\u0120+", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120trace", "Exec", "ution", "(", "\u0120final", "\u0120Message", "Frame", "\u0120frame", ",", "\u0120final", "\u0120Operation", "Tr", "acer", ".", "Exec", "ute", "Operation", "\u0120execute", "Operation", ")", "\u0120{"], "docstring_tokens": ["Instead", "\u0120of", "\u0120storing", "\u0120the", "\u0120revert", "\u0120flag", "\u0120in", "\u0120the", "\u0120tr", "acer", "\u0120is", "\u0120it", "\u0120possible", "\u0120to", "\u0120use", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "et", "here", "um", ".", "main", "net", ".", "Transaction", "Process", "or", ".", "Result", "#", "get", "R", "ever", "t", "Reason", "?", "\u0120(", "via", "\u0120org", ".", "hyper", "led", "ger", ".", "bes", "u", ".", "et", "here", "um", ".", "trans", "action", ".", "Transaction", "Sim", "ulator", "Result", "#", "get", "Result", ")?", "\u0120If", "\u0120a", "\u0120TX", "\u0120re", "verts", "\u0120without", "\u0120a", "\u0120reason", "\u0120do", "\u0120we", "\u0120get", "\u0120an", "\u0120empty", "\u0120revert", "\u0120reason", "\u0120or", "\u0120a", "\u0120revert", "\u0120reason", "\u0120with", "\u0120zero", "\u0120bytes", "?"]}
{"function": "@@ -71,7 +71,7 @@ public class TestSparkOrcReader extends AvroDataTest { try (CloseableIterable<InternalRow> reader = ORC.read(Files.localInput(testFile)) .project(schema) - .createReaderFunc(SparkOrcReader::new) + .createReaderFunc(readOrcSchema -> new SparkOrcReader(schema, readOrcSchema)) .build()) { final Iterator<InternalRow> actualRows = reader.iterator(); final Iterator<InternalRow> expectedRows = expected.iterator();", "text": "I think this should test with and without container reuse if that is implemented in this PR. Probably just make this test parameterized.", "function_tokens": ["@@", "\u0120-", "71", ",", "7", "\u0120+", "71", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Test", "Sp", "ark", "Or", "c", "Reader", "\u0120extends", "\u0120Av", "ro", "Data", "Test", "\u0120{", "\u0120try", "\u0120(", "Close", "able", "Iter", "able", "<", "Internal", "Row", ">", "\u0120reader", "\u0120=", "\u0120OR", "C", ".", "read", "(", "Files", ".", "local", "Input", "(", "test", "File", "))", "\u0120.", "project", "(", "sche", "ma", ")", "\u0120-", "\u0120.", "create", "Reader", "F", "unc", "(", "Sp", "ark", "Or", "c", "Reader", "::", "new", ")", "\u0120+", "\u0120.", "create", "Reader", "F", "unc", "(", "read", "Or", "c", "Sche", "ma", "\u0120->", "\u0120new", "\u0120Spark", "Or", "c", "Reader", "(", "sche", "ma", ",", "\u0120read", "Or", "c", "Sche", "ma", "))", "\u0120.", "build", "())", "\u0120{", "\u0120final", "\u0120Iter", "ator", "<", "Internal", "Row", ">", "\u0120actual", "R", "ows", "\u0120=", "\u0120reader", ".", "iterator", "();", "\u0120final", "\u0120Iter", "ator", "<", "Internal", "Row", ">", "\u0120expected", "R", "ows", "\u0120=", "\u0120expected", ".", "iterator", "();"], "docstring_tokens": ["I", "\u0120think", "\u0120this", "\u0120should", "\u0120test", "\u0120with", "\u0120and", "\u0120without", "\u0120container", "\u0120reuse", "\u0120if", "\u0120that", "\u0120is", "\u0120implemented", "\u0120in", "\u0120this", "\u0120PR", ".", "\u0120Probably", "\u0120just", "\u0120make", "\u0120this", "\u0120test", "\u0120parameter", "ized", "."]}
{"function": "@@ -100,6 +100,10 @@ abstract class BaseFile<F> found = true; fromProjectionPos[i] = j; } + if (fields.get(i).fieldId() == ManifestFile.SPEC_ID.fieldId()) { + found = true; + fromProjectionPos[i] = 14; + } } if (!found) {", "text": "These modifications allow BaseFile to translate into a SparkRow with the specID as a column", "function_tokens": ["@@", "\u0120-", "100", ",", "6", "\u0120+", "100", ",", "10", "\u0120@@", "\u0120abstract", "\u0120class", "\u0120Base", "File", "<", "F", ">", "\u0120found", "\u0120=", "\u0120true", ";", "\u0120from", "Project", "ion", "Pos", "[", "i", "]", "\u0120=", "\u0120j", ";", "\u0120}", "\u0120+", "\u0120if", "\u0120(", "fields", ".", "get", "(", "i", ").", "field", "Id", "()", "\u0120==", "\u0120Manifest", "File", ".", "SPEC", "_", "ID", ".", "field", "Id", "())", "\u0120{", "\u0120+", "\u0120found", "\u0120=", "\u0120true", ";", "\u0120+", "\u0120from", "Project", "ion", "Pos", "[", "i", "]", "\u0120=", "\u012014", ";", "\u0120+", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "found", ")", "\u0120{"], "docstring_tokens": ["These", "\u0120modifications", "\u0120allow", "\u0120Base", "File", "\u0120to", "\u0120translate", "\u0120into", "\u0120a", "\u0120Spark", "Row", "\u0120with", "\u0120the", "\u0120spec", "ID", "\u0120as", "\u0120a", "\u0120column"]}
{"function": "@@ -519,7 +519,7 @@ function resolveReadPreference(parent, options) { throw new Error('No readPreference was provided or inherited.'); } - return readPreference; + return typeof readPreference === 'string' ? new ReadPreference(readPreference) : readPreference; } /**", "text": "is this something we've been missing this whole time?", "function_tokens": ["@@", "\u0120-", "519", ",", "7", "\u0120+", "519", ",", "7", "\u0120@@", "\u0120function", "\u0120resolve", "Read", "Pre", "ference", "(", "parent", ",", "\u0120options", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Error", "('", "No", "\u0120read", "Pre", "ference", "\u0120was", "\u0120provided", "\u0120or", "\u0120inherited", ".'", ");", "\u0120}", "\u0120-", "\u0120return", "\u0120read", "Pre", "ference", ";", "\u0120+", "\u0120return", "\u0120type", "of", "\u0120read", "Pre", "ference", "\u0120===", "\u0120'", "string", "'", "\u0120?", "\u0120new", "\u0120Read", "Pre", "ference", "(", "read", "Pre", "ference", ")", "\u0120:", "\u0120read", "Pre", "ference", ";", "\u0120}", "\u0120/**"], "docstring_tokens": ["is", "\u0120this", "\u0120something", "\u0120we", "'ve", "\u0120been", "\u0120missing", "\u0120this", "\u0120whole", "\u0120time", "?"]}
{"function": "@@ -25,6 +25,7 @@ import ( const ( defaultWaitApprovalTimeout = Duration(6 * time.Hour) defaultAnalysisQueryTimeout = Duration(30 * time.Second) + allEvents = \"*\" ) type GenericDeploymentSpec struct {", "text": "nit: this is a package-wide constant so better to narrow the scope like `allEventsSign`.", "function_tokens": ["@@", "\u0120-", "25", ",", "6", "\u0120+", "25", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120const", "\u0120(", "\u0120default", "Wait", "App", "ro", "val", "Timeout", "\u0120=", "\u0120Duration", "(", "6", "\u0120*", "\u0120time", ".", "Hour", ")", "\u0120default", "Analysis", "Query", "Timeout", "\u0120=", "\u0120Duration", "(", "30", "\u0120*", "\u0120time", ".", "Second", ")", "\u0120+", "\u0120all", "Events", "\u0120=", "\u0120\"", "*", "\"", "\u0120)", "\u0120type", "\u0120Generic", "Deploy", "ment", "Spec", "\u0120struct", "\u0120{"], "docstring_tokens": ["nit", ":", "\u0120this", "\u0120is", "\u0120a", "\u0120package", "-", "wide", "\u0120constant", "\u0120so", "\u0120better", "\u0120to", "\u0120narrow", "\u0120the", "\u0120scope", "\u0120like", "\u0120`", "all", "Events", "Sign", "`."]}
{"function": "@@ -111,6 +111,15 @@ def generate_thrift_files(thrift_files_dir, env, silent=True): LOG.error('Failed to generate viewer server files') return ret + auth_thrift = os.path.join(thrift_files_dir, 'authentication.thrift') + auth_thrift = 'authentication.thrift' + auth_cmd = ['thrift', '-r', '-I', '.', + '--gen', 'py', auth_thrift] + ret = run_cmd(auth_cmd, thrift_files_dir, env, silent=silent) + if ret: + LOG.error('Failed to generate authentication interface files') + return ret + # ------------------------------------------------------------------- def generate_documentation(doc_root, env, silent=True):", "text": "There seems to be some repetition. Does a local function make this code shorter overall?", "function_tokens": ["@@", "\u0120-", "111", ",", "6", "\u0120+", "111", ",", "15", "\u0120@@", "\u0120def", "\u0120generate", "_", "th", "rift", "_", "files", "(", "th", "rift", "_", "files", "_", "dir", ",", "\u0120env", ",", "\u0120silent", "=", "True", "):", "\u0120LOG", ".", "error", "('", "F", "ailed", "\u0120to", "\u0120generate", "\u0120viewer", "\u0120server", "\u0120files", "')", "\u0120return", "\u0120ret", "\u0120+", "\u0120auth", "_", "th", "rift", "\u0120=", "\u0120os", ".", "path", ".", "join", "(", "th", "rift", "_", "files", "_", "dir", ",", "\u0120'", "authent", "ication", ".", "th", "rift", "')", "\u0120+", "\u0120auth", "_", "th", "rift", "\u0120=", "\u0120'", "authent", "ication", ".", "th", "rift", "'", "\u0120+", "\u0120auth", "_", "cmd", "\u0120=", "\u0120['", "th", "rift", "',", "\u0120'", "-", "r", "',", "\u0120'", "-", "I", "',", "\u0120'", ".'", ",", "\u0120+", "\u0120'", "--", "gen", "',", "\u0120'", "py", "',", "\u0120auth", "_", "th", "rift", "]", "\u0120+", "\u0120ret", "\u0120=", "\u0120run", "_", "cmd", "(", "auth", "_", "cmd", ",", "\u0120thr", "ift", "_", "files", "_", "dir", ",", "\u0120env", ",", "\u0120silent", "=", "sil", "ent", ")", "\u0120+", "\u0120if", "\u0120ret", ":", "\u0120+", "\u0120LOG", ".", "error", "('", "F", "ailed", "\u0120to", "\u0120generate", "\u0120authentication", "\u0120interface", "\u0120files", "')", "\u0120+", "\u0120return", "\u0120ret", "\u0120+", "\u0120#", "\u0120----------------------------------------------------------------", "---", "\u0120def", "\u0120generate", "_", "document", "ation", "(", "doc", "_", "root", ",", "\u0120env", ",", "\u0120silent", "=", "True", "):"], "docstring_tokens": ["There", "\u0120seems", "\u0120to", "\u0120be", "\u0120some", "\u0120repetition", ".", "\u0120Does", "\u0120a", "\u0120local", "\u0120function", "\u0120make", "\u0120this", "\u0120code", "\u0120shorter", "\u0120overall", "?"]}
{"function": "@@ -298,6 +298,7 @@ function diffElementNodes( } if (dom == null) { + isHydrating = false; if (newVNode.type === null) { return document.createTextNode(newProps); }", "text": "Might be cheaper to reuse the `null` assignment of line 313 and set `isHydrating` to null instead WDYT?", "function_tokens": ["@@", "\u0120-", "298", ",", "6", "\u0120+", "298", ",", "7", "\u0120@@", "\u0120function", "\u0120diff", "Element", "N", "odes", "(", "\u0120}", "\u0120if", "\u0120(", "dom", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120+", "\u0120is", "Hyd", "rating", "\u0120=", "\u0120false", ";", "\u0120if", "\u0120(", "new", "V", "Node", ".", "type", "\u0120===", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120document", ".", "create", "Text", "Node", "(", "new", "Pro", "ps", ");", "\u0120}"], "docstring_tokens": ["M", "ight", "\u0120be", "\u0120cheaper", "\u0120to", "\u0120reuse", "\u0120the", "\u0120`", "null", "`", "\u0120assignment", "\u0120of", "\u0120line", "\u0120313", "\u0120and", "\u0120set", "\u0120`", "is", "Hyd", "rating", "`", "\u0120to", "\u0120null", "\u0120instead", "\u0120WD", "Y", "T", "?"]}
{"function": "@@ -22,7 +22,6 @@ import java.util.List; @AutoValue public abstract class TestCaseView { - public abstract String clientMethodName(); public abstract InitCodeView initCode();", "text": "Revert this blank line", "function_tokens": ["@@", "\u0120-", "22", ",", "7", "\u0120+", "22", ",", "6", "\u0120@@", "\u0120import", "\u0120java", ".", "util", ".", "List", ";", "\u0120@", "Auto", "Value", "\u0120public", "\u0120abstract", "\u0120class", "\u0120Test", "Case", "View", "\u0120{", "\u0120-", "\u0120public", "\u0120abstract", "\u0120String", "\u0120client", "Method", "Name", "();", "\u0120public", "\u0120abstract", "\u0120Init", "Code", "View", "\u0120init", "Code", "();"], "docstring_tokens": ["R", "ever", "t", "\u0120this", "\u0120blank", "\u0120line"]}
{"function": "@@ -50,8 +50,8 @@ public class MoveReplicaHDFSTest extends MoveReplicaTest { HdfsTestUtil.teardownClass(dfsCluster); } finally { dfsCluster = null; - System.setProperty(\"solr.hdfs.blockcache.blocksperbank\", \"512\"); - System.setProperty(\"tests.hdfs.numdatanodes\", \"1\"); + System.clearProperty(\"solr.hdfs.blockcache.blocksperbank\"); + System.clearProperty(\"tests.hdfs.numdatanodes\"); } } ", "text": "This was introduced recently for the Hadoop 3 upgrade. Copy/paste error but definitely causing some of the new test failures.", "function_tokens": ["@@", "\u0120-", "50", ",", "8", "\u0120+", "50", ",", "8", "\u0120@@", "\u0120public", "\u0120class", "\u0120Move", "Repl", "ica", "H", "DF", "ST", "est", "\u0120extends", "\u0120Move", "Repl", "ica", "Test", "\u0120{", "\u0120H", "df", "s", "Test", "Ut", "il", ".", "te", "ard", "own", "Class", "(", "df", "s", "Cl", "uster", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120d", "fs", "Cl", "uster", "\u0120=", "\u0120null", ";", "\u0120-", "\u0120System", ".", "set", "Property", "(\"", "sol", "r", ".", "h", "df", "s", ".", "block", "cache", ".", "blocks", "per", "bank", "\",", "\u0120\"", "512", "\");", "\u0120-", "\u0120System", ".", "set", "Property", "(\"", "tests", ".", "h", "df", "s", ".", "num", "dat", "an", "odes", "\",", "\u0120\"", "1", "\");", "\u0120+", "\u0120System", ".", "clear", "Property", "(\"", "sol", "r", ".", "h", "df", "s", ".", "block", "cache", ".", "blocks", "per", "bank", "\");", "\u0120+", "\u0120System", ".", "clear", "Property", "(\"", "tests", ".", "h", "df", "s", ".", "num", "dat", "an", "odes", "\");", "\u0120}", "\u0120}", "\u0120"], "docstring_tokens": ["This", "\u0120was", "\u0120introduced", "\u0120recently", "\u0120for", "\u0120the", "\u0120H", "ado", "op", "\u01203", "\u0120upgrade", ".", "\u0120Copy", "/", "paste", "\u0120error", "\u0120but", "\u0120definitely", "\u0120causing", "\u0120some", "\u0120of", "\u0120the", "\u0120new", "\u0120test", "\u0120failures", "."]}
{"function": "@@ -2,6 +2,7 @@ class ProposalsController < ApplicationController include TokenAuth skip_before_action :authenticate_user!, only: [:approve] + before_action :check_disabled_client # TODO use Policy for all actions before_action ->{authorize proposal}, only: [:show, :cancel, :cancel_form, :history] before_action :needs_token_on_get, only: :approve", "text": "I think we should only need to do this for `:approve` since we are using `authenticate_user!` for all other actions and that checks for disabled client", "function_tokens": ["@@", "\u0120-", "2", ",", "6", "\u0120+", "2", ",", "7", "\u0120@@", "\u0120class", "\u0120Pro", "pos", "als", "Controller", "\u0120<", "\u0120Application", "Controller", "\u0120include", "\u0120Token", "Auth", "\u0120skip", "_", "before", "_", "action", "\u0120:", "authent", "icate", "_", "user", "!,", "\u0120only", ":", "\u0120[", ":", "appro", "ve", "]", "\u0120+", "\u0120before", "_", "action", "\u0120:", "check", "_", "disabled", "_", "client", "\u0120#", "\u0120TOD", "O", "\u0120use", "\u0120Policy", "\u0120for", "\u0120all", "\u0120actions", "\u0120before", "_", "action", "\u0120->", "{", "author", "ize", "\u0120proposal", "},", "\u0120only", ":", "\u0120[", ":", "show", ",", "\u0120:", "c", "ancel", ",", "\u0120:", "c", "ancel", "_", "form", ",", "\u0120:", "history", "]", "\u0120before", "_", "action", "\u0120:", "needs", "_", "token", "_", "on", "_", "get", ",", "\u0120only", ":", "\u0120:", "appro", "ve"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120should", "\u0120only", "\u0120need", "\u0120to", "\u0120do", "\u0120this", "\u0120for", "\u0120`", ":", "appro", "ve", "`", "\u0120since", "\u0120we", "\u0120are", "\u0120using", "\u0120`", "authent", "icate", "_", "user", "!", "`", "\u0120for", "\u0120all", "\u0120other", "\u0120actions", "\u0120and", "\u0120that", "\u0120checks", "\u0120for", "\u0120disabled", "\u0120client"]}
{"function": "@@ -56,9 +56,10 @@ class DefaultBucketViewTest(BaseWebTest, unittest.TestCase): self.app.get(self.collection_url, headers=self.headers) def test_querystring_parameters_are_taken_into_account(self): - self.app.get(self.collection_url + '/records?_since=invalid', - headers=self.headers, - status=400) + resp = self.app.get(self.collection_url + '/records?_since=invalid', + headers=self.headers, + status=400) + self.assertIn('Content-Length', resp.headers) def test_option_is_possible_without_authentication_for_default(self): headers = 'authorization,content-type'", "text": "I wonder if we should create new tests for header checks; here for instance we're mixing querystring and headers. Thoughts?", "function_tokens": ["@@", "\u0120-", "56", ",", "9", "\u0120+", "56", ",", "10", "\u0120@@", "\u0120class", "\u0120Default", "B", "ucket", "View", "Test", "(", "Base", "Web", "Test", ",", "\u0120un", "itt", "est", ".", "Test", "Case", "):", "\u0120self", ".", "app", ".", "get", "(", "self", ".", "collection", "_", "url", ",", "\u0120headers", "=", "self", ".", "headers", ")", "\u0120def", "\u0120test", "_", "query", "string", "_", "param", "eters", "_", "are", "_", "t", "aken", "_", "into", "_", "account", "(", "self", "):", "\u0120-", "\u0120self", ".", "app", ".", "get", "(", "self", ".", "collection", "_", "url", "\u0120+", "\u0120'/", "rec", "ords", "?", "_", "since", "=", "in", "valid", "',", "\u0120-", "\u0120headers", "=", "self", ".", "headers", ",", "\u0120-", "\u0120status", "=", "400", ")", "\u0120+", "\u0120resp", "\u0120=", "\u0120self", ".", "app", ".", "get", "(", "self", ".", "collection", "_", "url", "\u0120+", "\u0120'/", "rec", "ords", "?", "_", "since", "=", "in", "valid", "',", "\u0120+", "\u0120headers", "=", "self", ".", "headers", ",", "\u0120+", "\u0120status", "=", "400", ")", "\u0120+", "\u0120self", ".", "assert", "In", "('", "Content", "-", "Length", "',", "\u0120resp", ".", "headers", ")", "\u0120def", "\u0120test", "_", "option", "_", "is", "_", "p", "ossible", "_", "without", "_", "authent", "ication", "_", "for", "_", "default", "(", "self", "):", "\u0120headers", "\u0120=", "\u0120'", "author", "ization", ",", "content", "-", "type", "'"], "docstring_tokens": ["I", "\u0120wonder", "\u0120if", "\u0120we", "\u0120should", "\u0120create", "\u0120new", "\u0120tests", "\u0120for", "\u0120header", "\u0120checks", ";", "\u0120here", "\u0120for", "\u0120instance", "\u0120we", "'re", "\u0120mixing", "\u0120query", "string", "\u0120and", "\u0120headers", ".", "\u0120Thoughts", "?"]}
{"function": "@@ -42,7 +42,7 @@ module Bolt path = File.join(libexec, 'custom_facts.rb') file = { 'name' => 'custom_facts.rb', 'path' => path } metadata = { 'supports_noop' => true, 'input_method' => 'stdin' } - Bolt::Task.new(name: 'custom_facts', files: [file], metadata: metadata) + Bolt::Task.new(name: 'apply_helpers::custom_facts', files: [file], metadata: metadata) end end ", "text": "We should be able to add sensitive by hard-coding the parameters, same as you put into the metadata in apply_helpers.", "function_tokens": ["@@", "\u0120-", "42", ",", "7", "\u0120+", "42", ",", "7", "\u0120@@", "\u0120module", "\u0120Bolt", "\u0120path", "\u0120=", "\u0120File", ".", "join", "(", "lib", "exec", ",", "\u0120'", "custom", "_", "facts", ".", "rb", "')", "\u0120file", "\u0120=", "\u0120{", "\u0120'", "name", "'", "\u0120=>", "\u0120'", "custom", "_", "facts", ".", "rb", "',", "\u0120'", "path", "'", "\u0120=>", "\u0120path", "\u0120}", "\u0120metadata", "\u0120=", "\u0120{", "\u0120'", "supp", "orts", "_", "no", "op", "'", "\u0120=>", "\u0120true", ",", "\u0120'", "input", "_", "method", "'", "\u0120=>", "\u0120'", "std", "in", "'", "\u0120}", "\u0120-", "\u0120Bolt", "::", "Task", ".", "new", "(", "name", ":", "\u0120'", "custom", "_", "facts", "',", "\u0120files", ":", "\u0120[", "file", "],", "\u0120metadata", ":", "\u0120metadata", ")", "\u0120+", "\u0120Bolt", "::", "Task", ".", "new", "(", "name", ":", "\u0120'", "apply", "_", "help", "ers", "::", "custom", "_", "facts", "',", "\u0120files", ":", "\u0120[", "file", "],", "\u0120metadata", ":", "\u0120metadata", ")", "\u0120end", "\u0120end", "\u0120"], "docstring_tokens": ["We", "\u0120should", "\u0120be", "\u0120able", "\u0120to", "\u0120add", "\u0120sensitive", "\u0120by", "\u0120hard", "-", "c", "oding", "\u0120the", "\u0120parameters", ",", "\u0120same", "\u0120as", "\u0120you", "\u0120put", "\u0120into", "\u0120the", "\u0120metadata", "\u0120in", "\u0120apply", "_", "help", "ers", "."]}
{"function": "@@ -0,0 +1,11 @@ +<?php + +declare(strict_types=1); + +namespace Shopsys\\ShopBundle\\Model\\Order\\Item; + +use Shopsys\\FrameworkBundle\\Model\\Order\\Item\\OrderItemFactory as BaseOrderItemFactory; + +class OrderItemFactory extends BaseOrderItemFactory +{ +}", "text": "Why do you think that it is necessary to create this class?", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "11", "\u0120@@", "\u0120+", "<?", "php", "\u0120+", "\u0120+", "decl", "are", "(", "st", "rict", "_", "types", "=", "1", ");", "\u0120+", "\u0120+", "names", "pace", "\u0120Sh", "ops", "ys", "\\", "Shop", "B", "undle", "\\", "Model", "\\", "Order", "\\", "Item", ";", "\u0120+", "\u0120+", "use", "\u0120Sh", "ops", "ys", "\\", "Fram", "ework", "B", "undle", "\\", "Model", "\\", "Order", "\\", "Item", "\\", "Order", "Item", "Factory", "\u0120as", "\u0120Base", "Order", "Item", "Factory", ";", "\u0120+", "\u0120+", "class", "\u0120Order", "Item", "Factory", "\u0120extends", "\u0120Base", "Order", "Item", "Factory", "\u0120+", "{", "\u0120+", "}"], "docstring_tokens": ["Why", "\u0120do", "\u0120you", "\u0120think", "\u0120that", "\u0120it", "\u0120is", "\u0120necessary", "\u0120to", "\u0120create", "\u0120this", "\u0120class", "?"]}
{"function": "@@ -18,8 +18,8 @@ type Hash struct { // // See http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html for more information. func ComputeHashes(r io.ReadSeeker) Hash { - r.Seek(0, 0) // Read the whole stream - defer r.Seek(0, 0) // Rewind stream at end + start, _ := r.Seek(0, 1) // Read the whole stream + defer r.Seek(start, 0) // Rewind stream at end buf := make([]byte, bufsize) hashes := [][]byte{}", "text": "replacing the `1` with `io.SeekCurrent` may be good here", "function_tokens": ["@@", "\u0120-", "18", ",", "8", "\u0120+", "18", ",", "8", "\u0120@@", "\u0120type", "\u0120Hash", "\u0120struct", "\u0120{", "\u0120//", "\u0120//", "\u0120See", "\u0120http", "://", "docs", ".", "aws", ".", "amazon", ".", "com", "/", "amaz", "ong", "l", "ac", "ier", "/", "latest", "/", "dev", "/", "checks", "um", "-", "cal", "cul", "ations", ".", "html", "\u0120for", "\u0120more", "\u0120information", ".", "\u0120func", "\u0120Comp", "ute", "H", "ashes", "(", "r", "\u0120io", ".", "Read", "Se", "eker", ")", "\u0120Hash", "\u0120{", "\u0120-", "\u0120r", ".", "Se", "ek", "(", "0", ",", "\u01200", ")", "\u0120//", "\u0120Read", "\u0120the", "\u0120whole", "\u0120stream", "\u0120-", "\u0120defer", "\u0120r", ".", "Se", "ek", "(", "0", ",", "\u01200", ")", "\u0120//", "\u0120Rew", "ind", "\u0120stream", "\u0120at", "\u0120end", "\u0120+", "\u0120start", ",", "\u0120_", "\u0120:=", "\u0120r", ".", "Se", "ek", "(", "0", ",", "\u01201", ")", "\u0120//", "\u0120Read", "\u0120the", "\u0120whole", "\u0120stream", "\u0120+", "\u0120defer", "\u0120r", ".", "Se", "ek", "(", "start", ",", "\u01200", ")", "\u0120//", "\u0120Rew", "ind", "\u0120stream", "\u0120at", "\u0120end", "\u0120buf", "\u0120:=", "\u0120make", "(", "[]", "byte", ",", "\u0120buf", "size", ")", "\u0120hashes", "\u0120:=", "\u0120[", "][", "]", "byte", "{", "}"], "docstring_tokens": ["repl", "acing", "\u0120the", "\u0120`", "1", "`", "\u0120with", "\u0120`", "io", ".", "Se", "ek", "Current", "`", "\u0120may", "\u0120be", "\u0120good", "\u0120here"]}
{"function": "@@ -0,0 +1,15 @@ +package main + +import ( + \"time\" + + \"gopkg.in/square/go-jose.v2\" +) + +type JWKSSource interface { + // FetchJWKS returns the key set and modified time. + FetchKeySet() (*jose.JSONWebKeySet, time.Time, bool) + + // Close closes the source. + Close() error +}", "text": "nit: perhaps this file would be better named `jwks_source.go` ?", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "15", "\u0120@@", "\u0120+", "package", "\u0120main", "\u0120+", "\u0120+", "import", "\u0120(", "\u0120+", "\u0120\"", "time", "\"", "\u0120+", "\u0120+", "\u0120\"", "g", "op", "kg", ".", "in", "/", "square", "/", "go", "-", "j", "ose", ".", "v", "2", "\"", "\u0120+", ")", "\u0120+", "\u0120+", "type", "\u0120J", "W", "K", "SS", "ource", "\u0120interface", "\u0120{", "\u0120+", "\u0120//", "\u0120F", "etch", "J", "W", "KS", "\u0120returns", "\u0120the", "\u0120key", "\u0120set", "\u0120and", "\u0120modified", "\u0120time", ".", "\u0120+", "\u0120F", "etch", "Key", "Set", "()", "\u0120(*", "j", "ose", ".", "JSON", "Web", "Key", "Set", ",", "\u0120time", ".", "Time", ",", "\u0120bool", ")", "\u0120+", "\u0120+", "\u0120//", "\u0120Close", "\u0120closes", "\u0120the", "\u0120source", ".", "\u0120+", "\u0120Close", "()", "\u0120error", "\u0120+", "}"], "docstring_tokens": ["nit", ":", "\u0120perhaps", "\u0120this", "\u0120file", "\u0120would", "\u0120be", "\u0120better", "\u0120named", "\u0120`", "j", "w", "ks", "_", "source", ".", "go", "`", "\u0120?"]}
{"function": "@@ -153,6 +153,9 @@ public class Constants { // Overridable plugin load properties public static final String AZ_PLUGIN_LOAD_OVERRIDE_PROPS = \"azkaban.plugin.load.override.props\"; + // File containing param override configs + public static final String PARAM_OVERRIDE_FILE = \"param_override.properties\"; + // Azkaban event reporter constants public static class EventReporterConstants { ", "text": "It will be helpful to specify the intended priority as well for the properties within this file.", "function_tokens": ["@@", "\u0120-", "153", ",", "6", "\u0120+", "153", ",", "9", "\u0120@@", "\u0120public", "\u0120class", "\u0120Const", "ants", "\u0120{", "\u0120//", "\u0120Over", "rid", "able", "\u0120plugin", "\u0120load", "\u0120properties", "\u0120public", "\u0120static", "\u0120final", "\u0120String", "\u0120AZ", "_", "PL", "UG", "IN", "_", "LOAD", "_", "OVER", "R", "IDE", "_", "PR", "OPS", "\u0120=", "\u0120\"", "az", "k", "aban", ".", "plugin", ".", "load", ".", "over", "ride", ".", "pro", "ps", "\";", "\u0120+", "\u0120//", "\u0120File", "\u0120containing", "\u0120param", "\u0120override", "\u0120config", "s", "\u0120+", "\u0120public", "\u0120static", "\u0120final", "\u0120String", "\u0120PAR", "AM", "_", "OVER", "R", "IDE", "_", "FILE", "\u0120=", "\u0120\"", "param", "_", "over", "ride", ".", "properties", "\";", "\u0120+", "\u0120//", "\u0120Az", "k", "aban", "\u0120event", "\u0120reporter", "\u0120constants", "\u0120public", "\u0120static", "\u0120class", "\u0120Event", "Rep", "orter", "Const", "ants", "\u0120{", "\u0120"], "docstring_tokens": ["It", "\u0120will", "\u0120be", "\u0120helpful", "\u0120to", "\u0120specify", "\u0120the", "\u0120intended", "\u0120priority", "\u0120as", "\u0120well", "\u0120for", "\u0120the", "\u0120properties", "\u0120within", "\u0120this", "\u0120file", "."]}
{"function": "@@ -23,6 +23,8 @@ import ( \"github.com/GoogleCloudPlatform/compute-image-tools/go/osinfo\" ) +type RunFunc func(*exec.Cmd) ([]byte, error) + var ( // AptExists indicates whether apt is installed. AptExists bool", "text": "Make this private and update all the public functions to not take this argument. The variable you set below should also be private, then in the tests instead of passing the variable in to the function just update the variable. We don't want to expose the testing implementation in the public api if it can be avoided.", "function_tokens": ["@@", "\u0120-", "23", ",", "6", "\u0120+", "23", ",", "8", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "github", ".", "com", "/", "Google", "Cloud", "Platform", "/", "comp", "ute", "-", "image", "-", "tools", "/", "go", "/", "os", "info", "\"", "\u0120)", "\u0120+", "type", "\u0120Run", "F", "unc", "\u0120func", "(*", "exec", ".", "Cmd", ")", "\u0120(", "[]", "byte", ",", "\u0120error", ")", "\u0120+", "\u0120var", "\u0120(", "\u0120//", "\u0120A", "pt", "Ex", "ists", "\u0120indicates", "\u0120whether", "\u0120apt", "\u0120is", "\u0120installed", ".", "\u0120A", "pt", "Ex", "ists", "\u0120bool"], "docstring_tokens": ["Make", "\u0120this", "\u0120private", "\u0120and", "\u0120update", "\u0120all", "\u0120the", "\u0120public", "\u0120functions", "\u0120to", "\u0120not", "\u0120take", "\u0120this", "\u0120argument", ".", "\u0120The", "\u0120variable", "\u0120you", "\u0120set", "\u0120below", "\u0120should", "\u0120also", "\u0120be", "\u0120private", ",", "\u0120then", "\u0120in", "\u0120the", "\u0120tests", "\u0120instead", "\u0120of", "\u0120passing", "\u0120the", "\u0120variable", "\u0120in", "\u0120to", "\u0120the", "\u0120function", "\u0120just", "\u0120update", "\u0120the", "\u0120variable", ".", "\u0120We", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120expose", "\u0120the", "\u0120testing", "\u0120implementation", "\u0120in", "\u0120the", "\u0120public", "\u0120api", "\u0120if", "\u0120it", "\u0120can", "\u0120be", "\u0120avoided", "."]}
{"function": "@@ -1956,7 +1956,7 @@ SDDkwd__(EXE_DIAGNOSTIC_EVENTS, \"OFF\"), DDkwd__(HIVE_DEFAULT_CHARSET, (char *)SQLCHARSETSTRING_UTF8), DD_____(HIVE_DEFAULT_SCHEMA, \"HIVE\"), DD_____(HIVE_FILE_CHARSET, \"\"), - DD_____(HIVE_FILE_NAME, \"/hive/tpcds/customer/customer.dat\" ), + DD_____(HIVE_FILE_NAME, \"/user/trafodion/hive/tpcds/customer/customer.dat\" ), DD_____(HIVE_HDFS_STATS_LOG_FILE, \"\"), DDui___(HIVE_INSERT_ERROR_MODE, \"1\"), DDint__(HIVE_LIB_HDFS_PORT_OVERRIDE, \"-1\"),", "text": "Do you now why is it a specific table name is used as a default?", "function_tokens": ["@@", "\u0120-", "19", "56", ",", "7", "\u0120+", "19", "56", ",", "7", "\u0120@@", "\u0120SD", "D", "k", "wd", "__", "(", "EX", "E", "_", "D", "IA", "GN", "OST", "IC", "_", "EV", "ENTS", ",", "\u0120\"", "OFF", "\"),", "\u0120DD", "k", "wd", "__", "(", "H", "IVE", "_", "DE", "FAULT", "_", "CH", "ARS", "ET", ",", "\u0120(", "char", "\u0120*)", "SQL", "CH", "ARS", "ET", "STR", "ING", "_", "UTF", "8", "),", "\u0120DD", "_____", "(", "H", "IVE", "_", "DE", "FAULT", "_", "S", "CH", "EMA", ",", "\u0120\"", "H", "IVE", "\"),", "\u0120DD", "_____", "(", "H", "IVE", "_", "FILE", "_", "CH", "ARS", "ET", ",", "\u0120\"", "\"),", "\u0120-", "\u0120DD", "_____", "(", "H", "IVE", "_", "FILE", "_", "NAME", ",", "\u0120\"/", "h", "ive", "/", "t", "pc", "ds", "/", "custom", "er", "/", "custom", "er", ".", "dat", "\"", "\u0120),", "\u0120+", "\u0120DD", "_____", "(", "H", "IVE", "_", "FILE", "_", "NAME", ",", "\u0120\"/", "user", "/", "tra", "f", "od", "ion", "/", "h", "ive", "/", "t", "pc", "ds", "/", "custom", "er", "/", "custom", "er", ".", "dat", "\"", "\u0120),", "\u0120DD", "_____", "(", "H", "IVE", "_", "H", "DF", "S", "_", "ST", "ATS", "_", "LOG", "_", "FILE", ",", "\u0120\"", "\"),", "\u0120DD", "ui", "___", "(", "H", "IVE", "_", "INS", "ERT", "_", "ERROR", "_", "MODE", ",", "\u0120\"", "1", "\"),", "\u0120DD", "int", "__", "(", "H", "IVE", "_", "LIB", "_", "H", "DF", "S", "_", "PORT", "_", "OVER", "R", "IDE", ",", "\u0120\"-", "1", "\"),"], "docstring_tokens": ["Do", "\u0120you", "\u0120now", "\u0120why", "\u0120is", "\u0120it", "\u0120a", "\u0120specific", "\u0120table", "\u0120name", "\u0120is", "\u0120used", "\u0120as", "\u0120a", "\u0120default", "?"]}
{"function": "@@ -414,8 +414,8 @@ namespace Microsoft.DotNet.Build.Tasks return Environment.GetEnvironmentVariable(\"TMPDIR\"); else if (DirExists(Environment.GetEnvironmentVariable(\"TMP\"))) return Environment.GetEnvironmentVariable(\"TMP\"); - else if (DirExists(\"/home/DDITAdministrator/myagent/_work/_temp\")) - return \"/home/DDITAdministrator/myagent/_work/_temp\"; + else if (DirExists(Path.Combine(Environment.GetEnvironmentVariable(\"HOME\"), \"myagent/_work/_temp\"))) + return Path.Combine(Environment.GetEnvironmentVariable(\"HOME\"), \"myagent/_work/_temp\"); else { Log.LogMessage(\"No TEMP dir found.\");", "text": "If all you're doing is checking for the existence of a directory as your \"temp\" directory, why does it matter what OS you're on?", "function_tokens": ["@@", "\u0120-", "414", ",", "8", "\u0120+", "414", ",", "8", "\u0120@@", "\u0120namespace", "\u0120Microsoft", ".", "D", "ot", "Net", ".", "Build", ".", "T", "asks", "\u0120return", "\u0120Environment", ".", "Get", "Environment", "Variable", "(\"", "TM", "PD", "IR", "\");", "\u0120else", "\u0120if", "\u0120(", "Dir", "Ex", "ists", "(", "Environment", ".", "Get", "Environment", "Variable", "(\"", "T", "MP", "\"", ")))", "\u0120return", "\u0120Environment", ".", "Get", "Environment", "Variable", "(\"", "T", "MP", "\");", "\u0120-", "\u0120else", "\u0120if", "\u0120(", "Dir", "Ex", "ists", "(\"", "/", "home", "/", "DD", "IT", "Administ", "rator", "/", "my", "agent", "/_", "work", "/_", "temp", "\"))", "\u0120-", "\u0120return", "\u0120\"/", "home", "/", "DD", "IT", "Administ", "rator", "/", "my", "agent", "/_", "work", "/_", "temp", "\";", "\u0120+", "\u0120else", "\u0120if", "\u0120(", "Dir", "Ex", "ists", "(", "Path", ".", "Comb", "ine", "(", "Environment", ".", "Get", "Environment", "Variable", "(\"", "HOME", "\"),", "\u0120\"", "my", "agent", "/_", "work", "/_", "temp", "\"", ")))", "\u0120+", "\u0120return", "\u0120Path", ".", "Comb", "ine", "(", "Environment", ".", "Get", "Environment", "Variable", "(\"", "HOME", "\"),", "\u0120\"", "my", "agent", "/_", "work", "/_", "temp", "\");", "\u0120else", "\u0120{", "\u0120Log", ".", "Log", "Message", "(\"", "No", "\u0120T", "EMP", "\u0120dir", "\u0120found", ".\"", ");"], "docstring_tokens": ["If", "\u0120all", "\u0120you", "'re", "\u0120doing", "\u0120is", "\u0120checking", "\u0120for", "\u0120the", "\u0120existence", "\u0120of", "\u0120a", "\u0120directory", "\u0120as", "\u0120your", "\u0120\"", "temp", "\"", "\u0120directory", ",", "\u0120why", "\u0120does", "\u0120it", "\u0120matter", "\u0120what", "\u0120OS", "\u0120you", "'re", "\u0120on", "?"]}
{"function": "@@ -60,10 +60,11 @@ package server import ( - \"fmt\" + v2 \"github.com/algorand/go-algorand/daemon/algod/api/server/v2\" + \"github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated\" \"net/http\" - \"github.com/gorilla/mux\" + \"github.com/labstack/echo/v4\" \"github.com/algorand/go-algorand/daemon/algod/api/server/common\" \"github.com/algorand/go-algorand/daemon/algod/api/server/lib\"", "text": "nit- would be cleaner to import it once", "function_tokens": ["@@", "\u0120-", "60", ",", "10", "\u0120+", "60", ",", "11", "\u0120@@", "\u0120package", "\u0120server", "\u0120import", "\u0120(", "\u0120-", "\u0120\"", "f", "mt", "\"", "\u0120+", "\u0120v", "2", "\u0120\"", "github", ".", "com", "/", "al", "gor", "and", "/", "go", "-", "al", "gor", "and", "/", "da", "emon", "/", "alg", "od", "/", "api", "/", "server", "/", "v", "2", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "al", "gor", "and", "/", "go", "-", "al", "gor", "and", "/", "da", "emon", "/", "alg", "od", "/", "api", "/", "server", "/", "v", "2", "/", "generated", "\"", "\u0120\"", "net", "/", "http", "\"", "\u0120-", "\u0120\"", "github", ".", "com", "/", "gor", "illa", "/", "m", "ux", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "lab", "stack", "/", "echo", "/", "v", "4", "\"", "\u0120\"", "github", ".", "com", "/", "al", "gor", "and", "/", "go", "-", "al", "gor", "and", "/", "da", "emon", "/", "alg", "od", "/", "api", "/", "server", "/", "common", "\"", "\u0120\"", "github", ".", "com", "/", "al", "gor", "and", "/", "go", "-", "al", "gor", "and", "/", "da", "emon", "/", "alg", "od", "/", "api", "/", "server", "/", "lib", "\""], "docstring_tokens": ["nit", "-", "\u0120would", "\u0120be", "\u0120cleaner", "\u0120to", "\u0120import", "\u0120it", "\u0120once"]}
{"function": "@@ -159,6 +159,14 @@ class GenericProxyHandler(BaseHTTPRequestHandler): # allow pre-flight CORS headers by default if 'Access-Control-Allow-Origin' not in response.headers: self.send_header('Access-Control-Allow-Origin', '*') + if 'Access-Control-Allow-Headers' not in response.headers: + self.send_header('Access-Control-Allow-Headers', ','.join([ + 'authorization', + 'x-amz-content-sha256', + 'x-amz-date', + 'x-amz-security-token', + 'x-amz-user-agent' + ]) self.end_headers() if len(response.content):", "text": "Looks like there is a closing parenthesis `)` missing here.", "function_tokens": ["@@", "\u0120-", "159", ",", "6", "\u0120+", "159", ",", "14", "\u0120@@", "\u0120class", "\u0120Generic", "Proxy", "Handler", "(", "Base", "HTTP", "Request", "Handler", "):", "\u0120#", "\u0120allow", "\u0120pre", "-", "flight", "\u0120C", "ORS", "\u0120headers", "\u0120by", "\u0120default", "\u0120if", "\u0120'", "Access", "-", "Control", "-", "Allow", "-", "Origin", "'", "\u0120not", "\u0120in", "\u0120response", ".", "headers", ":", "\u0120self", ".", "send", "_", "header", "('", "Access", "-", "Control", "-", "Allow", "-", "Origin", "',", "\u0120'", "*", "')", "\u0120+", "\u0120if", "\u0120'", "Access", "-", "Control", "-", "Allow", "-", "Head", "ers", "'", "\u0120not", "\u0120in", "\u0120response", ".", "headers", ":", "\u0120+", "\u0120self", ".", "send", "_", "header", "('", "Access", "-", "Control", "-", "Allow", "-", "Head", "ers", "',", "\u0120'", ",'", ".", "join", "([", "\u0120+", "\u0120'", "author", "ization", "',", "\u0120+", "\u0120'", "x", "-", "am", "z", "-", "content", "-", "sha", "256", "',", "\u0120+", "\u0120'", "x", "-", "am", "z", "-", "date", "',", "\u0120+", "\u0120'", "x", "-", "am", "z", "-", "security", "-", "token", "',", "\u0120+", "\u0120'", "x", "-", "am", "z", "-", "user", "-", "agent", "'", "\u0120+", "\u0120])", "\u0120self", ".", "end", "_", "headers", "()", "\u0120if", "\u0120len", "(", "response", ".", "content", "):"], "docstring_tokens": ["Looks", "\u0120like", "\u0120there", "\u0120is", "\u0120a", "\u0120closing", "\u0120parent", "hesis", "\u0120`", ")", "`", "\u0120missing", "\u0120here", "."]}
{"function": "@@ -1684,8 +1684,8 @@ void PairTlsph::coeff(int narg, char **arg) { } // end energy release rate failure criterion else { - sprintf(str, \"unknown *KEYWORD: %s\", arg[ioffset]); - error->all(FLERR, str); + snprintf(str,128,\"unknown *KEYWORD: %s\", arg[ioffset]); + error->all(FLERR, str); } }", "text": "this one bothers me. There are many places where this one is written to for an error message and just a single callsite is changed.", "function_tokens": ["@@", "\u0120-", "16", "84", ",", "8", "\u0120+", "16", "84", ",", "8", "\u0120@@", "\u0120void", "\u0120Pair", "T", "ls", "ph", "::", "co", "eff", "(", "int", "\u0120n", "arg", ",", "\u0120char", "\u0120**", "arg", ")", "\u0120{", "\u0120}", "\u0120//", "\u0120end", "\u0120energy", "\u0120release", "\u0120rate", "\u0120failure", "\u0120criterion", "\u0120else", "\u0120{", "\u0120-", "\u0120sprint", "f", "(", "str", ",", "\u0120\"", "unknown", "\u0120*", "KEY", "W", "ORD", ":", "\u0120%", "s", "\",", "\u0120arg", "[", "io", "ff", "set", "]);", "\u0120-", "\u0120error", "->", "all", "(", "FL", "ER", "R", ",", "\u0120str", ");", "\u0120+", "\u0120sn", "printf", "(", "str", ",", "128", ",\"", "unknown", "\u0120*", "KEY", "W", "ORD", ":", "\u0120%", "s", "\",", "\u0120arg", "[", "io", "ff", "set", "]);", "\u0120+", "\u0120error", "->", "all", "(", "FL", "ER", "R", ",", "\u0120str", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["this", "\u0120one", "\u0120bothers", "\u0120me", ".", "\u0120There", "\u0120are", "\u0120many", "\u0120places", "\u0120where", "\u0120this", "\u0120one", "\u0120is", "\u0120written", "\u0120to", "\u0120for", "\u0120an", "\u0120error", "\u0120message", "\u0120and", "\u0120just", "\u0120a", "\u0120single", "\u0120calls", "ite", "\u0120is", "\u0120changed", "."]}
{"function": "@@ -706,6 +706,7 @@ func TestKBFSOpsGetBaseDirChildrenCacheSuccess(t *testing.T) { ops := getOps(config, id) n := nodeFromPath(t, ops, p) + config.mockMdserv.EXPECT().FastForwardBackoff().AnyTimes() children, err := config.KBFSOps().GetDirChildren(ctx, n) if err != nil { t.Errorf(\"Got error on getdir: %+v\", err)", "text": "You can put this in `kbfsOpsInit()` in you want, so we don't have to call it in every test.", "function_tokens": ["@@", "\u0120-", "706", ",", "6", "\u0120+", "706", ",", "7", "\u0120@@", "\u0120func", "\u0120Test", "KB", "FS", "Ops", "Get", "Base", "Dir", "Children", "Cache", "Success", "(", "t", "\u0120*", "testing", ".", "T", ")", "\u0120{", "\u0120ops", "\u0120:=", "\u0120get", "Ops", "(", "config", ",", "\u0120id", ")", "\u0120n", "\u0120:=", "\u0120node", "From", "Path", "(", "t", ",", "\u0120ops", ",", "\u0120p", ")", "\u0120+", "\u0120config", ".", "m", "ock", "M", "d", "serv", ".", "EXP", "ECT", "().", "Fast", "Forward", "Back", "off", "().", "Any", "Times", "()", "\u0120children", ",", "\u0120err", "\u0120:=", "\u0120config", ".", "KB", "FS", "Ops", "().", "Get", "Dir", "Children", "(", "ctx", ",", "\u0120n", ")", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120t", ".", "Error", "f", "(\"", "Got", "\u0120error", "\u0120on", "\u0120get", "dir", ":", "\u0120%", "+", "v", "\",", "\u0120err", ")"], "docstring_tokens": ["You", "\u0120can", "\u0120put", "\u0120this", "\u0120in", "\u0120`", "kb", "fs", "Ops", "Init", "()", "`", "\u0120in", "\u0120you", "\u0120want", ",", "\u0120so", "\u0120we", "\u0120don", "'t", "\u0120have", "\u0120to", "\u0120call", "\u0120it", "\u0120in", "\u0120every", "\u0120test", "."]}
{"function": "@@ -528,8 +528,10 @@ drx_insert_counter_update(void *drcontext, instrlist_t *ilist, instr_t *where, } } #elif defined(AARCHXX) +# ifdef ARM_32 /* FIXME i#1551: implement 64-bit counter support */ - ASSERT(!is_64, \"DRX_COUNTER_64BIT is not implemented\"); + ASSERT(!is_64, \"DRX_COUNTER_64BIT is not implemented for ARM_32\"); +# endif /* ARM_32 */ if (use_drreg) { if (drreg_reserve_register(drcontext, ilist, where, NULL, &reg1) !=", "text": "`ARM_32` is what clients define as an input to DR, and is not always defined internally: we use just `ARM` to mean AArch32.", "function_tokens": ["@@", "\u0120-", "528", ",", "8", "\u0120+", "528", ",", "10", "\u0120@@", "\u0120dr", "x", "_", "insert", "_", "counter", "_", "update", "(", "void", "\u0120*", "dr", "context", ",", "\u0120instr", "list", "_", "t", "\u0120*", "il", "ist", ",", "\u0120instr", "_", "t", "\u0120*", "where", ",", "\u0120}", "\u0120}", "\u0120#", "el", "if", "\u0120defined", "(", "A", "ARCH", "XX", ")", "\u0120+#", "\u0120if", "def", "\u0120ARM", "_", "32", "\u0120/*", "\u0120FIX", "ME", "\u0120i", "#", "15", "51", ":", "\u0120implement", "\u012064", "-", "bit", "\u0120counter", "\u0120support", "\u0120*/", "\u0120-", "\u0120ASS", "ERT", "(", "!", "is", "_", "64", ",", "\u0120\"", "DR", "X", "_", "C", "OUN", "TER", "_", "64", "BIT", "\u0120is", "\u0120not", "\u0120implemented", "\");", "\u0120+", "\u0120ASS", "ERT", "(", "!", "is", "_", "64", ",", "\u0120\"", "DR", "X", "_", "C", "OUN", "TER", "_", "64", "BIT", "\u0120is", "\u0120not", "\u0120implemented", "\u0120for", "\u0120ARM", "_", "32", "\");", "\u0120+#", "\u0120endif", "\u0120/*", "\u0120ARM", "_", "32", "\u0120*/", "\u0120if", "\u0120(", "use", "_", "dr", "reg", ")", "\u0120{", "\u0120if", "\u0120(", "dr", "reg", "_", "res", "erve", "_", "register", "(", "dr", "context", ",", "\u0120il", "ist", ",", "\u0120where", ",", "\u0120NULL", ",", "\u0120&", "reg", "1", ")", "\u0120!="], "docstring_tokens": ["`", "ARM", "_", "32", "`", "\u0120is", "\u0120what", "\u0120clients", "\u0120define", "\u0120as", "\u0120an", "\u0120input", "\u0120to", "\u0120DR", ",", "\u0120and", "\u0120is", "\u0120not", "\u0120always", "\u0120defined", "\u0120internally", ":", "\u0120we", "\u0120use", "\u0120just", "\u0120`", "ARM", "`", "\u0120to", "\u0120mean", "\u0120A", "Arch", "32", "."]}
{"function": "@@ -38,8 +38,11 @@ import javax.annotation.Nullable; /** A field declaration wrapper around a Discovery Schema. */ public class DiscoveryField implements FieldModel, TypeModel { private final List<DiscoveryField> properties; + // Dereferenced schema for use rendering type names and determining properties, type, and format. private final Schema schema; - private final Schema originalSchema; // Not dereferenced schema. + + // Not dereferenced schema; used in rendering this FieldModel's parameter name. + private final Schema originalSchema; private final DiscoApiModel apiModel; /* Create a FieldModel object from a non-null Schema object, and internally dereference the input schema. */", "text": "s/for use/to use for/", "function_tokens": ["@@", "\u0120-", "38", ",", "8", "\u0120+", "38", ",", "11", "\u0120@@", "\u0120import", "\u0120j", "av", "ax", ".", "ann", "otation", ".", "Null", "able", ";", "\u0120/**", "\u0120A", "\u0120field", "\u0120declaration", "\u0120wrapper", "\u0120around", "\u0120a", "\u0120Discovery", "\u0120Sche", "ma", ".", "\u0120*/", "\u0120public", "\u0120class", "\u0120Discovery", "Field", "\u0120implements", "\u0120Field", "Model", ",", "\u0120Type", "Model", "\u0120{", "\u0120private", "\u0120final", "\u0120List", "<", "D", "iscovery", "Field", ">", "\u0120properties", ";", "\u0120+", "\u0120//", "\u0120D", "ere", "f", "eren", "ced", "\u0120schema", "\u0120for", "\u0120use", "\u0120rendering", "\u0120type", "\u0120names", "\u0120and", "\u0120determining", "\u0120properties", ",", "\u0120type", ",", "\u0120and", "\u0120format", ".", "\u0120private", "\u0120final", "\u0120Sche", "ma", "\u0120schema", ";", "\u0120-", "\u0120private", "\u0120final", "\u0120Sche", "ma", "\u0120original", "Sche", "ma", ";", "\u0120//", "\u0120Not", "\u0120de", "ref", "eren", "ced", "\u0120schema", ".", "\u0120+", "\u0120+", "\u0120//", "\u0120Not", "\u0120de", "ref", "eren", "ced", "\u0120schema", ";", "\u0120used", "\u0120in", "\u0120rendering", "\u0120this", "\u0120Field", "Model", "'s", "\u0120parameter", "\u0120name", ".", "\u0120+", "\u0120private", "\u0120final", "\u0120Sche", "ma", "\u0120original", "Sche", "ma", ";", "\u0120private", "\u0120final", "\u0120Disco", "A", "pi", "Model", "\u0120api", "Model", ";", "\u0120/*", "\u0120Create", "\u0120a", "\u0120Field", "Model", "\u0120object", "\u0120from", "\u0120a", "\u0120non", "-", "null", "\u0120Sche", "ma", "\u0120object", ",", "\u0120and", "\u0120internally", "\u0120de", "reference", "\u0120the", "\u0120input", "\u0120schema", ".", "\u0120*/"], "docstring_tokens": ["s", "/", "for", "\u0120use", "/", "to", "\u0120use", "\u0120for", "/"]}
{"function": "@@ -60,7 +60,7 @@ class UserCreatedEventProjector 'language' => $event->getLanguage()->getCode(), 'password' => $event->getPassword()->getValue(), 'is_active' => $event->isActive(), - 'avatar_id' => $event->getAvatarId() ? $event->getAvatarId()->getValue() : null, + 'avatar_filename' => $event->getAvatarFilename() ? $event->getAvatarFilename()->getValue() : null, ], [ 'is_active' => \\PDO::PARAM_BOOL,", "text": "` $event->getAvatarFilename()` this function return `string` or `null`. In this place ` $event->getAvatarFilename()->getValue()` return `Fatal error `", "function_tokens": ["@@", "\u0120-", "60", ",", "7", "\u0120+", "60", ",", "7", "\u0120@@", "\u0120class", "\u0120User", "Created", "Event", "Project", "or", "\u0120'", "language", "'", "\u0120=>", "\u0120$", "event", "->", "get", "Language", "()", "->", "get", "Code", "(),", "\u0120'", "password", "'", "\u0120=>", "\u0120$", "event", "->", "get", "Password", "()", "->", "get", "Value", "(),", "\u0120'", "is", "_", "active", "'", "\u0120=>", "\u0120$", "event", "->", "is", "Active", "(),", "\u0120-", "\u0120'", "av", "atar", "_", "id", "'", "\u0120=>", "\u0120$", "event", "->", "get", "Av", "atar", "Id", "()", "\u0120?", "\u0120$", "event", "->", "get", "Av", "atar", "Id", "()", "->", "get", "Value", "()", "\u0120:", "\u0120null", ",", "\u0120+", "\u0120'", "av", "atar", "_", "filename", "'", "\u0120=>", "\u0120$", "event", "->", "get", "Av", "atar", "Filename", "()", "\u0120?", "\u0120$", "event", "->", "get", "Av", "atar", "Filename", "()", "->", "get", "Value", "()", "\u0120:", "\u0120null", ",", "\u0120],", "\u0120[", "\u0120'", "is", "_", "active", "'", "\u0120=>", "\u0120\\", "PD", "O", "::", "PAR", "AM", "_", "BO", "OL", ","], "docstring_tokens": ["`", "\u0120$", "event", "->", "get", "Av", "atar", "Filename", "()", "`", "\u0120this", "\u0120function", "\u0120return", "\u0120`", "string", "`", "\u0120or", "\u0120`", "null", "`.", "\u0120In", "\u0120this", "\u0120place", "\u0120`", "\u0120$", "event", "->", "get", "Av", "atar", "Filename", "()", "->", "get", "Value", "()", "`", "\u0120return", "\u0120`", "F", "atal", "\u0120error", "\u0120`"]}
{"function": "@@ -34,7 +34,7 @@ import ( var ( // ErrPersistenceLimitExceeded is the error indicating QPS limit reached. - ErrPersistenceLimitExceeded = serviceerror.NewResourceExhausted(\"Persistence Max QPS Reached.\") + ErrPersistenceLimitExceeded = serviceerror.NewUnavailable(\"Persistence Max QPS Reached.\") ) type (", "text": "why not creating a new error type for server's own resource limit exceed error and do conversion within rpc interceptor?", "function_tokens": ["@@", "\u0120-", "34", ",", "7", "\u0120+", "34", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120var", "\u0120(", "\u0120//", "\u0120Err", "Pers", "istence", "Limit", "Ex", "ceed", "ed", "\u0120is", "\u0120the", "\u0120error", "\u0120indicating", "\u0120Q", "PS", "\u0120limit", "\u0120reached", ".", "\u0120-", "\u0120Err", "Pers", "istence", "Limit", "Ex", "ceed", "ed", "\u0120=", "\u0120service", "error", ".", "New", "Resource", "Ex", "ha", "usted", "(\"", "Pers", "istence", "\u0120Max", "\u0120Q", "PS", "\u0120Reached", ".\")", "\u0120+", "\u0120Err", "Pers", "istence", "Limit", "Ex", "ceed", "ed", "\u0120=", "\u0120service", "error", ".", "New", "Un", "available", "(\"", "Pers", "istence", "\u0120Max", "\u0120Q", "PS", "\u0120Reached", ".\")", "\u0120)", "\u0120type", "\u0120("], "docstring_tokens": ["why", "\u0120not", "\u0120creating", "\u0120a", "\u0120new", "\u0120error", "\u0120type", "\u0120for", "\u0120server", "'s", "\u0120own", "\u0120resource", "\u0120limit", "\u0120exceed", "\u0120error", "\u0120and", "\u0120do", "\u0120conversion", "\u0120within", "\u0120r", "pc", "\u0120intercept", "or", "?"]}
{"function": "@@ -27,13 +27,10 @@ namespace OpenTelemetry.Instrumentation.AspNet public class AspNetInstrumentationOptions { /// <summary> - /// Gets or sets <see cref=\"TextMapPropagator\"/> for context propagation. Default value: <see cref=\"CompositeTextMapPropagator\"/> with <see cref=\"TraceContextPropagator\"/> &amp; <see cref=\"BaggagePropagator\"/>. + /// Gets or sets <see cref=\"TextMapPropagator\"/> for context propagation. + /// By default, <see cref=\"Propagators.DefaultTextMapPropagator\" /> will be used. /// </summary> - public TextMapPropagator Propagator { get; set; } = new CompositeTextMapPropagator(new TextMapPropagator[] - { - new TraceContextPropagator(), - new BaggagePropagator(), - }); + public TextMapPropagator Propagator { get; set; } = Propagators.DefaultTextMapPropagator; /// <summary> /// Gets or sets a Filter function to filter instrumentation for requests on a per request basis.", "text": "Could be a timing thing here. When options are created they'll copy the ref for the current default propagator. If user sets through SDK the global propagator after that, it won't be reflected. Could leave it null here and then when it is used in instrumentation do `options.Propagator ?? Propagators.DefaultTextMapPropagator`. It would be a slight perf hit but it makes it hot-swappable.", "function_tokens": ["@@", "\u0120-", "27", ",", "13", "\u0120+", "27", ",", "10", "\u0120@@", "\u0120namespace", "\u0120Open", "Tele", "metry", ".", "In", "strument", "ation", ".", "As", "p", "Net", "\u0120public", "\u0120class", "\u0120As", "p", "Net", "In", "strument", "ation", "Options", "\u0120{", "\u0120///", "\u0120<", "summary", ">", "\u0120-", "\u0120///", "\u0120Gets", "\u0120or", "\u0120sets", "\u0120<", "see", "\u0120cre", "f", "=\"", "Text", "Map", "Prop", "ag", "ator", "\"/>", "\u0120for", "\u0120context", "\u0120propagation", ".", "\u0120Default", "\u0120value", ":", "\u0120<", "see", "\u0120cre", "f", "=\"", "Com", "pos", "ite", "Text", "Map", "Prop", "ag", "ator", "\"/>", "\u0120with", "\u0120<", "see", "\u0120cre", "f", "=\"", "Tr", "ace", "Context", "Prop", "ag", "ator", "\"/>", "\u0120&", "amp", ";", "\u0120<", "see", "\u0120cre", "f", "=\"", "B", "agg", "age", "Prop", "ag", "ator", "\"/>", ".", "\u0120+", "\u0120///", "\u0120Gets", "\u0120or", "\u0120sets", "\u0120<", "see", "\u0120cre", "f", "=\"", "Text", "Map", "Prop", "ag", "ator", "\"/>", "\u0120for", "\u0120context", "\u0120propagation", ".", "\u0120+", "\u0120///", "\u0120By", "\u0120default", ",", "\u0120<", "see", "\u0120cre", "f", "=\"", "Prop", "ag", "ators", ".", "Default", "Text", "Map", "Prop", "ag", "ator", "\"", "\u0120/>", "\u0120will", "\u0120be", "\u0120used", ".", "\u0120///", "\u0120</", "summary", ">", "\u0120-", "\u0120public", "\u0120Text", "Map", "Prop", "ag", "ator", "\u0120Prop", "ag", "ator", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u0120new", "\u0120Composite", "Text", "Map", "Prop", "ag", "ator", "(", "new", "\u0120Text", "Map", "Prop", "ag", "ator", "[]", "\u0120-", "\u0120{", "\u0120-", "\u0120new", "\u0120Trace", "Context", "Prop", "ag", "ator", "(),", "\u0120-", "\u0120new", "\u0120Bagg", "age", "Prop", "ag", "ator", "(),", "\u0120-", "\u0120});", "\u0120+", "\u0120public", "\u0120Text", "Map", "Prop", "ag", "ator", "\u0120Prop", "ag", "ator", "\u0120{", "\u0120get", ";", "\u0120set", ";", "\u0120}", "\u0120=", "\u0120Prop", "ag", "ators", ".", "Default", "Text", "Map", "Prop", "ag", "ator", ";", "\u0120///", "\u0120<", "summary", ">", "\u0120///", "\u0120Gets", "\u0120or", "\u0120sets", "\u0120a", "\u0120Filter", "\u0120function", "\u0120to", "\u0120filter", "\u0120instrument", "ation", "\u0120for", "\u0120requests", "\u0120on", "\u0120a", "\u0120per", "\u0120request", "\u0120basis", "."], "docstring_tokens": ["Could", "\u0120be", "\u0120a", "\u0120timing", "\u0120thing", "\u0120here", ".", "\u0120When", "\u0120options", "\u0120are", "\u0120created", "\u0120they", "'ll", "\u0120copy", "\u0120the", "\u0120ref", "\u0120for", "\u0120the", "\u0120current", "\u0120default", "\u0120propag", "ator", ".", "\u0120If", "\u0120user", "\u0120sets", "\u0120through", "\u0120SDK", "\u0120the", "\u0120global", "\u0120propag", "ator", "\u0120after", "\u0120that", ",", "\u0120it", "\u0120won", "'t", "\u0120be", "\u0120reflected", ".", "\u0120Could", "\u0120leave", "\u0120it", "\u0120null", "\u0120here", "\u0120and", "\u0120then", "\u0120when", "\u0120it", "\u0120is", "\u0120used", "\u0120in", "\u0120instrument", "ation", "\u0120do", "\u0120`", "options", ".", "Prop", "ag", "ator", "\u0120??", "\u0120Prop", "ag", "ators", ".", "Default", "Text", "Map", "Prop", "ag", "ator", "`.", "\u0120It", "\u0120would", "\u0120be", "\u0120a", "\u0120slight", "\u0120perf", "\u0120hit", "\u0120but", "\u0120it", "\u0120makes", "\u0120it", "\u0120hot", "-", "sw", "app", "able", "."]}
{"function": "@@ -158,7 +158,6 @@ public class TransactionSimulator { callParams.getFrom() != null ? callParams.getFrom() : DEFAULT_FROM; BlockHeader blockHeaderToProcess = header; - if (transactionValidationParams.isAllowExceedingBalance()) { updater.getOrCreate(senderAddress).getMutable().setBalance(Wei.of(UInt256.MAX_VALUE)); if (header.getBaseFee().isPresent()) {", "text": "Unrelated file. Please remove from PR.", "function_tokens": ["@@", "\u0120-", "158", ",", "7", "\u0120+", "158", ",", "6", "\u0120@@", "\u0120public", "\u0120class", "\u0120Transaction", "Sim", "ulator", "\u0120{", "\u0120call", "Par", "ams", ".", "get", "From", "()", "\u0120!=", "\u0120null", "\u0120?", "\u0120call", "Par", "ams", ".", "get", "From", "()", "\u0120:", "\u0120DE", "FAULT", "_", "FR", "OM", ";", "\u0120Block", "Header", "\u0120block", "Header", "To", "Process", "\u0120=", "\u0120header", ";", "\u0120-", "\u0120if", "\u0120(", "trans", "action", "Val", "idation", "Par", "ams", ".", "is", "Allow", "Ex", "ceed", "ing", "Balance", "())", "\u0120{", "\u0120upd", "ater", ".", "get", "Or", "Create", "(", "s", "ender", "Address", ").", "get", "M", "utable", "().", "set", "Balance", "(", "We", "i", ".", "of", "(", "U", "Int", "256", ".", "MAX", "_", "VALUE", "));", "\u0120if", "\u0120(", "header", ".", "get", "Base", "F", "ee", "().", "is", "Present", "())", "\u0120{"], "docstring_tokens": ["Un", "related", "\u0120file", ".", "\u0120Please", "\u0120remove", "\u0120from", "\u0120PR", "."]}
{"function": "@@ -2663,6 +2663,7 @@ static work_queue_msg_code_t process_http_request( struct work_queue *q, struct } else { // Other requests get raw JSON data. send_worker_msg(q,w,\"Content-type: text/plain\\n\\n\"); + send_worker_msg(q,w,\"Access-Control-Allow-Origin: *\\n\\n\"); process_queue_status(q, w, &path[1], stoptime ); } ", "text": "Careful: you only want two newlines after the final header message. (That indicates the end of headers and the start of data.)", "function_tokens": ["@@", "\u0120-", "26", "63", ",", "6", "\u0120+", "26", "63", ",", "7", "\u0120@@", "\u0120static", "\u0120work", "_", "queue", "_", "msg", "_", "code", "_", "t", "\u0120process", "_", "http", "_", "request", "(", "\u0120struct", "\u0120work", "_", "queue", "\u0120*", "q", ",", "\u0120struct", "\u0120}", "\u0120else", "\u0120{", "\u0120//", "\u0120Other", "\u0120requests", "\u0120get", "\u0120raw", "\u0120JSON", "\u0120data", ".", "\u0120send", "_", "worker", "_", "msg", "(", "q", ",", "w", ",\"", "Content", "-", "type", ":", "\u0120text", "/", "plain", "\\", "n", "\\", "n", "\");", "\u0120+", "\u0120send", "_", "worker", "_", "msg", "(", "q", ",", "w", ",\"", "Access", "-", "Control", "-", "Allow", "-", "Origin", ":", "\u0120*", "\\", "n", "\\", "n", "\");", "\u0120process", "_", "queue", "_", "status", "(", "q", ",", "\u0120w", ",", "\u0120&", "path", "[", "1", "],", "\u0120stop", "time", "\u0120);", "\u0120}", "\u0120"], "docstring_tokens": ["Care", "ful", ":", "\u0120you", "\u0120only", "\u0120want", "\u0120two", "\u0120new", "lines", "\u0120after", "\u0120the", "\u0120final", "\u0120header", "\u0120message", ".", "\u0120(", "That", "\u0120indicates", "\u0120the", "\u0120end", "\u0120of", "\u0120headers", "\u0120and", "\u0120the", "\u0120start", "\u0120of", "\u0120data", ".)"]}
{"function": "@@ -9,6 +9,9 @@ def request(flow): flow.request.headers.pop('If-Modified-Since', None) flow.request.headers.pop('Cache-Control', None) + # do not force https redirection + flow.request.headers.pop('Upgrade-Insecure-Requests', None) + # proxy connections to SSL-enabled hosts if flow.request.pretty_host in secure_hosts: flow.request.scheme = 'https'", "text": "This will not work on Python 3 (to which we are transitioning) because `.content` is bytes, not a str. Can you make the pattern a bytes object as well (like so: `b\"pattern\"`)?", "function_tokens": ["@@", "\u0120-", "9", ",", "6", "\u0120+", "9", ",", "9", "\u0120@@", "\u0120def", "\u0120request", "(", "flow", "):", "\u0120flow", ".", "request", ".", "headers", ".", "pop", "('", "If", "-", "Mod", "ified", "-", "Since", "',", "\u0120None", ")", "\u0120flow", ".", "request", ".", "headers", ".", "pop", "('", "Cache", "-", "Control", "',", "\u0120None", ")", "\u0120+", "\u0120#", "\u0120do", "\u0120not", "\u0120force", "\u0120https", "\u0120red", "irection", "\u0120+", "\u0120flow", ".", "request", ".", "headers", ".", "pop", "('", "Upgrade", "-", "In", "secure", "-", "Requ", "ests", "',", "\u0120None", ")", "\u0120+", "\u0120#", "\u0120proxy", "\u0120connections", "\u0120to", "\u0120SSL", "-", "enabled", "\u0120hosts", "\u0120if", "\u0120flow", ".", "request", ".", "pretty", "_", "host", "\u0120in", "\u0120secure", "_", "host", "s", ":", "\u0120flow", ".", "request", ".", "sche", "me", "\u0120=", "\u0120'", "https", "'"], "docstring_tokens": ["This", "\u0120will", "\u0120not", "\u0120work", "\u0120on", "\u0120Python", "\u01203", "\u0120(", "to", "\u0120which", "\u0120we", "\u0120are", "\u0120transitioning", ")", "\u0120because", "\u0120`", ".", "content", "`", "\u0120is", "\u0120bytes", ",", "\u0120not", "\u0120a", "\u0120str", ".", "\u0120Can", "\u0120you", "\u0120make", "\u0120the", "\u0120pattern", "\u0120a", "\u0120bytes", "\u0120object", "\u0120as", "\u0120well", "\u0120(", "like", "\u0120so", ":", "\u0120`", "b", "\"", "pattern", "\"", "`", ")?"]}
{"function": "@@ -85,7 +85,7 @@ const ariaRoles = { }, combobox: { type: 'composite', - requiredOwned: ['textbox', 'listbox', 'tree', 'grid', 'dialog'], + requiredOwned: ['listbox', 'tree', 'grid', 'dialog', 'textbox'], requiredAttrs: ['aria-expanded'], // Note: because aria-controls is not well supported we will not // make it a required attribute even though it is required in the", "text": "This was to allow the tests to pass when the order of the required was different. Silly, but we don't have an easy way to check for \"equal but order doesn't matter\" in chai.", "function_tokens": ["@@", "\u0120-", "85", ",", "7", "\u0120+", "85", ",", "7", "\u0120@@", "\u0120const", "\u0120a", "ria", "R", "oles", "\u0120=", "\u0120{", "\u0120},", "\u0120comb", "ob", "ox", ":", "\u0120{", "\u0120type", ":", "\u0120'", "com", "pos", "ite", "',", "\u0120-", "\u0120required", "Own", "ed", ":", "\u0120['", "text", "box", "',", "\u0120'", "list", "box", "',", "\u0120'", "tree", "',", "\u0120'", "grid", "',", "\u0120'", "dial", "og", "'", "],", "\u0120+", "\u0120required", "Own", "ed", ":", "\u0120['", "list", "box", "',", "\u0120'", "tree", "',", "\u0120'", "grid", "',", "\u0120'", "dial", "og", "',", "\u0120'", "text", "box", "'", "],", "\u0120required", "Att", "rs", ":", "\u0120['", "aria", "-", "exp", "anded", "'", "],", "\u0120//", "\u0120Note", ":", "\u0120because", "\u0120a", "ria", "-", "control", "s", "\u0120is", "\u0120not", "\u0120well", "\u0120supported", "\u0120we", "\u0120will", "\u0120not", "\u0120//", "\u0120make", "\u0120it", "\u0120a", "\u0120required", "\u0120attribute", "\u0120even", "\u0120though", "\u0120it", "\u0120is", "\u0120required", "\u0120in", "\u0120the"], "docstring_tokens": ["This", "\u0120was", "\u0120to", "\u0120allow", "\u0120the", "\u0120tests", "\u0120to", "\u0120pass", "\u0120when", "\u0120the", "\u0120order", "\u0120of", "\u0120the", "\u0120required", "\u0120was", "\u0120different", ".", "\u0120S", "illy", ",", "\u0120but", "\u0120we", "\u0120don", "'t", "\u0120have", "\u0120an", "\u0120easy", "\u0120way", "\u0120to", "\u0120check", "\u0120for", "\u0120\"", "equal", "\u0120but", "\u0120order", "\u0120doesn", "'t", "\u0120matter", "\"", "\u0120in", "\u0120ch", "ai", "."]}
{"function": "@@ -16546,6 +16546,18 @@ RelInternalSP::costMethod() const } // RelInternalSP::costMethod() //<pb> +CostMethod * +HbaseDelete::costMethod() const +{ + if (CmpCommon::getDefault(HBASE_DELETE_COSTING) == DF_OFF) + return RelExpr::costMethod(); // returns cost 1 cost object + + static THREAD_P CostMethodHbaseDelete *m = NULL; + if (m == NULL) + m = new (GetCliGlobals()->exCollHeap()) CostMethodHbaseDelete(); + return m; +} // HbaseDelete::costMethod() + PhysicalProperty* HbaseDelete::synthPhysicalProperty(const Context* myContext, const Lng32 planNumber,", "text": "maybe say \"returns the default cost method that returns an object of cost 1\".", "function_tokens": ["@@", "\u0120-", "165", "46", ",", "6", "\u0120+", "165", "46", ",", "18", "\u0120@@", "\u0120Rel", "Internal", "SP", "::", "cost", "Method", "()", "\u0120const", "\u0120}", "\u0120//", "\u0120Rel", "Internal", "SP", "::", "cost", "Method", "()", "\u0120//", "<", "pb", ">", "\u0120+", "Cost", "Method", "\u0120*", "\u0120+", "H", "base", "Delete", "::", "cost", "Method", "()", "\u0120const", "\u0120+", "{", "\u0120+", "\u0120if", "\u0120(", "C", "mp", "Common", "::", "get", "Default", "(", "HB", "ASE", "_", "DE", "LE", "TE", "_", "CO", "ST", "ING", ")", "\u0120==", "\u0120DF", "_", "OFF", ")", "\u0120+", "\u0120return", "\u0120Rel", "Ex", "pr", "::", "cost", "Method", "();", "\u0120//", "\u0120returns", "\u0120cost", "\u01201", "\u0120cost", "\u0120object", "\u0120+", "\u0120+", "\u0120static", "\u0120TH", "READ", "_", "P", "\u0120Cost", "Method", "H", "base", "Delete", "\u0120*", "m", "\u0120=", "\u0120NULL", ";", "\u0120+", "\u0120if", "\u0120(", "m", "\u0120==", "\u0120NULL", ")", "\u0120+", "\u0120m", "\u0120=", "\u0120new", "\u0120(", "Get", "Cl", "i", "Gl", "ob", "als", "()", "->", "ex", "Coll", "He", "ap", "())", "\u0120Cost", "Method", "H", "base", "Delete", "();", "\u0120+", "\u0120return", "\u0120m", ";", "\u0120+", "}", "\u0120//", "\u0120H", "base", "Delete", "::", "cost", "Method", "()", "\u0120+", "\u0120Physical", "Property", "*", "\u0120H", "base", "Delete", "::", "syn", "th", "Physical", "Property", "(", "const", "\u0120Context", "*", "\u0120my", "Context", ",", "\u0120const", "\u0120L", "ng", "32", "\u0120plan", "Number", ","], "docstring_tokens": ["maybe", "\u0120say", "\u0120\"", "return", "s", "\u0120the", "\u0120default", "\u0120cost", "\u0120method", "\u0120that", "\u0120returns", "\u0120an", "\u0120object", "\u0120of", "\u0120cost", "\u01201", "\"."]}
{"function": "@@ -293,6 +293,19 @@ func (r *DefaultRuleRenderer) endpointIptablesChain( }, }) + rules = append(rules, Rule{ + Match: Match().ProtocolNum(ProtoUDP). + DestPorts(uint16(r.Config.VXLANPort)). + VXLANVNI(uint32(r.Config.VXLANVNI)), + Action: DropAction{}, + Comment: \"Drop VXLAN encapped packets originating in pods\", + }) + rules = append(rules, Rule{ + Match: Match().ProtocolNum(ProtoIPIP), + Action: DropAction{}, + Comment: \"Drop IPinIP encapped packets originating in pods\", + }) + if len(policyNames) > 0 { // Clear the \"pass\" mark. If a policy sets that mark, we'll skip the rest of the policies and // continue processing the profiles, if there are any.", "text": "I believe these rules will be enforced both (1) on egress from a local workload, and (2) on ingress **to** a local workload. Right? I understand that we definitely want (1), but do we really want to enforce (2) as well?", "function_tokens": ["@@", "\u0120-", "293", ",", "6", "\u0120+", "293", ",", "19", "\u0120@@", "\u0120func", "\u0120(", "r", "\u0120*", "Default", "Rule", "R", "end", "erer", ")", "\u0120endpoint", "I", "pt", "ables", "Chain", "(", "\u0120},", "\u0120})", "\u0120+", "\u0120rules", "\u0120=", "\u0120append", "(", "rules", ",", "\u0120Rule", "{", "\u0120+", "\u0120Match", ":", "\u0120Match", "().", "Prot", "ocol", "Num", "(", "Pro", "to", "U", "DP", ").", "\u0120+", "\u0120Dest", "P", "orts", "(", "uint", "16", "(", "r", ".", "Config", ".", "V", "X", "LAN", "Port", ")).", "\u0120+", "\u0120V", "X", "LAN", "V", "NI", "(", "uint", "32", "(", "r", ".", "Config", ".", "V", "X", "LAN", "V", "NI", ")),", "\u0120+", "\u0120Action", ":", "\u0120Drop", "Action", "{", "},", "\u0120+", "\u0120Comment", ":", "\u0120\"", "Drop", "\u0120V", "X", "LAN", "\u0120enc", "apped", "\u0120packets", "\u0120originating", "\u0120in", "\u0120pods", "\",", "\u0120+", "\u0120})", "\u0120+", "\u0120rules", "\u0120=", "\u0120append", "(", "rules", ",", "\u0120Rule", "{", "\u0120+", "\u0120Match", ":", "\u0120Match", "().", "Prot", "ocol", "Num", "(", "Pro", "to", "IP", "IP", "),", "\u0120+", "\u0120Action", ":", "\u0120Drop", "Action", "{", "},", "\u0120+", "\u0120Comment", ":", "\u0120\"", "Drop", "\u0120IP", "in", "IP", "\u0120enc", "apped", "\u0120packets", "\u0120originating", "\u0120in", "\u0120pods", "\",", "\u0120+", "\u0120})", "\u0120+", "\u0120if", "\u0120len", "(", "policy", "Names", ")", "\u0120>", "\u01200", "\u0120{", "\u0120//", "\u0120Clear", "\u0120the", "\u0120\"", "pass", "\"", "\u0120mark", ".", "\u0120If", "\u0120a", "\u0120policy", "\u0120sets", "\u0120that", "\u0120mark", ",", "\u0120we", "'ll", "\u0120skip", "\u0120the", "\u0120rest", "\u0120of", "\u0120the", "\u0120policies", "\u0120and", "\u0120//", "\u0120continue", "\u0120processing", "\u0120the", "\u0120profiles", ",", "\u0120if", "\u0120there", "\u0120are", "\u0120any", "."], "docstring_tokens": ["I", "\u0120believe", "\u0120these", "\u0120rules", "\u0120will", "\u0120be", "\u0120enforced", "\u0120both", "\u0120(", "1", ")", "\u0120on", "\u0120e", "gress", "\u0120from", "\u0120a", "\u0120local", "\u0120workload", ",", "\u0120and", "\u0120(", "2", ")", "\u0120on", "\u0120ing", "ress", "\u0120**", "to", "**", "\u0120a", "\u0120local", "\u0120workload", ".", "\u0120Right", "?", "\u0120I", "\u0120understand", "\u0120that", "\u0120we", "\u0120definitely", "\u0120want", "\u0120(", "1", "),", "\u0120but", "\u0120do", "\u0120we", "\u0120really", "\u0120want", "\u0120to", "\u0120enforce", "\u0120(", "2", ")", "\u0120as", "\u0120well", "?"]}
{"function": "@@ -125,7 +125,9 @@ public class SalesforceNetworkPlugin extends ForcePlugin { try { // Not a 2xx status if (!response.isSuccess()) { - callbackContext.error(response.asString()); + JSONObject errorObj = new JSONObject(); + errorObj.putOpt(\"response\", response.fullResponseAsJSONObject()); + callbackContext.error(errorObj.toString()); } // Binary response else if (returnBinary) {", "text": "Use `response.asJsonObject()` instead. Also, use `put()` instead of `putOpt()`, `null` as a value is fine.", "function_tokens": ["@@", "\u0120-", "125", ",", "7", "\u0120+", "125", ",", "9", "\u0120@@", "\u0120public", "\u0120class", "\u0120Sales", "force", "Network", "Plugin", "\u0120extends", "\u0120Force", "Plugin", "\u0120{", "\u0120try", "\u0120{", "\u0120//", "\u0120Not", "\u0120a", "\u01202", "xx", "\u0120status", "\u0120if", "\u0120(!", "response", ".", "is", "Success", "())", "\u0120{", "\u0120-", "\u0120callback", "Context", ".", "error", "(", "response", ".", "as", "String", "());", "\u0120+", "\u0120JSON", "Object", "\u0120error", "Obj", "\u0120=", "\u0120new", "\u0120JSON", "Object", "();", "\u0120+", "\u0120error", "Obj", ".", "put", "Opt", "(\"", "response", "\",", "\u0120response", ".", "full", "Response", "As", "JSON", "Object", "());", "\u0120+", "\u0120callback", "Context", ".", "error", "(", "error", "Obj", ".", "to", "String", "());", "\u0120}", "\u0120//", "\u0120Binary", "\u0120response", "\u0120else", "\u0120if", "\u0120(", "return", "B", "inary", ")", "\u0120{"], "docstring_tokens": ["Use", "\u0120`", "response", ".", "as", "J", "son", "Object", "()", "`", "\u0120instead", ".", "\u0120Also", ",", "\u0120use", "\u0120`", "put", "()", "`", "\u0120instead", "\u0120of", "\u0120`", "put", "Opt", "()", "`,", "\u0120`", "null", "`", "\u0120as", "\u0120a", "\u0120value", "\u0120is", "\u0120fine", "."]}
{"function": "@@ -113,7 +113,7 @@ describe('PasswordEditor', () => { const editorHolder = $('.handsontableInputHolder'); const editor = editorHolder.find('.handsontableInput'); - expect(parseInt(editorHolder.css('z-index'), 10)).toBeGreaterThan(0); + expect(editorHolder.is(':visible')).toBe(true); editor.val('Edgar'); ", "text": "Are you sure? We've changed it during an introduction of the IME support.", "function_tokens": ["@@", "\u0120-", "113", ",", "7", "\u0120+", "113", ",", "7", "\u0120@@", "\u0120describe", "('", "Password", "Editor", "',", "\u0120()", "\u0120=>", "\u0120{", "\u0120const", "\u0120editor", "H", "older", "\u0120=", "\u0120$(", "'.", "hands", "ont", "able", "Input", "H", "older", "');", "\u0120const", "\u0120editor", "\u0120=", "\u0120editor", "H", "older", ".", "find", "(", "'.", "hands", "ont", "able", "Input", "');", "\u0120-", "\u0120expect", "(", "parse", "Int", "(", "editor", "H", "older", ".", "css", "('", "z", "-", "index", "'),", "\u012010", ")).", "to", "Be", "Great", "er", "Th", "an", "(", "0", ");", "\u0120+", "\u0120expect", "(", "editor", "H", "older", ".", "is", "(", "':", "visible", "')", ").", "to", "Be", "(", "true", ");", "\u0120editor", ".", "val", "('", "Ed", "gar", "');", "\u0120"], "docstring_tokens": ["Are", "\u0120you", "\u0120sure", "?", "\u0120We", "'ve", "\u0120changed", "\u0120it", "\u0120during", "\u0120an", "\u0120introduction", "\u0120of", "\u0120the", "\u0120IM", "E", "\u0120support", "."]}
{"function": "@@ -46,7 +46,7 @@ class QueryBuilder $queryBuilder->leftJoin('entity.'.$sortFieldParts[0], $sortFieldParts[0]); } - if (!empty($dqlFilter)) { + if (null !== $dqlFilter) { $queryBuilder->andWhere($dqlFilter); } ", "text": "I think here we want the use of `empty()` to take care of empty strings. If you put `dql_filter: ''` in your YAML config ... this will add `->andWhere('')` and it will fail, right?", "function_tokens": ["@@", "\u0120-", "46", ",", "7", "\u0120+", "46", ",", "7", "\u0120@@", "\u0120class", "\u0120Query", "Builder", "\u0120$", "query", "Builder", "->", "left", "Join", "('", "entity", ".'", ".$", "sort", "Field", "Parts", "[", "0", "],", "\u0120$", "sort", "Field", "Parts", "[", "0", "]);", "\u0120}", "\u0120-", "\u0120if", "\u0120(!", "empty", "($", "d", "ql", "Filter", "))", "\u0120{", "\u0120+", "\u0120if", "\u0120(", "null", "\u0120!", "==", "\u0120$", "d", "ql", "Filter", ")", "\u0120{", "\u0120$", "query", "Builder", "->", "and", "Where", "($", "d", "ql", "Filter", ");", "\u0120}", "\u0120"], "docstring_tokens": ["I", "\u0120think", "\u0120here", "\u0120we", "\u0120want", "\u0120the", "\u0120use", "\u0120of", "\u0120`", "empty", "()", "`", "\u0120to", "\u0120take", "\u0120care", "\u0120of", "\u0120empty", "\u0120strings", ".", "\u0120If", "\u0120you", "\u0120put", "\u0120`", "d", "ql", "_", "filter", ":", "\u0120''", "`", "\u0120in", "\u0120your", "\u0120Y", "AM", "L", "\u0120config", "\u0120...", "\u0120this", "\u0120will", "\u0120add", "\u0120`", "->", "and", "Where", "(", "''", ")", "`", "\u0120and", "\u0120it", "\u0120will", "\u0120fail", ",", "\u0120right", "?"]}
{"function": "@@ -170,14 +170,12 @@ func (p *Agent) Start(ctx context.Context) error { p2pMsgLatency.WithLabelValues(\"broadcast\", strconv.Itoa(int(broadcast.MsgType)), status).Observe(float64(latency)) }() if err = proto.Unmarshal(data, &broadcast); err != nil { - err = errors.Wrap(err, \"error when marshaling broadcast message\") - return + return errors.Wrap(err, \"error when marshaling broadcast message\") } // Skip the broadcast message if it's from the node itself rawmsg, ok := p2p.GetBroadcastMsg(ctx) if !ok { - err = errors.New(\"error when asserting broadcast msg context\") - return + return errors.New(\"error when asserting broadcast msg context\") } peerID = rawmsg.GetFrom().Pretty() if p.host.HostIdentity() == peerID {", "text": "this is golang's named return, err is defined, `return` is equivalent to `return err` the current code has no problem", "function_tokens": ["@@", "\u0120-", "170", ",", "14", "\u0120+", "170", ",", "12", "\u0120@@", "\u0120func", "\u0120(", "p", "\u0120*", "Agent", ")", "\u0120Start", "(", "ctx", "\u0120context", ".", "Context", ")", "\u0120error", "\u0120{", "\u0120p", "2", "p", "Msg", "Lat", "ency", ".", "With", "Label", "Values", "(\"", "broad", "cast", "\",", "\u0120str", "conv", ".", "It", "oa", "(", "int", "(", "broad", "cast", ".", "Msg", "Type", ")),", "\u0120status", ").", "Obs", "erve", "(", "float", "64", "(", "lat", "ency", "))", "\u0120}", "()", "\u0120if", "\u0120err", "\u0120=", "\u0120proto", ".", "Un", "m", "arsh", "al", "(", "data", ",", "\u0120&", "broad", "cast", ");", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120-", "\u0120err", "\u0120=", "\u0120errors", ".", "W", "rap", "(", "err", ",", "\u0120\"", "error", "\u0120when", "\u0120marsh", "aling", "\u0120broadcast", "\u0120message", "\")", "\u0120-", "\u0120return", "\u0120+", "\u0120return", "\u0120errors", ".", "W", "rap", "(", "err", ",", "\u0120\"", "error", "\u0120when", "\u0120marsh", "aling", "\u0120broadcast", "\u0120message", "\")", "\u0120}", "\u0120//", "\u0120Skip", "\u0120the", "\u0120broadcast", "\u0120message", "\u0120if", "\u0120it", "'s", "\u0120from", "\u0120the", "\u0120node", "\u0120itself", "\u0120raw", "msg", ",", "\u0120ok", "\u0120:=", "\u0120p", "2", "p", ".", "Get", "Broad", "cast", "Msg", "(", "ctx", ")", "\u0120if", "\u0120!", "ok", "\u0120{", "\u0120-", "\u0120err", "\u0120=", "\u0120errors", ".", "New", "(\"", "error", "\u0120when", "\u0120asserting", "\u0120broadcast", "\u0120msg", "\u0120context", "\")", "\u0120-", "\u0120return", "\u0120+", "\u0120return", "\u0120errors", ".", "New", "(\"", "error", "\u0120when", "\u0120asserting", "\u0120broadcast", "\u0120msg", "\u0120context", "\")", "\u0120}", "\u0120peer", "ID", "\u0120=", "\u0120raw", "msg", ".", "Get", "From", "().", "Pretty", "()", "\u0120if", "\u0120p", ".", "host", ".", "Host", "Id", "entity", "()", "\u0120==", "\u0120peer", "ID", "\u0120{"], "docstring_tokens": ["this", "\u0120is", "\u0120gol", "ang", "'s", "\u0120named", "\u0120return", ",", "\u0120err", "\u0120is", "\u0120defined", ",", "\u0120`", "return", "`", "\u0120is", "\u0120equivalent", "\u0120to", "\u0120`", "return", "\u0120err", "`", "\u0120the", "\u0120current", "\u0120code", "\u0120has", "\u0120no", "\u0120problem"]}
{"function": "@@ -202,7 +202,7 @@ ostree_gpg_verify_result_get_all (OstreeGpgVerifyResult *result, * ostree_gpg_verify_result_describe: * @result: an #OstreeGpgVerifyResult * @signature_index: which signature to describe - * @output_buffer: a #GString to hold the description + * @output_buffer: (out): a #GString to hold the description * @line_prefix: (allow-none): optional line prefix string * @flags: flags to adjust the description format *", "text": "I don't think this is right; in Rust terms it's like a `&mut String`, in Java `StringBuilder` - it's not a return value from the function which is what `(out)` is for.", "function_tokens": ["@@", "\u0120-", "202", ",", "7", "\u0120+", "202", ",", "7", "\u0120@@", "\u0120ost", "ree", "_", "g", "pg", "_", "ver", "ify", "_", "result", "_", "get", "_", "all", "\u0120(", "O", "st", "ree", "G", "pg", "Ver", "ify", "Result", "\u0120*", "result", ",", "\u0120*", "\u0120ost", "ree", "_", "g", "pg", "_", "ver", "ify", "_", "result", "_", "desc", "ribe", ":", "\u0120*", "\u0120@", "result", ":", "\u0120an", "\u0120#", "O", "st", "ree", "G", "pg", "Ver", "ify", "Result", "\u0120*", "\u0120@", "sign", "ature", "_", "index", ":", "\u0120which", "\u0120signature", "\u0120to", "\u0120describe", "\u0120-", "\u0120*", "\u0120@", "output", "_", "buffer", ":", "\u0120a", "\u0120#", "G", "String", "\u0120to", "\u0120hold", "\u0120the", "\u0120description", "\u0120+", "\u0120*", "\u0120@", "output", "_", "buffer", ":", "\u0120(", "out", "):", "\u0120a", "\u0120#", "G", "String", "\u0120to", "\u0120hold", "\u0120the", "\u0120description", "\u0120*", "\u0120@", "line", "_", "prefix", ":", "\u0120(", "allow", "-", "none", "):", "\u0120optional", "\u0120line", "\u0120prefix", "\u0120string", "\u0120*", "\u0120@", "flags", ":", "\u0120flags", "\u0120to", "\u0120adjust", "\u0120the", "\u0120description", "\u0120format", "\u0120*"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120this", "\u0120is", "\u0120right", ";", "\u0120in", "\u0120Rust", "\u0120terms", "\u0120it", "'s", "\u0120like", "\u0120a", "\u0120`", "&", "mut", "\u0120String", "`,", "\u0120in", "\u0120Java", "\u0120`", "String", "Builder", "`", "\u0120-", "\u0120it", "'s", "\u0120not", "\u0120a", "\u0120return", "\u0120value", "\u0120from", "\u0120the", "\u0120function", "\u0120which", "\u0120is", "\u0120what", "\u0120`", "(", "out", ")", "`", "\u0120is", "\u0120for", "."]}
{"function": "@@ -7,9 +7,9 @@ from ..registry import LOSSES def _expand_binary_labels(labels, label_weights, label_channels): bin_labels = labels.new_full((labels.size(0), label_channels), 0) - inds = torch.nonzero(labels >= 1).squeeze() + inds = torch.nonzero((labels >= 0) & (labels < label_channels)).squeeze() if inds.numel() > 0: - bin_labels[inds, labels[inds] - 1] = 1 + bin_labels[inds, labels[inds]] = 1 bin_label_weights = label_weights.view(-1, 1).expand( label_weights.size(0), label_channels) return bin_labels, bin_label_weights", "text": "If the label is not binary, should we rename this function?", "function_tokens": ["@@", "\u0120-", "7", ",", "9", "\u0120+", "7", ",", "9", "\u0120@@", "\u0120from", "\u0120..", "reg", "istry", "\u0120import", "\u0120L", "OSS", "ES", "\u0120def", "\u0120_", "exp", "and", "_", "binary", "_", "lab", "els", "(", "lab", "els", ",", "\u0120label", "_", "weights", ",", "\u0120label", "_", "ch", "annels", "):", "\u0120bin", "_", "lab", "els", "\u0120=", "\u0120labels", ".", "new", "_", "full", "((", "lab", "els", ".", "size", "(", "0", "),", "\u0120label", "_", "ch", "annels", "),", "\u01200", ")", "\u0120-", "\u0120ind", "s", "\u0120=", "\u0120torch", ".", "non", "zero", "(", "lab", "els", "\u0120>=", "\u01201", ").", "squ", "ee", "ze", "()", "\u0120+", "\u0120ind", "s", "\u0120=", "\u0120torch", ".", "non", "zero", "((", "lab", "els", "\u0120>=", "\u01200", ")", "\u0120&", "\u0120(", "lab", "els", "\u0120<", "\u0120label", "_", "ch", "annels", ")).", "squ", "ee", "ze", "()", "\u0120if", "\u0120ind", "s", ".", "num", "el", "()", "\u0120>", "\u01200", ":", "\u0120-", "\u0120bin", "_", "lab", "els", "[", "ind", "s", ",", "\u0120labels", "[", "ind", "s", "]", "\u0120-", "\u01201", "]", "\u0120=", "\u01201", "\u0120+", "\u0120bin", "_", "lab", "els", "[", "ind", "s", ",", "\u0120labels", "[", "ind", "s", "]]", "\u0120=", "\u01201", "\u0120bin", "_", "label", "_", "weights", "\u0120=", "\u0120label", "_", "weights", ".", "view", "(-", "1", ",", "\u01201", ").", "exp", "and", "(", "\u0120label", "_", "weights", ".", "size", "(", "0", "),", "\u0120label", "_", "ch", "annels", ")", "\u0120return", "\u0120bin", "_", "lab", "els", ",", "\u0120bin", "_", "label", "_", "weights"], "docstring_tokens": ["If", "\u0120the", "\u0120label", "\u0120is", "\u0120not", "\u0120binary", ",", "\u0120should", "\u0120we", "\u0120rename", "\u0120this", "\u0120function", "?"]}
{"function": "@@ -421,10 +421,12 @@ class JMeterExecutor(ScenarioExecutor, WidgetProvider, FileLister): :param file_list: :return: etree \"\"\" + cur_path = r\"${__BeanShell(import org.apache.jmeter.services.FileServer; FileServer.getFileServer()\" \\ + r\".getBaseDir();)}${__BeanShell(File.separator,)}\" for file_path in file_list: file_path_elements = jmx.xpath('//stringProp[text()=\"%s\"]' % file_path) for file_path_element in file_path_elements: - file_path_element.text = os.path.basename(file_path) + file_path_element.text = cur_path + os.path.basename(file_path) def __get_resource_files_from_jmx(self, jmx): \"\"\"", "text": "This is very-very bad idea because of its performance impact", "function_tokens": ["@@", "\u0120-", "421", ",", "10", "\u0120+", "421", ",", "12", "\u0120@@", "\u0120class", "\u0120JM", "eter", "Exec", "utor", "(", "Sc", "enario", "Exec", "utor", ",", "\u0120W", "idget", "Provider", ",", "\u0120File", "L", "ister", "):", "\u0120:", "param", "\u0120file", "_", "list", ":", "\u0120:", "return", ":", "\u0120et", "ree", "\u0120\"\"\"", "\u0120+", "\u0120cur", "_", "path", "\u0120=", "\u0120r", "\"", "${", "__", "Be", "an", "Shell", "(", "import", "\u0120org", ".", "apache", ".", "j", "meter", ".", "services", ".", "File", "Server", ";", "\u0120File", "Server", ".", "get", "File", "Server", "()", "\"", "\u0120\\", "\u0120+", "\u0120r", "\".", "get", "Base", "Dir", "();", ")}", "${", "__", "Be", "an", "Shell", "(", "File", ".", "separ", "ator", ",)", "}\"", "\u0120for", "\u0120file", "_", "path", "\u0120in", "\u0120file", "_", "list", ":", "\u0120file", "_", "path", "_", "e", "lements", "\u0120=", "\u0120j", "mx", ".", "x", "path", "('", "//", "string", "Prop", "[", "text", "()", "=\"", "%", "s", "\"]", "'", "\u0120%", "\u0120file", "_", "path", ")", "\u0120for", "\u0120file", "_", "path", "_", "element", "\u0120in", "\u0120file", "_", "path", "_", "e", "lements", ":", "\u0120-", "\u0120file", "_", "path", "_", "element", ".", "text", "\u0120=", "\u0120os", ".", "path", ".", "bas", "ename", "(", "file", "_", "path", ")", "\u0120+", "\u0120file", "_", "path", "_", "element", ".", "text", "\u0120=", "\u0120cur", "_", "path", "\u0120+", "\u0120os", ".", "path", ".", "bas", "ename", "(", "file", "_", "path", ")", "\u0120def", "\u0120__", "get", "_", "resource", "_", "files", "_", "from", "_", "j", "mx", "(", "self", ",", "\u0120j", "mx", "):", "\u0120\"\"\""], "docstring_tokens": ["This", "\u0120is", "\u0120very", "-", "very", "\u0120bad", "\u0120idea", "\u0120because", "\u0120of", "\u0120its", "\u0120performance", "\u0120impact"]}
{"function": "@@ -6,6 +6,7 @@ import ( \"database/sql\" \"encoding/json\" \"fmt\" + \"github.com/sonm-io/core/proto\" \"math/big\" \"net\" \"sync\"", "text": "WHY U NOT SORT IMPORTS?", "function_tokens": ["@@", "\u0120-", "6", ",", "6", "\u0120+", "6", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "database", "/", "sql", "\"", "\u0120\"", "enc", "oding", "/", "json", "\"", "\u0120\"", "f", "mt", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "son", "m", "-", "io", "/", "core", "/", "pro", "to", "\"", "\u0120\"", "math", "/", "big", "\"", "\u0120\"", "net", "\"", "\u0120\"", "sync", "\""], "docstring_tokens": ["WH", "Y", "\u0120U", "\u0120NOT", "\u0120S", "ORT", "\u0120IMP", "ORTS", "?"]}
{"function": "@@ -0,0 +1,11 @@ +module SignInRequestHelpers + def sign_in_as(user) + post( + \"/session\", + session: { + email: user.email, + password: user.password, + }, + ) + end +end", "text": "Put a comma after the last item of a multiline hash.", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "11", "\u0120@@", "\u0120+", "module", "\u0120Sign", "In", "Request", "Hel", "pers", "\u0120+", "\u0120def", "\u0120sign", "_", "in", "_", "as", "(", "user", ")", "\u0120+", "\u0120post", "(", "\u0120+", "\u0120\"/", "session", "\",", "\u0120+", "\u0120session", ":", "\u0120{", "\u0120+", "\u0120email", ":", "\u0120user", ".", "email", ",", "\u0120+", "\u0120password", ":", "\u0120user", ".", "password", ",", "\u0120+", "\u0120},", "\u0120+", "\u0120)", "\u0120+", "\u0120end", "\u0120+", "end"], "docstring_tokens": ["Put", "\u0120a", "\u0120comma", "\u0120after", "\u0120the", "\u0120last", "\u0120item", "\u0120of", "\u0120a", "\u0120mult", "il", "ine", "\u0120hash", "."]}
{"function": "@@ -12,7 +12,7 @@ __version__ = param.Version(release=(1,7,0), fpath=__file__, commit=\"$Format:%h$\", reponame='holoviews') from .core import archive # noqa (API import) -from .core.dimension import OrderedDict, Dimension # noqa (API import) +from .core.dimension import OrderedDict, Dimension, Dimensioned # noqa (API import) from .core.boundingregion import BoundingBox # noqa (API import) from .core.options import (Options, Store, Cycle, # noqa (API import) Palette, StoreOptions)", "text": "How come we need ``Dimensioned`` in the top-level namespace?", "function_tokens": ["@@", "\u0120-", "12", ",", "7", "\u0120+", "12", ",", "7", "\u0120@@", "\u0120__", "version", "__", "\u0120=", "\u0120param", ".", "Version", "(", "release", "=(", "1", ",", "7", ",", "0", "),", "\u0120f", "path", "=", "__", "file", "__", ",", "\u0120commit", "=\"", "$", "Format", ":", "%", "h", "$", "\",", "\u0120rep", "on", "ame", "='", "hol", "ov", "iew", "s", "')", "\u0120from", "\u0120.", "core", "\u0120import", "\u0120archive", "\u0120#", "\u0120no", "qa", "\u0120(", "API", "\u0120import", ")", "\u0120-", "from", "\u0120.", "core", ".", "dimension", "\u0120import", "\u0120Ord", "ered", "D", "ict", ",", "\u0120Dimension", "\u0120#", "\u0120no", "qa", "\u0120(", "API", "\u0120import", ")", "\u0120+", "from", "\u0120.", "core", ".", "dimension", "\u0120import", "\u0120Ord", "ered", "D", "ict", ",", "\u0120Dimension", ",", "\u0120Dimension", "ed", "\u0120#", "\u0120no", "qa", "\u0120(", "API", "\u0120import", ")", "\u0120from", "\u0120.", "core", ".", "bound", "ing", "region", "\u0120import", "\u0120B", "ounding", "Box", "\u0120#", "\u0120no", "qa", "\u0120(", "API", "\u0120import", ")", "\u0120from", "\u0120.", "core", ".", "options", "\u0120import", "\u0120(", "Options", ",", "\u0120Store", ",", "\u0120Cycle", ",", "\u0120#", "\u0120no", "qa", "\u0120(", "API", "\u0120import", ")", "\u0120Pal", "ette", ",", "\u0120Store", "Options", ")"], "docstring_tokens": ["How", "\u0120come", "\u0120we", "\u0120need", "\u0120``", "Dim", "ension", "ed", "``", "\u0120in", "\u0120the", "\u0120top", "-", "level", "\u0120namespace", "?"]}
{"function": "@@ -75,9 +75,9 @@ import net.runelite.client.util.Text; import net.runelite.client.util.WildcardMatcher; @PluginDescriptor( - name = \"NPC Indicators\", - description = \"Highlight NPCs on-screen and/or on the minimap\", - tags = {\"highlight\", \"minimap\", \"npcs\", \"overlay\", \"respawn\", \"tags\"} + name = \"NPC Indicators\", + description = \"Highlight NPCs on-screen and/or on the minimap\", + tags = {\"highlight\", \"minimap\", \"npcs\", \"overlay\", \"respawn\", \"tags\"} ) @Slf4j @Singleton", "text": "excess whitespace through plugin.", "function_tokens": ["@@", "\u0120-", "75", ",", "9", "\u0120+", "75", ",", "9", "\u0120@@", "\u0120import", "\u0120net", ".", "run", "el", "ite", ".", "client", ".", "util", ".", "Text", ";", "\u0120import", "\u0120net", ".", "run", "el", "ite", ".", "client", ".", "util", ".", "Wild", "card", "Mat", "cher", ";", "\u0120@", "Plugin", "Desc", "ript", "or", "(", "\u0120-", "\u0120name", "\u0120=", "\u0120\"", "N", "PC", "\u0120Ind", "icators", "\",", "\u0120-", "\u0120description", "\u0120=", "\u0120\"", "High", "light", "\u0120NPCs", "\u0120on", "-", "screen", "\u0120and", "/", "or", "\u0120on", "\u0120the", "\u0120minim", "ap", "\",", "\u0120-", "\u0120tags", "\u0120=", "\u0120{\"", "high", "light", "\",", "\u0120\"", "min", "im", "ap", "\",", "\u0120\"", "np", "cs", "\",", "\u0120\"", "over", "lay", "\",", "\u0120\"", "resp", "awn", "\",", "\u0120\"", "tags", "\"}", "\u0120+", "\u0120name", "\u0120=", "\u0120\"", "N", "PC", "\u0120Ind", "icators", "\",", "\u0120+", "\u0120description", "\u0120=", "\u0120\"", "High", "light", "\u0120NPCs", "\u0120on", "-", "screen", "\u0120and", "/", "or", "\u0120on", "\u0120the", "\u0120minim", "ap", "\",", "\u0120+", "\u0120tags", "\u0120=", "\u0120{\"", "high", "light", "\",", "\u0120\"", "min", "im", "ap", "\",", "\u0120\"", "np", "cs", "\",", "\u0120\"", "over", "lay", "\",", "\u0120\"", "resp", "awn", "\",", "\u0120\"", "tags", "\"}", "\u0120)", "\u0120@", "S", "lf", "4", "j", "\u0120@", "Sing", "leton"], "docstring_tokens": ["ex", "cess", "\u0120whites", "pace", "\u0120through", "\u0120plugin", "."]}
{"function": "@@ -138,7 +138,7 @@ void EdgeBasedGraphFactory::InsertEdgeBasedNode(const NodeID node_u, const NodeI NodeID current_edge_source_coordinate_id = node_u; // traverse arrays from start and end respectively - for (const auto i : util::irange(0UL, geometry_size)) + for (const auto i : util::irange(std::size_t{ 0 }, geometry_size)) { BOOST_ASSERT(current_edge_source_coordinate_id == m_compressed_edge_container.GetBucketReference(", "text": "What is the problem here? I feel we used this in a lot of places.", "function_tokens": ["@@", "\u0120-", "138", ",", "7", "\u0120+", "138", ",", "7", "\u0120@@", "\u0120void", "\u0120Edge", "Based", "Graph", "Factory", "::", "Insert", "Edge", "Based", "Node", "(", "const", "\u0120Node", "ID", "\u0120node", "_", "u", ",", "\u0120const", "\u0120Node", "I", "\u0120Node", "ID", "\u0120current", "_", "edge", "_", "source", "_", "coord", "inate", "_", "id", "\u0120=", "\u0120node", "_", "u", ";", "\u0120//", "\u0120traverse", "\u0120arrays", "\u0120from", "\u0120start", "\u0120and", "\u0120end", "\u0120respectively", "\u0120-", "\u0120for", "\u0120(", "const", "\u0120auto", "\u0120i", "\u0120:", "\u0120util", "::", "ir", "ange", "(", "0", "UL", ",", "\u0120geometry", "_", "size", "))", "\u0120+", "\u0120for", "\u0120(", "const", "\u0120auto", "\u0120i", "\u0120:", "\u0120util", "::", "ir", "ange", "(", "std", "::", "size", "_", "t", "{", "\u01200", "\u0120},", "\u0120geometry", "_", "size", "))", "\u0120{", "\u0120B", "OO", "ST", "_", "ASS", "ERT", "(", "current", "_", "edge", "_", "source", "_", "coord", "inate", "_", "id", "\u0120==", "\u0120m", "_", "comp", "ressed", "_", "edge", "_", "container", ".", "Get", "B", "ucket", "Reference", "("], "docstring_tokens": ["What", "\u0120is", "\u0120the", "\u0120problem", "\u0120here", "?", "\u0120I", "\u0120feel", "\u0120we", "\u0120used", "\u0120this", "\u0120in", "\u0120a", "\u0120lot", "\u0120of", "\u0120places", "."]}
{"function": "@@ -109,8 +109,7 @@ class RPN(BaseDetector): for proposals, meta in zip(proposal_list, img_metas): proposals[:, :4] /= proposals.new_tensor(meta['scale_factor']) - # TODO: remove this restriction - return proposal_list[0].cpu().numpy() + return [proposal.cpu().numpy() for proposal in proposal_list] def aug_test(self, imgs, img_metas, rescale=False): \"\"\"Test function with test time augmentation.", "text": "Update the docstring.", "function_tokens": ["@@", "\u0120-", "109", ",", "8", "\u0120+", "109", ",", "7", "\u0120@@", "\u0120class", "\u0120R", "PN", "(", "Base", "Det", "ector", "):", "\u0120for", "\u0120proposals", ",", "\u0120meta", "\u0120in", "\u0120zip", "(", "pro", "posal", "_", "list", ",", "\u0120img", "_", "met", "as", "):", "\u0120proposals", "[", ":,", "\u0120:", "4", "]", "\u0120/", "=", "\u0120proposals", ".", "new", "_", "t", "ensor", "(", "meta", "['", "scale", "_", "factor", "'", "])", "\u0120-", "\u0120#", "\u0120TOD", "O", ":", "\u0120remove", "\u0120this", "\u0120restriction", "\u0120-", "\u0120return", "\u0120proposal", "_", "list", "[", "0", "].", "cpu", "().", "n", "umpy", "()", "\u0120+", "\u0120return", "\u0120[", "pro", "posal", ".", "cpu", "().", "n", "umpy", "()", "\u0120for", "\u0120proposal", "\u0120in", "\u0120proposal", "_", "list", "]", "\u0120def", "\u0120aug", "_", "test", "(", "self", ",", "\u0120im", "gs", ",", "\u0120img", "_", "met", "as", ",", "\u0120resc", "ale", "=", "False", "):", "\u0120\"\"\"", "Test", "\u0120function", "\u0120with", "\u0120test", "\u0120time", "\u0120aug", "mentation", "."], "docstring_tokens": ["Update", "\u0120the", "\u0120doc", "string", "."]}
{"function": "@@ -7,10 +7,11 @@ package api import ( - \"errors\" \"testing\" \"time\" + \"github.com/pkg/errors\" + \"github.com/golang/mock/gomock\" \"github.com/stretchr/testify/require\" ", "text": "delete the empty line \"github.com/pkg/errors\" should be grouped with other third party packages same for the rest", "function_tokens": ["@@", "\u0120-", "7", ",", "10", "\u0120+", "7", ",", "11", "\u0120@@", "\u0120package", "\u0120api", "\u0120import", "\u0120(", "\u0120-", "\u0120\"", "errors", "\"", "\u0120\"", "testing", "\"", "\u0120\"", "time", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "pkg", "/", "errors", "\"", "\u0120+", "\u0120\"", "github", ".", "com", "/", "g", "ol", "ang", "/", "m", "ock", "/", "gom", "ock", "\"", "\u0120\"", "github", ".", "com", "/", "st", "retch", "r", "/", "test", "ify", "/", "require", "\"", "\u0120"], "docstring_tokens": ["delete", "\u0120the", "\u0120empty", "\u0120line", "\u0120\"", "github", ".", "com", "/", "pkg", "/", "errors", "\"", "\u0120should", "\u0120be", "\u0120grouped", "\u0120with", "\u0120other", "\u0120third", "\u0120party", "\u0120packages", "\u0120same", "\u0120for", "\u0120the", "\u0120rest"]}
{"function": "@@ -155,7 +155,7 @@ public class RemoteWebDriver implements WebDriver, JavascriptExecutor, } private void init(Capabilities capabilities) { - capabilities = capabilities == null ? new ImmutableCapabilities() : capabilities; + this.capabilities = capabilities == null ? new ImmutableCapabilities() : capabilities; logger.addHandler(LoggingHandler.getInstance()); ", "text": "Assigning capabilities to the field here is not the best idea. Semantically this field contains the capabilities returned by the browser after session start. So here we sould better amend capabilities and return them from `init` method to pass later to `startSession` method (that will assign the capabilities returned by the browser to the field).", "function_tokens": ["@@", "\u0120-", "155", ",", "7", "\u0120+", "155", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Remote", "Web", "Driver", "\u0120implements", "\u0120Web", "Driver", ",", "\u0120Javascript", "Exec", "utor", ",", "\u0120}", "\u0120private", "\u0120void", "\u0120init", "(", "Cap", "abilities", "\u0120capabilities", ")", "\u0120{", "\u0120-", "\u0120capabilities", "\u0120=", "\u0120capabilities", "\u0120==", "\u0120null", "\u0120?", "\u0120new", "\u0120Imm", "utable", "Cap", "abilities", "()", "\u0120:", "\u0120capabilities", ";", "\u0120+", "\u0120this", ".", "cap", "abilities", "\u0120=", "\u0120capabilities", "\u0120==", "\u0120null", "\u0120?", "\u0120new", "\u0120Imm", "utable", "Cap", "abilities", "()", "\u0120:", "\u0120capabilities", ";", "\u0120logger", ".", "add", "Handler", "(", "Log", "ging", "Handler", ".", "get", "Instance", "());", "\u0120"], "docstring_tokens": ["Ass", "igning", "\u0120capabilities", "\u0120to", "\u0120the", "\u0120field", "\u0120here", "\u0120is", "\u0120not", "\u0120the", "\u0120best", "\u0120idea", ".", "\u0120Sem", "antically", "\u0120this", "\u0120field", "\u0120contains", "\u0120the", "\u0120capabilities", "\u0120returned", "\u0120by", "\u0120the", "\u0120browser", "\u0120after", "\u0120session", "\u0120start", ".", "\u0120So", "\u0120here", "\u0120we", "\u0120s", "ould", "\u0120better", "\u0120amend", "\u0120capabilities", "\u0120and", "\u0120return", "\u0120them", "\u0120from", "\u0120`", "init", "`", "\u0120method", "\u0120to", "\u0120pass", "\u0120later", "\u0120to", "\u0120`", "start", "Session", "`", "\u0120method", "\u0120(", "that", "\u0120will", "\u0120assign", "\u0120the", "\u0120capabilities", "\u0120returned", "\u0120by", "\u0120the", "\u0120browser", "\u0120to", "\u0120the", "\u0120field", ")."]}
{"function": "@@ -110,8 +110,6 @@ module RSpec::Core end end - alias_method :abort, :finish - def stop @duration = (RSpec::Core::Time.now - @start).to_f if @start notify :stop", "text": "Is this a breaking change, or is the API private?", "function_tokens": ["@@", "\u0120-", "110", ",", "8", "\u0120+", "110", ",", "6", "\u0120@@", "\u0120module", "\u0120R", "Spec", "::", "Core", "\u0120end", "\u0120end", "\u0120-", "\u0120alias", "_", "method", "\u0120:", "ab", "ort", ",", "\u0120:", "fin", "ish", "\u0120-", "\u0120def", "\u0120stop", "\u0120@", "duration", "\u0120=", "\u0120(", "R", "Spec", "::", "Core", "::", "Time", ".", "now", "\u0120-", "\u0120@", "start", ").", "to", "_", "f", "\u0120if", "\u0120@", "start", "\u0120notify", "\u0120:", "stop"], "docstring_tokens": ["Is", "\u0120this", "\u0120a", "\u0120breaking", "\u0120change", ",", "\u0120or", "\u0120is", "\u0120the", "\u0120API", "\u0120private", "?"]}
{"function": "@@ -0,0 +1,4 @@ +import pandas as pd + +test_data = pd.read_json(\"./dumps/courseData.json\"); +test_data = {k: val.groupby('pk')['fields'].apply(list).apply(lambda x: x[0]).to_dict() for k, val in test_data.groupby(\"model\")};", "text": "I don't think we need this dependency in this project right now", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "4", "\u0120@@", "\u0120+", "import", "\u0120pand", "as", "\u0120as", "\u0120p", "d", "\u0120+", "\u0120+", "test", "_", "data", "\u0120=", "\u0120p", "d", ".", "read", "_", "json", "(", "\".", "/", "d", "umps", "/", "course", "Data", ".", "json", "\");", "\u0120+", "test", "_", "data", "\u0120=", "\u0120{", "k", ":", "\u0120val", ".", "group", "by", "('", "p", "k", "')", "['", "fields", "'", "].", "apply", "(", "list", ").", "apply", "(", "lambda", "\u0120x", ":", "\u0120x", "[", "0", "]).", "to", "_", "dict", "()", "\u0120for", "\u0120k", ",", "\u0120val", "\u0120in", "\u0120test", "_", "data", ".", "group", "by", "(\"", "model", "\")", "};"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120we", "\u0120need", "\u0120this", "\u0120dependency", "\u0120in", "\u0120this", "\u0120project", "\u0120right", "\u0120now"]}
{"function": "@@ -30,8 +30,9 @@ const ( // FanoutName is the name used for the fanout container. FanoutName = \"fanout\" // RetryName is the name used for the retry container. - RetryName = \"retry\" - BrokerCellLabelKey = \"brokerCell\" + RetryName = \"retry\" + BrokerCellLabelKey = \"brokerCell\" + BrokerSystemNamespace = \"cloud-run-events\" ) var (", "text": "I don't think this is necessary since `CommonLabels` is a public func and every component name is also public constant.", "function_tokens": ["@@", "\u0120-", "30", ",", "8", "\u0120+", "30", ",", "9", "\u0120@@", "\u0120const", "\u0120(", "\u0120//", "\u0120Fan", "out", "Name", "\u0120is", "\u0120the", "\u0120name", "\u0120used", "\u0120for", "\u0120the", "\u0120fan", "out", "\u0120container", ".", "\u0120Fan", "out", "Name", "\u0120=", "\u0120\"", "fan", "out", "\"", "\u0120//", "\u0120Ret", "ry", "Name", "\u0120is", "\u0120the", "\u0120name", "\u0120used", "\u0120for", "\u0120the", "\u0120ret", "ry", "\u0120container", ".", "\u0120-", "\u0120Ret", "ry", "Name", "\u0120=", "\u0120\"", "ret", "ry", "\"", "\u0120-", "\u0120Bro", "ker", "Cell", "Label", "Key", "\u0120=", "\u0120\"", "bro", "ker", "Cell", "\"", "\u0120+", "\u0120Ret", "ry", "Name", "\u0120=", "\u0120\"", "ret", "ry", "\"", "\u0120+", "\u0120Bro", "ker", "Cell", "Label", "Key", "\u0120=", "\u0120\"", "bro", "ker", "Cell", "\"", "\u0120+", "\u0120Bro", "ker", "System", "Names", "pace", "\u0120=", "\u0120\"", "cloud", "-", "run", "-", "events", "\"", "\u0120)", "\u0120var", "\u0120("], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120this", "\u0120is", "\u0120necessary", "\u0120since", "\u0120`", "Common", "Lab", "els", "`", "\u0120is", "\u0120a", "\u0120public", "\u0120func", "\u0120and", "\u0120every", "\u0120component", "\u0120name", "\u0120is", "\u0120also", "\u0120public", "\u0120constant", "."]}
{"function": "@@ -155,14 +155,15 @@ module Bolt \"`task.py`) and the extension is case sensitive. When a target's name is `localhost`, \"\\ \"Ruby tasks run with the Bolt Ruby interpreter by default.\", additionalProperties: { - type: String, + type: [String, Array], _plugin: false }, propertyNames: { pattern: \"^.?[a-zA-Z0-9]+$\" }, _plugin: true, - _example: { \"rb\" => \"/usr/bin/ruby\" } + _example: { \"rb\" => [\"/usr/bin/ruby\", \"-r\", \"puppet\"], + \".py\" => \"/usr/bin/python3\" } }, \"job-poll-interval\" => { type: Integer,", "text": "The `_example` field should be updated to include an interpreter with an array value.", "function_tokens": ["@@", "\u0120-", "155", ",", "14", "\u0120+", "155", ",", "15", "\u0120@@", "\u0120module", "\u0120Bolt", "\u0120\"", "`", "task", ".", "py", "`", ")", "\u0120and", "\u0120the", "\u0120extension", "\u0120is", "\u0120case", "\u0120sensitive", ".", "\u0120When", "\u0120a", "\u0120target", "'s", "\u0120name", "\u0120is", "\u0120`", "localhost", "`,", "\u0120\"\\", "\u0120\"", "Ruby", "\u0120tasks", "\u0120run", "\u0120with", "\u0120the", "\u0120Bolt", "\u0120Ruby", "\u0120interpreter", "\u0120by", "\u0120default", ".\",", "\u0120additional", "Pro", "perties", ":", "\u0120{", "\u0120-", "\u0120type", ":", "\u0120String", ",", "\u0120+", "\u0120type", ":", "\u0120[", "String", ",", "\u0120Array", "],", "\u0120_", "plugin", ":", "\u0120false", "\u0120},", "\u0120property", "Names", ":", "\u0120{", "\u0120pattern", ":", "\u0120\"", "^", ".?", "[", "a", "-", "z", "A", "-", "Z", "0", "-", "9", "]+", "$", "\"", "\u0120},", "\u0120_", "plugin", ":", "\u0120true", ",", "\u0120-", "\u0120_", "example", ":", "\u0120{", "\u0120\"", "rb", "\"", "\u0120=>", "\u0120\"/", "usr", "/", "bin", "/", "ruby", "\"", "\u0120}", "\u0120+", "\u0120_", "example", ":", "\u0120{", "\u0120\"", "rb", "\"", "\u0120=>", "\u0120[\"", "/", "usr", "/", "bin", "/", "ruby", "\",", "\u0120\"-", "r", "\",", "\u0120\"", "p", "uppet", "\"],", "\u0120+", "\u0120\".", "py", "\"", "\u0120=>", "\u0120\"/", "usr", "/", "bin", "/", "python", "3", "\"", "\u0120}", "\u0120},", "\u0120\"", "job", "-", "poll", "-", "inter", "val", "\"", "\u0120=>", "\u0120{", "\u0120type", ":", "\u0120Integer", ","], "docstring_tokens": ["The", "\u0120`", "_", "example", "`", "\u0120field", "\u0120should", "\u0120be", "\u0120updated", "\u0120to", "\u0120include", "\u0120an", "\u0120interpreter", "\u0120with", "\u0120an", "\u0120array", "\u0120value", "."]}
{"function": "@@ -532,12 +532,14 @@ var supportedKeyTypes = map[string]acme.KeyType{ // Map of supported protocols. // HTTP/2 only supports TLS 1.2 and higher. -var supportedProtocols = map[string]uint16{ +var SupportedProtocols = map[string]uint16{ \"tls1.0\": tls.VersionTLS10, \"tls1.1\": tls.VersionTLS11, \"tls1.2\": tls.VersionTLS12, } +// NOTE: if updating the above map, also update sslProtocolToStringMap in caddyhttp/fastcgi/fastcgi.go + // Map of supported ciphers, used only for parsing config. // // Note that, at time of writing, HTTP/2 blacklists 276 cipher suites,", "text": "Put this in the godoc of SupportedProtocols instead. Preferably we would just use one map though. Why not just use this one?", "function_tokens": ["@@", "\u0120-", "5", "32", ",", "12", "\u0120+", "5", "32", ",", "14", "\u0120@@", "\u0120var", "\u0120supported", "Key", "Types", "\u0120=", "\u0120map", "[", "string", "]", "ac", "me", ".", "Key", "Type", "{", "\u0120//", "\u0120Map", "\u0120of", "\u0120supported", "\u0120protocols", ".", "\u0120//", "\u0120HTTP", "/", "2", "\u0120only", "\u0120supports", "\u0120TLS", "\u01201", ".", "2", "\u0120and", "\u0120higher", ".", "\u0120-", "var", "\u0120supported", "Prot", "ocol", "s", "\u0120=", "\u0120map", "[", "string", "]", "uint", "16", "{", "\u0120+", "var", "\u0120Supported", "Prot", "ocol", "s", "\u0120=", "\u0120map", "[", "string", "]", "uint", "16", "{", "\u0120\"", "t", "ls", "1", ".", "0", "\":", "\u0120t", "ls", ".", "Version", "T", "LS", "10", ",", "\u0120\"", "t", "ls", "1", ".", "1", "\":", "\u0120t", "ls", ".", "Version", "T", "LS", "11", ",", "\u0120\"", "t", "ls", "1", ".", "2", "\":", "\u0120t", "ls", ".", "Version", "T", "LS", "12", ",", "\u0120}", "\u0120+", "//", "\u0120NOTE", ":", "\u0120if", "\u0120updating", "\u0120the", "\u0120above", "\u0120map", ",", "\u0120also", "\u0120update", "\u0120s", "sl", "Prot", "ocol", "To", "String", "Map", "\u0120in", "\u0120c", "addy", "http", "/", "fast", "cgi", "/", "fast", "cgi", ".", "go", "\u0120+", "\u0120//", "\u0120Map", "\u0120of", "\u0120supported", "\u0120c", "ip", "hers", ",", "\u0120used", "\u0120only", "\u0120for", "\u0120parsing", "\u0120config", ".", "\u0120//", "\u0120//", "\u0120Note", "\u0120that", ",", "\u0120at", "\u0120time", "\u0120of", "\u0120writing", ",", "\u0120HTTP", "/", "2", "\u0120black", "lists", "\u0120276", "\u0120cipher", "\u0120suites", ","], "docstring_tokens": ["Put", "\u0120this", "\u0120in", "\u0120the", "\u0120god", "oc", "\u0120of", "\u0120Supported", "Prot", "ocol", "s", "\u0120instead", ".", "\u0120Pre", "fer", "ably", "\u0120we", "\u0120would", "\u0120just", "\u0120use", "\u0120one", "\u0120map", "\u0120though", ".", "\u0120Why", "\u0120not", "\u0120just", "\u0120use", "\u0120this", "\u0120one", "?"]}
{"function": "@@ -59,13 +59,12 @@ func (container *CronContainer) StopStatsCron() { } // newCronContainer creates a CronContainer object. -func newCronContainer(dockerID *string, name *string, dockerGraphPath string) *CronContainer { +func newCronContainer(dockerID *string, dockerGraphPath string) *CronContainer { statePath := filepath.Join(dockerGraphPath, DockerExecDriverPath, *dockerID) container := &CronContainer{ containerMetadata: &ContainerMetadata{ DockerID: dockerID, - Name: name, }, statePath: statePath, }", "text": "I'd feel a little safer if the first argument were a string, not a *string unless there's a particular reason for making it a pointer.", "function_tokens": ["@@", "\u0120-", "59", ",", "13", "\u0120+", "59", ",", "12", "\u0120@@", "\u0120func", "\u0120(", "container", "\u0120*", "C", "ron", "Container", ")", "\u0120Stop", "Stats", "C", "ron", "()", "\u0120{", "\u0120}", "\u0120//", "\u0120new", "C", "ron", "Container", "\u0120creates", "\u0120a", "\u0120Cron", "Container", "\u0120object", ".", "\u0120-", "func", "\u0120new", "C", "ron", "Container", "(", "docker", "ID", "\u0120*", "string", ",", "\u0120name", "\u0120*", "string", ",", "\u0120docker", "Graph", "Path", "\u0120string", ")", "\u0120*", "C", "ron", "Container", "\u0120{", "\u0120+", "func", "\u0120new", "C", "ron", "Container", "(", "docker", "ID", "\u0120*", "string", ",", "\u0120docker", "Graph", "Path", "\u0120string", ")", "\u0120*", "C", "ron", "Container", "\u0120{", "\u0120state", "Path", "\u0120:=", "\u0120file", "path", ".", "Join", "(", "docker", "Graph", "Path", ",", "\u0120Docker", "Exec", "Driver", "Path", ",", "\u0120*", "docker", "ID", ")", "\u0120container", "\u0120:=", "\u0120&", "C", "ron", "Container", "{", "\u0120container", "Met", "adata", ":", "\u0120&", "Container", "Met", "adata", "{", "\u0120Docker", "ID", ":", "\u0120docker", "ID", ",", "\u0120-", "\u0120Name", ":", "\u0120name", ",", "\u0120},", "\u0120state", "Path", ":", "\u0120state", "Path", ",", "\u0120}"], "docstring_tokens": ["I", "'d", "\u0120feel", "\u0120a", "\u0120little", "\u0120safer", "\u0120if", "\u0120the", "\u0120first", "\u0120argument", "\u0120were", "\u0120a", "\u0120string", ",", "\u0120not", "\u0120a", "\u0120*", "string", "\u0120unless", "\u0120there", "'s", "\u0120a", "\u0120particular", "\u0120reason", "\u0120for", "\u0120making", "\u0120it", "\u0120a", "\u0120pointer", "."]}
{"function": "@@ -22,6 +22,7 @@ import static org.junit.Assert.assertEquals; import org.junit.Before; import org.junit.Test; +import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Arrays; ", "text": "Can you please revert changes to files in the `thoughtworks` package? This is legacy code and we will eventually phase out RC.", "function_tokens": ["@@", "\u0120-", "22", ",", "6", "\u0120+", "22", ",", "7", "\u0120@@", "\u0120import", "\u0120static", "\u0120org", ".", "j", "unit", ".", "Ass", "ert", ".", "assert", "Equ", "als", ";", "\u0120import", "\u0120org", ".", "j", "unit", ".", "Before", ";", "\u0120import", "\u0120org", ".", "j", "unit", ".", "Test", ";", "\u0120+", "import", "\u0120java", ".", "lang", ".", "reflect", ".", "Inv", "ocation", "Target", "Exception", ";", "\u0120import", "\u0120java", ".", "lang", ".", "reflect", ".", "Method", ";", "\u0120import", "\u0120java", ".", "util", ".", "Ar", "rays", ";", "\u0120"], "docstring_tokens": ["Can", "\u0120you", "\u0120please", "\u0120revert", "\u0120changes", "\u0120to", "\u0120files", "\u0120in", "\u0120the", "\u0120`", "though", "tw", "orks", "`", "\u0120package", "?", "\u0120This", "\u0120is", "\u0120legacy", "\u0120code", "\u0120and", "\u0120we", "\u0120will", "\u0120eventually", "\u0120phase", "\u0120out", "\u0120RC", "."]}
{"function": "@@ -19,7 +19,10 @@ package org.openqa.selenium.grid.graphql; import graphql.schema.DataFetcher; import graphql.schema.DataFetchingEnvironment; + +import org.openqa.selenium.SessionNotCreatedException; import org.openqa.selenium.grid.distributor.Distributor; +import org.openqa.selenium.grid.sessionmap.SessionMap; import org.openqa.selenium.internal.Require; import java.net.URI;", "text": "You can safely revert changes to this file.", "function_tokens": ["@@", "\u0120-", "19", ",", "7", "\u0120+", "19", ",", "10", "\u0120@@", "\u0120package", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "grid", ".", "graph", "ql", ";", "\u0120import", "\u0120graph", "ql", ".", "sche", "ma", ".", "Data", "F", "et", "cher", ";", "\u0120import", "\u0120graph", "ql", ".", "sche", "ma", ".", "Data", "F", "etch", "ing", "Environment", ";", "\u0120+", "\u0120+", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "Session", "Not", "Created", "Exception", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "grid", ".", "dist", "ribut", "or", ".", "Dist", "ribut", "or", ";", "\u0120+", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "grid", ".", "session", "map", ".", "Session", "Map", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "internal", ".", "Requ", "ire", ";", "\u0120import", "\u0120java", ".", "net", ".", "URI", ";"], "docstring_tokens": ["You", "\u0120can", "\u0120safely", "\u0120revert", "\u0120changes", "\u0120to", "\u0120this", "\u0120file", "."]}
{"function": "@@ -127,7 +127,6 @@ class AnchorHead(nn.Module): def loss_single(self, cls_score, bbox_pred, labels, label_weights, bbox_targets, bbox_weights, num_total_samples, cfg): - # classification loss labels = labels.reshape(-1) label_weights = label_weights.reshape(-1) cls_score = cls_score.permute(0, 2, 3, 1).reshape(", "text": "This deletion is unnecessary.", "function_tokens": ["@@", "\u0120-", "127", ",", "7", "\u0120+", "127", ",", "6", "\u0120@@", "\u0120class", "\u0120Anch", "or", "Head", "(", "nn", ".", "Module", "):", "\u0120def", "\u0120loss", "_", "single", "(", "self", ",", "\u0120cl", "s", "_", "score", ",", "\u0120b", "box", "_", "pred", ",", "\u0120labels", ",", "\u0120label", "_", "weights", ",", "\u0120b", "box", "_", "t", "arg", "ets", ",", "\u0120b", "box", "_", "weights", ",", "\u0120num", "_", "total", "_", "s", "amples", ",", "\u0120cf", "g", "):", "\u0120-", "\u0120#", "\u0120classification", "\u0120loss", "\u0120labels", "\u0120=", "\u0120labels", ".", "resh", "ape", "(-", "1", ")", "\u0120label", "_", "weights", "\u0120=", "\u0120label", "_", "weights", ".", "resh", "ape", "(-", "1", ")", "\u0120cl", "s", "_", "score", "\u0120=", "\u0120cl", "s", "_", "score", ".", "perm", "ute", "(", "0", ",", "\u01202", ",", "\u01203", ",", "\u01201", ").", "resh", "ape", "("], "docstring_tokens": ["This", "\u0120deletion", "\u0120is", "\u0120unnecessary", "."]}
{"function": "@@ -302,7 +302,10 @@ class Notification extends Component { mdc-layout-grid__cell mdc-layout-grid__cell--span-1 \"> - <img className=\"googlesitekit-publisher-win__small-image\" alt=\"\" src={ smallImage } /> + { + typeof smallImage === 'string' + ? <img className=\"googlesitekit-publisher-win__small-image\" alt=\"\" src={ smallImage } /> : smallImage + } </div> } ", "text": "I'm not a huge fan of this overloading of the prop; accepting very different types of arguments for props like this can be confusing, and wasn't part of the IB. I understand wanting to import the SVG directly, but the IB suggests using `${global._googlesitekitLegacyData.admin.assetsRoot}${userInputSuccessImage}` as the `src`/`smallImage` value here. It'd be great to refactor this to accept components directly in the future, but let's do that all-at-once rather than this hybrid approach that makes the API less clear.", "function_tokens": ["@@", "\u0120-", "302", ",", "7", "\u0120+", "302", ",", "10", "\u0120@@", "\u0120class", "\u0120Notification", "\u0120extends", "\u0120Component", "\u0120{", "\u0120m", "dc", "-", "layout", "-", "grid", "__", "cell", "\u0120m", "dc", "-", "layout", "-", "grid", "__", "cell", "--", "span", "-", "1", "\u0120\"", ">", "\u0120-", "\u0120<", "img", "\u0120class", "Name", "=\"", "go", "og", "les", "ite", "kit", "-", "pub", "lisher", "-", "win", "__", "small", "-", "image", "\"", "\u0120alt", "=\"\"", "\u0120src", "={", "\u0120small", "Image", "\u0120}", "\u0120/>", "\u0120+", "\u0120{", "\u0120+", "\u0120type", "of", "\u0120small", "Image", "\u0120===", "\u0120'", "string", "'", "\u0120+", "\u0120?", "\u0120<", "img", "\u0120class", "Name", "=\"", "go", "og", "les", "ite", "kit", "-", "pub", "lisher", "-", "win", "__", "small", "-", "image", "\"", "\u0120alt", "=\"\"", "\u0120src", "={", "\u0120small", "Image", "\u0120}", "\u0120/>", "\u0120:", "\u0120small", "Image", "\u0120+", "\u0120}", "\u0120</", "div", ">", "\u0120}", "\u0120"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120a", "\u0120huge", "\u0120fan", "\u0120of", "\u0120this", "\u0120over", "loading", "\u0120of", "\u0120the", "\u0120prop", ";", "\u0120accepting", "\u0120very", "\u0120different", "\u0120types", "\u0120of", "\u0120arguments", "\u0120for", "\u0120props", "\u0120like", "\u0120this", "\u0120can", "\u0120be", "\u0120confusing", ",", "\u0120and", "\u0120wasn", "'t", "\u0120part", "\u0120of", "\u0120the", "\u0120IB", ".", "\u0120I", "\u0120understand", "\u0120wanting", "\u0120to", "\u0120import", "\u0120the", "\u0120SVG", "\u0120directly", ",", "\u0120but", "\u0120the", "\u0120IB", "\u0120suggests", "\u0120using", "\u0120`", "${", "global", "._", "go", "og", "les", "ite", "kit", "Leg", "acy", "Data", ".", "admin", ".", "assets", "Root", "}", "${", "user", "Input", "Success", "Image", "}", "`", "\u0120as", "\u0120the", "\u0120`", "src", "`", "/", "`", "small", "Image", "`", "\u0120value", "\u0120here", ".", "\u0120It", "'d", "\u0120be", "\u0120great", "\u0120to", "\u0120ref", "actor", "\u0120this", "\u0120to", "\u0120accept", "\u0120components", "\u0120directly", "\u0120in", "\u0120the", "\u0120future", ",", "\u0120but", "\u0120let", "'s", "\u0120do", "\u0120that", "\u0120all", "-", "at", "-", "once", "\u0120rather", "\u0120than", "\u0120this", "\u0120hybrid", "\u0120approach", "\u0120that", "\u0120makes", "\u0120the", "\u0120API", "\u0120less", "\u0120clear", "."]}
{"function": "@@ -21,10 +21,7 @@ import java.io.InputStream; import java.io.StringWriter; import java.lang.invoke.MethodHandles; import java.nio.charset.StandardCharsets; -import java.util.Collections; -import java.util.HashMap; -import java.util.List; -import java.util.Map; +import java.util.*; import java.util.concurrent.TimeUnit; import org.apache.solr.cloud.ZkController;", "text": "I've had this happen recently with IntelliJ, was this intentional?", "function_tokens": ["@@", "\u0120-", "21", ",", "10", "\u0120+", "21", ",", "7", "\u0120@@", "\u0120import", "\u0120java", ".", "io", ".", "Input", "Stream", ";", "\u0120import", "\u0120java", ".", "io", ".", "String", "Writer", ";", "\u0120import", "\u0120java", ".", "lang", ".", "invoke", ".", "Method", "Hand", "les", ";", "\u0120import", "\u0120java", ".", "n", "io", ".", "ch", "ars", "et", ".", "Standard", "Ch", "ars", "ets", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Col", "lections", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Hash", "Map", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "List", ";", "\u0120-", "import", "\u0120java", ".", "util", ".", "Map", ";", "\u0120+", "import", "\u0120java", ".", "util", ".*", ";", "\u0120import", "\u0120java", ".", "util", ".", "con", "current", ".", "Time", "Unit", ";", "\u0120import", "\u0120org", ".", "apache", ".", "sol", "r", ".", "cloud", ".", "Z", "k", "Controller", ";"], "docstring_tokens": ["I", "'ve", "\u0120had", "\u0120this", "\u0120happen", "\u0120recently", "\u0120with", "\u0120Int", "elli", "J", ",", "\u0120was", "\u0120this", "\u0120intentional", "?"]}
{"function": "@@ -22,9 +22,10 @@ #include <string.h> #include <string> #include <vector> -#include <map> +#include <unordered_map> #include \"vulkan/vulkan.h\" #include \"vk_format_utils.h\" +#include \"hash_util.h\" struct VULKAN_FORMAT_INFO { size_t size;", "text": "Order(1) vs Order(logN) -- not sure it's measurable at the ~200 element size of the table. All of the published comparisons start at ~1000 elements.", "function_tokens": ["@@", "\u0120-", "22", ",", "9", "\u0120+", "22", ",", "10", "\u0120@@", "\u0120#", "include", "\u0120<", "string", ".", "h", ">", "\u0120#", "include", "\u0120<", "string", ">", "\u0120#", "include", "\u0120<", "vector", ">", "\u0120-", "#", "include", "\u0120<", "map", ">", "\u0120+#", "include", "\u0120<", "un", "ordered", "_", "map", ">", "\u0120#", "include", "\u0120\"", "v", "ulkan", "/", "v", "ulkan", ".", "h", "\"", "\u0120#", "include", "\u0120\"", "v", "k", "_", "format", "_", "utils", ".", "h", "\"", "\u0120+#", "include", "\u0120\"", "hash", "_", "util", ".", "h", "\"", "\u0120struct", "\u0120V", "UL", "K", "AN", "_", "FORM", "AT", "_", "INFO", "\u0120{", "\u0120size", "_", "t", "\u0120size", ";"], "docstring_tokens": ["Order", "(", "1", ")", "\u0120vs", "\u0120Order", "(", "log", "N", ")", "\u0120--", "\u0120not", "\u0120sure", "\u0120it", "'s", "\u0120measurable", "\u0120at", "\u0120the", "\u0120~", "200", "\u0120element", "\u0120size", "\u0120of", "\u0120the", "\u0120table", ".", "\u0120All", "\u0120of", "\u0120the", "\u0120published", "\u0120comparisons", "\u0120start", "\u0120at", "\u0120~", "1000", "\u0120elements", "."]}
{"function": "@@ -33,6 +33,7 @@ import ( \"github.com/mysteriumnetwork/node/core/connection\" \"github.com/mysteriumnetwork/node/core/ip\" \"github.com/mysteriumnetwork/node/core/location\" + location_factory \"github.com/mysteriumnetwork/node/core/location/factory\" \"github.com/mysteriumnetwork/node/core/node\" \"github.com/mysteriumnetwork/node/core/port\" \"github.com/mysteriumnetwork/node/core/service\"", "text": "I don't know about this aliasing and 'factory'. Previous version was rather straightforward: `location.CreateLocationResolver`. Perhaps `location.CreateResolver` would be even better? What do we actually gain here from moving DI to a separate sub-package?", "function_tokens": ["@@", "\u0120-", "33", ",", "6", "\u0120+", "33", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "connection", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "ip", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "location", "\"", "\u0120+", "\u0120location", "_", "f", "actory", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "location", "/", "f", "actory", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "node", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "port", "\"", "\u0120\"", "github", ".", "com", "/", "my", "ster", "ium", "network", "/", "node", "/", "core", "/", "service", "\""], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120know", "\u0120about", "\u0120this", "\u0120ali", "asing", "\u0120and", "\u0120'", "f", "actory", "'.", "\u0120Previous", "\u0120version", "\u0120was", "\u0120rather", "\u0120straightforward", ":", "\u0120`", "location", ".", "Create", "Location", "Res", "olver", "`.", "\u0120Perhaps", "\u0120`", "location", ".", "Create", "Res", "olver", "`", "\u0120would", "\u0120be", "\u0120even", "\u0120better", "?", "\u0120What", "\u0120do", "\u0120we", "\u0120actually", "\u0120gain", "\u0120here", "\u0120from", "\u0120moving", "\u0120DI", "\u0120to", "\u0120a", "\u0120separate", "\u0120sub", "-", "package", "?"]}
{"function": "@@ -47,6 +47,14 @@ void Engine::SetCallBack(std::function<void(const void *, std::string, { } +static void engineThrowUp(const std::string &engineType, + const std::string &func) +{ + throw std::invalid_argument( + \"ERROR: Engine bass class \" + func + \"() called. \" + engineType + + \" child class is not implementing this function\\n\"); +} + // should these functions throw an exception? void Engine::Write(Variable<char> & /*variable*/, const char * /*values*/) {} void Engine::Write(Variable<unsigned char> & /*variable*/,", "text": "Use `UpperCamelCase` for function names", "function_tokens": ["@@", "\u0120-", "47", ",", "6", "\u0120+", "47", ",", "14", "\u0120@@", "\u0120void", "\u0120Engine", "::", "Set", "Call", "Back", "(", "std", "::", "function", "<", "void", "(", "const", "\u0120void", "\u0120*", ",", "\u0120std", "::", "string", ",", "\u0120{", "\u0120}", "\u0120+", "static", "\u0120void", "\u0120engine", "Throw", "Up", "(", "const", "\u0120std", "::", "string", "\u0120&", "engine", "Type", ",", "\u0120+", "\u0120const", "\u0120std", "::", "string", "\u0120&", "func", ")", "\u0120+", "{", "\u0120+", "\u0120throw", "\u0120std", "::", "in", "valid", "_", "argument", "(", "\u0120+", "\u0120\"", "ERROR", ":", "\u0120Engine", "\u0120bass", "\u0120class", "\u0120\"", "\u0120+", "\u0120func", "\u0120+", "\u0120\"", "()", "\u0120called", ".", "\u0120\"", "\u0120+", "\u0120engine", "Type", "\u0120+", "\u0120+", "\u0120\"", "\u0120child", "\u0120class", "\u0120is", "\u0120not", "\u0120implementing", "\u0120this", "\u0120function", "\\", "n", "\");", "\u0120+", "}", "\u0120+", "\u0120//", "\u0120should", "\u0120these", "\u0120functions", "\u0120throw", "\u0120an", "\u0120exception", "?", "\u0120void", "\u0120Engine", "::", "Write", "(", "Variable", "<", "char", ">", "\u0120&", "\u0120/*", "variable", "*/", ",", "\u0120const", "\u0120char", "\u0120*", "\u0120/*", "values", "*/", ")", "\u0120{}", "\u0120void", "\u0120Engine", "::", "Write", "(", "Variable", "<", "unsigned", "\u0120char", ">", "\u0120&", "\u0120/*", "variable", "*/", ","], "docstring_tokens": ["Use", "\u0120`", "U", "pper", "C", "amel", "Case", "`", "\u0120for", "\u0120function", "\u0120names"]}
{"function": "@@ -232,9 +232,12 @@ SchemaDate.prototype.cast = function(value) { if (value instanceof Number || typeof value === 'number') { date = new Date(value); + } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < 0)) { + // string representation of milliseconds take this path + date = new Date(Number(value)); } else if (typeof value.valueOf === 'function') { - // support for moment.js. This is also the path strings will take because strings - // have a `valueOf()` + // support for moment.js. This is also the path string representation of years + // will take because strings have a `valueOf()` date = new Date(value.valueOf()); } else { // fallback", "text": "I'm not 100% sold on this idea but I like it in general. Nice compromise between using the 'Date' constructor where possible and falling back to the pre #5880 behavior when it makes sense. However, instead of `Number(value) < 0`, let's do `Number(value) < MIN_YEAR` because `new Date('-2017')` is perfectly valid in JS and I don't want to break the date behavior.", "function_tokens": ["@@", "\u0120-", "232", ",", "9", "\u0120+", "232", ",", "12", "\u0120@@", "\u0120Sche", "ma", "Date", ".", "prototype", ".", "cast", "\u0120=", "\u0120function", "(", "value", ")", "\u0120{", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Number", "\u0120||", "\u0120type", "of", "\u0120value", "\u0120===", "\u0120'", "number", "')", "\u0120{", "\u0120date", "\u0120=", "\u0120new", "\u0120Date", "(", "value", ");", "\u0120+", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "of", "\u0120value", "\u0120===", "\u0120'", "string", "'", "\u0120&&", "\u0120!", "is", "Na", "N", "(", "Number", "(", "value", "))", "\u0120&&", "\u0120(", "Number", "(", "value", ")", "\u0120>=", "\u0120275", "76", "1", "\u0120||", "\u0120Number", "(", "value", ")", "\u0120<", "\u01200", "))", "\u0120{", "\u0120+", "\u0120//", "\u0120string", "\u0120representation", "\u0120of", "\u0120milliseconds", "\u0120take", "\u0120this", "\u0120path", "\u0120+", "\u0120date", "\u0120=", "\u0120new", "\u0120Date", "(", "Number", "(", "value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "of", "\u0120value", ".", "value", "Of", "\u0120===", "\u0120'", "function", "')", "\u0120{", "\u0120-", "\u0120//", "\u0120support", "\u0120for", "\u0120moment", ".", "js", ".", "\u0120This", "\u0120is", "\u0120also", "\u0120the", "\u0120path", "\u0120strings", "\u0120will", "\u0120take", "\u0120because", "\u0120strings", "\u0120-", "\u0120//", "\u0120have", "\u0120a", "\u0120`", "value", "Of", "()", "`", "\u0120+", "\u0120//", "\u0120support", "\u0120for", "\u0120moment", ".", "js", ".", "\u0120This", "\u0120is", "\u0120also", "\u0120the", "\u0120path", "\u0120string", "\u0120representation", "\u0120of", "\u0120years", "\u0120+", "\u0120//", "\u0120will", "\u0120take", "\u0120because", "\u0120strings", "\u0120have", "\u0120a", "\u0120`", "value", "Of", "()", "`", "\u0120date", "\u0120=", "\u0120new", "\u0120Date", "(", "value", ".", "value", "Of", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120//", "\u0120fall", "back"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120100", "%", "\u0120sold", "\u0120on", "\u0120this", "\u0120idea", "\u0120but", "\u0120I", "\u0120like", "\u0120it", "\u0120in", "\u0120general", ".", "\u0120Nice", "\u0120compromise", "\u0120between", "\u0120using", "\u0120the", "\u0120'", "Date", "'", "\u0120constructor", "\u0120where", "\u0120possible", "\u0120and", "\u0120falling", "\u0120back", "\u0120to", "\u0120the", "\u0120pre", "\u0120#", "58", "80", "\u0120behavior", "\u0120when", "\u0120it", "\u0120makes", "\u0120sense", ".", "\u0120However", ",", "\u0120instead", "\u0120of", "\u0120`", "Number", "(", "value", ")", "\u0120<", "\u01200", "`,", "\u0120let", "'s", "\u0120do", "\u0120`", "Number", "(", "value", ")", "\u0120<", "\u0120MIN", "_", "Y", "EAR", "`", "\u0120because", "\u0120`", "new", "\u0120Date", "('", "-", "2017", "')", "`", "\u0120is", "\u0120perfectly", "\u0120valid", "\u0120in", "\u0120JS", "\u0120and", "\u0120I", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120break", "\u0120the", "\u0120date", "\u0120behavior", "."]}
{"function": "@@ -138,8 +138,7 @@ public abstract class BaseHttpClusterStateProvider implements ClusterStateProvid Set<String> liveNodes = new HashSet((List<String>)(cluster.get(\"live_nodes\"))); this.liveNodes = liveNodes; liveNodesTimestamp = System.nanoTime(); - //TODO SOLR-11877 we don't know the znode path; CLUSTER_STATE is probably wrong leading to bad stateFormat - ClusterState cs = ClusterState.load(znodeVersion, collectionsMap, liveNodes, ZkStateReader.CLUSTER_STATE); + ClusterState cs = ClusterState.createFromData(znodeVersion, collectionsMap, liveNodes); if (clusterProperties != null) { Map<String, Object> properties = (Map<String, Object>) cluster.get(\"properties\"); if (properties != null) {", "text": "Remember to close SOLR-11877 after this", "function_tokens": ["@@", "\u0120-", "138", ",", "8", "\u0120+", "138", ",", "7", "\u0120@@", "\u0120public", "\u0120abstract", "\u0120class", "\u0120Base", "Http", "Cl", "uster", "State", "Provider", "\u0120implements", "\u0120Cluster", "State", "Prov", "id", "\u0120Set", "<", "String", ">", "\u0120live", "N", "odes", "\u0120=", "\u0120new", "\u0120Hash", "Set", "((", "List", "<", "String", ">", ")(", "cl", "uster", ".", "get", "(\"", "live", "_", "n", "odes", "\"))", ");", "\u0120this", ".", "live", "N", "odes", "\u0120=", "\u0120live", "N", "odes", ";", "\u0120live", "N", "odes", "Tim", "estamp", "\u0120=", "\u0120System", ".", "n", "ano", "Time", "();", "\u0120-", "\u0120//", "T", "OD", "O", "\u0120SOL", "R", "-", "118", "77", "\u0120we", "\u0120don", "'t", "\u0120know", "\u0120the", "\u0120z", "node", "\u0120path", ";", "\u0120CL", "UST", "ER", "_", "STATE", "\u0120is", "\u0120probably", "\u0120wrong", "\u0120leading", "\u0120to", "\u0120bad", "\u0120state", "Format", "\u0120-", "\u0120Cluster", "State", "\u0120cs", "\u0120=", "\u0120Cluster", "State", ".", "load", "(", "z", "node", "Version", ",", "\u0120collections", "Map", ",", "\u0120live", "N", "odes", ",", "\u0120Z", "k", "State", "Reader", ".", "CL", "UST", "ER", "_", "STATE", ");", "\u0120+", "\u0120Cluster", "State", "\u0120cs", "\u0120=", "\u0120Cluster", "State", ".", "create", "From", "Data", "(", "z", "node", "Version", ",", "\u0120collections", "Map", ",", "\u0120live", "N", "odes", ");", "\u0120if", "\u0120(", "cl", "uster", "Pro", "perties", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120properties", "\u0120=", "\u0120(", "Map", "<", "String", ",", "\u0120Object", ">)", "\u0120cluster", ".", "get", "(\"", "properties", "\");", "\u0120if", "\u0120(", "properties", "\u0120!=", "\u0120null", ")", "\u0120{"], "docstring_tokens": ["Remember", "\u0120to", "\u0120close", "\u0120SOL", "R", "-", "118", "77", "\u0120after", "\u0120this"]}
{"function": "@@ -1124,7 +1124,7 @@ void Identifier::_exportToJSON(JSONFormatter *formatter) const { //! @cond Doxygen_Suppress static bool isIgnoredChar(char ch) { return ch == ' ' || ch == '_' || ch == '-' || ch == '/' || ch == '(' || - ch == ')' || ch == '.' || ch == '&' || ch == ','; + ch == ')' || ch == '.' || ch == '&'; } //! @endcond ", "text": "this change should be reverted", "function_tokens": ["@@", "\u0120-", "112", "4", ",", "7", "\u0120+", "112", "4", ",", "7", "\u0120@@", "\u0120void", "\u0120Ident", "ifier", "::", "_", "export", "To", "JSON", "(", "JSON", "Form", "atter", "\u0120*", "form", "atter", ")", "\u0120const", "\u0120{", "\u0120//", "!", "\u0120@", "cond", "\u0120D", "oxy", "gen", "_", "Supp", "ress", "\u0120static", "\u0120bool", "\u0120is", "Ign", "ored", "Char", "(", "char", "\u0120ch", ")", "\u0120{", "\u0120return", "\u0120ch", "\u0120==", "\u0120'", "\u0120'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", "_", "'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", "-'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'/", "'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", "('", "\u0120||", "\u0120-", "\u0120ch", "\u0120==", "\u0120'", ")'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", ".'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", "&", "'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", ",'", ";", "\u0120+", "\u0120ch", "\u0120==", "\u0120'", ")'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", ".'", "\u0120||", "\u0120ch", "\u0120==", "\u0120'", "&", "';", "\u0120}", "\u0120//", "!", "\u0120@", "end", "cond", "\u0120"], "docstring_tokens": ["this", "\u0120change", "\u0120should", "\u0120be", "\u0120reverted"]}
{"function": "@@ -186,9 +186,15 @@ type mockedIdentityRegistry struct { anyIdentityRegistered bool } +// IsRegistered mock func (mir *mockedIdentityRegistry) IsRegistered(address common.Address) (bool, error) { return mir.anyIdentityRegistered, nil } +// WaitForRegistrationEvent mock +func (mir *mockedIdentityRegistry) WaitForRegistrationEvent(providerAddress common.Address, registeredEvent chan int, stopLoop chan int) { + +} + //check that we implemented mocked registry correctly var _ registry.IdentityRegistry = &mockedIdentityRegistry{}", "text": "This function signature is a bit complicated, some parameters are IN type (stopLoop which is modified from outside), others are OUT (registeredEvent channel which is modified inside function) I suggest the following signature -> SubscribeToRegistrationEvent(identityAddress) returns registeredEvent chan of type (RegisteredEvent not int), Unsubscribe func(), error (in case of any error). That way caller can always cance subscription if needed and check for any errors. Also - unsubscribe function hides any internal details how subscribtion is really implemented", "function_tokens": ["@@", "\u0120-", "186", ",", "9", "\u0120+", "186", ",", "15", "\u0120@@", "\u0120type", "\u0120mocked", "Id", "entity", "Reg", "istry", "\u0120struct", "\u0120{", "\u0120any", "Id", "entity", "Registered", "\u0120bool", "\u0120}", "\u0120+", "//", "\u0120Is", "Registered", "\u0120mock", "\u0120func", "\u0120(", "mir", "\u0120*", "m", "ocked", "Id", "entity", "Reg", "istry", ")", "\u0120Is", "Registered", "(", "address", "\u0120common", ".", "Address", ")", "\u0120(", "bool", ",", "\u0120error", ")", "\u0120{", "\u0120return", "\u0120mir", ".", "any", "Id", "entity", "Registered", ",", "\u0120nil", "\u0120}", "\u0120+", "//", "\u0120Wait", "For", "Registration", "Event", "\u0120mock", "\u0120+", "func", "\u0120(", "mir", "\u0120*", "m", "ocked", "Id", "entity", "Reg", "istry", ")", "\u0120Wait", "For", "Registration", "Event", "(", "prov", "ider", "Address", "\u0120common", ".", "Address", ",", "\u0120registered", "Event", "\u0120ch", "an", "\u0120int", ",", "\u0120stop", "Loop", "\u0120ch", "an", "\u0120int", ")", "\u0120{", "\u0120+", "\u0120+", "}", "\u0120+", "\u0120//", "check", "\u0120that", "\u0120we", "\u0120implemented", "\u0120mocked", "\u0120registry", "\u0120correctly", "\u0120var", "\u0120_", "\u0120registry", ".", "Id", "entity", "Reg", "istry", "\u0120=", "\u0120&", "m", "ocked", "Id", "entity", "Reg", "istry", "{", "}"], "docstring_tokens": ["This", "\u0120function", "\u0120signature", "\u0120is", "\u0120a", "\u0120bit", "\u0120complicated", ",", "\u0120some", "\u0120parameters", "\u0120are", "\u0120IN", "\u0120type", "\u0120(", "stop", "Loop", "\u0120which", "\u0120is", "\u0120modified", "\u0120from", "\u0120outside", "),", "\u0120others", "\u0120are", "\u0120OUT", "\u0120(", "registered", "Event", "\u0120channel", "\u0120which", "\u0120is", "\u0120modified", "\u0120inside", "\u0120function", ")", "\u0120I", "\u0120suggest", "\u0120the", "\u0120following", "\u0120signature", "\u0120->", "\u0120Subscribe", "To", "Registration", "Event", "(", "ident", "ity", "Address", ")", "\u0120returns", "\u0120registered", "Event", "\u0120ch", "an", "\u0120of", "\u0120type", "\u0120(", "Registered", "Event", "\u0120not", "\u0120int", "),", "\u0120Un", "sub", "scribe", "\u0120func", "(),", "\u0120error", "\u0120(", "in", "\u0120case", "\u0120of", "\u0120any", "\u0120error", ").", "\u0120That", "\u0120way", "\u0120caller", "\u0120can", "\u0120always", "\u0120cance", "\u0120subscription", "\u0120if", "\u0120needed", "\u0120and", "\u0120check", "\u0120for", "\u0120any", "\u0120errors", ".", "\u0120Also", "\u0120-", "\u0120unsub", "scribe", "\u0120function", "\u0120hides", "\u0120any", "\u0120internal", "\u0120details", "\u0120how", "\u0120subscrib", "tion", "\u0120is", "\u0120really", "\u0120implemented"]}
{"function": "@@ -45,7 +45,7 @@ const options = { query: ['src/**/*.png', 'src/**/*.jpg', 'src/**/*.gif', 'src/**/*.svg'] }, copy: { - query: ['src/**/*.json', 'src/**/*.ico'] + query: ['src/**/*.json', 'src/**/*.ico', 'src/**/*.wav'] }, injectBundle: { query: 'src/index.html'", "text": "`.wav`?! cannot we use something slightly more modern and compressed instead? :) I dunno, like `.mp3` or `.aac` or `.ogg`...", "function_tokens": ["@@", "\u0120-", "45", ",", "7", "\u0120+", "45", ",", "7", "\u0120@@", "\u0120const", "\u0120options", "\u0120=", "\u0120{", "\u0120query", ":", "\u0120['", "src", "/**", "/*", ".", "png", "',", "\u0120'", "src", "/**", "/*", ".", "jpg", "',", "\u0120'", "src", "/**", "/*", ".", "gif", "',", "\u0120'", "src", "/**", "/*", ".", "sv", "g", "']", "\u0120},", "\u0120copy", ":", "\u0120{", "\u0120-", "\u0120query", ":", "\u0120['", "src", "/**", "/*", ".", "json", "',", "\u0120'", "src", "/**", "/*", ".", "ico", "']", "\u0120+", "\u0120query", ":", "\u0120['", "src", "/**", "/*", ".", "json", "',", "\u0120'", "src", "/**", "/*", ".", "ico", "',", "\u0120'", "src", "/**", "/*", ".", "wav", "']", "\u0120},", "\u0120inject", "B", "undle", ":", "\u0120{", "\u0120query", ":", "\u0120'", "src", "/", "index", ".", "html", "'"], "docstring_tokens": ["`.", "wav", "`", "?!", "\u0120cannot", "\u0120we", "\u0120use", "\u0120something", "\u0120slightly", "\u0120more", "\u0120modern", "\u0120and", "\u0120compressed", "\u0120instead", "?", "\u0120:)", "\u0120I", "\u0120dunno", ",", "\u0120like", "\u0120`", ".", "mp", "3", "`", "\u0120or", "\u0120`", ".", "a", "ac", "`", "\u0120or", "\u0120`", ".", "ogg", "`", "..."]}
{"function": "@@ -1602,6 +1602,17 @@ luaA_client_swap(lua_State *L) *ref_swap = c; luaA_class_emit_signal(L, &client_class, \"list\", 0); + + luaA_object_push(L, swap); + lua_pushboolean(L, true); + luaA_object_emit_signal(L, -4, \"swapped\", 2); + lua_pop(L, 2); + + luaA_object_push(L, swap); + luaA_object_push(L, c); + lua_pushboolean(L, false); + luaA_object_emit_signal(L, -3, \"swapped\", 2); + lua_pop(L, 3); } return 0;", "text": "Wouldn't a single signal call be enough? (without the boolean even)", "function_tokens": ["@@", "\u0120-", "16", "02", ",", "6", "\u0120+", "16", "02", ",", "17", "\u0120@@", "\u0120l", "ua", "A", "_", "client", "_", "sw", "ap", "(", "lua", "_", "State", "\u0120*", "L", ")", "\u0120*", "ref", "_", "sw", "ap", "\u0120=", "\u0120c", ";", "\u0120l", "ua", "A", "_", "class", "_", "em", "it", "_", "sign", "al", "(", "L", ",", "\u0120&", "client", "_", "class", ",", "\u0120\"", "list", "\",", "\u01200", ");", "\u0120+", "\u0120+", "\u0120l", "ua", "A", "_", "object", "_", "push", "(", "L", ",", "\u0120swap", ");", "\u0120+", "\u0120l", "ua", "_", "push", "bo", "olean", "(", "L", ",", "\u0120true", ");", "\u0120+", "\u0120l", "ua", "A", "_", "object", "_", "em", "it", "_", "sign", "al", "(", "L", ",", "\u0120-", "4", ",", "\u0120\"", "sw", "apped", "\",", "\u01202", ");", "\u0120+", "\u0120l", "ua", "_", "pop", "(", "L", ",", "\u01202", ");", "\u0120+", "\u0120+", "\u0120l", "ua", "A", "_", "object", "_", "push", "(", "L", ",", "\u0120swap", ");", "\u0120+", "\u0120l", "ua", "A", "_", "object", "_", "push", "(", "L", ",", "\u0120c", ");", "\u0120+", "\u0120l", "ua", "_", "push", "bo", "olean", "(", "L", ",", "\u0120false", ");", "\u0120+", "\u0120l", "ua", "A", "_", "object", "_", "em", "it", "_", "sign", "al", "(", "L", ",", "\u0120-", "3", ",", "\u0120\"", "sw", "apped", "\",", "\u01202", ");", "\u0120+", "\u0120l", "ua", "_", "pop", "(", "L", ",", "\u01203", ");", "\u0120}", "\u0120return", "\u01200", ";"], "docstring_tokens": ["Would", "n", "'t", "\u0120a", "\u0120single", "\u0120signal", "\u0120call", "\u0120be", "\u0120enough", "?", "\u0120(", "without", "\u0120the", "\u0120boolean", "\u0120even", ")"]}
{"function": "@@ -17,6 +17,11 @@ <br/> <%= note_event(@note.status, @note.closed_at, @note_comments.last.author) %> <% end %> + <% if current_user && current_user != @note.author %> + <%= link_to new_report_url(reportable_id: @note.id, reportable_type: @note.class.name), :title => t('browse.note.report') do %> + &nbsp;&#9872; + <% end %> + <% end %> </div> <% if @note_comments.find { |comment| comment.author.nil? } -%>", "text": "I suspect that this whole block, which is going to be repeated a number of times, should probably be in a helper. I guess it would need to be given the object and the title and could probably figure out everything else from that?", "function_tokens": ["@@", "\u0120-", "17", ",", "6", "\u0120+", "17", ",", "11", "\u0120@@", "\u0120<", "br", "/>", "\u0120<", "%", "=", "\u0120note", "_", "event", "(", "@", "note", ".", "status", ",", "\u0120@", "note", ".", "closed", "_", "at", ",", "\u0120@", "note", "_", "comments", ".", "last", ".", "author", ")", "\u0120%", ">", "\u0120<", "%", "\u0120end", "\u0120%", ">", "\u0120+", "\u0120<", "%", "\u0120if", "\u0120current", "_", "user", "\u0120&&", "\u0120current", "_", "user", "\u0120!=", "\u0120@", "note", ".", "author", "\u0120%", ">", "\u0120+", "\u0120<", "%", "=", "\u0120link", "_", "to", "\u0120new", "_", "report", "_", "url", "(", "report", "able", "_", "id", ":", "\u0120@", "note", ".", "id", ",", "\u0120report", "able", "_", "type", ":", "\u0120@", "note", ".", "class", ".", "name", "),", "\u0120:", "title", "\u0120=>", "\u0120t", "('", "brow", "se", ".", "note", ".", "report", "')", "\u0120do", "\u0120%", ">", "\u0120+", "\u0120&", "n", "bsp", ";", "&", "#", "98", "72", ";", "\u0120+", "\u0120<", "%", "\u0120end", "\u0120%", ">", "\u0120+", "\u0120<", "%", "\u0120end", "\u0120%", ">", "\u0120</", "div", ">", "\u0120<", "%", "\u0120if", "\u0120@", "note", "_", "comments", ".", "find", "\u0120{", "\u0120|", "comment", "|", "\u0120comment", ".", "author", ".", "nil", "?", "\u0120}", "\u0120-", "%", ">"], "docstring_tokens": ["I", "\u0120suspect", "\u0120that", "\u0120this", "\u0120whole", "\u0120block", ",", "\u0120which", "\u0120is", "\u0120going", "\u0120to", "\u0120be", "\u0120repeated", "\u0120a", "\u0120number", "\u0120of", "\u0120times", ",", "\u0120should", "\u0120probably", "\u0120be", "\u0120in", "\u0120a", "\u0120helper", ".", "\u0120I", "\u0120guess", "\u0120it", "\u0120would", "\u0120need", "\u0120to", "\u0120be", "\u0120given", "\u0120the", "\u0120object", "\u0120and", "\u0120the", "\u0120title", "\u0120and", "\u0120could", "\u0120probably", "\u0120figure", "\u0120out", "\u0120everything", "\u0120else", "\u0120from", "\u0120that", "?"]}
{"function": "@@ -218,6 +218,9 @@ class Document < AbstractBlock # Public: Get the Reader associated with this document attr_reader :reader + # Public: Get/Set the PathResolver instance used to resolve paths in this Document. + attr_reader :path_resolver + # Public: Get the Converter associated with this document attr_reader :converter ", "text": "Should we expose this attribute in the Asciidoctor.js API ?", "function_tokens": ["@@", "\u0120-", "218", ",", "6", "\u0120+", "218", ",", "9", "\u0120@@", "\u0120class", "\u0120Document", "\u0120<", "\u0120Abstract", "Block", "\u0120#", "\u0120Public", ":", "\u0120Get", "\u0120the", "\u0120Reader", "\u0120associated", "\u0120with", "\u0120this", "\u0120document", "\u0120att", "r", "_", "reader", "\u0120:", "reader", "\u0120+", "\u0120#", "\u0120Public", ":", "\u0120Get", "/", "Set", "\u0120the", "\u0120Path", "Res", "olver", "\u0120instance", "\u0120used", "\u0120to", "\u0120resolve", "\u0120paths", "\u0120in", "\u0120this", "\u0120Document", ".", "\u0120+", "\u0120att", "r", "_", "reader", "\u0120:", "path", "_", "res", "olver", "\u0120+", "\u0120#", "\u0120Public", ":", "\u0120Get", "\u0120the", "\u0120Conver", "ter", "\u0120associated", "\u0120with", "\u0120this", "\u0120document", "\u0120att", "r", "_", "reader", "\u0120:", "con", "ver", "ter", "\u0120"], "docstring_tokens": ["Should", "\u0120we", "\u0120expose", "\u0120this", "\u0120attribute", "\u0120in", "\u0120the", "\u0120As", "ci", "ido", "ctor", ".", "js", "\u0120API", "\u0120?"]}
{"function": "@@ -147,7 +147,7 @@ public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, @Override default boolean contains(Tuple2<K, V> element) { - return get(element._1).map(v -> Objects.equals(v, element._2)).getOrElse(false); + return get(element._1).map(v -> v.contains(element._2)).getOrElse(false); } /**", "text": "I think contains on `Multimap` was broken - it should return true if one of the values is associated with the key? It that right", "function_tokens": ["@@", "\u0120-", "147", ",", "7", "\u0120+", "147", ",", "7", "\u0120@@", "\u0120public", "\u0120interface", "\u0120Mult", "im", "ap", "<", "K", ",", "\u0120V", ">", "\u0120extends", "\u0120Tra", "vers", "able", "<", "T", "uple", "2", "<", "K", ",", "\u0120V", ">>", ",", "\u0120Function", "1", "<", "K", ",", "\u0120@", "Override", "\u0120default", "\u0120boolean", "\u0120contains", "(", "T", "uple", "2", "<", "K", ",", "\u0120V", ">", "\u0120element", ")", "\u0120{", "\u0120-", "\u0120return", "\u0120get", "(", "element", "._", "1", ").", "map", "(", "v", "\u0120->", "\u0120Objects", ".", "equ", "als", "(", "v", ",", "\u0120element", "._", "2", ")).", "get", "Or", "Else", "(", "false", ");", "\u0120+", "\u0120return", "\u0120get", "(", "element", "._", "1", ").", "map", "(", "v", "\u0120->", "\u0120v", ".", "cont", "ains", "(", "element", "._", "2", ")).", "get", "Or", "Else", "(", "false", ");", "\u0120}", "\u0120/**"], "docstring_tokens": ["I", "\u0120think", "\u0120contains", "\u0120on", "\u0120`", "Mult", "im", "ap", "`", "\u0120was", "\u0120broken", "\u0120-", "\u0120it", "\u0120should", "\u0120return", "\u0120true", "\u0120if", "\u0120one", "\u0120of", "\u0120the", "\u0120values", "\u0120is", "\u0120associated", "\u0120with", "\u0120the", "\u0120key", "?", "\u0120It", "\u0120that", "\u0120right"]}
{"function": "@@ -57,6 +57,7 @@ public class TiConfiguration implements Serializable { private static final int DEF_KV_CLIENT_CONCURRENCY = 10; private static final List<TiStoreType> DEF_ISOLATION_READ_ENGINES = ImmutableList.of(TiStoreType.TiKV, TiStoreType.TiFlash); + private static final int DEF_PREWRITE_CONCURRENCY = 20; private int timeout = DEF_TIMEOUT; private TimeUnit timeoutUnit = DEF_TIMEOUT_UNIT;", "text": "delete this line", "function_tokens": ["@@", "\u0120-", "57", ",", "6", "\u0120+", "57", ",", "7", "\u0120@@", "\u0120public", "\u0120class", "\u0120Ti", "Configuration", "\u0120implements", "\u0120Serial", "izable", "\u0120{", "\u0120private", "\u0120static", "\u0120final", "\u0120int", "\u0120DEF", "_", "K", "V", "_", "CL", "IENT", "_", "CON", "C", "URR", "ENCY", "\u0120=", "\u012010", ";", "\u0120private", "\u0120static", "\u0120final", "\u0120List", "<", "Ti", "Store", "Type", ">", "\u0120DEF", "_", "IS", "OL", "ATION", "_", "READ", "_", "ENG", "IN", "ES", "\u0120=", "\u0120Imm", "utable", "List", ".", "of", "(", "Ti", "Store", "Type", ".", "Ti", "K", "V", ",", "\u0120Ti", "Store", "Type", ".", "Ti", "Flash", ");", "\u0120+", "\u0120private", "\u0120static", "\u0120final", "\u0120int", "\u0120DEF", "_", "PRE", "WR", "ITE", "_", "CON", "C", "URR", "ENCY", "\u0120=", "\u012020", ";", "\u0120private", "\u0120int", "\u0120timeout", "\u0120=", "\u0120DEF", "_", "TIME", "OUT", ";", "\u0120private", "\u0120Time", "Unit", "\u0120timeout", "Unit", "\u0120=", "\u0120DEF", "_", "TIME", "OUT", "_", "UN", "IT", ";"], "docstring_tokens": ["delete", "\u0120this", "\u0120line"]}
{"function": "@@ -43,6 +43,7 @@ module Test def self.setup_models conn = ClientRequest.connection + return if conn.table_exists? \"test_client_requests\" conn.create_table(:test_client_requests, force: true) do |t| t.decimal :amount t.string :project_title", "text": "Presumably we no longer need `force: true` here.", "function_tokens": ["@@", "\u0120-", "43", ",", "6", "\u0120+", "43", ",", "7", "\u0120@@", "\u0120module", "\u0120Test", "\u0120def", "\u0120self", ".", "setup", "_", "models", "\u0120conn", "\u0120=", "\u0120Client", "Request", ".", "connection", "\u0120+", "\u0120return", "\u0120if", "\u0120conn", ".", "table", "_", "ex", "ists", "?", "\u0120\"", "test", "_", "client", "_", "requ", "ests", "\"", "\u0120conn", ".", "create", "_", "table", "(", ":", "test", "_", "client", "_", "requ", "ests", ",", "\u0120force", ":", "\u0120true", ")", "\u0120do", "\u0120|", "t", "|", "\u0120t", ".", "dec", "imal", "\u0120:", "amount", "\u0120t", ".", "string", "\u0120:", "project", "_", "title"], "docstring_tokens": ["Pres", "umably", "\u0120we", "\u0120no", "\u0120longer", "\u0120need", "\u0120`", "force", ":", "\u0120true", "`", "\u0120here", "."]}
{"function": "@@ -339,6 +339,12 @@ hipError_t hipHostAlloc(void** ptr, size_t sizeBytes, unsigned int flags) { // width in bytes hipError_t ihipMallocPitch(void** ptr, size_t* pitch, size_t width, size_t height, size_t depth) { hipError_t hip_status = hipSuccess; + if(ptr==NULL || ptr==0) + { + hip_status=hipErrorInvalidValue; + return hip_status; + } + // hardcoded 128 bytes *pitch = ((((int)width - 1) / 128) + 1) * 128; const size_t sizeBytes = (*pitch) * height;", "text": "HIP runtime is compiled using a C++ compiler. So comparison to both NULL as well as 0 does not make sense. Just comparing to NULL is sufficient.", "function_tokens": ["@@", "\u0120-", "339", ",", "6", "\u0120+", "339", ",", "12", "\u0120@@", "\u0120hip", "Error", "_", "t", "\u0120hip", "Host", "All", "oc", "(", "void", "**", "\u0120ptr", ",", "\u0120size", "_", "t", "\u0120size", "Bytes", ",", "\u0120unsigned", "\u0120int", "\u0120flags", ")", "\u0120{", "\u0120//", "\u0120width", "\u0120in", "\u0120bytes", "\u0120hip", "Error", "_", "t", "\u0120i", "hip", "M", "alloc", "P", "itch", "(", "void", "**", "\u0120ptr", ",", "\u0120size", "_", "t", "*", "\u0120pitch", ",", "\u0120size", "_", "t", "\u0120width", ",", "\u0120size", "_", "t", "\u0120height", ",", "\u0120size", "_", "t", "\u0120depth", ")", "\u0120{", "\u0120hip", "Error", "_", "t", "\u0120hip", "_", "status", "\u0120=", "\u0120hip", "Success", ";", "\u0120+", "\u0120if", "(", "ptr", "==", "NULL", "\u0120||", "\u0120ptr", "==", "0", ")", "\u0120+", "\u0120{", "\u0120+", "\u0120hip", "_", "status", "=", "hip", "Error", "Invalid", "Value", ";", "\u0120+", "\u0120return", "\u0120hip", "_", "status", ";", "\u0120+", "\u0120}", "\u0120+", "\u0120//", "\u0120hard", "coded", "\u0120128", "\u0120bytes", "\u0120*", "p", "itch", "\u0120=", "\u0120((", "((", "int", ")", "width", "\u0120-", "\u01201", ")", "\u0120/", "\u0120128", ")", "\u0120+", "\u01201", ")", "\u0120*", "\u0120128", ";", "\u0120const", "\u0120size", "_", "t", "\u0120size", "Bytes", "\u0120=", "\u0120(*", "p", "itch", ")", "\u0120*", "\u0120height", ";"], "docstring_tokens": ["H", "IP", "\u0120runtime", "\u0120is", "\u0120compiled", "\u0120using", "\u0120a", "\u0120C", "++", "\u0120compiler", ".", "\u0120So", "\u0120comparison", "\u0120to", "\u0120both", "\u0120NULL", "\u0120as", "\u0120well", "\u0120as", "\u01200", "\u0120does", "\u0120not", "\u0120make", "\u0120sense", ".", "\u0120Just", "\u0120comparing", "\u0120to", "\u0120NULL", "\u0120is", "\u0120sufficient", "."]}
{"function": "@@ -0,0 +1,10 @@ +<%= t(\"mailer.welcome_mailer.welcome_notification.header\") %> + +<%= t(\"mailer.welcome_mailer.welcome_notification.para1\") %> + +<%= t(\"mailer.welcome_mailer.welcome_notification.para2\", help_url: help_url('') ) %> + +<%= t(\"mailer.welcome_mailer.welcome_notification.para3\", feedback_url: feedback_url ) %> + +<%= t(\"mailer.welcome_mailer.welcome_notification.signature\") %> +", "text": "these urls are still in `a` tags so we should probably include these links separately for a non-HTML version", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "10", "\u0120@@", "\u0120+", "<", "%", "=", "\u0120t", "(\"", "mail", "er", ".", "w", "elcome", "_", "mail", "er", ".", "w", "elcome", "_", "not", "ification", ".", "header", "\")", "\u0120%", ">", "\u0120+", "\u0120+", "<", "%", "=", "\u0120t", "(\"", "mail", "er", ".", "w", "elcome", "_", "mail", "er", ".", "w", "elcome", "_", "not", "ification", ".", "par", "a", "1", "\")", "\u0120%", ">", "\u0120+", "\u0120+", "<", "%", "=", "\u0120t", "(\"", "mail", "er", ".", "w", "elcome", "_", "mail", "er", ".", "w", "elcome", "_", "not", "ification", ".", "par", "a", "2", "\",", "\u0120help", "_", "url", ":", "\u0120help", "_", "url", "(", "''", ")", "\u0120)", "\u0120%", ">", "\u0120+", "\u0120+", "<", "%", "=", "\u0120t", "(\"", "mail", "er", ".", "w", "elcome", "_", "mail", "er", ".", "w", "elcome", "_", "not", "ification", ".", "par", "a", "3", "\",", "\u0120feedback", "_", "url", ":", "\u0120feedback", "_", "url", "\u0120)", "\u0120%", ">", "\u0120+", "\u0120+", "<", "%", "=", "\u0120t", "(\"", "mail", "er", ".", "w", "elcome", "_", "mail", "er", ".", "w", "elcome", "_", "not", "ification", ".", "sign", "ature", "\")", "\u0120%", ">", "\u0120+"], "docstring_tokens": ["these", "\u0120ur", "ls", "\u0120are", "\u0120still", "\u0120in", "\u0120`", "a", "`", "\u0120tags", "\u0120so", "\u0120we", "\u0120should", "\u0120probably", "\u0120include", "\u0120these", "\u0120links", "\u0120separately", "\u0120for", "\u0120a", "\u0120non", "-", "HTML", "\u0120version"]}
{"function": "@@ -507,8 +507,18 @@ func (s *Server) configureAccounts() error { if opts.SystemAccount != _EMPTY_ { // Lock may be acquired in lookupAccount, so release to call lookupAccount. s.mu.Unlock() - _, err := s.lookupAccount(opts.SystemAccount) + acc, err := s.lookupAccount(opts.SystemAccount) s.mu.Lock() + if err == nil && s.sys != nil && acc != s.sys.account { + // sys.account.clients (including internal client)/respmap/etc... are transferred separately + s.sys.account = acc + s.mu.Unlock() + // acquires server lock separately + s.addSystemAccountExports(acc) + // can't hold the lock as go routine reading it may be waiting for lock as well + s.sys.resetCh <- struct{}{} + s.mu.Lock() + } if err != nil { return fmt.Errorf(\"error resolving system account: %v\", err) }", "text": "That's fine though, meaning that you can send to this channel under the server lock. The internalSendLoop will pick up the change when the server lock is released (if loop is blocked trying to grab the server lock). Even the way you do it here (releasing the lock, sending, then reacquiring) does not guarantee that the internalSendLoop will have time to refresh in that interval.", "function_tokens": ["@@", "\u0120-", "507", ",", "8", "\u0120+", "507", ",", "18", "\u0120@@", "\u0120func", "\u0120(", "s", "\u0120*", "Server", ")", "\u0120configure", "Account", "s", "()", "\u0120error", "\u0120{", "\u0120if", "\u0120opt", "s", ".", "System", "Account", "\u0120!=", "\u0120_", "EMP", "TY", "_", "\u0120{", "\u0120//", "\u0120Lock", "\u0120may", "\u0120be", "\u0120acquired", "\u0120in", "\u0120lookup", "Account", ",", "\u0120so", "\u0120release", "\u0120to", "\u0120call", "\u0120lookup", "Account", ".", "\u0120s", ".", "mu", ".", "Un", "lock", "()", "\u0120-", "\u0120_", ",", "\u0120err", "\u0120:=", "\u0120s", ".", "look", "up", "Account", "(", "op", "ts", ".", "System", "Account", ")", "\u0120+", "\u0120acc", ",", "\u0120err", "\u0120:=", "\u0120s", ".", "look", "up", "Account", "(", "op", "ts", ".", "System", "Account", ")", "\u0120s", ".", "mu", ".", "Lock", "()", "\u0120+", "\u0120if", "\u0120err", "\u0120==", "\u0120nil", "\u0120&&", "\u0120s", ".", "sys", "\u0120!=", "\u0120nil", "\u0120&&", "\u0120acc", "\u0120!=", "\u0120s", ".", "sys", ".", "account", "\u0120{", "\u0120+", "\u0120//", "\u0120sys", ".", "account", ".", "cl", "ients", "\u0120(", "including", "\u0120internal", "\u0120client", ")/", "resp", "map", "/", "etc", "...", "\u0120are", "\u0120transferred", "\u0120separately", "\u0120+", "\u0120s", ".", "sys", ".", "account", "\u0120=", "\u0120acc", "\u0120+", "\u0120s", ".", "mu", ".", "Un", "lock", "()", "\u0120+", "\u0120//", "\u0120acqu", "ires", "\u0120server", "\u0120lock", "\u0120separately", "\u0120+", "\u0120s", ".", "add", "System", "Account", "Ex", "ports", "(", "acc", ")", "\u0120+", "\u0120//", "\u0120can", "'t", "\u0120hold", "\u0120the", "\u0120lock", "\u0120as", "\u0120go", "\u0120routine", "\u0120reading", "\u0120it", "\u0120may", "\u0120be", "\u0120waiting", "\u0120for", "\u0120lock", "\u0120as", "\u0120well", "\u0120+", "\u0120s", ".", "sys", ".", "reset", "Ch", "\u0120<-", "\u0120struct", "{", "}{", "}", "\u0120+", "\u0120s", ".", "mu", ".", "Lock", "()", "\u0120+", "\u0120}", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120return", "\u0120fmt", ".", "Error", "f", "(\"", "error", "\u0120resolving", "\u0120system", "\u0120account", ":", "\u0120%", "v", "\",", "\u0120err", ")", "\u0120}"], "docstring_tokens": ["That", "'s", "\u0120fine", "\u0120though", ",", "\u0120meaning", "\u0120that", "\u0120you", "\u0120can", "\u0120send", "\u0120to", "\u0120this", "\u0120channel", "\u0120under", "\u0120the", "\u0120server", "\u0120lock", ".", "\u0120The", "\u0120internal", "Send", "Loop", "\u0120will", "\u0120pick", "\u0120up", "\u0120the", "\u0120change", "\u0120when", "\u0120the", "\u0120server", "\u0120lock", "\u0120is", "\u0120released", "\u0120(", "if", "\u0120loop", "\u0120is", "\u0120blocked", "\u0120trying", "\u0120to", "\u0120grab", "\u0120the", "\u0120server", "\u0120lock", ").", "\u0120Even", "\u0120the", "\u0120way", "\u0120you", "\u0120do", "\u0120it", "\u0120here", "\u0120(", "re", "leasing", "\u0120the", "\u0120lock", ",", "\u0120sending", ",", "\u0120then", "\u0120re", "acqu", "iring", ")", "\u0120does", "\u0120not", "\u0120guarantee", "\u0120that", "\u0120the", "\u0120internal", "Send", "Loop", "\u0120will", "\u0120have", "\u0120time", "\u0120to", "\u0120refresh", "\u0120in", "\u0120that", "\u0120interval", "."]}
{"function": "@@ -47,6 +47,7 @@ public interface CapabilityType { String ELEMENT_SCROLL_BEHAVIOR = \"elementScrollBehavior\"; String HAS_TOUCHSCREEN = \"hasTouchScreen\"; String OVERLAPPING_CHECK_DISABLED = \"overlappingCheckDisabled\"; + String ENABLE_DOWNLOADING = \"chromium:enableDownloading\"; String LOGGING_PREFS = \"loggingPrefs\"; ", "text": "The name `enableDownloading` implies this is a boolean capability. How about `downloadDir`?", "function_tokens": ["@@", "\u0120-", "47", ",", "6", "\u0120+", "47", ",", "7", "\u0120@@", "\u0120public", "\u0120interface", "\u0120Cap", "ability", "Type", "\u0120{", "\u0120String", "\u0120ELE", "MENT", "_", "SC", "RO", "LL", "_", "BE", "HA", "VI", "OR", "\u0120=", "\u0120\"", "element", "Scroll", "Beh", "avior", "\";", "\u0120String", "\u0120HAS", "_", "T", "OU", "CH", "SC", "RE", "EN", "\u0120=", "\u0120\"", "has", "Touch", "Screen", "\";", "\u0120String", "\u0120OVER", "L", "APP", "ING", "_", "CHECK", "_", "DIS", "AB", "LED", "\u0120=", "\u0120\"", "over", "l", "apping", "Check", "Dis", "abled", "\";", "\u0120+", "\u0120String", "\u0120E", "NA", "BLE", "_", "DOWN", "LOAD", "ING", "\u0120=", "\u0120\"", "chrom", "ium", ":", "enable", "Download", "ing", "\";", "\u0120String", "\u0120LOG", "G", "ING", "_", "PRE", "FS", "\u0120=", "\u0120\"", "log", "ging", "Pref", "s", "\";", "\u0120"], "docstring_tokens": ["The", "\u0120name", "\u0120`", "enable", "Download", "ing", "`", "\u0120implies", "\u0120this", "\u0120is", "\u0120a", "\u0120boolean", "\u0120capability", ".", "\u0120How", "\u0120about", "\u0120`", "download", "Dir", "`", "?"]}
{"function": "@@ -28,10 +28,9 @@ public interface ValidatorManager { Map<String, ValidationReport> validate(Project project, File projectDir); /** - * The ValidatorManager should have a default validator which checks for the most essential - * components of a project. The ValidatorManager should always load the default validator. This - * method returns the default validator of this ValidatorManager. + * ValidatorManager will not have any default validator. */ + @Deprecated ProjectValidator getDefaultValidator(); /**", "text": "Found one internal team is using this method. Will coordinate with them about the migration solution.", "function_tokens": ["@@", "\u0120-", "28", ",", "10", "\u0120+", "28", ",", "9", "\u0120@@", "\u0120public", "\u0120interface", "\u0120Valid", "ator", "Manager", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Val", "idation", "Report", ">", "\u0120validate", "(", "Project", "\u0120project", ",", "\u0120File", "\u0120project", "Dir", ");", "\u0120/**", "\u0120-", "\u0120*", "\u0120The", "\u0120Valid", "ator", "Manager", "\u0120should", "\u0120have", "\u0120a", "\u0120default", "\u0120valid", "ator", "\u0120which", "\u0120checks", "\u0120for", "\u0120the", "\u0120most", "\u0120essential", "\u0120-", "\u0120*", "\u0120components", "\u0120of", "\u0120a", "\u0120project", ".", "\u0120The", "\u0120Valid", "ator", "Manager", "\u0120should", "\u0120always", "\u0120load", "\u0120the", "\u0120default", "\u0120valid", "ator", ".", "\u0120This", "\u0120-", "\u0120*", "\u0120method", "\u0120returns", "\u0120the", "\u0120default", "\u0120valid", "ator", "\u0120of", "\u0120this", "\u0120Valid", "ator", "Manager", ".", "\u0120+", "\u0120*", "\u0120Valid", "ator", "Manager", "\u0120will", "\u0120not", "\u0120have", "\u0120any", "\u0120default", "\u0120valid", "ator", ".", "\u0120*/", "\u0120+", "\u0120@", "Dep", "recated", "\u0120Project", "Valid", "ator", "\u0120get", "Default", "Valid", "ator", "();", "\u0120/**"], "docstring_tokens": ["Found", "\u0120one", "\u0120internal", "\u0120team", "\u0120is", "\u0120using", "\u0120this", "\u0120method", ".", "\u0120Will", "\u0120coordinate", "\u0120with", "\u0120them", "\u0120about", "\u0120the", "\u0120migration", "\u0120solution", "."]}
{"function": "@@ -230,6 +230,18 @@ namespace Datadog.Trace.Configuration /// </summary> public const string DiagnosticSourceEnabled = \"DD_DIAGNOSTIC_SOURCE_ENABLED\"; + /// <summary> + /// Configuration key for the application's server http statuses to set spans as errors by. + /// </summary> + /// <seealso cref=\"TracerSettings.HttpServerErrorCodes\"/> + public const string HttpServerErrorCodes = \"DD_HTTP_SERVER_ERROR_STATUSES\"; + + /// <summary> + /// Configuration key for the application's client http statuses to set spans as errors by. + /// </summary> + /// <seealso cref=\"TracerSettings.HttpClientErrorCodes\"/> + public const string HttpClientErrorCodes = \"DD_HTTP_CLIENT_ERROR_STATUSES\"; + /// <summary> /// String format patterns used to match integration-specific configuration keys. /// </summary>", "text": "The field `HttpServerErrorCodes` should be called `HttpServerErrorStatuses`", "function_tokens": ["@@", "\u0120-", "230", ",", "6", "\u0120+", "230", ",", "18", "\u0120@@", "\u0120namespace", "\u0120Dat", "ad", "og", ".", "Tr", "ace", ".", "Configuration", "\u0120///", "\u0120</", "summary", ">", "\u0120public", "\u0120const", "\u0120string", "\u0120Diagn", "ostic", "Source", "Enabled", "\u0120=", "\u0120\"", "DD", "_", "D", "IA", "GN", "OST", "IC", "_", "SOURCE", "_", "EN", "AB", "LED", "\";", "\u0120+", "\u0120///", "\u0120<", "summary", ">", "\u0120+", "\u0120///", "\u0120Configuration", "\u0120key", "\u0120for", "\u0120the", "\u0120application", "'s", "\u0120server", "\u0120http", "\u0120stat", "uses", "\u0120to", "\u0120set", "\u0120spans", "\u0120as", "\u0120errors", "\u0120by", ".", "\u0120+", "\u0120///", "\u0120</", "summary", ">", "\u0120+", "\u0120///", "\u0120<", "se", "eal", "so", "\u0120cre", "f", "=\"", "Tr", "acer", "Settings", ".", "Http", "Server", "Error", "C", "odes", "\"/>", "\u0120+", "\u0120public", "\u0120const", "\u0120string", "\u0120H", "ttp", "Server", "Error", "C", "odes", "\u0120=", "\u0120\"", "DD", "_", "HTTP", "_", "SER", "VER", "_", "ERROR", "_", "STAT", "US", "ES", "\";", "\u0120+", "\u0120+", "\u0120///", "\u0120<", "summary", ">", "\u0120+", "\u0120///", "\u0120Configuration", "\u0120key", "\u0120for", "\u0120the", "\u0120application", "'s", "\u0120client", "\u0120http", "\u0120stat", "uses", "\u0120to", "\u0120set", "\u0120spans", "\u0120as", "\u0120errors", "\u0120by", ".", "\u0120+", "\u0120///", "\u0120</", "summary", ">", "\u0120+", "\u0120///", "\u0120<", "se", "eal", "so", "\u0120cre", "f", "=\"", "Tr", "acer", "Settings", ".", "Http", "Client", "Error", "C", "odes", "\"/>", "\u0120+", "\u0120public", "\u0120const", "\u0120string", "\u0120H", "ttp", "Client", "Error", "C", "odes", "\u0120=", "\u0120\"", "DD", "_", "HTTP", "_", "CL", "IENT", "_", "ERROR", "_", "STAT", "US", "ES", "\";", "\u0120+", "\u0120///", "\u0120<", "summary", ">", "\u0120///", "\u0120String", "\u0120format", "\u0120patterns", "\u0120used", "\u0120to", "\u0120match", "\u0120integration", "-", "specific", "\u0120configuration", "\u0120keys", ".", "\u0120///", "\u0120</", "summary", ">"], "docstring_tokens": ["The", "\u0120field", "\u0120`", "Http", "Server", "Error", "C", "odes", "`", "\u0120should", "\u0120be", "\u0120called", "\u0120`", "Http", "Server", "Error", "Stat", "uses", "`"]}
{"function": "@@ -35,6 +35,12 @@ MAXIMUM_LOOP_COUNT = 600 DEFAULT_BUCKET_FMT_V1 = 'gs://{}-data-{}' DEFAULT_BUCKET_FMT_V2 = 'gs://{}-{}-data-{}' +FORSETI_V1_RULE_FILES = [ + 'bigquery_rules.yaml', 'blacklist_rules.yaml', 'bucket_rules.yaml', + 'cloudsql_rules.yaml', 'firewall_rules.yaml', 'forwarding_rules.yaml', + 'group_rules.yaml', 'iam_rules.yaml', 'iap_rules.yaml', 'ke_rules.yaml', + 'instance_network_interface_rules.yaml'] + GCLOUD_MIN_VERSION = (180, 0, 0) GCLOUD_VERSION_REGEX = r'Google Cloud SDK (.*)' GCLOUD_ALPHA_REGEX = r'alpha.*'", "text": "Can you please make each of these in a separate line. It will be easier to keep them sorted, and add/remove.", "function_tokens": ["@@", "\u0120-", "35", ",", "6", "\u0120+", "35", ",", "12", "\u0120@@", "\u0120MAX", "IM", "UM", "_", "LO", "OP", "_", "C", "OUNT", "\u0120=", "\u0120600", "\u0120DE", "FAULT", "_", "B", "UCK", "ET", "_", "F", "MT", "_", "V", "1", "\u0120=", "\u0120'", "gs", "://", "{", "}", "-", "data", "-", "{", "}", "'", "\u0120DE", "FAULT", "_", "B", "UCK", "ET", "_", "F", "MT", "_", "V", "2", "\u0120=", "\u0120'", "gs", "://", "{", "}", "-", "{", "}", "-", "data", "-", "{", "}", "'", "\u0120+", "FOR", "SET", "I", "_", "V", "1", "_", "R", "ULE", "_", "FIL", "ES", "\u0120=", "\u0120[", "\u0120+", "\u0120'", "big", "query", "_", "rules", ".", "y", "aml", "',", "\u0120'", "black", "list", "_", "rules", ".", "y", "aml", "',", "\u0120'", "buck", "et", "_", "rules", ".", "y", "aml", "',", "\u0120+", "\u0120'", "cloud", "sql", "_", "rules", ".", "y", "aml", "',", "\u0120'", "fire", "wall", "_", "rules", ".", "y", "aml", "',", "\u0120'", "forward", "ing", "_", "rules", ".", "y", "aml", "',", "\u0120+", "\u0120'", "group", "_", "rules", ".", "y", "aml", "',", "\u0120'", "iam", "_", "rules", ".", "y", "aml", "',", "\u0120'", "i", "ap", "_", "rules", ".", "y", "aml", "',", "\u0120'", "ke", "_", "rules", ".", "y", "aml", "',", "\u0120+", "\u0120'", "instance", "_", "network", "_", "interface", "_", "rules", ".", "y", "aml", "']", "\u0120+", "\u0120G", "CL", "OU", "D", "_", "MIN", "_", "VERSION", "\u0120=", "\u0120(", "180", ",", "\u01200", ",", "\u01200", ")", "\u0120G", "CL", "OU", "D", "_", "VERSION", "_", "REG", "EX", "\u0120=", "\u0120r", "'", "Google", "\u0120Cloud", "\u0120SDK", "\u0120(", ".*", ")'", "\u0120G", "CL", "OU", "D", "_", "AL", "P", "HA", "_", "REG", "EX", "\u0120=", "\u0120r", "'", "alpha", ".*", "'"], "docstring_tokens": ["Can", "\u0120you", "\u0120please", "\u0120make", "\u0120each", "\u0120of", "\u0120these", "\u0120in", "\u0120a", "\u0120separate", "\u0120line", ".", "\u0120It", "\u0120will", "\u0120be", "\u0120easier", "\u0120to", "\u0120keep", "\u0120them", "\u0120sorted", ",", "\u0120and", "\u0120add", "/", "remove", "."]}
{"function": "@@ -170,10 +170,14 @@ public class ConfigSetsHandler extends RequestHandlerBase implements PermissionN boolean overwritesExisting = zkClient.exists(configPathInZk, true); - if (overwritesExisting && !req.getParams().getBool(ConfigSetParams.OVERWRITE, false)) { - throw new SolrException(ErrorCode.BAD_REQUEST, - \"The configuration \" + configSetName + \" already exists in zookeeper\"); - } + // Get upload parameters + String singleFilePath = req.getParams().get(ConfigSetParams.FILE_PATH, \"\"); + boolean allowOverwrite = req.getParams().getBool(ConfigSetParams.OVERWRITE, false); + // Cleanup is not allowed while using singleFilePath upload + boolean cleanup = singleFilePath.isEmpty() && req.getParams().getBool(ConfigSetParams.CLEANUP, false); + + // Create a node for the configuration in zookeeper + createBaseZnode(zkClient, overwritesExisting, isTrusted(req, coreContainer.getAuthenticationPlugin()), cleanup, configPathInZk); Iterator<ContentStream> contentStreamsIterator = req.getContentStreams().iterator(); ", "text": "should we error instead of silently ignoring the `cleanup` param? it defaults to `false`, so someone must have explicitly set it to `true`", "function_tokens": ["@@", "\u0120-", "170", ",", "10", "\u0120+", "170", ",", "14", "\u0120@@", "\u0120public", "\u0120class", "\u0120Config", "S", "ets", "Handler", "\u0120extends", "\u0120Request", "Handler", "Base", "\u0120implements", "\u0120Per", "mission", "N", "\u0120boolean", "\u0120overw", "rites", "Ex", "isting", "\u0120=", "\u0120z", "k", "Client", ".", "ex", "ists", "(", "config", "Path", "In", "Z", "k", ",", "\u0120true", ");", "\u0120-", "\u0120if", "\u0120(", "over", "writ", "es", "Ex", "isting", "\u0120&&", "\u0120!", "req", ".", "get", "Par", "ams", "().", "get", "B", "ool", "(", "Config", "Set", "Par", "ams", ".", "OVER", "WR", "ITE", ",", "\u0120false", "))", "\u0120{", "\u0120-", "\u0120throw", "\u0120new", "\u0120Sol", "r", "Exception", "(", "Error", "Code", ".", "B", "AD", "_", "RE", "QUEST", ",", "\u0120-", "\u0120\"", "The", "\u0120configuration", "\u0120\"", "\u0120+", "\u0120config", "Set", "Name", "\u0120+", "\u0120\"", "\u0120already", "\u0120exists", "\u0120in", "\u0120zo", "oke", "eper", "\");", "\u0120-", "\u0120}", "\u0120+", "\u0120//", "\u0120Get", "\u0120upload", "\u0120parameters", "\u0120+", "\u0120String", "\u0120single", "File", "Path", "\u0120=", "\u0120req", ".", "get", "Par", "ams", "().", "get", "(", "Config", "Set", "Par", "ams", ".", "FILE", "_", "PATH", ",", "\u0120\"\"", ");", "\u0120+", "\u0120boolean", "\u0120allow", "Over", "write", "\u0120=", "\u0120req", ".", "get", "Par", "ams", "().", "get", "B", "ool", "(", "Config", "Set", "Par", "ams", ".", "OVER", "WR", "ITE", ",", "\u0120false", ");", "\u0120+", "\u0120//", "\u0120Clean", "up", "\u0120is", "\u0120not", "\u0120allowed", "\u0120while", "\u0120using", "\u0120single", "File", "Path", "\u0120upload", "\u0120+", "\u0120boolean", "\u0120cleanup", "\u0120=", "\u0120single", "File", "Path", ".", "is", "Empty", "()", "\u0120&&", "\u0120req", ".", "get", "Par", "ams", "().", "get", "B", "ool", "(", "Config", "Set", "Par", "ams", ".", "CLE", "AN", "UP", ",", "\u0120false", ");", "\u0120+", "\u0120+", "\u0120//", "\u0120Create", "\u0120a", "\u0120node", "\u0120for", "\u0120the", "\u0120configuration", "\u0120in", "\u0120zo", "oke", "eper", "\u0120+", "\u0120create", "Base", "Z", "node", "(", "z", "k", "Client", ",", "\u0120overw", "rites", "Ex", "isting", ",", "\u0120is", "Tr", "usted", "(", "req", ",", "\u0120core", "Container", ".", "get", "Authent", "ication", "Plugin", "()", "),", "\u0120cleanup", ",", "\u0120config", "Path", "In", "Z", "k", ");", "\u0120Iter", "ator", "<", "Content", "Stream", ">", "\u0120content", "Stream", "s", "Iterator", "\u0120=", "\u0120req", ".", "get", "Content", "Stream", "s", "().", "iterator", "();", "\u0120"], "docstring_tokens": ["should", "\u0120we", "\u0120error", "\u0120instead", "\u0120of", "\u0120silently", "\u0120ignoring", "\u0120the", "\u0120`", "clean", "up", "`", "\u0120param", "?", "\u0120it", "\u0120defaults", "\u0120to", "\u0120`", "false", "`,", "\u0120so", "\u0120someone", "\u0120must", "\u0120have", "\u0120explicitly", "\u0120set", "\u0120it", "\u0120to", "\u0120`", "true", "`"]}
{"function": "@@ -191,7 +191,7 @@ func NewReader(r io.ReaderAt, size int64) (*Reader, error) { if len(archive.File) == 0 { return nil, errors.New(\"archive is empty\") } else if fi := archive.File[0].FileInfo(); !fi.IsDir() { - return nil, errors.New(\"archive root is not a directory\") + return nil, fmt.Errorf(\"archive root directory missing: expected a 'root' directory but got %v\", archive.File[0].Name) } root := archive.File[0].Name pref, err := unitPrefix(root, archive.File)", "text": "There is no specific requirement that the root be called `root`, just that there is a single root directory and that it be the first entry in the zip.", "function_tokens": ["@@", "\u0120-", "191", ",", "7", "\u0120+", "191", ",", "7", "\u0120@@", "\u0120func", "\u0120New", "Reader", "(", "r", "\u0120io", ".", "Reader", "At", ",", "\u0120size", "\u0120int", "64", ")", "\u0120(*", "Reader", ",", "\u0120error", ")", "\u0120{", "\u0120if", "\u0120len", "(", "archive", ".", "File", ")", "\u0120==", "\u01200", "\u0120{", "\u0120return", "\u0120nil", ",", "\u0120errors", ".", "New", "(\"", "archive", "\u0120is", "\u0120empty", "\")", "\u0120}", "\u0120else", "\u0120if", "\u0120fi", "\u0120:=", "\u0120archive", ".", "File", "[", "0", "].", "File", "Info", "();", "\u0120!", "fi", ".", "Is", "Dir", "()", "\u0120{", "\u0120-", "\u0120return", "\u0120nil", ",", "\u0120errors", ".", "New", "(\"", "archive", "\u0120root", "\u0120is", "\u0120not", "\u0120a", "\u0120directory", "\")", "\u0120+", "\u0120return", "\u0120nil", ",", "\u0120fmt", ".", "Error", "f", "(\"", "archive", "\u0120root", "\u0120directory", "\u0120missing", ":", "\u0120expected", "\u0120a", "\u0120'", "root", "'", "\u0120directory", "\u0120but", "\u0120got", "\u0120%", "v", "\",", "\u0120archive", ".", "File", "[", "0", "].", "Name", ")", "\u0120}", "\u0120root", "\u0120:=", "\u0120archive", ".", "File", "[", "0", "].", "Name", "\u0120pref", ",", "\u0120err", "\u0120:=", "\u0120unit", "Pref", "ix", "(", "root", ",", "\u0120archive", ".", "File", ")"], "docstring_tokens": ["There", "\u0120is", "\u0120no", "\u0120specific", "\u0120requirement", "\u0120that", "\u0120the", "\u0120root", "\u0120be", "\u0120called", "\u0120`", "root", "`,", "\u0120just", "\u0120that", "\u0120there", "\u0120is", "\u0120a", "\u0120single", "\u0120root", "\u0120directory", "\u0120and", "\u0120that", "\u0120it", "\u0120be", "\u0120the", "\u0120first", "\u0120entry", "\u0120in", "\u0120the", "\u0120zip", "."]}
{"function": "@@ -1,6 +1,9 @@ <% unless ENV['DISABLE_SANDBOX_WARNING'] == 'true' %> <%= render partial: 'shared/sandbox_warning' %> <% end %> +<% if !current_page?(me_path) && current_user && current_user.requires_profile_attention? %> + <%= render partial: \"shared/user_profile_warning\" %> +<% end %> <header> <div class='container'> <div id='header-identity'>", "text": "perhaps we should encapsulate this logic in a helper method w a test?", "function_tokens": ["@@", "\u0120-", "1", ",", "6", "\u0120+", "1", ",", "9", "\u0120@@", "\u0120<", "%", "\u0120unless", "\u0120EN", "V", "['", "DIS", "ABLE", "_", "S", "AND", "BOX", "_", "WARNING", "']", "\u0120==", "\u0120'", "true", "'", "\u0120%", ">", "\u0120<", "%", "=", "\u0120render", "\u0120partial", ":", "\u0120'", "shared", "/", "sand", "box", "_", "warning", "'", "\u0120%", ">", "\u0120<", "%", "\u0120end", "\u0120%", ">", "\u0120+", "<", "%", "\u0120if", "\u0120!", "current", "_", "page", "?", "(", "me", "_", "path", ")", "\u0120&&", "\u0120current", "_", "user", "\u0120&&", "\u0120current", "_", "user", ".", "requires", "_", "profile", "_", "att", "ention", "?", "\u0120%", ">", "\u0120+", "\u0120<", "%", "=", "\u0120render", "\u0120partial", ":", "\u0120\"", "shared", "/", "user", "_", "profile", "_", "warning", "\"", "\u0120%", ">", "\u0120+", "<", "%", "\u0120end", "\u0120%", ">", "\u0120<", "header", ">", "\u0120<", "div", "\u0120class", "='", "container", "'>", "\u0120<", "div", "\u0120id", "='", "header", "-", "ident", "ity", "'>"], "docstring_tokens": ["perhaps", "\u0120we", "\u0120should", "\u0120encaps", "ulate", "\u0120this", "\u0120logic", "\u0120in", "\u0120a", "\u0120helper", "\u0120method", "\u0120w", "\u0120a", "\u0120test", "?"]}
{"function": "@@ -0,0 +1,7 @@ +[ 'options_hash', 'defaults', 'command_line_parser', 'pe_version_scraper', 'parser' ].each do |file| + begin + require \"beaker/options/#{file}\" + rescue LoadError + require File.expand_path(File.join(File.dirname(__FILE__), 'options', file)) + end +end", "text": "Now that we're only using this repo as a Gem you shouldn't need to `require` an expanded local file path like below.", "function_tokens": ["@@", "\u0120-", "0", ",", "0", "\u0120+", "1", ",", "7", "\u0120@@", "\u0120+", "[", "\u0120'", "options", "_", "hash", "',", "\u0120'", "default", "s", "',", "\u0120'", "command", "_", "line", "_", "parser", "',", "\u0120'", "pe", "_", "version", "_", "sc", "raper", "',", "\u0120'", "parser", "'", "\u0120].", "each", "\u0120do", "\u0120|", "file", "|", "\u0120+", "\u0120begin", "\u0120+", "\u0120require", "\u0120\"", "be", "aker", "/", "options", "/#", "{", "file", "}\"", "\u0120+", "\u0120rescue", "\u0120Load", "Error", "\u0120+", "\u0120require", "\u0120File", ".", "exp", "and", "_", "path", "(", "File", ".", "join", "(", "File", ".", "dir", "name", "(", "__", "FILE", "__", "),", "\u0120'", "options", "',", "\u0120file", "))", "\u0120+", "\u0120end", "\u0120+", "end"], "docstring_tokens": ["Now", "\u0120that", "\u0120we", "'re", "\u0120only", "\u0120using", "\u0120this", "\u0120repo", "\u0120as", "\u0120a", "\u0120Gem", "\u0120you", "\u0120shouldn", "'t", "\u0120need", "\u0120to", "\u0120`", "require", "`", "\u0120an", "\u0120expanded", "\u0120local", "\u0120file", "\u0120path", "\u0120like", "\u0120below", "."]}
{"function": "@@ -53,7 +53,8 @@ enum Timestamps implements Transform<Long, Integer> { OffsetDateTime timestamp = Instant .ofEpochSecond(timestampMicros / 1_000_000) .atOffset(ZoneOffset.UTC); - return (int) granularity.between(EPOCH, timestamp); + Integer year = Long.valueOf(granularity.between(EPOCH, timestamp)).intValue(); + return year; } @Override", "text": "This isn't necessarily a year. It may be months, days, or hours. Can we return `intValue()` directly instead?", "function_tokens": ["@@", "\u0120-", "53", ",", "7", "\u0120+", "53", ",", "8", "\u0120@@", "\u0120enum", "\u0120Tim", "est", "amps", "\u0120implements", "\u0120Transform", "<", "Long", ",", "\u0120Integer", ">", "\u0120{", "\u0120Off", "set", "Date", "Time", "\u0120timestamp", "\u0120=", "\u0120Instant", "\u0120.", "of", "Ep", "och", "Second", "(", "tim", "estamp", "Micro", "s", "\u0120/", "\u01201", "_", "000", "_", "000", ")", "\u0120.", "at", "Offset", "(", "Zone", "Offset", ".", "UTC", ");", "\u0120-", "\u0120return", "\u0120(", "int", ")", "\u0120gran", "ularity", ".", "between", "(", "EP", "O", "CH", ",", "\u0120timestamp", ");", "\u0120+", "\u0120Integer", "\u0120year", "\u0120=", "\u0120Long", ".", "value", "Of", "(", "gran", "ularity", ".", "between", "(", "EP", "O", "CH", ",", "\u0120timestamp", ")).", "int", "Value", "();", "\u0120+", "\u0120return", "\u0120year", ";", "\u0120}", "\u0120@", "Override"], "docstring_tokens": ["This", "\u0120isn", "'t", "\u0120necessarily", "\u0120a", "\u0120year", ".", "\u0120It", "\u0120may", "\u0120be", "\u0120months", ",", "\u0120days", ",", "\u0120or", "\u0120hours", ".", "\u0120Can", "\u0120we", "\u0120return", "\u0120`", "int", "Value", "()", "`", "\u0120directly", "\u0120instead", "?"]}
{"function": "@@ -351,8 +351,6 @@ func (mtask *managedTask) waitEvent(stopWaiting <-chan struct{}) bool { mtask.handleDesiredStatusChange(acsTransition.desiredStatus, acsTransition.seqnum) return false case dockerChange := <-mtask.dockerMessages: - seelog.Infof(\"Managed task [%s]: got container [%s (Runtime ID: %s)] event: [%s]\", - mtask.Arn, dockerChange.container.Name, dockerChange.container.GetRuntimeID(), dockerChange.event.Status.String()) mtask.handleContainerChange(dockerChange) return false case resChange := <-mtask.resourceStateChangeEvent:", "text": "this is redundant because it gets logged immediately on entering the handleContainerChange function", "function_tokens": ["@@", "\u0120-", "351", ",", "8", "\u0120+", "351", ",", "6", "\u0120@@", "\u0120func", "\u0120(", "mt", "ask", "\u0120*", "managed", "Task", ")", "\u0120wait", "Event", "(", "stop", "Wa", "iting", "\u0120<-", "chan", "\u0120struct", "{", "})", "\u0120bool", "\u0120{", "\u0120m", "task", ".", "handle", "Des", "ired", "Status", "Change", "(", "acs", "Trans", "ition", ".", "des", "ired", "Status", ",", "\u0120ac", "s", "Trans", "ition", ".", "seq", "num", ")", "\u0120return", "\u0120false", "\u0120case", "\u0120docker", "Change", "\u0120:=", "\u0120<-", "mt", "ask", ".", "docker", "Mess", "ages", ":", "\u0120-", "\u0120se", "el", "og", ".", "Inf", "of", "(\"", "Man", "aged", "\u0120task", "\u0120[", "%", "s", "]:", "\u0120got", "\u0120container", "\u0120[", "%", "s", "\u0120(", "Runtime", "\u0120ID", ":", "\u0120%", "s", ")]", "\u0120event", ":", "\u0120[", "%", "s", "]", "\",", "\u0120-", "\u0120m", "task", ".", "Ar", "n", ",", "\u0120docker", "Change", ".", "container", ".", "Name", ",", "\u0120docker", "Change", ".", "container", ".", "Get", "Runtime", "ID", "(),", "\u0120docker", "Change", ".", "event", ".", "Status", ".", "String", "())", "\u0120m", "task", ".", "handle", "Container", "Change", "(", "docker", "Change", ")", "\u0120return", "\u0120false", "\u0120case", "\u0120res", "Change", "\u0120:=", "\u0120<-", "mt", "ask", ".", "resource", "State", "Change", "Event", ":"], "docstring_tokens": ["this", "\u0120is", "\u0120redundant", "\u0120because", "\u0120it", "\u0120gets", "\u0120logged", "\u0120immediately", "\u0120on", "\u0120entering", "\u0120the", "\u0120handle", "Container", "Change", "\u0120function"]}
{"function": "@@ -126,7 +126,7 @@ func (e *Executor) reportRequiringApproval(ctx context.Context) { var approvers []string for _, v := range ds.GenericDeploymentConfig.DeploymentNotification.Mentions { - if v.Event == \"DEPLOYMENT_WAIT_APPROVAL\" { + if e := \"EVENT_\" + v.Event; e == model.NotificationEventType_EVENT_DEPLOYMENT_WAIT_APPROVAL.String() { approvers = v.Slack } }", "text": "`ds.GenericDeploymentConfig.DeploymentNotification` in L128 is nullable.", "function_tokens": ["@@", "\u0120-", "126", ",", "7", "\u0120+", "126", ",", "7", "\u0120@@", "\u0120func", "\u0120(", "e", "\u0120*", "Exec", "utor", ")", "\u0120report", "Requ", "iring", "App", "ro", "val", "(", "ctx", "\u0120context", ".", "Context", ")", "\u0120{", "\u0120var", "\u0120appro", "vers", "\u0120[]", "string", "\u0120for", "\u0120_", ",", "\u0120v", "\u0120:=", "\u0120range", "\u0120d", "s", ".", "Generic", "Deploy", "ment", "Config", ".", "Deploy", "ment", "Not", "ification", ".", "M", "ent", "ions", "\u0120{", "\u0120-", "\u0120if", "\u0120v", ".", "Event", "\u0120==", "\u0120\"", "DE", "PL", "OY", "MENT", "_", "WA", "IT", "_", "AP", "PROV", "AL", "\"", "\u0120{", "\u0120+", "\u0120if", "\u0120e", "\u0120:=", "\u0120\"", "EV", "ENT", "_", "\"", "\u0120+", "\u0120v", ".", "Event", ";", "\u0120e", "\u0120==", "\u0120model", ".", "Not", "ification", "Event", "Type", "_", "EV", "ENT", "_", "DE", "PL", "OY", "MENT", "_", "WA", "IT", "_", "AP", "PROV", "AL", ".", "String", "()", "\u0120{", "\u0120appro", "vers", "\u0120=", "\u0120v", ".", "Sl", "ack", "\u0120}", "\u0120}"], "docstring_tokens": ["`", "ds", ".", "Generic", "Deploy", "ment", "Config", ".", "Deploy", "ment", "Not", "ification", "`", "\u0120in", "\u0120L", "128", "\u0120is", "\u0120null", "able", "."]}
{"function": "@@ -42,4 +42,8 @@ public class CliqueMiningTracker { public boolean blockCreatedLocally(final BlockHeader header) { return CliqueHelpers.getProposerOfBlock(header).equals(localAddress); } + + public ProtocolContext getProtocolContext() { + return protocolContext; + } }", "text": "this shouldn't be exposed here - this class isn't a carriage for this - its used internally to determine if/how we can mine.", "function_tokens": ["@@", "\u0120-", "42", ",", "4", "\u0120+", "42", ",", "8", "\u0120@@", "\u0120public", "\u0120class", "\u0120Cl", "ique", "M", "ining", "Tracker", "\u0120{", "\u0120public", "\u0120boolean", "\u0120block", "Created", "Loc", "ally", "(", "final", "\u0120Block", "Header", "\u0120header", ")", "\u0120{", "\u0120return", "\u0120Cl", "ique", "Hel", "pers", ".", "get", "Prop", "oser", "Of", "Block", "(", "header", ").", "equ", "als", "(", "local", "Address", ");", "\u0120}", "\u0120+", "\u0120+", "\u0120public", "\u0120Protocol", "Context", "\u0120get", "Prot", "ocol", "Context", "()", "\u0120{", "\u0120+", "\u0120return", "\u0120protocol", "Context", ";", "\u0120+", "\u0120}", "\u0120}"], "docstring_tokens": ["this", "\u0120shouldn", "'t", "\u0120be", "\u0120exposed", "\u0120here", "\u0120-", "\u0120this", "\u0120class", "\u0120isn", "'t", "\u0120a", "\u0120carriage", "\u0120for", "\u0120this", "\u0120-", "\u0120its", "\u0120used", "\u0120internally", "\u0120to", "\u0120determine", "\u0120if", "/", "how", "\u0120we", "\u0120can", "\u0120mine", "."]}
{"function": "@@ -265,13 +265,11 @@ public class FirefoxDriver extends RemoteWebDriver @Override public String installExtension(Path path) { - Require.nonNull(\"Path\", path); return extensions.installExtension(path); } @Override public void uninstallExtension(String extensionId) { - Require.nonNull(\"Extension ID\", extensionId); extensions.uninstallExtension(extensionId); } ", "text": "It's fine to leave these checks in. It'll make the exception come from `FirefoxDriver`, and that's probably clearer to a user.", "function_tokens": ["@@", "\u0120-", "265", ",", "13", "\u0120+", "265", ",", "11", "\u0120@@", "\u0120public", "\u0120class", "\u0120Firefox", "Driver", "\u0120extends", "\u0120Remote", "Web", "Driver", "\u0120@", "Override", "\u0120public", "\u0120String", "\u0120install", "Ext", "ension", "(", "Path", "\u0120path", ")", "\u0120{", "\u0120-", "\u0120Requ", "ire", ".", "non", "Null", "(\"", "Path", "\",", "\u0120path", ");", "\u0120return", "\u0120extensions", ".", "install", "Ext", "ension", "(", "path", ");", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120uninstall", "Ext", "ension", "(", "String", "\u0120extension", "Id", ")", "\u0120{", "\u0120-", "\u0120Requ", "ire", ".", "non", "Null", "(\"", "Ext", "ension", "\u0120ID", "\",", "\u0120extension", "Id", ");", "\u0120extensions", ".", "un", "install", "Ext", "ension", "(", "ext", "ension", "Id", ");", "\u0120}", "\u0120"], "docstring_tokens": ["It", "'s", "\u0120fine", "\u0120to", "\u0120leave", "\u0120these", "\u0120checks", "\u0120in", ".", "\u0120It", "'ll", "\u0120make", "\u0120the", "\u0120exception", "\u0120come", "\u0120from", "\u0120`", "Fire", "fox", "Driver", "`,", "\u0120and", "\u0120that", "'s", "\u0120probably", "\u0120clearer", "\u0120to", "\u0120a", "\u0120user", "."]}
{"function": "@@ -60,8 +60,9 @@ RSpec.configure do |config| # Add modules for helpers config.include ControllerSpecHelper, type: :controller config.include RequestSpecHelper, type: :request - [:feature, :request].each do |type| + [:feature, :request, :model].each do |type| config.include IntegrationSpecHelper, type: type + config.include EnvironmentSpecHelper, type: type end config.include FeatureSpecHelper, type: :feature ", "text": "We don't want to include the `IntegrationSpecHelper` for models...mind moving this line out of the loop to be `config.include EnvironmentSpecHelper, type: :model`?", "function_tokens": ["@@", "\u0120-", "60", ",", "8", "\u0120+", "60", ",", "9", "\u0120@@", "\u0120R", "Spec", ".", "config", "ure", "\u0120do", "\u0120|", "config", "|", "\u0120#", "\u0120Add", "\u0120modules", "\u0120for", "\u0120helpers", "\u0120config", ".", "include", "\u0120Controller", "Spec", "Helper", ",", "\u0120type", ":", "\u0120:", "controller", "\u0120config", ".", "include", "\u0120Request", "Spec", "Helper", ",", "\u0120type", ":", "\u0120:", "request", "\u0120-", "\u0120[", ":", "feature", ",", "\u0120:", "request", "].", "each", "\u0120do", "\u0120|", "type", "|", "\u0120+", "\u0120[", ":", "feature", ",", "\u0120:", "request", ",", "\u0120:", "model", "].", "each", "\u0120do", "\u0120|", "type", "|", "\u0120config", ".", "include", "\u0120Integration", "Spec", "Helper", ",", "\u0120type", ":", "\u0120type", "\u0120+", "\u0120config", ".", "include", "\u0120Environment", "Spec", "Helper", ",", "\u0120type", ":", "\u0120type", "\u0120end", "\u0120config", ".", "include", "\u0120Feature", "Spec", "Helper", ",", "\u0120type", ":", "\u0120:", "feature", "\u0120"], "docstring_tokens": ["We", "\u0120don", "'t", "\u0120want", "\u0120to", "\u0120include", "\u0120the", "\u0120`", "Integ", "ration", "Spec", "Helper", "`", "\u0120for", "\u0120models", "...", "mind", "\u0120moving", "\u0120this", "\u0120line", "\u0120out", "\u0120of", "\u0120the", "\u0120loop", "\u0120to", "\u0120be", "\u0120`", "config", ".", "include", "\u0120Environment", "Spec", "Helper", ",", "\u0120type", ":", "\u0120:", "model", "`", "?"]}
{"function": "@@ -25,6 +25,9 @@ func TestWriteDrupalConfig(t *testing.T) { err = WriteDrupalConfig(drupalConfig, file.Name()) assert.NoError(t, err) + os.Chmod(dir, 0755) + os.Chmod(file.Name(), 0666) + err = os.RemoveAll(dir) assert.NoError(t, err) }", "text": "Please check the return on these.", "function_tokens": ["@@", "\u0120-", "25", ",", "6", "\u0120+", "25", ",", "9", "\u0120@@", "\u0120func", "\u0120Test", "Write", "D", "rupal", "Config", "(", "t", "\u0120*", "testing", ".", "T", ")", "\u0120{", "\u0120err", "\u0120=", "\u0120Write", "D", "rupal", "Config", "(", "d", "rupal", "Config", ",", "\u0120file", ".", "Name", "())", "\u0120assert", ".", "No", "Error", "(", "t", ",", "\u0120err", ")", "\u0120+", "\u0120os", ".", "Ch", "mod", "(", "dir", ",", "\u01200", "755", ")", "\u0120+", "\u0120os", ".", "Ch", "mod", "(", "file", ".", "Name", "(),", "\u01200", "666", ")", "\u0120+", "\u0120err", "\u0120=", "\u0120os", ".", "Remove", "All", "(", "dir", ")", "\u0120assert", ".", "No", "Error", "(", "t", ",", "\u0120err", ")", "\u0120}"], "docstring_tokens": ["Please", "\u0120check", "\u0120the", "\u0120return", "\u0120on", "\u0120these", "."]}
{"function": "@@ -279,10 +279,14 @@ class Storage { if (uplink == null) { uplink = new Proxy({ url: file.url, + cache: true, _autogenerated: true, }, self.config); } - let savestream = self.local.add_tarball(name, filename); + let savestream = null; + if (uplink.config.cache) { + savestream = self.local.add_tarball(name, filename); + } let on_open = function() { // prevent it from being called twice on_open = function() {};", "text": "Do we need `==` for true?", "function_tokens": ["@@", "\u0120-", "279", ",", "10", "\u0120+", "279", ",", "14", "\u0120@@", "\u0120class", "\u0120Storage", "\u0120{", "\u0120if", "\u0120(", "u", "pl", "ink", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120upl", "ink", "\u0120=", "\u0120new", "\u0120Proxy", "({", "\u0120url", ":", "\u0120file", ".", "url", ",", "\u0120+", "\u0120cache", ":", "\u0120true", ",", "\u0120_", "aut", "og", "ener", "ated", ":", "\u0120true", ",", "\u0120},", "\u0120self", ".", "config", ");", "\u0120}", "\u0120-", "\u0120let", "\u0120sa", "vest", "ream", "\u0120=", "\u0120self", ".", "local", ".", "add", "_", "tar", "ball", "(", "name", ",", "\u0120filename", ");", "\u0120+", "\u0120let", "\u0120sa", "vest", "ream", "\u0120=", "\u0120null", ";", "\u0120+", "\u0120if", "\u0120(", "u", "pl", "ink", ".", "config", ".", "cache", ")", "\u0120{", "\u0120+", "\u0120sa", "vest", "ream", "\u0120=", "\u0120self", ".", "local", ".", "add", "_", "tar", "ball", "(", "name", ",", "\u0120filename", ");", "\u0120+", "\u0120}", "\u0120let", "\u0120on", "_", "open", "\u0120=", "\u0120function", "()", "\u0120{", "\u0120//", "\u0120prevent", "\u0120it", "\u0120from", "\u0120being", "\u0120called", "\u0120twice", "\u0120on", "_", "open", "\u0120=", "\u0120function", "()", "\u0120{", "};"], "docstring_tokens": ["Do", "\u0120we", "\u0120need", "\u0120`", "==", "`", "\u0120for", "\u0120true", "?"]}
{"function": "@@ -17,7 +17,7 @@ class BaseEMAHook(Hook): momentum (float): The momentum used for updating ema parameter. Ema's parameter are updated with the formula: `ema_param = (1-momentum) * ema_param + momentum * cur_param`. - Defaults to 0.0002. + Defaults to 0.0001. skip_buffers (bool): Whether to skip the model buffers, such as batchnorm running stats (running_mean, running_var), it does not perform the ema operation. Default to False.", "text": "Changing the default value may cause BC-breaking. Suggest changing this value in config.", "function_tokens": ["@@", "\u0120-", "17", ",", "7", "\u0120+", "17", ",", "7", "\u0120@@", "\u0120class", "\u0120Base", "EM", "AH", "ook", "(", "H", "ook", "):", "\u0120momentum", "\u0120(", "float", "):", "\u0120The", "\u0120momentum", "\u0120used", "\u0120for", "\u0120updating", "\u0120em", "a", "\u0120parameter", ".", "\u0120Em", "a", "'s", "\u0120parameter", "\u0120are", "\u0120updated", "\u0120with", "\u0120the", "\u0120formula", ":", "\u0120`", "ema", "_", "param", "\u0120=", "\u0120(", "1", "-", "mom", "ent", "um", ")", "\u0120*", "\u0120em", "a", "_", "param", "\u0120+", "\u0120momentum", "\u0120*", "\u0120cur", "_", "param", "`.", "\u0120-", "\u0120Def", "aults", "\u0120to", "\u01200", ".", "0002", ".", "\u0120+", "\u0120Def", "aults", "\u0120to", "\u01200", ".", "0001", ".", "\u0120skip", "_", "buff", "ers", "\u0120(", "bool", "):", "\u0120Whether", "\u0120to", "\u0120skip", "\u0120the", "\u0120model", "\u0120buffers", ",", "\u0120such", "\u0120as", "\u0120batch", "norm", "\u0120running", "\u0120stats", "\u0120(", "running", "_", "mean", ",", "\u0120running", "_", "var", "),", "\u0120it", "\u0120does", "\u0120not", "\u0120perform", "\u0120the", "\u0120em", "a", "\u0120operation", ".", "\u0120Default", "\u0120to", "\u0120False", "."], "docstring_tokens": ["Changing", "\u0120the", "\u0120default", "\u0120value", "\u0120may", "\u0120cause", "\u0120BC", "-", "breaking", ".", "\u0120Suggest", "\u0120changing", "\u0120this", "\u0120value", "\u0120in", "\u0120config", "."]}
{"function": "@@ -325,7 +325,7 @@ class SimpleConfig(Logger): slider_pos = max(slider_pos, 0) slider_pos = min(slider_pos, len(FEE_ETA_TARGETS)) if slider_pos < len(FEE_ETA_TARGETS): - num_blocks = FEE_ETA_TARGETS[slider_pos] + num_blocks = FEE_ETA_TARGETS[int(slider_pos)] fee = self.eta_target_to_fee(num_blocks) else: fee = self.eta_target_to_fee(1)", "text": "how does that happen?", "function_tokens": ["@@", "\u0120-", "325", ",", "7", "\u0120+", "325", ",", "7", "\u0120@@", "\u0120class", "\u0120Simple", "Config", "(", "Log", "ger", "):", "\u0120slider", "_", "pos", "\u0120=", "\u0120max", "(", "sl", "ider", "_", "pos", ",", "\u01200", ")", "\u0120slider", "_", "pos", "\u0120=", "\u0120min", "(", "sl", "ider", "_", "pos", ",", "\u0120len", "(", "F", "EE", "_", "ETA", "_", "T", "ARGET", "S", "))", "\u0120if", "\u0120slider", "_", "pos", "\u0120<", "\u0120len", "(", "F", "EE", "_", "ETA", "_", "T", "ARGET", "S", "):", "\u0120-", "\u0120num", "_", "blocks", "\u0120=", "\u0120F", "EE", "_", "ETA", "_", "T", "ARGET", "S", "[", "sl", "ider", "_", "pos", "]", "\u0120+", "\u0120num", "_", "blocks", "\u0120=", "\u0120F", "EE", "_", "ETA", "_", "T", "ARGET", "S", "[", "int", "(", "sl", "ider", "_", "pos", ")]", "\u0120fee", "\u0120=", "\u0120self", ".", "eta", "_", "target", "_", "to", "_", "fee", "(", "num", "_", "blocks", ")", "\u0120else", ":", "\u0120fee", "\u0120=", "\u0120self", ".", "eta", "_", "target", "_", "to", "_", "fee", "(", "1", ")"], "docstring_tokens": ["how", "\u0120does", "\u0120that", "\u0120happen", "?"]}
{"function": "@@ -31,9 +31,9 @@ # from __future__ import print_function -import unittest +import unittest, doctest import os,sys - +from rdkit.six import exec_ from rdkit.six.moves import cPickle from rdkit import rdBase", "text": "This is gross/clever. :-)", "function_tokens": ["@@", "\u0120-", "31", ",", "9", "\u0120+", "31", ",", "9", "\u0120@@", "\u0120#", "\u0120from", "\u0120__", "future", "__", "\u0120import", "\u0120print", "_", "function", "\u0120-", "import", "\u0120un", "itt", "est", "\u0120+", "import", "\u0120un", "itt", "est", ",", "\u0120doct", "est", "\u0120import", "\u0120os", ",", "sys", "\u0120-", "\u0120+", "from", "\u0120r", "d", "kit", ".", "six", "\u0120import", "\u0120exec", "_", "\u0120from", "\u0120r", "d", "kit", ".", "six", ".", "m", "oves", "\u0120import", "\u0120c", "Pick", "le", "\u0120from", "\u0120r", "d", "kit", "\u0120import", "\u0120r", "d", "Base"], "docstring_tokens": ["This", "\u0120is", "\u0120gross", "/", "cle", "ver", ".", "\u0120:-)"]}
{"function": "@@ -1,6 +1,6 @@ require File.expand_path(File.dirname(__FILE__) + '/test_helper.rb') -class TestZhCnLocale < Test::Unit::TestCase +class TestZhLocale < Test::Unit::TestCase def setup Faker::Config.locale = 'zh-CN' end", "text": "Take a look at the name of this file. Definitely copy and  ", "function_tokens": ["@@", "\u0120-", "1", ",", "6", "\u0120+", "1", ",", "6", "\u0120@@", "\u0120require", "\u0120File", ".", "exp", "and", "_", "path", "(", "File", ".", "dir", "name", "(", "__", "FILE", "__", ")", "\u0120+", "\u0120'/", "test", "_", "hel", "per", ".", "rb", "')", "\u0120-", "class", "\u0120Test", "Z", "h", "C", "n", "Loc", "ale", "\u0120<", "\u0120Test", "::", "Unit", "::", "Test", "Case", "\u0120+", "class", "\u0120Test", "Z", "h", "Loc", "ale", "\u0120<", "\u0120Test", "::", "Unit", "::", "Test", "Case", "\u0120def", "\u0120setup", "\u0120F", "aker", "::", "Config", ".", "loc", "ale", "\u0120=", "\u0120'", "zh", "-", "CN", "'", "\u0120end"], "docstring_tokens": ["Take", "\u0120a", "\u0120look", "\u0120at", "\u0120the", "\u0120name", "\u0120of", "\u0120this", "\u0120file", ".", "\u0120Definitely", "\u0120copy", "\u0120and", "\u0120", "\u0120"]}
{"function": "@@ -163,12 +163,15 @@ func NewVolumeInfo(URL string, volname string, namespace string) (volInfo *Volum if resp.StatusCode == 500 { fmt.Printf(\"Volume: %s not found at namespace: %q\\n\", volname, namespace) err = util.InternalServerError + return } else if resp.StatusCode == 503 { fmt.Printf(\"maya apiservice not reachable at %q\\n\", mapiserver.GetURL()) err = util.ServerUnavailable + return } else if resp.StatusCode == 404 { fmt.Printf(\"Volume: %s not found at namespace: %q error: %s\\n\", volname, namespace, http.StatusText(resp.StatusCode)) err = util.PageNotFound + return } fmt.Printf(\"Received an error from maya apiservice: statuscode: %d\", resp.StatusCode) err = fmt.Errorf(\"Received an error from maya apiservice: statuscode: %d\", resp.StatusCode)", "text": "Can you check with @mahebbar how to work this error. Should be different from 404.", "function_tokens": ["@@", "\u0120-", "163", ",", "12", "\u0120+", "163", ",", "15", "\u0120@@", "\u0120func", "\u0120New", "Volume", "Info", "(", "URL", "\u0120string", ",", "\u0120vol", "name", "\u0120string", ",", "\u0120namespace", "\u0120string", ")", "\u0120(", "vol", "Info", "\u0120*", "Vol", "um", "\u0120if", "\u0120resp", ".", "Status", "Code", "\u0120==", "\u0120500", "\u0120{", "\u0120fmt", ".", "Print", "f", "(\"", "Volume", ":", "\u0120%", "s", "\u0120not", "\u0120found", "\u0120at", "\u0120namespace", ":", "\u0120%", "q", "\\", "n", "\",", "\u0120vol", "name", ",", "\u0120namespace", ")", "\u0120err", "\u0120=", "\u0120util", ".", "Internal", "Server", "Error", "\u0120+", "\u0120return", "\u0120}", "\u0120else", "\u0120if", "\u0120resp", ".", "Status", "Code", "\u0120==", "\u0120503", "\u0120{", "\u0120fmt", ".", "Print", "f", "(\"", "may", "a", "\u0120ap", "is", "erv", "ice", "\u0120not", "\u0120reach", "able", "\u0120at", "\u0120%", "q", "\\", "n", "\",", "\u0120map", "iser", "ver", ".", "Get", "URL", "())", "\u0120err", "\u0120=", "\u0120util", ".", "Server", "Un", "available", "\u0120+", "\u0120return", "\u0120}", "\u0120else", "\u0120if", "\u0120resp", ".", "Status", "Code", "\u0120==", "\u0120404", "\u0120{", "\u0120fmt", ".", "Print", "f", "(\"", "Volume", ":", "\u0120%", "s", "\u0120not", "\u0120found", "\u0120at", "\u0120namespace", ":", "\u0120%", "q", "\u0120error", ":", "\u0120%", "s", "\\", "n", "\",", "\u0120vol", "name", ",", "\u0120namespace", ",", "\u0120http", ".", "Status", "Text", "(", "resp", ".", "Status", "Code", "))", "\u0120err", "\u0120=", "\u0120util", ".", "Page", "Not", "Found", "\u0120+", "\u0120return", "\u0120}", "\u0120fmt", ".", "Print", "f", "(\"", "Re", "ceived", "\u0120an", "\u0120error", "\u0120from", "\u0120may", "a", "\u0120ap", "is", "erv", "ice", ":", "\u0120status", "code", ":", "\u0120%", "d", "\",", "\u0120resp", ".", "Status", "Code", ")", "\u0120err", "\u0120=", "\u0120fmt", ".", "Error", "f", "(\"", "Re", "ceived", "\u0120an", "\u0120error", "\u0120from", "\u0120may", "a", "\u0120ap", "is", "erv", "ice", ":", "\u0120status", "code", ":", "\u0120%", "d", "\",", "\u0120resp", ".", "Status", "Code", ")"], "docstring_tokens": ["Can", "\u0120you", "\u0120check", "\u0120with", "\u0120@", "ma", "he", "b", "bar", "\u0120how", "\u0120to", "\u0120work", "\u0120this", "\u0120error", ".", "\u0120Should", "\u0120be", "\u0120different", "\u0120from", "\u0120404", "."]}
{"function": "@@ -46,7 +46,7 @@ setup( 'spark': ['pyspark>=2.4.0'], 'mlflow': ['mlflow>=1.0'], }, - python_requires='>=3.5,<3.8', + python_requires='>=3.5', install_requires=[ 'pandas>=0.23.2', 'pyarrow>=0.10',", "text": "Do we still need the upper bound `<3.9`?", "function_tokens": ["@@", "\u0120-", "46", ",", "7", "\u0120+", "46", ",", "7", "\u0120@@", "\u0120setup", "(", "\u0120'", "sp", "ark", "':", "\u0120['", "p", "ys", "park", ">", "=", "2", ".", "4", ".", "0", "'", "],", "\u0120'", "m", "lf", "low", "':", "\u0120['", "m", "lf", "low", ">", "=", "1", ".", "0", "'", "],", "\u0120},", "\u0120-", "\u0120python", "_", "requires", "='", ">", "=", "3", ".", "5", ",", "<", "3", ".", "8", "',", "\u0120+", "\u0120python", "_", "requires", "='", ">", "=", "3", ".", "5", "',", "\u0120install", "_", "requires", "=[", "\u0120'", "p", "and", "as", ">", "=", "0", ".", "23", ".", "2", "',", "\u0120'", "py", "arrow", ">", "=", "0", ".", "10", "',"], "docstring_tokens": ["Do", "\u0120we", "\u0120still", "\u0120need", "\u0120the", "\u0120upper", "\u0120bound", "\u0120`", "<", "3", ".", "9", "`", "?"]}
{"function": "@@ -229,7 +229,10 @@ function getPathsToCheck($f_paths): ?array /** @var string */ $input_path = $input_paths[$i]; - if (realpath($input_path) === realpath(dirname(__DIR__) . DIRECTORY_SEPARATOR . 'psalm') + if ( + realpath($input_path) === realpath(dirname(__DIR__, 3) . DIRECTORY_SEPARATOR . 'bin' . DIRECTORY_SEPARATOR . 'psalm') + || realpath($input_path) === realpath(dirname(__DIR__, 3) . DIRECTORY_SEPARATOR . 'bin' . DIRECTORY_SEPARATOR . 'psalter') + || realpath($input_path) === realpath(dirname(__DIR__) . DIRECTORY_SEPARATOR . 'psalm') || realpath($input_path) === realpath(dirname(__DIR__) . DIRECTORY_SEPARATOR . 'psalter') || realpath($input_path) === realpath(Phar::running(false)) ) {", "text": "Does this mean `vendor/bin/psalm` is not a symlink (or whatever equivalent Windows has for symlinks) on Windows?", "function_tokens": ["@@", "\u0120-", "229", ",", "7", "\u0120+", "229", ",", "10", "\u0120@@", "\u0120function", "\u0120get", "Path", "s", "To", "Check", "($", "f", "_", "path", "s", "):", "\u0120?", "array", "\u0120/**", "\u0120@", "var", "\u0120string", "\u0120*/", "\u0120$", "input", "_", "path", "\u0120=", "\u0120$", "input", "_", "path", "s", "[", "$", "i", "];", "\u0120-", "\u0120if", "\u0120(", "real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "dir", "name", "(", "__", "DIR", "__", ")", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "ps", "alm", "')", "\u0120+", "\u0120if", "\u0120(", "\u0120+", "\u0120real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "dir", "name", "(", "__", "DIR", "__", ",", "\u01203", ")", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "bin", "'", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "ps", "alm", "')", "\u0120+", "\u0120||", "\u0120real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "dir", "name", "(", "__", "DIR", "__", ",", "\u01203", ")", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "bin", "'", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "ps", "alter", "')", "\u0120+", "\u0120||", "\u0120real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "dir", "name", "(", "__", "DIR", "__", ")", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "ps", "alm", "')", "\u0120||", "\u0120real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "dir", "name", "(", "__", "DIR", "__", ")", "\u0120.", "\u0120DIRECT", "ORY", "_", "SE", "PAR", "ATOR", "\u0120.", "\u0120'", "ps", "alter", "')", "\u0120||", "\u0120real", "path", "($", "input", "_", "path", ")", "\u0120===", "\u0120real", "path", "(", "Ph", "ar", "::", "running", "(", "false", "))", "\u0120)", "\u0120{"], "docstring_tokens": ["Does", "\u0120this", "\u0120mean", "\u0120`", "v", "endor", "/", "bin", "/", "ps", "alm", "`", "\u0120is", "\u0120not", "\u0120a", "\u0120sy", "ml", "ink", "\u0120(", "or", "\u0120whatever", "\u0120equivalent", "\u0120Windows", "\u0120has", "\u0120for", "\u0120sym", "links", ")", "\u0120on", "\u0120Windows", "?"]}
{"function": "@@ -1,4 +1,4 @@ -package aws_test +package aws import ( \"fmt\"", "text": "@lpabon having a separate package name `aws_test` allows to test the package as if the tester was an external package. If the test package name is the same as the package being tested, the test package can also use methods and variables not exposed to the eventual user.", "function_tokens": ["@@", "\u0120-", "1", ",", "4", "\u0120+", "1", ",", "4", "\u0120@@", "\u0120-", "package", "\u0120aw", "s", "_", "test", "\u0120+", "package", "\u0120aw", "s", "\u0120import", "\u0120(", "\u0120\"", "f", "mt", "\""], "docstring_tokens": ["@", "lp", "ab", "on", "\u0120having", "\u0120a", "\u0120separate", "\u0120package", "\u0120name", "\u0120`", "aws", "_", "test", "`", "\u0120allows", "\u0120to", "\u0120test", "\u0120the", "\u0120package", "\u0120as", "\u0120if", "\u0120the", "\u0120t", "ester", "\u0120was", "\u0120an", "\u0120external", "\u0120package", ".", "\u0120If", "\u0120the", "\u0120test", "\u0120package", "\u0120name", "\u0120is", "\u0120the", "\u0120same", "\u0120as", "\u0120the", "\u0120package", "\u0120being", "\u0120tested", ",", "\u0120the", "\u0120test", "\u0120package", "\u0120can", "\u0120also", "\u0120use", "\u0120methods", "\u0120and", "\u0120variables", "\u0120not", "\u0120exposed", "\u0120to", "\u0120the", "\u0120eventual", "\u0120user", "."]}
{"function": "@@ -54,8 +54,6 @@ func RunEndToEndTest(ctx context.Context, t *testing.T, exp *otlpmetric.Exporter instruments := map[string]data{ \"test-int64-counter\": {sdkapi.CounterInstrumentKind, number.Int64Kind, 1}, \"test-float64-counter\": {sdkapi.CounterInstrumentKind, number.Float64Kind, 1}, - \"test-int64-histogram\": {sdkapi.HistogramInstrumentKind, number.Int64Kind, 2}, - \"test-float64-histogram\": {sdkapi.HistogramInstrumentKind, number.Float64Kind, 2}, \"test-int64-gaugeobserver\": {sdkapi.GaugeObserverInstrumentKind, number.Int64Kind, 3}, \"test-float64-gaugeobserver\": {sdkapi.GaugeObserverInstrumentKind, number.Float64Kind, 3}, }", "text": "The exporter should still be able to test these histogram instrument kinds, right? Is there another reason to remove these?", "function_tokens": ["@@", "\u0120-", "54", ",", "8", "\u0120+", "54", ",", "6", "\u0120@@", "\u0120func", "\u0120Run", "End", "To", "End", "Test", "(", "ctx", "\u0120context", ".", "Context", ",", "\u0120t", "\u0120*", "testing", ".", "T", ",", "\u0120exp", "\u0120*", "ot", "lp", "met", "ric", ".", "Ex", "porter", "\u0120instruments", "\u0120:=", "\u0120map", "[", "string", "]", "data", "{", "\u0120\"", "test", "-", "int", "64", "-", "counter", "\":", "\u0120{", "sd", "k", "api", ".", "Counter", "In", "strument", "Kind", ",", "\u0120number", ".", "Int", "64", "Kind", ",", "\u01201", "},", "\u0120\"", "test", "-", "float", "64", "-", "counter", "\":", "\u0120{", "sd", "k", "api", ".", "Counter", "In", "strument", "Kind", ",", "\u0120number", ".", "Float", "64", "Kind", ",", "\u01201", "},", "\u0120-", "\u0120\"", "test", "-", "int", "64", "-", "hist", "ogram", "\":", "\u0120{", "sd", "k", "api", ".", "Hist", "ogram", "In", "strument", "Kind", ",", "\u0120number", ".", "Int", "64", "Kind", ",", "\u01202", "},", "\u0120-", "\u0120\"", "test", "-", "float", "64", "-", "hist", "ogram", "\":", "\u0120{", "sd", "k", "api", ".", "Hist", "ogram", "In", "strument", "Kind", ",", "\u0120number", ".", "Float", "64", "Kind", ",", "\u01202", "},", "\u0120\"", "test", "-", "int", "64", "-", "g", "au", "ge", "ob", "server", "\":", "\u0120{", "sd", "k", "api", ".", "G", "au", "ge", "Obs", "erver", "In", "strument", "Kind", ",", "\u0120number", ".", "Int", "64", "Kind", ",", "\u01203", "},", "\u0120\"", "test", "-", "float", "64", "-", "g", "au", "ge", "ob", "server", "\":", "\u0120{", "sd", "k", "api", ".", "G", "au", "ge", "Obs", "erver", "In", "strument", "Kind", ",", "\u0120number", ".", "Float", "64", "Kind", ",", "\u01203", "},", "\u0120}"], "docstring_tokens": ["The", "\u0120exp", "orter", "\u0120should", "\u0120still", "\u0120be", "\u0120able", "\u0120to", "\u0120test", "\u0120these", "\u0120hist", "ogram", "\u0120instrument", "\u0120kinds", ",", "\u0120right", "?", "\u0120Is", "\u0120there", "\u0120another", "\u0120reason", "\u0120to", "\u0120remove", "\u0120these", "?"]}
{"function": "@@ -274,6 +274,13 @@ func (eval *BlockEvaluator) Round() basics.Round { return eval.block.Round() } +// ResetTxnBytes resets the number of bytes tracked by the BlockEvaluator to +// zero. This is a specialized operation used by the transaction pool to +// simulate the effect of putting pending transactions in multiple blocks. +func (eval *BlockEvaluator) ResetTxnBytes(validateTxnBytes bool) { + eval.totalTxBytes = 0 +} + // Transaction tentatively adds a new transaction as part of this block evaluation. // If the transaction cannot be added to the block without violating some constraints, // an error is returned and the block evaluator state is unchanged.", "text": "should this increment eval.Round somehow?", "function_tokens": ["@@", "\u0120-", "274", ",", "6", "\u0120+", "274", ",", "13", "\u0120@@", "\u0120func", "\u0120(", "eval", "\u0120*", "Block", "E", "val", "u", "ator", ")", "\u0120Round", "()", "\u0120basics", ".", "Round", "\u0120{", "\u0120return", "\u0120eval", ".", "block", ".", "Round", "()", "\u0120}", "\u0120+", "//", "\u0120Reset", "Tx", "n", "Bytes", "\u0120res", "ets", "\u0120the", "\u0120number", "\u0120of", "\u0120bytes", "\u0120tracked", "\u0120by", "\u0120the", "\u0120Block", "E", "val", "u", "ator", "\u0120to", "\u0120+", "//", "\u0120zero", ".", "\u0120This", "\u0120is", "\u0120a", "\u0120specialized", "\u0120operation", "\u0120used", "\u0120by", "\u0120the", "\u0120transaction", "\u0120pool", "\u0120to", "\u0120+", "//", "\u0120simulate", "\u0120the", "\u0120effect", "\u0120of", "\u0120putting", "\u0120pending", "\u0120transactions", "\u0120in", "\u0120multiple", "\u0120blocks", ".", "\u0120+", "func", "\u0120(", "eval", "\u0120*", "Block", "E", "val", "u", "ator", ")", "\u0120Reset", "Tx", "n", "Bytes", "(", "valid", "ate", "Tx", "n", "Bytes", "\u0120bool", ")", "\u0120{", "\u0120+", "\u0120eval", ".", "total", "Tx", "Bytes", "\u0120=", "\u01200", "\u0120+", "}", "\u0120+", "\u0120//", "\u0120Transaction", "\u0120tent", "atively", "\u0120adds", "\u0120a", "\u0120new", "\u0120transaction", "\u0120as", "\u0120part", "\u0120of", "\u0120this", "\u0120block", "\u0120evaluation", ".", "\u0120//", "\u0120If", "\u0120the", "\u0120transaction", "\u0120cannot", "\u0120be", "\u0120added", "\u0120to", "\u0120the", "\u0120block", "\u0120without", "\u0120violating", "\u0120some", "\u0120constraints", ",", "\u0120//", "\u0120an", "\u0120error", "\u0120is", "\u0120returned", "\u0120and", "\u0120the", "\u0120block", "\u0120eval", "u", "ator", "\u0120state", "\u0120is", "\u0120unchanged", "."], "docstring_tokens": ["should", "\u0120this", "\u0120increment", "\u0120eval", ".", "Round", "\u0120somehow", "?"]}
{"function": "@@ -91,7 +91,7 @@ class Blacklight::Solr::Response < ActiveSupport::HashWithIndifferentAccess value.each { |v| force_to_utf8(v) } when String if value.encoding != Encoding::UTF_8 - Rails.logger.warn \"Found a non utf-8 value in Blacklight::Solr::Response. \\\"#{value}\\\" Encoding is #{value.encoding}\" + Blacklight.logger.warn \"Found a non utf-8 value in Blacklight::Solr::Response. \\\"#{value}\\\" Encoding is #{value.encoding}\" value.dup.force_encoding('UTF-8') else value", "text": "Although this change looks good. Maybe there are other inconsistent cases too?", "function_tokens": ["@@", "\u0120-", "91", ",", "7", "\u0120+", "91", ",", "7", "\u0120@@", "\u0120class", "\u0120Black", "light", "::", "Sol", "r", "::", "Response", "\u0120<", "\u0120Active", "Support", "::", "Hash", "With", "Ind", "ifferent", "Access", "\u0120value", ".", "each", "\u0120{", "\u0120|", "v", "|", "\u0120force", "_", "to", "_", "utf", "8", "(", "v", ")", "\u0120}", "\u0120when", "\u0120String", "\u0120if", "\u0120value", ".", "enc", "oding", "\u0120!=", "\u0120Enc", "oding", "::", "UTF", "_", "8", "\u0120-", "\u0120Rails", ".", "log", "ger", ".", "warn", "\u0120\"", "Found", "\u0120a", "\u0120non", "\u0120ut", "f", "-", "8", "\u0120value", "\u0120in", "\u0120Black", "light", "::", "Sol", "r", "::", "Response", ".", "\u0120\\\"", "#", "{", "value", "}", "\\\"", "\u0120Enc", "oding", "\u0120is", "\u0120#", "{", "value", ".", "enc", "oding", "}\"", "\u0120+", "\u0120Black", "light", ".", "log", "ger", ".", "warn", "\u0120\"", "Found", "\u0120a", "\u0120non", "\u0120ut", "f", "-", "8", "\u0120value", "\u0120in", "\u0120Black", "light", "::", "Sol", "r", "::", "Response", ".", "\u0120\\\"", "#", "{", "value", "}", "\\\"", "\u0120Enc", "oding", "\u0120is", "\u0120#", "{", "value", ".", "enc", "oding", "}\"", "\u0120value", ".", "du", "p", ".", "force", "_", "enc", "oding", "('", "UTF", "-", "8", "')", "\u0120else", "\u0120value"], "docstring_tokens": ["Although", "\u0120this", "\u0120change", "\u0120looks", "\u0120good", ".", "\u0120Maybe", "\u0120there", "\u0120are", "\u0120other", "\u0120inconsistent", "\u0120cases", "\u0120too", "?"]}
{"function": "@@ -21,7 +21,7 @@ module ApplicationHelper '/auth/github' end - def format_resources(resources) + def format_markdown(resources) BlueCloth.new(resources).to_html.html_safe end ", "text": "This is a way better method name.", "function_tokens": ["@@", "\u0120-", "21", ",", "7", "\u0120+", "21", ",", "7", "\u0120@@", "\u0120module", "\u0120Application", "Helper", "\u0120'/", "auth", "/", "github", "'", "\u0120end", "\u0120-", "\u0120def", "\u0120format", "_", "resources", "(", "resources", ")", "\u0120+", "\u0120def", "\u0120format", "_", "mark", "down", "(", "resources", ")", "\u0120Blue", "Cl", "oth", ".", "new", "(", "resources", ").", "to", "_", "html", ".", "html", "_", "safe", "\u0120end", "\u0120"], "docstring_tokens": ["This", "\u0120is", "\u0120a", "\u0120way", "\u0120better", "\u0120method", "\u0120name", "."]}
{"function": "@@ -1,7 +1,5 @@ class NewLanguageConfirmationsController < ApplicationController def index - redirect_to welcome_to_upcase_path( - confirmation: true, language_selected: params[:language], - ), notice: \"Thanks for signing up. We will be in touch!\" + redirect_to root_path, notice: t(\"marketing.show.language_flash\") end end", "text": "Prefer single-quoted strings when you don't need string interpolation or special symbols.", "function_tokens": ["@@", "\u0120-", "1", ",", "7", "\u0120+", "1", ",", "5", "\u0120@@", "\u0120class", "\u0120New", "Language", "Conf", "irm", "ations", "Controller", "\u0120<", "\u0120Application", "Controller", "\u0120def", "\u0120index", "\u0120-", "\u0120redirect", "_", "to", "\u0120welcome", "_", "to", "_", "up", "case", "_", "path", "(", "\u0120-", "\u0120confirmation", ":", "\u0120true", ",", "\u0120language", "_", "selected", ":", "\u0120params", "[", ":", "language", "],", "\u0120-", "\u0120),", "\u0120notice", ":", "\u0120\"", "Thanks", "\u0120for", "\u0120signing", "\u0120up", ".", "\u0120We", "\u0120will", "\u0120be", "\u0120in", "\u0120touch", "!\"", "\u0120+", "\u0120redirect", "_", "to", "\u0120root", "_", "path", ",", "\u0120notice", ":", "\u0120t", "(\"", "market", "ing", ".", "show", ".", "language", "_", "flash", "\")", "\u0120end", "\u0120end"], "docstring_tokens": ["Pre", "fer", "\u0120single", "-", "qu", "oted", "\u0120strings", "\u0120when", "\u0120you", "\u0120don", "'t", "\u0120need", "\u0120string", "\u0120interpol", "ation", "\u0120or", "\u0120special", "\u0120symbols", "."]}
{"function": "@@ -1,3 +1,5 @@ +options = Array.isArray(options) ? options : []; + var invalid = []; var attr, attrName, allowed,", "text": "I was wondering if this should allow per role specification, instead of (or in addition to) a generic \"allowed everywhere\". So you could do: `{ separator: ['aria-valuenow', 'aria-valuemin', 'aria-valuemax'] }`. You could still allow the array, and you could add a wildcard option for the \"generic\" case you've got now: `{ '*': ['always-allowed'] }`.", "function_tokens": ["@@", "\u0120-", "1", ",", "3", "\u0120+", "1", ",", "5", "\u0120@@", "\u0120+", "options", "\u0120=", "\u0120Array", ".", "is", "Array", "(", "options", ")", "\u0120?", "\u0120options", "\u0120:", "\u0120[];", "\u0120+", "\u0120var", "\u0120invalid", "\u0120=", "\u0120[];", "\u0120var", "\u0120att", "r", ",", "\u0120att", "r", "Name", ",", "\u0120allowed", ","], "docstring_tokens": ["I", "\u0120was", "\u0120wondering", "\u0120if", "\u0120this", "\u0120should", "\u0120allow", "\u0120per", "\u0120role", "\u0120specification", ",", "\u0120instead", "\u0120of", "\u0120(", "or", "\u0120in", "\u0120addition", "\u0120to", ")", "\u0120a", "\u0120generic", "\u0120\"", "allowed", "\u0120everywhere", "\".", "\u0120So", "\u0120you", "\u0120could", "\u0120do", ":", "\u0120`", "{", "\u0120separ", "ator", ":", "\u0120['", "aria", "-", "val", "u", "en", "ow", "',", "\u0120'", "aria", "-", "val", "u", "emin", "',", "\u0120'", "aria", "-", "val", "u", "em", "ax", "']", "\u0120}", "`.", "\u0120You", "\u0120could", "\u0120still", "\u0120allow", "\u0120the", "\u0120array", ",", "\u0120and", "\u0120you", "\u0120could", "\u0120add", "\u0120a", "\u0120wild", "card", "\u0120option", "\u0120for", "\u0120the", "\u0120\"", "generic", "\"", "\u0120case", "\u0120you", "'ve", "\u0120got", "\u0120now", ":", "\u0120`", "{", "\u0120'", "*", "':", "\u0120['", "always", "-", "allowed", "']", "\u0120}", "`."]}
{"function": "@@ -942,7 +942,8 @@ SQLVarChar::SQLVarChar(Lng32 maxLen, FALSE, allowSQLnull, isUpShifted, isCaseInsensitive, TRUE, cs, co, ce, encoding, vcIndLen), - clientDataType_(collHeap()) // Get heap from NABasicObject. Can't allocate on stack. + clientDataType_(collHeap()), // Get heap from NABasicObject. Can't allocate on stack. + wasHiveString_(FALSE) {} #pragma warn(1506) // warning elimination ", "text": "I'm confused by the name. The string was a Hive string but it isn't any longer? Why should we care? (I imagine I'll find the answer later... there is some different semantic that we want downstream...)", "function_tokens": ["@@", "\u0120-", "9", "42", ",", "7", "\u0120+", "9", "42", ",", "8", "\u0120@@", "\u0120SQL", "Var", "Char", "::", "SQL", "Var", "Char", "(", "L", "ng", "32", "\u0120max", "Len", ",", "\u0120FALSE", ",", "\u0120allow", "SQL", "null", ",", "\u0120is", "Up", "Sh", "ifted", ",", "\u0120is", "Case", "Ins", "ensitive", ",", "\u0120TRUE", ",", "\u0120cs", ",", "\u0120co", ",", "\u0120ce", ",", "\u0120encoding", ",", "\u0120v", "c", "Ind", "Len", "),", "\u0120-", "\u0120client", "Data", "Type", "_(", "coll", "He", "ap", "())", "\u0120//", "\u0120Get", "\u0120heap", "\u0120from", "\u0120N", "AB", "as", "ic", "Object", ".", "\u0120Can", "'t", "\u0120allocate", "\u0120on", "\u0120stack", ".", "\u0120+", "\u0120client", "Data", "Type", "_(", "coll", "He", "ap", "()", "),", "\u0120//", "\u0120Get", "\u0120heap", "\u0120from", "\u0120N", "AB", "as", "ic", "Object", ".", "\u0120Can", "'t", "\u0120allocate", "\u0120on", "\u0120stack", ".", "\u0120+", "\u0120was", "H", "ive", "String", "_(", "F", "ALSE", ")", "\u0120{}", "\u0120#", "pr", "ag", "ma", "\u0120warn", "(", "150", "6", ")", "\u0120//", "\u0120warning", "\u0120elimination", "\u0120"], "docstring_tokens": ["I", "'m", "\u0120confused", "\u0120by", "\u0120the", "\u0120name", ".", "\u0120The", "\u0120string", "\u0120was", "\u0120a", "\u0120Hive", "\u0120string", "\u0120but", "\u0120it", "\u0120isn", "'t", "\u0120any", "\u0120longer", "?", "\u0120Why", "\u0120should", "\u0120we", "\u0120care", "?", "\u0120(", "I", "\u0120imagine", "\u0120I", "'ll", "\u0120find", "\u0120the", "\u0120answer", "\u0120later", "...", "\u0120there", "\u0120is", "\u0120some", "\u0120different", "\u0120semantic", "\u0120that", "\u0120we", "\u0120want", "\u0120downstream", "...)"]}
{"function": "@@ -31,12 +31,7 @@ import org.openqa.selenium.grid.sessionmap.SessionMap; import org.openqa.selenium.grid.sessionmap.local.LocalSessionMap; import org.openqa.selenium.netty.server.NettyServer; import org.openqa.selenium.remote.SessionId; -import org.openqa.selenium.remote.http.HttpClient; -import org.openqa.selenium.remote.http.HttpHandler; -import org.openqa.selenium.remote.http.HttpRequest; -import org.openqa.selenium.remote.http.HttpResponse; -import org.openqa.selenium.remote.http.TextMessage; -import org.openqa.selenium.remote.http.WebSocket; +import org.openqa.selenium.remote.http.*; import org.openqa.selenium.remote.tracing.DefaultTestTracer; import org.openqa.selenium.remote.tracing.Tracer; ", "text": "Could you please leave the explicit imports?", "function_tokens": ["@@", "\u0120-", "31", ",", "12", "\u0120+", "31", ",", "7", "\u0120@@", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "grid", ".", "session", "map", ".", "Session", "Map", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "grid", ".", "session", "map", ".", "local", ".", "Local", "Session", "Map", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "net", "ty", ".", "server", ".", "Net", "ty", "Server", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "Session", "Id", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Http", "Client", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Http", "Handler", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Http", "Request", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Http", "Response", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Text", "Message", ";", "\u0120-", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".", "Web", "Socket", ";", "\u0120+", "import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "http", ".*", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "tr", "acing", ".", "Default", "Test", "Tr", "acer", ";", "\u0120import", "\u0120org", ".", "open", "qa", ".", "sel", "enium", ".", "remote", ".", "tr", "acing", ".", "Tr", "acer", ";", "\u0120"], "docstring_tokens": ["Could", "\u0120you", "\u0120please", "\u0120leave", "\u0120the", "\u0120explicit", "\u0120imports", "?"]}
{"function": "@@ -23,7 +23,7 @@ import ( \"github.com/iotexproject/iotex-core/pkg/hash\" \"github.com/iotexproject/iotex-core/pkg/keypair\" \"github.com/iotexproject/iotex-core/pkg/log\" - \"github.com/iotexproject/iotex-core/proto\" + iproto \"github.com/iotexproject/iotex-core/proto\" \"github.com/iotexproject/iotex-core/state/factory\" ) ", "text": "Why need alias?", "function_tokens": ["@@", "\u0120-", "23", ",", "7", "\u0120+", "23", ",", "7", "\u0120@@", "\u0120import", "\u0120(", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "pkg", "/", "hash", "\"", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "pkg", "/", "key", "pair", "\"", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "pkg", "/", "log", "\"", "\u0120-", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "pro", "to", "\"", "\u0120+", "\u0120ip", "ro", "to", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "pro", "to", "\"", "\u0120\"", "github", ".", "com", "/", "iot", "ex", "project", "/", "iot", "ex", "-", "core", "/", "state", "/", "f", "actory", "\"", "\u0120)", "\u0120"], "docstring_tokens": ["Why", "\u0120need", "\u0120alias", "?"]}
{"function": "@@ -148,6 +148,10 @@ func (c testTLFJournalConfig) teamMembershipChecker() kbfsmd.TeamMembershipCheck return nil } +func (c testTLFJournalConfig) tlfIDGetter() tlfIDGetter { + return nil +} + func (c testTLFJournalConfig) diskLimitTimeout() time.Duration { return c.dlTimeout }", "text": "Shouldn't this be a `libfs.nullIDGetter` (exported, of course)?", "function_tokens": ["@@", "\u0120-", "148", ",", "6", "\u0120+", "148", ",", "10", "\u0120@@", "\u0120func", "\u0120(", "c", "\u0120test", "TL", "F", "Journal", "Config", ")", "\u0120team", "Members", "hip", "Check", "er", "()", "\u0120k", "bf", "sm", "d", ".", "Team", "Members", "hip", "Check", "\u0120return", "\u0120nil", "\u0120}", "\u0120+", "func", "\u0120(", "c", "\u0120test", "TL", "F", "Journal", "Config", ")", "\u0120t", "lf", "ID", "Get", "ter", "()", "\u0120t", "lf", "ID", "Get", "ter", "\u0120{", "\u0120+", "\u0120return", "\u0120nil", "\u0120+", "}", "\u0120+", "\u0120func", "\u0120(", "c", "\u0120test", "TL", "F", "Journal", "Config", ")", "\u0120disk", "Limit", "Timeout", "()", "\u0120time", ".", "Duration", "\u0120{", "\u0120return", "\u0120c", ".", "dl", "Timeout", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120this", "\u0120be", "\u0120a", "\u0120`", "lib", "fs", ".", "null", "ID", "Get", "ter", "`", "\u0120(", "ex", "ported", ",", "\u0120of", "\u0120course", ")?"]}
{"function": "@@ -156,6 +156,9 @@ const ( tealsignTooManyArg = \"--set-lsig-arg-idx too large, maximum of %d arguments\" tealsignInfoWroteSig = \"Wrote signature for %s to LSig.Args[%d]\" + tealLogicSigSize = \"%s: logicsig program size too large: %d > %d\" + tealAppSize = \"%s: app program size too large: %d > %d\" + // Wallet infoRecoveryPrompt = \"Please type your recovery mnemonic below, and hit return when you are done: \" infoChoosePasswordPrompt = \"Please choose a password for wallet '%s': \"", "text": "I dislike the messages.go pattern; the strings are only used once and make more sense in context. The other two added reportErrorf() calls in clerk.go have inline strings.", "function_tokens": ["@@", "\u0120-", "156", ",", "6", "\u0120+", "156", ",", "9", "\u0120@@", "\u0120const", "\u0120(", "\u0120te", "als", "ign", "Too", "Many", "Arg", "\u0120=", "\u0120\"", "--", "set", "-", "ls", "ig", "-", "arg", "-", "id", "x", "\u0120too", "\u0120large", ",", "\u0120maximum", "\u0120of", "\u0120%", "d", "\u0120arguments", "\"", "\u0120te", "als", "ign", "Info", "W", "rote", "S", "ig", "\u0120=", "\u0120\"", "W", "rote", "\u0120signature", "\u0120for", "\u0120%", "s", "\u0120to", "\u0120LS", "ig", ".", "Args", "[", "%", "d", "]\"", "\u0120+", "\u0120te", "al", "Log", "ic", "S", "ig", "Size", "\u0120=", "\u0120\"%", "s", ":", "\u0120log", "ics", "ig", "\u0120program", "\u0120size", "\u0120too", "\u0120large", ":", "\u0120%", "d", "\u0120>", "\u0120%", "d", "\"", "\u0120+", "\u0120te", "al", "App", "Size", "\u0120=", "\u0120\"%", "s", ":", "\u0120app", "\u0120program", "\u0120size", "\u0120too", "\u0120large", ":", "\u0120%", "d", "\u0120>", "\u0120%", "d", "\"", "\u0120+", "\u0120//", "\u0120Wallet", "\u0120info", "Rec", "overy", "Prom", "pt", "\u0120=", "\u0120\"", "Please", "\u0120type", "\u0120your", "\u0120recovery", "\u0120m", "n", "emonic", "\u0120below", ",", "\u0120and", "\u0120hit", "\u0120return", "\u0120when", "\u0120you", "\u0120are", "\u0120done", ":", "\u0120\"", "\u0120info", "Choose", "Password", "Prom", "pt", "\u0120=", "\u0120\"", "Please", "\u0120choose", "\u0120a", "\u0120password", "\u0120for", "\u0120wallet", "\u0120'", "%", "s", "':", "\u0120\""], "docstring_tokens": ["I", "\u0120dislike", "\u0120the", "\u0120messages", ".", "go", "\u0120pattern", ";", "\u0120the", "\u0120strings", "\u0120are", "\u0120only", "\u0120used", "\u0120once", "\u0120and", "\u0120make", "\u0120more", "\u0120sense", "\u0120in", "\u0120context", ".", "\u0120The", "\u0120other", "\u0120two", "\u0120added", "\u0120report", "Error", "f", "()", "\u0120calls", "\u0120in", "\u0120clerk", ".", "go", "\u0120have", "\u0120inline", "\u0120strings", "."]}
{"function": "@@ -118,9 +118,6 @@ Status FetchVerticesExecutor::prepareTags() { if (!tagIdStatus.ok()) { return tagIdStatus.status(); } - auto tagId = tagIdStatus.value(); - tagNames_.push_back(tagName); - tagIds_.push_back(tagId); auto result = tagNameSet_.emplace(tagName); if (!result.second) { return Status::Error(folly::sformat(\"tag({}) was dup\", tagName));", "text": "Seems we don't need it anymore.", "function_tokens": ["@@", "\u0120-", "118", ",", "9", "\u0120+", "118", ",", "6", "\u0120@@", "\u0120Status", "\u0120F", "etch", "Vert", "ices", "Exec", "utor", "::", "prep", "are", "Tags", "()", "\u0120{", "\u0120if", "\u0120(!", "tag", "Id", "Status", ".", "ok", "())", "\u0120{", "\u0120return", "\u0120tag", "Id", "Status", ".", "status", "();", "\u0120}", "\u0120-", "\u0120auto", "\u0120tag", "Id", "\u0120=", "\u0120tag", "Id", "Status", ".", "value", "();", "\u0120-", "\u0120tag", "Names", "_.", "push", "_", "back", "(", "tag", "Name", ");", "\u0120-", "\u0120tag", "Id", "s", "_.", "push", "_", "back", "(", "tag", "Id", ");", "\u0120auto", "\u0120result", "\u0120=", "\u0120tag", "Name", "Set", "_.", "em", "place", "(", "tag", "Name", ");", "\u0120if", "\u0120(!", "result", ".", "second", ")", "\u0120{", "\u0120return", "\u0120Status", "::", "Error", "(", "f", "olly", "::", "s", "format", "(\"", "tag", "({", "})", "\u0120was", "\u0120dup", "\",", "\u0120tag", "Name", "));"], "docstring_tokens": ["Se", "ems", "\u0120we", "\u0120don", "'t", "\u0120need", "\u0120it", "\u0120anymore", "."]}
{"function": "@@ -54,7 +54,7 @@ class Guidance < ActiveRecord::Base validates :published, inclusion: { message: INCLUSION_MESSAGE, in: BOOLEAN_VALUES} - validates :themes, presence: { message: PRESENCE_MESSAGE } + validates :themes, presence: { message: PRESENCE_MESSAGE }, if: :published? # Retrieves every guidance associated to an org scope :by_org, -> (org) {", "text": "This might cause problems with the weird way we publish Guidance and Groups in the UI. We will have to make sure that UAT is thorough.", "function_tokens": ["@@", "\u0120-", "54", ",", "7", "\u0120+", "54", ",", "7", "\u0120@@", "\u0120class", "\u0120Guid", "ance", "\u0120<", "\u0120Active", "Record", "::", "Base", "\u0120valid", "ates", "\u0120:", "published", ",", "\u0120inclusion", ":", "\u0120{", "\u0120message", ":", "\u0120IN", "CLUS", "ION", "_", "M", "ES", "SA", "GE", ",", "\u0120in", ":", "\u0120B", "OO", "LE", "AN", "_", "VAL", "UES", "}", "\u0120-", "\u0120valid", "ates", "\u0120:", "the", "mes", ",", "\u0120presence", ":", "\u0120{", "\u0120message", ":", "\u0120PRES", "ENCE", "_", "M", "ES", "SA", "GE", "\u0120}", "\u0120+", "\u0120valid", "ates", "\u0120:", "the", "mes", ",", "\u0120presence", ":", "\u0120{", "\u0120message", ":", "\u0120PRES", "ENCE", "_", "M", "ES", "SA", "GE", "\u0120},", "\u0120if", ":", "\u0120:", "published", "?", "\u0120#", "\u0120Ret", "rie", "ves", "\u0120every", "\u0120guidance", "\u0120associated", "\u0120to", "\u0120an", "\u0120org", "\u0120scope", "\u0120:", "by", "_", "org", ",", "\u0120->", "\u0120(", "org", ")", "\u0120{"], "docstring_tokens": ["This", "\u0120might", "\u0120cause", "\u0120problems", "\u0120with", "\u0120the", "\u0120weird", "\u0120way", "\u0120we", "\u0120publish", "\u0120Guid", "ance", "\u0120and", "\u0120Groups", "\u0120in", "\u0120the", "\u0120UI", ".", "\u0120We", "\u0120will", "\u0120have", "\u0120to", "\u0120make", "\u0120sure", "\u0120that", "\u0120U", "AT", "\u0120is", "\u0120thorough", "."]}
{"function": "@@ -75,7 +75,7 @@ func NewRawExporter(config Config) (*Exporter, error) { // defer pipeline.Stop() // ... Done func InstallNewPipeline(config Config) (*push.Controller, error) { - controller, err := NewExportPipeline(config) + controller, err := NewExportPipeline(config, time.Hour) if err != nil { return controller, err }", "text": "this default needs to be on order 1 minute, I'm not sure why we defaulted to 1 hour below...", "function_tokens": ["@@", "\u0120-", "75", ",", "7", "\u0120+", "75", ",", "7", "\u0120@@", "\u0120func", "\u0120New", "Raw", "Ex", "porter", "(", "config", "\u0120Config", ")", "\u0120(*", "Ex", "porter", ",", "\u0120error", ")", "\u0120{", "\u0120//", "\u0120defer", "\u0120pipeline", ".", "Stop", "()", "\u0120//", "\u0120...", "\u0120Done", "\u0120func", "\u0120Install", "New", "P", "ip", "eline", "(", "config", "\u0120Config", ")", "\u0120(*", "push", ".", "Controller", ",", "\u0120error", ")", "\u0120{", "\u0120-", "\u0120controller", ",", "\u0120err", "\u0120:=", "\u0120New", "Export", "P", "ip", "eline", "(", "config", ")", "\u0120+", "\u0120controller", ",", "\u0120err", "\u0120:=", "\u0120New", "Export", "P", "ip", "eline", "(", "config", ",", "\u0120time", ".", "Hour", ")", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120return", "\u0120controller", ",", "\u0120err", "\u0120}"], "docstring_tokens": ["this", "\u0120default", "\u0120needs", "\u0120to", "\u0120be", "\u0120on", "\u0120order", "\u01201", "\u0120minute", ",", "\u0120I", "'m", "\u0120not", "\u0120sure", "\u0120why", "\u0120we", "\u0120default", "ed", "\u0120to", "\u01201", "\u0120hour", "\u0120below", "..."]}
{"function": "@@ -92,6 +92,15 @@ func (ACMEIssuer) CaddyModule() caddy.ModuleInfo { func (iss *ACMEIssuer) Provision(ctx caddy.Context) error { iss.logger = ctx.Logger(iss) + // expand email address, if non-empty + if iss.Email != \"\" { + email, err := caddy.NewReplacer().ReplaceOrErr(iss.Email, true, true) + if err != nil { + return fmt.Errorf(\"expanding email address '%s': %v\", iss.Email, err) + } + iss.Email = email + } + // DNS providers if iss.Challenges != nil && iss.Challenges.DNS != nil && iss.Challenges.DNS.ProviderRaw != nil { val, err := ctx.LoadModule(iss.Challenges.DNS, \"ProviderRaw\")", "text": "I figure to make `{env.*}` work, right? I can't think of any other placeholder that makes sense here", "function_tokens": ["@@", "\u0120-", "92", ",", "6", "\u0120+", "92", ",", "15", "\u0120@@", "\u0120func", "\u0120(", "AC", "ME", "Iss", "uer", ")", "\u0120C", "addy", "Module", "()", "\u0120c", "addy", ".", "Module", "Info", "\u0120{", "\u0120func", "\u0120(", "iss", "\u0120*", "AC", "ME", "Iss", "uer", ")", "\u0120Provision", "(", "ctx", "\u0120c", "addy", ".", "Context", ")", "\u0120error", "\u0120{", "\u0120iss", ".", "log", "ger", "\u0120=", "\u0120c", "tx", ".", "Log", "ger", "(", "iss", ")", "\u0120+", "\u0120//", "\u0120expand", "\u0120email", "\u0120address", ",", "\u0120if", "\u0120non", "-", "empty", "\u0120+", "\u0120if", "\u0120iss", ".", "Email", "\u0120!=", "\u0120\"\"", "\u0120{", "\u0120+", "\u0120email", ",", "\u0120err", "\u0120:=", "\u0120c", "addy", ".", "New", "Repl", "acer", "().", "Re", "place", "Or", "Er", "r", "(", "iss", ".", "Email", ",", "\u0120true", ",", "\u0120true", ")", "\u0120+", "\u0120if", "\u0120err", "\u0120!=", "\u0120nil", "\u0120{", "\u0120+", "\u0120return", "\u0120fmt", ".", "Error", "f", "(\"", "exp", "anding", "\u0120email", "\u0120address", "\u0120'", "%", "s", "':", "\u0120%", "v", "\",", "\u0120iss", ".", "Email", ",", "\u0120err", ")", "\u0120+", "\u0120}", "\u0120+", "\u0120iss", ".", "Email", "\u0120=", "\u0120email", "\u0120+", "\u0120}", "\u0120+", "\u0120//", "\u0120DNS", "\u0120providers", "\u0120if", "\u0120iss", ".", "Chall", "enges", "\u0120!=", "\u0120nil", "\u0120&&", "\u0120iss", ".", "Chall", "enges", ".", "D", "NS", "\u0120!=", "\u0120nil", "\u0120&&", "\u0120iss", ".", "Chall", "enges", ".", "D", "NS", ".", "Provider", "Raw", "\u0120!=", "\u0120nil", "\u0120{", "\u0120val", ",", "\u0120err", "\u0120:=", "\u0120c", "tx", ".", "Load", "Module", "(", "iss", ".", "Chall", "enges", ".", "D", "NS", ",", "\u0120\"", "Provider", "Raw", "\")"], "docstring_tokens": ["I", "\u0120figure", "\u0120to", "\u0120make", "\u0120`", "{", "env", ".*", "}", "`", "\u0120work", ",", "\u0120right", "?", "\u0120I", "\u0120can", "'t", "\u0120think", "\u0120of", "\u0120any", "\u0120other", "\u0120placeholder", "\u0120that", "\u0120makes", "\u0120sense", "\u0120here"]}
{"function": "@@ -29,7 +29,9 @@ TestEnv::~TestEnv() { void TestEnv::SetUp() { FLAGS_load_data_interval_secs = 1; // Create metaServer - metaServer_ = nebula::meta::TestUtils::mockMetaServer(0, metaRootPath_.path()); + metaServer_ = nebula::meta::TestUtils::mockMetaServer( + network::NetworkUtils::getAvailablePort(), + metaRootPath_.path()); FLAGS_meta_server_addrs = folly::stringPrintf(\"127.0.0.1:%d\", metaServerPort()); // Create storageServer", "text": "Why change the port from 0 to getAvailablePort()?", "function_tokens": ["@@", "\u0120-", "29", ",", "7", "\u0120+", "29", ",", "9", "\u0120@@", "\u0120Test", "En", "v", "::", "~", "Test", "En", "v", "()", "\u0120{", "\u0120void", "\u0120Test", "En", "v", "::", "Set", "Up", "()", "\u0120{", "\u0120FL", "AG", "S", "_", "load", "_", "data", "_", "inter", "val", "_", "sec", "s", "\u0120=", "\u01201", ";", "\u0120//", "\u0120Create", "\u0120meta", "Server", "\u0120-", "\u0120meta", "Server", "_", "\u0120=", "\u0120neb", "ula", "::", "meta", "::", "Test", "Ut", "ils", "::", "m", "ock", "Meta", "Server", "(", "0", ",", "\u0120meta", "Root", "Path", "_.", "path", "());", "\u0120+", "\u0120meta", "Server", "_", "\u0120=", "\u0120neb", "ula", "::", "meta", "::", "Test", "Ut", "ils", "::", "m", "ock", "Meta", "Server", "(", "\u0120+", "\u0120network", "::", "Network", "Ut", "ils", "::", "get", "Available", "Port", "(),", "\u0120+", "\u0120meta", "Root", "Path", "_.", "path", "());", "\u0120FL", "AG", "S", "_", "meta", "_", "server", "_", "add", "rs", "\u0120=", "\u0120folly", "::", "string", "Print", "f", "(\"", "127", ".", "0", ".", "0", ".", "1", ":", "%", "d", "\",", "\u0120meta", "Server", "Port", "());", "\u0120//", "\u0120Create", "\u0120storage", "Server"], "docstring_tokens": ["Why", "\u0120change", "\u0120the", "\u0120port", "\u0120from", "\u01200", "\u0120to", "\u0120get", "Available", "Port", "()", "?"]}
{"function": "@@ -691,9 +691,9 @@ class TestSeleniumScriptGeneration(SeleniumTestCase): content = fds.read() target_lines = [ - \"var_loc_keys=self.loc_mng.get_locator([{'name':'btn1',}])self.driver.find_element\" + \"var_loc_keys=self.loc_mng.get_locator([{'name':'btn1',}],30.0)self.driver.find_element\" \"(var_loc_keys[0],var_loc_keys[1]).click()\", - \"var_loc_keys=self.loc_mng.get_locator([{'id':'Id_123',}])self.driver.find_element\" + \"var_loc_keys=self.loc_mng.get_locator([{'id':'Id_123',}],30.0)self.driver.find_element\" \"(var_loc_keys[0],var_loc_keys[1]).clear()\", \"self.driver.find_element(var_loc_keys[0],var_loc_keys[1]).send_keys('London')\" ]", "text": "For me would be great don't repeat timeout sending in every get_locator call. Looks like it should be sent into LocatorsManager init. And possibly it should me non mandatory, something like that: `def __init__ (self, locators, timeout=60):`", "function_tokens": ["@@", "\u0120-", "691", ",", "9", "\u0120+", "691", ",", "9", "\u0120@@", "\u0120class", "\u0120Test", "Sel", "enium", "Script", "Gener", "ation", "(", "Sel", "enium", "Test", "Case", "):", "\u0120content", "\u0120=", "\u0120f", "ds", ".", "read", "()", "\u0120target", "_", "lines", "\u0120=", "\u0120[", "\u0120-", "\u0120\"", "var", "_", "loc", "_", "keys", "=", "self", ".", "loc", "_", "m", "ng", ".", "get", "_", "loc", "ator", "([", "{", "'", "name", "':", "'", "btn", "1", "',", "}", "])", "self", ".", "driver", ".", "find", "_", "element", "\"", "\u0120+", "\u0120\"", "var", "_", "loc", "_", "keys", "=", "self", ".", "loc", "_", "m", "ng", ".", "get", "_", "loc", "ator", "([", "{", "'", "name", "':", "'", "btn", "1", "',", "}", "],", "30", ".", "0", ")", "self", ".", "driver", ".", "find", "_", "element", "\"", "\u0120\"(", "var", "_", "loc", "_", "keys", "[", "0", "],", "var", "_", "loc", "_", "keys", "[", "1", "]).", "click", "()", "\",", "\u0120-", "\u0120\"", "var", "_", "loc", "_", "keys", "=", "self", ".", "loc", "_", "m", "ng", ".", "get", "_", "loc", "ator", "([", "{", "'", "id", "':", "'", "Id", "_", "123", "',", "}", "])", "self", ".", "driver", ".", "find", "_", "element", "\"", "\u0120+", "\u0120\"", "var", "_", "loc", "_", "keys", "=", "self", ".", "loc", "_", "m", "ng", ".", "get", "_", "loc", "ator", "([", "{", "'", "id", "':", "'", "Id", "_", "123", "',", "}", "],", "30", ".", "0", ")", "self", ".", "driver", ".", "find", "_", "element", "\"", "\u0120\"(", "var", "_", "loc", "_", "keys", "[", "0", "],", "var", "_", "loc", "_", "keys", "[", "1", "]).", "clear", "()", "\",", "\u0120\"", "self", ".", "driver", ".", "find", "_", "element", "(", "var", "_", "loc", "_", "keys", "[", "0", "],", "var", "_", "loc", "_", "keys", "[", "1", "]).", "send", "_", "keys", "('", "London", "')", "\"", "\u0120]"], "docstring_tokens": ["For", "\u0120me", "\u0120would", "\u0120be", "\u0120great", "\u0120don", "'t", "\u0120repeat", "\u0120timeout", "\u0120sending", "\u0120in", "\u0120every", "\u0120get", "_", "loc", "ator", "\u0120call", ".", "\u0120Looks", "\u0120like", "\u0120it", "\u0120should", "\u0120be", "\u0120sent", "\u0120into", "\u0120Loc", "ators", "Manager", "\u0120init", ".", "\u0120And", "\u0120possibly", "\u0120it", "\u0120should", "\u0120me", "\u0120non", "\u0120mandatory", ",", "\u0120something", "\u0120like", "\u0120that", ":", "\u0120`", "def", "\u0120__", "init", "__", "\u0120(", "self", ",", "\u0120loc", "ators", ",", "\u0120timeout", "=", "60", "):", "`"]}
