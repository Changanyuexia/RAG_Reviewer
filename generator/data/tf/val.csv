code,review
public static int positionToDragCursor(int swtPositionConstant) { switch (swtPositionConstant) { case SWT.LEFT: return LEFT; case SWT.RIGHT: return RIGHT; case SWT.TOP: return TOP; case SWT.BOTTOM: return BOTTOM; case SWT.CENTER: return CENTER; } return INVALID; },and default ?
"public static boolean shouldCaptureIncrementalChanges(FileSystem fs,Path rootDir) throws StandardException{ boolean shouldRegister = false; try { boolean enabled = incrementalBackupEnabled(); if (enabled) { RecoverableZooKeeper zooKeeper = ZkUtils.getRecoverableZooKeeper(); String spliceBackupPath = BackupUtils.getBackupPath(); if (zooKeeper.exists(spliceBackupPath, false)==null){ return false; } boolean isRestoreMode = SIDriver.driver().lifecycleManager().isRestoreMode(); if (!isRestoreMode) { if (BackupUtils.existsDatabaseBackup(fs, rootDir)) { if (LOG.isDebugEnabled()) { SpliceLogUtils.debug(LOG, ""There exists a successful full or incremental backup in the system""); } shouldRegister = true; } else { List<String> backupJobs = zooKeeper.getChildren(spliceBackupPath, false); for (String backupId : backupJobs) { String path = spliceBackupPath + ""/"" + backupId; byte[] data = zooKeeper.getData(path, false, null); BackupJobStatus status = BackupJobStatus.parseFrom(data); if (status.getScope() == BackupJobStatus.BackupScope.DATABASE.DATABASE) { if (LOG.isDebugEnabled()) { SpliceLogUtils.debug(LOG, ""A database backup is running""); } shouldRegister = true; } } } } } return shouldRegister; } catch (Exception e) { e.printStackTrace(); throw StandardException.plainWrapException(e); } }","Please remove the extra DATABASE in ""BackupJobStatus.BackupScope.DATABASE.DATABASE"""
"public synchronized void onCompleted(AbstractBuild r, TaskListener listener) { GerritCause cause = getCause(r); logger.info(""Completed. Build: {} Cause: {}"", r, cause); if (cause != null) { cleanUpGerritCauses(cause, r); PatchsetCreated event = cause.getEvent(); if (GerritTrigger.getTrigger(r.getProject()) != null) { GerritTrigger.getTrigger(r.getProject()).notifyBuildEnded(event); } event.fireBuildCompleted(r); if (!cause.isSilentMode()) { PatchSetKey key = memory.completed(event, r); if (r.getResult() != Result.SUCCESS) { try { String failureMessage = this.obtainFailureMessage(event, r, listener); memory.setEntryFailureMessage(key, r, failureMessage); } catch (IOException e) { e.printStackTrace(listener.getLogger()); } catch (InterruptedException e) { e.printStackTrace(listener.getLogger()); } } updateTriggerContexts(r, key); if (memory.isAllBuildsCompleted(key)) { try { logger.info(""All Builds are completed for cause: {}"", cause); event.fireAllBuildsCompleted(); NotificationFactory.getInstance().queueBuildCompleted(memory.getMemoryImprint(key), listener); } finally { memory.forget(key); } } else { logger.info(""Waiting for more builds to complete for cause [{}]. Status: \n{}"", cause, memory.getStatusReport(key)); } } } }",I would prefer a more comprehensive message to the user looking at the build log. And then the stacktrace to the logger that the admin is looking at (naming the build since that context is lost there).
"public void testVerifyByteArrayByteArray() { for(int i = 0; i < types.length; i++){ Hash hash = new Hash(types[i]); boolean verified = hash.verify(Hex.decode(trueHashes[i]), helloWorld); assertTrue(""HashType: ""+types[i].name(), verified); } }",Some places have this separate boolean to assert on and others put the entire condition in the assert statement. It seems preferable to use one consistently. Which one?
"protected void pullImage(CheServiceImpl service, String machineImageName, ProgressMonitor progressMonitor) throws MachineException { DockerMachineSource dockerMachineSource = new DockerMachineSource( new MachineSourceImpl(""image"").setLocation(service.getImage())); if (dockerMachineSource.getRepository() == null) { throw new MachineException( format(""Machine creation failed. Machine source is invalid. No repository is defined. Found '%s'."", dockerMachineSource)); } try { boolean isSnapshot = SNAPSHOT_LOCATION_PATTERN.matcher(dockerMachineSource.getLocation()).matches(); boolean isImageExistLocally = isDockerImageExistLocally(dockerMachineSource.getRepository()); if (!isSnapshot && (doForcePullImage || !isImageExistLocally) || isSnapshot && snapshotUseRegistry) { PullParams pullParams = PullParams.create(dockerMachineSource.getRepository()) .withTag(MoreObjects.firstNonNull(dockerMachineSource.getTag(), LATEST_TAG)) .withRegistry(dockerMachineSource.getRegistry()) .withAuthConfigs(dockerCredentials.getCredentials()); docker.pull(pullParams, progressMonitor); } String fullNameOfPulledImage = dockerMachineSource.getLocation(false); try { docker.tag(TagParams.create(fullNameOfPulledImage, machineImageName)); } catch (ImageNotFoundException nfEx) { throw new SourceNotFoundException(nfEx.getLocalizedMessage(), nfEx); } if (isSnapshot && snapshotUseRegistry) { docker.removeImage(RemoveImageParams.create(fullNameOfPulledImage).withForce(false)); } } catch (IOException e) { throw new MachineException(""Can't create machine from image. Cause: "" + e.getLocalizedMessage(), e); } }","In my opinion, this code would be more clear if operands wouldn't rely on remembering operations priority. E.g. next equivalent code looks clearer for me:  (!isSnapshot && (doForcePullImage || !isImageExistLocally) || isSnapshot && snapshotUseRegistry)"
"public boolean advance() { if (state.get() != State.RUNNING) { return false; } URI nextUri = currentStatusInfo().getNextUri(); if (nextUri == null) { state.compareAndSet(State.RUNNING, State.FINISHED); return false; } Request request = prepareRequest(HttpUrl.get(nextUri)).build(); Exception cause = null; long start = System.nanoTime(); long attempts = 0; while (true) { if (attempts > 0) { try { MILLISECONDS.sleep(attempts * 100); } catch (InterruptedException e) { try { close(); } finally { Thread.currentThread().interrupt(); } state.compareAndSet(State.RUNNING, State.COMMUNICATION_FAILURE); throw new RuntimeException(""StatementClient thread was interrupted""); } } attempts++; JsonResponse<QueryResults> response; try { response = JsonResponse.execute(QUERY_RESULTS_CODEC, httpClient, request); } catch (RuntimeException e) { cause = e; continue; } if ((response.getStatusCode() == HTTP_OK) && response.hasValue()) { processResponse(response.getHeaders(), response.getValue()); return true; } if (response.getStatusCode() != HTTP_UNAVAILABLE) { state.compareAndSet(State.RUNNING, State.COMMUNICATION_FAILURE); throw requestFailedException(""fetching next"", request, response); } if (System.nanoTime() - start >= requestTimeoutNanos) { state.compareAndSet(State.RUNNING, State.COMMUNICATION_FAILURE); throw new RuntimeException(""Time out fetching next"", cause); } if (isAborted()) { return false; } } }",Maybe switch requestTimeoutNanos to Duration and use nanosSince() with compareTo()
"public void visitNode(Tree tree) { if (hasSemantic()) { MethodTree methodTree = (MethodTree) tree; if (methodTree.block() != null && ""equals"".equals(methodTree.symbol().name()) && methodTree.parameters().size() == 1) { Symbol parameterSymbol = methodTree.parameters().get(0).symbol(); if (parameterSymbol.type().is(""java.lang.Object"")) { typeChecked = false; methodTree.accept(new EqualsMethodVisitor(parameterSymbol)); if (!typeChecked) { addIssue(tree, ""Add a type test to this method.""); } } } } }","To make the code a bit more readable and to avoid having 4 (or more) nested ifs, I preferably use at start of the method: <pre> if (!hasSemantic()) { return; }</pre>"
"protected void finishFeature() { final SWTBotTree projectExplorerTree = TestUtil.getExplorerTree(); getProjectItem(projectExplorerTree, PROJ1).select(); final String[] menuPath = new String[] { util.getPluginLocalizedValue(""TeamMenu.label""), util.getPluginLocalizedValue(""TeamGitFlowMenu.name"", false, Activator.getDefault().getBundle()), util.getPluginLocalizedValue(""TeamGitFlowFeatureFinish.name"", false, Activator.getDefault().getBundle()) }; ContextMenuHelper.clickContextMenu(projectExplorerTree, menuPath); bot.waitUntil(shellIsActive(UIText.FinishFeatureDialog_title)); selectOptions(); bot.checkBox(UIText.FinishFeatureDialog_saveAsDefault).click(); bot.button(""Finish"").click(); preFinish(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); }",use the constant like in the other tests ? then changing the corresponding property value doesn't break tests
"public void setUp() { spyMap = spy(newConcurrentMap()); registry = DefaultStateRegistry.getInstance(); try { final Field defaultStates = registry.getClass() .getDeclaredField(DEFAULT_STATES_FIELD_NAME); defaultStates.setAccessible(true); defaultStates.set(registry, spyMap); } catch (NoSuchFieldException | IllegalAccessException ignored) { } }","I suppose that in this case we should fail the test, not just ignore the exception."
"protected AwardAccount createDefaultAwardAccount(RassXmlAwardEntry xmlAward) { Map<String, String> defaultAwardAccountAttributes = getDefaultAwardAccountAttributes(); String directorPrincipalId = parameterService.getParameterValueAsString(RassStep.class, RassParameterConstants.DEFAULT_PROJECT_DIRECTOR); if (StringUtils.isBlank(directorPrincipalId)) { throw new RuntimeException(""Default project director parameter cannot be blank""); } AwardAccount awardAccount = new AwardAccount(); awardAccount.setProposalNumber(xmlAward.getProposalNumber()); awardAccount.setPrincipalId(directorPrincipalId); awardAccount.setChartOfAccountsCode(defaultAwardAccountAttributes.get(KFSPropertyConstants.CHART)); awardAccount.setAccountNumber(defaultAwardAccountAttributes.get(KFSPropertyConstants.ACCOUNT_NUMBER)); awardAccount.setActive(defaultAccountIndicatorIsActive(KFSPropertyConstants.ACCOUNT_ACTIVE_INDICATOR)); return awardAccount; }","This call to the indicator-is-active method is passing in the property key itself. I think it should instead be passing in the value that is associated with the key, given that the method treats its argument as being the value and not the key."
"public void testGetCompletionTimesFragmentCausedBy() throws Exception { String suffix=""3cb2""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis()); Consumer c1 = new Consumer(); c1.setUri(""uri1""); c1.getProperties().add(new Property(""prop1"",""value1"")); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(System.currentTimeMillis()); Consumer c2 = new Consumer(); c2.setUri(""uri2""); c2.getProperties().add(new Property(""prop1"",""value1"")); c2.getProperties().add(new Property(""prop2"",""value2"")); c2.addCausedByCorrelationId(trace1.getId()+"":0:0""); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(System.currentTimeMillis()); Consumer c3 = new Consumer(); c3.setUri(""uri3""); c3.getProperties().add(new Property(""prop3"",""value3"")); c3.addCausedByCorrelationId(trace1.getId()+"":0:0""); trace3.getNodes().add(c3); Component comp3 = new Component(); comp3.setUri(""comp3""); c3.getNodes().add(comp3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(3, times.get(0).getProperties().size()); }",It would be good to test concrete completion time not just properties and size.
"protected String[] getListOfPackageJsonFiles(String baseDir, String filename) { DirectoryScanner scanner = new DirectoryScanner(); scanner.setIncludes(new String[] {""**/*"" + filename}); scanner.setExcludes(EXCLUDED_DIRECTORIES); scanner.setBasedir(baseDir); scanner.scan(); return scanner.getIncludedFiles(); }",Do we actually need this dependency? I think a directory stream included with Java would work here too and could could return a nice collection instead of an array. <LINK_1> or <LINK_0>
"public void handle(@Nonnull CorfuPayloadMsg<OrchestratorMsg> msg, @Nonnull ChannelHandlerContext ctx, @Nonnull IServerRouter r) { OrchestratorMsg orchReq = msg.getPayload(); IWorkflow workflow; switch (orchReq.getRequest().getType()) { case QUERY: query(msg, ctx, r); break; case ADD_NODE: workflow = new AddNodeWorkflow((AddNodeRequest) orchReq.getRequest()); dispatch(workflow, msg, ctx, r); break; case REMOVE_NODE: workflow = new RemoveNodeWorkflow((RemoveNodeRequest) orchReq.getRequest()); dispatch(workflow, msg, ctx, r); break; case HEAL_NODE: workflow = new HealNodeWorkflow((HealNodeRequest) orchReq.getRequest()); dispatch(workflow, msg, ctx, r); break; case FORCE_REMOVE_NODE: workflow = new ForceRemoveWorkflow((ForceRemoveNodeRequest) orchReq.getRequest()); dispatch(workflow, msg, ctx, r); break; case MERGE_SEGMENTS: workflow = new MergeSegmentsWorkflow((MergeSegmentsRequest) orchReq.getRequest()); dispatch(workflow, msg, ctx, r); break; default: log.error(""handle: Unknown request type {}"", orchReq.getRequest().getType()); } }",again is this more like a replicate_merge_segments?
"void inject(@ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) { for (int i = 0; i < sharedLocks.length; i++) { sharedLocks[i] = new InfinispanLock(nonBlockingExecutor, timeService); } }","I'm starting to think figuring out why a lock isn't unlocked after a BasicComponentRegistry.rewire() is too hard, and tests almost never replace executors anyway, so the master version of the method is safer."
"public void onPartitionBecomeInactiveFromStandby(String partitionName) { PartitionStateChangeListener storageManagerListener = partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener); if (storageManagerListener != null) { try { storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName); } catch (Exception e) { participantMetrics.standbyCount.addAndGet(-1); participantMetrics.errorStateCount.addAndGet(1); throw e; } } PartitionStateChangeListener replicationManagerListener = partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener); if (replicationManagerListener != null) { try { replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName); replicaSyncUpManager.waitDeactivationCompleted(partitionName); } catch (InterruptedException e) { logger.error(""Deactivation was interrupted on partition {}"", partitionName); participantMetrics.standbyCount.addAndGet(-1); participantMetrics.errorStateCount.addAndGet(1); throw new StateTransitionException(""Deactivation failed or was interrupted"", DeactivationFailure); } catch (StateTransitionException e) { logger.error(""Deactivation didn't complete on partition {}"", partitionName, e); participantMetrics.standbyCount.addAndGet(-1); participantMetrics.errorStateCount.addAndGet(1); throw e; } } participantMetrics.standbyCount.addAndGet(-1); participantMetrics.inactiveCount.addAndGet(1); }",see above about finally.
"public Seq<Binding<?>> bindings(final Environment environment, final play.api.Configuration configuration) { return seq( bind(CountryCode.class).qualifiedWith(""default"").toInstance(defaultCountry(configuration)), bind(PlayJavaSphereClient.class).toProvider(PlayJavaSphereClientProvider.class).in(Singleton.class), bind(CategoryTree.class).toProvider(CategoryTreeProvider.class), bind(TemplateService.class).toProvider(TemplateServiceProvider.class), bind(CmsService.class).toProvider(CmsServiceProvider.class) ); }","I think Providers are cool but there is the danger that you expect a singleton where it isn't. (at-Singleton on the provider reuses only the provider). Suppose you have multiple controllers, should everyone have its own copy of a CategoryTree, TemplateService and CmsService or should they share one instance? bind(Hello.class).toProvider(HelloProvider.class).in(Singleton.class) //make singleton even if class have not the annotation"
"public void updateEntriesOnSend(S38PacketPlayerListItem packet) { for (S38PacketPlayerListItem.AddPlayerData data : packet.players) { if (packet.action == S38PacketPlayerListItem.Action.ADD_PLAYER) { this.addEntry(data); } else if (packet.action == S38PacketPlayerListItem.Action.REMOVE_PLAYER) { this.removeEntry(data.getProfile().getId()); } else if (packet.action == S38PacketPlayerListItem.Action.UPDATE_GAME_MODE || packet.action == S38PacketPlayerListItem.Action.UPDATE_LATENCY || packet.action == S38PacketPlayerListItem.Action.UPDATE_DISPLAY_NAME) { this.getEntry(data.getProfile().getId()).ifPresent(entry -> { if (packet.action == S38PacketPlayerListItem.Action.UPDATE_DISPLAY_NAME) { ((SpongeTabListEntry) entry).updateWithoutSend(); entry.setDisplayName(data.getDisplayName() == null ? null : SpongeTexts.toText(data.getDisplayName())); } else if (packet.action == S38PacketPlayerListItem.Action.UPDATE_LATENCY) { ((SpongeTabListEntry) entry).updateWithoutSend(); entry.setLatency(data.getPing()); } else if (packet.action == S38PacketPlayerListItem.Action.UPDATE_GAME_MODE) { ((SpongeTabListEntry) entry).updateWithoutSend(); entry.setGameMode((GameMode) (Object) data.getGameMode()); } }); } else { throw new IllegalArgumentException(""unknown packet action: "" + packet.action); } } }","You shouldn't need this, since these are the only other options."
"protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { setReturnValue(new ArrayList<>()); return; } setReturnValue(filterDisks(diskList)); }","Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty"
public OfferAutoscaleSettings getOfferAutoscaleProperties() { return this.offer.getOfferAutoScaleSettings(); },How about inling the auto-scale related entries? What;s the value of nesting type?
"public ITmfStateInterval doSingularQuery(long t, int attributeQuark) throws TimeRangeException, StateSystemDisposedException { ITmfStateInterval ret = super.doSingularQuery(t, attributeQuark); if (ret != null) { return ret; } synchronized (intervalQueue) { if (fCurrentInterval.getAttribute() == attributeQuark && fCurrentInterval.intersects(t)) { return fCurrentInterval; } for (ITmfStateInterval interval : intervalQueue) { if (interval.getAttribute() == attributeQuark && interval.intersects(t)) { return interval; } } } return super.doSingularQuery(t, attributeQuark); }","Since fCurrentInterval is chronologically ""after"" the interval queue, I would add this check right after the for loop below instead."
"public GuestMigration buildMigrationManifest(ConsumerDTO incoming, Consumer existing) { if (incoming.getGuestIds() == null) { log.debug(""Guests not included in this consumer update, skipping update.""); migrationPending = false; return this; } Consumer incomingConsumerEntity = new Consumer(); List<GuestId> guestIds = new ArrayList<>(); for (GuestIdDTO dto : incoming.getGuestIds()) { GuestId entity = new GuestId(); GuestIdResource.populateEntity(entity, dto); guestIds.add(entity); } incomingConsumerEntity.setGuestIds(guestIds); return this.buildMigrationManifest(incomingConsumerEntity, existing); }",There is almost as much work done here just to convert the consumer as there would be if the DTO were used directly. This is the type of thing we want to avoid.
"public void run() { while (!_shutdownRequested) { try { Thread.sleep(_periodMs); } catch (InterruptedException e) { break; } flushAndMakeCheckpoints(); } LOG.info(String.format(""Checkpoint handler exited, tasks = [%s]."", _taskDesc)); }",Log an error ?
"public @ResponseBody CertifiedProductSearchDetails getCertifiedProductByChplProductNumberBasic2( @PathVariable(""chplPrefix"") final String chplPrefix, @PathVariable(""identifier"") final String identifier) throws EntityRetrievalException { String chplProductNumber = chplProductNumberUtil.getChplProductNumber(chplPrefix, identifier); CertifiedProductSearchDetails certifiedProduct = cpdManager.getCertifiedProductDetailsBasicByChplProductNumber(chplProductNumber); certifiedProduct = validateCertifiedProduct(certifiedProduct); removeNonBasicCertifiedProductSearchDetails(certifiedProduct); return certifiedProduct; }","If we're still returning the same type of object, won't it still have the keys that we want removed?"
"public ResponseEntity<ResourceSupport> postAdminGroup(@PathVariable UUID uuid, HttpServletResponse response, HttpServletRequest request) throws SQLException, AuthorizeException { Context context = ContextUtil.obtainContext(request); Community community = communityService.find(context, uuid); if (community == null) { throw new ResourceNotFoundException(""No such community: "" + uuid); } if (!authorizeService.isAdmin(context) && !authorizeService.authorizeActionBoolean(context, community, Constants.ADMIN, true)) { throw new AccessDeniedException(""The current user was not allowed to retrieve the AdminGroup for"" + "" community: "" + uuid); } if (community.getAdministrators() != null) { throw new UnprocessableEntityException(""The community with UUID: "" + uuid + "" already has "" + ""an admin group""); } GroupRest adminGroup = communityRestRepository.createAdminGroup(context, request, community); context.complete(); GroupResource groupResource = converterService.toResource(adminGroup); return ControllerUtils.toResponseEntity(HttpStatus.CREATED, new HttpHeaders(), groupResource); }","org.dspace.app.util.AuthorizeUtil.authorizeManageAdminGroup(Context, Community) should be used here"
"public ByteBuf processFrame(ByteBuf inputBuffer) throws TException, IOException { byte[] encodedBytes = new byte[inputBuffer.readableBytes()]; inputBuffer.readBytes(encodedBytes); byte[] inputBytes = Base64.decodeBase64(encodedBytes); if (inputBytes.length < 4) { throw new IOException(""Invalid request size "" + inputBytes.length); } ByteBuffer buff = ByteBuffer.wrap(inputBytes); int sz = buff.getInt(); if (sz != buff.remaining()) { throw new IOException( String.format(""Mismatch between expected frame size (%d) and actual size (%d)"", sz, inputBytes.length - 4) ); } byte[] inputFrame = Arrays.copyOfRange(inputBytes, 4, inputBytes.length); TTransport inTransport = new TMemoryInputTransport(inputFrame); TMemoryOutputBuffer outTransport = new TMemoryOutputBuffer(); processor.process(inProtocolFactory.getProtocol(inTransport), outProtocolFactory.getProtocol(outTransport)); byte[] outputBytes = Base64.encodeBase64(outTransport.getWriteBytes()); return Unpooled.copiedBuffer(outputBytes); }",I think we could get rid of the previous len < 4check and simply catch BufferUnderflowException thrown by [getInt](<LINK_0> on line 186.
public FeatureScenario(){ super(); },not needed
"public long getLowWatermark() { Map<String, Long> watermarks = new HashMap<>(pools.size()); Set<String> roots = topology.getRoots(); Map<String, Long> watermarkTrees = new HashMap<>(roots.size()); pools.forEach(pool -> watermarks.put(pool.getComputationName(), pool.getLowWatermark())); for (String root : roots) { watermarkTrees.put(root, topology.getDescendantComputationNames(root).stream().map(watermarks::get) .min(Comparator.naturalOrder()).orElse(0L)); } long ret = watermarkTrees.values().stream() .filter(wm -> wm > 1).min(Comparator.naturalOrder()).orElse(0L); if (log.isTraceEnabled()) { log.trace(""lowWatermark: "" + ret); watermarkTrees.forEach((k, v) -> log.trace(""tree "" + k + "": "" + v)); } return ret; }",Switch to LongStream as soon as possible: watermarkTrees.values().stream().mapToLong(Long::longValue).filter(wm -> wm > 1).min().orElse(0) And shouldn't this be wm > 0?
"private void printGroupRecord(ExtMap extMap) { if (extMap != null) { logger.info(String.format(""GroupRecord: ID %s, name: %s, Display name: %s"", extMap.get(Authz.GroupRecord.ID, """"), extMap.get(Authz.GroupRecord.NAME, """"), extMap.get(Authz.GroupRecord.DISPLAY_NAME, """") )); } }",missing NAMESPACE
"public static boolean deleteDir(File dir) { if (dir.isDirectory()) { String[] children = dir.list(); for (int i = 0; i < children.length; i++) { boolean success = deleteDir(new File(dir, children[i])); if (!success) { return false; } } } return dir.delete(); }","This causes a failure where some children are deleted but others are not, so it's not clear how a caller would recover. Could we instead have this return void and throw an IOException that includes the failed path?"
"private List<EmailWrapper> getEmailsToInstructor(InstructorAttributes instructor, List<EmailWrapper> emailsSent) { List<EmailWrapper> emailsToInstructor = new ArrayList<EmailWrapper>(); for (EmailWrapper email : emailsSent) { boolean emailSentToThisInstructor = email.getFirstRecipient().equalsIgnoreCase(instructor.email); if (emailSentToThisInstructor) { emailsToInstructor.add(email); } } return emailsToInstructor; }","Likewise for this, we get to rename this variable to prefix it with is"
"private void dropItem(CommandSender sender, String world, String x, String y, String z, SlimefunItem sfItem, String[] args) { if (sfItem instanceof MultiBlockMachine) { SlimefunPlugin.getLocalization().sendMessage(sender, ""guide.cheat.no-multiblocks""); } else { int amount = parseAmount(args); if (amount > 0) { Bukkit.getWorld(world).dropItem(new Location(Bukkit.getWorld(world), Integer.parseInt(x), Integer.parseInt(y), Integer.parseInt(z)), new CustomItem(sfItem.getItem(), amount)); SlimefunPlugin.getLocalization().sendMessage(sender, ""messages.drop-item"", true, msg -> msg.replace(PLACEHOLDER_WORLD, args[1]).replace(PLACEHOLDER_X, args[2]).replace(PLACEHOLDER_Y, args[3]).replace(PLACEHOLDER_Z, args[4]).replace(PLACEHOLDER_ITEM, sfItem.getItemName()).replace(PLACEHOLDER_AMOUNT, String.valueOf(amount))); } else { SlimefunPlugin.getLocalization().sendMessage(sender, ""messages.not-valid-amount"", true, msg -> msg.replace(PLACEHOLDER_AMOUNT, args[3])); } } }","suggestion SlimefunPlugin.getLocalization().sendMessage(sender, ""messages.invalid-amount"", true, msg -> msg.replace(PLACEHOLDER_AMOUNT, args[3]));"
"public boolean pollSocketsInfo() { if (!isTcpInfoSupported()) return false; boolean result = false; FileDescriptor fd = null; try { long time = SystemClock.elapsedRealtime(); fd = connectToKernel(); mTcpStats.clear(); for (int family : ADDRESS_FAMILIES) { if (!sendPollingRequest(fd, family)) continue; StructNlMsgHdr nlmsghdr = new StructNlMsgHdr(); do { final ByteBuffer bytes = recvMesssage(fd); log(""pollSocketsInfo: recv size="" + bytes.limit()); int curPos = 0; while (isValidNlMsg(bytes)) { nlmsghdr = StructNlMsgHdr.parse(bytes); final int nlmsgLen = nlmsghdr.nlmsg_len; log(""pollSocketsInfo: nlmsgLen="" + nlmsgLen); if (isValidInetDiagMsgSize(nlmsgLen)) { final int cookiePos = curPos + SOCKDIAG_MSG_HEADER_SIZE - 2 * Integer.BYTES; final long cookie = getSocketCookie(bytes, cookiePos); bytes.position(cookiePos + 2 * Integer.BYTES); final SocketInfo info = parseSockInfo(bytes, curPos, family, nlmsgLen, time); mTcpStats.put(cookie, makeTcpStat(info, mSocketInfos.get(cookie))); storeSocketInfo(cookie, info); } bytes.position(curPos + nlmsgLen); curPos = bytes.position(); } } while (nlmsghdr.nlmsg_type != NLMSG_DONE); } cleanupSocketInfo(time); result = true; } catch (ErrnoException | SocketException | InterruptedIOException e) { Log.e(TAG, ""Fail to get TCP info via netlink."", e); } finally { NetworkStackUtils.closeSocketQuietly(fd); } return result; }",Not accessed out of the try{} block : move declaration inside and make final.
"public HostAssert host(String hostAddress) { int port = actual.getConfiguration().getProtocolOptions().getPort(); InetSocketAddress socketAddress = new InetSocketAddress(hostAddress, port); Host host = actual.getMetadata().getHost(socketAddress); return new HostAssert(host, actual); }","Couldn't this be refactored into a new method TestUtils.findHost(Cluster, String) so that TestUtils.findHost(Cluster, int) could call it? Also, the same caveat probably applies here: we cannot make assertions on a host that hasn't joined the cluster yet or that has left it."
"public List<Index> listIndices() { InputStream response = null; try { URI uri = new DatabaseURIHelper(db.getDBUri()).path(""_index/"").build(); response = client.couchDbClient.get(uri); return getResponseList(response, client.getGson(), new TypeToken<List<Index>>() { }.getType()); } finally { close(response); } }","Remove trailing ""/""?"
"public ResourceGroupConfigurationManager create(Map<String, String> config, ResourceGroupConfigurationManagerContext context) { try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) { Bootstrap app = new Bootstrap( new JsonModule(), new DbResourceGroupsModule(), binder -> binder.bind(ResourceGroupConfigurationManagerContext.class).toInstance(context), binder -> binder.bind(ClusterMemoryPoolManager.class).toInstance(context.getMemoryPoolManager())); Injector injector = app .strictConfig() .doNotInitializeLogging() .setRequiredConfigurationProperties(config) .initialize(); return injector.getInstance(DbResourceGroupConfigurationManager.class); } catch (Exception e) { throw Throwables.propagate(e); } }",The reason to use the annotation is to avoid binding the configuration context. Bind the string directly like this: java binder.bind(String.class).annotatedWith(ForEnvironment.class).toInstance(context.getEnvironment())  Then you can remove the provides method
"public void setUp() throws IOException { MockitoAnnotations.initMocks(this); downloadDir = temp.newFolder(); when(updateCenterMatrixFactory.getUpdateCenter(anyBoolean())).thenReturn(Optional.of(updateCenter)); when(fs.getDownloadedEditionPluginsDir()).thenReturn(downloadDir); downloader = new EditionPluginDownloader(updateCenterMatrixFactory, httpDownloader, fs); }",long time since I've seen usage of MockitoAnnotations. I'd say it's not the trend in SQ's code. I personally think it's useless compared to just writing mock(Foo.class) and not using MockitoAnnotation saves from writing a setup method when there is no other need for it (not the case here)
"public TmfRawEventViewer(Composite parent, int style) { super(parent, style & (~SWT.H_SCROLL) & (~SWT.V_SCROLL)); GridLayout gridLayout = new GridLayout(); gridLayout.numColumns = 2; gridLayout.horizontalSpacing = 0; gridLayout.verticalSpacing = 0; gridLayout.marginWidth = 0; gridLayout.marginHeight = 0; setLayout(gridLayout); createTextArea(style & SWT.H_SCROLL); createSlider(style & SWT.V_SCROLL); setTabList(new Control[] { fScrolledComposite }); addDisposeListener(new DisposeListener() { @Override public void widgetDisposed(DisposeEvent e) { if (fBottomContext != null) { fBottomContext.dispose(); } PlatformUI.getWorkbench().getThemeManager().removePropertyChangeListener(TmfRawEventViewer.this); } }); }",lambda?
"public boolean matches(Map<String, Construct> prefilter, BindableEvent e) throws PrefilterNonMatchException { if(e instanceof MCEntityTargetEvent){ MCEntityTargetEvent ple = (MCEntityTargetEvent) e; if (ple.getTarget() instanceof Player) { return true; } } return false; }","Nope, this won't work, you need to also check to see if the player's name is the same, not just if it's an instance of a player."
"public void setup() throws Exception { super.setup(); KubernetesTestUtils.createTemporyFile(""some data"", flinkConfDir, ""logback.xml""); KubernetesTestUtils.createTemporyFile(""some data"", flinkConfDir, ""log4j.properties""); flinkConfig.set(KubernetesConfigOptionsInternal.ENTRY_POINT_CLASS, ENTRY_POINT_CLASS); flinkConfig.set(KubernetesConfigOptions.JOB_MANAGER_SERVICE_ACCOUNT, SERVICE_ACCOUNT_NAME); setHadoopConfDirEnv(); generateHadoopConfFileItems(); this.kubernetesJobManagerSpecification = KubernetesJobManagerFactory.createJobManagerComponent(kubernetesJobManagerParameters); }",We might possibly have a subclass of this test class so that don't pollute global settings. Also it seems we don't test existing hadoop conf case and empty local hadoop conf case.
"private Visualization getVisualizationInternal(String identifier) { return visualizationCache.computeIfAbsent(identifier, (s) -> { StepEngineSettings.VisualizationSetting settings = visualizationSettingsMap.get(s); String visualizationClassName = settings.getVisualizationClassName(); return StreamSupport.stream(ServiceLoader.load(Visualization.Factory.class).spliterator(), false) .filter(factory -> visualizationClassName.equals(factory.getVisualizationClass().getName())) .findFirst().orElseThrow(() -> new RuntimeException(""Failed: No Visualization.Factory found for "" + s + "" and "" + visualizationClassName) ).create(settings); }); }","unnecessary braces suggestion return visualizationCache.computeIfAbsent(identifier, s -> {"
"public Task<String> ensurePathExists(String path) { return exists(path).flatMap(stat -> { if (!stat.isPresent()) { Task<String> createAndIgnoreNodeExistsException = create(path, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT) .recoverWith(""recover from NodeExistsException"", e -> { if (e instanceof KeeperException.NodeExistsException) { return Task.value(path); } else { return Task.failure(e); } }); String parent = path.substring(0, path.lastIndexOf('/')); if (parent.isEmpty()) { return createAndIgnoreNodeExistsException; } else { return ensurePathExists(parent).flatMap(unused -> createAndIgnoreNodeExistsException); } } else { return Task.value(path); } }); }",createIfAbsent?
"public static void initInternal(Context context) { SalesforceSDKUpgradeManager.getInstance().upgrade(); Encryptor.init(context); HttpAccess.init(context, INSTANCE.getUserAgent()); final RuntimeConfig runtimeConfig = RuntimeConfig.getRuntimeConfig(context); final String idpAppUrlScheme = runtimeConfig.getString(RuntimeConfig.ConfigKey.IDPAppURLScheme); if (!TextUtils.isEmpty(idpAppUrlScheme)) { INSTANCE.idpAppURIScheme = idpAppUrlScheme; } (new Thread(new Runnable() { @Override public void run() { final String loginServer = SalesforceSDKManager.getInstance().getLoginServerManager().getSelectedLoginServer().url; final AuthConfigUtil.SSOAuthConfig authConfig = AuthConfigUtil.getSSOAuthConfig(loginServer); boolean browserLoginEnabled = false; if (authConfig != null) { browserLoginEnabled = authConfig.isBrowserLoginEnabled(); } SalesforceSDKManager.getInstance().setBrowserLoginEnabled(browserLoginEnabled); } })).start(); }",Shouldn't we wait for that call to complete? Could we use the same code as AuthConfigTask?
public CacheConfiguration getCache() { return cache; },@Restricted - don't want this API to leak to other plugins.
"CommandLineOptions build() { return new CommandLineOptions( this.files.build(), this.inPlace, this.lines.build(), this.offsets.build(), this.lengths.build(), this.aosp, this.version, this.help, this.stdin, this.fixImportsOnly, this.removeJavadocOnlyImports, this.validationMode ); }",I think this bracket should be on the previous line.
"public void update() { for (Integer rank = this.minRank; rank <= this.maxRank; rank++) { LOGGER.info(String.format(""Starting rank %d"", rank)); for (Map<String, Object> sector : getIndexSectors(rank)) for (UpdateRow place : getIndexSectorPlaces(rank, (Integer) sector.get(""geometry_sector""))) { template.update(""update placex set indexed_status = 0 where place_id = ?"", place.getPlaceId()); final List<PhotonDoc> updatedDocs = exporter.getByPlaceId(place.getPlaceId()); for (PhotonDoc updatedDoc : updatedDocs) { switch (place.getIndexdStatus()) { case 1: if (updatedDoc.isUsefulForIndex()) updater.create(updatedDoc); break; case 2: if (!updatedDoc.isUsefulForIndex()) { updater.delete(place.getPlaceId()); break; } updater.updateOrCreate(updatedDoc); break; case 100: updater.delete(place.getPlaceId()); break; default: LOGGER.error(String.format(""Unknown index status %d"", place.getIndexdStatus())); break; } } } } updater.finish(); }","Looking at this again, the different cases need a bit more consideration. For 'case 100' (object was deleted), export.getByPlaceId() shouldn't even be called because we already know that the placeID won't exist anymore. (That was wrong before as well but is worth fixing while changing this code.) More importantly, for the 'case 2', the code does not catch when a housenumber gets deleted from the batch of housenumbers for that placeID because the code only updates the ones that exist after the update. The most simple solution here is to always call a delete with a subsequent create for case 2. I don't know what the performance impact of such a solution would be. In any case, the delete() in 'case 2' should be moved out of the loop. isUsefulForIndex() evaluates always to the same value for the elements of updatesDocs and calling delete() multiple times for the same placeID is inefficient, if not harmful."
"private String sendAvroMessage(SpecificRecord message) throws ProducerException { try { GenericRecord avroRecord = addForkliftPropertiesToAvroObject(message); ProducerRecord record = new ProducerRecord<String, GenericRecord>(topic, null, avroRecord); try { RecordMetadata result = (RecordMetadata)kafkaProducer.send(record).get(); return result.topic() + ""-"" + result.partition() + ""-"" + result.offset(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new ProducerException(""Error sending Kafka Message"", e); } catch (ExecutionException e) { throw new ProducerException(""Error creating Kafka Message"", e); } } catch (IOException e) { throw new ProducerException(""Error creating Kafka Message"", e); } }",This exception message doesn't make sense; the message is completely created before the corresponding try block.
"protected void rebuild() { try (FlowScopeLog parentLogger = new FlowScopeLogBuilder(LOGGER, Level.FINE, ""TimeGraphView:Rebuilding"").setCategory(getViewId()).build()) { setStartTime(fTrace.getStartTime().toNanos()); setEndTime(fTrace.getEndTime().toNanos()); refresh(); ITmfTrace viewTrace = fTrace; if (viewTrace == null) { return; } resetView(viewTrace); List<IMarkerEventSource> markerEventSources = new ArrayList<>(); synchronized (fBuildJobMap) { for (ITmfTrace trace : getTracesToBuild(viewTrace)) { if (trace == null) { break; } List<@NonNull IMarkerEventSource> adapters = TmfTraceAdapterManager.getAdapters(trace, IMarkerEventSource.class); markerEventSources.addAll(adapters); Job buildJob = new Job(getTitle() + Messages.AbstractTimeGraphView_BuildJob) { @Override protected IStatus run(IProgressMonitor monitor) { new BuildRunnable(trace, viewTrace, parentLogger).run(monitor); monitor.done(); return Status.OK_STATUS; } }; fBuildJobMap.put(trace, buildJob); buildJob.schedule(); } } fMarkerEventSourcesMap.put(viewTrace, markerEventSources); } }",and this are the same. extractificate?
public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof ImplementNetworkVspCommand)) return false; if (!super.equals(o)) return false; ImplementNetworkVspCommand that = (ImplementNetworkVspCommand) o; if (_dhcpOption != null ? !_dhcpOption.equals(that._dhcpOption) : that._dhcpOption != null) return false; if (_network != null ? !_network.equals(that._network) : that._network != null) return false; return true; },Please consider simplifying this if block with Guava's Objects.equals.
"static String getRequireBundleValue(File manifestFile) { String bundleValue; try (FileInputStream manifestStream = new FileInputStream(manifestFile)) { Manifest manifest = new Manifest(manifestStream); bundleValue = manifest.getMainAttributes().getValue(REQUIRE_BUNDLE_KEY); } catch (IOException e) { throw new GradleException( ""Unable to determine the bundle dependencies defined in manifest: "" + manifestFile.getAbsolutePath(), e); } return bundleValue; }",Can be private according to IntelliJ code inspection.
"public void testMetadataUpdaterBinary() throws Exception { context.getRouteDefinition(""FcrepoSerializationBinaryUpdater"").adviceWith(context, new AdviceWithRouteBuilder() { @Override public void configure() throws Exception { replaceFromWith(""direct:start""); mockEndpointsAndSkip(""*""); } }); context.start(); getMockEndpoint(""mock:file:mock:direct:binary_file"").expectedMessageCount(0); final String body = IOUtils.toString(ObjectHelper.loadResourceAsStream(""binary.rdf""), ""UTF-8""); final Map<String, Object> headers = ImmutableMap.of( BASE_URL, baseURL, IDENTIFIER, ""foo""); template.sendBodyAndHeaders(body, headers); assertMockEndpointsSatisfied(); }","This is a strange formulation. I don't know what you're trying to mock here, but as it is, it's incorrect."
"public ObjectFilter withParameters(Map<String, Object> namedParameters) { if (namedParameters == null) { throw new IllegalArgumentException(""namedParameters argument cannot be null""); } for (String paramName : getParameterNames()) { if (namedParameters.get(paramName) == null) { throw new IllegalArgumentException(""Query parameter '"" + paramName + ""' was not set""); } } return new RejectObjectFilter<>(namedParameters, parsingResult); }",Here as well. It's the 3rd time I'm seeing this loop - would it be possible to extract it somehow?
"public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) throws IOException, OrmException { if (commitMessage == null) { PatchSet.Id psId = change(db).currentPatchSetId(); String sha1 = db.get().patchSets().get(psId).getRevision().get(); Project.NameKey name = change.getProject(); Repository repo = repoManager.openRepository(name); RevWalk walk = new RevWalk(repo); try { RevCommit c = walk.parseCommit(ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); } finally { walk.release(); repo.close(); } } return commitMessage; }","I am concerned that this is still unsafe, what if this throws a runtime exception, the repo will not get closed."
"private void createAndDispatchGDBFocusChangedEvent() { assert fCurrentThreadCtx != null; fCommandControl.getSession().dispatchEvent(new GDBFocusChangedEvent(fCurrentThreadCtx), fCommandControl.getProperties()); }","Why always specify the thread when the focus changes? Couldn't we send the most specific context? So by sending the frame, the receiver could know both the frame and its parent thread which is stored in the context hierarchy"
"public void init() { if (!init) { for (String mapName : store.getMapNames()) { if (mapName.startsWith(UNDO_LOG_NAME_PREFIX)) { if (mapName.equals(UNDO_LOG_NAME_PREFIX)) { if (!store.hasData(mapName) || store.isReadOnly()) { store.removeMap(mapName); } continue; } boolean committed = mapName.charAt(UNDO_LOG_NAME_PREFIX.length()) == UNDO_LOG_COMMITTED; if (store.hasData(mapName) || committed) { int transactionId = Integer.parseInt(mapName.substring(UNDO_LOG_NAME_PREFIX.length() + 1)); VersionedBitSet openTxBitSet = openTransactions.get(); if (!openTxBitSet.get(transactionId)) { Object[] data = preparedTransactions.get(transactionId); int status; String name; if (data == null) { status = Transaction.STATUS_OPEN; name = null; } else { status = (Integer) data[0]; name = (String) data[1]; } if (committed) { status = Transaction.STATUS_COMMITTED; } MVMap<Long, Object[]> undoLog = store.openMap(mapName, undoLogBuilder); undoLogs[transactionId] = undoLog; Long lastUndoKey = undoLog.lastKey(); assert committed || lastUndoKey != null; assert committed || getTransactionId(lastUndoKey) == transactionId; long logId = lastUndoKey == null ? 0 : getLogId(lastUndoKey) + 1; registerTransaction(transactionId, status, name, logId, timeoutMillis, 0, RollbackListener.NONE); } } } } init = true; } }",May be && !store.isReadOnly()?
"public void testDateTimeChannelCalendarDefaultTimeZoneUpdate() { Configuration configuration = new Configuration(); initialize(configuration, NtpBindingConstants.CHANNEL_DATE_TIME, ACCEPTED_ITEM_TYPE_DATE_TIME, null, null); ZoneOffset timeZoneIdFromItemRegistry = ((DateTimeType) getItemState(ACCEPTED_ITEM_TYPE_DATE_TIME)) .getZonedDateTime().getOffset(); assertThat(""The dateTime channel calendar was not updated with the right timezone"", timeZoneIdFromItemRegistry, is(equalTo(ZoneOffset.of(""+03:00"")))); }",Here as well - why do you assume every build server sits in EEST?
"public void mergeWith(UnweightedDoubleReservoirSample other) { checkArgument(samples.length == other.samples.length, ""Max samples must be equal""); if (other.count < other.samples.length) { other.stream().forEach(o -> add(o)); return; } if (count < samples.length) { final UnweightedDoubleReservoirSample target = ((UnweightedDoubleReservoirSample) other.clone()); stream().forEach(o -> target.add(o)); count = target.count; samples = target.samples; return; } shuffleArray(samples); shuffleArray(other.samples); int nextIndex = 0; int otherNextIndex = 0; double[] merged = new double[samples.length]; for (int i = 0; i < samples.length; ++i) { if (ThreadLocalRandom.current().nextLong(0, count + other.count) < count) { merged[i] = samples[nextIndex++]; } else { merged[i] = other.samples[otherNextIndex++]; } } count += other.count; samples = merged; }","* Max samples -> Maximum number of samples for consistency * add actual values to the error message to help debugging  checkArgument(samples.length == other.samples.length, ""Maximum number of samples must be equal: "" + samples.length + "" != "" + other.samples.length);"
public OperationAction createOperationAction() { OperationActionImpl operationAction = new OperationActionImpl(); return operationAction; },Lost @not-generated code.
"protected void writeItem(@NonNull final File rootFolder, @NonNull final AssetItem item, @NonNull WaitableExecutor executor) throws IOException { if (item.isTouched()) { executor.execute(new Callable() { @Override public Object call() throws Exception { AssetFile assetFile = item.getSource(); File fromFile = assetFile.getFile(); File toFile = new File(rootFolder, item.getKey().replaceAll(""/"", File.separator)); toFile.getParentFile().mkdirs(); Files.copy(fromFile, toFile); return null; } }); } }","Instead of replaceAll, which takes a string regexp, you can do .replace('/', File.separatorChar) (it will replace all character occurrences)"
"private boolean getValue(FutureVDSCall<VDSReturnValue> task, Guid hostId) { try { VDSReturnValue vdsReturnValue = task.get(Config.<Integer> getValue(ConfigValues.SetupNetworksPollingTimeout), TimeUnit.SECONDS); return vdsReturnValue.getSucceeded(); } catch (TimeoutException e) { return false; } catch (VDSRecoveringException e) { LOGGER.trace(""Failed to poll host {} - it's in recovery mode."", hostId, e); return false; } }",why trace ? it shouldn't be too excessive. It will be printed at most one time in case of a specific error. Therefore I suggest to increase the level to DEBUG.
"public List<String> getURLsFromPage(Document page) { Elements elements = page.select(""#post-list .thumb a,#pool-show .thumb a""); List<String> res = new ArrayList<String>(elements.size()); if (page.getElementById(""pool-show"") != null) { int index = 0; Element e = page.getElementById(""paginator""); if (e != null && (e = e.getElementsByClass(""current"").first()) != null) index = (Integer.parseInt(e.text()) - 1) * POOL_IMAGES_PER_PAGE; for (Element e_ : elements) res.add(e_.absUrl(""href"") + ""#"" + ++index); } else { for (Element e : elements) res.add(e.absUrl(""href"") + ""#"" + e.child(0).attr(""id"").substring(1)); } return res; }","Please don't use assignment within an if-statement, as it makes reading and maintaining the code more difficult. Nested if-statements are fine. Please also wrap if-statement and for-loop bodies in braces."
"public void testExecuteAndPostProcess() throws Exception{ InstructorAttributes instructor = dataBundle.instructors.get(""teammates.test.instructor2""); String instructorId = instructor.googleId; gaeSimulation.loginAsInstructor(instructorId); ______TS(""Successful case""); InstructorFeedbackEditCopyPageAction a = getAction(); AjaxResult r = getAjaxResult(a); assertFalse(r.isError); InstructorFeedbackEditCopyPageData pageData = (InstructorFeedbackEditCopyPageData) r.data; assertEquals(4, pageData.courses.size()); }",Are there no more test cases? Any case where it will fail? Does this check that archived courses/courses without edit permission are omitted?
"protected static String propertyValue(String propertyFile, String propertyName) throws ParserConfigurationException, SAXException, IOException, URISyntaxException{ String configLocation = System.getenv(""HADOOP_CONF_DIR""); File file = new File(configLocation+""/""+propertyFile); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory .newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); Document document = documentBuilder.parse(file); document.getDocumentElement().normalize(); Element docElement = document.getDocumentElement(); NodeList nodeList = docElement.getElementsByTagName(""property""); ArrayList<String> names = new ArrayList<String>(); ArrayList<String> values = new ArrayList<String>(); if (nodeList != null) { int length = nodeList.getLength(); for (int i = 0; i < length; i++) { if (nodeList.item(i).getNodeType() == Node.ELEMENT_NODE) { Element element = (Element) nodeList.item(i); if (element.getNodeName().contains(""property"")) { names.add( element.getElementsByTagName(""name"").item(0).getTextContent()); values.add( element.getElementsByTagName(""value"").item(0).getTextContent()); } } } } String[] nameslist = names.toArray(new String[names.size()]); String[] valueslist = values.toArray(new String[values.size()]); int valuePosition = Arrays.asList(nameslist).indexOf(propertyName); String propertyValue = valueslist[valuePosition].toString(); return propertyValue; }",Are these methods have to be protected static? Why?
"public ConstraintEventsIterator(String dumpDirectory, HiveConf hiveConf) throws IOException { Path path = new Path(dumpDirectory); fs = path.getFileSystem(hiveConf); dbDirs = fs.listStatus(new Path(dumpDirectory), EximUtil.getDirectoryFilter(fs)); currentDbIndex = 0; if (dbDirs.length != 0) { currentConstraintIndex = 0; constraintFiles = listConstraintFilesInDBDir(fs, dbDirs[0].getPath()); } }",Constraint files listing for 0th Db also can be done inside hasNext to avoid duplicate code here.
"private static Map<String, List<String>> checkTable(String schema, String table, String index, int level) throws Exception { LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC(); TransactionController tc = lcc.getTransactionExecute(); TxnView txn = ((SpliceTransactionManager) tc).getActiveStateTxn(); Activation activation = lcc.getLastActivation(); DataDictionary dd = lcc.getDataDictionary(); SchemaDescriptor sd = dd.getSchemaDescriptor(schema, tc, true); if (sd == null) { throw StandardException.newException(SQLState.LANG_SCHEMA_DOES_NOT_EXIST, schema); } TableDescriptor td = dd.getTableDescriptor(table, sd, tc); if (td == null) { throw StandardException.newException(SQLState.TABLE_NOT_FOUND, table); } if (index != null) { ConglomerateDescriptor indexCD = SpliceRegionAdmin.getIndex(td, index); if (indexCD == null) { throw StandardException.newException(SQLState.LANG_INDEX_NOT_FOUND, index); } } ConglomerateDescriptorList list = td.getConglomerateDescriptorList(); List<TentativeIndex> tentativeIndexList = new ArrayList(); for (ConglomerateDescriptor searchCD : list) { if (searchCD.isIndex() && !searchCD.isPrimaryKey()) { DDLChange ddlChange = ProtoUtil.createTentativeIndexChange(txn.getTxnId(), activation.getLanguageConnectionContext(), td.getHeapConglomerateId(), searchCD.getConglomerateNumber(), td, searchCD.getIndexDescriptor(), td.getDefaultValue(searchCD.getIndexDescriptor().baseColumnPositions()[0])); if (index == null || searchCD.getObjectName().compareToIgnoreCase(index) == 0) { tentativeIndexList.add(ddlChange.getTentativeIndex()); } } } Map<String, List<String>> errors = null; if (tentativeIndexList.size() > 0) { ConglomerateDescriptorList cdList = td.getConglomerateDescriptorList(); errors = checkIndexes(schema, table, cdList, tentativeIndexList, level); } return errors; }",Please move the setting of the ddlChange inside the subsequent if statement.
"private void setUpAudioPlayer() { audioPlayer = ExoPlayerFactory.newSimpleInstance( getApplicationContext(), new DefaultTrackSelector(), new DefaultLoadControl()); audioPlayer.addListener(this); audioPlayer.setPlayWhenReady(true); audioPlayer.setVolume(1.0f); }","newSimpleInstance(Context, TrackSelector, LoadControl) is deprecated, you may use newSimpleInstance(RenderersFactory, TrackSelector, LoadControl)."
"private ClusterCacheStatus initCacheStatusIfAbsent(String cacheName) { return cacheStatusMap.computeIfAbsent(cacheName, (name) -> { Configuration cacheConfiguration = cacheManager.getCacheConfiguration(cacheName); AvailabilityStrategy availabilityStrategy; if (cacheConfiguration != null && cacheConfiguration.clustering().partitionHandling().enabled()) { availabilityStrategy = new PreferConsistencyStrategy(eventLogManager); } else { availabilityStrategy = new PreferAvailabilityStrategy(eventLogManager); } Optional<GlobalStateManager> globalStateManager = cacheManager.getGlobalComponentRegistry().getOptionalComponent(GlobalStateManager.class); Optional<ScopedPersistentState> persistedState = globalStateManager.flatMap(gsm -> { return gsm.readScopedState(cacheName); }); return new ClusterCacheStatus(cacheName, availabilityStrategy, this, transport, persistedState); }); }",Why not use injection?
"public void sortingShouldIgnoreCase() { assertSortedLike(""a"", ""b"", ""z""); assertSortedLike(""a"", ""B""); }",I'd add another lower and upper case character to prove the point
"private static void checkValidStep(long start, long stop, long step) { checkCondition( step != 0, INVALID_FUNCTION_ARGUMENT, ""step must not be zero""); checkCondition( step > 0 ? stop >= start : stop <= start, INVALID_FUNCTION_ARGUMENT, ""sequence stop value should be greater than or equal to start value if step is greater than zero otherwise stop should be less than or equal start""); }",or equal to
"public Object visitPutMapCommand(InvocationContext ctx, PutMapCommand command) throws Throwable { Object returnValue = super.visitPutMapCommand(ctx, command); if (shouldUpdateOnWriteCommand(command)) { Set<Object> keys = command.getMap().keySet(); Set<Object> toInvalidate = new HashSet<Object>(keys.size()); for (Object k : keys) { if (cdl.localNodeIsPrimaryOwner(k)) { toInvalidate.add(k); } } if (!toInvalidate.isEmpty()) { getLog().tracef(""Sending additional invalidation for requestors if necessary.""); l1Manager.flushCache(toInvalidate, ctx.getOrigin(), true); } } return returnValue; }",invokeNext instead of super.visitPutMapCommand?
"private void initRenderingSupport() { dynamicFBM = new DynamicFBM(); staticFBM = new StaticFBM(); shadowMapResolutionDependentFBM = new ShadowMapResolutionDependentFBM(); context.put(DynamicFBM.class, dynamicFBM); context.put(StaticFBM.class, staticFBM); context.put(ShadowMapResolutionDependentFBM.class, shadowMapResolutionDependentFBM); postProcessor = new PostProcessor(dynamicFBM); context.put(PostProcessor.class, postProcessor); dynamicFBM.setPostProcessor(postProcessor); dynamicFBM.initialise(); staticFBM.initialise(); shadowMapResolutionDependentFBM.initialise(); shaderManager.initShaders(); initMaterials(); context.put(WorldRenderer.class, this); context.put(RenderQueuesHelper.class, renderQueues); context.put(RenderableWorld.class, renderableWorld); initRenderGraph(); }","I'm not convinced these should be so public as to be available through the context. In my opinion only objects working within the renderer should obtain them, i.e. via constructor or injection."
"private void writeCSV(){ try { for (int i = 0; i < this.usersIdArray.size()-1; i++) { Integer idUser = this.mapUsers.inverse().get(this.usersIdArray.get(i)); this.fileWriter.append(String.valueOf(idUser)); this.fileWriter.append("",""); Integer idProduct = this.mapProducts.inverse().get(this.productsIdArray.get(i)); this.fileWriter.append(String.valueOf(idProduct)); this.fileWriter.append("",""); this.fileWriter.append(String.valueOf(this.reviewsArray.get(i))); this.fileWriter.append('\n'); } } catch (IOException e) { e.printStackTrace(); } }",I consider it's better to construct an entire line and append it :)
"List<String> registerProvidedLocalResources() { checkNotNull(localResources); final ArrayList<String> classPaths = new ArrayList<>(); providedSharedLibs.forEach( (fileName, fileStatus) -> { final Path filePath = fileStatus.getPath(); LOG.debug(""Using remote file {} to register local resource"", filePath); final YarnLocalResourceDescriptor descriptor = YarnLocalResourceDescriptor .fromFileStatus(fileName, fileStatus, LocalResourceVisibility.PUBLIC); localResources.put(fileName, descriptor.toLocalResource()); remotePaths.add(filePath); envShipResourceList.add(descriptor); if (!isFlinkDistJar(fileName) && !isPlugin(fileStatus.getPath())) { classPaths.add(fileName); } else if (isFlinkDistJar(fileName)) { flinkDist = descriptor; } }); return classPaths; }","I think we could not use fileName to check isFlinkDistJar  since it is relative path, not the real file name(e.g. lib/flink-dist_2.11-1.11-SNAPSHOT.jar). So i suggest to use the key or relative to instead of fileName to avoid confusing. fileStatus.getPath() could be replaced with filePath."
"private Group addDomainToUserMembers(Group group, String userStoreDomain) throws CharonException { List<String> membersId = group.getMembers(); if (StringUtils.isBlank(userStoreDomain) || membersId == null || membersId.isEmpty()) { return group; } List<String> membersDisplayNamesWithoutDomain = group.getMembersWithDisplayName(); List<String> membersDisplayNamesWithDomain = new ArrayList<String>(); for (String memberId : membersId) { group.removeMember(memberId); } if (membersDisplayNamesWithoutDomain != null) { for (String memberDisplayNameWithoutDomain : membersDisplayNamesWithoutDomain) { membersDisplayNamesWithDomain .add(UserCoreUtil.addDomainToName(memberDisplayNameWithoutDomain, userStoreDomain)); } } for (int i = 0; i < membersId.size(); i++) { group.setMember(membersId.get(i), membersDisplayNamesWithDomain.get(i)); } return group; }",Better to do a null or empty check check for memberIDs and only a single check in the beginning
private boolean isProjectInternalDependency(VirtualFile jar) { Path jarPath = Paths.get(jar.getPath()); Optional<Path> bloopJarsPath = bloopJarsPath(project); Optional<Path> sourcesJarPath = sourcesJarPath(project); return jarPath.startsWith(bloopJarsPath.get()) || jarPath.startsWith(sourcesJarPath.get()); },are these get calls safe?
"public ImmutableColumn(String name, ColumnType type, Table table, int columnNumber, Integer columnSize, String nativeType, Boolean nullable, String remarks, boolean indexed, String quote, boolean primaryKey) { this.name = name; this.type = type; this.table = table; this.columnNumber = columnNumber; this.columnSize = columnSize; this.decimalDigits = null; this.nativeType = nativeType; this.nullable = nullable; this.remarks = remarks; this.indexed = indexed; this.quote = quote; this.primaryKey = primaryKey; }","It is common practice to use constructor chaining when using multiple constructors for a java class, so then you could change this to:  this(name, type, table, columnNumber, columnSize, null, nativeType, nullable, remarks, indexed, quote, primaryKey);"
"public void appendCompacted(List<LogData> entries) { try { if (entries.isEmpty()) { return; } if (containsAny(entries, true)) { log.debug(""appendCompacted: Overwritten exception, entries: {}"", entries); throw new OverwriteException(OverwriteCause.SAME_DATA); } Map<Long, AddressMetaData> addressMetaData = writeRecords(entries); knownAddresses.putAll(addressMetaData); compactionMetaData.updateTotalPayloadSize(entries); log.trace(""appendCompacted: Written entries to disk: {}"", entries); } catch (IOException ioe) { log.error(""appendCompacted: IOException when writing entries: {}"", entries, ioe); throw new RuntimeException(ioe); } }",inherent doc from base class.
public void destroy() { super.destroy(); this.subscribers.forEach(Subscriber::onComplete); this.disposables.values().forEach(Disposable::dispose); },suggestion this.flux.onComplete();
"public Order discontinueOrder(Order orderToDiscontinue, String reasonNonCoded, Date discontinueDate) { discontinueOrder(orderToDiscontinue, discontinueDate); Order newOrder = orderToDiscontinue.cloneForDiscontinuing(); newOrder.setDiscontinuedReasonNonCoded(reasonNonCoded); return saveOrder(newOrder); }","Looks like you are returning the discontinuation order, i think you should still return the discontinued order, not so @djazayeri ?"
"protected SleepTask createRunnable(HttpAction action) { String interval = action.request.getParameter(""interval""); int sleepMilli = 5000; if ( interval != null ) { try { sleepMilli = Integer.parseInt(interval); } catch (NumberFormatException ex) { ServletOps.errorBadRequest(""Bad format for 'interval': integer required""); return null; } } if ( sleepMilli < 0 ) { ServletOps.errorBadRequest(""Negative sleep interval""); return null; } if ( sleepMilli > MaxSleepMillis ) { ServletOps.errorBadRequest(""Sleep internal greater than maximum allowed""); return null; } return new SleepTask(action, sleepMilli, AsyncPool.get()); }","Maybe use the same prefix for all errors? ""Bad format for 'interval': integer required"" ""Bad format for 'interval': negative sleep interval"" ""Bad format for 'interval': sleep internal greater than maximum allowed"" ?"
"public void shouldBeAbleToDeserializeADogWithoutRootAndParameterNameEqualsJsonProperty() throws Exception { InputStream stream = asStream(""{'name':'Brutus','age':7}""); when(deserializeeInstance.get()).thenReturn(new Deserializee()); when(container.instanceFor(WithoutRoot.class)).thenReturn(new WithoutRoot()); Object[] deserialized = deserializer.deserialize(stream, dogParameterNameEqualsJsonPropertyWithoutRoot); assertThat(deserialized.length, is(1)); assertThat(deserialized[0], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[0]; assertThat(dog.name, is(""Brutus"")); assertThat(dog.age, is(7)); }",this line is repeated on all tests. move it to setup
"public void testImport() { mode = LanguageMode.ECMASCRIPT6; parse(""import 'someModule'""); parse(""import d from './someModule'""); parse(""import {} from './someModule'""); parse(""import {x, y} from './someModule'""); parse(""import {x as x1, y as y1} from './someModule'""); parse(""import {x as x1, y as y1, } from './someModule'""); parse(""import {default as d} from './someModule'""); parse(""import d, {x as x1, y as y1} from './someModule'""); parse(""import * as sm from './someModule'""); parseError(""import class from './someModule'"", ""cannot use keyword 'class' here.""); parseError(""import * as class from './someModule'"", ""'identifier' expected""); parseError(""import {a as class} from './someModule'"", ""'identifier' expected""); parseError(""import {class} from './someModule'"", ""'as' expected""); }",If I understand correctly {a as class} is invalid (makes sense as it would put a var called 'class' into the module scope) but {class as a} is valid. I don't see tests of this valid case ({someKeyword as nonKeyword}) except for default.
"public void post_generated_events_to_event_bus() { final Command cmd = Given.Command.startProject(); handler.handle(cmd); final int postedEventCount = 2; final ArgumentCaptor<Event> eventCaptor = ArgumentCaptor.forClass(Event.class); verify(eventBus, times(postedEventCount)).post(eventCaptor.capture()); final List<Event> events = eventCaptor.getAllValues(); assertEquals(postedEventCount, events.size()); assertEquals(ProjectStarted.class, Events.getMessage(events.get(0)) .getClass()); assertEquals(StringValue.class, Events.getMessage(events.get(1)) .getClass()); }",How do you know there is going to be 2?
"public ExecutionResult execute(Item item) { ProcessType processType = getProcessType(item); if (getProject().getLanguage() != ECodeLanguage.JAVA || processType == null) { return ExecutionResult.NOTHING_TO_DO; } try { String componentsName = new String(""tFTPFileExist""); IComponentFilter filter = new NameComponentFilter(componentsName); IComponentConversion addOption = new IComponentConversion() { @Override public void transform(NodeType node) { if (ComponentUtilities.getNodeProperty(node, PROPERTY_NAME) == null) { ComponentUtilities.addNodeProperty(node, PROPERTY_NAME, PROPERTY_TYPE); } ComponentUtilities.setNodeValue(node, PROPERTY_NAME, ""false""); } }; ModifyComponentsAction.searchAndModify(item, processType, filter, Arrays.<IComponentConversion> asList(addOption)); return ExecutionResult.SUCCESS_NO_ALERT; } catch (Exception e) { ExceptionHandler.process(e); return ExecutionResult.FAILURE; } }","Please move value ""tFTPFileExist"" to constant COMPONENT_NAME"
"public SegmentEvent transform(org.atlasapi.media.entity.simple.SegmentEvent simple, PublisherDetails publisher) { checkArgument(Strings.isNullOrEmpty(simple.getUri()), ""You must specify a URI on the item""); checkArgument(simple.getSegment() != null, ""You must specify a Segment on the SegmentEvent""); SegmentEvent complex = new SegmentEvent(); complex.setCanonicalUri(simple.getUri()); complex.setDescription(Description.description() .withSynopsis(simple.getDescription()) .withTitle(simple.getTitle()) .build()); complex.setPosition(simple.getPosition()); if (simple.getOffset() != null) { complex.setOffset(Duration.standardMinutes(simple.getOffset())); } complex.setIsChapter(simple.getIsChapter()); if (Strings.isNullOrEmpty(simple.getSegment().getId())) { complex.setSegment(writeSegment(simple.getSegment(), publisher)); } else { complex.setSegment(new SegmentRef(codec.decode(simple.getSegment().getId()).longValue())); } return complex; }",inverse?
"public Single<Integer> getUploadCount(String userName) { HttpUrl.Builder urlBuilder = wikiMediaToolforgeUrl.newBuilder(); urlBuilder .addPathSegments(""uploadsbyuser.py"") .addQueryParameter(""user"", userName); if (ConfigUtils.isBetaFlavour()) { urlBuilder.addQueryParameter(""labs"", ""commonswiki""); } Request request = new Request.Builder() .url(urlBuilder.build()) .build(); return Single.fromCallable(() -> { Response response = okHttpClient.newCall(request).execute(); if (response != null && response.isSuccessful()) { ResponseBody responseBody = response.body(); if(null!=responseBody) { String responseBodyString = responseBody.toString(); if (!TextUtils.isEmpty(responseBodyString.trim())) { return Integer.parseInt(responseBodyString.trim()); } } } return 0; }); }","Note that this will throw a NumberFormatException if the response body is not actually a number. It might be okay to allow this to just throw, but if crashing is undesired you could use a try/catch and return 0 in the catch."
"protected void testExecute() { InstructorAttributes instructor1ofCourse1 = typicalBundle.instructors.get(""instructor1OfCourse1""); loginAsAdmin(); ______TS(""Not enough parameters""); verifyHttpParameterFailure(); ______TS(""Typical case""); String[] params = { Const.ParamsNames.INSTRUCTOR_ID, instructor1ofCourse1.getGoogleId(), }; DowngradeAccountAction a = getAction(params); JsonResult r = getJsonResult(a); MessageOutput response = (MessageOutput) r.getOutput(); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(""Instructor account is successfully downgraded to student."", response.getMessage()); ______TS(""Failure: Downgrades an invalid account""); String[] invalidParams = { Const.ParamsNames.INSTRUCTOR_ID, ""invalid-google-id"", }; assertThrows(EntityNotFoundException.class, () -> getJsonResult(getAction(invalidParams))); }",You need to verify the change using logic.getAccount()
private IReadOnlyListener createReadOnlyListener() { return new IReadOnlyListener() { @Override public void readOnlyStateChanged(ReadOnlyEvent event) { switch (event.getEventType()) { case ReadOnlyEvent.RESOURCE_READ_ONLY_STATE_CHANGED: scheduleRefresh(); break; case ReadOnlyEvent.OBJECT_READ_ONLY_STATE_CHANGED: CommonViewer viewer = getCommonViewer(); if ((viewer != null) && (viewer.getControl() != null) && !viewer.getControl().isDisposed()) { viewer.refresh(event.getObject()); } break; default: Activator.log.warn(Messages.ModelExplorerView_WarningReadOnlyEvent + event.getEventType()); break; } } }; },Exception Message like logs shouldn't be internationalize just use // NLS....
public void shouldComputeMaxOfOneValue() { assertThat(Iterator.of(5).max()).isEqualTo(Option.some(5)); },"Please change Iterator.of(...) to just of(...). AbstractTraversableTest has a protected method [of(T)](<LINK_0> that is implemented by all Test classes, [especially by IteratorTest](<LINK_1> Thank you!"
"public void batchAutomaticRouting() { EventHubProducerAsyncClient producer = new EventHubClientBuilder() .connectionString( ""Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};SharedAccessKey={key}"", ""event-hub-name"") .buildAsyncProducerClient(); producer.createBatch().flatMap(batch -> { batch.tryAdd(new EventData(""test-event-1"")); batch.tryAdd(new EventData(""test-event-2"")); return producer.send(batch); }).block(); END: com.azure.messaging.eventhubs.eventhubasyncproducerclient.createBatch producer.close(); }",Should our samples have block() or subscribe() for async clients?
"public void testPingFailOn500() throws Exception { MockWebServer server = mockOpenStackServer(); server.enqueue(addCommonHeaders(new MockResponse().setBody(stringFromResource(""/access.json"")))); server.enqueue(addCommonHeaders(new MockResponse().setResponseCode(500))); try { PoppyApi poppyApi = api(server.getUrl(""/"").toString(), ""openstack-poppy"", overrides); boolean online = poppyApi.ping(); assertThat(server.getRequestCount()).isEqualTo(2); assertAuthentication(server); assertRequest(server.takeRequest(), ""GET"", BASE_URI + ""/ping""); assertThat(online).isTrue(); } finally { server.shutdown(); } }",This is hanging then?
"private void populateRepositoryFactoryInformation(ListableBeanFactory factory) { Set<Map.Entry<String, RepositoryFactoryInformation>> repositoryFactoryBeans = BeanFactoryUtils .beansOfTypeIncludingAncestors(factory, RepositoryFactoryInformation.class).entrySet(); for (Map.Entry<String, RepositoryFactoryInformation> entry : repositoryFactoryBeans) { String beanName = entry.getKey(); if (BeanFactoryUtils.isFactoryDereference(beanName)) { RepositoryFactoryInformation repositoryFactoryInformation = entry.getValue(); Class<?> userDomainType = ClassUtils.getUserClass(repositoryFactoryInformation.getRepositoryInformation() .getDomainType()); this.repositoryFactoryInfos.put(userDomainType, repositoryFactoryInformation); this.repositoryBeanNames.put(userDomainType, BeanFactoryUtils.transformedBeanName(beanName)); } } }","Do we need this guard? RFI should only ever be implemented by FactoryBeans anyway. Even if it is not,  .transformedbeanName( ) will handle this case transparently."
"public void shouldUpgradeFromClean1_9To1_10() throws IOException, SQLException { upgradeTestUtil.upgrade(); }",This has no assertions?
"public PushOperatorBuilder atPosition(int position) { if (position < 0) { throw new IllegalArgumentException(""Position must be greater or equal to zero.""); } this.modifiers.addModifier(new PositionModifier(position)); return this; }","atPosition or ""toPosition""? atPosition sounds more like ""reading"" toPosition sounds more ""writing""."
public Object execute(ExecutionEvent event) throws ExecutionException { rebuildJob.cancel(); rebuildJob.schedule(); return null; },ExecutionException is unnecessary but ok.
protected WappalyzerPassiveScanner createScanner() { Logger.getLogger(WappalyzerPassiveScanner.class).setLevel(Level.DEBUG); getDefaultHolder().resetApplicationsToSite(); return new WappalyzerPassiveScanner(getDefaultHolder()); },This is not necessary by default.
"public void testSimpleEnvironmentNothingTodo() throws IOException, InterruptedException, FormException { TestableDockerContainerWatchdog subject = new TestableDockerContainerWatchdog(); final String nodeName = ""unittest-12345""; final String containerId = UUID.randomUUID().toString(); List<DockerCloud> listOfCloud = new LinkedList<DockerCloud>(); Map<String, String> labelMap = new HashMap<>(); labelMap.put(DockerContainerLabelKeys.NODE_NAME, nodeName); labelMap.put(DockerContainerLabelKeys.REMOVE_VOLUMES, ""false""); List<Container> containerList = new LinkedList<Container>(); Container c = TestableDockerContainerWatchdog.createMockedContainer(containerId, ""Running"", 0L, labelMap); containerList.add(c); DockerAPI dockerApi = TestableDockerContainerWatchdog.createMockedDockerAPI(containerList); DockerCloud cloud = new DockerCloud(""unittestcloud"", dockerApi, new LinkedList<DockerTemplate>()); listOfCloud.add(cloud); subject.setAllClouds(listOfCloud); LinkedList<Node> allNodes = new LinkedList<Node>(); DockerTransientNode node = TestableDockerContainerWatchdog.createMockedDockerTransientNode(containerId, nodeName, cloud, false); allNodes.add(node); subject.setAllNodes(allNodes); subject.runExecute(); Assert.assertEquals(0, subject.getAllRemovedNodes().size()); }",My IDE tells me that there's nothing in this method that throws FormException. Same applies to all the other times it's declared on the test methods - looks like we can remove the import of it as well as the declaration of it from all methods.
"private Map<String, Object> computeKeyValues(List<String> fieldNames, List<String> values) { Map<String, Object> retVal = new LinkedHashMap<>(); Iterator<String> keysIter = fieldNames.iterator(); Iterator<String> valsIter = values.iterator(); while (keysIter.hasNext()) { final String key = keysIter.next(); if (valsIter.hasNext()) { Object splitedValue = spliteValue(key, valsIter.next()); retVal.put(key, splitedValue); } else { break; } } return retVal; }",Could be simpler for-each loop over keys
"public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_ballot, container, false); final VIPTabBarActivity myActivity = (VIPTabBarActivity)this.getActivity(); SimpleDateFormat election_date_api_format = new SimpleDateFormat(""yyyy-MM-dd""); SimpleDateFormat election_date_display_format = new SimpleDateFormat(""MMMM d, yyyy""); TextView election_name_label = (TextView)rootView.findViewById(R.id.ballot_election_name); TextView election_date_label = (TextView)rootView.findViewById(R.id.ballot_election_date); election_name_label.setText(voterInfo.election.name); try { Date election_date = election_date_api_format.parse(voterInfo.election.electionDay); election_date_label.setText(election_date_display_format.format(election_date)); } catch (ParseException e) { Log.e(""BallotFragment"", ""Failed to parse election date "" + voterInfo.election.electionDay); election_date_label.setText(voterInfo.election.electionDay); } ArrayList contestInfo = (ArrayList) voterInfo.contests; ArrayAdapter adapter = new ArrayAdapter<String>(myActivity, android.R.layout.simple_selectable_list_item, contestInfo); ListView contestList = (ListView)rootView.findViewById(R.id.ballot_contests_list); contestList.setAdapter(adapter); contestList.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) { Log.d(""ContestsList"", ""clicked: "" + voterInfo.contests.get(position).office); myActivity.showContestDetails(position); } }); return rootView; }","Rather than parsing the election_date into a string here, consider adding a method on the Election class that returns a nicely formatted date string. Then the SimpleDateFormat objects can be used all over the app."
"public KmlMarshaller() { try { this.jaxbContext = JAXBContext.newInstance(Kml.class); this.unmarshaller = jaxbContext.createUnmarshaller(); } catch (JAXBException e) { LOGGER.info(""Unable to create JAXB Context. Setting to null.""); this.jaxbContext = null; } }",This might be more appropriate at debug
"private void buildVmGraphicsDevicesFromDb(Map<String, Object> extraSpecParams) { String spiceDeviceName = ""spice""; Comparator<VmDevice> spiceLastDeviceComparator = Comparator.comparing( VmDevice::getDevice, ComparatorUtils.sortLast(spiceDeviceName, ComparatorUtils.noOrdering())); buildVmDevicesFromDb(VmDeviceGeneralType.GRAPHICS, false, extraSpecParams, spiceLastDeviceComparator); String legacyDisplay = deriveDisplayTypeLegacy(); if (legacyDisplay != null) { createInfo.put(VdsProperties.display, legacyDisplay); } }",please use VmDeviceType#SPICE.getName instead
"public static byte[] newByteArray(byte[] data, int finalSize) { byte[] filledArray = new byte[finalSize]; int diff = finalSize - data.length; if (diff >= 0) { for (int i = 0; i < diff; i++) filledArray[i] = '0'; System.arraycopy(data, 0, filledArray, diff, data.length); } else System.arraycopy(data, 0, filledArray, 0, finalSize); return filledArray; }",Check if data is null.
"public void testPolicyDelete(String path) throws Exception { URL fileURL = Thread.currentThread().getContextClassLoader().getResource(path); Path policyDir = Paths.get(fileURL.toURI()).getParent(); assertTrue(RoleRegistry.get().getRegisteredRoles().isEmpty()); deployer.deployPolicy(policyDir); ArgumentCaptor<AuthorizationPolicy> policyCaptor = ArgumentCaptor.forClass(AuthorizationPolicy.class); ArgumentCaptor<Group> groupCaptor = ArgumentCaptor.forClass(Group.class); verify(storage).loadPolicy(); verify(storage).savePolicy(policyCaptor.capture()); Group group = new GroupImpl(""group1""); storage.deletePolicyByGroup(group, policyCaptor.getValue()); verify(storage).deletePolicyByGroup(groupCaptor.capture(), policyCaptor.capture()); verify(event).fire(any()); AuthorizationPolicy policy = policyCaptor.getValue(); verify(permissionManager).setAuthorizationPolicy(policy); Set<Group> roles = policyCaptor.getValue().getGroups(); assertEquals(1, roles.size()); PermissionCollection permissions = policy.getPermissions(group); Permission permission = permissions.get(""perspective.read""); assertNotNull(permission); assertEquals(AuthorizationResult.ACCESS_GRANTED, permission.getResult()); ; }",unnecessary semicolon
"protected void commitSubsection(final CitationCollectionOrder citationCollectionOrder) { List<CitationCollectionOrder> citationCollectionOrderList = getNestedCollectionAsList(citationCollectionOrder.getCollectionId()); int subSectionLocation = 1; final List<CitationCollectionOrder> citationCollectionOrderToSave = new ArrayList<CitationCollectionOrder>(); for (CitationCollectionOrder collectionOrder : citationCollectionOrderList) { if (citationCollectionOrder.getLocation() == subSectionLocation){ citationCollectionOrderToSave.add(citationCollectionOrder); } citationCollectionOrderToSave.add(collectionOrder); subSectionLocation++; } if (citationCollectionOrderToSave.size()==citationCollectionOrderList.size()){ citationCollectionOrderToSave.add(citationCollectionOrder); } m_sqlService.transact(new Runnable() { public void run() { String statement = ""delete from "" + m_collectionOrderTableName + "" where COLLECTION_ID = ? and SECTION_TYPE is not null""; Object fields[] = new Object[1]; fields[0] = citationCollectionOrder.getCollectionId(); m_sqlService.dbWrite(statement, fields); int location = 1; for (CitationCollectionOrder citationCollectionOrder1 : citationCollectionOrderToSave) { String orderStatement = ""insert into "" + m_collectionOrderTableName + "" (COLLECTION_ID, CITATION_ID, LOCATION, SECTION_TYPE, VALUE) VALUES(?,?,?,?,?)""; Object[] orderFields = new Object[5]; orderFields [0] = citationCollectionOrder1.getCollectionId(); orderFields [1] = citationCollectionOrder1.getCitationid(); orderFields [2] = location; orderFields [3] = citationCollectionOrder1.getSectiontype(); orderFields [4] = citationCollectionOrder1.getValue(); m_sqlService.dbWrite(orderStatement, orderFields); location++; } } }, ""commitSubsection: "" + citationCollectionOrder.getCollectionId()); updateCitationCollectionUpdateDate(citationCollectionOrder.getCollectionId()); }",Why not have the updating of the date in the transaction?
"public static Job create(String name, final ICoreRunnable runnable) { return new Job(name) { @Override protected IStatus run(IProgressMonitor monitor) { try { runnable.run(monitor); } catch (CoreException e) { return toStatusPreservingCause(e); } finally { monitor.done(); } return Status.OK_STATUS; } private IStatus toStatusPreservingCause(CoreException e) { IStatus status = e.getStatus(); if (status.getException() != null) return status; return new Status(status.getSeverity(), status.getPlugin(), status.getCode(), status.getMessage(), e); } }; }","This logic (converting a CoreException to an IStatus without losing the stack trace) needs to be used in more places than just here. In fact, looking over all callers of CoreException#getStatus(), it looks to me as though many callers should be using this logic instead. I'd suggest that this be moved to a static helper method in equinox common -- or perhaps even a new final method right on CoreException. Also, this logic assumes that if the CoreException contains a more specific cause then the stack trace for the CoreException itself is always uninteresting. I think this is probably the case in most situations, but we should be fairly certain that it occurs in all situations before discarding the wrapper unconditionally."
"public DataOutputStream getTempOutputStream() throws IOException { File tempFile = File.createTempFile(""test"", "".dat""); tempFilename = tempFile.getAbsolutePath(); Path path = new Path(""file:/ Configuration conf = new Configuration(); FileSystem fs = path.getFileSystem(conf); return fs.create(path); }","better to create these files under 'System.getProperty(""test.build.data"")/TestRawBytesStorage'"
"protected boolean canMutate(MutatableCode mutatableCode) { for (MInsn mInsn : mutatableCode.getInstructions()) { return (mInsn.insn.info.opcode == Opcode.NEW_INSTANCE); } Log.debug(""No New Instance in method, skipping...""); return false; }","uh, this is not right? can you spot the error?"
"public void publish(Message message, Topic topic, MessageState messageState, RequestTimeoutLock requestTimeoutLock, BrokerListeners listeners, PublishingCallback callback) { if (requestTimeoutLock.tryLock()) { messageState.setState(SENDING_TO_KAFKA_PRODUCER_QUEUE); brokerMessageProducer.send(message, topic, callback); messageState.setState(SENDING_TO_KAFKA); } }","if send() throws an exception (for example could not fetch topic metadata) after 65ms then client receives 202 but message will not be send to kafka, only persisted in backup storage."
"public T editHosted(@ApiParam(hidden = true) @Auth User user, @ApiParam(value = ""Entry to modify."", required = true) @PathParam(""entryId"") Long entryId, @ApiParam(value = ""Set of updated sourcefiles, add files by adding new files with unknown paths, delete files by including them with emptied content"", required = true) Set<SourceFile> sourceFiles) { T entry = getEntryDAO().findById(entryId); checkEntry(entry); checkUser(user, entry); checkHosted(entry); U version = getVersion(entry); Set<SourceFile> versionSourceFiles = handleSourceFileMerger(entryId, sourceFiles, entry, version); boolean isValidVersion = checkValidVersion(versionSourceFiles, entry); if (!isValidVersion) { throw new WebApplicationException(""The reversion is not valid"", HttpStatus.SC_BAD_REQUEST); } version.setValid(isValidVersion); version.setVersionEditor(user); long l = getVersionDAO().create(version); entry.getVersions().add(getVersionDAO().findById(l)); userDAO.clearCache(); T newTool = getEntryDAO().findById(entryId); elasticManager.handleIndexUpdate(newTool, ElasticMode.UPDATE); return newTool; }","I think this makes it into the GUI, so maybe something more descriptive like ""Your edited files for are invalid. No new version was created. Please check your syntax and try again."""
protected void executeQueryCommand() { setReturnValue(getDbFacade().getVdsGroupDao().getClustersHavingHosts()); },can be replaced with injection
"public void executeCommand(UICommand command) { super.executeCommand(command); if (command.equals(getNewSnapshotCommand())) { newSnapshot(); } else if (command.getName().equalsIgnoreCase(""onCreateSnapshot"")) { onCreateSnapshot(); } else if (command.getName().equalsIgnoreCase(""Cancel"")) { setWindow(null); } else if (command.equals(getEditSnapshotScheduleCommand())) { editSnapshotSchedule(); } else if (command.getName().equalsIgnoreCase(""onEditSnapshotSchedule"")) { onEditSnapshotSchedule(); } }",lower case first?
public int getRowCountEstimate() { int estimate = rowCountEstimate; if (estimate < 1) { estimate = pageSize * 4; } if (estimate <= requestedRange.getEnd()) { estimate = requestedRange.getEnd() + pageSize; } return estimate; },"Just wondering, based on what you choose 4 for default estimation? For me it looks reasonable, because usually users have either not so much data to explore, or they apply filters to find something quicker and they scroll not so deeply, but is there any testers feedback about that?"
"public MergeOp create(Branch.NameKey branch) { final ProjectState pe = mergeArguments.projectCache.get(branch.getParentKey()); if (pe == null) { log.error(""No such project: "" + branch.getParentKey()); return null; } final Project destProject = pe.getProject(); mergeArguments.destBranch = branch; mergeArguments.destProject = destProject; switch (destProject.getSubmitType()) { case CHERRY_PICK: return new CherryPick(mergeArguments); case FAST_FORWARD_ONLY: return new FastForwardOnly(mergeArguments); case MERGE_ALWAYS: return new MergeAlways(mergeArguments); case MERGE_IF_NECESSARY: return new MergeIfNecessary(mergeArguments); default: return null; } }",Maybe it would be better to throw an exception in this case.
"void peekMessage() { final String messageId = UUID.randomUUID().toString(); final String contents = ""Some-contents""; final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0); final ReceiveMessageOptions options = new ReceiveMessageOptions().setAutoComplete(true); receiver = createBuilder() .receiveMessageOptions(options) .buildAsyncReceiverClient(); StepVerifier.create(sender.send(message).thenMany(receiver.peek())) .assertNext(receivedMessage -> { Assertions.assertEquals(contents, receivedMessage.getBodyAsString()); Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)); Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID)); }) .verifyComplete(); }",sender.send(message).then(receiver.peek()) is probably what you want. thenMany suggests it returns a flux.
protected void executeVDSCommand() { vmManager.lock(); try { executeVmCommand(); vmManager.setLastUpdateDate(Calendar.getInstance().getTime()); } finally { vmManager.unlock(); } },"Note that a side effect of putting it here will be that every time the user changes CD, there is a chance to skip a cycle of the monitoring. Not the end of the world though"
"public String validateInput() { File file = getSelectedFile(); if (file == null) { return I18N.tr(""A file must be selected""); } boolean exists = getSelectedFile().exists(); if (exists && fileMustNotExist) { return UIFactory.getI18n().tr(""The file already exists""); } else if(exists && confirmOverwrite) { if(JOptionPane.showConfirmDialog(getComponent(),""<html><body><p style='width: ""+ getMessageWidth()+ ""px;'>""+ I18N.tr(""The file {0} already exists do you confirm overwrite ?"" + ""</body></html>"", getSelectedFile()) , I18N.tr(""Overwrite confirmation""), JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) { return I18N.tr(""Overwrite canceled""); } } return null; }","This is a [run-on sentence](<LINK_0> In addition, we don't but a space before the question mark in English. Better: ""The file {0} already exists. Overwrite?"""
"private GlusterVolumeTaskStatusEntity fetchRemobeBricksStatusDetails() { VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount())); GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue(); GlusterAsyncTask asyncTask = volume.getAsyncTask(); if (asyncTask != null && asyncTask.getTaskId() != null) { List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId()); if (stepsList != null && !stepsList.isEmpty()) { entity.setStartTime(stepsList.get(0).getStartTime()); } updateTaskStepDetails(asyncTask, entity.getStatusSummary().getStatus()); if (asyncTask.getStatus() == JobExecutionStatus.ABORTED) { entity.getStatusSummary().setStatus(JobExecutionStatus.ABORTED); } } updateHostIP(entity); return entity; }",can you not pass the step retrieved here to updateTaskStepDetails method? Can avoid a call to dao.
"private EnvVars addVarsToBuildEnv(final EnvVars envs, final ArrayList<ParameterValue> vars) { for (ParameterValue p : vars) { envs.putIfNotNull(p.getName(), String.valueOf(p.getValue())); } return envs; }",final?
"public AbstractChannelTypeBuilder(ChannelTypeUID channelTypeUID, String label) { this.channelTypeUID = channelTypeUID; this.label = label; }","in a previous version both parameters where checked for empty-ness, would be nice to see it again."
"public static void fhirResourceSearchGet(String resourceName) throws IOException, URISyntaxException { CloudHealthcare client = createClient(); HttpClient httpClient = HttpClients.createDefault(); String uri = String.format( ""%sv1beta1/%s"", client.getRootUrl(), resourceName); URIBuilder uriBuilder = new URIBuilder(uri) .setParameter(""access_token"", getAccessToken()); HttpUriRequest request = RequestBuilder .get() .setUri(uriBuilder.build()) .addHeader(""Content-Type"", ""application/fhir+json"") .addHeader(""Accept-Charset"", ""utf-8"") .addHeader(""Accept"", ""application/fhir+json; charset=utf-8"") .build(); HttpResponse response = httpClient.execute(request); HttpEntity responseEntity = response.getEntity(); if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) { System.err.print(String.format( ""Exception searching FHIR resources: %s\n"", response.getStatusLine().toString())); responseEntity.writeTo(System.err); throw new RuntimeException(); } System.out.println(""FHIR resource search results: ""); responseEntity.writeTo(System.out); }","s.b. v1, not v1beta1"
"public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ColumnStatistics that = (ColumnStatistics) o; return hasNumberOfValues == that.hasNumberOfValues && numberOfValues == that.numberOfValues && Objects.equals(booleanStatistics, that.booleanStatistics) && Objects.equals(integerStatistics, that.integerStatistics) && Objects.equals(doubleStatistics, that.doubleStatistics) && Objects.equals(stringStatistics, that.stringStatistics) && Objects.equals(dateStatistics, that.dateStatistics) && Objects.equals(decimalStatistics, that.decimalStatistics) && Objects.equals(bloomFilter, that.bloomFilter); }",I'd only compare this if hasNumberOfValues
public static CreateServer create(List<String> servers) { return new AutoValue_PrivateNetwork_Server_CreateServer(servers == null ? ImmutableList.<String>of() : servers); },Enforce an immutable list when present too.
default Set<User> calculateCulprits() { Set<User> r = new HashSet<User>(); RunT p = ((RunT)this).getPreviousCompletedBuild(); if (p != null && ((RunT)this).isBuilding()) { Result pr = p.getResult(); if (pr != null && pr.isWorseThan(Result.SUCCESS)) { r.addAll(p.getCulprits()); } } for (ChangeLogSet<? extends ChangeLogSet.Entry> c : getChangeSets()) { for (ChangeLogSet.Entry e : c) r.add(e.getAuthor()); } return r; },braces
"public static ColumnarArray toColumnarArray(Block block) { requireNonNull(block, ""block is null""); if (block instanceof LazyBlock) { return toColumnarArray((LazyBlock) block); } if (block instanceof DictionaryBlock) { return toColumnarArray((DictionaryBlock) block); } if (block instanceof RunLengthEncodedBlock) { return toColumnarArray((RunLengthEncodedBlock) block); } if (!(block instanceof AbstractArrayBlock)) { throw new IllegalArgumentException(""Invalid array block: "" + block.getClass().getName()); } AbstractArrayBlock arrayBlock = (AbstractArrayBlock) block; Block elementsBlock = arrayBlock.getValues(); int elementsOffset = 0; int elementsLength = 0; if (arrayBlock.getPositionCount() > 0) { elementsOffset = arrayBlock.getOffset(0); elementsLength = arrayBlock.getOffset(arrayBlock.getPositionCount()) - elementsOffset; } elementsBlock = elementsBlock.getRegion(elementsOffset, elementsLength); return new ColumnarArray(block, arrayBlock.getOffsetBase(), arrayBlock.getOffsets(), elementsBlock); }",Do the same in ColumnarRow
"private void prepareHandlers() { for (Map.Entry<Class<?>, SortedSet<MessageHandlingMember<? super T>>> typeHandlers : handlerInspector.getAllHandlers().entrySet()) { for (MessageHandlingMember<? super T> handler : typeHandlers.getValue()) { Class<?> type = typeHandlers.getKey(); if (handler.unwrap(CommandMessageHandlingMember.class).isPresent()) { if (Modifier.isAbstract(type.getModifiers()) && handler.unwrap(Constructor.class).isPresent()) { throw new AggregateModellingException(format( ""An abstract aggregate %s cannot have @CommandHandler on constructor."", type)); } addHandler(allCommandHandlers, type, handler); } else if (handler.unwrap(CommandHandlerInterceptorHandlingMember.class).isPresent()) { addHandler(allCommandHandlerInterceptors, type, handler); } else { addHandler(allEventHandlers, type, handler); } } } validateCommandHandlers(); }","Nit: I think renaming typeHandlers to handlersPerType is slightly clearer. Might be a taste thing though, hence marked as a nit."
default Builder result(ItemStack result) { return result(result.createSnapshot()); },"There should be a null check here checkNotNull(result, ""result"")"
"int foo(int y) { MathOperation addition = (x) -> x + x; MathOperation addition2 = (x) -> { return x + x; }; MathOperation addition3 = x -> x + x; MathOperation2 addition4 = (a, b) -> a + b; return y; }","> Do you mean lambdas that are nested inside expressions? inside Lambdas and probably few cases for inside expressions , just to make sure we do make difference between them."
"void runBenchmark() { try { long start, time; start = JVM.monotonicTimeMillis(); String privateDir = System.getProperty(""fileconn.dir.private""); Random random = new Random(); String filename = new javax.bluetooth.UUID(java.lang.Math.abs(random.nextInt())).toString(); FileConnection file = (FileConnection)Connector.open(privateDir + filename); System.out.println(""Writing to file "" + privateDir + filename); file.create(); SecureRandom rnd = SecureRandom.getInstance(SecureRandom.ALG_SECURE_RANDOM); OutputStream out = file.openOutputStream(); byte[] b = new byte[1024]; for (int i = 0; i < 1000; i++) { rnd.nextBytes(b, 0, 1024); out.write(b); } out.close(); time = JVM.monotonicTimeMillis() - start; System.out.println(""FileConnection.write time: "" + time); } catch (Exception e) { System.out.println(""Unexpected exception: "" + e); e.printStackTrace(); } }","javax.bluetooth.UUID only exists if you build with JSR_082=1, could you use another name? Even a static name would work, with a:  Java if (file.exists()) { file.delete(); }"
public boolean equals(final Object obj) { if (obj == this) { return true; } if (!(obj instanceof Ds3Element)) { return false; } final Ds3Element element = (Ds3Element) obj; if (this.getName().equals(element.getName()) && this.getType().equals(element.getType()) && this.getComponentType().equals(element.getComponentType())) { return true; } return false; },This can probably be simplified to just return the result of the boolean expression
"public String getUsername(URI uri) throws ClientConfigException { final CallbackHandler callbackHandler = AUTH_CONTEXT_CLIENT.getCallbackHandler(AUTH_CONTEXT_CLIENT.getAuthenticationConfiguration(uri, authenticationContext)); NameCallback nameCallback = new NameCallback(""user name""); try { callbackHandler.handle(new Callback[]{nameCallback}); return nameCallback.getName(); } catch (IOException | UnsupportedCallbackException e) { throw new ClientConfigException(""Name callback handling was unsuccessful""); } }",Would be good to get this and the following ones into an ElytronMessages class.
"private Action getNextEventAction() { if (fNextEventAction == null) { fNextEventAction = new Action() { @Override public void run() { TimeGraphViewer viewer = getTimeGraphViewer(); ITimeGraphEntry entry = viewer.getSelection(); if (entry instanceof CallStackEntry) { try { CallStackEntry callStackEntry = (CallStackEntry) entry; ITmfStateSystem ss = callStackEntry.getStateSystem(); long time = Math.max(ss.getStartTime(), Math.min(ss.getCurrentEndTime(), viewer.getSelectionBegin())); ThreadEntry threadEntry = (ThreadEntry) callStackEntry.getParent(); int quark = ss.getParentAttributeQuark(callStackEntry.getQuark()); ITmfStateInterval stackInterval = ss.querySingleState(time, quark); long newTime = stackInterval.getEndTime() + 1; viewer.setSelectedTimeNotify(newTime, true); stackInterval = ss.querySingleState(Math.min(ss.getCurrentEndTime(), newTime), quark); int stackLevel = stackInterval.getStateValue().unboxInt(); ITimeGraphEntry selectedEntry = threadEntry.getChildren().get(Math.max(0, stackLevel - 1)); getTimeGraphCombo().setSelection(selectedEntry); viewer.getTimeGraphControl().fireSelectionChanged(); startZoomThread(viewer.getTime0(), viewer.getTime1()); } catch (TimeRangeException | StateSystemDisposedException | StateValueTypeException e) { Activator.getDefault().logError(""Error querying state system"", e); } } } }; fNextEventAction.setText(Messages.TmfTimeGraphViewer_NextStateChangeActionNameText); fNextEventAction.setToolTipText(Messages.TmfTimeGraphViewer_NextStateChangeActionToolTipText); fNextEventAction.setImageDescriptor(Activator.getDefault().getImageDescripterFromPath(ITmfImageConstants.IMG_UI_NEXT_EVENT)); } return fNextEventAction; }","For this view, I wonder if it would not be better to call it ""Select Previous/Next Stack Event""? The actions in this view are modified so that you ""walk up/down the stack""."
"private boolean validateSurl(String surlString) { TSURL surl; if(!SurlValidator.valid(surlString)){ validationResponse = Response.status(400).entity(""Invalid surl\n\n"").build(); return false; } try { surl = TSURL.makeFromStringValidate(surlString); } catch (InvalidTSURLAttributesException e) { validationResponse = Response.status(400).build(); return false; } try { stori = NamespaceDirector.getNamespace().resolveStoRIbySURL(surl); } catch (UnapprochableSurlException e) { log.warn(""Unable to build a stori for surl "" + surl + "" UnapprochableSurlException: "" + e.getMessage()); return false; } return true; }",and the same for the surl.
"protected void startScan() { removeOlderResults(getTimestampOfLastScan(), null); logger.trace(""Starting Discovery""); List<String> networkIPs = getScannableIPs(); scannedIPcount = 0; networkIPs.add(0, ""127.0.0.1""); final int totalScans = networkIPs.size() * 2; MqttBrokerConnection o[]; try { o = createTestConnections(networkIPs); } catch (ConfigurationException e) { logger.debug(""Could not create MqttBrokerConnection object"", e); stopScan(); return; } for (MqttBrokerConnection c : o) { scheduler.execute(() -> { Thread.currentThread().setName(""Discovery thread "" + c.getHost() + "":"" + String.valueOf(c.getPort())); try { scanTarget(c); } catch (ConfigurationException | MqttException | InterruptedException e) { logger.trace(""Scan of {} failed"", c.getHost() + "":"" + String.valueOf(c.getPort())); } stopScanIfAllScanned(totalScans); }); } }",change to fully parameterised logging
"public void setupLibraryBreadCrumbsForImportProjects(final String repositoryUrl) { breadcrumbs.clearBreadcrumbs(LibraryPlaces.LIBRARY_PERSPECTIVE); breadcrumbs.addBreadCrumb(LibraryPlaces.LIBRARY_PERSPECTIVE, translationUtils.getOrganizationalUnitAliasInPlural(), () -> goToOrganizationalUnits()); breadcrumbs.addBreadCrumb(LibraryPlaces.LIBRARY_PERSPECTIVE, projectContext.getActiveOrganizationalUnit() .orElseThrow(() -> new IllegalStateException(""Cannot create library breadcrumb without active organizational unit."")) .getName(), () -> goToLibrary()); breadcrumbs.addBreadCrumb(LibraryPlaces.LIBRARY_PERSPECTIVE, ts.getTranslation(LibraryConstants.ImportProjects), () -> goToImportProjects(repositoryUrl)); }","I'd prefer if the message used ""space"" instead of ""organizational unit"" even though the class names still contain ""organizational unit"". What do you think about this?"
"public String getAdvertiseNonce() { return CAPABILITY_PUSH_CERT + ""="" + nonceGenerator.createNonce(seed, dirPath, TimeUnit.MILLISECONDS .toSeconds(System.currentTimeMillis())); }",save the nonce here in sentNonce?
"public Iterable<ProjectState> parents() { return new Iterable<ProjectState>() { @Override public Iterator<ProjectState> iterator() { Iterator<ProjectState> i = tree().iterator(); Preconditions.checkState( i.hasNext() && i.next() == ProjectState.this, ""skip starting ProjectState""); return i; } }; }","nit: Iterables.skip(tree(), 1)"
"public void managementClientWithProxy() throws InterruptedException, ServiceBusException { String proxyHostName = ""127.0.0.1""; int proxyPort = 8888; final ProxySelector systemDefaultSelector = ProxySelector.getDefault(); ProxySelector.setDefault(new ProxySelector() { @Override public List<Proxy> select(URI uri) { if (uri != null && uri.getHost() != null ) { List<Proxy> proxies = new LinkedList<>(); proxies.add(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHostName, proxyPort))); return proxies; } return systemDefaultSelector.select(uri); } @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe){ if (uri == null || sa == null || ioe == null) { throw new IllegalArgumentException(""Arguments can't be null.""); } systemDefaultSelector.connectFailed(uri, sa, ioe); } }); URI namespaceEndpointURI = TestUtils.getNamespaceEndpointURI(); ClientSettings managementClientSettings = TestUtils.getManagementClientSettings(); ManagementClient managementClient = new ManagementClient(namespaceEndpointURI, managementClientSettings); String queueName = ""proxy"" + UUID.randomUUID().toString().substring(0, 8); QueueDescription q = new QueueDescription(queueName); QueueDescription qCreated = managementClient.createQueue(q); Assert.assertEquals(q, qCreated); }",">managementClientWithProxy [](start = 16, length = 25) You can ignore this test. The CI/CD machine doens't have a proxy server and hence this won't run there."
"private static Authorizer getAuthorizer(TimelockAuthConfiguration authConfiguration) { Map<AuthenticatedClient, Privileges> privilegesMap = authConfiguration.privileges().stream() .collect(Collectors.toMap(p -> AuthenticatedClient.create(p.id()), PrivilegesConfiguration::privileges)); return SimpleAuthorizer.of(privilegesMap, AuthRequirement.PRIVILEGE_BASED); }","extract out AuthRequirement.PRIVLEGE_BASED into a constant explaining that this is what makes timelock 0.x, 1.x etc."
"private void propagatePartitionErrorToPrestoException(String databaseName, String tableName, List<PartitionError> partitionErrors) { if (partitionErrors != null && !partitionErrors.isEmpty()) { ErrorDetail errorDetail = partitionErrors.get(0).getErrorDetail(); String glueExceptionCode = errorDetail.getErrorCode(); switch (glueExceptionCode) { case ""AlreadyExistsException"": throw new PrestoException(StandardErrorCode.ALREADY_EXISTS, errorDetail.getErrorMessage()); case ""EntityNotFoundException"": throw new TableNotFoundException(new SchemaTableName(databaseName, tableName), errorDetail.getErrorMessage()); default: throw new PrestoException(HIVE_METASTORE_ERROR, errorDetail.getErrorCode() + "": "" + errorDetail.getErrorMessage()); } } }",Static import ALREADY_EXISTS
public String getBranchPath(ServiceProvider context) { if (branchPath == null) { CodeSystemVersionSearchRequestBuilder versionSearch = CodeSystemRequests.prepareSearchCodeSystemVersion() .one() .filterByCodeSystemShortName(codeSystem.getShortName()); if (uri.isHead()) { branchPath = codeSystem.getBranchPath(); } else { if (uri.isLatest()) { versionSearch.sortBy(SearchResourceRequest.SortField.descending(CodeSystemVersionEntry.Fields.EFFECTIVE_DATE)); } else { versionSearch.filterByVersionId(uri.getPath()); } branchPath = versionSearch .build(codeSystem.getRepositoryUuid()) .getRequest() .execute(context) .stream() .findFirst() .map(CodeSystemVersionEntry::getPath) .orElse(codeSystem.getRelativeBranchPath(uri.getPath())); } } return branchPath; },The code system version search request is only used in the else block below; move the local variable declaration inside the block.
"public void savePlannedVisitDates(String subjectId, LocalDate primeVaccinationDate) { Subject subject = subjectDataService.findSubjectBySubjectId(subjectId); validateDate(subjectId, primeVaccinationDate); if (subject == null) { throw new VisitScheduleException(String.format(""Cannot save Planned Dates, because Participant with Id: %s not found"", subjectId)); } if (subject.getVisits() == null || subject.getVisits().isEmpty()) { throw new VisitScheduleException(String.format(""Cannot save Planned Dates, because Participant with Id: %s has no Visits"", subjectId)); } if (subject.getPrimerVaccinationDate() != null) { throw new VisitScheduleException(String.format(""Cannot save Planned Dates, because Participant with Id: %s has been vaccinated"", subjectId)); } visitBookingDetailsService.createOrUpdate(calculatePlannedDates(subject.getVisits(), primeVaccinationDate).values()); }",move this to calculatePlannedDates
"private SQLException receiveErrorResponse() throws IOException { int elen = pgStream.receiveInteger4(); EncodingPredictor.DecodeResult totalMessage = pgStream.receiveErrorString(elen - 4); ServerErrorMessage errorMsg = new ServerErrorMessage(totalMessage); if (LOGGER.isLoggable(Level.FINEST)) { LOGGER.log(Level.FINEST, "" <=BE ErrorMessage({0})"", errorMsg.toString()); } PSQLException error; if (errorMsg.getMessage() != null && errorMsg.getMessage().endsWith(COPY_ERROR_MESSAGE)) { error = new CopyNotSupportedException(errorMsg); } else { error = new PSQLException(errorMsg); } if (transactionFailCause == null) { transactionFailCause = error; } else { error.initCause(transactionFailCause); } return error; }","Assuming there is a translated string, will this work? This will also check for that string for every PSQLException throw, which doesn't look good from a perspective that CopyNotSupportedException might be throw in a 1% of use cases?"
"public String getLoginFromSessionId(@PathParam(""sessionId"") String sessionId) throws SchedulerRestException, LoginException, NotConnectedRestException { if (sessionId != null && sessionStore.exists(sessionId)) { return sessionStore.get(sessionId).getUserName(); } return """"; }",Is it not better to throw an exception in that case?
"public AbstractRecordAndOffset(final SAMRecord record, final int offset, int length, int refPos) { validateIndex(offset, record.getBaseQualities()); if (length > record.getReadLength()) { throw new IllegalArgumentException(""Block length cannot be larger than whole read length""); } this.offset = offset; this.record = record; this.length = length; this.refPos = refPos; }","confusing name, shouldn't this be validateOffset?"
"public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) { return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (Objects.equals(iface.getQos(), qos) || iface.isQosOverridden()); }","As I stated, the syncness should not be affected by the fact the user decided to override the QoS. It is entirely possible that this will get out of sync even if he decided to put his own QoS definition."
"private void doTaskEnd() { if((this.listenerFailed || this.started) && !this.finished) { this.taskExecution.setEndTime(new Date()); if(this.exitCodeEvent != null) { this.taskExecution.setExitCode(this.exitCodeEvent.getExitCode()); } else if(this.listenerFailed || this.applicationFailedEvent != null){ this.taskExecution.setExitCode(1); } else{ this.taskExecution.setExitCode(0); } if(this.applicationFailedEvent != null) { this.taskExecution.setErrorMessage(stackTraceToString(this.applicationFailedEvent.getException())); } if(this.listenerException != null) { String errorMessage = this.stackTraceToString(this.listenerException); if (StringUtils.hasText(this.taskExecution.getErrorMessage())) { errorMessage = String.format(""%s :Task Also threw this Exception: %s"", errorMessage, this.taskExecution.getErrorMessage()); } this.taskExecution.setErrorMessage(errorMessage); } if(this.listenerFailed && this.taskExecution.getExitCode() != 0) { setMessages(invokeOnTaskError(this.taskExecution, this.listenerException)); } else if (this.applicationFailedEvent != null && this.taskExecution.getExitCode() != 0) { setMessages(invokeOnTaskError(this.taskExecution, this.applicationFailedEvent.getException())); } setMessages(invokeOnTaskEnd(this.taskExecution)); if(this.listenerFailed) { this.taskExecution.setExitCode(1); } this.taskRepository.completeTaskExecution(this.taskExecution.getExecutionId(), this.taskExecution.getExitCode(), this.taskExecution.getEndTime(), this.taskExecution.getExitMessage(), this.taskExecution.getErrorMessage()); this.finished = true; if(this.taskProperties.getClosecontextEnabled() && this.context.isActive()) { this.context.close(); } } else if(!this.started){ logger.error(""An event to end a task has been received for a task that has "" + ""not yet started.""); } }","Should this be hardcoded as 1, a specific value that we specify other than one (to indicate the specific error condition being an exception was thrown via a SCT listener), or should this be the result of any configured ExitCodeGenerator? Where in the lifecycle does the ExitCodeGenerator get called based on this logic?"
"public void shouldRemoveExistingElements() { final Seq<Integer> seq = of(1, 2, 3); assertThat(seq.reject(i -> i == 1)).isEqualTo(of(2, 3)); assertThat(seq.reject(i -> i == 2)).isEqualTo(of(1, 3)); assertThat(seq.reject(i -> i == 3)).isEqualTo(of(1, 2)); assertThat(seq.reject(ignore -> true)).isEmpty(); assertThat(seq.reject(ignore -> false)).isSameAs(seq); }","This test must use exactly removeAll method. It is deprecated, but must be tested too"
private void minimumSleep(long millis) { long nanos = TimeUnit.MILLISECONDS.toNanos(millis); long start = System.nanoTime(); while (true) { long nanosLeft = nanos - (System.nanoTime() - start); if (nanosLeft <= 0) { break; } try { Thread.sleep(TimeUnit.NANOSECONDS.toMillis(nanosLeft)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } } },You can do TimeUnit.NANOSECONDS.sleep(nanosLeft)
"public void test_capabilities_exposed() throws Exception { Capability[] capabilities = consumer.getValueForNode(consumerId, new String[]{""management"", ""clients"", clientIdentifier, ""registry"", ""capabilities""}, Capability[].class); assertThat(capabilities.length, equalTo(5)); assertThat(capabilities[0].getName(), equalTo(""ActionsCapability"")); assertThat(capabilities[1].getName(), equalTo(""StatisticsCapability"")); assertThat(capabilities[2].getName(), equalTo(""StatisticCollectorCapability"")); assertThat(capabilities[3].getName(), equalTo(""SettingsCapability"")); assertThat(capabilities[4].getName(), equalTo(""ManagementAgentService"")); assertThat(capabilities[0].getDescriptors(), hasSize(4)); Collection<Descriptor> descriptors = capabilities[1].getDescriptors(); Collection<Descriptor> allDescriptors = new ArrayList<Descriptor>(); allDescriptors.addAll(StatsUtil.CACHE_DESCRIPTORS); allDescriptors.addAll(StatsUtil.ONHEAP_DESCRIPTORS); allDescriptors.addAll(StatsUtil.OFFHEAP_DESCRIPTORS); allDescriptors.addAll(StatsUtil.CLUSTERED_DESCRIPTORS); assertThat(descriptors, hasSize(allDescriptors.size())); assertThat(descriptors, containsInAnyOrder(allDescriptors.toArray())); assertThat(capabilities[1].getDescriptors(), hasSize(allDescriptors.size())); }",isn't this the same as line 149 ?
"private List<Entity> getEntities(String extensionName, String jobName, InputStream configStream, String extensionType, String extensionBuildLocation) { List<Entity> entities = null; if (!extensionType.equals(ExtensionType.CUSTOM.name())) { try { entities = ExtensionHandler.loadAndPrepare(extensionName, jobName, configStream, extensionBuildLocation); } catch (Exception e) { LOG.error(""Error in building the extension. Cause: "", e); throw new FalconCLIException(""Error in building the extension:"" + e.getMessage(), e); } if (entities == null || entities.isEmpty()) { throw new FalconCLIException(""No entities got built for the given extension""); } } return entities; }",May be you should also log this in OUT stream too as the error might come from the extension builder and the error stack will be easily available to the user.
public void run() { MessageReceiver receiver = new MessageReceiver(mmHandler); while (true) { try { mmReader.readAvailable(receiver); } catch (IOException e) { e.printStackTrace(); break; } catch (Throwable t) { t.printStackTrace(); break; } } stopWriteThread(); disconnect(); },Is there a ticket to add this later? Or will it happen before this code gets pulled in?
public void shouldExecute() throws Exception { Assert.assertTrue(this.mocker.getComponentUnderTest().shouldExecute(new XWikiDBVersion(54689))); Assert.assertTrue(this.mocker.getComponentUnderTest().shouldExecute(new XWikiDBVersion(54693))); },"These numbers are copy/pasted, change them to 71500 and 71510."
"public boolean isVolumeEmpty(String volume) throws IOException { String volumePrefix = getVolumeKey(volume + OM_KEY_PREFIX); if (bucketTable instanceof TypedTable) { Iterator<Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>>> iterator = ((TypedTable< String, OmBucketInfo>) bucketTable).cacheIterator(); while (iterator.hasNext()) { Map.Entry< CacheKey< String >, CacheValue< OmBucketInfo > > entry = iterator.next(); String key = entry.getKey().getKey(); OmBucketInfo omBucketInfo = entry.getValue().getValue(); if (key.startsWith(volumePrefix) && omBucketInfo != null) { return false; } } } try (TableIterator<String, ? extends KeyValue<String, OmBucketInfo>> bucketIter = bucketTable.iterator()) { KeyValue<String, OmBucketInfo> kv = bucketIter.seek(volumePrefix); if (kv != null && kv.getKey().startsWith(volumePrefix)) { return false; } } return true; }",When will this check be false?
"private void backUpCompactionPolicyInfo(String dataDir, CompactionPolicySwitchInfo compactionPolicySwitchInfo) { if (dataDir != null && !dataDir.isEmpty()) { File tempFile = new File(Paths.get(dataDir, COMPACT_POLICY_INFO_PATH).toString()); try { tempFile.createNewFile(); objectMapper.defaultPrettyPrintingWriter().writeValue(tempFile, compactionPolicySwitchInfo); } catch (IOException e) { logger.error(""Exception while store compaction policy info for local report. Output file path - {}"", tempFile.getAbsolutePath(), e); } } }","nit: I encourage to create and write data to a temporary file and then rename the temporary file to COMPACT_POLICY_INFO_PATH file Something like  File tempFile = new File(dataDir, COMPACT_POLICY_INFO_PATH + "".temp""); if (!tempFile.exists()) { tempFile.createNewFile(); } objectMapper.defaultPrettyPrintingWriter().writeValue(tempFile, compactionPolicySwitchInfo); tempFile.renameTo(new File(dataDir, COMPACT_POLICY_INFO_PATH);  The reason to use a temporary file and rename it after is that POSIX guarantees file rename is an atomic operation, but not the file write. The json file is pretty small so that file writing should be atomic, but it's just a good pattern to follow."
"protected DiskProfiles mapCollection(List<org.ovirt.engine.core.common.businessentities.profiles.DiskProfile> entities) { DiskProfiles collection = new DiskProfiles(); Map<Guid, List<Qos>> qosMap = new HashMap<>(); for (org.ovirt.engine.core.common.businessentities.profiles.DiskProfile entity : entities) { DiskProfile profile = populate(map(entity), entity); collection.getDiskProfiles().add(profile); if (entity.getQosId() != null) { List<Qos> qosList = qosMap.get(entity.getQosId()); if (qosList == null) { qosList = new ArrayList<>(); qosMap.put(entity.getQosId(), qosList); } qosList.add(profile.getQos()); } } handleQosDataCenterLinks(qosMap); for (DiskProfile diskProfile : collection.getDiskProfiles()) { addLinks(diskProfile); } return collection; }",consider using putIfAbsent
"public byte[] getBinary(int ordinal) { BytesColumnVector.Bytes byteArray = getByteArray(ordinal); if (byteArray.len == byteArray.data.length) { return byteArray.data; } else { byte[] ret = new byte[byteArray.len]; System.arraycopy(byteArray.data, byteArray.offset, ret, 0, byteArray.len); return ret; } }",Can we use Arrays.copyOfRange?
"public void testQueryNameDisplayable() { String test = ""select * from employee e (where e.id <> 0 and e.name ='foo' and e.other != 'other'""; long start = System.currentTimeMillis(); for ( int looper = 0; looper < 500000; looper ++) { QueryName name = new QueryName(test); } long end = System.currentTimeMillis(); long duration = (end - start); Assert.assertTrue(""Duration of QueryName.displayable called in a 500000 loop must be lower than 3000 milliseconds, but was "" + duration, duration < 3000); }","git grep TimeoutUtil on wildfly repo shows quite many usages, feel free to get inspired there too."
"public void Export_SerializerConfig() { exporter.setTargetFolder(new File(""target/gen7"")); exporter.setSerializerConfig(new SimpleSerializerConfig(true, true, true, true, """")); exporter.export(Cat.class.getPackage()); }",Shouldn't there be an assertion here?
"public DruidServerMetadata getMetadata(@Self DruidNode node, DruidServerConfig config) { return new DruidServerMetadata( node.getHost(), node.getHost(), config.getMaxSize(), config.getType(), config.getTier() ); }","This should be hard-coded, not configuration. You can make it a constructor parameter on the Module."
"public void onConnected(Session session) { Log.d(TAG, ""onConnected: Connected to session "" + session.getSessionId()); CustomVideoCapturer capturer = new CustomVideoCapturer(MainActivity.this, Publisher.CameraCaptureResolution.MEDIUM, Publisher.CameraCaptureFrameRate.FPS_30); capturer.setCustomVideoCapturerDataSource(new CustomVideoCapturer.CustomVideoCapturerDataSource() { @Override public byte[] retrieveMetadata() { return getCurrentTimeStamp().getBytes(); } }); InvertedColorsVideoRenderer renderer = new InvertedColorsVideoRenderer(MainActivity.this); renderer.setInvertedColorsVideoRendererMetadataListener(new InvertedColorsVideoRenderer.InvertedColorsVideoRendererMetadataListener() { @Override public void onMetadataReady(byte[] metadata) { String timestamp = null; try { timestamp = new String(metadata, ""UTF-8""); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } System.out.println(timestamp); } }); mPublisher = new Publisher.Builder(MainActivity.this) .name(""publisher"") .capturer(capturer) .renderer(renderer).build(); mPublisher.setPublisherListener(this); mPublisher.setStyle(BaseVideoRenderer.STYLE_VIDEO_SCALE, BaseVideoRenderer.STYLE_VIDEO_FILL); mPublisherViewContainer.addView(mPublisher.getView()); if (mPublisher.getView() instanceof GLSurfaceView) { ((GLSurfaceView)(mPublisher.getView())).setZOrderOnTop(true); } mSession.publish(mPublisher); }",I know that our current custom renderer is InvertedColorsVideoRenderer... but it feels a lot strange to use it here. wdyt? I'm thiking on changing the Custom-Video-Driver sample to have a CustomRenderer and this Inverted too. This sample will use the CustomRenderer (without inversion).
"protected String doIt() throws Exception { final EDIExportStatus targetExportStatus = EDIExportStatus.ofCode(p_TargetExportStatus); for (final ArchiveId logId : getSelectedDocOutboundLogIds()) { ChangeEDI_ExportStatusHelper.C_DocOutbound_LogDoIt(targetExportStatus, logId); } return MSG_OK; }",ArchiveId shall not be used for C_Doc_OutBound_Log_ID. (note that we have a dedicated AD_Archive table that is also *referenced* by C_Doc_Outbound_Log_Line)
"public void testEquals() throws Exception { Map<String, Object> map = new HashMap<>(); map.put(""a"", ""aval""); map.put(""b"", ""bval""); IotasEvent event1 = new IotasEventImpl(map); IotasEvent event2 = new IotasEventImpl(map, event1.getId()); assertEquals(event1, event2); }","if we are writing test for equals, for consistency we should probably write test for hasCode() has well."
"protected String getProbeSetName() { if (BAIT_SET_NAME != null) { return BAIT_SET_NAME; } if (BAIT_INTERVALS.size() == 1) { return CollectTargetedMetrics.renderProbeNameFromFilename(BAIT_INTERVALS.get(0)); } else { throw new PicardException(""Cannot infer BAIT_SET_NAME because there is not exactly one BAIT_INTERVALS provided.""); } }",Isn't throwing an exception here just punting? You could loop over the files and render name1+name2+name3... which would be friendlier.
"public void initShaders() { defaultShaderProgram = prepareAndStoreShaderProgramInstance(""default"", new ShaderParametersDefault()); defaultTexturedShaderProgram = prepareAndStoreShaderProgramInstance(""defaultTextured"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""post"", new ShaderParametersPost()); prepareAndStoreShaderProgramInstance(""ssao"", new ShaderParametersSSAO()); prepareAndStoreShaderProgramInstance(""lightShafts"", new ShaderParametersLightShafts()); prepareAndStoreShaderProgramInstance(""sobel"", new ShaderParametersSobel()); prepareAndStoreShaderProgramInstance(""initialPost"", new ShaderParametersInitialPost()); prepareAndStoreShaderProgramInstance(""prePostComposite"", new ShaderParametersPrePostComposite()); prepareAndStoreShaderProgramInstance(""highp"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""blur"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""down"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""hdr"", new ShaderParametersHdr()); prepareAndStoreShaderProgramInstance(""sky"", new ShaderParametersSky()); prepareAndStoreShaderProgramInstance(""chunk"", new ShaderParametersChunk()); prepareAndStoreShaderProgramInstance(""particle"", new ShaderParametersParticle()); prepareAndStoreShaderProgramInstance(""block"", new ShaderParametersBlock()); prepareAndStoreShaderProgramInstance(""shadowMap"", new ShaderParametersShadowMap()); prepareAndStoreShaderProgramInstance(""debug"", new ShaderParametersDebug()); prepareAndStoreShaderProgramInstance(""ocDistortion"", new ShaderParametersOcDistortion()); prepareAndStoreShaderProgramInstance(""lightBufferPass"", new ShaderParametersLightBufferPass()); prepareAndStoreShaderProgramInstance(""lightGeometryPass"", new ShaderParametersLightGeometryPass()); prepareAndStoreShaderProgramInstance(""simple"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""ssaoBlur"", new ShaderParametersDefault()); prepareAndStoreShaderProgramInstance(""newParticle"", new ShaderParametersNewParticle()); }","In line with flo's suggestion, this system should replace the existing system. As such there is no need to call its shader ""newParticle"". Instead, call it for what it is. DefaultParticleSprites for example."
"public boolean run(CommandSender sender, Player playerSender, Command cmd, String commandLabel, String[] args, boolean senderIsConsole) { if (DisallowedDisguises.disabled) { msg(""Disguises are not enabled.""); return true; } FUtil.adminAction(sender.getName(), ""Undisguising all non-admins"", true); plugin.ldb.undisguiseAll(false); return true; }",Won't this throw an error when LibsDisguises is not enabled on the server? You could instead check if ldb.getLibsDisguisePlugin() is null or not.
"public Optional<GradleBuild> getGradleBuild(IProject project) { try { if (GradleProjectNature.isPresentOn(project)) { ProjectConfiguration projectConfiguration = CorePlugin.configurationManager().loadProjectConfiguration(project); BuildConfiguration buildConfig = projectConfiguration.getBuildConfiguration(); return Optional.<GradleBuild>of(new DefaultGradleBuild(buildConfig)); } else { return Optional.absent(); } } catch (RuntimeException e) { CorePlugin.logger().debug(""Cannot load configuration for project "" + project.getName()); return Optional.absent(); } }",This should be encapsulated instead of spreading the error handling in multiple places. E.g. tryLoad
"public static String getParameterOrDefaultValue(ParameterCore key) { if (Objects.nonNull(key.getType())) { if (key.getType().equals(String.class)) { return getParameter(key.getName(), (String) key.getDefaultValue()); } throw new ConfigParameterException(key.getName(), ""String""); } throw new ConfigParameterException(""Type of key is null""); }",I would suggest to output the name of key which is null because without this it could be difficult to fix it.
"private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) { if (_vdsManager.getbeforeFirstRefresh()) { boolean flagsChanged = false; final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean(); _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds); flagsChanged = processHardwareCapsNeededTemp.get(); _vdsManager.setbeforeFirstRefresh(false); refreshedCapabilities = true; _saveVdsDynamic = true; processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged; } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) { return; } if (_vds.getStatus() != VDSStatus.Up) { AuditLogableBase logable = new AuditLogableBase(_vds.getId()); logable.addCustomValue(""VdsStatus"", _vds.getStatus().toString()); auditLog(logable, AuditLogType.VDS_DETECTED); } }","Martin, why can't we just have the audit log you added at InitiVdsOnUp, and that's it ? isn't this logging redundant?"
"public boolean match(Double outputValue, Double correctValue) { try { double a = outputValue; double b = correctValue; if (Double.isNaN(a) && Double.isNaN(b)) { return true; } else if (Double.isInfinite(a) && Double.isInfinite(b) && a * b < 0) { return true; } else if (Math.abs(a - b) < COMPARISON_THRESHOLD * a) { return true; } return false; } catch(NumberFormatException e) { return false; } }","Are two infinite values not comparable using ==? I believe the multiplication should yield a positive number if the signs are equal (a * b > 0). Better yet, check the signs more explicitly (I assume this works for pos/neg infinity): Math.signum(a) == Math.signum(b)."
"public void testCorrect() throws Exception { final String expected = new String(Files.readAllBytes(Paths.get( getPath(""ExpectedSuppressionsStringPrinter.txt""))), StandardCharsets.UTF_8).replaceAll(""\\\\r\\\\n"", ""\\\\n""); final File input = new File(getPath(""InputSuppressionsStringPrinter.java"")); final String lineAndColumnNumber = ""3:1""; final int tabWidth = 2; final String result = SuppressionsStringPrinter.printSuppressions(input, lineAndColumnNumber, tabWidth); Assert.assertEquals(""Invalid xpath queries"", expected, result); }","we put Expected to file only if it is huge to be embedded. I do not see your expected output as huge. If there was some previous discussion .. please give me a link to it to review. If no discussions before, please inline expected to UT method."
"Set<InetSocketAddress> maybeFilterLocalHosts(Set<InetSocketAddress> hosts) { if (new Random().nextDouble() < config.localHostWeighting()) { Set<InetSocketAddress> localFilteredHosts = Sets.intersection(localHosts, hosts); if (!localFilteredHosts.isEmpty()) { localHostsSelected.inc(); return localFilteredHosts; } } randomHostsSelected.inc(); return hosts; }",make this Random be a field - no need to create a new one for each usage
"public Schema apply(Schema originalSchema) throws SchemaSyncError { Schema newSchema = originalSchema.copy(); Database database = findDatabase(newSchema, dbName, ifExists); if ( database == null && !ifExists ) { throw new SchemaSyncError(""Can't drop missing database: "" + dbName); } newSchema.getDatabases().remove(database); return newSchema; }",nitpic: The interchanging usage of findDatabase within SchemaChange and within Schema is confusing.
"public PagedFlux<SecretBase> listSecretVersions(String name) { return new PagedFlux<>(() -> listSecretVersionsFirstPage(name), continuationToken -> listSecretsNextPage(continuationToken)); }",The logging messages with listSecretsNextPage will not be consistent with listSecretVersionsFirstPage
public void init(ComponentRegistry componentRegistry) { if (encodingClasses != null) { componentRegistry.wireDependencies(this); } if (encodingClasses != null) { componentRegistry.wireDependencies(this); } },wiring twice?
"public List<String> getAllTables(String dbname) throws MetaException, IOException { try { return getHive().getAllTables(dbname); } catch (TException e) { mHive = newHiveClient(); return getHive().getAllTables(dbname); } }","instead of just calling it twice, can we have a retry loop?"
public void validate(GlobalConfiguration globalConfig) { Attribute<String> location = attributes.attribute(LOCATION); if (location.isNull() && !globalConfig.globalState().enabled()) { Log.CONFIG.storeLocationRequired(); } super.validate(globalConfig); },We can remove this as the error will always be thrown on startup via PersistenceUtil#getLocation.
"public void run() { try { listener = new ServerSocket(port); while (true) { socket = listener.accept(); outStr = new DataOutputStream(socket.getOutputStream()); while (socket.getInputStream() .read() != -1) { testRunSession = new TestRunSessionAndPort(launch, project); outStr.writeInt(testRunSession.getPort()); } } } catch (SocketException se) { logger.logInfo(""Connection to tester terminated"", se); } catch (IOException e) { logger.logError(""Error communicating to the tester"", e); } close(); }",So the only way out of this loop is throwing an exception? That seems like poor flow control.
protected List<Object> getModelChildren() { ArrayList<Object> elements = new ArrayList<>(); elements.add(new InstanceName(getModel())); elements.addAll(getModel().getInterface().getAllInterfaceElements()); return elements; },List<Object>
"public FormattingModel createModel(@NotNull PsiElement element, @NotNull CodeStyleSettings settings) { if (settings.getIndentOptions() != null) { settings.getIndentOptions().USE_TAB_CHARACTER = true; settings.getIndentOptions().SMART_TABS = false; } Block block = new GoFormattingBlock(element.getNode(), null, Indent.getNoneIndent(), null, settings, createSpacingBuilder(settings)); return FormattingModelProvider.createFormattingModelForPsiFile(element.getContainingFile(), block, settings); }",GoLanguageCodeStyleSettingsProvider should be used for setting default values
"public int openDocument(ParcelFileDescriptor source) throws RemoteException { synchronized (mLock) { while(mRenderer != null) { try { mLock.wait(); } catch (InterruptedException e) { } } try { throwIfOpened(); if (DEBUG) { Log.i(LOG_TAG, ""openDocument()""); } mEditor = new PdfEditor(source); return mEditor.getPageCount(); } catch (IOException | IllegalStateException e) { IoUtils.closeQuietly(source); Log.e(LOG_TAG, ""Cannot open file"", e); throw new RemoteException(e.toString()); } } }",minor code style nit: you're missing a space after '(' here and in line 87.
public static MessageType getMessageType(String line) { for (MessageType msgType : MessageType.values()) { if (line.startsWith(msgType.getMessageIndicator())) { return msgType; } } return null; },this MessageType getMessageType is more or less duplicate of the message.getType() is this really needed?
"public void testReconfigure() throws InterruptedException { RepositoryCache.register(db); assertTrue(RepositoryCache.isCached(db)); db.close(); assertTrue(RepositoryCache.isCached(db)); RepositoryCacheConfig config = new RepositoryCacheConfig(); config.setExpireAfter(1); config.setCleanupDelay(1); config.install(); int t = 1; for (int i = 0; i <= 10; i++) { Thread.sleep(t); if (!RepositoryCache.isCached(db)) { return; } t = t * 2; } fail(""Repository should have been evicted from cache""); }",instead we could use for (int i = 0; i <= 10; i++) { Thread.sleep(1 << i); if (!RepositoryCache.isCached(db)) { return; } }
"public String deleteExtensionMetadata(final String extensionName) throws StoreAccessException{ ExtensionType extensionType = AbstractExtension.isExtensionTrusted(extensionName) ? ExtensionType.TRUSTED : ExtensionType.CUSTOM; if (extensionType.toString().equalsIgnoreCase(ExtensionType.TRUSTED.toString())){ throw new StoreAccessException(new Exception(extensionName + "" is trusted cannot be deleted."")); } if (metaStore.checkIfExtensionExists(extensionName)) { metaStore.deleteExtensionMetadata(extensionName); return ""Deleted entry for:"" + extensionName; }else { return ""Extension:"" + extensionName + "" is not registered with falcon.""; } }",Nit : No need to create new Exception. You can directly create StoreAccessException
"public void visitNode(Tree tree) { if (!hasSemantic()) { return; } if (tree.is(SYNCHRONIZED_STATEMENT)) { SynchronizedStatementTree synchronizedTree = (SynchronizedStatementTree) tree; if (synchronizedTree.expression().is(METHOD_INVOCATION)) { MethodInvocationTree synchronizedExpr = (MethodInvocationTree) synchronizedTree.expression(); if (GET_CLASS_MATCHER.matches(synchronizedExpr) && !isEnclosingClassFinal(synchronizedExpr.methodSelect())) { reportIssue(synchronizedExpr, ""Synchronize on the static class name instead.""); } } } }",no need for that if.
"private void assertIndexMatchesVals(IndexedFloats indexed, float[] vals) { Assert.assertEquals(vals.length, indexed.size()); int[] indices = new int[vals.length]; for (int i = 0; i < indexed.size(); ++i) { Assert.assertEquals(vals[i], indexed.get(i), DELTA); indices[i] = i; } IntArrays.shuffle(indices, new Random()); final int limit = Math.min(indexed.size(), 1000); for (int i = 0; i < limit; ++i) { int k = indices[i]; Assert.assertEquals(vals[k], indexed.get(k), DELTA); } }","ThreadLocalRandom.current(), and same at other places."
"public void addParam(String key, String value) { if (parameters.containsKey(key)) { throw new IllegalArgumentException(); } if (hasParameterBefore) { builder.append(""&""); } else { hasParameterBefore = true; } try { builder.append(key).append(""="").append(URLEncoder.encode(value, ""UTF-8"")); } catch (UnsupportedEncodingException e) { throw rethrow(e); } parameters.put(key, value); }",Can you please add a proper exception message?
public void resumeFormEntry() { saveResult = new MutableLiveData<>(null); },"In my head this needs to be saveResult.setValue(null) instead. Otherwise saving multiple times won't work for observations made in onCreate of an Activity/Fragment as they'll be observing a different LiveData value. Maybe I'm reading this wrong! We can verify with a test for the ViewModel: java @Test public void resumeFormEntry_clearsSaveResult() { LiveData<FormSaveViewModel.SaveResult> saveResult = viewModel.getSavedResult(); viewModel.saveForm(Uri.parse(""file://form""), true, """", false); viewModel.resumeFormEntry(); assertThat(saveResult.getValue(), equalTo(null)); }"
"private SortedPositionLinks(PositionLinks positionLinks, int[][] sortedPositionLinks, List<JoinFilterFunction> searchFunctions) { this.positionLinks = requireNonNull(positionLinks, ""positionLinks is null""); this.sortedPositionLinks = requireNonNull(sortedPositionLinks, ""sortedPositionLinks is null""); this.sizeInBytes = INSTANCE_SIZE + positionLinks.getSizeInBytes() + sizeOfPositionLinks(sortedPositionLinks); checkState(!searchFunctions.isEmpty(), ""Using sortedPositionLinks with no search functions""); this.searchFunctions = requireNonNull(searchFunctions, ""searchFunctions is null""); }","rNN is ineffective, as you'd have NPE on preceding line"
"public void dropIndex(final String schemaName, String idxName, boolean ifExists) throws IgniteCheckedException{ String sql = H2Utils.indexDropSql(schemaName, idxName, ifExists); GridH2Table tbl = dataTableForIndex(schemaName, idxName); tbl.setRemoveIndexOnDestroy(true); connMgr.executeStatement(schemaName, sql); }",assert tbl != null?
"public Repo<Master> call(long tid, Master master) throws Exception { VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironment(tableInfo.tableId); String baseDir = master.getFileSystem().choose(chooserEnv, ServerConstants.getBaseUris()) + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + tableInfo.tableId; tableInfo.dir = baseDir + Constants.DEFAULT_TABLET_LOCATION; if (tableInfo.initialSplitSize > 0) { createTableDirectoriesInfo(master, baseDir); } return new CreateDir(tableInfo); }","Looking at this, I wonder if the volume chooser should be called for each tablet. Not sure, need to investigate. I can look into this. Could also be a follow on issue."
"public boolean apply(Game game, Ability source) { Player controller = game.getPlayer(source.getControllerId()); Player opponent = game.getPlayer(this.getTargetPointer().getFirst(game, source)); if (opponent != null) { int xValue = opponent.getHand().size() - controller.getHand().size(); if (xValue > 0) { opponent.loseLife(xValue, game, false); } return true; } return false; }",add a check that the controller != null
"public static double[] rgbToHSL(RGB rgb) { double r = rgb.red / 255.D; double g = rgb.green / 255.D; double b = rgb.blue / 255.D; double max = Math.max(Math.max(r, g), b); double min = Math.min(Math.min(r, g), b); double[] hsl = new double[] { 0, 0, (max + min) / 2 }; if (max != min) { double delta = max - min; if (hsl[2] <= 0.5) { hsl[1] = (delta / (max + min)); } else { hsl[1] = (delta / (2.0 - (max + min))); } if (r == max) { hsl[0] = (g - b) / delta; } else if (g == max) { hsl[0] = 2.0 + ((b - r) / delta); } else if (b == max) { hsl[0] = 4.0 + ((r - g) / delta); } hsl[0] *= 60.0; if (hsl[0] < 0.0) { hsl[0] += 360.0; } } return hsl; }",should we extract that to a a constant MaxRGBValue
"public static String appendIfNotEmpty(final String str, final String suffix) { return isEmpty(str) ? EMPTY : str + defaultString(suffix); }",suggestion return isEmpty(str) ? str : str + defaultString(suffix);
"protected PatternBasedElementProcessor newProcessor() { return new PatternBasedElementProcessor() { @Override public void emit() { Attributes attributes = new Attributes(); SpanType span = SpanType.SPAN; String cssClass = group(1); if (cssClass != null && !cssClass.isEmpty()) { attributes.setCssClass(cssClass); } else { span = SpanType.HIGHLIGHT; } getBuilder().beginSpan(span, attributes); getBuilder().characters(group(2)); getBuilder().endSpan(); } }; }",Why highlight by default? Is that normal behaviour for AsciiDoc?
private boolean isAffectedBy(IResourceDelta delta) { if (delta.getKind() != IResourceDelta.CHANGED) return true; int flags = delta.getFlags(); if (flags != 0 && flags != IResourceDelta.MARKERS) return true; IResourceDelta[] children = delta.getAffectedChildren(); for (IResourceDelta child : children) { if (isAffectedBy(child)) return true; } return false; },Please consider reimplementing this with <LINK_0> Please always use curly braces.
"public String any() { String[] relationships = new String[] {""direct"", ""extended"", ""in_law"", ""spouse"", ""parent"", ""sibling""}; int idx = faker.random().nextInt(relationships.length); String methodName = relationships[idx]; try { Method m = Relationships.class.getMethod(methodName); Relationships relInstance = new Relationships(faker); return (String)m.invoke(relInstance); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return null; }",couldn't you get a list of declaredMethods and exclude any? instead defining your own list of method names
"public boolean isVerbose() { Logger log = Logger.getLogger(""com.google.devtools.j2objc""); return log != null && log.getLevel() != null && log.getLevel().equals(Level.FINEST); }","An easier way to test for null is to reverse the equals, as the constant should always be non-null:  return log != null && Level.FINEST.equals(log.getLevel());"
"public String decodeMessage(KM200Device device, byte[] encoded) { String retString = null; byte[] decodedB64 = null; try { decodedB64 = Base64.getMimeDecoder().decode(encoded); } catch (IllegalArgumentException e) { logger.error(""Message is not in valid Base64 scheme:"" + e.getMessage()); e.printStackTrace(); } try { if ((decodedB64.length & 0xF) != 0) { retString = new String(decodedB64, device.getCharSet()); return retString; } final Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding""); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(device.getCryptKeyPriv(), ""AES"")); final byte[] decryptedData = cipher.doFinal(decodedB64); byte[] decryptedDataWOZP = removeZeroPadding(decryptedData); retString = new String(decryptedDataWOZP, device.getCharSet()); return retString; } catch (BadPaddingException | IllegalBlockSizeException | UnsupportedEncodingException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) { logger.error(""Exception on encoding:"" + e.getMessage()); return null; } catch (final GeneralSecurityException e) { throw new IllegalStateException(""Algorithms or unlimited crypto files not available"", e); } }",Use parameterized logging instead of string concatenation
public static long localTime(ConnectorSession session) { return UTC_CHRONOLOGY.millisOfDay().get(session.getStartTime()); },This is not obvious that this one commit _introduces_ legacy semantics -- i.e. localTime implemented _new_ TIME semantics and in this commit it implements _legacy_ just to be fixed ~3 commits later.
"private void recreateUserVmSeach(NetworkVO network) { if (network != null) { SearchBuilder<NicVO> nicSearch = _nicDao.createSearchBuilder(); nicSearch.and(""networkId"", nicSearch.entity().getNetworkId(), SearchCriteria.Op.EQ); nicSearch.and(""removed"", nicSearch.entity().getRemoved(), SearchCriteria.Op.NULL); if (!network.getGuestType().equals(Network.GuestType.L2)) { nicSearch.and().op(""ip4Address"", nicSearch.entity().getIPv4Address(), SearchCriteria.Op.NNULL); nicSearch.or(""ip6Address"", nicSearch.entity().getIPv6Address(), SearchCriteria.Op.NNULL); nicSearch.cp(); } UserVmSearch = createSearchBuilder(); UserVmSearch.and(""states"", UserVmSearch.entity().getState(), SearchCriteria.Op.IN); UserVmSearch.join(""nicSearch"", nicSearch, UserVmSearch.entity().getId(), nicSearch.entity().getInstanceId(), JoinBuilder.JoinType.INNER); UserVmSearch.done(); } }","Can the method getGuestType return Null? If not, the code is ok. Otherwise, it might be more interesting to do Network.GuestType.L2.equals(network.getGuestType()) Or even using ==, if it is an enum type, it is ok to use =="
"public void edit(final IscsiStorageModel object) { driver.edit(object); initLists(object); object.getPropertyChangedEvent().addListener((ev, sender, args) -> { String propName = args.propertyName; if (propName.equals(""IsValid"")) { onIsValidPropertyChange(object); } else if (propName.equals(""IsGroupedByTarget"")) { updateListByGrouping(object); } }); iscsiTargetToLunView.edit(object); iscsiLunToTargetView.edit(object); targetsToLunTab.addClickHandler(event -> { iscsiLunToTargetView.disableItemsUpdate(); object.setIsGroupedByTarget(true); }); lunToTargetsTab.addClickHandler(event -> { iscsiTargetToLunView.disableItemsUpdate(); object.setIsGroupedByTarget(false); }); dialogTabPanel.switchTab(object.getIsGroupedByTarget() ? targetsToLunTab : lunToTargetsTab); updateListByGrouping(object); if (!object.getContainer().isNewStorage()) { switch (object.getContainer().getStorage().getStatus()) { case Maintenance: mainLabel.setText(constants.storageIscsiRemoveLUNsLabel()); subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel()); break; case Active: mainLabel.setText(constants.storageIscsiActionsLabel()); subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel()); break; } } if (object.getContainer().isNewStorage()) { dialogTabPanel.setBarStyle(multiSelection ? style.barShort() : style.barNewDisk()); } else { dialogTabPanel.setBarStyle(style.barLong()); } }","Please consider renaming to a more informative name, just as you did with barNewDisk. Maybe barNewDomain?"
"public void checkAttributeValue(PerunSessionImpl perunSession, Facility facility, Attribute attribute) throws InternalErrorException, WrongAttributeValueException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException { if(attribute.getValue() == null) return; String attrValue = (String) attribute.getValue(); Pattern pattern = Pattern.compile(""^[01234567]?[01234567]{3}$""); Matcher match = pattern.matcher(attrValue); if(!match.matches()) throw new WrongAttributeValueException(attribute, facility, ""Bad format of attribute, (expected something like '750' or '0700').""); }",Pattern should be compiled only once. Please move it outside from method.
"public void testFindActivator() throws Exception { Builder bmaker = new Builder(); try { bmaker.setProperty(""Bundle-Activator"", ""test.activator.Activator""); bmaker.setProperty(""build"", ""xyz""); bmaker.setProperty(""Private-Package"", ""test.*""); bmaker.setProperty(""-bundleannotations"", ""!test.annotationheaders.attrs.std.activator.TypeInVersionedPackage""); bmaker.setProperty(""-dsannotations"", ""!*""); bmaker.setProperty(""-metatypeannotations"", ""!*""); bmaker.setClasspath(new File[] { new File(""bin_test"") }); bmaker.setProperty(""-fixupmessages.export"", ""The annotation aQute.bnd.annotation.Export applied to package test.versionpolicy.api is deprecated and will be removed in a future release. The org.osgi.annotation.bundle.Export should be used instead""); bmaker.setProperty(""-fixupmessages.directive"", ""Unknown directive foobar: in Export-Package, allowed directives are uses:,mandatory:,include:,exclude:,-import:, and 'x-*'""); Jar jar = bmaker.build(); assertTrue(bmaker.check()); report(""testFindActivator"", bmaker, jar); assertEquals(0, bmaker.getErrors() .size()); assertEquals(0, bmaker.getWarnings() .size()); } finally { bmaker.close(); } }","Shouldn't this have a ,* at the end?"
"public List<DispoItem> call() throws Exception { List<DispoItem> fromThread = new LinkedList<DispoItem>(); for (File file : sublist) { InputStream inputStream = null; try { inputStream = new FileInputStream(file); String sanitizedFileName = file.getName().replaceAll(""\\..*"", """"); DispoItemData itemToBuild = new DispoItemData(); if (sanitizedFileName.contains(""sample"")) { System.out.println(""""); } if (exisitingItems.containsKey(sanitizedFileName)) { if (sanitizedFileName.contains(""sample"")) { System.out.println(""""); } DispoItem oldItem = exisitingItems.get(sanitizedFileName); Date lastUpdate = oldItem.getLastUpdate(); boolean wasSameFile = DiscrepancyParser.buildItemFromFile(itemToBuild, sanitizedFileName, inputStream, false, lastUpdate); if (!wasSameFile) { itemToBuild.setGuid(oldItem.getGuid()); itemToBuild.setAnnotationsList(new JSONArray()); if (itemToBuild.getDiscrepanciesList().length() > 0) { DispoItemDataCopier.copyOldItemData(oldItem, itemToBuild); } dataFactory.setStatus(itemToBuild); fromThread.add(itemToBuild); } } else { DiscrepancyParser.buildItemFromFile(itemToBuild, sanitizedFileName, inputStream, true, new Date()); dataFactory.initDispoItem(itemToBuild); fromThread.add(itemToBuild); } } finally { Lib.close(inputStream); } } return fromThread; }",/** */ here and below
"int get(final int numAlleles, final int ploidy) { if(numAlleles <= 0 || ploidy <= 0){ throw new IllegalArgumentException(""numAlleles and ploidy must both exceed 0""); } if(numAlleles < staticCache.length && ploidy < staticCache[numAlleles].length){ return staticCache[numAlleles][ploidy]; } else{ final Integer cachedValue = dynamicCache.get(new CacheKey(numAlleles, ploidy)); if(cachedValue == null){ final int newValue = GenotypeLikelihoods.calcNumLikelihoods(numAlleles, ploidy); put(numAlleles, ploidy, newValue); return newValue; } else{ return cachedValue; } } }",include their actual values here in case anyone actually hits this error
"public static void validateOptions(Options options) { try { GcsPath valid = GcsPath.fromUri(options.getTempPath()); Preconditions.checkArgument(!Strings.isNullOrEmpty(valid.getBucket()), ""Bucket must be specified""); } catch (Exception x) { Preconditions.checkState(false, ""temp path must be a valid Google Cloud Storage URL (starting with gs://)""); } }","This swallows the exception rather than presenting it to the user. Presumably you should at least only catch the expected exception, and it would be best to include it in the message (since you may be denying the user important debugging information, like an access control problem rather than a mispelled path)"
"public boolean onOptionsItemSelected(final MenuItem item) { switch (item.getItemId()) { case android.R.id.home: finish(); return true; case R.id.send_coins_options_help: HelpDialogFragment.page(getFragmentManager(), R.string.help_pop); return true; } return super.onOptionsItemSelected(item); }","Again, needs own menu id."
"CachedFileInfo loadFileInfo(long ledgerId, byte[] masterKey) throws IOException { lock.readLock().lock(); try { CachedFileInfo fi = fileInfos.get(ledgerId); if (fi != null) { fi.retain(); return fi; } } finally { lock.readLock().unlock(); } lock.writeLock().lock(); try { File backingFile = fileLoader.load(ledgerId, masterKey != null); CachedFileInfo fi = new CachedFileInfo(ledgerId, backingFile, masterKey); fileInfos.put(ledgerId, fi); fi.retain(); return fi; } finally { lock.writeLock().unlock(); } }","You wouldn't if the fileInfo is already in the map, right?"
"public void noEvents() { Single.just(""1"") .delay(1, TimeUnit.MILLISECONDS, testScheduler) .compose(new UntilCorrespondingEventSingleTransformer<String, String>(lifecycle, CORRESPONDING_EVENTS)) .subscribe(testSubscriber); testScheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS); testSubscriber.assertValue(""1""); testSubscriber.assertCompleted(); }",Also in my opinion it increases readability of the test and the purpose becomes a bit clearer of what is being tested.
"public synchronized void put(final Protos.TaskID key, final Protos.TaskState value) { LOGGER.debug(""put(key : {}, value : {})"", key.getValue(), value); taskStates.put(key, value); }","You shouldn't need synchronized here, since taskStates is a concurrent map."
"public void logChange(final String storeName, final Bytes key, final byte[] value, final long timestamp) { throwUnsupportedOperationExceptionIfStandby(""logChange""); collector.send( storeToChangelogTopic.get(storeName), key, value, null, taskId().partition, timestamp, KEY_SERIALIZER, VALUE_SERIALIZER); }","req: Please unit test a processor context for a standby with the unsupported methods. That is, all code paths that involve a call to throwUnsupportedOperationExceptionIfStandby()."
"protected TimedBufferObserver createTimedBufferObserver() { return new LocalBufferObserver() { @Override public void flushBuffer(ByteBuf byteBuf, boolean requestedSync, List<IOCallback> callbacks) { final int bytes = byteBuf.readableBytes(); if (bytes == 0) { DelegateCallback.done(callbacks); } else { if (byteBuf.nioBufferCount() == 1 && byteBuf.isDirect()) { final ByteBuffer buffer = byteBuf.internalNioBuffer(byteBuf.readerIndex(), bytes); final IOCallback callback = new DelegateCallback(callbacks); try { internalWrite(buffer, requestedSync, callback, false); } catch (Exception e) { callback.onError(ActiveMQExceptionType.GENERIC_EXCEPTION.getCode(), e.getMessage()); } } else { super.flushBuffer(byteBuf, requestedSync, callbacks); } } } }; }","Make this its own class, so its not anonymous."
"public CLIWrapper(boolean connect, String cliAddress, InputStream consoleInput) throws CliInitializationException { this(connect, cliAddress, consoleInput, CONNECTION_TIMEOUT); }",Do you want to supersede the CLI defaults? You could not provide any connectionTimeout if a negative connectionTimeout is provided.
"public String toString() { StringBuilder sb = new StringBuilder(); sb.append(""Swaps used: ""); sb.append(FormatUtil.formatBytes(getSwapUsed())); sb.append(""/""); sb.append(FormatUtil.formatBytes(getSwapTotal())); return sb.toString(); }","Similar to the memory header, let's put ""Swap: "" in the SystemInfo test and just put ""Used:"" here instead."
"String generateCalendar(String title, List<Absence> absences) { final Calendar calendar = new Calendar(); calendar.getProperties().add(VERSION_2_0); calendar.getProperties().add(new ProdId(""- calendar.getProperties().add(GREGORIAN); calendar.getProperties().add(new XProperty(""X-WR-CALNAME"", title)); calendar.getProperties().add(new XProperty(""X-MICROSOFT-CALSCALE"", GREGORIAN.getValue())); RefreshInterval refreshInterval = new RefreshInterval(); refreshInterval.setValue(Duration.ofHours(1).toString()); calendar.getProperties().add(refreshInterval); final List<VEvent> absencesVEvents = absences.stream().map(this::toVEvent).collect(toList()); calendar.getComponents().addAll(absencesVEvents); final StringWriter calenderWriter = new StringWriter(); final CalendarOutputter calendarOutputter = new CalendarOutputter(); try { calendarOutputter.output(calendar, calenderWriter); } catch (ValidationException | IOException e) { throw new CalendarException(""iCal calender could not be generated"", e); } return calenderWriter.toString(); }",uv.calendar.refresh-interval ?
"public void testSASTokenProviderInitializeException() throws Exception { final AzureBlobFileSystem fs = this.getFileSystem(); final AzureBlobFileSystem testFs = new AzureBlobFileSystem(); MockSASTokenProvider.setThrowExceptionAtInit(true); intercept(TokenAccessProviderException.class, ()-> { testFs.initialize(fs.getUri(), this.getConfiguration().getRawConfiguration()); }); MockSASTokenProvider.setThrowExceptionAtInit(false); }","I think this will fail intermittently (since it is stored in a static) when the tests are run in parallel, which is how we usually run the tests."
"public Response processReview(@Context HttpServletRequest request, @PathParam(""deliveryId"") Long deliveryId, @FormParam(""grade"") String grade, @FormParam(""commentary"") String commentary, @FormParam(""state"") Delivery.State state) throws UnauthorizedException, ApiError { if(!(currentUser.isAdmin() || currentUser.isAssisting(group.getCourse()))) { throw new UnauthorizedException(); } Double gradeValue = grade.isEmpty() ? null : Double.valueOf(grade); Delivery delivery = deliveries.find(group, deliveryId); Delivery.Review review = new Delivery.Review(); review.setState(state); review.setGrade(gradeValue); review.setCommentary(commentary); try { deliveriesBackend.review(delivery, review); } catch (Exception e){ throw new ApiError(""error.could-not-review"", e); } return redirect(request.getRequestURI()); }","When a delivery is rejected, it should not be possible to be graded. E.g. currently I can review a delivery as rejected, but still grade it with a 9,5. A variation of this could be that it should not be possible to grade > X, where X is a course configuration variable."
"@Override public boolean startListener(int port, String name, InboundProcessorParams inboundParameters) { try { messageConsumer.consumeMessage(); } catch (IOException | InterruptedException e) { log.error(""An error occurred while connecting to NATS server or consuming messages. "" + e); messageConsumer.closeConnection(); return true; } catch (SynapseException e) { log.error(""Error while retrieving or injecting NATS message. "" + e.getMessage(), e); return true; } catch (Exception e) { log.error(""Error while retrieving or injecting NATS message. "" + e.getMessage(), e); messageConsumer.closeConnection(); return true; } return true; }",Can we just log an ignore any exception? I think we need to throw it. WDYT>
public int hashCode() { int result; final long temp; temp = Double.doubleToLongBits(output); result = (int) (temp ^ (temp >>> 32)); result = 31 * result + feature.hashCode(); return result; },nit: Why don't we make the declaration and assignment in one line as follows? final long temp = Double.doubleToLongBits(output);
public <T> boolean isBean(Class<T> clazz) { m_lock.readLock().lock(); try { if (m_beanHierarchies.containsKey(clazz)) { return !m_beanHierarchies.get(clazz).getBeans().isEmpty(); } return false; } finally { m_lock.readLock().unlock(); } },just get() no contains
"void checkMaxEnvironmentRam(@Nullable String workspaceId, WorkspaceConfig config) throws ServerException { if (maxRamPerEnvMB < 0) { return; } if (config.getEnvironments().isEmpty()) { return; } if (SidecarToolingWorkspaceUtil.isSidecarBasedWorkspace(config.getAttributes())) { LOG.warn( ""Can not estimate memory needed for sidecar based workspace{}. Set environment memory limits may work incorrectly"", workspaceId == null ? """" : ' ' + workspaceId); } for (Map.Entry<String, ? extends Environment> envEntry : config.getEnvironments().entrySet()) { Environment env = envEntry.getValue(); final long workspaceRam = environmentRamCalculator.calculate(env); if (workspaceRam > maxRamPerEnvMB) { throw new LimitExceededException( format(""You are only allowed to use %d mb. RAM per workspace."", maxRamPerEnvMB), ImmutableMap.of( ""environment_max_ram"", Long.toString(maxRamPerEnvMB), ""environment_max_ram_unit"", ""mb"", ""environment_ram"", Long.toString(workspaceRam), ""environment_ram_unit"", ""mb"")); } } }","How about: ""Cannot estimate the memory requirements of a devfile-based workspace{}. The memory limits may not be applied correctly."""
"public void setUpWindow() { MenuBar menuBar = new MenuBar(this); BorderPane pane = new BorderPane(); Scene scene = new PlayOnLinuxScene(pane, 780, 400); VBox topContainer = new VBox(); toolBar = new ToolBar(this); topContainer.getChildren().add(menuBar); topContainer.getChildren().add(toolBar); pane.setTop(topContainer); statusBar = new StatusBar(this, scene); pane.setBottom(statusBar); GridPane mainContent = new GridPane(); ColumnConstraints columnConstraint = new ColumnConstraints(); columnConstraint.setPercentWidth(30); ColumnConstraints columnConstraint2 = new ColumnConstraints(); columnConstraint2.setPercentWidth(70); RowConstraints rowConstraint = new RowConstraints(); rowConstraint.setPercentHeight(100); mainContent.getColumnConstraints().add(columnConstraint); mainContent.getColumnConstraints().add(columnConstraint2); mainContent.getRowConstraints().add(rowConstraint); mainContent.setVgap(2.0); mainContent.add(new MenuLeft(), 0, 0); this.applicationListWidget = new ApplicationListWidget(); mainContent.add(applicationListWidget, 1, 0); pane.setCenter(mainContent); this.setScene(scene); this.setTitle(translate(""${application.name}"")); this.show(); scene.getWindow().setOnCloseRequest(new EventHandler<WindowEvent>() { @Override public void handle(WindowEvent event) { Alert alert = new Alert(Alert.AlertType.CONFIRMATION); alert.setTitle(translate(""Would you like to exit?"")); alert.setHeaderText(translate(""Are You Sure?"")); Optional<ButtonType> result = alert.showAndWait(); if (result.get() == ButtonType.OK){ Platform.exit(); } else { event.consume(); } } }); }",Can you use a lambda expression instead please?
"public ColumnFilter build() { if (built) { return null; } String columnName = ""potOwner""; UserGroupCallback userGroupCallback = UserDataServiceProvider.getUserGroupCallback(); List<String> potOwners = (List<String>)parameters.get(columnName); List<String> potOwnersList = new ArrayList<String>(); for(String potOwner: potOwners) { potOwnersList.add(potOwner); if(userGroupCallback.getGroupsForUser(potOwner) != null) { potOwnersList.addAll(userGroupCallback.getGroupsForUser(potOwner)); } } ColumnFilter filter = FilterFactory.AND( FilterFactory.in(columnName,potOwnersList)); filter.setColumnId(columnName); built = true; return filter; }",I'd move this to separate line  List<String> groups = userGroupCallback.getGroupsForUser(potOwner);  otherwise it might be rather heavy in some cases to call it twice
"public InputFormatBuilder.InputFormatOptions<T> addIterator(IteratorSetting cfg) { Objects.requireNonNull(cfg, ""IteratorSetting must not be null.""); this.iterators.put(cfg.getName(), cfg); tableConfigMap.get(currentTable).setIterators(new ArrayList<>(this.iterators.values())); return this; }",The way this.iterators is used seems a bit odd. Dropping this.iterators and doing tableConfigMap.get(currentTable).addIterator(cfg) might clean this up.
"public void getAllDocids(Compression compression) throws IOException { Query q = new FieldValueQuery(LuceneDocumentGenerator.FIELD_ID); IndexSearcher searcher = new IndexSearcher(reader); ScoreDoc[] scoreDocs; try { scoreDocs = searcher.search(new FieldValueQuery(LuceneDocumentGenerator.FIELD_ID), reader.maxDoc(), BREAK_SCORE_TIES_BY_DOCID).scoreDocs; } catch (IllegalStateException e) { scoreDocs = searcher.search(new FieldValueQuery(TweetGenerator.StatusField.ID_LONG.name), reader.maxDoc(), BREAK_SCORE_TIES_BY_TWEETID).scoreDocs; } String basePath = directory.getDirectory().getFileName().toString() + "".allDocids""; OutputStream outStream = null; String outputPath = """"; switch (compression) { case RAW: outputPath = basePath+"".txt""; outStream = Files.newOutputStream(Paths.get(outputPath)); break; case GZ: outputPath = basePath+"".gz""; outStream = new GzipCompressorOutputStream(new BufferedOutputStream( Files.newOutputStream(Paths.get(outputPath)))); break; case ZIP: outputPath = basePath+"".zip""; outStream = new ZipOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(outputPath)))); ((ZipOutputStream) outStream).putNextEntry(new ZipEntry(basePath)); break; case BZ2: outputPath = basePath+"".bz2""; outStream = new BZip2CompressorOutputStream(new BufferedOutputStream( Files.newOutputStream(Paths.get(outputPath)))); break; } for (int i = 0; i < scoreDocs.length; i++) { StringBuilder builder = new StringBuilder(); builder.append(searcher.doc(scoreDocs[i].doc).getField(LuceneDocumentGenerator.FIELD_ID).stringValue()).append(""\n""); outStream.write(builder.toString().getBytes(StandardCharsets.UTF_8)); } outStream.close(); System.out.println(String.format(""All Documents IDs are output to: %s"", outputPath)); }","how about ""NONE""? RAW might be confused for some compression scheme."
"public PropertyConstraint computeSpecific( LabelSchemaDescriptor schema ) { switch ( descriptor.type() ) { case UNIQUE: final int labelId = schema.getLabelId(); final int[] propertyKeyIds = new int[]{schema.getPropertyId()}; return new UniquenessConstraint( SchemaDescriptorFactory.forLabel( labelId, propertyKeyIds ) ); case EXISTS: final int labelId1 = schema.getLabelId(); final int[] propertyKeyIds1 = new int[]{schema.getPropertyId()}; return new NodePropertyExistenceConstraint( SchemaDescriptorFactory.forLabel( labelId1, propertyKeyIds1 ) ); default: throw new UnsupportedOperationException( ""Although we cannot get here, this has not been implemented."" ); } }",You can just do schema.getPropertyIds() to get the real array.
"private Map<String, String> getTagFor(TableReference tableRef) { if (LoggingArgs.tableRef(tableRef).isSafeForLogging()) { return ImmutableMap.of(""tableName"", tableRef.getQualifiedName()); } else { return ImmutableMap.of(""tableName"", ""suppressed""); } }","This should probably live in LoggingArgs. Also, I'd use LoggingArgs.safeTableOrPlaceholder to avoid custom conditional logic below"
"public GroupIdPage(GroupByIdBlock groupByIdBlock, Page page) { this.page = page; this.groupByIdBlock = groupByIdBlock; }",requireNonNull
"public static Date parse(String date) { SimpleDateFormat format = new SimpleDateFormat( ""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'""); format.setTimeZone(TimeZone.getTimeZone(""ZULU"")); Date ret; try { ret = format.parse(date); return ret; } catch (ParseException ex) { format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"", Locale.getDefault()); try { return format.parse(date); } catch (ParseException e) { format = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"", Locale.getDefault()); try { return format.parse(date); } catch (ParseException e1) { format = new SimpleDateFormat(""yyyy-MM-dd"", Locale.getDefault()); try { return format.parse(date); } catch (ParseException e2) { format = new SimpleDateFormat(""yyyy-MM"", Locale.getDefault()); try { return format.parse(date); } catch (ParseException e3) { format = new SimpleDateFormat(""yyyy"", Locale.getDefault()); try { return format.parse(date); } catch (ParseException e4) { log.error(e4.getMessage(), e); } } } } } } return new Date(); }",For the others we should continue to use Locale.getDefault() and hop that the servlet container/java environment is configured to use the right one.
"private void refill() { long now = System.currentTimeMillis(); if (now - this.lastRefillTime >= this.refillPeriod) { this.remainingTokens = (int) Math.min(this.capacity, this.remainingTokens + (now - this.lastRefillTime) / this.refillPeriod); this.remainingTokens = Math.max(1, this.remainingTokens); this.lastRefillTime = now; } }",lastRefillTime is not accurate as you lose the elapsed part of the refillPeriod at the time refill() is called. I believe it should be computed as: lastRefillTime += ((now - lastRefillTime) / refillPeriod) * refillPeriod Note that this does not equal now due to the calculation uses integer arithmetics.
"public void showSingleOfficeObjectInOfficeView(String uri) { if (uri.isEmpty()) return; String filePath = CapraOfficeObject.getFilePathFromUri(uri); String objectID = CapraOfficeObject.getIdFromUri(uri); if (new File(filePath).exists()) parseFile(filePath, objectID); else showMessage(viewer.getControl().getShell(), SWT.ERROR, ""Error"", ""Resource not found.""); viewer.refresh(); }",You could refactor parseFile() and the methods it calls to accept a File instance instead of the path. Then you could create the File instance here once and use it everywhere else.
"public double leftExtrapolate(double xValue) { throw new IllegalArgumentException(""Extrapolation is not permitted""); }",I'd expect UnsupportedOperationException here. Or maybe IllegalStateException
"private void setupSearchMenuItem(Menu menu, MenuInflater inflater) { inflater.inflate(R.menu.media_search, menu); MenuItem searchMenuItem = menu.findItem(R.id.action_search); if (searchMenuItem != null) { searchView = (SearchView) MenuItemCompat.getActionView(searchMenuItem); searchView.setOnQueryTextListener(this); searchView.setQueryHint(getString(R.string.action_search)); if (!TextUtils.isEmpty(savedSearchFilter)) { searchMenuItem.expandActionView(); searchView.setQuery(savedSearchFilter, false); searchView.clearFocus(); } MenuItemCompat.setOnActionExpandListener(searchMenuItem, new MenuItemCompat.OnActionExpandListener() { @Override public boolean onMenuItemActionExpand(MenuItem item) { return true; } @Override public boolean onMenuItemActionCollapse(MenuItem item) { searchFilter = savedSearchFilter = null; restartLoader(); return true; } }); } View view = searchView.findViewById(R.id.search_close_btn); if (view != null) { view.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText editText = (EditText) searchView.findViewById(R.id.search_src_text); editText.setText(""""); searchView.setQuery("""", false); searchFilter = savedSearchFilter = """"; restartLoader(); } }); } }","Call something else to this function, as it has nothing to do with Android's Loader - refreshList() for instance."
"private void verifyInvalidValueSize(IndexValue value, String logSegmentName) { try { int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity()); ByteBuffer invalidValue = ByteBuffer.allocate(capacity); invalidValue.put(value.getBytes().array(), 0, capacity); new IndexValue(logSegmentName, invalidValue, version); fail( ""Contruction of IndexValue expected to fail with invalid byte buffer capacity of "" + invalidValue.capacity()); } catch (IllegalArgumentException e) { } }",minor: put _only_ the statement you expect to fail in try.
public long getProducerTimestamp() { return producerId << 16 >> 16; },Keep the producerTimestamp as a field to avoid the need to strip out the pid on every compareTo().
"public DefaultNmsService(final NmsEntity entity, BlockingQueue<Optional<Message>> incomingMessageQueue, Consumer<Message> sink) { this.entity = Objects.requireNonNull(entity); this.incomingMessageQueue = incomingMessageQueue; this.entity.registerMessageListener(Message.class, message -> { LOGGER.trace(""onMessage({})"", message); switch (message.getType()) { case ""MANAGEMENT_CALL_RETURN"": String managementCallIdentifier = ((ManagementCallMessage) message).getManagementCallIdentifier(); ContextualReturn<?> contextualReturn = message.unwrap(ContextualReturn.class).get(0); getManagementAnswerFor(managementCallIdentifier).complete(contextualReturn); break; case ""NOTIFICATION"": case ""STATISTICS"": boolean offered = incomingMessageQueue.offer(Optional.of(message)); if (!offered) { sink.accept(message); } break; default: LOGGER.warn(""Received unsupported message: "" + message); } }); }",Ensure that sink != null.
"protected int[] makeDimValSelector(PooledTopNParams params, int numProcessed, int numToProcess) { final TopNMetricSpecBuilder<int[]> arrayProvider = params.getArrayProvider(); if (query.getDimensionSpec().preservesOrdering()) { return arrayProvider.build(); } arrayProvider.ignoreFirstN(numProcessed); arrayProvider.keepOnlyN(numToProcess); return query.getTopNMetricSpec().configureOptimizer(arrayProvider).build(); }","same, needs to be negated"
"public static void main(String[] args) { Class<?>[] testClasses; try { testClasses = new Class<?>[]{ Class.forName(ReceiveAndDeleteMessageTest.class.getName()), Class.forName(ReceiveAndLockMessageTest.class.getName()), Class.forName(SendMessageTest.class.getName()), Class.forName(SendMessagesTest.class.getName()) }; } catch (ClassNotFoundException e) { throw new RuntimeException(e); } PerfStressProgram.run(testClasses, args); }",I think this statement is the same as ReceiveAndDeleteMessageTest.class?
private void zoom(final double zoomFactor) { scale = scale * zoomFactor; repaintNow = true; repaint(); },should make this scale *= zoomFactor
"private void populateAuthorsAndMingleCards(List<StageFeedEntry> stageEntries, String pipelineName, Username username) { List<Long> pipelineIds = new ArrayList<>(); for (StageFeedEntry stageEntry : stageEntries) { pipelineIds.add(stageEntry.getPipelineId()); } CruiseConfig config = goConfigService.currentCruiseConfig(); Map<Long, List<ModificationForPipeline>> revisionsPerPipeline = changesetService.modificationsOfPipelines(pipelineIds, pipelineName, username); for (StageFeedEntry stageEntry : stageEntries) { List<ModificationForPipeline> revs = revisionsPerPipeline.get(stageEntry.getPipelineId()); for (ModificationForPipeline rev : revs) { Author author = rev.getAuthor(); if (author != null) { stageEntry.addAuthor(author); } String pipelineForRev = rev.getPipelineId().getPipelineName(); if (config.hasPipelineNamed(new CaseInsensitiveString(pipelineForRev))) { PipelineConfig pipelineConfig = config.pipelineConfigByName(new CaseInsensitiveString(pipelineForRev)); MingleConfig mingleConfig = pipelineConfig.getMingleConfig(); Set<String> cardNos = rev.getCardNumbersFromComments(); if (mingleConfig.isDefined()) { for (String cardNo : cardNos) { stageEntry.addCard(new MingleCard(mingleConfig, cardNo)); } } } else { LOGGER.debug(""pipeline not found: "" + pipelineForRev); } } } }",change
"public void testUavg() throws IOException, ProcCallException { String[] columnNames = {""Number""}; String[] columnValues = {""1"", ""2"", ""3"", ""4""}; testFunction(""Uavg(Number)"", 2.5, VoltType.FLOAT, columnNames, columnValues); }","Test same aggregate function called on more than one column: select Uavg(Number1), Uavg(Number2) from t Test aggregate function with group by clause, where clause, having clause, join, order by..."
"public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory) { final BaseObjectColumnValueSelector selector = metricFactory.makeColumnValueSelector(getName()); return new StringFirstBufferAggregator(null, null, maxStringBytes) { @Override public void aggregate(ByteBuffer buf, int position) { SerializablePairLongString pair = (SerializablePairLongString) selector.getObject(); if (pair != null && pair.rhs != null) { ByteBuffer mutationBuffer = buf.duplicate(); mutationBuffer.position(position); long lastTime = mutationBuffer.getLong(position); if (pair.lhs < lastTime) { mutationBuffer.putLong(position, pair.lhs); byte[] valueBytes = StringUtils.toUtf8(pair.rhs); mutationBuffer.putInt(position + Long.BYTES, valueBytes.length); mutationBuffer.position(position + Long.BYTES + Integer.BYTES); mutationBuffer.put(valueBytes); } } } @Override public void inspectRuntimeShape(RuntimeShapeInspector inspector) { inspector.visit(""selector"", selector); } }; }",This looks a bug. lastTime should be checked even when pair.rhs is null.
"public String getProcessFilePath(final HWND hwnd) { final byte[] filePath = new byte[256]; final IntByReference pid = new IntByReference(); User32.INSTANCE.GetWindowThreadProcessId(hwnd, pid); final HANDLE process = Kernel32.INSTANCE.OpenProcess( 0x0400 | 0x0010, false, pid.getValue()); if (process == null && Kernel32.INSTANCE.GetLastError() != 5) throw new Win32Exception(Kernel32.INSTANCE.GetLastError()); final int length = Psapi.INSTANCE.GetModuleFileNameExA(process, null, filePath, filePath.length); if (length == 0 && Kernel32.INSTANCE.GetLastError() != 6) throw new Win32Exception(Kernel32.INSTANCE.GetLastError()); return Native.toString(filePath).trim(); }","If this is entirely internal, you should prefer using the unicode versions of functions to avoid issues with ASCII conversions. Call the -W version of the function and use a char[] buffer instead."
"public Double getRowCount(Intersect rel, RelMetadataQuery mq) { Double rowCount = null; for (RelNode input : rel.getInputs()) { Double partialRowCount = mq.getRowCount(input); if (rowCount == null || partialRowCount != null && partialRowCount < rowCount) { rowCount = partialRowCount; } } if (!rel.all) { return rowCount; } else { return rowCount * 2; } }","IMO, it should not return row count which is bigger than the max row count of inputs."
"public void executionForDeletionByKey() throws Exception { final String key = randomKey(); final CategoryDraft draft = CategoryDraftBuilder.of(randomSlug(), randomSlug()).key(key).build(); final Category category = client().executeBlocking(CategoryCreateCommand.of(draft)); client().executeBlocking(CategoryDeleteCommand.ofKey(key,category.getVersion())); assertThat(client().executeBlocking(CategoryQuery.of().byId(category.getId())).head()).isEmpty(); }",How about replacing the first randomSlug() call to a new method SphereTestUtils.randomLocalizedString()?
"@Test public void smokeTest() throws Exception { int sleepSeconds = -1; switch (platform) { case NATIVE: sleepSeconds = 0; break; case CENTOS: case UBUNTU: case SIMPLE: sleepSeconds = 10; break; case ALPINE: case SLIM: sleepSeconds = 45; break; default: fail(""Unknown enum value: "" + platform); break; } String script = String.format(""echo hello world; sleep %s"", sleepSeconds); Controller c = new BourneShellScript(script).launch(new EnvVars(), ws, launcher, listener); awaitCompletion(c); ByteArrayOutputStream baos = new ByteArrayOutputStream(); c.writeLog(ws,baos); assertEquals(0, c.exitStatus(ws, launcher, listener).intValue()); assertTrue(baos.toString().contains(""hello world"")); c.cleanup(ws); assertThat(getZombies(), isEmptyString()); }",suggestion int sleepSeconds;
"private void verifyPopoverImageUrlWithHoverRetry( final String popoverSelector, final String hoverSelector, final String urlRegex, String taskName) { RetryManager.runUntilNoException(new RetryableTask(taskName) { @Override public void run() { verifyPopoverImageUrl(popoverSelector, urlRegex); } @Override public void beforeRetry() { moveToElement(By.cssSelector(hoverSelector)); } }, WebDriverException.class); }","If the current location is already at the element, will the moveToElement trigger the hover action? It seems like jquery hover action is only triggered on mouse enter and mouse leave, although I am not sure if it is the same action."
"public ColumnIndices(ColumnIndices other, boolean mutable) { this(other.schemaVersion, new HashMap<Pair<Class<? extends RealmModel>, String>, ColumnInfo>(other.classesToColumnInfo.size()), mutable); for (Map.Entry<Pair<Class<? extends RealmModel>, String>, ColumnInfo> entry : other.classesToColumnInfo.entrySet()) { ColumnInfo columnInfo = entry.getValue().copy(mutable); Pair<Class<? extends RealmModel>, String> oldKey = entry.getKey(); Pair<Class<? extends RealmModel>, String> newKey = Pair.<Class<? extends RealmModel>, String>create(oldKey.first, oldKey.second); this.classes.put(newKey.first, columnInfo); this.classesByName.put(newKey.second, columnInfo); this.classesToColumnInfo.put(newKey, columnInfo); } }",why do you need to create a new Pair? the first and second are both immutable anyway?
"protected ColumnRealName resolveCompoundColumn(ColumnRealName baseRealName, ConditionOption option) { if (option == null || !option.hasCompoundColumn()) { return baseRealName; } if (!option.hasStringConnector()) { String msg = ""The option should have string connector when compound column is specified: "" + option; throw new IllegalConditionBeanOperationException(msg); } final List<SpecifiedColumn> compoundColumnList = option.getCompoundColumnList(); final List<ColumnRealName> realNameList = new ArrayList<ColumnRealName>(); if (option.treatsCompoundColumnNullAsEmpty()) { realNameList.add(toColumnRealName(""coalesce("" + baseRealName + "",\'\')"")); for (SpecifiedColumn specifiedColumn : compoundColumnList) { realNameList.add(toColumnRealName(""coalesce("" + doResolveCompoundColumn(option, specifiedColumn) + "",\'\')"")); } } else { realNameList.add(baseRealName); for (SpecifiedColumn specifiedColumn : compoundColumnList) { ColumnRealName resolvedColumnRealName = doResolveCompoundColumn(option, specifiedColumn); realNameList.add(resolvedColumnRealName); } } final OnQueryStringConnector stringConnector = option.getStringConnector(); final String connected = stringConnector.connect(realNameList.toArray()); return ColumnRealName.create(null, new ColumnSqlName(connected)); }",I want you to refactor this logic if you can. Please unify for-statement.
public void handleMinutesSpentInputChange( ChangeEvent event ) { try { Long value = minutesSpentInput.getValue().isEmpty() ? null : Long.parseLong( minutesSpentInput.getValue() ); presenter.onMinutesSpentChange( value ); } catch ( NumberFormatException e ) { } },Likewise..
public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); presenter.startListeningForDirection(); },"i'd maybe just ""forward"" the onConnect to the presenter instead"
"protected Map<ComponentType, Set<DistributionModuleGroup>> buildModuleGroups() { Map<ComponentType, Set<DistributionModuleGroup>> componentsMap = new HashMap<>(); componentsMap.put(ComponentType.HDFS, QuboleHDFSModuleGroup.getModuleGroups()); componentsMap.put(ComponentType.HIVE, QuboleHiveModuleGroup.getModuleGroups()); componentsMap.put(ComponentType.PIG, QubolePigModuleGroup.getModuleGroups()); componentsMap.put(ComponentType.PIGOUTPUT, QubolePigOutputModuleGroup.getModuleGroups()); return componentsMap; }",Needed ?
"public void run() { long currentTime = System.currentTimeMillis(); long purgeTime; Object[] purgeTimes = new Object[1]; List<VariableExpressionExecutor> variableExpressionExecutorList = new ArrayList<>(); Attribute attribute; VariableExpressionExecutor variableExpressionExecutor; ComplexEventChunk<StateEvent> eventChunk = new ComplexEventChunk<>(true); BaseIncrementalDataPurgingValueStore baseIncrementalDataPurgingValueStore = new BaseIncrementalDataPurgingValueStore(currentTime, streamEventPool); attribute = new Attribute(INTERNAL_AGG_TIMESTAMP_FIELD, Attribute.Type.LONG); variableExpressionExecutor = new VariableExpressionExecutor(attribute, 0, 1); variableExpressionExecutorList.add(variableExpressionExecutor); for (Map.Entry<TimePeriod.Duration, Table> entry : aggregationTables.entrySet()) { if (retentionPeriods.get(entry.getKey()) != -1) { Variable leftVariable = new Variable(INTERNAL_AGG_TIMESTAMP_FIELD); leftVariable.setStreamId(entry.getValue().getTableDefinition().getId()); Compare expression = new Compare(leftVariable, Compare.Operator.LESS_THAN, new Variable(INTERNAL_AGG_TIMESTAMP_FIELD)); purgeTime = currentTime - retentionPeriods.get(entry.getKey()); purgeTimes[0] = purgeTime; StateEvent secEvent = baseIncrementalDataPurgingValueStore.createStreamEvent(purgeTimes); eventChunk.add(secEvent); Table table = aggregationTables.get(entry.getKey()); try { CompiledCondition compiledCondition = table.compileCondition(expression, matchingMetaInfoHolder(table, attribute), siddhiAppContext, variableExpressionExecutorList, tableMap, ""query1""); LOG.info(""Purging has enable for the table: "" + table.getTableDefinition().getId() + "" with a"" + "" retention of timestamp : "" + purgeTime); table.deleteEvents(eventChunk, compiledCondition, 1); } catch (Exception e) { LOG.error(""Exception occurred while deleting events from "" + table.getTableDefinition().getId() + "" table"", e); throw new DataPurgingException(""Exception occurred while deleting events from "" + table.getTableDefinition().getId() + "" table"", e); } } } }",name the attribute to say what it hold. And it seems it can static as it's a constant
"public void validateSerialNumber(@RequestBody SerialNumberValidationDto params, HttpServletRequest request, HttpServletResponse response, UriComponentsBuilder uriBuilder) throws IOException { String serialNumber = params.getSerialNumber(); String maybeContainerId = params.getContainerId(); if (isStringEmptyOrNull(serialNumber) || isStringEmptyOrNull(maybeContainerId)) { throw new RestException(""Serial number and containerID must be provided"", Status.BAD_REQUEST); } Long containerId = SequencerPartitionContainerImpl.UNSAVED_ID; if (!maybeContainerId.contains(""Unsaved"")) { containerId = Long.valueOf(maybeContainerId); } try { List<SequencerPartitionContainer> matchingContainers = (List<SequencerPartitionContainer>) containerService .listByBarcode(serialNumber); if (matchingContainers.isEmpty() || (matchingContainers.size() == 1 && matchingContainers.get(0).getId() == containerId)) { return; } else { throw new RestException(""Serial number is already associated with another container"", Status.PRECONDITION_FAILED); } } catch (IOException e) { String error = String.format(""Error looking up containers by serial number '%s'"", serialNumber); log.error(error, e); throw new RestException(error); } }",All instances of Status.PRECONDITION_FAILED should be changed to Status.BAD_REQUEST. Precondition failed status refers to conditions specified in request headers - not the user/application data
"public void testFileBatchInputFormatText() throws Exception { String filePath = ""file:/ String testData = ""String for testing purposes""; Path textFile = new Path(filePath); Configuration conf = new Configuration(); FileSystem fs = FileSystem.get(conf); FSDataOutputStream writeData = fs.create(textFile); writeData.write(testData.getBytes()); writeData.flush(); writeData.close(); ETLStage source = new ETLStage( ""source"", new ETLPlugin(""File"", BatchSource.PLUGIN_TYPE, ImmutableMap.<String, String>builder() .put(Constants.Reference.REFERENCE_NAME, ""TestFile"") .put(Properties.File.FILESYSTEM, ""Text"") .put(Properties.File.PATH, filePath) .put(Properties.File.FILE_SOURCE_FORMAT, ""text"") .put(Properties.File.IGNORE_NON_EXISTING_FOLDERS, ""false"") .build(), null)); String outputDatasetName = ""test-filesource-text""; ETLStage sink = new ETLStage(""sink"", MockSink.getPlugin(outputDatasetName)); ETLBatchConfig etlConfig = ETLBatchConfig.builder(""* * * * *"") .addStage(source) .addStage(sink) .addConnection(source.getName(), sink.getName()) .build(); AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(BATCH_ARTIFACT, etlConfig); ApplicationId appId = NamespaceId.DEFAULT.app(""FileSourceTextFormat""); ApplicationManager appManager = deployApplication(appId, appRequest); WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME); workflowManager.start(); workflowManager.waitForRuns(ProgramRunStatus.COMPLETED, 1, 2, TimeUnit.MINUTES); DataSetManager<Table> outputManager = getDataset(outputDatasetName); List<StructuredRecord> output = MockSink.readOutput(outputManager); Assert.assertEquals(1, output.size()); Assert.assertEquals(testData, output.get(0).get(""body"")); }","hardcoding a directory like this is bad practice, as it assumes the system has permission to write to that location, will not clean up after itself, and will break if some other test writes to the same directory. Use the TemporaryFolder variable in this class to create a new temporary folder just for this test case."
public byte toByte() { switch (this) { case CORE: return 1; case LEAF: return 2; default: throw new IllegalStateException(); } },return fByteValue;
"public GroupedExecutionProperties visitTableScan(TableScanNode node, Void context) { Optional<TablePartitioning> tablePartitioning = metadata.getLayout(session, node.getTable()).getTablePartitioning(); if (!tablePartitioning.isPresent()) { return GroupedExecutionProperties.notCapable(); } List<ConnectorPartitionHandle> partitionHandles = nodePartitioningManager.listPartitionHandles(session, tablePartitioning.get().getPartitioningHandle()); boolean recoveryEligible = metadata.getConnectorCapabilities(session, node.getTable().getConnectorId()).contains(SUPPORTS_REWINDABLE_SPLIT_SOURCE); boolean useful = isGroupedExecutionForAllEligibleTableScansEnabled(session); if (ImmutableList.of(NOT_PARTITIONED).equals(partitionHandles)) { return new GroupedExecutionProperties(false, useful, ImmutableList.of(), 1, recoveryEligible); } else { return new GroupedExecutionProperties(true, useful, ImmutableList.of(node.getId()), partitionHandles.size(), recoveryEligible); } }",I feel GroupedExecutionProperties#useful should be renamed. But don't have to do it in this PR.
"public void handle(CommandContext ctx) throws CommandLineException { ModelControllerClient client = ctx.getModelControllerClient(); if(client == null) { throw new CommandFormatException(""You are disconnected at the moment."" + "" Type 'connect' to connect to the server"" + "" or 'help' for the list of supported commands.""); } RequestWithAttachments reqWithAttachments = (RequestWithAttachments) ctx.get(Scope.REQUEST, ""OP_REQ""); if (reqWithAttachments == null) { throw new CommandLineException(""Parsed request isn't available.""); } ModelNode request = reqWithAttachments.getRequest(); OperationBuilder opBuilder = new OperationBuilder(request, true); for (String path : reqWithAttachments.getAttachedFiles()) { opBuilder.addFileAsAttachment(new File(path)); } Operation op = opBuilder.build(); if(ctx.getConfig().isValidateOperationRequests()) { ModelNode opDescOutcome = Util.validateRequest(ctx, request); if (opDescOutcome != null) { Util.replaceFilePathsWithBytes(request, opDescOutcome); } } try { CliLogger.ROOT_LOGGER.executingOperationRequest(op.getOperation().toString()); final ModelNode result = ctx.execute(op, ""Operation request""); if (Util.isSuccess(result)) { ctx.printLine(result.toString()); } else { throw new CommandLineException(result.toString()); } } catch(NoSuchElementException e) { throw new CommandLineException(""ModelNode request is incomplete"", e); } catch (CancellationException e) { throw new CommandLineException(""The result couldn't be retrieved (perhaps the task was cancelled"", e); } catch (IOException e) { if (e.getCause() != null && !(e.getCause() instanceof InterruptedException)) { ctx.disconnectController(); } throw new CommandLineException(""Communication error"", e); } catch (RuntimeException e) { throw new CommandLineException(""Failed to execute operation."", e); } }","This is okay, but debug logging isn't required in a logger interface. Also {{toString()}} shouldn't be required. If debug is enabled the logger will essentially us String.valueOf() for the op.getOperation() value."
"public String toString() { return ""MemberCandidate{"" + ""candidate="" + candidate + "", member="" + member + "", richUser="" + richUser + '}'; }","Even if it's not PerunBean, please use similar toString: MemberCandidate:[content]."
"public F.Promise<Result> pop() { return cmsService().get(userContext().locale(), ""pop"").flatMap(cms -> { final ProductOverviewPageContent pageData = new ProductOverviewPageContent(cms); return view().map(view -> ok(view.productOverviewPage(pageData))); }); }","I would extract a method, so that you could write:  java getPage(""pop"").flatMap(cms -> {"
"public <T> Future<T> submit(Callable<T> task) { final Callable<T> callable = doWrapOrThrowException(task, controlPoint); try { return super.submit(doIdentityWrap(callable)); } catch (RejectedExecutionException e) { controlPoint.requestComplete(); throw e; } }","this is not ok, for any exception the request should be completed, not just RejectedException"
"private Object invokeParser(InputStream inputStream, Function<io.crate.protocols.postgres.antlr.v4.PgArrayParser, ParserRuleContext> parseFunction, Function<byte[], Object> convert) { try { var lexer = new PgArrayLexer(CharStreams.fromStream( inputStream, Charset.forName(""UTF-8""))); var tokenStream = new CommonTokenStream(lexer); var parser = new io.crate.protocols.postgres.antlr.v4.PgArrayParser(tokenStream); lexer.removeErrorListeners(); lexer.addErrorListener(ERROR_LISTENER); parser.removeErrorListeners(); parser.addErrorListener(ERROR_LISTENER); ParserRuleContext tree; try { parser.getInterpreter().setPredictionMode(PredictionMode.SLL); tree = parseFunction.apply(parser); } catch (ParseCancellationException ex) { tokenStream.seek(0); parser.reset(); parser.getInterpreter().setPredictionMode(PredictionMode.LL); tree = parseFunction.apply(parser); } return new PgArrayASTVisitor(convert).visit(tree); } catch (StackOverflowError e) { throw new PgArrayParsingException(""stack overflow while parsing: "" + e.getLocalizedMessage()); } catch (IOException e) { return new IllegalArgumentException(e); } }",suggestion StandardCharsets.UTF_8));
"public void initialize(final ExtensionContext context) { JSFLogger.ROOT_LOGGER.debug(""Activating JSF(Mojarra) Extension""); final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION); subsystem.registerSubsystemModel(JSFResourceDefinition.INSTANCE); subsystem.registerXMLElementWriter(JSFSubsystemParser_1_1.INSTANCE); if (context.isRegisterTransformers()) { JSFResourceDefinition.registerTransformers(subsystem); } }",There's a new ServiceLoader based way of registering transformers that should be used -- see implementations of org.jboss.as.controller.transform.ExtensionTransformerRegistration
"public void onIndexPageWithResourcesFromCdn() { ContentSecurityPolicyHeaderWriter writer = new ContentSecurityPolicyHeaderWriter( true, false, bool(), SiteUrl.PUBLIC_URL, H2_CONSOLE_PROPERTIES ); String[] directives = writer.constructDirectives(""/"").split("";""); assertThat(directives) .contains( ""default-src 'none'"", ""img-src <LINK_3> <LINK_4>"", ""font-src <LINK_2>"", ""report-uri <LINK_0>"" ) .contains( ""style-src "" + ""'report-sample' "" + ""<LINK_3> "" + ""<LINK_4> "" + ""<LINK_2>"" ) .contains( ""script-src "" + ""'report-sample' "" + ""'unsafe-inline' "" + ""<LINK_4> "" + ""<LINK_2> "" + ""<LINK_1>"" ) .hasSize(NUMBER_OF_DIRECTIVES_ON_STANDARD_PAGES); }",nit: we can write 2 lines into one now: java ContentSecurityPolicyHeaderWriter writer = new ContentSecurityPolicyHeaderWriter(
"private Exception createTimeoutException(Thread thread) { StackTraceElement[] stackTrace = thread.getStackTrace(); final Thread stuckThread = fLookForStuckThread ? getStuckThread(thread) : null; Exception currThreadException = new TestFailedOnTimeoutException(String.format( ""test timed out after %d %s"", fTimeout, fTimeUnit.name().toLowerCase())); if (stackTrace != null) { currThreadException.setStackTrace(stackTrace); thread.interrupt(); } if (stuckThread != null) { Exception stuckThreadException = new Exception (""Appears to be stuck in thread "" + stuckThread.getName()); stuckThreadException.setStackTrace(getStackTrace(stuckThread)); return new MultipleFailureException (Arrays.<Throwable>asList(currThreadException, stuckThreadException)); } else { return currThreadException; } }","If we are making a custom exception, then perhaps we should pass these values into the constructor and provide methods in the exception to get these values so people don't have to parse the exception message"
"protected Tag getVersion(Tool tool) { Tag tag = new Tag(); tag.setCwlPath(""/Dockstore.cwl""); tag.setDockerfilePath(""/Dockerfile""); tag.setAutomated(false); tag.setWdlPath(""/Dockstore.wdl""); tag.setReferenceType(Version.ReferenceType.TAG); tag.setLastBuilt(new Date()); return tag; }","If this is being set at creation time, isn't this redundant with dbCreateDate?"
public FastReaderBuilder getFastReaderBuilder() { if (fastReaderBuilder == null) { FastReaderBuilder localFastReader = new FastReaderBuilder(this); this.fastReaderBuilder = localFastReader; return localFastReader; } else { return this.fastReaderBuilder; } },"Definitely a nit, but why introduce the local variable here?"
"void setFadeEnabled(boolean enabled) { fadeEnabled = enabled; pageFragment.getWebView().postDelayed(this::update, DELAY_UPDATE_MS); }","When I see code that uses postDelayed to work around a problem, it usually means that there's an incomplete understanding of the underlying issue. (see below)"
"public void build(ExtFile appDir, File outFile) throws BrutException { LOGGER.info(""Using Apktool "" + Androlib.getVersion()); MetaInfo meta = readMetaFile(appDir); apkOptions.isFramework = meta.isFrameworkApk; apkOptions.resourcesAreCompressed = meta.compressionType; apkOptions.doNotCompress = meta.doNotCompress; mAndRes.setSdkInfo(meta.sdkInfo); mAndRes.setPackageId(meta.packageInfo); mAndRes.setPackageRenamed(meta.packageInfo); mAndRes.setVersionInfo(meta.versionInfo); mAndRes.setSharedLibrary(meta.sharedLibrary); if (meta.sdkInfo != null && meta.sdkInfo.get(""minSdkVersion"") != null) mMinSdkVersion = Integer.parseInt(meta.sdkInfo.get(""minSdkVersion"")); if (outFile == null) { String outFileName = meta.apkFileName; outFile = new File(appDir, ""dist"" + File.separator + (outFileName == null ? ""out.apk"" : outFileName)); } new File(appDir, APK_DIRNAME).mkdirs(); buildSources(appDir); buildNonDefaultSources(appDir); File manifest = new File(appDir, ""AndroidManifest.xml""); File manifestOriginal = new File(appDir, ""AndroidManifest.xml.orig""); if (manifest.isFile() && manifest.exists()) { try { if (manifestOriginal.exists()) { manifestOriginal.delete(); } FileUtils.copyFile(manifest, manifestOriginal); ResXmlPatcher.fixingPublicAttrsInProviderAttributes(manifest); } catch (IOException ex) { throw new AndrolibException(ex.getMessage()); } } buildResources(appDir, meta.usesFramework); buildLib(appDir); buildLibs(appDir); buildCopyOriginalFiles(appDir); buildApk(appDir, outFile); buildUnknownFiles(appDir, outFile, meta); if (manifest.isFile() && manifest.exists()) { try { if (new File(appDir, ""AndroidManifest.xml"").delete()) { FileUtils.moveFile(manifestOriginal, manifest); } } catch (IOException ex) { throw new AndrolibException(ex.getMessage()); } } }",Can you use braces for added logic? I try to stay away from single statement control flow as its just prone to errors.
"protected void scheduleFlush(String encodedRegionName, List<byte[]> families) { RegionServerServices services = this.abortable; HRegion r = (HRegion) services.getRegion(encodedRegionName); if (r == null) { LOG.warn(""Failed to schedule flush of {}, because it is not online on us"", encodedRegionName); return; } FlushRequester requester = services.getFlushRequester(); if (requester == null) { LOG.warn(""Failed to schedule flush of {}, region={}, because FlushRequester is null"", encodedRegionName, r); return; } requester.requestFlush(r, false, families, FlushLifeCycleTracker.DUMMY); }",We are in here because a force roll was requested. You change the true to false. Isn't that changing behavior at least for the default flush all stores case?
private void makeCachedRequestWithCredsId(String credsId) throws IOException { GitHubServerConfig config = new GitHubServerConfig(credsId); config.setApiUrl(github.serverConfig().getApiUrl()); config.setClientCacheSize(1); GitHub gitHub = new GitHubLoginFunction().apply(config); gitHub.getMyself(); },@kohsuke maybe it would be easy for you to implement this <LINK_0> ?
"public synchronized void send(DatastreamEventRecord record) throws DatastreamException { if (_shutdownRequested) { throw new IllegalStateException(""send() is not allowed on a shutdown producer""); } validateEventRecord(record); try { _transportProvider.send(record); _latestCheckpoints.get(record.getDatastreamTask()).put(record.getPartition(), record.getCheckpoint()); _pendingCheckpoint = true; } catch (TransportException e) { throw new DatastreamException(""Failed to send: "" + record, e); } }",Why are you wrapping the TransportException?
"public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) { TypeCompatibility compatibility = compatibility(firstType, secondType); if (!compatibility.isCompatible()) { return null; } return compatibility.getCommonType(); }","Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation could be avoided (if types match, undefined case, maybe even the ""by precedence"" case)"
"private Map<URL, URL> findExportedResources(Module dependencyModule, Map<String, Map<URL, URL>> exportedResourcesCache) { if (exportedResourcesCache.containsKey(dependencyModule)) { return exportedResourcesCache.get(dependencyModule.getName()); } Set<URL> beanXmls = findExportedResource(dependencyModule, META_INF_BEANS_XML); if (beanXmls.isEmpty()) { exportedResourcesCache.put(dependencyModule.getName(), Collections.emptyMap()); return Collections.emptyMap(); } Set<URL> indexes = findExportedResource(dependencyModule, META_INF_JANDEX_IDX); Map<URL, URL> ret = new HashMap<>(); for (URL beansXml : beanXmls) { String urlBase = beansXml.toString().substring(0, beansXml.toString().length() - META_INF_BEANS_XML.length()); URL idx = null; for (URL index : indexes) { if (index.toString().startsWith(urlBase)) { idx = index; break; } } ret.put(beansXml, idx); } exportedResourcesCache.put(dependencyModule.getName(), ret); return ret; }",This will always return false as the keys are dependencyModule.getName().
private String getDatabase(final Query query) { String db = query.getDatabase(); return db == null ? this.database : db; },"I dont like elvis, please consider without"
"private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) { final Map<String, List<Entry<T>>> copy = new HashMap<>(); original.forEach((key, value) -> copy.put(key, new CopyOnWriteArrayList<>(value))); return copy; }","OK, so to be sure I'm getting this properly, the reasoning behind the change in SubtypeMap is that instead of having heavy ConcurrentHashMap instances, we can have more lightweight plain HashMap instances. The concurrency is dealt with by copying on writing and having volatile references to the instances. Right? Btw, would it make sense to try providing a size parameter when creating the new (copy) map? Now, I'm wondering, shouldn't the add and getPossible methods be synchronized to ensure consistent results? Or perhaps more fine-grain synchronized blocks should be added to make the changes to the 3 indexes here atomic and preventing access to them while the change is being performed? On the other hand, this problem was there before even with the ConcurrentHashMap based implementation... so we could simply ignore it for now and maybe create a jira for it if necessary."
"private void executeStartOperation(final PlanOperation startOp) { final String planContextId = startOp.getEvalId().get(); final Optional<ActiveContext> context = executingPlan.getAddedWorkerContext(planContextId); if (context.isPresent()) { final String contextId = context.get().getId(); LOG.log(Level.FINE, ""START: worker {0}"", contextId); asyncDolphinDriver.get().getSecondContextActiveHandlerForWorker(true).onNext(context.get()); executingPlan.putWorkerTaskControlOp(contextId, startOp); } else { throw new RuntimeException(""There's no worker evaluator to start""); } }",I think L473 should precede L472.
"public AnalysisResult runCheckers(ImmutableList<AnalysisResult> knownResultsSoFar, AnalysisDatabase database, MutableTypeInformation mutableTypeInformation, AnalysisInProgress analysisInProgress) { Map<IsImmutable, Integer> results = newHashMap(); Collection<MutableReasonDetail> reasons = newArrayList(); Collection<AnalysisError> errors = newArrayList(); boolean isClassSelfReferenced=false; Iterable<AsmMutabilityChecker> checkers = factory.createInstances( database, verifierFactory, mutableTypeInformation, analysisInProgress); CheckerRunner checkerRunner = checkerRunnerFactory.createRunner(); for (AsmMutabilityChecker checker : checkers) { if(checker instanceof CollectionWithMutableElementTypeToFieldChecker) { checker.setIsClassSelfReferenced(isClassSelfReferenced); } CheckerResult checkerResult = checkerRunner.run(checker, toAnalyse, knownResultsSoFar); if(checker instanceof MutableTypeToFieldChecker) { isClassSelfReferenced = checker.isClassSelfReferenced(); } results.put(checkerResult.isImmutable, getNewCount(results, checkerResult.isImmutable)); reasons.addAll(checkerResult.reasons); errors.addAll(checkerResult.errors); } IsImmutable isImmutable = new ResultCalculator().calculateImmutableStatus(results); return AnalysisResult.analysisResult(toAnalyse, isImmutable, reasons, errors); }","Here and elsewhere: try to follow the existing code style with respect to whitespace: spaces around =, space after comma, space after if, etc."
"private void initializeCryptoClients() { if (localKeyCryptographyClient != null) { return; } if (key.get().getKeyType().equals(RSA) || key.get().getKeyType().equals(RSA_HSM)) { localKeyCryptographyClient = new RsaKeyCryptographyClient(key.get(), cryptographyServiceClient); } else if (key.get().getKeyType().equals(EC) || key.get().getKeyType().equals(EC_HSM)) { localKeyCryptographyClient = new EcKeyCryptographyClient(key.get(), cryptographyServiceClient); } else if (key.get().getKeyType().equals(OCT)) { localKeyCryptographyClient = new SymmetricKeyCryptographyClient(key.get(), cryptographyServiceClient); } else { throw logger.logExceptionAsError(new IllegalArgumentException(String.format( ""The Json Web Key Type: %s is not supported."", key.get().getKeyType().toString()))); } }",This would be more readable with a switch statement
"public static final int compare(MemorySegment seg1, MemorySegment seg2, int offset1, int offset2, int len) { final byte[] b1 = seg1.memory; final byte[] b2 = seg2.memory; int val = 0; for (int pos = 0; pos < len && (val = (b1[offset1 + pos] & 0xff) - (b2[offset2 + pos] & 0xff)) == 0; pos++) { ; } return val; }","is checkstyle forbidding this, if we write for( .. ; .. ; .. ); ?"
"public int hashCode() { return Objects.hash(getUsername(), getPolicy(), getContext(), getTitle(), ttl, getPushTitle(), pushBody); }",ttl should be getTTLM()
"public void onMatch(RelOptRuleCall call) { SingleRel single = call.rel(0); RelNode emptyValues = call.builder().push(single).empty().build(); RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList()); call.transformTo(result); }","If you change PruneEmptyRule's autoPruneOld to false, you might be able to see another error."
public String getString(String key) throws JSONException { Object object = this.get(key); return object.toString(); },"Just a note for other reviewers, the get(key) will throw an exception if the key or the value is null, so no null check is needed here. I'm not sure if you want to make this more succinct though as  java return this.get(key).toString();  I'm personally not a fan of local variables that are only used once."
"private static boolean isPositionWithin(final ContentPosition position, final Box box) { return position.getOffset() >= box.getStartOffset() && position.getOffset() <= box.getEndOffset(); }",Please use ContentPosition.isBeforeOrEquals and isAfterOrEquals here
"private static Object evaluate(TokenKind op, Object value, Location loc) throws EvalException, InterruptedException { switch (op) { case NOT: return !EvalUtils.toBoolean(value); case MINUS: if (!(value instanceof Integer)) { throw new EvalException( loc, String.format( ""unsupported operand type for -: '%s'"", EvalUtils.getDataTypeName(value))); } try { return Math.negateExact((Integer) value); } catch (ArithmeticException e) { throw new EvalException(loc, e.getMessage()); } case TILDE: if (!(value instanceof Integer)) { throw new EvalException( loc, String.format( ""unsupported operand type for ~: '%s'"", EvalUtils.getDataTypeName(value))); } return ~((Integer) value); default: throw new AssertionError(""Unsupported unary operator: "" + op); } }",You can write the exception code once if you structure it as:  switch op { case NOT: ... case MINUS: if (x instanceof Integer) { return ... } break; case TILDE: if (x instanceof Integer) { return ... } break; } throw unsupported unary operation <op><type>
"public String toString() { switch (this) { case APPS: return ""Apps""; case ENGINES: return ""Engines""; default: throw new IllegalArgumentException(); } }","As an alternative you could add the display name of the installation types as a parameter to the enum, then you would simply need to return this parameter."
public CPUStat getCPUStat() { return new CPUStat(); },"Is this coded on purpose? I mean, can we use it as a stateless call? At first sight, this getCPUStat seem to return an object property, but instead, it will always return a different object instance."
"public void create(Player player, Game game) { this.game = game; this.owner = player; int breakTime = Main.getInstance().getIntConfig(""specials.arrow-blocker.protection-time"", 10); int waitTime = Main.getInstance().getIntConfig(""specials.arrow-blocker.using-wait-time"", 30); if (waitTime > 0) { ArrayList<ArrowBlocker> livingBlockers = this.getLivingBlocker(); if (!livingBlockers.isEmpty()) { for (ArrowBlocker livingBlocker : livingBlockers) { int waitLeft = waitTime - livingBlocker.getLivingTime(); if (waitLeft > 0) { player.sendMessage( ChatWriter.pluginMessage(Main._l(""ingame.specials.arrow-blocker.left"", ImmutableMap.of(""time"", String.valueOf(waitLeft))))); return; } } } } ItemStack usedStack = null; if (Main.getInstance().getCurrentVersion().startsWith(""v1_8"")) { usedStack = player.getInventory().getItemInHand(); usedStack.setAmount(usedStack.getAmount() - 1); player.getInventory().setItem(player.getInventory().getHeldItemSlot(), usedStack); } else { if (player.getInventory().getItemInOffHand().getType() == this.getItemMaterial()) { usedStack = player.getInventory().getItemInOffHand(); usedStack.setAmount(usedStack.getAmount() - 1); player.getInventory().setItemInOffHand(usedStack); } else if (player.getInventory().getItemInMainHand().getType() == this.getItemMaterial()) { usedStack = player.getInventory().getItemInMainHand(); usedStack.setAmount(usedStack.getAmount() - 1); player.getInventory().setItemInMainHand(usedStack); } } player.updateInventory(); player.sendMessage(ChatWriter.pluginMessage(Main._l(""ingame.specials.arrow-blocker.start"", ImmutableMap.of(""time"", String.valueOf(breakTime))))); if (breakTime > 0 || waitTime > 0) { this.runTask(breakTime, waitTime); game.addSpecialItem(this); } }",Hyphens (-) are not allowed in Java variable names. I guess you meant protectionTime. :smile_cat:
"private Void dropTablesWithPrefix(String prefix) { String namespacedPrefix = NAMESPACE.getName() + ""."" + prefix + ""__""; Set<TableReference> tablesToDrop = Sets.newHashSet(); for (TableReference tableRef : kvs.getAllTableNames()) { if (tableRef.getQualifiedName().startsWith(namespacedPrefix)) { tablesToDrop.add(tableRef); } } kvs.dropTables(tablesToDrop); return null; }",= kvs.getAllTableNames().stream() .filter(tableRef -> tableRef.getQualifiedName().startsWith(namespacedPrefix)) .collect(Collectors.toSet());  for style points?
"public static CardinalitySize getEstimatedCardinality( String dimension, Class<?> cls, EntityDictionary entityDictionary ) { if (entityDictionary.isRelation(cls, dimension)) { Cardinality annotation = entityDictionary.getAttributeOrRelationAnnotation( cls, Cardinality.class, dimension ); if (annotation != null) { return annotation.size(); } } Cardinality annotation = entityDictionary .getAttributeOrRelationAnnotation(cls, Cardinality.class, dimension); return annotation == null ? getDefaultCardinality() : annotation.size(); }",This is identical to the call on 83. I think this is not what you intended.
"public int read(ByteBuffer buff) throws IOException { int read = 0; if (this.appPeerBuffer.position() == 0) { this.channel.read(this.packatPeerBuffer); if (this.packatPeerBuffer.position() == 0) { return read; } this.packatPeerBuffer.flip(); boolean retry = true; while (retry) { SSLEngineResult result = this.engine.unwrap(this.packatPeerBuffer, this.appPeerBuffer); switch (result.getStatus()) { case BUFFER_OVERFLOW: putBuffer(buff); read += result.bytesProduced(); retry = false; break; case BUFFER_UNDERFLOW: read += result.bytesProduced(); retry = false; break; default: if (HandshakeStatus.NEED_TASK.equals(result.getHandshakeStatus()) || !this.appPeerBuffer.hasRemaining()) { retry = false; } read += result.bytesProduced(); } } this.packatPeerBuffer.compact(); } putBuffer(buff); return read; }",just a matter of preferences (and style) - you could move lines 63-65 and code will work the same. But I'm okay with this as well.
"public void testRegisterClusterListenerDuplicates() { reset(); TestClusterListener clusterListener = new TestClusterListener(); _state.registerClusterListener(clusterListener); _state.registerClusterListener(clusterListener); _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback()); _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME)); assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, ""expected 1 call""); }","It would be nice if the messages were a bit more descriptive with reasons why we expect a certain number of count. for example, ""Expected 1 call since duplicates are not allowed."" makes the test that much easier to understand."
"private ExportValue emptyValue() { return new JustValue("""", ValueType.EMPTY, (empty) -> ""--""); }",Define the empty value string as a constant
protected Thread createDispatchThread() { return new Thread(new Runnable() { public void run() { while (!shutDown || drainingBeforeShutdown) { try { final ApnsConnection<T> connection = connectionPool.getNextConnection(); T notification = retryQueue.poll(); if (notification == null && !drainingBeforeShutdown) { notification = queue.poll(); } if (notification != null) { connection.sendNotification(notification); } else { if (drainingBeforeShutdown) { for (final ApnsConnection<T> connectionToClose : connectionPool.getAll()) { connectionToClose.shutdownGracefully(); } } Thread.sleep(POLL_TIMEOUT); } } catch (InterruptedException e) { continue; } } } }); },So you can't drain before you send all of your notifications?
"public String toString() { return ""BuildImageParams{"" + ""repository='"" + repository + '\'' + "", tag='"" + tag + '\'' + "", authConfigs="" + authConfigs + "", doForcePull="" + doForcePull + "", memoryLimit="" + memoryLimit + "", memorySwapLimit="" + memorySwapLimit + "", files="" + files + "", dockerfile='"" + dockerfile + '\'' + "", remote='"" + remote + '\'' + "", quiet="" + quiet + "", noCache="" + noCache + "", removeIntermediateContainer="" + removeIntermediateContainer + "", forceRemoveIntermediateContainers="" + forceRemoveIntermediateContainers + "", cpusetCpus="" + cpusetCpus + "", cpuPeriod="" + cpuPeriod + "", cpuQuota="" + cpuQuota + "", buildArgs="" + buildArgs + '}'; }",Looks like it should have  symbol before and after value
"private static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments( Iterable<String> liveInstances, ResourceAssignment prevAssignment, Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName, Map<String, Set<Integer>> tasksToDrop) { Map<String, SortedSet<Integer>> result = new HashMap<>(); for (String instance : liveInstances) { result.put(instance, new TreeSet<>()); } for (Partition partition : prevAssignment.getMappedPartitions()) { int pId = TaskUtil.getPartitionId(partition.getPartitionName()); if (allTaskPartitions.contains(pId)) { Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition); for (String instance : replicaMap.keySet()) { SortedSet<Integer> pIdSet = result.get(instance); if (pIdSet != null) { pIdSet.add(pId); } } } } Map<Partition, Map<String, String>> partitions = currStateOutput.getCurrentStateMap(jobName); for (Map.Entry<Partition, Map<String, String>> entry : partitions.entrySet()) { for (Map.Entry<String, String> instanceToCurrState : entry.getValue().entrySet()) { String instance = instanceToCurrState.getKey(); String requestedState = currStateOutput.getRequestedState(jobName, entry.getKey(), instance); TaskPartitionState currState = TaskPartitionState.valueOf(instanceToCurrState.getValue()); int pId = TaskUtil.getPartitionId(entry.getKey().getPartitionName()); if (result.containsKey(instance)) { if (currState == TaskPartitionState.INIT && requestedState != null && requestedState.equals(TaskPartitionState.RUNNING.name()) || currState == TaskPartitionState.RUNNING) { result.get(instance).add(pId); } if (requestedState != null && requestedState.equals(TaskPartitionState.DROPPED.name())) { if (!tasksToDrop.containsKey(instance)) { tasksToDrop.put(instance, new HashSet<>()); } tasksToDrop.get(instance).add(pId); } } } } return result; }","Will this fix the COMPLETE with requested state is DROPPED? I think COMPLETE/TASK_ERROR will not be added in map, right?"
"public void testSerializable() throws JsonProcessingException { RestoreRedundancyResultsImpl restoreRedundancyResults = new RestoreRedundancyResultsImpl(); restoreRedundancyResults.setStatusMessage(""Test""); restoreRedundancyResults.setSuccess(true); restoreRedundancyResults.setTotalPrimaryTransfersCompleted(150); restoreRedundancyResults.setTotalPrimaryTransferTime(250); RegionRedundancyStatusImpl regionRedundancyStatus = new RegionRedundancyStatusImpl(); regionRedundancyStatus.setActualRedundancy(1); regionRedundancyStatus.setConfiguredRedundancy(1); regionRedundancyStatus.setRegionName(""/foo""); regionRedundancyStatus.setStatus(SATISFIED); restoreRedundancyResults.addRegionResult(regionRedundancyStatus); String jsonString = geodeMapper.writeValueAsString(restoreRedundancyResults); RestoreRedundancyResultsImpl value = geodeMapper.readValue(jsonString, RestoreRedundancyResultsImpl.class); assertThat(value.getStatusMessage()).isEqualTo(""Test""); assertThat(value.getSuccess()).isTrue(); }","This test sets multiple fields but does not verify all of them. Would it be possible to confirm that all data in the object is correctly serialized and deserialized, not just the message and status fields?"
"public void toggleAvailableOffline(OCFile file, boolean isAvailableOffline) { if (OCFile.AvailableOfflineStatus.AVAILABLE_OFFLINE_PARENT == file.getAvailableOfflineStatus()) { Snackbar snackbar = Snackbar.make( mFileActivity.findViewById(android.R.id.content), R.string.available_offline_inherited_msg, Snackbar.LENGTH_LONG ); snackbar.show(); } else { OCFile.AvailableOfflineStatus targetAvailableOfflineStatus = isAvailableOffline ? OCFile.AvailableOfflineStatus.AVAILABLE_OFFLINE : OCFile.AvailableOfflineStatus.NOT_AVAILABLE_OFFLINE; file.setAvailableOfflineStatus(targetAvailableOfflineStatus); boolean success = mFileActivity.getStorageManager().saveLocalAvailableOfflineStatus(file); if (success) { FileObserverService.observeFile( mFileActivity, file, mFileActivity.getAccount(), isAvailableOffline ); if (OCFile.AvailableOfflineStatus.AVAILABLE_OFFLINE == file.getAvailableOfflineStatus()) { syncFile(file); } else { cancelTransference(file); } } else { Snackbar snackbar = Snackbar.make( mFileActivity.findViewById(android.R.id.content), R.string.common_error_unknown, Snackbar.LENGTH_LONG ); snackbar.show(); } } }","Same, avoid duplicating the code using a method to show the snackbar"
"private MQTTSessionState getSessionState(String clientId) { return MQTTSession.getSessionState(clientId, session.getServer().getIdentity()); }","-1 Ive raised this already, simply shouldnt be having static map holding state."
"public void createSynapseDebugEnvironment(ServerContextInformation contextInfo) { try { String carbonHome = System.getProperty(ServerConstants.CARBON_HOME); File synapseProperties = new File(CarbonUtils.getCarbonConfigDirPath() + File.separator + ""synapse"" + "".properties""); Properties properties = new Properties(); InputStream inputStream = new FileInputStream(synapseProperties); properties.load(inputStream); inputStream.close(); int event_port = Integer.parseInt(properties.getProperty(ServiceBusConstants.ESB_DEBUG_EVENT_PORT)); int command_port = Integer.parseInt(properties.getProperty(ServiceBusConstants.ESB_DEBUG_COMMAND_PORT)); SynapseDebugInterface debugInterface = SynapseDebugInterface.getInstance(); debugInterface.init(command_port, event_port); contextInfo.setServerDebugModeEnabled(true); contextInfo.setSynapseDebugInterface(debugInterface); SynapseDebugManager debugManager = SynapseDebugManager.getInstance(); contextInfo.setSynapseDebugManager(debugManager); log.info(""Synapse debug Environment created successfully""); } catch (IOException ex) { log.error(""Error while creating Synapse debug environment "", ex); } catch (InterruptedException ex) { log.error(""Error while creating Synapse debug environment "", ex); } }","Shall we use Paths.get("""").toFile here"
"protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAnalyticsListener.trackLoginMagicLinkOpened(); Intent intent = new Intent(this, WPMainActivity.class); intent.setAction(getIntent().getAction()); intent.setData(getIntent().getData()); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); startActivity(intent); finish(); }","I think we need to inject the mAnalyticsListener instance before using it, otherwise it will be null."
