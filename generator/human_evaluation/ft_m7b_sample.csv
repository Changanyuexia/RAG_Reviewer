label,top0_predict,top1_predict,top0_bleu4,top1_bleu4,top0_cg,top1_cg,code,prompt
Sets.newHashSet,"We don't need this check, as the model has already been updated.","this is the same as fSelectedIds = Lists.newArrayList(Iterables.filter(entries, TmfGenericTreeEntry.class)); which would be a bit shorter. Also, this would mean we could remove the clearContent() call and have the updateContent() call clear the content as well.",0.0187942939461838,0.022904473595,IN,IN,"public void handleCheckStateChangedEvent(Collection<ITmfTreeViewerEntry> entries) { cancelUpdate(); Iterable<TmfGenericTreeEntry> counterEntries = Iterables.filter(entries, TmfGenericTreeEntry.class); Collection<@NonNull Long> selectedIds = Lists.newArrayList(Iterables.transform(counterEntries, e -> e.getModel().getId())); if (!selectedIds.containsAll(fSelectedIds)) { clearContent(); } fSelectedIds = selectedIds; updateContent(); }","'point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"extract method suggestion assertTimeoutPreemptively(ofSeconds(5), () -> executor.run());",This should be a static import.,You can use the stateExecution arg here.,0.0112341002987898,0.0932592189502801,IN,IN,"public void runWorkflowThroughOneSuccessfulState() { WorkflowInstance instance = executingInstanceBuilder().setType(""execute-test"").setState(""start"").build(); when(workflowInstances.getWorkflowInstance(instance.id, INCLUDES, null)).thenReturn(instance); when(workflowInstancePreProcessor.process(newChildWorkflow)).thenReturn(newChildWorkflow); when(workflowInstancePreProcessor.process(newWorkflow)).thenReturn(newWorkflow); assertTimeoutPreemptively(ofSeconds(5),() -> executor.run()); verify(workflowInstanceDao).updateWorkflowInstanceAfterExecution( argThat( matchesWorkflowInstance(inProgress, ExecuteTestWorkflow.State.process, 0, is(""Scheduled by previous state start""))), argThat(matchesWorkflowInstanceAction(ExecuteTestWorkflow.State.start, is(""Process after delay""), 0, stateExecution)), childWorkflows.capture(), workflows.capture(), eq(true)); assertThat(childWorkflows.getValue().get(0), is(newChildWorkflow)); assertThat(workflows.getValue().get(0), is(newWorkflow)); }","'Please use the default timeout (5 minutes) set by GeodeAwaitility instead: await().untilAsserted() (without the timeout).'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Can you think of a way to avoid passing OzoneManager to this class? We now have a low level class depending on a higher level class and potentially a circular dependency.,I think this is not needed,"You should initialize this.deletedKeyCount = 0. Otherwise, it will be 0 + 1 = 1.",0.0021102569999021,0.0569871910695691,IN,IN,"public KeyDeletingService(OzoneManager ozoneManager, ScmBlockLocationProtocol scmClient, KeyManager manager, long serviceInterval, long serviceTimeout, Configuration conf) { super(""KeyDeletingService"", serviceInterval, TimeUnit.MILLISECONDS, KEY_DELETING_CORE_POOL_SIZE, serviceTimeout); this.ozoneManager = ozoneManager; this.scmClient = scmClient; this.manager = manager; this.keyLimitPerTask = conf.getInt(OZONE_KEY_DELETING_LIMIT_PER_TASK, OZONE_KEY_DELETING_LIMIT_PER_TASK_DEFAULT); this.deletedKeyCount = new AtomicLong(0); this.runCount = new AtomicLong(0); }","'Just to be sure, we are reusing the code, but not changing the behaviour for backoff right?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Let's remove the stack trace from the logs here, since we know it's a TimeoutException, and if it happens there's bound to be a lot of these. suggestion LOG.warn(""Timeout occurred while sending message to topic {}, it will be attempted again."", topic);",can we make this a constant?,"suggestion final ProducerRecord<String, byte[]> record = new ProducerRecord<>(topic, messageId, messageInBytes);",0.0001255432455338,0.0872734933766875,IN,IN,"public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String topic, T message) { try (MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) { LOG.trace(""dispatch({}): sending message {}"", topic, message); String messageId = UUID.randomUUID().toString(); byte[] messageInBytes = wrapMessageToProto(messageId, module.marshal(message)); final ProducerRecord<String,byte[]> record = new ProducerRecord<>(topic, messageId, messageInBytes); while(true) { try { final Future<RecordMetadata> future = producer.send(record); future.get(); break; } catch (InterruptedException e) { LOG.warn(""Interrupted while sending message to topic {}."", topic, e); Thread.currentThread().interrupt(); break; } catch (ExecutionException e) { if (e.getCause() != null && e.getCause() instanceof TimeoutException) { LOG.warn(""Timeout occured while sending message to topic {}, it will be attempted again."", topic, e); } else { LOG.error(""Exception occured while sending message to topic {} "", e); break; } } } } }","'suggestion final ProducerRecord<String, byte[]> record = new ProducerRecord<>(topic, module.marshal(message));'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"this is 'quark', then you don't need the try-catch.",You should use e.getLocalizedMessage() instead of e::getLocalizedMessage,The method should return a boolean.,0.0436713549140148,0.0525666754485276,IN,IN,"private void addTreeViewerBranch(ITmfStateSystem stateSystem, TmfTreeViewerEntry rootBranch, String branchName) { try { int quark = stateSystem.optQuarkAbsolute(branchName); if (quark != ITmfStateSystem.INVALID_ATTRIBUTE && !stateSystem.getSubAttributes(quark, false).isEmpty()) { TmfTreeViewerEntry branch = new TmfTreeViewerEntry(branchName); rootBranch.addChild(branch); addTreeViewerEntries(stateSystem, branch, stateSystem.getQuarkAbsolute(branchName)); } } catch (AttributeNotFoundException e) { LOGGER.log(Level.WARNING, e::getLocalizedMessage); } }","'=='. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Why is this error? Should we make this an info log? And ""updating {} {}"" is not detailed enough. Say something like ""Successfully added metadata store realm {} to namespace {}!""... and put it after the call so we know it succeeded.",This is not an error. It should be a debug message.,Remove?,0.0160810764195469,6.128001307616313e-16,SE,IN,"public Response addMetadataStoreRealm(@PathParam(""realm"") String realm) { try { LOG.error(""updating {} {}"", _namespace, realm); _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm); } catch (IllegalArgumentException ex) { return notFound(ex.getMessage()); } return OK(); }","'Remove?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Could this (RuleConfigParam) be passed as parameter of HostProcess instead? (It would be easier to use custom configurations per scan, for example, through an advanced tab in Active Scan dialogue.)",Should we be doing this?,"If this is a scan node, the scanner type should not be ignored.",0.0003609158619156,0.0531564331221206,IN,IN,"private boolean scanSingleNode(Plugin plugin, StructuralNode node) { Thread thread; Plugin test; HttpMessage msg; log.debug(""scanSingleNode node plugin="" + plugin.getName() + "" node="" + node.getName()); try { if (node == null || node.getHistoryReference() == null) { log.debug(""scanSingleNode node or href null, returning: node="" + node); return false; } if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) { log.debug(""Ignoring \""scanner\"" type href""); return false; } if (!nodeInScope(node.getName())) { log.debug(""scanSingleNode node not in scope""); return false; } msg = node.getHistoryReference().getHttpMessage(); if (msg == null) { log.debug(""scanSingleNode msg null""); return false; } test = plugin.getClass().newInstance(); test.setConfig(plugin.getConfig()); FileConfiguration confFile = Model.getSingleton().getOptionsParam().getConfig(); Iterator<String> iter = confFile.getKeys(""rules.""); while (iter.hasNext()) { String key = iter.next(); test.getConfig().setProperty(key, confFile.getProperty(key)); } test.setDelayInMs(plugin.getDelayInMs()); test.setDefaultAlertThreshold(plugin.getAlertThreshold()); test.setDefaultAttackStrength(plugin.getAttackStrength()); test.setTechSet(getTechSet()); test.init(msg, this); notifyHostProgress(plugin.getName() + "": "" + msg.getRequestHeader().getURI().toString()); } catch (Exception e) { log.error(e.getMessage() + "" "" + node.getName(), e); return false; } do { if (this.isStop()) { return false; } thread = threadPool.getFreeThreadAndRun(test); if (thread == null) { Util.sleep(200); } } while (thread == null); mapPluginStats.get(plugin.getId()).incProgress(); return true; }","'should the Mapping be the other way around?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"If there is an interrupt, the thread will not wait for count down of the latch and proceed. It would be safe if we assume that thread interrupt can suddenly happen.",I think you need to catch the exception here and not swallow it.,This will block the thread. Do we want to block the thread?,0.0878831632582652,0.0964693125379167,AS,AS,"public synchronized void allocateEvaluators(final int evalNum, final int megaBytes, final int cores, final EventHandler<AllocatedEvaluator> evaluatorAllocatedHandler, final List<EventHandler<ActiveContext>> contextActiveHandlerList) { try { ongoingEvaluatorRequest.get().await(); } catch (final InterruptedException e) { LOG.log(Level.WARNING, ""Interrupted while waiting for ongoing request to be finished"", e); } LOG.log(Level.INFO, ""Requesting {0} evaluators..."", evalNum); for (int i = 0; i < evalNum; i++) { final Queue<EventHandler<ActiveContext>> handlerQueue = new ConcurrentLinkedQueue<>(contextActiveHandlerList); pendingEvalRequests.add(new Tuple2<>(evaluatorAllocatedHandler, handlerQueue)); } final EvaluatorRequest request = EvaluatorRequest.newBuilder() .setNumber(evalNum) .setNumberOfCores(cores) .setMemory(megaBytes) .build(); ongoingEvaluatorRequest.set(new CountDownLatch(request.getNumber())); evaluatorRequestor.submit(request); }","'It looks that removing this variable is better, since it has almost no performance benefit. Thanks for pointing in out :)'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
I think this should be setSelected not setEnabled,I would rather have a separate method setStartEndDate(DateRangeFilter) that would set both start and end.,This is wrong: our local date in many cases would differ that that in the passed zone offset.,0.1488043485793567,0.134920171461748,IN,IN,"private void setDateRangeFilter(DateRangeFilter dateFilter) { ZonedDateTime zoneDate = ZonedDateTime.ofInstant(Instant.ofEpochSecond(dateFilter.getStartDate()), Utils.getUserPreferredZoneId()); startDatePicker.setEnabled(dateFilter.isStartDateEnabled()); startCheckBox.setEnabled(dateFilter.isStartDateEnabled()); startDatePicker.setDate(zoneDate.toLocalDate()); zoneDate = ZonedDateTime.ofInstant(Instant.ofEpochSecond(dateFilter.getEndDate()), Utils.getUserPreferredZoneId()); endDatePicker.setEnabled(dateFilter.isEndDateEnabled()); endCheckBox.setEnabled(dateFilter.isEndDateEnabled()); endDatePicker.setDate(zoneDate.toLocalDate()); }","'While UTC is the good choice for epochs, here we should use GMT to comply with the spec. ![image](<LINK_0>'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Same question like above.,This method has a lot of code that is specific to the web-image-resize. Maybe we should move the code to the ImageConverter class?,"this is not going to work for file:// paths, which should be the only ones you are dealing with here.",0.0250349218712178,0.0199925272656586,IN,IN,"public Image getSizedWebImage(URI sourceUri, int width) throws IOException { if (!new File(sourceUri).exists()) { throw new FileNotFoundException(""sourceUri must exist: "" + sourceUri.getRawPath()); } if (width <= 0) { throw new IllegalArgumentException(""width must be > 0, but was "" + Integer.toString(width)); } File tempFile = File.createTempFile(""sizedWebImage-"", WEB_IMAGE_FORMAT, TMPDIR); try { tempFile.deleteOnExit(); URI webImageUri = tempFile.toURI(); ImageConverter imageConverter = new ImageConverter(sourceUri); imageConverter.addResult(webImageUri).resizeToWidth(width); logger.info(""Generating sized web image from {} as {}, width {} px"", sourceUri, tempFile, width); imageConverter.run(); logger.trace(""Loading {}"", tempFile); Image buffer = ImageIO.read(tempFile); logger.trace(""{} successfully loaded"", tempFile); return buffer; } finally { logger.debug(""Deleting {}"", tempFile); tempFile.delete(); logger.trace(""Successfully deleted {}"", tempFile); } }","'Why did you add this deleteOnExit if you delete this file in any way inside the finally block?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
This clock should be a constant like the other one (or the other one should be a local variable; I don't mind as long as it's consistent).,Please check for null values,"This is not the default value for GMT, it is for Europe/London. I think you meant to use a parameter builder with the default value.",0.0045895981574,0.2276668695229955,IN,IN,"public void should_include_default_browserTimezoneOffsetMins_for_Gmt_when_timezone_offset_provided_is_invalid (@Nullable String timeZoneOffsetMins) { Clock gmtClock = Clock.fixed(ZonedDateTime.parse(""2020-01-01T10:10:10.100Z"").toInstant(), ZoneId.of(""Europe/London"")); var epdqPayloadDefinitionFor3ds2NewOrder = new EpdqPayloadDefinitionForNew3ds2Order(FRONTEND_URL, SupportedLanguage.ENGLISH, gmtClock); authCardDetails.setJsTimezoneOffsetMins(timeZoneOffsetMins); List<NameValuePair> result = epdqPayloadDefinitionFor3ds2NewOrder.extract(epdqTemplateData); assertThat(result, is(aParameterBuilder().withBrowserTimezoneOffsetMins(""0"").build())); }","'Niche!'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
I think that this condition is not sufficient. We end up creating an ambiguous symbol in the following case and I suppose we should not:  x = 42 x = 43,"Why do you have to check this here? If it's not a binding usage, it can't be ambiguous.",Why do we have to cast here?,0.1840154015674347,0.0033011004537938,AS,IN,"private void createAmbiguousSymbols() { for (Scope scope : scopesByRootTree.values()) { Set<SymbolToUpdate> symbolsToUpdate = new HashSet<>(); for (Symbol symbol : scope.symbols()) { if (symbol.kind() == Symbol.Kind.OTHER) { List<Usage> bindingUsages = symbol.usages().stream().filter(Usage::isBindingUsage).collect(Collectors.toList()); if (bindingUsages.size() > 1) { Set<Symbol> alternativeDefinitions = getAlternativeDefinitions(symbol, bindingUsages); AmbiguousSymbol ambiguousSymbol = AmbiguousSymbolImpl.create(alternativeDefinitions); symbol.usages().forEach(usage -> ((SymbolImpl) ambiguousSymbol).addUsage(usage.tree(), usage.kind())); symbolsToUpdate.add(new SymbolToUpdate(symbol, ambiguousSymbol)); } } } symbolsToUpdate.forEach(symbolToUpdate -> scope.replaceSymbolWithAmbiguousSymbol(symbolToUpdate.symbol, symbolToUpdate.ambiguousSymbol)); } }","'I would add a map operation to make the ClassSymbolImpl cast in order to avoid the repeated the casts below.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Empty collection should be returned instead of null,The method name should be changed to determineIncludedStructuralElementPathToChild,Please extract this to a method ProcessService.getProcessIdFromUri(uri),0.2181841028201997,0.0320846634720325,IN,IN,"private LinkedList<IncludedStructuralElement> determineIncludedStructuralElementPathToChildRecursive( IncludedStructuralElement includedStructuralElement, int number) { if (!Objects.isNull(includedStructuralElement.getLink())) { try { if (ServiceManager.getProcessService() .processIdFromUri(includedStructuralElement.getLink().getUri()) == number) { LinkedList<IncludedStructuralElement> linkedIncludedStructuralElements = new LinkedList<>(); linkedIncludedStructuralElements.add(includedStructuralElement); return linkedIncludedStructuralElements; } } catch (IllegalArgumentException | ClassCastException | SecurityException e) { logger.catching(Level.TRACE, e); } } for (IncludedStructuralElement includedStructuralElementChild : includedStructuralElement.getChildren()) { LinkedList<IncludedStructuralElement> includedStructuralElementList = determineIncludedStructuralElementPathToChildRecursive( includedStructuralElementChild, number); if (Objects.nonNull(includedStructuralElementList)) { includedStructuralElementList.addFirst(includedStructuralElementChild); return includedStructuralElementList; } } return null; }","'Stack trace is nice to have (but not necessary): suggestion logger.info(e.getLocalizedMessage(), e);'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
This does not pass on OS X - investigating...,"I think this should be assertFalse, but not sure.",Can you just make a List<File> and then just add to it. You can also do an asList on it at the end to get a List,0.1789964319491101,0.0527600805495316,IN,IN,"public void testInitialAndAddMore() throws Exception { WatchServiceDirectoryScanner scanner = new WatchServiceDirectoryScanner(folder.getRoot().getAbsolutePath()); scanner.start(); List<File> files = scanner.listFiles(folder.getRoot()); assertEquals(3, files.size()); assertTrue(files.contains(top1)); assertTrue(files.contains(foo1)); assertTrue(files.contains(bar1)); File top2 = this.folder.newFile(); File foo2 = File.createTempFile(""foo"", "".txt"", this.foo); File bar2 = File.createTempFile(""bar"", "".txt"", this.bar); File baz = new File(this.foo, ""baz""); baz.mkdir(); File baz1 = File.createTempFile(""baz"", "".txt"", baz); files = scanner.listFiles(folder.getRoot()); int n = 0; List<File> accum = new ArrayList<File>(files); while (n++ < 300 && accum.size() != 4) { Thread.sleep(100); files = scanner.listFiles(folder.getRoot()); accum.addAll(files); } assertEquals(4, accum.size()); assertTrue(accum.contains(top2)); assertTrue(accum.contains(foo2)); assertTrue(accum.contains(bar2)); assertTrue(accum.contains(baz1)); List<File> filesForOverflow = new ArrayList<File>(512); for (int i = 0; i < 512; i++) { filesForOverflow.add(this.folder.newFile("""" + i)); } files = scanner.listFiles(folder.getRoot()); assertEquals(512, files.size()); for (File fileForOverFlow : filesForOverflow) { files.contains(fileForOverFlow); } File baz2 = File.createTempFile(""baz2"", "".txt"", baz); files = scanner.listFiles(folder.getRoot()); assertEquals(1, files.size()); assertTrue(files.contains(baz2)); scanner.stop(); }","'Nit, assertEquals would give a better error message on failure'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Only the own implemented interfaces (immediate implemented?), or also transitively?","I think we should keep this check, as it is used by other parts of the code.",Is there a reason for the change?,0.1157882073903521,0.0527042146402391,IN,IN,"private void visitClassOrInterface(String name, FunctionType ftype) { final boolean emitInstance = !ftype.isInterface(); if (emitInstance) { emit(""class""); emit(name); visitTemplateTypes(ftype); emit(""extends""); emit(name + INSTANCE_CLASS_SUFFIX); visitTemplateTypes(ftype); emit(""{""); indent(); emitBreak(); visitProperties(ftype, true); unindent(); emit(""}""); emitBreak(); } if (ftype.isConstructor()) { emit(""class""); } else if (ftype.isInterface()) { emit(""interface""); } else { checkState(false, ""Unexpected function type "" + ftype); } emit(emitInstance ? name + INSTANCE_CLASS_SUFFIX : name); visitTemplateTypes(ftype); if (ftype.getExtendedInterfacesCount() > 0) { emit(""extends""); Iterator<ObjectType> it = ftype.getExtendedInterfaces().iterator(); emitCommaSeparatedInterfaces(it); } ObjectType superType = getSuperType(ftype); if (superType != null) { emit(""extends""); if (isPrivate(superType.getJSDocInfo())) { emit(Constants.INTERNAL_NAMESPACE + "".PrivateClass""); } else { Visitor<Void> visitor = new ExtendsImplementsTypeVisitor( emitInstance && !isDefinedInPlatformExterns(superType)); superType.visit(visitor); } } Iterator<ObjectType> it = ftype.getOwnImplementedInterfaces().iterator(); if (it.hasNext()) { emit(""implements""); emitCommaSeparatedInterfaces(it); } boolean implementsIArrayLike = any(ftype.getOwnImplementedInterfaces(), IARRAYLIKE_PREDICATE); visitObjectType(ftype, ftype.getPrototype(), ftype.isDict() || implementsIArrayLike); }","'whitespace is a bit off here'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Can you merge these three filter operations into a single one?,"I would use p.getFileName().toString().replace(DASHBOARD_EXTENSION, """").toLowerCase() to avoid case sensitivity",Can we make this a separate method?,0.0742470457656907,0.1480849143489181,IN,IN,"private Optional<String> checkForExistingFile(byte[] uploadedFile) throws IOException { try (Stream<java.nio.file.Path> walk = Files.walk(Paths.get(runtimeOptions.getImportsBaseDir()), 1)) { return walk .filter(p -> p.toFile().isFile()) .filter(p -> p.toString().toLowerCase().endsWith(DASHBOARD_EXTENSION)) .filter(p -> isContentEquals(uploadedFile, p)) .map(p -> p.getFileName().toString().replace(DASHBOARD_EXTENSION, """")) .findFirst(); } catch (Exception e) { logger.info(""Error checking for duplicated file contents.""); logger.debug(""Error checking for duplicated file contents."", e); return Optional.empty(); } }","'This is crazy badass.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"According to the Druid formatting rules, should break all or none arguments.",Could use assertThat instead.,I think this should be a CoordinatorDynamicConfig.builder().withMaxTtl(524288000).build(). The same applies to the other tests below.,0.0473420000595579,0.2003099314100017,IN,IN,"public void testBuilderDefaults() { CoordinatorDynamicConfig defaultConfig = CoordinatorDynamicConfig.builder().build(); assertConfig(defaultConfig, 900000, 524288000, 100, 5, 15, 10, 1, false, ImmutableSet.of(), false, 0, ImmutableSet.of(), 7); }","'I thought we should do:  assertRecordedDefaults( recordDefaults(CompilerConfig.class) .setInterpreterEnabled(false) .setExpressionCacheEnabled(true));'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"You can not put person via storIOSQLite.put() because it will be recursive, so you need to use storIOSQLite.internal(), but you can use storIOSQLite.put() to put cars.",This is an internal class. I'd say this should be private and use a static method instead.,why do you need this Set?,0.1155690061395145,0.0017462061897218,AS,IN,"public PutResult performPut(@NonNull StorIOSQLite storIOSQLite, @NonNull Person person) { final PutResults<Object> putResults = storIOSQLite .put() .objects(asList(person, person.getCars())) .prepare() .executeAsBlocking(); final Set<String> affectedTables = new HashSet<String>(2); affectedTables.add(PersonsTable.TABLE); affectedTables.add(CarsTable.TABLE); return PutResult.newUpdateResult(putResults.numberOfUpdates(), affectedTables); }","'Now it's correct! :+1:'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""typeName"", type.getInternalName());","This will cause a NullPointerException when a character like a < is escaped. You should be escaping the internal name of the equipment type, not the string representation of the type.",This is probably a bug. It's probably the same problem as with the equipmentType.,0.1432850577677717,0.0763157634291014,IN,IN,"public void writeToXml(PrintWriter pw1, int indent) { writeToXmlBegin(pw1, indent); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""equipmentNum"", equipmentNum); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""typeName"", MekHqXmlUtil.escape(type.getInternalName())); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""size"", size); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""equipTonnage"", equipTonnage); writeToXmlEnd(pw1, indent); }","'suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, ""typeName"", type.getInternalName());'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Seems like a copy-paste. Can you refactor skipping logic to a separate method?,I would rather add a method to check if we should use cross thread stacks traces.,This can be refactored into a single function.,0.203173424758755,0.1985068588161087,IN,SE,"private void appendTaskStackTrace(final Throwable error) { if (!ParSeqGlobalConfiguration.getInstance().isCrossThreadStackTracesEnabled() || error == null || _taskStackTrace == null || _taskStackTrace.length <= 2) { return; } StackTraceElement[] errorStackTrace = error.getStackTrace(); if (errorStackTrace.length <= 2) { return; } int skipErrorFrames = 1; while (skipErrorFrames < errorStackTrace.length) { int index = errorStackTrace.length - 1 - skipErrorFrames; if (!errorStackTrace[index].getClassName().equals(CANONICAL_NAME) && errorStackTrace[index + 1].getClassName().equals(CANONICAL_NAME)) { break; } skipErrorFrames++; } if (skipErrorFrames == errorStackTrace.length) { skipErrorFrames = 0; } int skipTaskFrames = 1; while (skipTaskFrames < _taskStackTrace.length) { if (!_taskStackTrace[skipTaskFrames].getClassName().equals(CANONICAL_NAME) && _taskStackTrace[skipTaskFrames - 1].getClassName().equals(CANONICAL_NAME)) { break; } skipTaskFrames++; } if (skipTaskFrames == _taskStackTrace.length) { skipTaskFrames = 0; } int combinedLength = errorStackTrace.length - skipErrorFrames + _taskStackTrace.length - skipTaskFrames; if (combinedLength <= 0) { return; } StackTraceElement[] concatenatedStackTrace = new StackTraceElement[combinedLength + 1]; System.arraycopy(errorStackTrace, 0, concatenatedStackTrace, 0, errorStackTrace.length - skipErrorFrames); concatenatedStackTrace[errorStackTrace.length - skipErrorFrames] = new StackTraceElement(""********** Task \"""" + getName() + ""\"" (above) was instantiated as following (below): **********"", """",null, 0); System.arraycopy(_taskStackTrace, skipTaskFrames, concatenatedStackTrace, errorStackTrace.length - skipErrorFrames + 1, _taskStackTrace.length - skipTaskFrames); error.setStackTrace(concatenatedStackTrace); }","'time -> iteration? or repetition? and isTimes -> isIterated or isRepeated'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Just a minor note: throw org.apache.calcite.util.TestUtil#rethrow(java.lang.Throwable) should be used to rethrow exceptions in the test code.,Do we really need this?,why do you need to wrap this in an array list?,0.0014648833037444,0.0370513609115545,IN,IN,"private void testContextLiteral( final SqlOperator operator, final DataContext.Variable variable, final Object value) { Frameworks.withPrepare(new Frameworks.PrepareAction<Void>() { public Void apply(final RelOptCluster cluster, final RelOptSchema relOptSchema, final SchemaPlus rootSchema, final CalciteServerStatement statement) { final RexBuilder rexBuilder = cluster.getRexBuilder(); final RexExecutorImpl executor = new RexExecutorImpl( new SingleValueDataContext(variable.camelName, value)); try { checkConstant(value, new Function<RexBuilder, RexNode>() { public RexNode apply(RexBuilder builder) { List<RexNode> output = new ArrayList<>(); executor.reduce(rexBuilder, ImmutableList.of(rexBuilder.makeCall(operator)), output); return output.get(0); } }); } catch (Exception e) { throw new RuntimeException(e); } return null; } }); }","'Remove correctSchemaSelection?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"You can remove this line, this is done in transactionalFeature.nextTransaction()",This method is called from two different places (waitForAsyncCompletion and commitAndWaitForAsyncCompletion). Shouldn't it be moved to the superclass and called from there?,This line is missing,0.1199921916365444,0.0309164091988039,IN,IN,protected void waitForAsyncCompletion() { nextTransaction(); transactionalFeature.nextTransaction(); eventService.waitForAsyncCompletion(); },"'Does related dynamic APIs refresh the schema cache as well?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Should remove, and use similar functionality in MockServiceTicket",this can be done using [mockito-core](<LINK_0>,"Please don't create mocks of existing classes. Instead, you can use a Mockito argument matcher to match the expected arguments. e.g.  Mockito.mock(ServiceTicket.class, argThat(ServiceTicket::getService)).getService()  (This would be the preferred approach for creating mocks in general, rather than the standard way which involves Mockito.mock(Object.class, Mockito.any()) and then using Mockito.verify on the mocked object. That is used in the rest of the codebase, so it's important to keep it that way).",0.0628328315398239,0.0725101220006666,IN,IN,private ServiceTicket createServiceTicket() { val mock = mock(ServiceTicket.class); when(mock.getService()).thenReturn(createService()); return mock; },"'Don't see how this change is necessary'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
These lines seem duplicated this.connectFuture = null; this.handshakeFuture = null;,I think this should be a debug log.,I think we should use this.connectFuture.channel() here,0.072450442216192,0.313635342638002,IN,IN,"private boolean connectOrContinueConnecting() throws InterruptedException { if (this.connectFuture == null) { log.debug(String.format(""%s beginning connection process."", this.getName())); this.connectFuture = this.bootstrap.connect( this.pushManager.getEnvironment().getApnsGatewayHost(), this.pushManager.getEnvironment().getApnsGatewayPort()); } this.connectFuture.await(); if (this.connectFuture.isSuccess()) { log.debug(String.format(""%s connected."", this.getName())); this.channel = this.connectFuture.channel(); this.channel.config().setAutoClose(false); if (this.handshakeFuture == null) { log.debug(String.format(""%s waiting for TLS handshake."", this.getName())); final SslHandler sslHandler = this.channel.pipeline().get(SslHandler.class); if (sslHandler != null) { this.handshakeFuture = sslHandler.handshakeFuture(); } else { log.error(String.format(""%s failed to get SSL handler and could not wait for a TLS handshake."", this.getName())); this.closeChannelAndLogOutcome(this.channel); this.connectFuture = null; this.handshakeFuture = null; return false; } } this.handshakeFuture.await(); if (this.handshakeFuture.isSuccess()) { log.debug(String.format(""%s successfully completed TLS handshake."", this.getName())); this.connectFuture = null; this.handshakeFuture = null; return true; } else { log.error(String.format(""%s failed to complete TLS handshake with APNs gateway."", this.getName()), this.handshakeFuture.cause()); this.closeChannelAndLogOutcome(this.channel); this.connectFuture = null; this.handshakeFuture = null; return false; } } else { log.error(String.format(""%s failed to connect to APNs gateway."", this.getName()), connectFuture.cause()); Thread.sleep(CONNECT_EXCEPTION_WAIT); this.connectFuture = null; return false; } }","'Time is never freeing resources here if the same script never comes back the last value is always cached. This isn't ideal'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
s/this.cacheAllTables/cacheAllTables/g I think we prefer not to use this to reference variables,"nit: should be ""All tables are expected when caching all tables""","I think this should be a separate assertion, to be consistent with the code in TableCheckers.",0.1649181820796682,0.2725777337822793,IN,IN,"public CachedTableChecker(List<String> cachedTables) { this.cacheAllTables = cachedTables.contains(""*""); if (cacheAllTables) { checkArgument(cachedTables.size() == 1, ""Only '*' is expected when caching all tables""); this.cachedTableNames = ImmutableSet.of(); } else { this.cachedTableNames = cachedTables.stream() .map(CachingDirectoryLister::parseTableName) .collect(toImmutableSet()); } }","'Also check data type, should be BYTES'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Can we leave List<String> as return type ? All the other methods in RunImageConfiguration return a List for collections, and also it is not the most generic type which can be used here, I would like to keep it uniform.",This will return an Iterable<String> instead of an Iterable<String>,"This should be getLink, right?",0.0448110988445248,0.0007003623749937,IN,IN,public Iterable<String> getLinks() { return EnvUtil.splitAtCommasAndTrim(links); },"'minor nitpick: Could we rename it to removeNullEntries() ?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
In the JUnit integration we actually only check if testResult.hasException() {throw Exception}.. If the test is skipped the JUnit specific exception AssumptionViolatedException is caught from JUnit and rethrown.. We would need to update the JUnit integration as well to check for the State==skipped and recreate a AssumptionViolatedException,"I would have expected that the TestResult would be added to the list after the fire event. This way, if the TestExecutionDecider is not null and it decides to execute the test, the result is added to the list after the test has been executed. Otherwise, it is added before the test is executed. This seems to me like a mistake.",This should be in the resolveTestExecutionDecider method.,0.3176814929703678,0.0025473447435614,IN,IN,"public TestResult test(TestMethodExecutor testMethodExecutor) throws Exception { Validate.notNull(testMethodExecutor, ""TestMethodExecutor must be specified""); final List<TestResult> result = new ArrayList<TestResult>(); TestExecutionDecider testExecutionDecider = resolveTestExecutionDecider(manager); if (testExecutionDecider != null && !testExecutionDecider.execute(testMethodExecutor.getMethod())) { result.add(TestResult.skipped(null)); return result.get(0); } manager.fire(new Test(testMethodExecutor), new NonManagedObserver<Test>() { @Inject private Instance<TestResult> testResult; @Override public void fired(Test event) { result.add(testResult.get()); } }); return result.get(0); }","'Class variable serverTaskEngine is never used, so we can remove the constructor.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"If the widget is turned into a label and the member to an EntityModel, these lines should be replaced by setEntity().",Please add the model to the hash,I would set it to true,0.0378527384610647,0.0071855941621058,IN,IN,"public NewExternalSubnetModel(NetworkView network, SearchableListModel sourceModel) { this.sourceModel = sourceModel; setName(new EntityModel<String>()); setCidr(new EntityModel<String>()); setNetwork(new ListModel<NetworkView>()); setIpVersion(new ListModel<IpVersion>()); getIpVersion().setItems(AsyncDataProvider.getExternalSubnetIpVerionList()); getNetwork().setItems(Arrays.asList(network)); getNetwork().setSelectedItem(network); getNetwork().setIsChangable(false); setHashName(""new_external_subnet""); initCommands(); }","'you can reuse the constant in HostModel..'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"There is a FluxUtil method to handle pulling a response value out, I believe it is called toMono. Should use that in all the places update.","This is a bit confusing, why not use the same pattern as the other methods?",nit: can you replace withContext(...) with mapContext(...)?,0.1818523873486242,0.0426182800035933,IN,IN,"public Mono<ConfigurationSetting> getSetting(String key, String label, OffsetDateTime asOfDateTime) { return withContext(context -> getSetting(new ConfigurationSetting().setKey(key).setLabel(label), asOfDateTime, false, context)).map(response -> response.getValue()); }","'This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
is this now guaranteed to be called from the event loop? I think so but just to double-check...,I think we should also remove from the tail chain.,I think we can do without this lock,0.1852323167897564,0.101600569724868,IN,IN,private void destroy() { AbstractChannelHandlerContext ctx = this.tail.prev; while (ctx != head) { synchronized (handlers) { handlers.remove(ctx); } remove0(ctx); ctx = ctx.prev; } },"'This is not enough... You will need to release the message as well and fail the promise.  ClosedChannelException exception = null; for (;;) { AbstractMap.SimpleEntry<Object, ChannelPromise> entry = queue.poll(); if (entry == null) { break; } ReferenceCountedUtil.release(entry.getKey()); ChannelPromise promise = entry.getValue(); if (promise != null) { if (exception == null) { exception = new ClosedChannelException(); } promise.tryFailure(exception); } }'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Hmm, if you make ViewHolder a non-static class, then it could have access to all these fields directly (and shouldn't need to be passed this click handling Runnable).",Why not just call it in the constructor?,Should this be in the constructor?,0.0138560386064395,0.0114133431921923,IN,IN,"public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); viewHolder = new ViewHolder(view, isViewingOwnProfile, new Runnable() { @Override public void run() { router.showUserProfileEditor(getActivity(), username); } }); viewHolder.setUsername(username); viewHolder.setAccount(account); }","'Java coding-standard: name variables in CamelCase... launchPianoActivity in this case'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"You will get an NPE if user is null. It shouldn't ever happen, unless the user gets deleted after it has been cached in SimpleAuthenticator, and given that we make it hard to delete users... Still, the Objects.equals isn't adding anything.",I don't think this is correct. I think this should be.filter(token -> sourceControls.contains(token.getTokenSource().getSourceControl())).collect(Collectors.toList()) and then.forEach(token -> {... }),"This is a pretty complex way of getting the organizations. You could just use the repositoryId to get the organization from the source code repo interface, and then just get the workflows for that organization.",0.1914150808833755,0.2610466853510229,IN,IN,"public List<Workflow> addUserToDockstoreWorkflows(@ApiParam(hidden = true) @Parameter(hidden = true, name = ""user"", in = ParameterIn.HEADER) @Auth User authUser, @ApiParam(name = ""userId"", required = true, value = ""User to update"") @PathParam(""userId"") @Parameter(name = ""userId"", in = ParameterIn.PATH, description = ""User to update"", required = true) long userId, @ApiParam(name = ""emptyBody"", value = APPEASE_SWAGGER_PATCH) @Parameter(description = APPEASE_SWAGGER_PATCH, name = ""emptyBody"") String emptyBody) { final User user = userDAO.findById(authUser.getId()); if (!Objects.equals(userId, user.getId())) { throw new CustomWebApplicationException(""The user Id provided does not match the logged-in user id."", HttpStatus.SC_BAD_REQUEST); } List<SourceControl> sourceControls = Arrays.stream(SourceControl.values()).filter(sourceControl -> !Objects.equals(sourceControl, SourceControl.DOCKSTORE)).collect( Collectors.toList()); List<Token> scTokens = getAndRefreshTokens(user, tokenDAO, client, bitbucketClientID, bitbucketClientSecret) .stream() .filter(token -> sourceControls.contains(token.getTokenSource().getSourceControl())) .collect(Collectors.toList()); scTokens.stream().forEach(token -> { SourceCodeRepoInterface sourceCodeRepo = SourceCodeRepoFactory.createSourceCodeRepo(token, client); Map<String, String> gitUrlToRepositoryId = sourceCodeRepo.getWorkflowGitUrl2RepositoryId(); Set<String> organizations = gitUrlToRepositoryId.values().stream().map(repository -> repository.split(""/"")[0]).collect(Collectors.toSet()); organizations.forEach(organization -> { List<Workflow> workflows = workflowDAO.findByOrganization(token.getTokenSource().getSourceControl(), organization); workflows.stream().forEach(workflow -> workflow.getUsers().add(user)); }); }); return getStrippedBioworkflows(userDAO.findById(user.getId())); }","'Whether the checker workflow has been changed from unpublished to published or vice versa should be irrelevant. It should not make it into the index at all. Figure out why the checker workflow is not being filtered out.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"handleFailure not needed here, it is already set as defaul error state above",nit: no need to permit here. The super class constructor already permits the schedule and doWork.,Can we add a check that the schedule is not null?,0.2758730552236251,0.1537652116062416,AS,IN,"protected CronWorkflow(String type, WorkflowSettings settings) { super(type, schedule, handleFailure, settings); permit(schedule, doWork); permit(doWork, schedule, handleFailure); permit(handleFailure, schedule); }","'there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize.",Could we use the 8 bytes of the long directly? (valueLong.longValue()),Why 8?,0.0558090403515921,7.662258039965253e-17,IN,IN,public byte[] toByteArray() { return ByteBuffer.allocate(8).putLong(valueLong).array(); },"'Can't you use just address.getPort()?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Seems to be this whole for is equivalent to footnoteMacro.getChildren().clear();,Shouldn't this be footnoteMacro.getChildren().remove(0);?,"You could do something like this instead, to avoid the listIterator:  for (Block child : footnoteMacro.getChildren()) { footnoteMacro.removeChild(child); }",0.4688079132270412,0.2964958905576496,AS,SE,"private void addFootnoteRef(MacroMarkerBlock footnoteMacro, Block footnoteRef) { for (ListIterator<Block> it = footnoteMacro.getChildren().listIterator(); it.hasNext();) { it.next(); it.remove(); } footnoteMacro.addChild(footnoteRef); }","'Why does this only update the font if it is not already set?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
foundService or existingClusterService?,Should we be doing this in a transaction?,"We should check if status is null here, and also if it is null, should not add a service to cluster.",0.0684881719169765,0.1349886659431271,IN,IN,"private void addOrUpdateClusterServices(VDSGroup cluster, Map<ServiceType, GlusterServiceStatus> fetchedClusterServiceStatusMap) { Map<ServiceType, GlusterClusterService> existingClusterServiceMap = getClusterServiceMap(cluster); for (Entry<ServiceType, GlusterServiceStatus> entry : fetchedClusterServiceStatusMap.entrySet()) { ServiceType type = entry.getKey(); GlusterServiceStatus status = entry.getValue(); GlusterClusterService foundService = existingClusterServiceMap.get(type); if (foundService == null) { existingClusterServiceMap.put(type, mapServiceTypeToCluster(cluster, type, status)); } else if (foundService.getStatus() != status) { updateClusterServiceStatus(foundService, status); } } }","'Need instanceof check.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Final result can be written directly (without computing the intermediary values: return y1 \* Math.pow(y2 / y1, (value - x1) \* xDiffInv); (remove lines 55 and 56). This should save one log and one exp computation. firstDerivative and getNodeSensitivityForValue should probably be adapted also.","If we have a value at the upper bound, it is better to use the upper bound value, rather than the lower bound value. I think this is what we should do here, and also in the other interpolation methods.",Could you change the return type of this method to double?,0.2268870345680231,0.007310216494819,IN,IN,"public Double interpolate(final Interpolator1DDataBundle data, final Double value) { Validate.notNull(value, ""value""); Validate.notNull(data, ""data bundle""); InterpolationBoundedValues boundedValues = data.getBoundedValues(value); Double x1 = boundedValues.getLowerBoundKey(); Double y1 = boundedValues.getLowerBoundValue(); if (boundedValues.getLowerBoundIndex() == data.size() - 1) { return y1; } Double x2 = boundedValues.getHigherBoundKey(); Double y2 = boundedValues.getHigherBoundValue(); double xDiffInv = 1.0 / (x2 - x1); double a = Math.pow(y1 / y2, x1 * xDiffInv) * y1; double b = Math.log(y2 / y1) * xDiffInv; return a * Math.exp(b * value); }","'And this is why mutability is bad - rather than modifying the weights of Instances in-place, which could have all kinds of unintended and potentially very negative side-effects (what if we re-use these instances elsewhere?), this method should return a new set of instances that have been reweighted, leaving the original instances unmodified.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
This should also have one assignment per newly opened resource.,I don't think this will work in the case of a file with no separator. You'll want to call the constructor with the three streams as arguments.,Can we just have a static field that is this byte array?,0.0813357091877753,0.1856923608661812,IN,IN,"public Note merge(Note base, Note ours, Note theirs, ObjectReader reader, ObjectInserter inserter) throws IOException { if (ours == null) { return theirs; } if (theirs == null) { return ours; } if (ours.getData().equals(theirs.getData())) { return ours; } ObjectLoader lo = reader.open(ours.getData()); byte[] sep = new byte[] {'\n'}; ObjectLoader lt = reader.open(theirs.getData()); try (UnionInputStream union = new UnionInputStream( lo.openStream(), new ByteArrayInputStream(sep), lt.openStream())) { ObjectId noteData = inserter.insert(Constants.OBJ_BLOB, lo.getSize() + sep.length + lt.getSize(), union); return new Note(ours, noteData); } }","'Should be a try-with-resources block.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Not that exhaustive that 'a' is the right password.,Is this really what you want?,Why not use assertEquals?,0.1091162056672291,0.0428639208833429,IN,IN,"protected void _check(String attributeValue) { if (""a"".equals(attributeValue)) { addError(""there is an error""); } }","'Wouldn't it be nicer to create a verify value in codelists so that an exception is thown on purpose and not as side effect? The code should already be available anyway(?)'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
why is the compareAndSet() necessary? Why would this method be called more than once?,This looks like a candidate for a method like sealIfPersistent().,I think we need to add a null check for config here.,0.1876622024187938,0.0911173129743431,AS,IN,"void seal() throws IOException, StoreException { if (sealed.compareAndSet(false, true)) { if (!config.storeKeepIndexInMemory) { map(); } persistBloomFilter(); } }","'is there any benefit to waking all the other consumers when the GC consumer closes ? The way I understand it the GC consumer will only null out entries, so any sleeping consumer shouldn't have any benefit in waking up.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
null check should done for asyncTask.getTaskId() as well,please use getGlusterVolumeVdsParameters,Can you please add the check for volume.getAsyncTask() in the method,0.0424909216844285,0.3423428503431633,IN,IN,"private GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() { VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName())); GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue(); GlusterAsyncTask asyncTask = volume.getAsyncTask(); if (asyncTask != null) { List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId()); if (stepsList != null && !stepsList.isEmpty()) { entity.setStartTime(stepsList.get(0).getStartTime()); } } return entity; }","'it could me more readable if (asyncTask != null && asyncTask.getTaskId() != null ) { ... }'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"This seems hacky, and besides why this is needed? bootstrapLayoutServer has an exceptionally block: java .exceptionally(throwable -> { try { CFUtils.unwrap(throwable, AlreadyBootstrappedException.class); } catch (AlreadyBootstrappedException e) { log.info(""bootstrapLayoutServer: Layout Server {} already bootstrapped."", endpoint); } return true; })  Notice this CFUtils.unwrap(throwable, AlreadyBootstrappedException.class); It will throw a RutimeException in case of exceptions other than AlreadyBootstrappedException, which makes the returned future exceptionally completed . Thus in this bootstrapNewNode method you will get a exceptionally completed future of RutimeException with a TimeoutException wrapped inside.",Why do you need to create the future here? Why not just call future.complete(bootstrapped)?,Shouldn't we log the error here?,0.0005983103162675,1.7163259596757566e-10,IN,IN,"public CompletableFuture<Boolean> bootstrapNewNode(String endpoint) { Layout layout = new Layout(runtime.getLayoutView().getLayout()); CompletableFuture<Boolean> future = new CompletableFuture<>(); try { boolean bootstrapped = runtime.getLayoutView().bootstrapLayoutServer(endpoint, layout); future.complete(bootstrapped); return future; } catch (TimeoutException toe){ future.completeExceptionally(toe); return future; } }","'I would throw instead something like: throw new IllegalStateException(""Unable to reset and sync Nomad system: "" + e.getMessage(), e);. The reason is because the first exception's message is what the user will see in the CLI output from the diagnostic client call that is deserialized and and wrapping it will leak an internal class name appended before the message, so this is less user freiendly.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Add ""this"" qualifier",Maybe this should be immutable,Add this qualifier: this.data,0.1099151472949891,0.4755800131631805,IN,SE,public List<DataSample> getData() { return data; },"'You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
rename 'child',I think we should do this instead: group.getChildren().forEach(Control::setEnabled); This avoids the need to use a for loop.,rename to ctrl,0.0329065977421751,0.460462862587273,IN,AS,"public void setEnabled(boolean enabled, Composite parent) { super.setEnabled(enabled, parent); group.setEnabled(enabled); for (Control element : group.getChildren()) { element.setEnabled(enabled); } }","'we typically write the annotations on separate line'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"I would use ""get"" directly without checking with ""containsKey"", there is no reason generate hashCode twice and search in the map. Then you can check ""if null"" and return empty list ...... But this is matter of style.","this is wrong, the return type is Collection, not List","Please use the Guava Pair.of(osId, version)",0.0274332668774612,0.0052466648414265,IN,IN,"public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) { Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version); if (getDiskHotpluggableInterfacesMap().containsKey(pair)) { List<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(pair); Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>(); for (String diskHotpluggableInterface : diskHotpluggableInterfaces) { diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface)); } return diskInterfaces; } return Collections.emptyList(); }","'Be careful calling ArchitectureType.valueOf(architecture) if the architecture can be null - it would fail on NPE. Please move it inside the null check.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"This needs to return a completable future, not null",We could add a return statement here.,"This needs to return a completable future, not null",0.230936218288451,1.0,SE,PP,"public CompletableFuture<Void> hideMapVersion(MapBean map) { String id = map.getId(); MapVersion mapVersion = new MapVersion(); mapVersion.setHidden(true); mapVersion.setId(map.getId()); fafApiAccessor.updateMapVersion(id, mapVersion); return null; }","'This needs to return a completable future, not null'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
rename to operation,"This condition is always true, no need to check the length.","recompute = true; is called multiple times, this is redundant.",0.0983986787987938,0.0402333029469418,IN,IN,public void removeContext(IUndoContext context) { boolean recompute = false; if (triggeringOperation != null && triggeringOperation.hasContext(context)) { if (triggeringOperation.getContexts().length == 1) { remove(triggeringOperation); return; } triggeringOperation.removeContext(context); recompute = true; } ArrayList<IUndoableOperation> toBeRemoved = new ArrayList<>(); for (IUndoableOperation child : children) { if (child.hasContext(context)) { if (child.getContexts().length == 1) { toBeRemoved.add(child); } else { child.removeContext(context); } recompute = true; } } for (IUndoableOperation element : toBeRemoved) { remove(element); } if (recompute) { recomputeContexts(); } },"'data.keySet().removeAll(removed) probably suffices, but not sure.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"minor code style improvement: java Deadline deadline = Optional.ofNullable(Context.current().getDeadline()); if (useTimeout) { deadline = deadline.or(Deadline.after(requestTimeoutMs, TimeUnit.MILLISECONDS)); } return deadline;","why not: return Optional.of(Deadline.after(requestTimeoutMs, TimeUnit.MILLISECONDS))?","I'm not sure what is the goal here, but it looks like this is a duplicate of the deadline parameter of the Operation constructor.",0.1700086631230595,0.1050531957101198,IN,IN,"private Optional<Deadline> createOperationDeadline() { Deadline contextDeadline = Context.current().getDeadline(); if (contextDeadline != null) { return Optional.of(contextDeadline); } else if (useTimeout) { return Optional.of(Deadline.after(requestTimeoutMs, TimeUnit.MILLISECONDS)); } else { return Optional.absent(); } }","'I investigated why containerAllowsStaticMethodAccess() doesn't need such fix and found [this in default.properties](<LINK_0>! I think we should keep same conduct as static methods for static fields.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Again: missed Math.abs() and {} arround procedure.appy(...).,Shouldn't we be able to skip the if check?,"If you change this to get(i,j) >= 0, you won't need the if.",0.025619713583124,0.0515854060671272,IN,IN,"public void eachNonZeroInColumn(int j, MatrixProcedure procedure) { for (int i = 0; i < rows; i++) { if (get(i, j) > Matrices.EPS) procedure.apply(i,j,get(i,j)); } }","'It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Typo here. should be service_type,Why don't you use a constant?,please use serviceType instead of servive_type,0.0407209099497435,0.3433528871552628,IN,SE,"public List<GlusterServerService> getByServerIdAndServiceType(Guid serverId, ServiceType serviceType) { MapSqlParameterSource paramSource = getCustomMapSqlParameterSource(); paramSource.addValue(""server_id"", serverId); paramSource.addValue(""servive_type"", serviceType); return getCallsHandler().executeReadList(""GetGlusterServerServicesByServerIdAndServiceType"", serviceRowMapper, paramSource); }","'Typo here. should be service_type'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Another space after add,"This seems to be a bit inconsistent. Why is this message only displayed if the positionArgsBuilder is null, and not when the builder is already populated?",Should have a space after add,0.0356025470605016,0.5492319291521991,IN,SE,"public TextArgs add(Object... args) { if (positionedArgsBuilder == null) { throw new IllegalArgumentException(""Positioned arguments were already accessed, to add"" + ""more arguments use TextArgs.copy()""); } positionedArgsBuilder.add(args); return this; }","'Should have a space after add'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
This is never used?,"This should throw an exception, not return 0.","This is not a good idea, if ammoStorage is null, you will still remove shots from the infantry weapon, and it will return 0. This is a very bad bug, that can go unnoticed for a long time. This can be fixed by just returning -1, if ammoStorage is null.",0.1076377411641296,0.0420333742897199,IN,IN,"public int removeAmmo(AmmoType ammoType, InfantryWeapon infantryWeapon, int shotsNeeded) { Objects.requireNonNull(ammoType); if (shotsNeeded <= 0) { return 0; } InfantryAmmoStorage ammoStorage = findSpareAmmo(ammoType, infantryWeapon); int shotsRemoved = removeAmmo(ammoStorage, shotsNeeded); shotsNeeded -= shotsRemoved; return shotsRemoved; }","'Oops!'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
suggestion assertThat(params1).hasSize(2);,It is not possible to pass null as a parameter to merge. So the tests with null as a parameter should be removed.,"You should also test that merge(params1, params2) is the same as merge(params1, params2, null).",0.073896706893087,0.1407314385540745,IN,SE,"public void testMerge() { final Parameters params1 = new Parameters(""foo"", ""bar""); final Parameters params2 = new Parameters(""baz"", ""xyzzy""); assertThat(Parameters.merge(params1)).isSameAs(params1); assertThat(Parameters.merge(params1, null)).isSameAs(params1); assertThat(Parameters.merge(null, params1)).isSameAs(params1); assertThat(Parameters.merge(null, params1, null, params2, null)).isSameAs(params1); assertThat(params1).hasSize(4); assertThat(params2).hasSize(2); }","'please use more concise methods like Arrays.asList'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
this.distanceTolerance = distanceTolerance < MIN_DISTANCE_TOLERANCE ? MIN_DISTANCE_TOLERANCE : distanceTolerance,"This is probably more a matter of taste but I find this code a bit confusing. It is doing a check but it is not throwing an exception. It is just setting a private variable to a constant. I think it would be clearer to throw an exception in this case, and let the caller deal with it.",The variable should be named tolerance,0.0408989232059485,0.0387032541945276,IN,IN,public void setDistanceTolerance(int distanceTolerance) { if (distanceTolerance < MIN_DISTANCE_TOLERANCE) { this.distanceTolerance = MIN_DISTANCE_TOLERANCE; } else { this.distanceTolerance = distanceTolerance; } },"'Add { } around if body, here and on line 113 below.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"if-else can be simplified as: 'errorMessages.putIfAbsent(Constants.INVALID_TRIAL, new ArrayList<>()); errorMessages.get(Constants.INVALID_TRIAL).add(message.get());'",This should be changed to be a Set,"I'm not sure if this is a good idea. This is not a validation of a trial factor value, it's a validation of a variable value, and the validation logic should not be mixed up.",0.0041052907934181,0.0477170068930889,IN,IN,"public void validateTrialInstanceValue(final List<MeasurementVariable> conditions, final Map<String, List<Message>> errorMessages) { for (final MeasurementVariable varCondition : conditions) { if (varCondition.getTermId() == TermId.TRIAL_INSTANCE_FACTOR.getId()) { final Optional<Message> message = Util.validateVariableValues(varCondition, varCondition.getValue()); if (message.isPresent()) { if (errorMessages.containsKey(Constants.INVALID_TRIAL)) { errorMessages.get(Constants.INVALID_TRIAL).add(message.get()); } else { errorMessages.put(Constants.INVALID_TRIAL, Arrays.asList(message.get())); } } } } }","'No need to evict these, it won't grow over time. Also I think you might have missed some locking here.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Double the attribute compartment Same visual id InterfaceAttributeCompartmentEditPart.VISUAL_ID,rename to label2004,This font resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the label.,0.0040618038732397,0.0907068562886311,IN,IN,"public Node createInterface_2004(EObject domainElement, View containerView, String semanticHint, int index, boolean persisted, PreferencesHint preferencesHint) { Shape node = NotationFactory.eINSTANCE.createShape(); node.setLayoutConstraint(NotationFactory.eINSTANCE.createBounds()); node.setType(semanticHint); ViewUtil.insertChildView(containerView, node, index, persisted); node.setElement(domainElement); ClassifierViewFactoryUtil.stampShortcut(containerView, node); final IPreferenceStore prefStore = (IPreferenceStore) preferencesHint.getPreferenceStore(); PreferenceInitializerForElementHelper.initFontStyleFromPrefs(node, prefStore, ""Interface""); ClassifierViewFactoryUtil.createLabel(node, UMLVisualIDRegistry.getType(InterfaceNameEditPart.VISUAL_ID)); Node label8507 = ClassifierViewFactoryUtil.createLabel(node, UMLVisualIDRegistry.getType(InterfaceFloatingNameEditPart.VISUAL_ID)); label8507.setLayoutConstraint(NotationFactory.eINSTANCE.createLocation()); Location location8507 = (Location) label8507.getLayoutConstraint(); location8507.setX(0); location8507.setY(5); ClassifierViewFactoryUtil.createCompartment(node, UMLVisualIDRegistry.getType(InterfaceAttributeCompartmentEditPart.VISUAL_ID), true, true, true, true); ClassifierViewFactoryUtil.createCompartment(node, UMLVisualIDRegistry.getType(InterfaceAttributeCompartmentEditPart.VISUAL_ID), true, true, true, true); ClassifierViewFactoryUtil.createCompartment(node, UMLVisualIDRegistry.getType(InterfaceOperationCompartmentEditPart.VISUAL_ID), true, true, true, true); ClassifierViewFactoryUtil.createCompartment(node, UMLVisualIDRegistry.getType(InterfaceNestedClassifierCompartmentEditPart.VISUAL_ID), true, true, true, true); PreferenceInitializerForElementHelper.initCompartmentsStatusFromPrefs(node, prefStore, ""Interface""); return node; }","'Just to repeat what codacy has said this Relationship browser argument, class variable, and probably the import can be removed as they are unused.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
not equals!,why is this needed?,equals!,0.0203504103382499,0.5647181220077593,IN,IN,"public void testChangeBrickField() throws InterpretationException { cloneBrickFormula.setRoot(new FormulaElement(FormulaElement.ElementType.NUMBER, CLONE_BRICK_FORMULA_VALUE, null)); assertNotSame(brickFormula.interpretInteger(sprite), cloneBrickFormula.interpretInteger(sprite)); }","'Please call checkAttributeSyntax from attributesManager instead of attributesManagerBl if it is possible (in all tests). We need to check if the code in the Entry layer is working correctly too.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Should we log errors?,"We need to make sure that we're not doing a drop conglomerate on a conglomerate that has already been dropped. Otherwise, we'll get an exception from dropTable().",should this be logged?,0.0190288564398114,0.4050364054284844,IN,SE,"private void dropConglomerate(long CID, Activation activation) { TransactionController tc = activation.getTransactionController(); LOG.trace(format(""Dropping temporary conglomerate splice:%d"", CID)); try { tc.dropConglomerate(CID); } catch (StandardException e) { } try { dropTable(CID); } catch (StandardException e) { } }","'Should we log the potential error?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this with a call to the ""toFile().exists()"" method [![rule](<LINK_1>](<LINK_2>",Why do we need this logging?,"Why not just do LOG.info(""Application data directory: {}"", appDataRoot);?",0.0086547696753311,0.0258818986254181,IN,IN,"public static void init() throws IOException { Path appDataRoot = getAppDataRoot(); if (Files.notExists(appDataRoot)) { LOG.info(""Creating application data root directory: {}"", appDataRoot.toString()); Files.createDirectory(appDataRoot); } else { if (!Files.isDirectory(appDataRoot)) { throw new IOException( format(""Application data root path '%s' is not a directory"", appDataRoot.toString())); } if (!Files.isWritable(appDataRoot)) { throw new IOException( format(""Application data root directory '%s' is not writable"", appDataRoot.toString())); } } LOG.info(""Application data directory: {}"", appDataRoot.toString()); AppDataRootProvider.setAppDataRoot(appDataRoot); }","'the object has been modified before the exception is thrown'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
inline: java return hash.addPage(page);,return value of addPage is not used,"Work is generic, so add <?> at least",0.3348688650991616,0.0652822882392379,SE,IN,public Work<?> addPage(Page page) { Work<?> work = hash.addPage(page); return work; },"'ResourceSet<E> is correct and stricter than ResourceSet<?>'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"suggestion public PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) { return _partitionMetadataManagerMap.computeIfAbsent(partitionId, PartitionUpsertMetadataManager::new); }",I don't see why we need to do this synchronization. This method is not used by any thread except for the main thread.,"(nit) suggestion.computeIfAbsent(partitionId, k -> new PartitionUpsertMetadataManager(partitionId));",0.035673062290927,0.3055193385440703,IN,AS,"public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) { if(!_partitionMetadataManagerMap.containsKey(partitionId)) { _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId)); } return _partitionMetadataManagerMap.get(partitionId); }","'missed two'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Nitpick braces,If you don't have a formatter you can pass null,We should also validate the input values here.,0.0107455293431533,0.0202582816326282,IN,IN,"protected ModelNode createAddSizeRotatingFileHandlerOperation(String handlerName, String formatterName, String fileName, String rotateSize, int maxBackupIndex) { ModelNode op = Util.createAddOperation(createSizeRotatingFileHandlerAddress(handlerName)); op.get(ModelDescriptionConstants.RELATIVE_TO).set(""log.dir""); op.get(ModelDescriptionConstants.PATH).set(fileName); op.get(ModelDescriptionConstants.FORMATTER).set(formatterName); if (rotateSize != null) op.get(ModelDescriptionConstants.ROTATE_SIZE).set(rotateSize); op.get(ModelDescriptionConstants.MAX_BACKUP_INDEX).set(maxBackupIndex); return op; }","'Nitpick, use braces'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Why not just this.gender = student.gender?,"I'd like to have a check here if the student.gender is null, in which case I would set the gender to null and log a warning message.",I think this can be private.,0.1832605243741068,0.1044395297542074,IN,IN,"public StudentProfile(String fullName, StudentProfileAttributes student, String pictureUrl) { this.pictureUrl = pictureUrl; this.name = fullName; this.shortName = student.shortName; this.gender = Gender.valueOf(student.gender.name()); this.email = student.email; this.institute = student.institute; this.nationality = student.nationality; this.moreInfo = student.moreInfo; }","'Is it worth having null checks?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
new LinkedHashMap<>();,"Please change this to use an explicit type, i.e. Map<String, Attribute>",This will only get the attributes of the entities of the current context. This is probably not what you want.,0.049499796201188,0.005835943380547,IN,IN,"private Map<String, Attribute> getCachedOwnAttrs() { if (cachedOwnAttrs == null) { cachedOwnAttrs = newLinkedHashMap(); getEntities(ATTRIBUTES, Attribute.class) .forEach(attr -> cachedOwnAttrs.put(attr.getName(), attr)); } return cachedOwnAttrs; }","'Why are you doing this just return m_groups it is immutable? Or atl east just use the construct which takes a Collection new ArrayList<>(m_groups);'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Please use assertNotNull from TestNG and fix indents here,this test should probably be renamed to something like testRebootNodes,assertNotNull,0.0803599226969287,0.033890674714179,IN,SE,"public void testReboot() throws Exception { Set<? extends NodeMetadata> rebootNodes = client.rebootNodesMatching(inGroup(group)); for (ComputeMetadata node : rebootNodes) { assert node.getProviderId() != null : node; assert node.getLocation() != null : node; assertEquals(node.getType(), ComputeType.NODE); } testGet(); }","'We don't use final for local variables unless some lambda execution demands it.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
UnchangedCommitMessage,"That's not a good test case, because this exception is thrown for a different reason (not the same message)",UnchangedCommitMessageException,0.0576492224419027,0.6943791127685994,AS,SE,"public void updateMessage() throws Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))) .isEqualTo(RefUpdate.Result.NEW); Optional<ChangeEdit> edit = editUtil.byChange(change); try { modifier.modifyMessage( edit.get(), edit.get().getEditCommit().getFullMessage()); fail(""InvalidChangeOperationException expected""); } catch (UnchangedCommitMessage ex) { assertThat(ex.getMessage()).isEqualTo( ""New commit message cannot be same as existing commit message""); } String msg = String.format(""New commit message\n\nChange-Id: %s"", change.getKey()); assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo( RefUpdate.Result.FORCED); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg); editUtil.publish(edit.get()); assertThat(editUtil.byChange(change).isPresent()).isFalse(); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertThat(info.revisions.get(info.currentRevision).commit.message) .isEqualTo(msg); }","'UnchangedCommitMessageException'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Please use assertNull instead.,"I'm not sure if we want to be relying on the fact that the resolver is not set, and that we're just getting back the default resolver. We should be able to mock this.",usually we use assertEquals ;),0.0215342256651156,0.430923819458906,IN,AS,"public void testGetUserSelectResolverNotSet() { MockEnabledModelResolver resolver1 = new MockEnabledModelResolver(); manager.add(resolver1, resolver1.getClass().getName() + ""1"", """", """"); MockEnabledModelResolver resolver2 = new MockEnabledModelResolver(); manager.add(resolver2, resolver2.getClass().getName() + ""2"", """", """"); MockEnabledModelResolver resolver3 = new MockEnabledModelResolver(); String resolver3Id = resolver3.getClass().getName() + ""3""; manager.add(resolver3, resolver3Id, """", """"); assertEquals(manager.getUserSelectedResolver(), null); }","'I think it is enough for the test to assign and check only once.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
java8-isation [forEach][methodReference],"Maybe a better name than ""newValue""?",you can remove this declaration and use a for loop below,0.0396648934110419,0.149044936985339,IN,IN,"protected void processMultiValuedEAttribute(EAttribute eAttribute, SIRIUS processedDescription, SIRIUS currentDescription, TransformationCache cache) { Object processedValue = processedDescription.eGet(eAttribute); Object currentValue = currentDescription.eGet(eAttribute); if (currentValue instanceof Iterable<?> && processedValue instanceof Iterable<?>) { List<Object> newValue = new ArrayList<>(); Iterable<?> currentIterable = (Iterable<?>) currentValue; Iterable<?> processedIterable = (Iterable<?>) processedValue; for (Object object : currentIterable) { newValue.add(object); } for (Object object : processedIterable) { newValue.add(object); } processedDescription.eSet(eAttribute, newValue); } }","'java8-isation [forEach][filter]'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
can be this(new ArrayList<Integer>(other.pattern));,Collections.unmodifiableList,Collections.unmodifiableList(other.pattern) should be used here.,0.0519956634885638,0.3295825246319872,IN,IN,public JsonPattern(JsonPattern other) { pattern = new ArrayList<Integer>(other.pattern); },"'Please add check for null for newItemsRegistry'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Plays the current, not the previous.",this should be the station that was played before the current station. The current station is the one that was played before the station that was played before the current station.,"This plays the current, not the previous station.",0.1077082250390988,0.688969763019509,SE,SE,"public void previous() { if (currentStation != null) new GetRealLinkAndPlayTask(itsContext, currentStation, itsBinder).execute(); }","'This plays the current, not the next station.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.",This should be IllegalArgumentException and not IndexOutOfBoundsException.,"@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.",0.4125654826539756,1.0,IN,PP,"public void add(final int index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(this.message, ex); } }","'@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
use java.util.Objects,Shouldn't this be obj.getClass() == this.getClass()?,This is a bit unclear. Do we really want to check that the classes are the same? It's a bit strange to be checking classes for equality. I'd be tempted to just do if (this.channel == other.channel) { return true; },0.0249007256780406,0.0089284191183938,IN,IN,public boolean equals(final Object obj) { if (this == obj) { return true; } if (!super.equals(obj)) { return false; } if (this.getClass() != obj.getClass()) { return false; } final SmartMeterConverter other = (SmartMeterConverter) obj; if (this.helper == null) { if (other.helper != null) { return false; } } else if (!this.helper.equals(other.helper)) { return false; } return true; },"'use java.util.Objects.equals'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Response is not closed,Should we add the name of the project to the log message?,Use a constant for the status code.,0.0292581608881418,0.091889935403133,IN,IN,"public static Map<String, Long> getAllVersions(final ZephyrRestClient restClient, final Long projectID) { final Map<String, Long> versions = new HashMap<>(); final String url = String.format(URL_GET_VERSIONS, restClient.getUrl(), projectID); final HttpResponse response = restClient.get(url); final int statusCode = response.getStatusLine().getStatusCode(); if (statusCode >= 200 && statusCode < 300) { final HttpEntity entity = response.getEntity(); String string = null; try { string = EntityUtils.toString(entity); } catch (ParseException | IOException e) { ZephyrPlugin.log(e); } final JsonArray projArray = new JsonParser().parse(string).getAsJsonArray(); for (int i = 0; i < projArray.size(); i++) { final Long id = projArray.get(i).getAsJsonObject().get(""id"").getAsLong(); final String projName = projArray.get(i).getAsJsonObject().get(""name"").getAsString(); versions.put(projName, id); } } else { ZephyrPlugin.log(""Unexpected response status: "" + statusCode); } return versions; }","'Resource leak.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"@ekondrashev Same here, let's declare Exception being thrown.",I think this is a bit confusing. You have two different headers here. One with a cache-control header and one without. I would prefer to have two separate tests for each.,"@ekondrashev I think we can simplify this assertion by just not checking for ""cache-control"" key at all.",0.0626527379001323,0.2401278052974207,IN,AS,"public void testsHeaderNotAvailable() throws IOException { MatcherAssert.assertThat( new RsWithBody(""<html></html>""), new HmRsHeader( Matchers.not( Matchers.hasEntry( ""cache-control"", ""no-cache, no-store"" ) ) ) ); }","'@ekondrashev Same here, let's declare Exception being thrown.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
rename 'resource',This will cause an NPE if there is only one resource and it is a folder.,The resourceData[0] is a project. This means you should check if all the elements in resourceData are of type IProject.,0.1112342308086802,0.0713892952762454,IN,IN,"public void run() { ResourceTransfer resTransfer = ResourceTransfer.getInstance(); IResource[] resourceData = (IResource[]) clipboard.getContents(resTransfer); if (resourceData != null && resourceData.length > 0) { if (resourceData[0].getType() == IResource.PROJECT) { for (IResource element : resourceData) { CopyProjectOperation operation = new CopyProjectOperation(shell); operation.copyProject((IProject) element); } } else { IContainer container = getContainer(); CopyFilesAndFoldersOperation operation = new CopyFilesAndFoldersOperation(shell); operation.copyResources(resourceData, container); } return; } FileTransfer fileTransfer = FileTransfer.getInstance(); String[] fileData = (String[]) clipboard.getContents(fileTransfer); if (fileData != null) { IContainer container = getContainer(); CopyFilesAndFoldersOperation operation = new CopyFilesAndFoldersOperation(shell); operation.copyFiles(fileData, container); } }","'style nit: remove unnecessary blank line'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
The local variable *ListData* should be renamed to *listData* as per local variable naming conventions.,"this method can be simplified a bit, i would suggest the following:  List<Integer> gids = data.stream().map(ListDataProject::getGermplasmId).collect(Collectors.toList()); Map<Integer, String> stockIds = inventoryDataManager.retrieveStockIds(gids); data.forEach(listDataProject -> { if (stockIds!= null) { stockIdValue = stockIds.get(listDataProject.getGermplasmId()); } listDataProject.setStockIDs(stockIdValue); });","again, ListData should be renamed to listData",0.0902012653520833,0.2221761966132227,IN,SE,"public static void populateStockIdInListDataProject(final List<ListDataProject> data , InventoryDataManager inventoryDataManager) { final List<Integer> gids = new ArrayList<>(); if (data != null && !data.isEmpty()) { for (final ListDataProject listDataProject : data) { gids.add(listDataProject.getGermplasmId()); } } Map<Integer, String> stockIds = inventoryDataManager.retrieveStockIds(gids); if (data != null && !data.isEmpty()) { for (final ListDataProject ListData : data) { String stockIdValue = """"; if (stockIds != null) { for (final Integer gid : stockIds.keySet()) { if (ListData.getGermplasmId().equals(gid)) { stockIdValue = stockIds.get(gid); break; } } } ListData.setStockIDs(stockIdValue); } } }","'Again, the local variable ListData should be renamed to listData as per local variable naming conventions.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Can you please add className to error message?,I would prefer to add the model name in the exception message.,"please move it to constructor declaration, so it will be executed only once",0.2927083356604698,0.1778114792642108,IN,IN,"public static Map<String, String> getKiePMMLScorecardModelSourcesMap(final DataDictionary dataDictionary, final Scorecard model, final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap, final String packageName) { logger.trace(""getKiePMMLScorecardModelSourcesMap {} {} {}"", dataDictionary, model, packageName); CompilationUnit cloneCU = getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, KIE_PMML_SCORECARD_MODEL_TEMPLATE_JAVA, KIE_PMML_SCORECARD_MODEL_TEMPLATE); String className = getSanitizedClassName(model.getModelName()); ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(className) .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND)); final ConstructorDeclaration constructorDeclaration = modelTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(""Missing default constructor in ClassOrInterfaceDeclaration %s "", modelTemplate.getName()))); setSuperInvocation(model, constructorDeclaration, modelTemplate.getName()); Map<String, String> toReturn = new HashMap<>(); String fullClassName = packageName + ""."" + className; toReturn.put(fullClassName, cloneCU.toString()); return toReturn; }","'Can you please add className to error message?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
so just use getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool());,"You should use getIsWipeAfterDelete() here, so that you don't need to call it again inside the if.","I'm not sure this is the right place for this check. You should check in the UI if the VM is attached to a pool and if it is - disable the checkbox. The UI should do this check, not the VM itself.",0.3384965088373743,0.0734983673598295,SE,IN,protected void updateWipeAfterDeleteChangeability() { if (isVmAttachedToPool()) { getIsWipeAfterDelete().setIsChangeable(false); } else { getIsWipeAfterDelete().setIsChangeable(true); } },"'Is it save to assign a new subscription here without unsubscribing a potentially existing previous subscription? Or to ask different: Can you guarantee this is not called two times in a row in the activity lifecycle with requireGeodata==true?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"FYI, 2 can be replaced by ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER","@davidkresten, I think you should use the CeWsModule.class and not the CeWsModule.","FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER",0.028713749623237,0.7747170081255814,IN,SE,public void verify_count_of_added_components() { ComponentContainer container = new ComponentContainer(); new CeWsModule().configure(container); assertThat(container.size()).isEqualTo(12 + 2 ); },"'FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
You should return an empty RepositoryDTO here,If you use the RepositoryDTO.Builder you don't need to build it. RepositoryDTO.Builder has a method build() which returns a RepositoryDTO.,"I think this is wrong, the repository is called ""classpath repository"" and it contains the classpath categories. I would rename the repository name to something like ""Classpath Repository"" or something like that.",0.1799102060666936,0.0952292278121862,SE,IN,"public RepositoryDTO fetchInstallableApplications() { try { final List<CategoryDTO> categoryDTOs = new ArrayList<>(); Resource[] resources = resourceResolver.getResources(packagePath + ""/*""); for (Resource resource : resources) { final CategoryDTO category = buildCategory(resource.getFilename()); if (!category.getApplications().isEmpty()) { categoryDTOs.add(category); } } Collections.sort(categoryDTOs, Comparator.comparing(CategoryDTO::getName)); final RepositoryDTO.Builder repositoryDTOBuilder = new RepositoryDTO.Builder() .withName(""classpath repository"").withCategories(categoryDTOs); return repositoryDTOBuilder.build(); } catch (IOException e) { LOGGER.warn(""Error while reading resource directory"", e); return null; } }","'be careful here. The old code was done so that the loading of the Language was done within the try-catch block, allowing us to capture the UnsupportedClassVersionError (when running under Java 7 with Apex in the classpath). This change will simply break at this point without being captured and skipped.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"add message ""renewer in "" + ids","suggestion assertEquals(""credentials in "" + ids, id.getMarshalledCredentials(), result.getMarshalledCredentials());","message ""renewer in "" + ids",0.1191208626374848,0.8623033568332588,IN,SE,"public void testSessionTokenIdentifierRoundTripNoRenewer() throws Throwable { SessionTokenIdentifier id = new SessionTokenIdentifier( SESSION_TOKEN_KIND, new Text(), null, landsatUri, new MarshalledCredentials(""a"", ""b"", ""c""), new EncryptionSecrets(), """"); SessionTokenIdentifier result = S3ATestUtils.roundTrip(id, null); String ids = id.toString(); assertEquals(""URI in "" + ids, id.getUri(), result.getUri()); assertEquals(""credentials in "" + ids, id.getMarshalledCredentials(), result.getMarshalledCredentials()); assertEquals(new Text(), id.getRenewer()); }","'yarn@EXAMPLE.COM?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"suggestion timer = getMetrics().timer(""key-validate"");",Should we create a separate timer for key-create and key-read?,"suggestion timer = getMetrics().timer(""file-read"");",0.1786579703841273,0.7709823457023088,AS,SE,"public Void call() throws Exception { init(); OzoneConfiguration ozoneConfiguration = createOzoneConfiguration(); rpcClient = OzoneClientFactory.getRpcClient(ozoneConfiguration); try (InputStream stream = rpcClient.getObjectStore().getVolume(volumeName) .getBucket(bucketName).readKey(generateObjectName(0))) { referenceDigest = getDigest(stream); } timer = getMetrics().timer(""key-create""); runTests(this::validateKey); return null; }","'suggestion timer = getMetrics().timer(""file-read"");'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
new Double() is redundant here,I'm not sure why we're using a Double here. I think we should be using a double and just using the valueOf method to get the Double if it's required.,new Double is redundant here,0.0951591977074695,0.8756115931199443,SE,SE,public Object getResult(VarianceData data) { return new Double(data.squaredSum / data.count); },"'new Double is redundant here'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
null != settings,Is there a reason to keep this private?,null!= settings,0.0129383129414271,0.8196501312471536,IN,PP,private void restoreWidgetValues() { IDialogSettings settings = getDialogSettings(); if (settings != null) { openType = settings.getBoolean(STORE_OPEN_TYPE_ID); replaceSource = settings.getBoolean(STORE_REPLACE_SOURCE_ID); } },"'null != settings'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(worldpayTemplateData::setState);,"I'm not sure I'd make this a public method. I think this should be internal to the OrderRequestBuilder and used by the OrderRequestBuilderFactory. It's not something a client would use, and it's something that should be used with caution.",java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).ifPresent(stateOrProvince -> worldpayTemplateData.setState(stateOrProvince.getAbbreviation()));,0.0523818287115147,0.7714846218582669,IN,IN,public OrderRequestBuilder withAuthorisationDetails(AuthCardDetails authCardDetails) { OrderRequestBuilder orderRequestBuilder = super.withAuthorisationDetails(authCardDetails); authCardDetails.getAddress().ifPresent(address -> northAmericanRegionMapper.getNorthAmericanRegionForCountry(address) .ifPresent(stateOrProvince -> worldpayTemplateData.setState(stateOrProvince.getAbbreviation())) ); return orderRequestBuilder; },"'java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
please check that the bitstreamformat is still here,I don't think this should be in here,check that the bitstreamformat is still here,0.2257496993045733,0.8529188173702603,IN,SE,"public void deleteNonAdminAccess() throws Exception { ObjectMapper mapper = new ObjectMapper(); context.turnOffAuthorisationSystem(); BitstreamFormat bitstreamFormat = BitstreamFormatBuilder.createBitstreamFormat(context) .withMimeType(""application/octet-stream"") .withDescription(""Description - updateAdminAccess"") .build(); EPerson user = EPersonBuilder.createEPerson(context) .withNameInMetadata(""first"", ""last"") .withEmail(""testaze@gmail.com"") .withPassword(password) .withLanguage(I18nUtil.getDefaultLocale().getLanguage()) .build(); context.restoreAuthSystemState(); String token = getAuthToken(user.getEmail(), password); getClient(token).perform(delete(""/api/core/bitstreamformats/"" + bitstreamFormat.getID())) .andExpect(status().isForbidden()); }","'check that the bitstreamformat is still here'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Component type for the inactive device exception should be DOMAIN_TARIFF_SWITCHING here.,"If you want to add this, please move this to a private method.",Component type for the inactive device exception should be DOMAIN_CORE here.,0.0768256876476486,0.7960044216855081,IN,SE,"protected Device findActiveDevice(final String deviceIdentification) throws FunctionalException { Device device; try { device = this.deviceDomainService.searchActiveDevice(deviceIdentification); } catch (final UnregisteredDeviceException e) { throw new FunctionalException(FunctionalExceptionType.UNREGISTERED_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } catch (final InactiveDeviceException e) { throw new FunctionalException(FunctionalExceptionType.INACTIVE_DEVICE, ComponentType.DOMAIN_CORE, e); } catch (final UnknownEntityException e) { throw new FunctionalException(FunctionalExceptionType.UNKNOWN_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } return device; }","'Component type for the inactive device exception should be DOMAIN_PUBLIC_LIGHTING here.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Check args ?,Please add curly brackets.,"I think the code is cleaner with this:  final double[] tk = new double[] {t, k}; return func.evaluate(tk);  (and remove the Function2D).",0.0392230500716946,0.0099892824031117,IN,IN,"public VolatilitySurface getVolSurface(final DoubleMatrix1D modelParameters) { final Function1D<double[], Double> func = new BasisFunctionAggregation<>(_bSplines, modelParameters.getData()); final Function2D<Double, Double> func2D = new Function2D<Double, Double>() { @Override public Double evaluate(final Double t, final Double k) { return func.evaluate(new double[] {t, k }); } }; final FunctionalDoublesSurface surface = new FunctionalDoublesSurface(func2D); return new VolatilitySurface(surface); }","'Check args?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,The deviceId.getDeviceIdG() is used in the request. It is not used in the request response. So it should not be passed in the properties map.,SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,0.2368345325990564,0.8654856896987353,IN,SE,"public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }","'SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
just return this.count < this.values.count();,this is not necessary,I think this is just return this.count < this.values.count();,0.0644758996329196,0.7309799441474696,IN,SE,public boolean hasNext() { if (this.count < this.values.count()) { return true; } return false; },"'Again, just return the boolean value.'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
Please remove System.out,Should we remove this debug statement?,Please remove System.out,0.2874560662474439,1.0,IN,PP,"@Override public void preBatchMutate(ObserverContext<RegionCoprocessorEnvironment> c, MiniBatchOperationInProgress<Mutation> miniBatchOp) throws IOException { System.out.println(""Fail once my coproc "" + this); if (failOnce) { failOnce = false; throw new IOException(); } }","'Please remove System.out'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
this method should be changed to private,You can use Collections.unmodifiableMap(),This should be private,0.0429547037228289,0.3832819081688798,IN,SE,"public HashMap<String, ArrayList<Order>> getBuyOrders() { return buyOrders; }","'this method should be changed to private'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"@lautarobock Here too, let's declare throws Exception.","This is a bit of a pain, but we could use the same test as in the previous commit to ensure that the new behavior is the same as the old one.",@lautarobock We don't need this throws.,0.0638667591066795,0.3742282152220731,IN,IN,"public void testOneFail() throws IOException { final List<Pass> list = new ArrayList<Pass>(1); list.add(new PsFake(false)); final Opt<Identity> identity = new PsAll(list, 0).enter(new RqFake()); MatcherAssert.assertThat( identity.has(), Matchers.is(false) ); }","'@lautarobock Same here, let's declare throws Exception'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
try-with-resources,"I'm not sure why you are using a do-while loop here. You're not checking the numberOfTries value at the end of the loop, so you're just going to keep retrying forever.",this is the same code that we wrote for the other one,0.0179746196357355,0.019905857061151,IN,IN,"public synchronized JDBCConfiguration getJDBCDiskQuotaConfig() throws IOException, org.geowebcache.config.ConfigurationException { Resource configFile = configDir.get(""geowebcache-diskquota-jdbc.xml""); if (!Resources.exists(configFile)) { return null; } try { JDBCConfiguration configuration; InputStream is = configFile.in(); try { configuration = JDBCConfiguration.load(is); } finally { is.close(); } return passwordHelper.unencryptPassword(configuration); } catch (Exception e) { LOGGER.log(Level.SEVERE, ""Failed to load geowebcache-diskquota-jdbc.xml"", e); return null; } }","'Since this error catch in later I think we don't need log error again and print it. WDYT?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
isUnauthorized 403,"Please also test that the _links.self.href is not the same as the REST_SERVER_URL + ""config/submissionforms"" (since it's not supposed to be).",isUnauthorized 401,0.0173915522930294,0.9391044157537524,IN,SE,"public void findAll() throws Exception { getClient().perform(get(""/api/config/submissionforms"")) .andExpect(status().isForbidden()); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get(""/api/config/submissionforms"")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath(""$.page.size"", is(20))) .andExpect(jsonPath(""$.page.totalElements"", greaterThanOrEqualTo(1))) .andExpect(jsonPath(""$.page.totalPages"", greaterThanOrEqualTo(1))) .andExpect(jsonPath(""$.page.number"", is(0))) .andExpect( jsonPath(""$._links.self.href"", Matchers.startsWith(REST_SERVER_URL + ""config/submissionforms""))) .andExpect(jsonPath(""$._embedded.submissionforms"", hasSize(greaterThanOrEqualTo(1)))) ; }","'isUnauthorized 403 ?'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private,This can't be used with WebSocketClientHandshaker13,nit: super.setForceCloseTimeoutMillis(...),0.0144922706862988,0.0275729803995208,IN,SE,public WebSocketClientHandshaker13 setForceCloseTimeoutMillis(long forceCloseTimeoutMillis) { this.forceCloseTimeoutMillis = forceCloseTimeoutMillis; return this; },"'nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>",I don't think we need the last expectCause.,"@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>",0.0601440595515405,1.0,IN,PP,"public final void wrapsIndexOutOfBoundsExceptionFromSubList() throws Exception { final int frmidx = 2; final int toidx = 5; final Exception cause = new IndexOutOfBoundsException(); Mockito.doThrow(cause).when(this.origin).subList(frmidx, toidx); this.thrown.expect(IllegalArgumentException.class); this.thrown.expectMessage(MSG); this.thrown.expectCause(Matchers.is(cause)); this.list.subList(frmidx, toidx); }","'While strictly correct, it looks weird to have a size assertion of 2, next to a contains assertion with only one element. A single containsExactly(1,1) would match expectations better'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
static imports,why not just use the super constructor?,Why not use the default validator here?,0.0287153189672187,0.0279688282538684,IN,IN,"public AbstractStringAssert<?> asHexString() { objects.assertNotNull(info, actual); return Assertions.assertThat(Hexadecimals.toHexString(actual)); }","'Let us have a common style in this file VdsProperties.ADDR'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
latch,Why is this necessary? The test will be flaky if this is the case.,"We should add a message here that says something like ""Expected success edit result but got something else"" or something similar.",0.0126205902254093,0.0081763366973136,IN,IN,"public void testCaptcha() { PageTitle title = new PageTitle(null, ""Test_page_for_app_testing/Captcha"", TEST_WIKI_SITE); String wikitext = ""== Section 2 ==\n\nEditing by inserting an external link https://"" + System.currentTimeMillis(); service.edit(TEST_WIKI_SITE, title, DEFAULT_SECTION_ID, wikitext, ANONYMOUS_TOKEN, DEFAULT_SUMMARY, false, null, null, new Edit.Callback() { @Override public void success(@NonNull EditingResult result) { validateCaptcha(result); } @Override public void failure(@NonNull Throwable caught) { throw new RuntimeException(caught); } }); }","'latch'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
"Just for consistency, please use final boolean actual","This is also a bit unclear, since this test does not check the expectedClass parameter. I'd expect it to check the rule and expectedClass parameter.",Please use final boolean actual,0.0389072424176547,0.4751071107866479,IN,SE,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule, context); assertFalse(actual); }","'Just for consistency, please use final boolean actual'. Limit your review to 1 or 2 sentences, and do not introduce any code details."
