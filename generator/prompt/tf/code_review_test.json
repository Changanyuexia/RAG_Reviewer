[{"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private ByteArrayInputStream uploadPackV2(String... inputLines) throws Exception { ByteArrayOutputStream send = new ByteArrayOutputStream(); PacketLineOut pckOut = new PacketLineOut(send); for (String line : inputLines) { if (line == PacketLineIn.END) { pckOut.end(); } else if (line == PacketLineIn.DELIM) { pckOut.writeDelim(); } else { pckOut.writeString(line); } } UploadPack up = new UploadPack(server); up.setUseProtocolV2(true); ByteArrayOutputStream recv = new ByteArrayOutputStream(); up.upload(new ByteArrayInputStream(send.toByteArray()), recv, null); ByteArrayInputStream recvStream = new ByteArrayInputStream(recv.toByteArray()); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(\"version 2\")); assertThat(pckIn.readString(), is(\"ls-refs\")); assertThat(pckIn.readString(), is(\"fetch=shallow\")); assertTrue(pckIn.readString() == PacketLineIn.END); return recvStream; }", "output": "Let's add a constant for \"version 2\""}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void repaint() { if (graph != null) { System.out.println(\"repainting graph...\"); Tile model = new Tile(graph); TileView view = new TileView(); TileController tc = new TileController(view, model); Group root = new Group(); wrapper.hvalueProperty().addListener( (ChangeListener<Number>) (ov, oldVal, newVal) -> { repaintPosition(tc, root, newVal.doubleValue()); }); Rectangle clip = new Rectangle(getMaxUnifiedEnd(graph) * VertexView.HORIZONTALSCALE, 0); root.getChildren().add(clip); repaintPosition(tc, root, wrapper.hvalueProperty().doubleValue()); } }", "output": "Iffy formatting"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Request iterate(final Request req, final Coordinates cords) { return null; }", "output": "don't return NULL, throw UnsupportedOperatedException instead"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public MamQueryIQ parse(XmlPullParser parser, int initialDepth) throws Exception { String queryId = null; String node = null; DataForm dataForm = null; if (parser.getName().equals(MamQueryIQ.ELEMENT)) { queryId = parser.getAttributeValue(\"\", \"queryid\"); node = parser.getAttributeValue(\"\", \"node\"); boolean done = false; while (!done) { int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) { if (parser.getName().equals(DataForm.ELEMENT)) { dataForm = new DataFormProvider().parse(parser); } } else if (eventType == XmlPullParser.END_TAG) { if (parser.getName().equals(MamQueryIQ.ELEMENT)) { done = true; } } } } return new MamQueryIQ(queryId, node, dataForm); }", "output": "That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static <T> TypeToken<T> getTypeToken(TypeToken<T> token, Class<? super T> raw) { if (raw!=null) return TypeToken.of((Class<T>)raw); if (token!=null) return token; throw new IllegalStateException(\"Both indicators of type are null\"); }", "output": "Should this not prefer the token over the raw?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void initPlugins() throws Exception { Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps(); for (InitStep initStep : pluginsInitSteps) { initStep.run(); } }", "output": "It would have been shorter to inline this variable and not have it in scope. :-)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public <T> T cast(FormField<?> formField) { if (getDefaultOrNull(formField)) { return null; } if (this == formField.getValueType()) { return (T) formField.getValue(); } else if (STRING == formField.getValueType()) { return (T) formField.getValue().toString(); } else { throw LOGGER.logExceptionAsError(new UnsupportedOperationException(String.format(\"Cannot cast from \" + \"field value of type %s to type %s\", formField.getValueType(), PHONE_NUMBER))); } }", "output": "Is toString() required? It's already of STRING type."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public LengthFieldBasedFrameDecoder( ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, boolean failFast) { checkPositive(maxFrameLength, \"maxFrameLength\"); checkPositiveOrZero(lengthFieldOffset, \"lengthFieldOffset\"); checkPositiveOrZero(initialBytesToStrip, \"initialBytesToStrip\"); if (lengthFieldOffset > maxFrameLength - lengthFieldLength) { throw new IllegalArgumentException( \"maxFrameLength (\" + maxFrameLength + \") \" + \"must be equal to or greater than \" + \"lengthFieldOffset (\" + lengthFieldOffset + \") + \" + \"lengthFieldLength (\" + lengthFieldLength + \").\"); } this.byteOrder = checkNotNull(byteOrder, \"byteOrder\"); this.maxFrameLength = maxFrameLength; this.lengthFieldOffset = lengthFieldOffset; this.lengthFieldLength = lengthFieldLength; this.lengthAdjustment = lengthAdjustment; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength; this.initialBytesToStrip = initialBytesToStrip; this.failFast = failFast; }", "output": "move the check and assignment before the other checks to ensure the behaviour is not changed."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - 1 - endOfTableName); return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }", "output": "might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void ThrottleForNormalizeTestWithinIdeal() throws Exception { List<RateLimit> scenarios = new ArrayList<>(); int limit = 5000; int buffer = ApiRateLimitChecker.calculateBuffer(limit); int approximateIdeal = 4000; scenarios.add(new RateLimit(limit, approximateIdeal + buffer - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 101, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, limit, soon)); setupStubs(scenarios); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(1, countOfOutputLinesContaining(\"under budget\")); assertFalse(handler.getView().stream().anyMatch(m -> m.getMessage().contains(\"Sleeping\"))); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(2, countOfOutputLinesContaining(\"rechecking\")); assertEquals(3, countOfOutputLinesContaining(\"Still sleeping\")); assertEquals(2, countOfOutputLinesContaining(\"Sleeping for\")); assertEquals(1, countOfOutputLinesContaining(\"under budget\")); assertEquals(10, handler.getView().size()); }", "output": "EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean cleanupNode(final String id) { RegionAndId regionAndId = RegionAndId.fromSlashEncoded(id); ResourceGroup resourceGroup = resourceGroupMap.getUnchecked(regionAndId.region()); String group = resourceGroup.name(); VirtualMachine virtualMachine = api.getVirtualMachineApi(group).get(regionAndId.id()); if (virtualMachine == null) { return true; } logger.debug(\">> destroying %s ...\", regionAndId.slashEncode()); boolean vmDeleted = deleteVirtualMachine(group, virtualMachine); cleanupVirtualMachineNICs(group, virtualMachine); cleanupVirtualMachineStorage(group, virtualMachine); return vmDeleted; }", "output": "[minor] could you name it resourceGroupName"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Factory(long nowMillis, Request request, Response cacheResponse) { this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; if (cacheResponse != null) { this.sentRequestMillis = cacheResponse.sentRequestAtMillis(); this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis(); Headers headers = cacheResponse.headers(); for (int i = 0, size = headers.size(); i < size; i++) { String fieldName = headers.name(i); String value = headers.value(i); if (\"Date\".equalsIgnoreCase(fieldName)) { servedDate = HttpDate.parse(value); servedDateString = value; } else if (\"Expires\".equalsIgnoreCase(fieldName)) { expires = HttpDate.parse(value); } else if (\"Last-Modified\".equalsIgnoreCase(fieldName)) { lastModified = HttpDate.parse(value); lastModifiedString = value; } else if (\"ETag\".equalsIgnoreCase(fieldName)) { etag = value; } else if (\"Age\".equalsIgnoreCase(fieldName)) { ageSeconds = UtilKtKt.toNonNegativeInt(value, -1); } } } }", "output": "UtilKtKt isn't a great name."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void doResolveAll(String inetHost, DnsRecord[] additionals, Promise<List<InetAddress>> promise, DnsCache resolveCache) throws Exception { if (inetHost == null || inetHost.isEmpty()) { promise.setSuccess(Collections.singletonList(loopbackAddress())); return; } final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost); if (bytes != null) { promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes))); return; } final String hostname = hostname(inetHost); InetAddress hostsFileEntry = resolveHostsFileEntry(hostname); if (hostsFileEntry != null) { promise.setSuccess(Collections.singletonList(hostsFileEntry)); return; } CacheResult res = doResolveAllCached(hostname, additionals, promise, resolveCache, resolvedInternetProtocolFamilies); if (res == CacheResult.CACHED) { return; } if (res == CacheResult.CACHED_EXPIRED) { promise = executor().newPromise(); } doResolveAllUncached(hostname, additionals, promise, promise, resolveCache, completeOncePreferredResolved); }", "output": "consider using a switch(res) {...}"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private List<Resource> filterNotAuthorizedResource(PerunSession sess, List<Resource> resources) throws InternalErrorException { Iterator<Resource> resIterator = resources.iterator(); while(resIterator.hasNext()) { Resource resource = resIterator.next(); if(!AuthzResolver.isAuthorized(sess, Role.RESOURCEADMIN, resource) && !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) resIterator.remove(); } return resources; }", "output": "For PerunObserver you can return all resources immediately."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void initTrackerServers(List<TrackerServer> serverList) { serverList.add(new TrackerServer(new ServerBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(\"objectDecoder\", new AstraProtocolDecoder(AstraProtocol.this)); } }); serverList.add(new TrackerServer(new ConnectionlessBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(\"objectDecoder\", new AstraProtocolDecoder(AstraProtocol.this)); } }); }", "output": "UDP is a datagram protocol, so it doesn't require frame decoder."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected Properties getIntegrationProperties() { if (this.beanFactory != null) { return IntegrationContextUtils.getIntegrationProperties(this.beanFactory); } else { return null; } }", "output": "Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testShowStatsSelectNonStarFails() { assertQueryFails(\"SHOW STATS FOR (SELECT nationkey FROM nation_partitioned)\", \".*Only SELECT \\\\* is supported in SHOW STATS SELECT clause\"); }", "output": "Why this change?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected static ConnectionFactory getConnectionFactory( IDatabaseConnection databaseConnection, String url ) { ConnectionFactory factory = null; if ( url.startsWith( \"jdbc:mysql:\" ) || ( url.startsWith( \"jdbc:mariadb:\" ) ) ) { Properties props = new Properties(); props.put( \"user\", StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ) ); props.put( \"password\", StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); props.put( \"socketTimeout\", \"0\" ); props.put( \"connectTimeout\", \"5000\" ); factory = new DriverManagerConnectionFactory( url, props ); } else { factory = new DriverManagerConnectionFactory( url, StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ), StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); } return factory; }", "output": "We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testDisableIncrementalAnalysis() { executeTarget(\"testDisableIncrementalAnalysis\"); assertOutputContaining(\"Avoid really long methods\"); }", "output": "you should check the cache doesn't exist, plus that no suggestion to use the cache is logged"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void preInstall() { resolver = Entities.newDownloader(this); String subpath = entity.getConfig(BrooklynNode.SUBPATH_IN_ARCHIVE); if (subpath==null) { String uploadUrl = entity.getConfig(BrooklynNode.DISTRO_UPLOAD_URL); String origDownloadName = uploadUrl; if (origDownloadName==null) { String downloadUrlTemplate = entity.getAttribute(BrooklynNode.DOWNLOAD_URL); if (downloadUrlTemplate!=null) { origDownloadName = DownloadSubstituters.substitute(downloadUrlTemplate, DownloadSubstituters.getBasicEntitySubstitutions(this)); } } if (origDownloadName!=null) { origDownloadName = Urls.getBasename(origDownloadName); String downloadName = origDownloadName; downloadName = Strings.removeFromEnd(downloadName, \".tar.gz\"); downloadName = Strings.removeFromEnd(downloadName, \".tgz\"); downloadName = Strings.removeFromEnd(downloadName, \".zip\"); if (!downloadName.equals(origDownloadName)) { downloadName = Strings.removeFromEnd(downloadName, \"-dist\"); subpath = downloadName; } } } if (subpath==null) subpath = format(\"brooklyn-%s\", getVersion()); setExpandedInstallDir(Os.mergePaths(getInstallDir(), resolver.getUnpackedDirectoryName(subpath))); }", "output": "Make sure to unescape the url path before using it. I've hit this in actual usage."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean isLaunchedFromIntent() { return invokeSource.equals(InvokeSource.WIDGET) || invokeSource.equals(InvokeSource.INTENT_SHARE) || invokeSource.equals(InvokeSource.INTENT_PROCESS_TEXT); }", "output": "A future refactor might place this method in the enum directly."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void initializeAsyncCancelAndVerifyCancelled(AlwaysFailingInitializer initializer, Runnable cleanupTask) throws InterruptedException { initializer.initialize(true); initializer.cancelInitialization(cleanupTask); int numberOfAttemptsWhenCancelled = initializer.initializationAttempts; initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY * 5 + 1, TimeUnit.MILLISECONDS); assertThat(initializer.initializationAttempts).isEqualTo(numberOfAttemptsWhenCancelled); }", "output": "We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ExecutorService getExecutor(Properties p) { TypedProperties tp = TypedProperties.toTypedProperties(p); int maxThreads = tp.getIntProperty(\"maxThreads\", 1); int queueSize = tp.getIntProperty(\"queueSize\", 100000); long keepAliveTime = tp.getLongProperty(\"keepAlive\", 10000); final int threadPrio = tp.getIntProperty(\"threadPriority\", Thread.MIN_PRIORITY); final String threadNamePrefix = tp.getProperty(\"threadNamePrefix\", tp.getProperty(\"componentName\", \"Thread\")); final String threadNameSuffix = tp.getProperty(\"threadNameSuffix\", \"\"); ThreadFactory tf = new ThreadFactory() { @Override public Thread newThread(Runnable r) { String threadName = threadNamePrefix + \"-\" + counter.getAndIncrement() + threadNameSuffix; Thread th = new Thread(r, threadName); th.setDaemon(true); th.setPriority(threadPrio); return th; } }; ThreadPoolExecutor tpe = new ThreadPoolExecutor(maxThreads, maxThreads, keepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(queueSize), tf, new ThreadPoolExecutor.CallerRunsPolicy()); tpe.allowCoreThreadTimeOut(true); return tpe; }", "output": "I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public GWCConfig getConfig() { if (gsEnvironment != null && gsEnvironment.isStale()) { syncEnvironment(); } return gwcConfigPersister.getConfig(); }", "output": "This bloc of code is repeated many times, should be centralized in a single method."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void captureScreenshot(String comment, WebDriver driver, WebElement element, boolean errorMessage) { if (getMessage(errorMessage) != null) { comment = getMessage(errorMessage); } LOGGER.debug(\"DriverListener->captureScreenshot starting...\"); try { if (errorMessage) { LOGGER.error(comment); Screenshot.captureFailure(driver, comment); } else { LOGGER.info(comment); if (MobileContextHelper.isInWebViewContext()) { MobileContextHelper.backUpContext(driver); Screenshot.capture(driver, comment); MobileContextHelper.restoreContext(driver); } else { Screenshot.capture(driver, comment); } } } catch (Exception e) { LOGGER.debug(\"Unrecognized failure detected in DriverListener->captureScreenshot: \" + e.getMessage(), e); } finally { resetMessages(); } LOGGER.debug(\"DriverListener->captureScreenshot finished...\"); }", "output": "I don't see sense from this if (MobileContextHelper.isInWebViewContext())"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) { super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.my_courses, menu); final Config config = environment.getConfig(); if (config.isTabsLayoutEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(false); menu.findItem(R.id.menu_item_account).setVisible(true); menu.findItem(R.id.menu_item_account).setIcon( new IconDrawable(getContext(), FontAwesomeIcons.fa_gear) .colorRes(getContext(), R.color.white) .actionBarSize(getContext())); } else { menu.findItem(R.id.menu_item_account).setVisible(false); if (config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(true); } else { menu.findItem(R.id.menu_item_search).setVisible(false); } } }", "output": "This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled())"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected List<AttributeStatement> createSubjectRoleStatement(final CallbackProperties properties) throws SAMLAssertionBuilderException { final String userCode = properties.getUserCode(); final String userSystem = properties.getUserSystem(); final String userSystemName = properties.getUserSystemName(); final String userDisplay = properties.getUserDisplay(); if (Arrays.asList(userCode, userSystem, userSystemName, userDisplay).contains(null)) { LOG.error(\"No information provided to fill in user role attribute..\"); throw new SAMLAssertionBuilderException(\"No information provided to fill in user role attribute.\"); } final List<AttributeStatement> statements = new ArrayList<>(); final List<Attribute> attributes = new ArrayList<>(); attributes.add(componentBuilder.createUserRoleAttribute(userCode, userSystem, userSystemName, userDisplay)); if (!attributes.isEmpty()) { statements.addAll(componentBuilder.createAttributeStatement(attributes)); } return statements; }", "output": "Can this be changed to createSubjectRoleAttribute?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public LineRanges within(final LineRanges ranges) { final LineRanges result = new LineRanges(); final Iterator<LineRange> iterator = ranges.iterate(); while (iterator.hasNext()) { final LineRange next = iterator.next(); for (final LineRange line : this.lines.collection()) { if (next.within(line)) { result.add(line); } } } return result; }", "output": "@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public GlusterServersListReturnForXmlRpc(Map<String, Object> innerMap) { super(innerMap); List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>(); Object[] serversArr = (Object[]) innerMap.get(GLUSTER_HOSTS); if (serversArr != null) { for (int i = 0; i < serversArr.length; i++) { glusterServers.add(prepareServerInfo((Map<String, Object>) serversArr[i])); } } setServer(glusterServers); }", "output": "Do not try to parse the sever list if the command has failed (mStatus.code != 0)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void buildTestedInstance() { ; this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }", "output": "Floating semicolon"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void parentIsNotCalledIfAccountStatusExceptionIsThrown() { AuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(new AccountStatusException( \"\", new Throwable()) { }); AuthenticationManager parent = mock(AuthenticationManager.class); ProviderManager mgr = new ProviderManager( Collections.singletonList(iThrowAccountStatusException), parent); try { mgr.authenticate(mock(Authentication.class)); fail(\"Expected exception\"); } catch (AccountStatusException expected) { } verifyZeroInteractions(parent); }", "output": "Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void initScanner(Schema projected) throws IOException { this.projector = new Projector(inSchema, outSchema, plan.getTargets()); System.out.println(\"=======================>\" + plan.getTableDesc().getName()); for (FragmentProto f: fragments) { FileFragment ff = (FileFragment)FragmentConvertor.convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), f); System.out.println(\">>>>>>>>>>>>>>>>>>>\" + ff.getPath()); } if (fragments != null) { if (fragments.length > 1) { this.scanner = new MergeScanner(context.getConf(), plan.getPhysicalSchema(), plan.getTableDesc().getMeta(), FragmentConvertor.<FileFragment>convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), fragments), projected ); } else { this.scanner = StorageManagerFactory.getStorageManager( context.getConf()).getScanner(plan.getTableDesc().getMeta(), plan.getPhysicalSchema(), fragments[0], projected); } scanner.init(); } }", "output": "Please remove debug codes."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean put(ConflictTxStream conflictStream) { Long val = cacheConflictKeys.get(conflictStream); if (val != null && val >= conflictStream.txVersion) { log.error(\"For key {}, the value {} is not smaller than the expected value {} or maxWildCard\", conflictStream, cacheConflictKeys.get(conflictStream), conflictStream.txVersion, maxConflictWildcard); return false; } if (cacheConflictKeys.size() == cacheSize) { invalidateFirst(); } cacheEntries.add(conflictStream); cacheConflictKeys.put(conflictStream, conflictStream.txVersion); cacheEntriesBytes += conflictStream.size(); return true; }", "output": "please use long"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(final Collection<BindingSet> bindingSets) throws QueryEvaluationException { return null; }", "output": "Is there a reason this isn't implemented?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static <T> void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }", "output": "nit: unnecessary generic type declaration"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Integer getPartition() { String changelogPartition = getMessageValue(CHANGELOG_VALUE_KEY); return (changelogPartition != null) ? Integer.parseInt(changelogPartition) : null; }", "output": "Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testInitAggregator() throws Exception { final List<BuiltinAggregator> aggregators = Arrays.asList(BuiltinAggregator.COUNT, BuiltinAggregator.MAX, BuiltinAggregator.MIN, BuiltinAggregator.SUM); testedView.initBuiltinAggregators(aggregators); aggregators.stream().forEach(agg -> verify(lstBuiltinAggregator).addOption(agg.value())); }", "output": "Out of interest why can you not do BuiltinAggregator.values()?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void doCopyRetry(FileSystem sourceFs, List<ReplChangeManager.FileInfo> srcFileList, FileSystem destinationFs, Path destination, boolean useRegularCopy) throws IOException, LoginException { int repeat = 0; boolean isCopyError; List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath); while (!pathList.isEmpty() && (repeat < MAX_COPY_RETRY)) { LOG.info(\"Attempt: \" + (repeat+1) + \". Copying files: \" + pathList); try { isCopyError = false; doCopyOnce(sourceFs, pathList, destinationFs, destination, useRegularCopy); } catch (IOException e) { if (!(e instanceof FileNotFoundException)) { LOG.info(\" File operation failed with error : \" + e.getMessage()); sourceFs = pathList.get(0).getFileSystem(hiveConf); destinationFs = destination.getFileSystem(hiveConf); } isCopyError = true; } pathList = getFilesToRetry(sourceFs, srcFileList, destinationFs, destination, isCopyError); repeat++; } if (!pathList.isEmpty()) { LOG.error(\"File copy failed even after several attempts. Files list: \" + srcFileList); throw new IOException(\"File copy failed even after several attempts.\"); } }", "output": "Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public long forceNext() { long l = longs.incrementAndGet(INDEX_HEAD); if (((l >> 3) << 3) == l && concurrentInvocations() > 10) { concurrencyDetection.onDetected(); } return l; }", "output": "minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean needsSequentialWriting() { return !vfsList.get(0).getCapabilities().contains(Capabilities.PARALLEL_WRITE); }", "output": "Why not use capabilities directly here?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static NewIssueLocation locationForIssue(InputFile inputFile, HtmlIssue issue, NewIssue newIssue) { NewIssueLocation location = newIssue.newLocation() .on(inputFile) .message(issue.message()); Integer line = issue.line(); if (issue.startColumn() != null) { location.at(inputFile.newRange(issue.line(), issue.startColumn(), issue.endLine(), issue.endColumn())); } else if (line != null) { location.at(inputFile.selectLine(line)); } return location; }", "output": "Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public FbChain(final Iterable<Fallback> fallbacks) { super( new Fallback() { @Override public Opt<Response> route(final RqFallback req) throws IOException { Opt<Response> rsp = new Opt.Empty<Response>(); for (final Fallback fbk : fallbacks) { final Opt<Response> opt = fbk.route(req); if (opt.has()) { rsp = new Opt.Single<Response>(opt.get()); break; } } return rsp; } } ); }", "output": "@ekondrashev why not just rsp = opt?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); Boolean dbShouldBeUpdated = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }", "output": "Why use a java.lang.Boolean and not a primitive boolean?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void modifyAST(IIndex index, IMarker marker) { IASTTranslationUnit ast; try { ITranslationUnit tu = getTranslationUnitViaEditor(marker); ast = tu.getAST(index, ITranslationUnit.AST_SKIP_INDEXED_HEADERS); } catch (CoreException e) { CheckersUiActivator.log(e); return; } IASTNode astNode = null; if (isCodanProblem(marker)) { astNode = getASTNodeFromMarker(marker, ast); } if (astNode == null || !(astNode instanceof IASTCastExpression)) { return; } ASTRewrite r = ASTRewrite.create(ast); INodeFactory factory = ast.getASTNodeFactory(); IASTCastExpression oldcast = (IASTCastExpression) astNode; IASTCastExpression newcast = factory.newCastExpression(getCastType(), oldcast.getTypeId().copy(CopyStyle.withLocations), oldcast.getOperand().copy(CopyStyle.withLocations)); r.replace(oldcast, newcast, null); Change c = r.rewriteAST(); try { c.perform(new NullProgressMonitor()); } catch (CoreException e) { CheckersUiActivator.log(e); return; } try { marker.delete(); } catch (CoreException e) { CheckersUiActivator.log(e); } }", "output": "merge the try/catch with the one below?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "synchronized public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) { List<String> newSegments = new ArrayList<>(); for (String onlineSegment : onlineSegments) { if (!_segmentToTimeRangeMSCache.containsKey(onlineSegment)) { newSegments.add(onlineSegment); } } List<String> newSegmentZKMetadataPaths = new ArrayList<>(); for (String segment: newSegments) { newSegmentZKMetadataPaths.add(_segmentZKMetadataPathPrefix + segment); } List<ZNRecord> znRecords = _propertyStore.get(newSegmentZKMetadataPaths, null, AccessOption.PERSISTENT, true); for (int i = 0; i < newSegments.size(); i++) { String segment = newSegments.get(i); Interval range = extractTimeRangeMSFromSegmentZKMetaZNRecord(segment, znRecords.get(i)); _segmentToTimeRangeMSCache.put(segment, range); } _segmentToTimeRangeMSCache.keySet().retainAll(onlineSegments); _timeRangeMSToSegmentSearchTree = new IntervalST<String>(_segmentToTimeRangeMSCache); }", "output": "@snleee This is handled with the API refreshSegment()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private TracingContext traceToMap(Map<String, Object> map) { long startParse = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - startParse; long startOffset = now - startRequestNanos; map.put(\"startOffset\", startOffset); map.put(\"duration\", duration); }; }", "output": "Probably just wants to be start or startPhase or something if now generic."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testIllegalMinMax() { try { new FixedDoubleHistogram(-200, 3.0, 3.0); fail(\"exception expected\"); } catch (IllegalArgumentException e) { assertTrue(e.getMessage().contains(\"bucketCount\")); } }", "output": "nit: any chance to make the message assertion more specific? :)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(baseDir, false); return p4.latestChange(); }", "output": "We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void putJobCompletedNotification() throws IOException, SignatureException { UUID notificationUUID = null; try { final PutJobCompletedNotificationRegistrationSpectraS3Response response = client .putJobCompletedNotificationRegistrationSpectraS3( new PutJobCompletedNotificationRegistrationSpectraS3Request(\"test@test.test\")); notificationUUID = response.getJobCompletedNotificationRegistrationResult().getId(); assertThat(response.getStatusCode(), is(201)); } finally { client.deleteJobCompletedNotificationRegistrationSpectraS3( new DeleteJobCompletedNotificationRegistrationSpectraS3Request(notificationUUID)); } }", "output": "check to make sure notificationUUID is not null"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static Pair<Boolean, String> checkFingerPrint(String expected, PublicKey key) throws Exception { if (key == null) { return null; } if (expected == null) { return new Pair<>(false, getFingerPrint(key)); } String comps[] = expected.split(\":\", 2); DigestFactory factory; if (comps[0].length() > 2) { factory = BuiltinDigests.fromString(comps[0]); if (factory == null) { return new Pair<>(false, getFingerPrint(key)); } } else { factory = BuiltinDigests.md5; expected = \"MD5:\" + expected; } String fingerprint = getFingerPrint(factory, key); return new Pair<>(expected.equals(fingerprint), fingerprint); }", "output": "java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private boolean isValidationNecessaryOnReads(TableReference tableRef) { return isValidationNecessary(tableRef) && validateLocksOnReads; }", "output": "probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }", "output": "We don't need super here"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean isEnabled() { GitHistoryPage page = getPage(); if (page == null) return false; String head; try { head = page.getInputInternal().getRepository().getFullBranch(); } catch (IOException e) { head = null; } IStructuredSelection sel = getSelection(page); if (sel.size() != 1) return false; Object o = sel.getFirstElement(); if (!(o instanceof PlotCommit)) return false; PlotCommit commit = (PlotCommit) o; int refCount = commit.getRefCount(); for (int i = 0; i < refCount; i++) { String refName = commit.getRef(i).getName(); if (refName.equals(head)) continue; if (refName.startsWith(Constants.R_HEADS) || refName.startsWith(Constants.R_REMOTES)) return true; } return false; }", "output": "Does it make sense to continue here? Or just return false."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testStartProcessFromNodeIdsWithTimer() throws Exception { final String processId = \"simple.restartWithTimer\"; assertNotNull(deploymentService); KModuleDeploymentUnit deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION); deploymentService.deploy(deploymentUnit); units.add(deploymentUnit); assertNotNull(processService); Long processInstanceId = processService.startProcess(deploymentUnit.getIdentifier(), processId, singletonMap(\"var_a\", 3)); assertNotNull(processInstanceId); Thread.sleep(3000); processService.abortProcessInstance(processInstanceId); Collection<NodeInstanceDesc> timed = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.SKIPPED, new QueryContext(0, 0)); assertThat(timed.size(), is(1)); Collection<NodeInstanceDesc> aborted = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.ABORTED, new QueryContext(0, 0)); assertThat(aborted.size(), is(1)); String[] nodeIds = aborted.stream().map(e -> e.getNodeId()).toArray(String[]::new); processInstanceId = processService.startProcessFromNodeIds(deploymentUnit.getIdentifier(), processId, singletonMap(\"var_a\", 3), nodeIds); runtimeDataService.getTasksByProcessInstanceId(processInstanceId).forEach(e -> { Task task = this.userTaskService.getTask(e); assertThat(task.getName(), is(\"Third Task\")); this.userTaskService.start(e, \"katy\"); this.userTaskService.complete(e, \"katy\", emptyMap()); }); ProcessInstance pi = processService.getProcessInstance(processInstanceId); assertNull(pi); }", "output": "Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected boolean isAnyAppConfiguredInSourceServerXml() { boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(\"Application configuration is found in server.xml.\"); bConfigured = true; } return bConfigured; }", "output": "Here I would just say return true. Then fall through return false, instead of creating a variable."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void exportAsContext() { if (EDatabaseConnTemplate.isSchemaNeeded(getConnection().getDatabaseType()) && schemaText != null && StringUtils.isEmpty(schemaText.getText())) { MessageDialog.openWarning(getShell(), Messages.getString(\"AbstractForm.ExportAsContext\"), Messages.getString(\"DatabaseForm.checkSchema\")); } collectContextParams(); super.exportAsContext(); }", "output": "It's better to use **isBlank** here"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().asConvertible().integer(); getModel().getNumOfDesktops().validateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().getMaxAssignedVmsPerUser().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 1000000) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid()); getModel().setIsPoolTabValid(true); return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid(); }", "output": "also here please use Short.MAX_VALUE"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void doConcurrentPutInTx(String s) throws Exception { for (int i = 0; i < totalNumberOfBuckets; i++) { synchronized (list) { list.add(i); } } Thread[] threads = new Thread[totalNumberOfBuckets]; for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i] = new Thread(() -> doPutOpInTx(s)); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].start(); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].join(); } }", "output": "This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void addEditLink(WebMvcLinkBuilder selfLinkBuilder, GoalDto goalResource) { goalResource.add(selfLinkBuilder.withRel(JsonRootLinkRelationProvider.EDIT_REL)); }", "output": "Here too we may use IanaLinkRelation.EDIT?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = \"\"; mFloppyPath = \"\"; mRunAndPause = false; _diskSize = 0; }", "output": "coudl be just ArrayList since now it is imported ^^ vv"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void setCurentCommitInfo(String revision) { fCommitInfo.reset(); Iterator<Map.Entry<String, RevisionInfo>> itr1 = fRevisions.entrySet().iterator(); while (itr1.hasNext()) { Entry<String, RevisionInfo> entry = itr1.next(); if (entry.getKey().equals(revision)) { System.out.println(\"Looking at the Current patchset : \" + entry.getValue().getNumber()); fCommitInfo.setCommit(revision); fCommitInfo.setMessage(entry.getValue().getCommit().getMessage()); fCommitInfo.setParents(entry.getValue().getCommit().getParents()); fCommitInfo.setAuthor(entry.getValue().getCommit().getAuthor()); fCommitInfo.setCommitter(entry.getValue().getCommit().getCommitter()); } else { System.out.println(\"Looking at the other patchset : \" + entry.getValue().getNumber()); } } }", "output": "log"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testQueryProcessByVariables() { Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\"); Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\"); List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext()); Assert.assertEquals(3, data.size()); for (ProcessInstanceWithVarsDesc p : data) { Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\")); Assert.assertEquals(\"test.test_A\", p.getProcessId()); } }", "output": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void updateThreadPoolSize(int numThreads) { m_scheduler.setCorePoolSize(numThreads); LOG.info(\"Updated PBD to use \" + numThreads + \" threads to enforce retention policy\"); }", "output": "Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void postProcessHeaderLines() { final List<String> headerLines = getHeaderLines(); final Pattern blankLine = Pattern.compile(EMPTY_LINE_PATTERN); for (final String line : headerLines) { try { if (line.isEmpty()) { headerRegexps.add(blankLine); } else { headerRegexps.add(Pattern.compile(line)); } } catch (final PatternSyntaxException ex) { throw new IllegalArgumentException(\"line \" + (headerRegexps.size() + 1) + \" in header specification\" + \" is not a regular expression\", ex); } } }", "output": "please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void setActivePart(IAction action, IWorkbenchPart targetPart) { if(targetPart instanceof IMavenProjectHolder) { this.projectHolder = (IMavenProjectHolder) targetPart; } else { this.projectHolder = null; } }", "output": "I don't like IMavenProjectHolder. I think targetPart.getAdapter(MavenProject.class) is more appropriate here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void parseConfiguration(Config config, FailureCollector collector) { if (!config.defaults.isEmpty()) { String[] defaultsList = config.defaults.split(\",\"); for (String defaultValue : defaultsList) { String[] defaultsArray = defaultValue.split(\":\"); if (defaultsArray.length != 2) { collector.addFailure( String.format(\"Invalid default: %s.\", defaultValue), \"Defaults should contain source field and its corresponding default \" + \"value in the format: <source-field>:<default-value>[,<source-field>:<default-value>]* \" + \"For example: lang_code:English,country_code:Britain\").withConfigElement(DEFAULTS, defaultValue); } else { defaultsMapping.put(defaultsArray[0], defaultsArray[1]); } } } String[] mappingArray = config.mapping.split(\",\"); for (String mapping : mappingArray) { String[] mappingValueArray = mapping.split(\":\"); if (mappingValueArray.length != 3) { collector.addFailure(String.format(\"Invalid mapping: %s.\", mapping), \"Mapping should contain source field, lookup table name, \" + \"and target field in the format: \" + \"<source-field>:<lookup-table-name>:<target-field>\" + \"[,<source-field>:<lookup-table-name>:<target-field>]* \" + \"For example: lang_code:language_code_lookup:lang_desc,\" + \"country_code:country_lookup:country_name\").withConfigElement(MAPPING, mapping); } else { String defaultValue = null; if (defaultsMapping.containsKey(mappingValueArray[0])) { defaultValue = defaultsMapping.get(mappingValueArray[0]); } ValueMapping valueMapping = new ValueMapping(mappingValueArray[2], mappingValueArray[1], defaultValue); mappingValues.put(mappingValueArray[0], valueMapping); } } collector.getOrThrowException(); }", "output": "indentation, here and rest of PR"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(\"eventData cannot be null.\"); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, \"Size of the payload exceeded Maximum message size: %s kb\", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }", "output": "Replace with Objects.requireNotNull."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static void doAppendEscapedIdentifier(Appendable sbuf, String value) throws SQLException { try { sbuf.append('\"'); for (char ch : value.toCharArray()) { if (ch == '\\0') { throw new PSQLException(GT.tr(\"Zero bytes may not occur in identifiers.\"), PSQLState.INVALID_PARAMETER_VALUE); } if (ch == '\"') { sbuf.append(ch); } sbuf.append(ch); } sbuf.append('\"'); } catch (IOException e) { throw new PSQLException(GT.tr(\"No IOException expected from StringBuffer or StringBuilder\"), PSQLState.UNEXPECTED_ERROR, e); } }", "output": "I wonder if this change would result array allocation and extra cpu/memory consumption issues"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void shouldScheduleDelayedActionOnHandlerThread() { Handler handler = mock(Handler.class); @SuppressWarnings(\"unchecked\") Action0 action = mock(Action0.class); Scheduler scheduler = HandlerScheduler.create(handler); Worker inner = scheduler.createWorker(); inner.schedule(action, 1L, TimeUnit.SECONDS); ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class); verify(handler).postDelayed(runnable.capture(), eq(1000L)); runnable.getValue().run(); verify(action).call(); }", "output": "May be static imports for TimeUnit values here and below?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void aggregate(ByteBuffer buf, int position) { boolean countNulls = !selector.nameLookupPossibleInAdvance() || NullHandlingHelper.useDefaultValuesForNull(); MutableBitmap mutableBitmap = getMutableBitmap(position); IndexedInts row = selector.getRow(); for (int i = 0; i < row.size(); i++) { int index = row.get(i); if (countNulls || selector.lookupName(index) != null) { mutableBitmap.add(index); } } buf.putLong(position, mutableBitmap.size()); }", "output": "Similar to DistinctCountAggregator"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private List<ModelNode> adjustInfinispan(final PathAddress subsystem) throws Exception { final List<ModelNode> list = new ArrayList<>(); list.add(getWriteAttributeOperation(subsystem.append(\"cache-container\", \"server\").append(\"transport\", \"jgroups\"), \"stack\", new ModelNode(\"udp\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"server\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"server\").append(\"replicated-cache\", \"default\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"web\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"web\").append(\"distributed-cache\", \"dist\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"ejb\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"ejb\").append(\"distributed-cache\", \"dist\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"invalidation-cache\", \"entity\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"local-cache\", \"local-query\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"replicated-cache\", \"timestamps\"))); return list; }", "output": "Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "EventBus eventBus() { EventBus bus = new EventBus((exception, context) -> exception.printStackTrace()); bus.register(new DeadEventHandler()); return bus; }", "output": "printStackTrace() must not be used. Use a logger instead."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "ObjectLoader openPackedObject(WindowCursor curs, AnyObjectId objectId) { PackList pList; do { pList = packList.get(); SEARCH: for (;;) { for (PackFile p : pList.packs) { try { ObjectLoader ldr = p.get(curs, objectId); if (ldr != null) return ldr; } catch (PackMismatchException e) { PackList nList = scanPacks(pList); if (pList != nList) { pList = nList; continue SEARCH; } } catch (IOException e) { removePack(p); } } break SEARCH; } } while (searchPacksAgain(pList)); return null; }", "output": "I think this could just be: if (searchPacksAgain(pList)) continue SEARCH;"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void bufferExactFailingSupplier() { Scheduler.Worker w = new TestScheduler().createWorker(); TestSubscriber<List<Integer>> observer = new TestSubscriber<List<Integer>>(); FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>> buf = new FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>>(observer, ArrayListSupplier.<Integer>asCallable(), 100, TimeUnit.MILLISECONDS, 10, false, w); buf.onError(new Throwable()); buf.onComplete(); }", "output": "The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private Image getImageForDraw() { if (sprite.look.getLookData() != null) { if (sprite.look.getLookData().getCollisionInformation().getLeftBubblePos() == null || sprite.look.getLookData().getCollisionInformation().getRightBubblePos() == null) { sprite.look.getLookData().getCollisionInformation().loadOrCreateCollisionPolygon(); } CollisionInformation collisionInformation = sprite.look.getLookData().getCollisionInformation(); Pair<Integer, Integer> bubblePosRight = collisionInformation.getRightBubblePos(); Pair<Integer, Integer> bubblePosLeft = collisionInformation.getLeftBubblePos(); imageLeft.setX(calculateLeftImageX(bubblePosLeft.first)); imageLeft.setY(calculateImageY(bubblePosLeft.second)); imageRight.setX(calculateRightImageX(bubblePosRight.first)); imageRight.setY(calculateImageY(bubblePosRight.second)); } else { if (drawRight) { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() + (sprite.look .getWidthInUserInterfaceDimensionUnit() / 2)); } else { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() - sprite.look .getWidthInUserInterfaceDimensionUnit() / 2 - image.getWidth()); } image.setY(sprite.look.getYInUserInterfaceDimensionUnit() + (sprite.look .getHeightInUserInterfaceDimensionUnit() / 2)); } return image; }", "output": "I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static User toUser(DecodedJWT jwt) { final String subject = jwt.getSubject(); final List<Role> roles = jwt.getClaims().entrySet().stream() .filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) .map(entry -> { final String roleName = entry.getKey(); final Claim claim = entry.getValue(); final List<Permission> permissions = claim.asList(String.class).stream().map(Permission::valueOf).collect(Collectors.toList()); return new Role(roleName.substring(roleName.indexOf(\"_\") + 1, roleName.length()), permissions); }).collect(Collectors.toList()); return new User(subject, roles); }", "output": "You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void readInfo() { this.mvnInfo = null; this.mvnName = null; if (!infofile.exists()) { return; } try { final String content = FileUtils.readFileToString(infofile, Charsets.UTF_8); final int i = content.indexOf(','); LOGGER.log(Level.FINE, \"The \" + name + \" artifact info cached is: \" + content); if (i != -1) { this.mvnInfo = content.substring(0, i); this.mvnName = content.substring(i + 1); } else { LOGGER.log(Level.WARNING, \"The \" + name + \" artifact info is invalid\"); } } catch (IOException e) { LOGGER.log(Level.WARNING, \"The \" + name + \" artifact info failed to be loaded\", e); } }", "output": "you can use parameterized logging here"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void refreshSignedOffBy() { String curText = commitText.getText(); if (signedOff) { commitText.setText(signOff(curText)); } else { String s = getSignedOff(); if (s != null) { curText = replaceSignOff(curText, s, EMPTY_STRING); if (curText.endsWith(Text.DELIMITER + Text.DELIMITER)) curText = curText.substring(0, curText.length() - Text.DELIMITER.length()); commitText.setText(curText); } } }", "output": "Style nit: unneeded curlies"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void put(String key, String value) { Assert.notNull(key, \"'key' must not be null.\"); Assert.notNull(value, \"'value' must not be null.\"); BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); ops.set(value); }", "output": "this.redisTemplate"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ResponseEntity<?> createDilution(@RequestBody DilutionDto dilutionDto, UriComponentsBuilder b) throws IOException { if (dilutionDto == null) { log.error( \"Received null dilutionDto from front end; cannot convert to Dilution. Something likely went wrong in the JS DTO conversion.\"); throw new RestException(\"Cannot convert null to Dilution\", Status.BAD_REQUEST); } Long id = null; LibraryDilution dilution; try { dilution = Dtos.to(dilutionDto); dilution.setLibrary(libraryService.get(dilutionDto.getLibrary().getId())); id = populateAndSaveDilutionFromDto(dilutionDto, dilution, true); } catch (ConstraintViolationException e) { log.error(\"Error while creating dilution\", e); RestException restException = new RestException(e.getMessage(), Status.BAD_REQUEST); restException.addData(\"constraintName\", e.getConstraintName()); throw restException; } UriComponents uriComponents = b.path(\"/library/{id}\").buildAndExpand(dilution.getLibrary().getId()); HttpHeaders headers = new HttpHeaders(); headers.setLocation(uriComponents.toUri()); headers.set(\"Id\", id.toString()); return new ResponseEntity<>(headers, HttpStatus.CREATED); }", "output": "fetch should already happen in Service"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void start(SocketAddress endpoint) throws IOException { if (isListening()) { throw new IllegalStateException(\"Cannot start when already listening for messages\"); } bindToAddress(endpoint); new Thread(() -> { while (!configServerSocket.isClosed()) { acceptConnection(); } }, \"configurationListener\").start(); }", "output": "thread.isUnterupted not necessary?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(\"Launch batch job (makeUnique=false) twice\"); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\"); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(\"job launch --name \" + MY_JOB); System.out.println(\"*************************\" + result.getException().getMessage()); assertThat( result.getException().getMessage(), containsString(\"A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters.\")); }", "output": "I assume this was meant to be removed?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<GenericVertex> resolve(GraphService graphService, SearchCriteria searchCriteria) { GenericGraph graph = graphService.getGraph(searchCriteria.getNamespace()); return graph.getVertices() .stream() .map(ApplicationVertex::new) .filter(v -> filter(v, searchCriteria.getCriteria())) .map(ApplicationVertex::asGenericVertex) .collect(Collectors.toList()); }", "output": "What do we do, if the result is null?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected Location manageRecursive(Location loc, final ManagementTransitionMode initialMode) { AccessController.Response access = managementContext.getAccessController().canManageLocation(loc); if (!access.isAllowed()) { throw new IllegalStateException(\"Access controller forbids management of \"+loc+\": \"+access.getMsg()); } if (log.isDebugEnabled()) { String msg = \"Managing location \" + loc + \" (\"+initialMode+\"), from \" + Tasks.current()+\" / \"+Entitlements.getEntitlementContext(); long count = LOCATION_CNT.incrementAndGet(); if (count % 100 == 0) { log.debug(msg, new Exception(\"Informational stack trace of call to manage location \"+loc+\" (\"+count+\" calls; \"+getLocations().size()+\" currently managed)\")); } else { log.debug(msg); } } recursively(loc, new Predicate<AbstractLocation>() { public boolean apply(AbstractLocation it) { ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId()); if (mode==null) { setManagementTransitionMode(it, mode = initialMode); } if (it.isManaged()) { if (mode==ManagementTransitionMode.CREATING) { return false; } else { } } boolean result = manageNonRecursive(it, null); if (result) { it.setManagementContext(managementContext); if (!mode.isReadOnly()) { it.onManagementStarted(); recordLocationEvent(it, Lifecycle.CREATED); } managementContext.getRebindManager().getChangeListener().onManaged(it); } return result; } }); return loc; }", "output": "I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void start(int slot) { mSlot = slot; int error = isValid(); if (error == SUCCESS) { Log.d(TAG, \"Starting keepalive \" + mSlot + \" on \" + mNai.name()); switch (mType) { case TYPE_NATT: mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; case TYPE_TCP: mTcpController.startSocketMonitor(mFd, this, mSlot); mNai.asyncChannel .sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0 , mPacket); mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; default: Log.wtf(TAG, \"Starting keepalive with unknown type: \" + mType); } mStartedState = STARTING; } else { handleStopKeepalive(mNai, mSlot, error); return; } }", "output": "Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public NewTmfViewAction(TmfView view) { super(MessageFormat.format(Messages.TmfView_NewTmfViewNameText, view.getTitle().toLowerCase()), IAction.AS_PUSH_BUTTON); setToolTipText(MessageFormat.format(Messages.TmfView_NewTmfViewToolTipText, view.getTitle())); }", "output": "I think we always display view names capitalized to users."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(\"message must be non-empty\"); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(); } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }", "output": "Unrelated change. Should be in a separate commit."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public CompletableFuture<Snapshot> copyTo(FileWrapper target, UserContext context) { ensureUnmodified(); NetworkAccess network = context.network; SafeRandom random = context.crypto.random; Hasher hasher = context.crypto.hasher; if (! target.isDirectory()) { return Futures.errored(new IllegalStateException(\"CopyTo target \" + target + \" must be a directory\")); } return context.network.synchronizer.applyComplexUpdate(target.owner(), target.signingPair(), (base, committer) -> { return target.hasChildWithName(base.get(target.writer()).props, getFileProperties().name, network).thenCompose(childExists -> { if (childExists) { CompletableFuture<Snapshot> error = new CompletableFuture<>(); error.completeExceptionally(new IllegalStateException(\"CopyTo target \" + target + \" already has child with name \" + getFileProperties().name)); return error; } if (isDirectory()) { byte[] newMapKey = random.randomBytes(32); SymmetricKey newBaseKey = SymmetricKey.random(); SymmetricKey newWriterBaseKey = SymmetricKey.random(); WritableAbsoluteCapability newCap = new WritableAbsoluteCapability(target.owner(), target.writer(), newMapKey, newBaseKey, newWriterBaseKey); SymmetricKey newParentParentKey = target.getParentKey(); return pointer.fileAccess.copyTo(base, committer, pointer.capability, newBaseKey, target.writableFilePointer(), target.entryWriter, newParentParentKey, newMapKey, network, random, hasher) .thenCompose(updatedBase -> { return target.addLinkTo(updatedBase, committer, getName(), newCap, network, random, hasher); }); } else { return base.withWriter(owner(), writer(), network).thenCompose(snapshot -> getInputStream(snapshot.get(writer()).props, network, random, x -> {}) .thenCompose(stream -> target.uploadFileSection(snapshot, committer, getName(), stream, false, 0, getSize(), Optional.empty(), false, network, random, hasher, x -> {}, target.generateChildLocations(props.getNumberOfChunks(), random)))); } }); }); }", "output": "this may impact web-ui code. Do we want to expose Snapshot in API?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testBlogPosting() { onView(withText(\"Log In\")) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserEmail), closeSoftKeyboard()); onView(withText(\"Next\")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.login_enter_password)) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserPassword), closeSoftKeyboard()); onView(withText(\"Next\")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(\"Continue\")) .perform(click()); onView(withId(R.id.viewpager_main)) .perform(ViewPagerActions.scrollToFirst()); onView(withId(R.id.fab_button)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.title)) .perform(replaceText(\"Hello\"), closeSoftKeyboard()); onView(withId(R.id.aztec)) .perform(replaceText(\"World\"), closeSoftKeyboard()); onView(withId(R.id.menu_save_post)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.promo_dialog_button_positive)) .perform(click()); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(R.string.uploading_post)).inRoot(new ToastMatcher()) .check(matches(isDisplayed())); }", "output": "This seems to fail the test when SmartLock for Passwords pops up the dialog for selecting a saved email/pass combination."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void placeOnTop(Node pNode) { assert pNode != null; if( aType == DiagramType.SEQUENCE && pNode.getClass() == CallNode.class ) { return; } if( pNode.hasParent() ) { Node parent = pNode.getParent(); parent.placeLast(pNode); placeOnTop(parent); } else if( containsAsRoot(pNode) ) { removeRootNode(pNode); addRootNode(pNode); } }", "output": "CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public int[] downloadSetupConfigurationTemplate(String uuid){ int[] result = new int[2]; try { SetupConfigurationTemplate setupConfigurationTemplate = setupConfigurationController.downloadSetupConfigurationTemplate(uuid); result[0] = SyncStatusConstants.SUCCESS; if(setupConfigurationTemplate != null) { result[1] = 1; } System.out.println(\"MuzimaSyncService: \"+setupConfigurationTemplate.getConfigJson()); setupConfigurationController.saveSetupConfigurationTemplate(setupConfigurationTemplate); } catch (SetupConfigurationController.SetupConfigurationDownloadException e){ Log.e(TAG, \"Exception when trying to download setup configs\"); result[0] = SyncStatusConstants.DOWNLOAD_ERROR; } catch (SetupConfigurationController.SetupConfigurationSaveException e){ Log.e(TAG, \"Exception when trying to save setup configs\"); result[0] = SyncStatusConstants.SAVE_ERROR; } return result; }", "output": "Replace with logger"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); if (orientation != newConfig.orientation) { try { orientation = newConfig.orientation; getFragmentManager().beginTransaction().remove(this).commit(); getFragmentManager().beginTransaction() .replace(R.id.cover_fragment_container, CoverFragment.class.newInstance()) .commitAllowingStateLoss(); } catch (Exception e) { Log.e(TAG, \"onConfigurationChanged \" + e.toString()); } } }", "output": "I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void serviceStart() throws Exception { super.serviceStart(); if (UserGroupInformation.isSecurityEnabled()) { delegationTokenManager.startThreads(); } InetSocketAddress connectAddress = NetUtils.getConnectAddress(this.heartbeatListener.getAddress()); URI connectUri = RecoverableRpcProxy.toConnectURI(connectAddress); FSRecoveryHandler recoveryHandler = new FSRecoveryHandler(dag.assertAppPath(), getConfig()); recoveryHandler.writeConnectUri(connectUri.toString()); try { org.mortbay.log.Log.setLog(null); } catch (Throwable throwable) { } try { Configuration config = getConfig(); if (SecurityUtils.isStramWebSecurityEnabled()) { config = new Configuration(config); config.set(\"hadoop.http.filter.initializers\", StramWSFilterInitializer.class.getCanonicalName()); } addSSLConfigResource(config); WebApp webApp = WebApps.$for(\"stram\", StramAppContext.class, appContext, \"ws\").with(config).start(new StramWebApp(this.dnmgr)); LOG.info(\"Started web service at port: \" + webApp.port()); appMasterTrackingUrl = NetUtils.getConnectAddress(webApp.getListenerAddress()).getAddress().getCanonicalHostName() + \":\" + webApp.port(); if (ConfigUtils.isSSLEnabled(config)) { appMasterTrackingUrl = \"https://\" + appMasterTrackingUrl; } LOG.info(\"Setting tracking URL to: \" + appMasterTrackingUrl); } catch (Exception e) { LOG.error(\"Webapps failed to start. Ignoring for now:\", e); } }", "output": "Sounds like a workaround for host misconfiguration issue."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void executeVdsBrokerCommand() { String storageDomainId = getParameters().getStorageDomainId().toString(); List<String> deviceList = getParameters().getDeviceList(); String[] deviceArray = deviceList.toArray(new String[deviceList.size()]); boolean isForce = getParameters().isForce(); boolean supportForceCreateVG = Config.<Boolean> getValue( ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString()); _result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray); proceedProxyReturnValue(); setReturnValue(_result.uuid); }", "output": "Could you please rename also _result?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean addNextEvent(final MistEvent event, final Direction direction) { if (operatorChainManager != null && queue.isEmpty()) { operatorChainManager.insert(this); } return queue.add(new Tuple<>(event, direction)); }", "output": "I think it would be good to perform this logic in OutputEmitter."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void freeUnderlyingResources() { int spi = mSpi.getSpi(); try { mSrvConfig .getNetdInstance() .ipSecDeleteSecurityAssociation( 0, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, 0, mConfig.getMarkMask()); } catch (RemoteException | ServiceSpecificException e) { Log.e(TAG, \"Failed to delete SA with ID: \" + mResourceId, e); } getResourceTracker().give(); }", "output": "I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API)."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void execute() { final Setting setting = getActionContext().getSetting(); final EObject eObject = setting.getEObject(); final EStructuralFeature eStructuralFeature = setting.getEStructuralFeature(); final List<?> containments = (List<?>) eObject.eGet(eStructuralFeature, true); final List<?> moveUpList = Arrays.asList( ((IStructuredSelection) getTableViewer().getSelection()).toArray()); sortSelectionBasedOnIndex(moveUpList, containments); final EditingDomain editingDomain = getActionContext().getEditingDomain(); for (final Object moveUpObject : moveUpList) { final int currentIndex = containments.indexOf(moveUpObject); if (currentIndex <= 0) { return; } editingDomain.getCommandStack() .execute( new MoveCommand( editingDomain, eObject, eStructuralFeature, currentIndex, currentIndex - 1)); } }", "output": "we should probably check in the canExecute whether we reached the start of the list"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected Array createArrayOf(String typeName, Object[] array) { Connection connection = null; try { connection = getJdbcTemplate().getDataSource().getConnection(); return connection.createArrayOf(typeName, array); } catch (SQLException e) { throw new RuntimeException(e); } finally { if (connection != null) { try { connection.close();} catch (SQLException e) {} } } }", "output": "Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public byte[] serialize() { ByteBuffer buffer = ByteBuffer.allocate(9); buffer.put(TYPE_LONG); buffer.putLong(value); return buffer.array(); }", "output": "magic number"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ServiceReference[] getServiceReferences(String clazz, String filter) { ServiceReference[] refs = null; try { if (bundleContext != null) { refs = bundleContext.getServiceReferences(clazz, filter); } } catch (InvalidSyntaxException e) { if (log.isLoggable(Level.SEVERE)) { log.log(Level.SEVERE, e.getMessage(), e); } } return refs; }", "output": "I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private boolean execute(final IProcessDMContext processDmc, final IDebugCommandRequest request) { try { fExecutor.execute(new DsfRunnable() { @Override public void run() { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null) { procService.terminate(processDmc, new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!getStatus().isOK()) { request.setStatus(getStatus()); request.done(); } else { WaitForTerminationJob job = new WaitForTerminationJob(fSession.getId(), request); job.schedule(); } }; }); } else { request.done(); } } }); } catch (RejectedExecutionException e) { request.done(); } return false; }", "output": "Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void deleteProperty(AccumuloElement element, Property property, Authorizations authorizations) { if (!element.getFetchHints().isIncludeAllProperties()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), \"All Properties\"); } if (!element.getFetchHints().isIncludeAllPropertyMetadata()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), \"All Property Metadata\"); } Mutation m = new Mutation(element.getId()); elementMutationBuilder.addPropertyDeleteToMutation(m, property); addMutations(element, m); getSearchIndex().deleteProperty( this, element, PropertyDescriptor.fromProperty(property), authorizations ); if (hasEventListeners()) { queueEvent(new DeletePropertyEvent(this, element, property)); } }", "output": "Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<ExperimentSpotDesignReadSpec> list() { List expmts = this.getHibernateTemplate().find(\"from ExperimentSpotDesignReadSpec as readSpec order by readSpec.experimentSpotDesignReadSpecId asc\" ); return expmts; }", "output": "Why does this need to be ordered by the synthetic primary key?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testToFlowElement_autostart() throws Exception { final ReusableSubprocess definition = new ReusableSubprocess(); definition.getExecutionSet().setAdHocAutostart(new AdHocAutostart(true)); final View<BaseReusableSubprocess> view = new ViewImpl<>(definition, Bounds.create()); final Node<View<BaseReusableSubprocess>, ?> node = new NodeImpl<>(java.util.UUID.randomUUID().toString()); node.setContent(view); final PropertyWriter propertyWriter = tested.toFlowElement(node); assertTrue(CallActivityPropertyWriter.class.isInstance(propertyWriter)); assertTrue(CustomElement.autoStart.of(propertyWriter.getFlowElement()).get()); }", "output": "The Exception is never thrown."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static Date parseDate(String date, String format) { return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); }", "output": "Is a null check for the passed in \"date\" required here for safety?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); } return false; }", "output": "Since numberOfVotes can be null you should replace this with Objects.equals(numberOfVotes, other.numberOfVotes)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static void connect(Socket socket, SocketAddress endpoint, SocketAddress localAddr, int timeout) throws IOException { if (socket == null || endpoint == null || timeout < 0) { throw new IllegalArgumentException(\"Illegal argument for connect()\"); } SocketChannel ch = socket.getChannel(); if (localAddr != null) { Class localClass = localAddr.getClass(); Class remoteClass = endpoint.getClass(); Preconditions.checkArgument(localClass.equals(remoteClass), \"Local address %s must be of same family as remote address %s.\", localAddr, endpoint); socket.bind(localAddr); } try { if (ch == null) { socket.connect(endpoint, timeout); } else { SocketIOWithTimeout.connect(ch, endpoint, timeout); } } catch (SocketTimeoutException ste) { throw new ConnectTimeoutException(ste.getMessage()); } catch (UnresolvedAddressException ue) { throw new UnknownHostException(ue.getMessage()); } if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) { LOG.info(\"Detected a loopback TCP socket, disconnecting it\"); socket.close(); throw new ConnectException( \"Localhost targeted connection resulted in a loopback. \" + \"No daemon is listening on the target port.\"); } }", "output": "nit: call it uae?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testReviewForm() throws ParseException { final DeliveryReviewView view = getDeliveryReviewView(); final DeliveryReviewView.DeliveryForm deliveryForm = view.getDelivery(); deliveryForm.setGrade(\"4.0\"); deliveryForm.setState(\"Rejected\"); deliveryForm.setCommentary(\"Hello World!\"); assertTrue(deliveryForm.getGrade() == 4.0D); assertEquals(Delivery.State.REJECTED, deliveryForm.getSelectedState()); assertEquals(\"Hello World!\", deliveryForm.getCommentary()); }", "output": "Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static void addRequestParameter(SOAPFactory soapFactory, OMElement bodyFirstChild, OMNamespace ns, String key, Object parameter) { if (parameter instanceof DataHandler) { DataHandler dataHandler = (DataHandler)parameter; OMText dataText = bodyFirstChild.getOMFactory().createOMText( dataHandler, true); OMElement omElement = soapFactory.createOMElement(key, ns, bodyFirstChild); omElement.addChild(dataText); omElement.addAttribute(\"filename\",((DataHandler) parameter).getDataSource().getName(),ns); omElement.addAttribute(\"filename\", ((DataHandler) parameter).getDataSource().getName(), ns); } else { String textValue = parameter.toString(); soapFactory.createOMElement(key, ns, bodyFirstChild).setText( textValue); } }", "output": "repeating code line."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Future<Void> executeFailed(Stage stage, Class<?> executingClass, ConsumerRecord<byte[], byte[]> consumerRecord, Throwable error) { if (!withinToleranceLimits()) { errorHandlingMetrics.recordFailure(); markAsFailed(); throw new ConnectException(\"Tolerance exceeded in the errant record reporter\", error); } context.consumerRecord(consumerRecord); context.currentContext(stage, executingClass); context.error(error); errorHandlingMetrics.recordError(); return context.report(); }", "output": "if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public OutputWriter createOutputWriter() { if (file.exists()) { ExcelDatastore datastore = new ExcelDatastore(file.getName(), new FileResource(file), file.getAbsolutePath()); try (final UpdateableDatastoreConnection connection = datastore.openConnection()) { final DataContext dataContext = connection.getDataContext(); final Schema[] schemas = dataContext.getSchemas(); if (schemas.length >= 1) { final String[] tableNames = schemas[1].getTableNames(); for (int i = 0; i < tableNames.length; i++) { if (tableNames[i].equals(sheetName)) { if (overwriteSheetIfExists) { final Table tableSheet = dataContext.getTableByQualifiedLabel(sheetName); final UpdateableDataContext updateableDataContext = connection .getUpdateableDataContext(); updateableDataContext.executeUpdate(new UpdateScript() { @Override public void run(UpdateCallback callback) { callback.dropTable(tableSheet).execute(); ; } }); } } } } } } String[] headers = new String[columns.length]; for (int i = 0; i < headers.length; i++) { headers[i] = columns[i].getName(); } return ExcelOutputWriterFactory.getWriter(file.getPath(), sheetName, columns); }", "output": "Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after \"information_schema\" :-)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean isQueryCacheable(Query query) { return !query.isDescending() && !unCacheable.contains(query.getType()); }", "output": "any reason for disabling cache for descending order queries ?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testBacktickEscapedIdentifier() { assertTrue(CharFormatUtil.unescapeIdentifier(\"``\").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(\"\").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(\"`s`\").equals(\"s\")); assertTrue(CharFormatUtil.unescapeIdentifier(\"`self`\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"`self\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"self`\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"``self`\").equals(\"self\")); }", "output": "assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void validateAuthenticationState(HttpClient httpClient) throws GerritLoginException { Optional<Cookie> cookie = findCookieWithName(LOGIN_COOKIE_NAME, httpClient); cookie.ifPresent(this::setXsrfCookie); if (!cookie.isPresent()) { if (CoreUtil.TEST_MODE) { System.err.println(\" Authentication failed: \" + httpClient.getState()); } throw new GerritLoginException(); } }", "output": "maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void testGetForDeletedBlobWithoutIncludeExpiredOption(List<BlobId> blobIds) { try { store.get(blobIds, EnumSet.noneOf(StoreGetOptions.class)); assertTrue( \"get should fail for a expired blob, if StoreGetOptions.Store_Include_Expired is not set in get options\", false); } catch (StoreException e) { assertTrue( \"get for expired blob with with StoreGetOptions.Store_Include_Expired not set in get options should throw exception with \" + StoreErrorCodes.TTL_Expired + \" error code.\", e.getErrorCode().equals(StoreErrorCodes.TTL_Expired)); } }", "output": "assertEquals and remove the expected value from message string"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Publisher<Integer> createFailedPublisher() { return null; }", "output": "should be possible to provide one"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String name() { return Json.createReader(new StringReader(this.obj)) .readObject() .getString(\"name\"); }", "output": "Looks like a duplication to me. How about this.json().getString(\"name\")?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected FieldBase(String name, DataType dataType) { if (CoreUtils.isNullOrEmpty(name)) { throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\")); } this.name = name; this.dataType = dataType; }", "output": "Should we also validate that DataType != null."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Map<?, ?> read() { final Yaml yaml = new Yaml(); final Map<String, String> properties = new HashMap<>(); try (InputStream in = inputStream) { yaml.loadAll(in).forEach((Object obj) -> this.loadValue(properties, \"\", obj)); return properties; } catch (IOException e) { throw new IllegalStateException(\"Cannot load environment\", e); } }", "output": "I think we need to close this InputStream at some point"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static String createOrUpdateAccountsAndWait(Collection<Account> accounts) throws Exception { String jsonFilePath = tempDirPath + File.separator + UUID.randomUUID().toString() + \".json\"; writeAccountsToFile(accounts, jsonFilePath); int numOfAccounts = AccountUpdater.createOrUpdate(jsonFilePath, ZK_SERVER_ADDRESS, HELIX_STORE_ROOT_PATH, null, null); Thread.sleep(100); return numOfAccounts == -1 ? null : jsonFilePath; }", "output": "do you clean up these files on exit? or the root level dir is deleted on exit ?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private Integer extractCount(HttpServletRequest request) { Integer count = Integer.valueOf(getParameter(request, \"count\")); checkArgument(COUNT_RANGE.contains(count), \"'count' must be in range %s, was %s\", COUNT_RANGE, count); return count; }", "output": "in range yet you're not providing a range; perhaps \"'count' must be at most %s\"? Also, shouldn't that be %d?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void dismissToast() { try { toast.cancel(); } catch (NullPointerException e) { ZLog.logException(e); } }", "output": "hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean hasDeploymentSubModel(final String subsystemName, final PathElement address) { final Resource root = deploymentUnit.getAttachment(DEPLOYMENT_RESOURCE); final PathElement subsystem = PathElement.pathElement(SUBSYSTEM, subsystemName); return root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address); }", "output": "Should this support a null address? Same with the other one, which make support a null or empty address."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void scheduleKeepAliveHeartbeat() { Scheduler.get().scheduleFixedDelay(new RepeatingCommand() { @Override public boolean execute() { boolean sessionInUse = restApiSessionId != null; if (sessionInUse && refreshRestApiSession) { sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback()); refreshRestApiSession = false; } return sessionInUse; } }, SESSION_HEARTBEAT_MS); }", "output": "this is followup of above, it should not be required."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void marriedKeychainBloomFilter() throws Exception { wallet = new Wallet(params); blockStore = new MemoryBlockStore(params); chain = new BlockChain(params, wallet, blockStore); String XPUB = \"xpub68KFnj3bqUx1s7mHejLDBPywCAKdJEu1b49uniEEn2WSbHmZ7xbLqFTjJbtx1LUcAt1DwhoqWHmo2s5WMJp6wi38CiF2hYD49qVViKVvAoi\"; wallet.addFollowingAccounts(ImmutableList.of(DeterministicKey.deserializeB58(null, XPUB))); Address address = wallet.currentReceiveAddress(); assertTrue(wallet.getBloomFilter(1e-12).contains(address.getHash160())); Transaction t1 = createFakeTx(params, CENT, address); StoredBlock b1 = createFakeBlock(blockStore, t1).storedBlock; TransactionOutPoint outPoint = new TransactionOutPoint(params, 0, t1); assertFalse(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); wallet.receiveFromBlock(t1, b1, BlockChain.NewBlockType.BEST_CHAIN, 0); assertTrue(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); }", "output": "I should probably have asked this in the previous review, but why \"addFollowingAccounts\"? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean test(Object receiver, String property, Object[] args, Object expectedValue) { IMonitorControl monitor = null; if (receiver instanceof IMonitorControl) { monitor = (IMonitorControl) receiver; } else { if (selectedMonitorId != null) { monitor = MonitorControlManager.getInstance().getMonitorControl(selectedMonitorId); } } if (monitor != null) { if (IS_ACTIVE.equals(property)) { return monitor.isActive() == toBoolean(expectedValue); } } return false; }", "output": "Please make sure this is properly formatted. \"else\" should be on the same line as the }."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public WorkspaceConfigImpl devFileToWorkspaceConfig(Devfile devfile) throws DevfileFormatException { validateCurrentVersion(devfile); WorkspaceConfigImpl config = new WorkspaceConfigImpl(); config.setName(devfile.getName()); List<ProjectConfigImpl> projects = new ArrayList<>(); devfile.getProjects().forEach(project -> projects.add(devProjectToProjectConfig(project))); config.setProjects(projects); Map<String, String> attributes = new HashMap<>(); StringJoiner pluginsStringJoiner = new StringJoiner(\",\"); StringJoiner toolIdToNameMappingStringJoiner = new StringJoiner(\",\"); for (Tool tool : devfile.getTools()) { switch (tool.getType()) { case EDITOR_TOOL_TYPE: attributes.put(WORKSPACE_TOOLING_EDITOR_ATTRIBUTE, tool.getId()); break; case PLUGIN_TOOL_TYPE: pluginsStringJoiner.add(tool.getId()); break; case KUBERNETES_TOOL_TYPE: continue; default: throw new DevfileFormatException( format(\"Unsupported tool %s type provided: %s\", tool.getName(), tool.getType())); } toolIdToNameMappingStringJoiner.add(tool.getId() + \"=\" + tool.getName()); } if (pluginsStringJoiner.length() > 0) { attributes.put(WORKSPACE_TOOLING_PLUGINS_ATTRIBUTE, pluginsStringJoiner.toString()); } if (toolIdToNameMappingStringJoiner.length() > 0) { attributes.put(ALIASES_WORKSPACE_ATTRIBUTE_NAME, toolIdToNameMappingStringJoiner.toString()); } config.setAttributes(attributes); List<CommandImpl> commands = new ArrayList<>(); devfile .getCommands() .forEach(command -> commands.addAll(devCommandToCommandImpls(devfile, command))); config.setCommands(commands); return config; }", "output": "throw exception?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testGetTaskRawFormViaUIClient() throws Exception { long processInstanceId = processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID); assertThat(processInstanceId).isGreaterThan(0); try { List<TaskSummary> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); assertThat(tasks).isNotNull().hasSize(1); Long taskId = tasks.get(0).getId(); String result = uiServicesClient.getTaskRawForm( CONTAINER_ID, taskId ); logger.debug(\"Form content is '{}'\", result); assertThat(result).isNotNull().isNotEmpty(); } finally { processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); } }", "output": "Please change user back to USER_YODA here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void buyCard(GameUserBean gameUser, GameBean game, Map<String, String> returnedParams) throws PlayException, GameException { DevelopmentCards availableDevelopmentCards = game.getAvailableDevelopmentCards(); DevelopmentCard obtainedDevelopmentCard = cardUtil.pullDevelopmentCard(availableDevelopmentCards); DevelopmentCards usersDevelopmentCards = gameUser.getDevelopmentCards(); usersDevelopmentCards.increaseQuantityByOne(obtainedDevelopmentCard); availableDevelopmentCards.decreaseQuantityByOne(obtainedDevelopmentCard); returnedParams.put(\"card\", obtainedDevelopmentCard.name()); }", "output": "you don't take any resourcees from player when buying dev card"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(\"Stream returnsCorrectInput!\").asBytes(); MatcherAssert.assertThat( \"Stream doesn't provide correct bytes\", new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }", "output": "@Serranya The same here. See above."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void handleSelectorEvents(List<ResponseInfo> responseInfoList) { long handleSelectorEventsStartTimeMs = System.currentTimeMillis(); for (String connId : selector.connected()) { connectionTracker.checkInConnection(connId); } List<String> disconnectedList = selector.disconnected(); networkMetrics.connectionsDisconnectedCount.mark(disconnectedList.size()); for (String connId : disconnectedList) { connectionTracker.removeConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); if (requestMetadata != null) { responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), NetworkClientErrorCode.NetworkError, null)); } } for (NetworkReceive recv : selector.completedReceives()) { String connId = recv.getConnectionId(); connectionTracker.checkInConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), null, recv.getReceivedBytes().getPayload())); requestMetadata.onResponseReceive(); } networkMetrics.handleSelectorEventsTime.update(System.currentTimeMillis() - handleSelectorEventsStartTimeMs); }", "output": "What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Void visitInstanceOf(InstanceOfTree node, Void p) { if (node.getType().getKind() == Kind.ANNOTATED_TYPE) { AnnotatedTypeMirror type = atypeFactory.fromExpression((ExpressionTree) node.getType()); if (type.hasAnnotation(Nullable.class)) { checker.reportError(node, \"instanceof.nullable.error\"); } if (type.hasAnnotation(NonNull.class)) { checker.reportWarning(node, \"instanceof.nonnull.redundant\"); } } return super.visitInstanceOf(node, p); }", "output": "Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onStartup(ServletContext servletContext) { LongTaskTimer longTaskTimer = LongTaskTimer .builder(\"spring.cloud.dataflow.server\").description(\"DataFlow duration timer\") .tags(Tags.empty()).register(Metrics.globalRegistry); this.longTaskSample = longTaskTimer.start(); if (StringUtils.hasText(dataSourceUrl) && dataSourceUrl.startsWith(\"jdbc:h2:tcp://localhost:\")) { logger.info(\"Start Embedded H2\"); initH2TCPServer(); } }", "output": "Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String getJournalKeyFromDoi(String doi, Site site) { Map<String, Object> journalDoiRegexList = getJournalDoiRegexList(site); for (Map.Entry<String, Object> entry : journalDoiRegexList.entrySet()) { if (doi.matches(entry.getValue().toString())) { return entry.getKey(); } } return null; }", "output": "String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void addSidecar( PodData pod, CheContainer container, ChePlugin chePlugin, KubernetesEnvironment kubernetesEnvironment, Collection<CommandImpl> sidecarRelatedCommands) throws InfrastructureException { K8sContainerResolver k8sContainerResolver = new K8sContainerResolverBuilder() .setContainer(container) .setImagePullPolicy(sidecarImagePullPolicy) .setPluginName(chePlugin.getName()) .setPluginEndpoints(chePlugin.getEndpoints()) .build(); List<ChePluginEndpoint> containerEndpoints = k8sContainerResolver.getEndpoints(); Container k8sContainer = k8sContainerResolver.resolve(); String machineName = Names.machineName(pod, k8sContainer); pod.getSpec().getContainers().add(k8sContainer); MachineResolver machineResolver = new MachineResolverBuilder() .setCheContainer(container) .setContainer(k8sContainer) .setContainerEndpoints(containerEndpoints) .setDefaultSidecarMemorySizeAttribute(defaultSidecarMemoryLimitBytes) .setAttributes(kubernetesEnvironment.getAttributes()) .build(); InternalMachineConfig machineConfig = machineResolver.resolve(); machineConfig.getAttributes().put(CONTAINER_TYPE_ATTRIBUTE, \"tool-container\"); kubernetesEnvironment.getMachines().put(machineName, machineConfig); sidecarRelatedCommands.forEach(c -> c.getAttributes().put(\"machineName\", machineName)); container .getCommands() .stream() .map(c -> asCommand(machineName, c)) .forEach(c -> kubernetesEnvironment.getCommands().add(c)); SidecarServicesProvisioner sidecarServicesProvisioner = new SidecarServicesProvisioner(containerEndpoints, pod.getMetadata().getName()); sidecarServicesProvisioner.provision(kubernetesEnvironment); }", "output": "It would be better to make value a constant too"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "@Override public void draw(Canvas canvas) { if (!animating) { image.draw(canvas); } else { if (placeholder != null) { placeholder.draw(canvas); } float normalized = (SystemClock.uptimeMillis() - startTimeMillis) / FADE_DURATION; int alpha = (int) (0xFF * normalized); if (normalized >= 1f) { animating = false; placeholder = null; image.setAlpha(0xFF); image.draw(canvas); } else { image.setAlpha(alpha); image.draw(canvas); invalidateSelf(); } } if (debugging) { drawDebugIndicator(canvas); } }", "output": "Don't we need to reset alpha here? Drawables share a global state."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void addingAStudentAddsThemToTheSortedRoster() { school = new School(); school.add(\"Aimee\", 2); List<String> expected = Arrays.asList(\"Aimee\"); assertEquals(expected,school.roster()); }", "output": "There should be a space here between expected and school.roster()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static <T extends RemoteJsonService> T create(Class<T> serviceClass, GerritHttpClient gerritHttpClient, Version version) { String uri = GerritVersion.isVersion26OrLater(version) ? \"/gerrit_ui/rpc/\" : \"/gerrit/rpc/\"; InvocationHandler handler = new GerritService(gerritHttpClient, uri + serviceClass.getSimpleName()); return serviceClass.cast(Proxy.newProxyInstance(GerritService.class.getClassLoader(), new Class<?>[] { serviceClass }, handler)); }", "output": "We should put the URL fragments into static vars in a common file then select them based on version in one place rather than scatterred throughout code."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public V replace(K key, V value) { V v = delegate.replace(key, value); if (v != null) { stats.incrementCacheHits(); } else { stats.incrementCacheMisses(); } stats.incrementCachePuts(); return v; }", "output": "This should be in the if(v != null) check I am thinking"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public JCloudsSlave( @Nonnull ProvisioningActivity.Id id, @Nonnull Server metadata, @Nonnull String labelString, @Nonnull SlaveOptions slaveOptions ) throws IOException, Descriptor.FormException { super( metadata.getName(), null, slaveOptions.getFsRoot(), slaveOptions.getNumExecutors(), Mode.NORMAL, labelString, null, new JCloudsRetentionStrategy(), Collections.singletonList(new EnvironmentVariablesNodeProperty( new EnvironmentVariablesNodeProperty.Entry(\"OPENSTACK_PUBLIC_IP\", Openstack.getPublicAddress(metadata)) )) ); this.cloudName = id.getCloudName(); this.provisioningId = id; this.options = slaveOptions; this.nodeId = metadata.getId(); final Map<String, String> instanceMetaData = metadata.getMetadata(); if (instanceMetaData != null && !instanceMetaData.isEmpty()) { this.openstackMetaData = new TreeMap<>(instanceMetaData); } else { this.openstackMetaData = null; } setLauncher(new JCloudsLauncher(getLauncherFactory().createLauncher(this))); }", "output": "Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected List<SurveyGroupDto> parseSurveyGroups(String response) throws Exception { List<SurveyGroupDto> dtoList = new ArrayList<SurveyGroupDto>(); JSONArray jsonArray = getJsonArray(response); if (jsonArray == null) { return dtoList; } for (int i = 0; i < jsonArray.length(); i++) { JSONObject o = jsonArray.getJSONObject(i); if (o != null) { try { SurveyGroupDto dto = new SurveyGroupDto(); if (o.has(\"name\") && o.isNull(\"name\")) { dto.setName(o.getString(\"name\")); } if (!o.has(\"monitoringGroup\") || o.isNull(\"monitoringGroup\")) { dto.setMonitoringGroup(false); } else { dto.setMonitoringGroup(o.getBoolean(\"monitoringGroup\")); } dtoList.add(dto); } catch (Exception e) { System.out.println(\"Error in json parsing: \" + e.getMessage()); e.printStackTrace(); } } } return dtoList; }", "output": "I guess you mean !o.isNull(\"name\")? Which by itself would be enough. No need for the o.has(\"name\")"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Factory build() { BitSet redacted = new BitSet(); List<String> fields = new ArrayList<>(), keys = new ArrayList<>(); List<Integer> keyToFieldList = new ArrayList<>(); int i = 0; for (String fieldName : fieldNames) { if (redactedFieldNames.contains(fieldName)) redacted.set(i); fields.add(fieldName); keys.add(fieldName); keyToFieldList.add(i++); } for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) { String nextPrefix = entry.getKey(); String[] nextFieldNames = entry.getValue(); for (i = 0; i < nextFieldNames.length; i++) { String nextFieldName = nextFieldNames[i]; int index = fields.indexOf(nextFieldName); if (index == -1) { index = fields.size(); fields.add(nextFieldName); } keys.add(nextPrefix + nextFieldName); keyToFieldList.add(index); } } int[] keyToField = new int[keys.size()]; for (i = 0; i < keyToField.length; i++) { keyToField[i] = keyToFieldList.get(i); } String[] validated = fields.toArray(new String[0]); if (validated.length == 0) return new Factory(delegate); return new RealFactory(delegate, validated, keys.toArray(new String[0]), keyToField, redacted); }", "output": "Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(..."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static String minimalEscape(Object content) { if (content == null) { return null; } String str = String.valueOf(content); StringBuilder result = new StringBuilder((int) (str.length() * 1.1)); int length = str.length(); char c; for (int i = 0; i < length; ++i) { c = str.charAt(i); switch (c) { case '&': result.append(AMP); break; case '<': result.append(LT); break; default: result.append(c); } } return result.toString(); }", "output": "Missing Unstable attribute."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void overloadedMethodsGetResolved() throws Exception { provider = new ExtensionAwareEvaluationContextProvider( Collections.singletonList(new DummyExtension(\"_first\", \"first\") { @Override public Object getRootObject() { return new RootWithOverloads(); } })); assertThat(evaluateExpression(\"method()\")).isEqualTo(\"zero\"); assertThat(evaluateExpression(\"method(23)\")).isEqualTo(\"single-int\"); assertThat(evaluateExpression(\"method('hello')\")).isEqualTo(\"single-string\"); assertThat(evaluateExpression(\"method('one', 'two')\")).isEqualTo(\"two\"); assertThat(evaluateExpression(\"method(1, 2)\")).isEqualTo(\"two-ints\"); assertThat(evaluateExpression(\"method(1, 'two')\")).isEqualTo(\"int-and-string\"); }", "output": "Shall we extract that setup step? It's repeated in every test below."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static String getPreferredVariable(IPath[] paths, IContainer target) { IPath commonRoot = null; for (IPath path : paths) { if (path != null) { if (commonRoot == null) commonRoot = path; else { int count = commonRoot.matchingFirstSegments(path); int remainingSegments = commonRoot.segmentCount() - count; if (remainingSegments <= 0) return null; commonRoot = commonRoot.removeLastSegments(remainingSegments); } } } String mostAppropriate = null; String mostAppropriateToParent = null; int mostAppropriateCount = Integer.MAX_VALUE; int mostAppropriateCountToParent = Integer.MAX_VALUE; IPathVariableManager pathVariableManager = target.getPathVariableManager(); for (String variable : pathVariableManager.getPathVariableNames()) { if (isPreferred(variable)) { URI rawValue = pathVariableManager.getURIValue(variable); URI value = pathVariableManager.resolveURI(rawValue); if (value != null) { IPath path = URIUtil.toPath(value); if (path != null) { int difference = path.matchingFirstSegments(commonRoot); if (difference > 0) { if (difference < mostAppropriateCount) { mostAppropriateCount = difference; mostAppropriate = variable; } } else { difference = commonRoot.matchingFirstSegments(path); if (difference > 0) { if (difference < mostAppropriateCountToParent) { mostAppropriateCountToParent = difference; mostAppropriateToParent = variable; } } } } } } } if (mostAppropriate == null) { if (mostAppropriateToParent == null) return \"PROJECT_LOC\"; return mostAppropriateToParent; } return mostAppropriate; }", "output": "rename 'variableName'"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void deleteStorage(final String id, final Optional<String> user) throws DbWriteOperationsBlockedException, NoSuchStorageException, StorageIsUsedException, InternalNakadiException { if (featureToggleService.isFeatureEnabled(FeatureToggleService.Feature.DISABLE_DB_WRITE_OPERATIONS)) { throw new DbWriteOperationsBlockedException(\"Cannot delete storage: write operations on DB \" + \"are blocked by feature flag.\"); } try { final Optional<Object> storageOrNone = storageDbRepository.getStorage(id) .map(Function.identity()); storageDbRepository.deleteStorage(id); auditLogPublisher.publish( Optional.empty(), storageOrNone, NakadiAuditLogPublisher.ResourceType.STORAGE, NakadiAuditLogPublisher.ActionType.DELETED, id, user); } catch (final RepositoryProblemException e) { LOG.error(\"DB error occurred when deleting storage\", e); throw new InternalNakadiException(e.getMessage()); } catch (final TransactionException e) { LOG.error(\"Error with transaction handling when deleting storage\", e); throw new InternalNakadiException(\"Transaction error occurred when deleting storage\"); } }", "output": "Good catch, thanks. Fixed <LINK_0>"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static String loadFile(String fileName) { String content = \"\"; fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName); File file = new File(fileName); if (file.exists()) { try { content = new String(Files.readAllBytes(file.toPath())); } catch (Exception e) { log.error(\"Failed to read sysprep template '{}': {}\", fileName, e.getMessage()); log.debug(\"Exception\", e); } } else { log.error(\"Sysprep template: '{}' not found\", fileName); } return content; }", "output": "The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean invalidateIfNecessary(BaragonRequest request) { if (request.getLoadBalancerService().getOptions().get(\"edgeCacheDNS\") == null) { return false; } try { String edgeCacheDNS = ((String) request.getLoadBalancerService().getOptions().get(\"edgeCacheDNS\")); Optional<CloudflareZone> matchingZone = getCloudflareZone(edgeCacheDNS); if (!matchingZone.isPresent()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but no matching Cloudflare Zone was found!\"); return false; } String zoneId = matchingZone.get().getId(); Optional<CloudflareDnsRecord> matchingDnsRecord = getCloudflareDnsRecord(edgeCacheDNS, zoneId); if (!matchingDnsRecord.isPresent()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but no matching Cloudflare DNS Record was found!\"); return false; } if (!matchingDnsRecord.get().isProxied()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but {} is not a proxied DNS record!\", edgeCacheDNS); return false; } return cf.purgeCache( zoneId, Collections.singletonList( String.format(CACHE_TAG_FORMAT, request.getLoadBalancerService().getServiceId(), environment.getName()) ) ); } catch (CloudflareClientException e) { LOG.error(\"Unable to invalidate Cloudflare cache for request {}\", request, e); return false; } }", "output": "edgeCacheDNS as a static variable since it's used a few times?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private <V> void addCallback(CompletableFuture<V> cfuture, CommitData cd, OnSuccessInterface<V> onSuccessInterface) { cfuture.handleAsync((result, exception) -> { if (result != null) { try { onSuccessInterface.onSuccess(cd, result); return null; } catch (Exception e) { cd.commitObserver.failed(e); return null; } } else { cd.commitObserver.failed(exception); return null; } }, env.getSharedResources().getAsyncCommitExecutor()); }", "output": "If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) { log.debug(\"deleteAsyncQueryAndResultCollection\"); Collection<AsyncQuery> asyncQueryList = null; try { asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> { EntityProjection asyncQueryCollection = EntityProjection.builder() .type(AsyncQuery.class) .filterExpression(filterExpression) .build(); Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope); Iterator<Object> itr = loaded.iterator(); while (itr.hasNext()) { AsyncQuery query = (AsyncQuery) itr.next(); if (query != null) { tx.delete(query, scope); } } return loaded; }); } catch (Exception e) { log.error(\"Exception: {}\", e); } return asyncQueryList; }", "output": "The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts)."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static void markNoteAsRead(final Note note) { if (note == null) { return; } if (note.isUnread()) { WordPress.getRestClientUtilsV1_1().decrementUnreadCount(note.getId(), \"10\", new RestRequest.Listener() { @Override public void onResponse(JSONObject response) { note.setRead(); NotificationsTable.saveNote(note); } }, new RestRequest.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { AppLog.e(AppLog.T.NOTIFS, \"Could not mark note as read via API.\"); } }); } }", "output": "Let's do the same way @jleandroperez did on iOS here <LINK_0>"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Set<String> map(Set<String> genres) { Set<String> tags = Sets.newHashSet(); for (String genre : genres) { if (genre.contains(\"<LINK_0>\")) { tags.add(paTagMap.get(genre)); } } if (tags.size() == 1 && tags.contains(\"film\")) { tags.add(\"action\"); } return tags; }", "output": "Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void checkWebJavaSpringCommands() { consoles.startCommandAndCheckResult(WEB_JAVA_SPRING, BUILD, \"build\", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, BUILD, \"web-java-spring:build\", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, \"web-java-spring:build and run\", \"Server startup in\"); consoles.startCommandAndCheckApp(currentWindow, \" consoles.closeProcessTabWithAskDialog(\"web-java-spring:build and run\"); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, \"web-java-spring:run tomcat\", \"Server startup in\"); consoles.startCommandAndCheckApp(currentWindow, \" projectExplorer.invokeCommandWithContextMenu( RUN, WEB_JAVA_SPRING, \"web-java-spring:stop tomcat\"); consoles.selectProcessInProcessConsoleTreeByName(\"Terminal\"); terminal.typeIntoTerminal(\"ps ax\"); terminal.typeIntoTerminal(ENTER.toString()); terminal.waitExpectedTextNotPresentTerminal(\"/bin/bash -c $TOMCAT_HOME/bin/catalina.sh\"); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, DEBUG, \"web-java-spring:debug\", \"Listening for transport dt_socket at address: 8000\"); }", "output": "let's make constant with \"web-java-spring:stop tomcat\" command: STOP_TOMCAT_COMMAND_ITEM_NAME"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public abstract BufferedSink valueSink() throws IOException; public final JsonWriter jsonValue(@Nullable Object value) throws IOException { if (value instanceof Map<?, ?>) { beginObject(); for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { Object key = entry.getKey(); if (!(key instanceof String)) { throw new IllegalArgumentException( \"Map keys must be of type String: \" + key.getClass().getName()); } name(((String) key)); jsonValue(entry.getValue()); } endObject(); } else if (value instanceof List<?>) { beginArray(); for (Object element : ((List<?>) value)) { jsonValue(element); } endArray(); } else if (value instanceof String) { value(((String) value)); } else if (value instanceof Boolean) { value(((Boolean) value).booleanValue()); } else if (value instanceof Double) { value(((Double) value).doubleValue()); } else if (value instanceof Long) { value(((Long) value).longValue()); } else if (value instanceof Number) { value(((Number) value)); } else if (value == null) { nullValue(); } else { throw new IllegalArgumentException(\"Unsupported type: \" + value.getClass().getName()); } return this; }", "output": "what does this do if key is null?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) { this.context = context; String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME; File dir = new File(modOutPath); if (dir.exists() == false) { dir.mkdirs(); } extractPrefetchFiles(dataSource); final String prefetchDumper = getPathForPrefetchDumper(); if (prefetchDumper == null) { logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); return; } if (context.dataSourceIngestIsCancelled()) { return; } String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE; try { String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME ); parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath); createAppExecArtifacts(modOutFile); } catch (IOException ex) { logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); } }", "output": "The output of this call should be checked and if it's false I think it should bail."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void parsesInvalidIdField() throws IOException { final MemberProfileJson memberprofilejson = Mockito.mock(MemberProfileJson.class); Mockito.when( memberprofilejson.fetch( Mockito.anyString(), Mockito.anyString(), Mockito.any(Href.class) ) ).thenReturn( Json.createReader( new FileInputStream( PsLinkedinTest.class.getResource( \"linkedinTestUserInvalidId.json\" ).getPath() ) ).readObject() ); try { new PsLinkedin(memberprofilejson) .enter(REQUEST); } catch (final ClassCastException ex) { MatcherAssert.assertThat( ex.getMessage(), Matchers.containsString(\"cannot be cast to\") ); throw ex; } }", "output": "@ikhvostenkov please name it json"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Matcher<View> atPositionOnView(final int position, final int targetViewId) { return new TypeSafeMatcher<View>() { Resources resources = null; View childView; public void describeTo(Description description) { String idDescription = Integer.toString(recyclerViewId); if (this.resources != null) { try { idDescription = this.resources.getResourceName(recyclerViewId); } catch (Resources.NotFoundException var4) { idDescription = String.format(\"%s (resource name not found)\", recyclerViewId); } } description.appendText(\"with id: \" + idDescription); } public boolean matchesSafely(View view) { this.resources = view.getResources(); if (childView == null) { RecyclerView recyclerView = (RecyclerView) view.getRootView().findViewById(recyclerViewId); if (recyclerView != null && recyclerView.getId() == recyclerViewId) { childView = recyclerView.findViewHolderForAdapterPosition(position).itemView; } else { return false; } } if (targetViewId == -1) { return view == childView; } else { View targetView = childView.findViewById(targetViewId); return view == targetView; } } }; }", "output": "why var4? Resources.NotFoundException e would be a bit nicer.."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public I setContext(HttpRequest request) { this.request = GeneratedHttpRequest.class.cast(request); return (I) this; }", "output": "Check for illegal arg or are we happy with a ClassCastException here?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private <T extends Enum<T>> void registerStatistic(String statNameSuffix, StatisticType type, final OperationStatisticDescriptor<T> descriptor, final EnumSet<T> outcomes) { if (contextObject == null) { return; } Set<TreeNode> result = queryBuilder() .descendants() .filter(context(attributes(Matchers.<Map<String, Object>>allOf( hasAttribute(\"type\", descriptor.getType()), hasAttribute(\"name\", descriptor.getObserverName()), hasAttribute(\"tags\", new Matcher<Set<String>>() { @Override protected boolean matchesSafely(Set<String> object) { return object.containsAll(descriptor.getTags()); } }))))) .filter(context(identifier(subclassOf(OperationStatistic.class)))) .build().execute(Collections.singleton(ContextManager.nodeFor(contextObject))); if (!result.isEmpty()) { for (TreeNode node : result) { String discriminator = null; Map<String, Object> properties = (Map<String, Object>) node.getContext().attributes().get(\"properties\"); if (properties != null && properties.containsKey(\"discriminator\")) { discriminator = properties.get(\"discriminator\").toString(); } String fullStatName = (discriminator == null ? \"\" : (discriminator + \":\")) + statNameSuffix; final OperationStatistic<T> statistic = (OperationStatistic<T>) node.getContext().attributes().get(\"this\"); registerStatistic(fullStatName, type, new ValueStatistic<Number>() { @Override public Number value() { return statistic.sum(outcomes); } }); } } }", "output": "Mutualize with the other matcher on tags"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void setPublicURIs(final FileSystem fileSystem) { final String[] uris = fileSystem.toString().split(\"\\\\r?\\\\n\"); final List<PublicURI> publicURIs = new ArrayList<>(uris.length); for (final String s : uris) { final int protocolStart = s.indexOf(\"://\"); publicURIs.add(getPublicURI(s, protocolStart)); } repo.setPublicURIs(publicURIs); }", "output": "Maybe using a constant here for \"://\""}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void handleRelatedAlarms(OnmsAlarm situation) { if (!situation.isSituation()) { return; } alarmAssociationById.putIfAbsent(situation.getId(), new HashMap<>()); final Map<Integer, AlarmAssociationAndFact> associationFacts = alarmAssociationById.get(situation.getId()); for (AlarmAssociation association : situation.getAssociatedAlarms()) { Integer alarmId = association.getRelatedAlarm().getId(); AlarmAssociationAndFact assocationFact = associationFacts.get(alarmId); if (assocationFact == null) { LOG.debug(\"Inserting alarm association into session: {}\", association); final FactHandle fact = getKieSession().insert(association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } else { FactHandle fact = assocationFact.getFact(); LOG.trace(\"Updating alarm assocation in session: {}\", assocationFact); getKieSession().update(fact, association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } } Set<Integer> deletedAlarmIds = associationFacts.values().stream() .map(fact -> fact.getAlarmAssociation().getRelatedAlarm().getId()) .filter(alarmId -> !situation.getRelatedAlarmIds().contains(alarmId)) .collect(Collectors.toSet()); deletedAlarmIds.stream().forEach(alarmId -> { final AlarmAssociationAndFact associationAndFact = associationFacts.remove(alarmId); if (associationAndFact != null) { LOG.debug(\"Deleting AlarmAssociationAndFact from session: {}\", associationAndFact.getAlarmAssociation()); getKieSession().delete(associationAndFact.getFact()); } }); }", "output": "suggestion deletedAlarmIds.forEach(alarmId -> {"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Obs saveObs(Obs obs, String changeMessage) throws APIException { if(obs == null){ throw new APIException(\"Obs.error.cannot.be.null\", (Object[]) null); } if(obs.getId() != null && changeMessage == null){ throw new APIException(\"Obs.error.ChangeMessage.required\", (Object[]) null); } handleExistingObsWithComplexConcept(obs); ensureRequirePrivilege(obs); if (obs.getObsId() == null || obs.getVoided()) { return saveNewOrVoidedObs(obs,changeMessage); } else if(!obs.isDirty()){ setPersonFromEncounter(obs); return saveObsNotDirty(obs, changeMessage); } else { Errors errors = new BindException(obs, \"obs\"); new ObsValidator().validate(obs, errors); if (!errors.hasFieldErrors(\"person\")){ setPersonFromEncounter(obs); return saveExistingObs(obs,changeMessage); } else{ throw new APIException(\"Obs.error.PersonId.mismatch\", (Object[]) null); } } }", "output": "You don't need to call the validator, it's called automatically via AOP advice around the saveObs method."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void onExportChanged() { boolean externalNetwork = (Boolean) getExport().getEntity(); getQos().setIsChangable(!externalNetwork); getAddQosCommand().setIsExecutionAllowed(!externalNetwork); String label = getNetworkLabel().getSelectedItem(); if (externalNetwork) { getNetworkLabel().setItems(new HashSet<String>()); } else { getNetworkLabel().setItems(dcLabels); } getNetworkLabel().setSelectedItem(label); }", "output": "consider 'ternary if' here"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void executeCommand() { setVds(null); if (getVds() == null) { setCommandShouldBeLogged(false); log.infoFormat(\"SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore.\", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } if (getVds().getStatus() != VDSStatus.Maintenance) { setCommandShouldBeLogged(false); log.infoFormat(\"SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance.\", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString()); if (result) { getVds().setStatus(VDSStatus.Down); if (!getParameters().getKeepPolicyPMEnabled()) { getVds().setPowerManagementControlledByPolicy(false); } getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData()); } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) { FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop); parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled()); Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext()); } getReturnValue().setSucceeded(result); }", "output": "power down"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Optional<Symbol> resolveMember(String memberName) { if (types.stream().anyMatch(type -> type instanceof RuntimeType && ((RuntimeType) type).hasUnresolvedHierarchy())) { return Optional.empty(); } Set<Optional<Symbol>> resolved = types.stream() .map(t -> t.resolveMember(memberName)) .filter(Optional::isPresent) .collect(Collectors.toSet()); if (resolved.isEmpty()) { return Optional.empty(); } else if (resolved.size() == 1) { return resolved.iterator().next(); } return Optional.of(AmbiguousSymbolImpl.create(resolved.stream().map(s -> s.orElse(null)).filter(Objects::nonNull).collect(Collectors.toSet()))); }", "output": "I don't think \"resolveMember\" should create a new symbol. We should find another approach"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static BlobProperties buildBlobProperties(Map<String, Object> args) throws RestServiceException { Account account = (Account) args.get(InternalKeys.TARGET_ACCOUNT_KEY); if (account == null) { throw new RestServiceException(InternalKeys.TARGET_ACCOUNT_KEY + \" is not set\", RestServiceErrorCode.MissingArgs); } Container container = (Container) args.get(InternalKeys.TARGET_CONTAINER_KEY); if (container == null) { throw new RestServiceException(InternalKeys.TARGET_CONTAINER_KEY + \" is not set\", RestServiceErrorCode.MissingArgs); } String serviceId = getHeader(args, Headers.SERVICE_ID, true); String contentType = getHeader(args, Headers.AMBRY_CONTENT_TYPE, true); String ownerId = getHeader(args, Headers.OWNER_ID, false); long ttl = Utils.Infinite_Time; String ttlStr = getHeader(args, Headers.TTL, false); if (ttlStr != null) { try { ttl = Long.parseLong(ttlStr); if (ttl < -1) { throw new RestServiceException(Headers.TTL + \"[\" + ttl + \"] is not valid (has to be >= -1)\", RestServiceErrorCode.InvalidArgs); } } catch (NumberFormatException e) { throw new RestServiceException(Headers.TTL + \"[\" + ttlStr + \"] could not parsed into a number\", RestServiceErrorCode.InvalidArgs); } } return new BlobProperties(-1, serviceId, ownerId, contentType, isPrivate(args), ttl, account.getId(), container.getId()); }", "output": "Let's make this InternalServerError"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public AlphaRejectBlocksNode(Context context) { Config config = context.get(Config.class); DisplayResolutionDependentFBOs displayResolutionDependentFBOs = context.get(DisplayResolutionDependentFBOs.class); worldRenderer = context.get(WorldRenderer.class); renderQueues = context.get(RenderQueuesHelper.class); wireframeStateChange = new SetWireframe(true); RenderingDebugConfig renderingDebugConfig = config.getRendering().getDebug(); new WireframeTrigger(renderingDebugConfig, this); playerCamera = worldRenderer.getActiveCamera(); addDesiredStateChange(new LookThrough(playerCamera)); addDesiredStateChange(new BindFBO(READONLY_GBUFFER, displayResolutionDependentFBOs)); addDesiredStateChange(new EnableMaterial(CHUNK_SHADER.toString())); chunkShader = getMaterial(CHUNK_SHADER); }", "output": "1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static String print(Node n, String encoding) { if (n == null) { return null; } try { Document document = null; if (n instanceof Document) { document = (Document) n; } else { document = n.getOwnerDocument(); } StringWriter stringOut = new StringWriter(); DOMImplementationLS domImpl = (DOMImplementationLS) document.getImplementation(); LSSerializer lsSerializer = domImpl.createLSSerializer(); lsSerializer.getDomConfig().setParameter(XML_DECLARATION, false); LSOutput lsout = domImpl.createLSOutput(); lsout.setEncoding(encoding); lsout.setCharacterStream(stringOut); NodeList childNodes = n.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { lsSerializer.write(childNodes.item(i), lsout); } return stringOut.toString(); } catch (DOMException | LSException e) { LOGGER.debug(e.getMessage(), e); } return null; }", "output": "Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onCompletion(Void result, Exception exception) { callbackTracker.markOperationEnd(); if (exception == null) { try { RestMethod restMethod = restRequest.getRestMethod(); logger.trace(\"Forwarding {} to the IdConverter/Router\", restMethod); switch (restMethod) { case GET: String receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); InboundIdConverterCallback idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, getCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case HEAD: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, headCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case DELETE: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, deleteCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; default: exception = new IllegalStateException(\"Unrecognized RestMethod: \" + restMethod); } } catch (Exception e) { exception = extractExecutionExceptionCause(e); } } if (exception != null) { submitResponse(restRequest, restResponseChannel, null, exception); } callbackTracker.markCallbackProcessingEnd(); }", "output": "Why not extract receivedId before switch block? (reduce the duplicate code)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "@OnClick(R.id.gallery_cta_button) void onTranslateClick(View v) { GalleryItemFragment item = getCurrentItem(); if (item == null || item.getImageTitle() == null || item.getMediaInfo() == null || item.getMediaInfo().getMetadata() == null) { return; } if (imageEditType != null) { switch (imageEditType) { case ADD_TAGS: startTagsEdit(item); break; case ADD_CAPTION_TRANSLATION: startCaptionTranslation(item); break; default: startCaptionEdit(item); } } }", "output": "Feels like this null check can be included above."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static String toHex(String s) { StringBuffer buf = null; try { buf = new StringBuffer(s.getBytes(\"UTF-8\").length); for (byte x : s.getBytes(\"UTF-8\")) { buf.append(\"%\"); buf.append(Integer.toHexString(x & 0xFF)); } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return buf.toString().toUpperCase(); }", "output": "Extra space"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private SmooshedWriter delegateSmooshedWriter(final String name,final long size) throws IOException { final File tmpFile = new File(baseDir, name); createFiles.add(tmpFile); return new SmooshedWriter () { private int currOffset = 0; private boolean open = true; private final FileOutputStream out = new FileOutputStream(tmpFile); @Override public void close() throws IOException { open = false; out.close(); files.add(tmpFile); if(!writerCurrentlyInUse ) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { FileChannel channel = out.getChannel(); int bytesWritten = channel.write(buffer); return addToOffset(bytesWritten); } @Override public int write(InputStream in) throws IOException { return addToOffset(Ints.checkedCast(java.nio.file.Files.copy(in, tmpFile.toPath()))); } public int addToOffset(int numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(\"Wrote more bytes[%,d] than available[%,d]. Don't do that.\", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return numBytesWritten; } @Override public boolean isOpen() { return open; } }; }", "output": "This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name \"verify\" which makes it clear that the intent of the method is to do some state checks..."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public DnsClientImpl(VertxInternal vertx, DnsClientOptions options) { Objects.requireNonNull(options, \"no null options accepted\"); Objects.requireNonNull(options.getHost(), \"no null host accepted\"); if (options.getPort() < 1) { throw new IllegalArgumentException(\"DNS client port \" + options.getPort() + \" must be > 0\"); } if (options.getQueryTimeout() < 0) { throw new IllegalArgumentException(\"DNS client timeout \" + options.getQueryTimeout() + \" must be > 0\"); } this.options = new DnsClientOptions(options); ContextInternal creatingContext = vertx.getContext(); if (creatingContext != null && creatingContext.isMultiThreadedWorkerContext()) { throw new IllegalStateException(\"Cannot use DnsClient in a multi-threaded worker verticle\"); } this.dnsServer = new InetSocketAddress(options.getHost(), options.getPort()); this.vertx = vertx; Transport transport = vertx.transport(); actualCtx = vertx.getOrCreateContext(); channel = transport.datagramChannel(InternetProtocolFamily.IPv4); channel.config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true); channel.config().setMaxMessagesPerRead(1); channel.config().setAllocator(PartialPooledByteBufAllocator.INSTANCE); actualCtx.nettyEventLoop().register(channel); if (options.getLogActivity()) { channel.pipeline().addLast(\"logging\", new LoggingHandler()); } channel.pipeline().addLast(new DatagramDnsQueryEncoder()); channel.pipeline().addLast(new DatagramDnsResponseDecoder()); channel.pipeline().addLast(new SimpleChannelInboundHandler<DnsResponse>() { @Override protected void channelRead0(ChannelHandlerContext ctx, DnsResponse msg) throws Exception { int id = msg.id(); Query query = inProgressMap.get(id); if (query != null) { query.handle(msg); } } }); }", "output": "I think this test should be moved to options instead"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager( getResources().getInteger(R.integer.news_fragment_column_count), StaggeredGridLayoutManager.VERTICAL); getListView().setLayoutManager(layoutManager); mAdapter = new NewsAdapter(getActivity(), ((GdgActivity) getActivity()).getGoogleApiClient()); setRecyclerAdapter(mAdapter); setOnRefreshListener(this); final String plusId = getArguments().getString(Const.EXTRA_PLUS_ID); if (Utils.isOnline(getActivity())) { new Builder<>(String.class, Activities.class) .addParameter(plusId) .setOnPreExecuteListener(new CommonAsyncTask.OnPreExecuteListener() { @Override public void onPreExecute() { setIsLoading(true); } }) .setOnBackgroundExecuteListener( new CommonAsyncTask.OnBackgroundExecuteListener<String, Activities>() { @Override public Activities doInBackground(String... params) { Activities feed = (Activities) App.getInstance().getModelCache().get(Const.CACHE_KEY_NEWS + params[0]); if (feed == null) { feed = getActivityFeedSync(params[0]); } return feed; } }) .setOnPostExecuteListener(new CommonAsyncTask.OnPostExecuteListener<String, Activities>() { @Override public void onPostExecute(String[] params, Activities activityFeed) { if (activityFeed != null) { mAdapter.addAll(activityFeed.getItems()); setIsLoading(false); } } }) .buildAndExecute(); } else { App.getInstance().getModelCache().getAsync(Const.CACHE_KEY_NEWS + plusId, false, new ModelCache.CacheListener() { @Override public void onGet(Object item) { Activities feed = (Activities) item; if (isAdded()) { Snackbar snackbar = Snackbar.make(getView(), R.string.cached_content, Snackbar.LENGTH_SHORT); ColoredSnackBar.info(snackbar).show(); } mAdapter.addAll(feed.getItems()); setIsLoading(false); } @Override public void onNotFound(String key) { showError(R.string.offline_alert); } }); } }", "output": "Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String[] getSupportedExtensions() { return new String[] { \"at3\", \"oma\", \"aa3\", \"at9\", }; }", "output": "@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }", "output": "SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String buildRunCommand() { final List<String> runCommand; if (importsZip == null || abstractEntryClient instanceof ToolClient || Objects.equals(languageType, LanguageType.WDL)) { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), \"--inputs\", provisionedParameterFile.getAbsolutePath()); } else { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), \"--inputs\", provisionedParameterFile.getAbsolutePath(), \"--imports\", importsZip.getAbsolutePath()); } System.out.println(\"Calling out to \" + LAUNCHER_NAME + \" to run your workflow\"); final String[] s = { \"java\", \"-jar\", exectionFile.getAbsolutePath(), \"run\" }; List<String> arguments = new ArrayList<>(); arguments.addAll(Arrays.asList(s)); arguments.addAll(runCommand); final String join = Joiner.on(\" \").join(arguments); System.out.println(\"Executing: \" + join); return join; }", "output": "You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Mono<CloseableChannel> start(ConnectionAcceptor acceptor, int mtu) { Objects.requireNonNull(acceptor, \"acceptor must not be null\"); return server .handle( (request, response) -> { transportHeaders.get().forEach(response::addHeader); return response.sendWebsocket( null, Math.max(DEFAULT_FRAME_SIZE, mtu == 0 ? FRAME_MAX_SIZE : mtu), (in, out) -> { DuplexConnection connection = new WebsocketDuplexConnection((Connection) in); if (mtu > 0) { connection = new FragmentationDuplexConnection( connection, ByteBufAllocator.DEFAULT, mtu, false); } return acceptor.apply(connection).then(out.neverComplete()); }); }) .bind() .map(CloseableChannel::new); }", "output": "what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private ClusteringModel pmmlClusteringModel(KMeansModel model, Map<Integer,Long> clusterSizesMap) { ClusteringModel clusteringModel = new ClusteringModel(AppPMMLUtils.buildMiningSchema(inputSchema), new ComparisonMeasure(ComparisonMeasure.Kind.DISTANCE) .withMeasure(new SquaredEuclidean()), MiningFunctionType.CLUSTERING, ClusteringModel.ModelClass.CENTER_BASED, model.clusterCenters().length) .withNumberOfClusters(model.k()); if (initializationStrategy.equals(KMeans.K_MEANS_PARALLEL())) { clusteringModel.setAlgorithmName(\"K-Means||\"); } else if (initializationStrategy.equals(KMeans.RANDOM())) { clusteringModel.setAlgorithmName(\"random\"); } Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { FieldName field = FieldName.create(\"field_\" + i); clusteringModel.getClusteringFields().add( new ClusteringField(field).withCompareFunction(CompareFunctionType.ABS_DIFF)); clusteringModel.getClusters().add(toCluster(clusterCenters[i], i, (int)clusterSizesMap.get(i).longValue())); } return clusteringModel; }", "output": "call intValue() and then there is no cast"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private List<Target> computeTargets(final ArgumentParser parser, final List<String> explicitEndpoints, final List<String> domainsArguments, final String srvName) { if (explicitEndpoints != null && !explicitEndpoints.isEmpty()) { final List<Target> targets = Lists.newArrayListWithExpectedSize(explicitEndpoints.size()); for (final String endpoint : explicitEndpoints) { targets.add(ExplicitTarget.from(URI.create(endpoint))); } return targets; } else if (domainsArguments != null && !domainsArguments.isEmpty()) { final Iterable<String> sites = parseDomains(domainsArguments); return SrvTarget.from(srvName, sites); } else if (!cliConfig.getMasterEndpoints().isEmpty()) { final List<URI> cliConfigMasterEndpoints = cliConfig.getMasterEndpoints(); List<Target> targets = Lists.newArrayListWithExpectedSize(cliConfigMasterEndpoints.size()); for (final URI endpoint : cliConfigMasterEndpoints) { targets.add(ExplicitTarget.from(endpoint)); } return targets; } else if (!cliConfig.getSitesString().isEmpty()) { final Iterable<String> sites = parseDomainsString(cliConfig.getSitesString()); return SrvTarget.from(srvName, sites); } handleError(parser, new ArgumentParserException( \"no masters specified. Use the -z or -d option to specify which helios \" + \"cluster/master to connect to\", parser)); return ImmutableList.of(); }", "output": "I think you can probably change the return type to List<? extends Target>"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void processNotification(OSNotification originalNotification, @Nullable OSNotification notification) { OneSignal.onesignalLog(OneSignal.LOG_LEVEL.DEBUG, \"processNotification called from Thread: \" + Thread.currentThread().toString()); if (notification != null) { boolean display = isStringEmpty(notification.getBody()); if (!display) { notDisplayNotificationLogic(originalNotification); } else { notificationJob.setNotification(notification); NotificationBundleProcessor.processJobForDisplay(this, isBackgroundLogic); } if (isRestoring) OSUtils.sleep(100); } else { notDisplayNotificationLogic(originalNotification); } }", "output": "This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void missingMapping(RegistryEvent.MissingMappings<Item> event) { for (MissingMappings.Mapping<Item> entry : event.getAllMappings()) { if (entry.key.toString().equals(\"minecraft:totem\")) { ResourceLocation newTotem = new ResourceLocation(\"minecraft:totem_of_undying\"); entry.remap(ForgeRegistries.ITEMS.getValue(newTotem)); } if (entry.key.toString().equals(\"forge:bucketFilled\")) { ResourceLocation newBucket = new ResourceLocation(\"forge:bucket_filled\"); entry.remap(ForgeRegistries.ITEMS.getValue(newBucket)); } } }", "output": "I'm pretty sure it ends up being lower cased because the registries do not support capital letters."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ProductInfo updateProduct(String productId, ProductInfo pinfo) { if (productId == null) { throw new IllegalArgumentException(\"productId is null\"); } if (pinfo == null) { throw new IllegalArgumentException(\"pinfo is null\"); } ProductData pdata = this.productMap.get(productId); if (pdata == null) { throw new IllegalStateException(\"product does not exist: \" + productId); } Collection<ProductContentData> pcdata = this.resolveProductContent(pdata.getProductContent()); if (pcdata != null) { pdata.setProductContent(pcdata); } if (pinfo.getName() != null) { pdata.setName(pinfo.getName()); } if (pinfo.getMultiplier() != null) { pdata.setMultiplier(pinfo.getMultiplier()); } if (pinfo.getAttributes() != null) { pdata.setAttributes(pinfo.getAttributes()); } if (pinfo.getDependentProductIds() != null) { pdata.setDependentProductIds(pinfo.getDependentProductIds()); } if (pinfo.getBranding() != null) { pdata.setBranding(this.resolveBranding(pinfo.getBranding())); } this.updateProductContentMappings(pdata); pdata.setUpdated(new Date()); return pdata; }", "output": "Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void injectHooks() { HookFile hookFile = fetchHookFile(); if (hookFile == null) { return; } HookParser parser = hookFile.getParser(); Injectable[] injectables = parser.getInjectables(); if (injectables == null) { return; } int index = 0; try { for (Injectable inj : injectables) { inj.inject(); index++; } } catch (NullPointerException ex) { if(!crashed) { Injectable inj = injectables[index]; int resp = UILog.alert(\"Outdated client\", \"This server currently has outdated hooks, please report it to a member of the Parabot staff/Dev Team.\\r\\n\\r\\n\" + \"Broken hook:\\r\\n\"+inj, new Object[]{\"Close\", \"Report here...\"}, JOptionPane.ERROR_MESSAGE); if(resp == 1) { URI uri = URI.create(Configuration.COMMUNITY + \"forum/135-reports/\"); try { Desktop.getDesktop().browse(uri); } catch (IOException ignore) {} } } crashed = true; throw ex; } Context.getInstance().setHookParser(parser); }", "output": "Remove /Dev Team"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void execute(TupleWindow inputWindow) { for (Tuple tuple : inputWindow.get()) { sum += tuple.getLongByField(\"value\"); } state.put(\"sum\", sum); collector.emit(new Values(sum)); }", "output": "You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private CDPStructuredNotificationDetails getNotificationDetails(ResourceEvent resourceEvent, String resourceCrn, String resourceType, Object payload) { String serializedPayload; try { serializedPayload = new Gson().toJson(payload); LOGGER.debug(\"CDPStructuredNotificationDetails' payload has been serialized with ResourceEvent[{}], resource type[{}], CRN[{}]\", resourceEvent.name(), resourceType, resourceCrn); } catch (RuntimeException re) { String msg = String.format(\"CDPStructuredNotificationDetails' payload couldn't be serialized with ResourceEvent[%s], resource type[%s], CRN[%s]\", resourceEvent.name(), resourceType, resourceCrn); LOGGER.warn(msg, re); serializedPayload = msg; } return new CDPStructuredNotificationDetails(resourceEvent, resourceCrn, resourceType, serializedPayload); }", "output": "I see no reason to introduce msg here, you could just use serializedPayload"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static Map<String, String> getInputFiles(String descriptorAbsolutePath) { WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, \"Problem parsing WDL file: \" + ex.getMessage(), API_ERROR); } return wdlInputs; }", "output": "Put the test in the same package (not directory) and you can at least use package private or protected"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<Timeline> listTimelines(final String eventType) { return jdbcTemplate.query( BASE_TIMELINE_QUERY + \" WHERE t.et_name=? order by t.t_order\", new Object[]{eventType}, timelineRowMapper); }", "output": "a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, \"filter\"); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }", "output": "suggestion Objects.requireNonNull(filter, \"filter cannot be null\");"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void write(Object msg, boolean flush, ChannelPromise promise) { final AbstractChannelHandlerContext next; if (flush) { AbstractChannelHandlerContext ctx = this; do { ctx = ctx.prev; } while ((ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0); next = ctx; } else { next = findContextOutbound(MASK_WRITE); } final Object m = pipeline.touch(msg, next); EventExecutor executor = next.executor(); if (executor.inEventLoop()) { if (flush) { next.invokeWriteAndFlush(m, promise); } else { next.invokeWrite(m, promise); } } else { final AbstractWriteTask task; if (flush) { task = WriteAndFlushTask.newInstance(next, m, promise); } else { task = WriteTask.newInstance(next, m, promise); } if (!safeExecute(executor, task, promise, m)) { task.cancel(); } } }", "output": "Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void serialize_test() { Note note = new Note() .setAuthor(HARDCODED_AUTHOR) .setDate(HARDCODED_DATE) .setUserIdsToNotify(Arrays.asList(HARDCODED_USER_IDS)) .setId(HARDCODED_ID) .setContactId(HARDCODED_CONTACT_ID) .setLinkedDealId(HARDCODED_LINKED_ID) .setModifiedAt(HARDCODED_MODIFY_DATE) .setCreatedAt(HARDCODED_CREATE_DATE); String json = NoteSerializer.toJsonObject(note); try { Note parsedNote = NoteSerializer.fromString(json); assertEquals(HARDCODED_AUTHOR, parsedNote.getAuthor()); assertEquals(HARDCODED_CONTACT_ID, parsedNote.getContactId()); assertEquals(HARDCODED_DATE, parsedNote.getDate()); assertEquals(HARDCODED_MODIFY_DATE, parsedNote.getModifiedAt()); assertEquals(HARDCODED_CREATE_DATE, parsedNote.getCreatedAt()); assertEquals(HARDCODED_ID, parsedNote.getId()); List<String> parsedUserIds = parsedNote.getUserIdsToNotify(); List<String> originalUserIds = Arrays.asList(HARDCODED_USER_IDS); assertTrue( parsedUserIds.containsAll(originalUserIds) && originalUserIds.containsAll(parsedUserIds)); } catch (OnePageException e) { e.printStackTrace(); } }", "output": "@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Owner updateOwner(@PathParam(\"owner_key\") @Verify(Owner.class) String key, @ApiParam(name = \"owner\", required = true) Owner owner) { Owner toUpdate = findOwner(key); EventBuilder eventBuilder = eventFactory.getEventBuilder(Target.OWNER, Type.MODIFIED) .setOldEntity(toUpdate); log.debug(\"Updating owner: {}\", key); if (owner.getDisplayName() != null) { toUpdate.setDisplayName(owner.getDisplayName()); } if (owner.getParentOwner() != null) { toUpdate.setParentOwner(owner.getParentOwner()); } if (owner.getDefaultServiceLevel() != null) { if (owner.getDefaultServiceLevel().equals(\"\")) { toUpdate.setDefaultServiceLevel(null); } else { serviceLevelValidator.validate(toUpdate, owner.getDefaultServiceLevel()); toUpdate.setDefaultServiceLevel(owner.getDefaultServiceLevel()); } } if (owner.getAutobindDisabled() != null) { toUpdate.setAutobindDisabled(owner.getAutobindDisabled()); } if (config.getBoolean(ConfigProperties.STANDALONE) && !toUpdate.getContentAccessMode().equals(owner.getContentAccessMode()) && owner.getContentAccessMode() != null) { throw new BadRequestException( i18n.tr(\"The owner content access mode cannot be set directly in standalone mode.\")); } boolean refreshContentAccess = false; if (owner.getContentAccessMode() != null) { if (toUpdate.isAllowedContentAccessMode(owner.getContentAccessMode())) { String before = toUpdate.getContentAccessMode(); String after = owner.getContentAccessMode(); if (!after.equals(before)) { toUpdate.setContentAccessMode(owner.getContentAccessMode()); refreshContentAccess = true; } } else { throw new BadRequestException( i18n.tr(\"The content access mode is not allowed for this owner.\")); } } ownerCurator.merge(toUpdate); ownerCurator.flush(); if (refreshContentAccess) { ownerManager.refreshOwnerForContentAccess(toUpdate); } Event e = eventBuilder.setNewEntity(toUpdate).buildEvent(); sink.queueEvent(e); return toUpdate; }", "output": "Need a null check here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testAcquireLockWithLockNotAvailableException() { JedisOps ops = mock(JedisOps.class); when(ops.setnx(eq(\"key\"), anyString())).thenReturn(0L); when(ops.ttl(\"key\")).thenReturn(30L); RedisLock lock = new RedisLock(ops); try { lock.acquireLock(\"key\", 10); } catch (LockNotAvailableException e) { assertTrue(\"LockNotAvailableException expected\", true); } InOrder inOrder = inOrder(ops); inOrder.verify(ops, times(1)).setnx(eq(\"key\"), anyString()); inOrder.verify(ops, times(1)).expire(\"key\", 10); }", "output": "This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(\"key\", 10); fail(\"expected exception\"); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(\"key\", 10); fail(\"expected exception\"); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<DataType> all() { return new ArrayList<>(dataTypes.values()); }", "output": "as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); }"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void startSequencesAtBeginning(TopicPartition topicPartition, ProducerIdAndEpoch newProducerIdAndEpoch) { final PrimitiveRef.IntRef sequence = PrimitiveRef.ofInt(0); getPartition(topicPartition).resetSequenceNumbers(inFlightBatch -> { inFlightBatch.resetProducerState(newProducerIdAndEpoch, sequence.value, inFlightBatch.isTransactional()); sequence.value += inFlightBatch.recordCount; }); getPartition(topicPartition).nextSequence = sequence.value; getPartition(topicPartition).lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER; }", "output": "nit: maybe we can save the result of getPartition(topicPartition)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private String getDataSourceName(DataSource dataSource) { Preconditions.checkArgument( dataSource instanceof TableDataSource, \"Subqueries and Unions are only supported in the broker\" ); return Iterables.getOnlyElement(dataSource.getNames()); }", "output": "I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void canTerminate(IProcessDMContext[] procDmcs, DataRequestMonitor<Boolean> rm) { if (procDmcs.length == 0) { IGDBControl gdbControl = fTracker.getService(IGDBControl.class); if (gdbControl != null) { rm.setData(true); } else { rm.setStatus(new Status(IStatus.ERROR, GdbUIPlugin.PLUGIN_ID, \"Service is not available.\")); } rm.done(); return; } IMultiTerminate multiTerminate = fTracker.getService(IMultiTerminate.class); if (multiTerminate != null) { multiTerminate.canTerminateSome(procDmcs, rm); } else { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null && procDmcs.length == 1) { procService.canTerminate(procDmcs[0], rm); } else { rm.setData(false);; rm.done(); } } }", "output": "Two ;;"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public AbfsRestOperation createPath(final String path, final boolean isFile, final boolean overwrite, final String permission, final String umask, final boolean appendBlob) throws AzureBlobFileSystemException { final List<AbfsHttpHeader> requestHeaders = createDefaultHeaders(); if (!overwrite) { requestHeaders.add(new AbfsHttpHeader(IF_NONE_MATCH, AbfsHttpConstants.STAR)); } if (permission != null && !permission.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_PERMISSIONS, permission)); } if (umask != null && !umask.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_UMASK, umask)); } final AbfsUriQueryBuilder abfsUriQueryBuilder = createDefaultUriQueryBuilder(); abfsUriQueryBuilder.addQuery(QUERY_PARAM_RESOURCE, isFile ? FILE : DIRECTORY); if (appendBlob) { abfsUriQueryBuilder.addQuery(QUERY_PARAM_BLOBTYPE, APPEND_BLOB_TYPE); } final URL url = createRequestUrl(path, abfsUriQueryBuilder.toString()); final AbfsRestOperation op = new AbfsRestOperation( AbfsRestOperationType.CreatePath, this, HTTP_METHOD_PUT, url, requestHeaders); op.execute(); return op; }", "output": "Test the change against an account in prod tenant which still doesnt have Dec-12 bits ."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void buildColumns(ElasticsearchTableDescription tableDescription) { Set<ElasticsearchColumn> columns = new HashSet(); Client client = clients.get(tableDescription.getClusterName()); verify(client != null); try { GetMappingsRequest mappingsRequest = new GetMappingsRequest().types(tableDescription.getType()); String index = tableDescription.getIndex(); if (!isNullOrEmpty(index)) { mappingsRequest.indices(index); } ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = client.admin().indices().getMappings(mappingsRequest).actionGet(timeout.toMillis()).getMappings(); Iterator<String> indexIterator = mappings.keysIt(); while (indexIterator.hasNext()) { MappingMetaData mappingMetaData = mappings.get(indexIterator.next()).get(tableDescription.getType()); JSONObject mappingObject = new JSONObject(mappingMetaData.source().toString()).getJSONObject(tableDescription.getType()); JSONObject properties = mappingObject.getJSONObject(\"properties\"); List<String> lists = new ArrayList<String>(); if (properties.has(\"_meta\")) { JSONObject meta = mappingObject.getJSONObject(\"_meta\"); if (meta.has(\"lists\")) { JSONArray arrays = meta.getJSONArray(\"lists\"); for (int i = 0; i < arrays.length(); i++) { lists.add(arrays.getString(i)); } } } for (String columnMetadata : getColumnsMetadata(null, properties)) { Optional<ElasticsearchColumn> column = createColumn(columnMetadata, lists); if (!column.isPresent()) { continue; } if (columns.stream().noneMatch(col -> col.getName().equals(column.get().getName()))) { columns.add(column.get()); } } } columns.add(createColumn(\"_id.type:string\", ImmutableList.of()).get()); columns.add(createColumn(\"_index.type:string\", ImmutableList.of()).get()); tableDescription.setColumns(ImmutableList.copyOf(columns)); tableDescription.setColumnsMetadata(columns.stream().map(ElasticsearchColumnMetadata::new).collect(Collectors.toList())); } catch (JSONException e) { throw new PrestoException(ELASTIC_SEARCH_MAPPING_REQUEST_ERROR, e); } }", "output": "verify(client != null, \"client cannot be null\");"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static SecretKeyEncryptionStrategy instantiateSecreteKeyEncryptionStrategy(String className) { log.debug(\"About to instantiate secret key encryption strategy {}\", className); SecretKeyEncryptionStrategy strategy = null; Class keyEncryptionStrategyClazz = null; try { keyEncryptionStrategyClazz = AccumuloVFSClassLoader.loadClass(className); } catch (ClassNotFoundException e1) { throw new RuntimeException(\"Could not find configured secret key encryption strategy: \" + className); } Class[] interfaces = keyEncryptionStrategyClazz.getInterfaces(); boolean implementsSecretKeyStrategy = false; for (Class clazz : interfaces) { if (clazz.equals(SecretKeyEncryptionStrategy.class)) { implementsSecretKeyStrategy = true; break; } } if (!implementsSecretKeyStrategy) { throw new RuntimeException(\"Configured Accumulo secret key encryption strategy \\\"%s\\\" does not implement the SecretKeyEncryptionStrategy interface.\"); } else { try { strategy = (SecretKeyEncryptionStrategy) keyEncryptionStrategyClazz.newInstance(); log.debug(\"Successfully instantiated secret key encryption strategy {}\", className); } catch (InstantiationException e) { throw new RuntimeException(\"Got instantiation exception {} when instantiating secret key encryption strategy \" + className); } catch (IllegalAccessException e) { throw new RuntimeException(\"Got illegal access exception when trying to instantiate secret key encryption strategy \" + className); } } return strategy; }", "output": "Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void removeAllChangeListeners() { realm.checkIfValid(); realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE); collection.removeAllListeners(); }", "output": "Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), buildPayload(4 * MiB))).isEqualTo(HashCode.fromString(TREEHASH)); RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), \"PUT /-/vaults/\" + VAULT_NAME + \"/multipart-uploads/\" + MULTIPART_UPLOAD_ID + \" \" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), \"bytes 0-4194303/*\"); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), \"4194304\"); }", "output": "Should TREEHASH be a HashCode?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String render(final ListAllMyBucketsResult obj) throws JsonProcessingException { if (obj == null) { return \"You do not have any buckets\"; } ObjectMapper mapper = new ObjectMapper(); return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); }", "output": "final"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void doMerge(Mapper mergeWith, boolean updateAllTypes) { super.doMerge(mergeWith, updateAllTypes); var mw = ((KeywordFieldMapper) mergeWith); this.ignoreAbove = ((KeywordFieldMapper) mergeWith).ignoreAbove; if (!Objects.equals(this.lengthLimit, mw.lengthLimit)) { throw new IllegalArgumentException( \"mapper [\" + name() + \"] has different length_limit settings, current [\" + this.fieldType().lengthLimit + \"], merged [\" + mw.fieldType().lengthLimit + \"]\"); } }", "output": "suggestion this.ignoreAbove = mw.ignoreAbove;"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void storeReleasedTime(AndroidCommCarePlatform platform, Reference ref) { long releasedOnTime = -1; if (ref instanceof JavaHttpReference) { Headers responseHeaders = ((JavaHttpReference)ref).getResponseHeaders(); if (responseHeaders != null) { String releasedOnStr = responseHeaders.get(HEADER_APP_RELEASED_ON); try { if (releasedOnStr != null) { releasedOnTime = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\").parse(releasedOnStr).getTime(); } } catch (ParseException e) { e.printStackTrace(); } } } if (releasedOnTime == -1) { releasedOnTime = new Date().getTime(); } HiddenPreferences.setReleasedOnTimeForOngoingAppDownload(platform, releasedOnTime); }", "output": "I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void centerOnNode(DataNode node) throws NodeNotFoundException { double x = -1; for (WrapperClone wrapperClone : graphData) { if (wrapperClone.getDataNodes().contains(node)) { x = wrapperClone.getX(); break; } } if (x != -1) { setZoomCenter(x); } else { throw new NodeNotFoundException(); } }", "output": "Wrapper#getX() : float Use float instead of double."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public SourceRecord extractRecord() throws SQLException { Struct record = new Struct(schemaMapping.schema()); for (FieldSetter setter : schemaMapping.fieldSetters()) { try { setter.setField(record, resultSet); } catch (IOException e) { log.warn(\"Ignoring record because processing failed:\", e); } catch (SQLException e) { log.warn(\"Ignoring record due to SQL error:\", e); } } offset = criteria.extractValues(schemaMapping.schema(), record, offset); final String topic; final Map<String, String> partition; switch (mode) { case TABLE: if (useFqn) { String fqn = ExpressionBuilder.create().append(tableId, false).toString(); partition = new HashMap<>(); partition.put(JdbcSourceConnectorConstants.TABLE_NAME_KEY, fqn); partition.put(JdbcSourceConnectorConstants.OFFSET_PROTOCOL_VERSION, \"1\"); topic = topicPrefix + fqn; } else { String name = tableId.tableName(); partition = Collections.singletonMap(JdbcSourceConnectorConstants.TABLE_NAME_KEY, name); topic = topicPrefix + name; } break; case QUERY: partition = Collections.singletonMap(JdbcSourceConnectorConstants.QUERY_NAME_KEY, JdbcSourceConnectorConstants.QUERY_NAME_VALUE); topic = topicPrefix; break; default: throw new ConnectException(\"Unexpected query mode: \" + mode); } return new SourceRecord(partition, offset.toMap(), topic, record.schema(), record); }", "output": "Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void decodeValue(Klv klv) { byte[] bytes = klv.getValue(); CharsetDetector charsetDetector = new CharsetDetector(); charsetDetector.setText(bytes); CharsetMatch charsetMatch = charsetDetector.detect(); Charset charset = Charset.defaultCharset(); if (charsetMatch != null) { try { charset = Charset.forName(charsetMatch.getName()); } catch (IllegalArgumentException e) { LOGGER.trace( \"Unsupported encoding of %s, falling back to default encoding\", charsetMatch.getName()); } } value = new String(bytes, charset); }", "output": ":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private AzureBlobStorageImpl constructImpl() { Objects.requireNonNull(blobName, \"'blobName' cannot be null.\"); if (Objects.isNull(containerName) || containerName.isEmpty()) { containerName = BlobContainerAsyncClient.ROOT_CONTAINER_NAME; } checkValidEncryptionParameters(); HttpPipeline pipeline = super.getPipeline(); if (pipeline == null) { pipeline = buildPipeline(); } return new AzureBlobStorageBuilder() .url(String.format(\"%s/%s/%s\", endpoint, containerName, blobName)) .pipeline(pipeline) .build(); }", "output": "ImplUtils has a isNullOrEmpty method that should handle these checks."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testLongFileNameThatDoesNotRequireEncoding() { String str = StringUtils.repeat(\"1\", 256); assertEquals( \"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.71634944\", fileManager.getFileName(TaskTestUtil.createMockTask(str), true)); }", "output": "Could you use Strings.repeat or something?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean applyCSSProperty(Object element, String property, CSSValue value, String pseudo, CSSEngine engine) throws Exception { if (!(element instanceof ISelectionBackgroundCustomizationElement && element instanceof ElementAdapter) || !(((ElementAdapter) element).getNativeWidget() instanceof Widget) || property == null || value.getCssValueType() != CSSValue.CSS_PRIMITIVE_VALUE) { return false; } Widget widget = (Widget) ((ElementAdapter) element).getNativeWidget(); ISelectionBackgroundCustomizationElement treeElement = (ISelectionBackgroundCustomizationElement) element; Color newColor = (Color) engine.convert(value, Color.class, widget.getDisplay()); switch (property.toLowerCase()) { case SWT_SELECTION_FOREGROUND_COLOR: treeElement.setSelectionForegroundColor(newColor); break; case SWT_SELECTION_BACKGROUND_COLOR: treeElement.setSelectionBackgroundColor(newColor); break; case SWT_SELECTION_BORDER_COLOR: treeElement.setSelectionBorderColor(newColor); break; case SWT_HOT_BACKGROUND_COLOR: treeElement.setHotBackgroundColor(newColor); break; case SWT_HOT_BORDER_COLOR: treeElement.setHotBorderColor(newColor); break; } return true; }", "output": "the original code does not make toLowerCase(). Why did you add it?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Optional<Guid> getUserIdIfExternal() { return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId()); }", "output": "this can be reduced to protected."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected DatabaseName unmarshal0( ReadableChannel channel ) throws IOException { byte nullMarker = channel.get(); if ( nullMarker == 0 ) { return null; } else { int nameLength = (int) channel.get(); byte[] nameBytes = new byte[nameLength]; channel.get( nameBytes, nameLength ); return new DatabaseName( UTF8.decode( nameBytes ) ); } }", "output": "We have a StringMarshal helper class that does all of this UTF8 logic for a string."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected <C, R> void doDispatch(CommandMessage<C> command, CommandCallback<? super C, R> callback) { MessageMonitor.MonitorCallback monitorCallback = messageMonitor.onMessageIngested(command); MessageHandler<? super CommandMessage<?>> handler = findCommandHandlerFor(command).orElseThrow(() -> { NoHandlerForCommandException exception = new NoHandlerForCommandException( format(\"No handler was subscribed to command [%s]\", command.getCommandName())); monitorCallback.reportFailure(exception); return exception; }); try { Object result = doDispatch(command, handler); monitorCallback.reportSuccess(); callback.onSuccess(command, (R) result); } catch (Exception throwable) { monitorCallback.reportFailure(throwable); callback.onFailure(command, throwable); } }", "output": "Shouldn't it be No handler was subscribed **for** command?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void processNewResponses() throws InterruptedException, IOException { SocketServerResponse curr = (SocketServerResponse) channel.receiveResponse(id); while (curr != null) { curr.onDequeueFromResponseQueue(); SocketServerRequest request = (SocketServerRequest) curr.getRequest(); String connectionId = request.getConnectionId(); try { if (curr.getPayload() == null) { logger.trace(\"Socket server received no response and hence closing the connection\"); selector.close(connectionId); } else { logger.trace(\"Socket server received response to send, registering for write: {}\", curr); NetworkSend networkSend = new NetworkSend(connectionId, curr.getPayload(), curr.getMetrics(), time); selector.send(networkSend); } } catch (IllegalStateException e) { logger .error(\"Attempt to write to socket for which there is no open connection. Connection id {}\", connectionId); } finally { curr = (SocketServerResponse) channel.receiveResponse(id); } } }", "output": "This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static boolean postHasEdits(@Nullable PostImmutableModel oldPost, PostImmutableModel newPost) { if (oldPost == null) { return newPost != null; } return newPost == null || !(StringUtils.equals(oldPost.getTitle(), newPost.getTitle()) && StringUtils.equals(oldPost.getContent(), newPost.getContent()) && StringUtils.equals(oldPost.getExcerpt(), newPost.getExcerpt()) && StringUtils.equals(oldPost.getStatus(), newPost.getStatus()) && StringUtils.equals(oldPost.getPassword(), newPost.getPassword()) && StringUtils.equals(oldPost.getPostFormat(), newPost.getPostFormat()) && StringUtils.equals(oldPost.getDateCreated(), newPost.getDateCreated()) && StringUtils.equals(oldPost.getSlug(), newPost.getSlug()) && oldPost.getFeaturedImageId() == newPost.getFeaturedImageId() && oldPost.getTagNameList().containsAll(newPost.getTagNameList()) && newPost.getTagNameList().containsAll(oldPost.getTagNameList()) && oldPost.getCategoryIdList().containsAll(newPost.getCategoryIdList()) && newPost.getCategoryIdList().containsAll(oldPost.getCategoryIdList()) && oldPost.getLocation().equals(newPost.getLocation()) && oldPost.getChangesConfirmedContentHashcode() == newPost .getChangesConfirmedContentHashcode() ); }", "output": "Shouldn't we call PostLocation.companion.equals here?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void noConflictTable() throws Exception, UpdateException { long baseline = System.currentTimeMillis(); final DataBuilderProvider.DataBuilder builder = DataBuilderProvider .row(-1, true); for (int i = 0; i < 1000; i++) { builder .row(i, true); } final Object[][] end = builder.end(); long now = System.currentTimeMillis(); System.out.println(\"Loading of model took.. \" + (now - baseline) + \" ms\"); baseline = now; final GuidedDecisionTable52 table52 = analyzerProvider.makeAnalyser() .withPersonAgeColumn(\"==\") .withPersonApprovedActionSetField() .withData(end) .buildTable(); now = System.currentTimeMillis(); System.out.println(\"Made table.. \" + (now - baseline) + \" ms\"); baseline = now; final Analyzer analyzer = analyzerProvider.makeAnalyser(table52); now = System.currentTimeMillis(); System.out.println(\"Indexing.. \" + (now - baseline) + \" ms\"); baseline = now; analyzer.analyze(); now = System.currentTimeMillis(); System.out.println(\"Validated.. \" + (now - baseline) + \" ms\"); baseline = now; table52.getData() .get(1) .get(2) .setNumericValue(3); List<Coordinate> updates = new ArrayList<>(); updates.add(new Coordinate(1, 2)); analyzerProvider.getUpdateManager(table52, analyzer) .update(table52, updates); now = System.currentTimeMillis(); System.out.println(\"Update.. \" + (now - baseline) + \" ms\"); assertContains(REDUNDANT_ROWS, analyzerProvider.getAnalysisReport()); }", "output": "Please don't use sysout. Logging is your friend."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void makeDependences(Job job, Map<String, ArrayList<String>> dependencies) throws JobCreationException { if (dependencies != null && dependencies.size() > 0 && job.getType() == JobType.TASKSFLOW) { TaskFlowJob tfj = (TaskFlowJob) job; for (Task t : tfj.getTasks()) { ArrayList<String> names = dependencies.get(t.getName()); if (names != null) { for (String name : names) { if (tfj.getTask(name) == null) { throw new JobCreationException(\"Unknown dependence: \" + name); } else { t.addDependence(tfj.getTask(name)); } } } } } }", "output": "You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(\"Unknown dependence: \" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(\"Unknown dependence: \" + name));"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private SubPlan reassignPartitioningHandleIfNecessaryHelper(Session session, Metadata metadata, SubPlan subPlan, PartitioningHandle newOutputPartitioningHandle) { PlanFragment fragment = subPlan.getFragment(); PartitioningHandleReassigner partitioningHandleReassigner = new PartitioningHandleReassigner(fragment.getPartitioning(), metadata, session); PlanNode newRoot; if (fragment.getPartitioning().isSingleNode()) { newRoot = fragment.getRoot(); } else { newRoot = SimplePlanRewriter.rewriteWith(partitioningHandleReassigner, fragment.getRoot()); } PartitioningScheme outputPartitioningScheme = fragment.getPartitioningScheme(); Partitioning newOutputPartitioning = outputPartitioningScheme.getPartitioning(); if (outputPartitioningScheme.getPartitioning().getHandle().getConnectorId().isPresent()) { newOutputPartitioning = newOutputPartitioning.withAlternativePartitiongingHandle(newOutputPartitioningHandle); } PlanFragment newFragment = new PlanFragment( fragment.getId(), newRoot, fragment.getSymbols(), fragment.getPartitioning(), fragment.getPartitionedSources(), new PartitioningScheme( newOutputPartitioning, outputPartitioningScheme.getOutputLayout(), outputPartitioningScheme.getHashColumn(), outputPartitioningScheme.isReplicateNullsAndAny(), outputPartitioningScheme.getBucketToPartition()), fragment.getStageExecutionStrategy(), fragment.getStatsAndCosts()); ImmutableList.Builder<SubPlan> childrenBuilder = ImmutableList.builder(); for (SubPlan child : subPlan.getChildren()) { childrenBuilder.add(reassignPartitioningHandleIfNecessaryHelper(session, metadata, child, fragment.getPartitioning())); } return new SubPlan(newFragment, childrenBuilder.build()); }", "output": "Should the condition here and the condition on 153 the same?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void doPolling(Guid cmdId, List<Guid> childCmdIds) { RebootVmCommand<P> command = getCommand(cmdId); boolean anyFailed = false; for (Guid childCmdId : childCmdIds) { CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId); switch (entity.getCommandStatus()) { case FAILED: case FAILED_RESTARTED: case UNKNOWN: anyFailed = true; break; default: break; } } if (anyFailed) { command.setCommandStatus(CommandStatus.FAILED); } else { VM vm = DbFacade.getInstance().getVmDao().get(command.getParameters().getVmId()); if (isVmDownForColdReboot(vm)) { command.proceedWithColdRun(); } } }", "output": "what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky.."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void run() { if (!mServiceConnection.isBound()) { mServiceConnection.unBindService(mContext); mCallback.onError(new AuthenticationException(ADALError.BROKER_BIND_SERVICE_FAILED)); } }", "output": "It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context)."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public int hashCode() { return Objects.hash(machine, content); }", "output": "-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private Stream<Map<Address, InternalCacheEntry<K, V>>> getConflicts(LocalizedCacheTopology topology) { if (stateConsumer.isStateTransferInProgress()) throw log.getConflictsStateTransferInProgress(cacheName); if (!streamInProgress.compareAndSet(false, true)) throw log.getConflictsAlreadyInProgress(); try { return StreamSupport .stream(new ReplicaSpliterator(topology), false) .filter(filterConsistentEntries()); } finally { streamInProgress.compareAndSet(true, false); } }", "output": "isn't the topology always a LocalizedCacheTopology?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testMergeRunnersEnsureGroupMerging() throws Exception { GroupByQuery query = GroupByQuery .builder() .setDataSource(\"xx\") .setQuerySegmentSpec(new LegacySegmentSpec(\"1970/3000\")) .setGranularity(QueryGranularities.ALL) .setDimensions(Lists.<DimensionSpec>newArrayList(new DefaultDimensionSpec(\"tags\", \"tags\"))) .setAggregatorSpecs( Arrays.asList( new AggregatorFactory[] { new CountAggregatorFactory(\"count\") } ) ) .build(); final QueryRunnerFactory factory = GroupByQueryRunnerTest.makeQueryRunnerFactory(new GroupByQueryConfig()); QueryRunner mergedRunner = factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { return factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { try { return new MergeSequence( query.getResultOrdering(), Sequences.simple( Arrays.asList( factory.createRunner(createSegment()).run(query, responseContext), factory.createRunner(createSegment()).run(query, responseContext) ) ) ); } catch (Exception e) { Assert.fail(e.getMessage()); return null; } } } ).run(query, responseContext); } } ); Sequence<Row> result = mergedRunner.run(query, Maps.newHashMap()); List<Row> expectedResults = Arrays.asList( GroupByQueryRunnerTestHelper.createExpectedRow(\"1970-01-01T00:00:00.000Z\", \"tags\", \"t1\", \"count\", 2L), GroupByQueryRunnerTestHelper.createExpectedRow(\"1970-01-01T00:00:00.000Z\", \"tags\", \"t2\", \"count\", 4L) ); TestHelper.assertExpectedObjects(expectedResults, Sequences.toList(result, new ArrayList<Row>()), \"\"); }", "output": "Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public WTextAreaUI() { panel.add(messages); WFieldLayout fieldLayout = new WFieldLayout(LAYOUT_FLAT); fieldLayout.setTitle(\"this is a bunch of fields\"); WTextArea wTextField = new WTextArea(); fieldLayout.addField(\"this is a textarea\", wTextField); wTextField.setMandatory(true); panel.add(fieldLayout); add(createWButton()); add(panel); }", "output": "Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String toString() { StringBuilder result = new StringBuilder(\"[Test: \\\"\" + m_name + \"\\\"\").append(\" verbose:\").append(m_verbose); result.append(\"[parameters:\"); for (Map.Entry<String, String> entry : m_parameters.entrySet()) { result.append(entry.getKey()).append(\"=>\").append(entry.getValue()); } result.append(\"]\"); result.append(\"[metagroups:\"); for (Map.Entry<String, List<String>> entry : m_metaGroups.entrySet()) { result.append(entry.getKey()).append(\"=\"); for (String n : entry.getValue()) { result.append(n).append(\",\"); } } result.append(\"] \"); result.append(\"[included: \"); for (String g : m_includedGroups) { result.append(g).append(\" \"); } result.append(\"]\"); result.append(\"[excluded: \"); for (String g : m_excludedGroups) { result.append(g).append(\"\"); } result.append(\"] \"); result.append(\" classes:\"); for (XmlClass cl : m_xmlClasses) { result.append(cl).append(\" \"); } result.append(\" packages:\"); for (XmlPackage p : m_xmlPackages) { result.append(p).append(\" \"); } result.append(\"] \"); return result.toString(); }", "output": "You missed new StringBuilder().append(\"[Test: \\\"\").append(m_name).append(\"\\\"\")"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testRename() throws Exception { typeContext = new LabelClientTypeContext(store, LabelType.METRIC, metrics, eventBus, MAX_CACHE_SIZE); final LabelId labelId = typeContext.createId(\"oldName\").get(); ListenableFuture<Void> response = typeContext.rename(\"oldName\", \"newName\"); Futures.addCallback(response, new FutureCallback<Void>() { @Override public void onSuccess(final Void result) { Futures.addCallback(typeContext.getName(labelId), new FutureCallback<Optional<String>>() { @Override public void onSuccess(final Optional<String> result) { if (!result.isPresent()) { fail(); } assertEquals(\"newName\", result.get()); } @Override public void onFailure(final Throwable throwable) { fail(); } }); } @Override public void onFailure(final Throwable throwable) { fail(); } }); }", "output": "See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void setLibraryAliasGenerator(NameGenerator<Library> generator) { this.libraryAliasGenerator = (DefaultLibraryAliasGenerator) generator; }", "output": "Remove cast"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Set<Field> getFields() { return fields.keySet(); }", "output": "What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void deleteLog() { CommandContext commandContext = new CommandContext(); commandContext.setData(\"SingleRun\", \"true\"); commandContext.setData(\"OlderThan\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); synchronized (this) { jobServicesClient.scheduleRequest(CONTAINER_ID, JobRequestInstance.builder().command(\"org.jbpm.executor.commands.LogCleanupCommand\").build()); } }", "output": "This commandContext seems unused."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private ContextMenuHandler showContextMenu() { if (contextMenuHandler == null) { contextMenuHandler = event -> { event.preventDefault(); event.stopPropagation(); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().show(); }; } return contextMenuHandler; }", "output": "Twice the same call."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected Control renderControl(SWTGridCell cell, Composite parent) throws NoRendererFoundException, NoPropertyDescriptorFoundExeption { final CTabFolder folder = new CTabFolder(parent, SWT.BOTTOM); folder.setBackground(parent.getBackground()); final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); final AdapterFactoryItemDelegator adapterFactoryItemDelegator = new AdapterFactoryItemDelegator( composedAdapterFactory); final EList<VAbstractCategorization> categorizations = getCategorizations(); for (final VAbstractCategorization categorization : categorizations) { final CTabItem item = new CTabItem(folder, SWT.NULL); final IItemPropertyDescriptor itemPropertyDescriptor = adapterFactoryItemDelegator.getPropertyDescriptor( categorization, VViewPackage.eINSTANCE.getElement_Name()); String categorizationName; if (itemPropertyDescriptor == null) { categorizationName = \"Categorization\"; } else { final PropertyValueWrapper valueWrapper = (PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization); if (valueWrapper == null) { categorizationName = itemPropertyDescriptor.getDisplayName(categorization); } else { categorizationName = (String) ((PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization)).getEditableValue(categorization); } } item.setText(categorizationName); final AbstractSWTRenderer<VElement> renderer = getSWTRendererFactory().getRenderer(categorization, getViewModelContext()); final SWTGridDescription gridDescription = renderer.getGridDescription(GridDescriptionFactory.INSTANCE .createEmptyGridDescription()); for (final SWTGridCell gridCell : gridDescription.getGrid()) { final Control render = renderer.render(gridCell, folder); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.FILL).grab(true, true) .applyTo(render); item.setControl(render); } } composedAdapterFactory.dispose(); if (folder.getItemCount() > 0) { folder.setSelection(0); } return folder; }", "output": "what is a PropertyValueWrapper? Why do you need it?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static void copy(File source, File dest) throws IOException { try (InputStream in = new FileInputStream(source)) { try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } } }", "output": "consider replacing 96-97 with just one try block (see line 455)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean includeMethod( IMethodSelectorContext context, ITestNGMethod tm, boolean isTestMethod) { if (!m_isInitialized) { m_isInitialized = true; init(context); } if (script != null) { return getScriptSelector(script.getLanguage()).includeMethodFromExpression(script.getExpression(), tm); } return includeMethodFromIncludeExclude(tm, isTestMethod); }", "output": "So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String getUpload() { Desktop desktop = getDesktop(); String upload = _auxinf != null ? _auxinf.upload : null; if (desktop != null && !Strings.isEmpty(upload) && !upload.contains(\"maxsize=\")) upload = upload.concat(\",maxsize=\" + desktop.getWebApp().getConfiguration().getMaxUploadSize()); return upload; }", "output": "not good to add sth when calling getter"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testSendCloseSession() throws Exception { assertTrue(\"Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!\", serverFactory instanceof NettyServerCnxnFactory); try (ZooKeeper zk = createClient()) { final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer(); final String path = \"/a\"; zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); assertNotNull(\"Didn't create znode:\" + path, zk.exists(path, true)); assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount()); Iterable<ServerCnxn> connections = serverFactory.getConnections(); assertEquals(\"Mismatch in number of live connections!\", 1, serverFactory.getNumAliveConnections()); for (ServerCnxn serverCnxn : connections) { serverCnxn.sendCloseSession(); } LOG.info(\"Waiting for the channel disconnected event\"); int timeout = 0; while (serverFactory.getNumAliveConnections() != 0) { Thread.sleep(1000); timeout += 1000; if (timeout > CONNECTION_TIMEOUT) { fail(\"The number of live connections should be 0\"); } } assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount()); } }", "output": "Please don't do unrelated refactor work next time"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static SentryStackTraceElement[] fromStackTraceElements(StackTraceElement[] stackTraceElements) { Frame[] localsCache = LocalsCache.getCache(); SentryStackTraceElement[] sentryStackTraceElements = new SentryStackTraceElement[stackTraceElements.length]; boolean mayHaveLocals = localsCache.length == stackTraceElements.length; for (int i = 0; i < stackTraceElements.length; i++) { Map<String, Object> vars = null; if (mayHaveLocals) { Frame frame = localsCache[i]; Frame.LocalVariable[] frameLocals = frame.getLocals(); if (frameLocals != null && frameLocals.length > 0) { for (Frame.LocalVariable localVariable : frameLocals) { if (localVariable != null) { if (vars == null) { vars = new HashMap<>(); } vars.put(localVariable.getName(), localVariable.getValue()); } } } } sentryStackTraceElements[i] = fromStackTraceElement(stackTraceElements[i], vars); } return sentryStackTraceElements; }", "output": "This check seems a little fragile at first glance (not sure why.)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void runBeforeAllTests() { conceptService = Context.getConceptService(); executeDataSet(STANDARD_TEST_DATASET_XML); }", "output": "Isn't this dataset automatically executed?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static void setParamsWithRegistrationConfigurationMappings(RegistrationConfiguration registrationConfiguration, ImportFromConfParameters params) { if (registrationConfiguration.getAffinityGroupMappings() != null && registrationConfiguration.isSetAffinityGroupMappings()) { Map<String, Object> affinityGroupMap = new HashMap<>(); affinityGroupMap.put(AFFINITY_GROUP_KEY, mapAffinityGroupMapping(registrationConfiguration.getAffinityGroupMappings())); params.setAffinityGroupMap(affinityGroupMap); } if (registrationConfiguration.getAffinityLabelMappings() != null && registrationConfiguration.isSetAffinityLabelMappings()) { Map<String, Object> affinityLabelMap = new HashMap<>(); affinityLabelMap.put(AFFINITY_LABEL_KEY, mapAffinityLabelMapping(registrationConfiguration.getAffinityLabelMappings())); params.setAffinityLabelMap(affinityLabelMap); } if (registrationConfiguration.getClusterMappings() != null && registrationConfiguration.isSetClusterMappings()) { Map<String, Object> clusterMap = new HashMap<>(); clusterMap.put(CLUSTER_KEY, mapClusterMapping(registrationConfiguration.getClusterMappings())); params.setClusterMap(clusterMap); } if (registrationConfiguration.getLunMapping() != null && registrationConfiguration.isSetLunMapping()) { Map<String, Object> lunMap = new HashMap<>(); lunMap.put(EXTERNAL_LUN_KEY, mapExternalLunMapping(registrationConfiguration.getLunMapping())); params.setExternalLunMap(lunMap); } if (registrationConfiguration.getRoleMappings() != null && registrationConfiguration.isSetRoleMappings()) { Map<String, Object> roleMap = new HashMap<>(); roleMap.put(ROLE_KEY, mapExternalRoleMapping(registrationConfiguration.getRoleMappings())); params.setRoleMap(roleMap); } if (registrationConfiguration.getDomainMappings() != null && registrationConfiguration.isSetDomainMappings()) { Map<String, Object> domainMap = new HashMap<>(); domainMap.put(DOMAIN_KEY, mapExternalDomainMapping(registrationConfiguration.getDomainMappings())); params.setDomainMap(domainMap); } }", "output": "If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to \"params.setAffinityGroupMap\" directly the result of \"mapAffinityGroupMapping\": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void fillDriverSpecificChannelConfiguration(final Tocd mainOcd, final List<Tad> driverSpecificChannelConfiguration) { final ChannelDescriptor basicChanneldescriptor = new BaseChannelDescriptor(); final Object baseChannelDescriptor = basicChanneldescriptor.getDescriptor(); if (nonNull(baseChannelDescriptor) && baseChannelDescriptor instanceof List<?>) { List<Tad> channelConfiguration = (List<Tad>) baseChannelDescriptor; channelConfiguration.addAll(driverSpecificChannelConfiguration); for (final Tad attribute : channelConfiguration) { final Set<String> channelPrefixes = retrieveChannelPrefixes(this.assetConfiguration.getAssetChannels()); for (final String prefix : channelPrefixes) { final Tad newAttribute = cloneAd(attribute, prefix); mainOcd.addAD(newAttribute); } } } }", "output": "Add invariants"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected ACTION getUserAction(Cluster cluster, Path buildPath) throws FalconException { ACTION action = unmarshalAction(ACTION_TEMPLATE); JAXBElement<org.apache.falcon.oozie.spark.ACTION> actionJaxbElement = OozieUtils.unMarshalSparkAction(action); org.apache.falcon.oozie.spark.ACTION sparkAction = actionJaxbElement.getValue(); String sparkMasterURL = entity.getSparkAttributes().getMaster(); Path sparkJarFilePath = new Path(entity.getSparkAttributes().getJar()); String sparkJobName = entity.getSparkAttributes().getName(); String sparkOpts = entity.getSparkAttributes().getSparkOpts(); String sparkClassName = entity.getSparkAttributes().getClazz(); String clusterEntitySparkMasterURL = getClusterEntitySparkMaster(cluster); sparkMasterURL = (sparkMasterURL == null) ? clusterEntitySparkMasterURL : sparkMasterURL; if (StringUtils.isBlank(sparkMasterURL)) { throw new FalconException(\"Spark Master URL can'be empty\"); } sparkAction.setMaster(sparkMasterURL); sparkAction.setName(sparkJobName); addPrepareDeleteOutputPath(sparkAction); if (StringUtils.isNotEmpty(sparkOpts)) { sparkAction.setSparkOpts(sparkOpts); } if (StringUtils.isNotEmpty(sparkClassName)) { sparkAction.setClazz(sparkClassName); } List<String> argList = sparkAction.getArg(); List<String> sparkArgs = entity.getSparkAttributes().getArgs(); if (sparkArgs != null) { argList.addAll(sparkArgs); } addOutputFeedsAsArgument(argList, cluster); addInputFeedsAsArgument(argList, cluster); validateSparkJarFilePath(sparkJarFilePath); sparkAction.setJar(getSparkJarFileName(sparkJarFilePath)); setSparkLibFileToWorkflowLib(sparkJarFilePath, entity); propagateEntityProperties(sparkAction); OozieUtils.marshalSparkAction(action, actionJaxbElement); return action; }", "output": "just pass sparkJarFilePath.toString less number of changes will be required in the code."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ArrayList<Pojo> getResults(String query) { ArrayList<Pojo> pojos = new ArrayList<>(); if (android.os.Build.VERSION.SDK_INT >= 11) { Set<String> selectedProviders = new TreeSet<>(); selectedProviders.addAll(PreferenceManager.getDefaultSharedPreferences(this).getStringSet(\"search-providers\", new HashSet<>(Arrays.asList(\"Google\")))); for (String searchProvider : selectedProviders) { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.url = searchProviderUrls.get(searchProvider); pojo.name = searchProvider; pojos.add(pojo); } } else { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.name=\"Google\"; pojo.url = searchProviderUrls.get(\"Google\"); pojos.add(pojo); } Pattern p = Pattern.compile(URL_REGEX); Matcher m = p.matcher(query); if(m.find()) { String guessedUrl = URLUtil.guessUrl(query).toString(); if(URLUtil.isValidUrl (guessedUrl)) { SearchPojo pojo = new SearchPojo(); pojo.query = \"\"; pojo.relevance = 50; pojo.name = guessedUrl; pojo.url = guessedUrl; pojo.direct = true; pojos.add(pojo); } } return pojos; }", "output": "Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public AutoRegisterModules discover() throws InvalidPluginException { sysSingletons = Sets.newHashSet(); sysListen = LinkedListMultimap.create(); if (sshGen != null) { sshGen.setPluginName(pluginName); } if (httpGen != null) { httpGen.setPluginName(pluginName); } scan(); if (!sysSingletons.isEmpty() || !sysListen.isEmpty()) { sysModule = makeSystemModule(); } if (sshGen != null) { sshModule = sshGen.create(); } if (httpGen != null) { httpModule = httpGen.create(); } return this; }", "output": "The same."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public <K, V> MessageStream<KV<K, V>> partitionBy(Function<? super M, ? extends K> keyExtractor, Function<? super M, ? extends V> valueExtractor, KVSerde<K, V> serde) { int opId = this.graph.getNextOpId(); String opName = String.format(\"%s-%s\", OperatorSpec.OpCode.PARTITION_BY.name().toLowerCase(), opId); IntermediateMessageStreamImpl<KV<K, V>> intermediateStream = this.graph.getIntermediateStream(opName, serde); PartitionByOperatorSpec<M, K, V> partitionByOperatorSpec = OperatorSpecs.createRepartitionOperatorSpec( intermediateStream.getOutputStream(), keyExtractor, valueExtractor, opId); this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return intermediateStream; }", "output": "The phrase \"repartition\" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public RealmIdentity getRealmIdentity(final Principal principal) throws RealmUnavailableException { boolean ok = false; final RealmIdentity authenticationIdentity = authenticationRealm.getRealmIdentity(principal); Principal authorizationPrincipal = principal; if(principalTransformer != null) { authorizationPrincipal = principalTransformer.apply(authorizationPrincipal); if (authorizationPrincipal == null) return null; } final RealmIdentity[] authorizationIdentities = new RealmIdentity[authorizationRealms.length]; try { for (int i = 0; i < authorizationIdentities.length; i++) { SecurityRealm authorizationRealm = authorizationRealms[i]; authorizationIdentities[i] = authorizationRealm == authenticationRealm && principalTransformer == null ? authenticationIdentity : authorizationRealm.getRealmIdentity(authorizationPrincipal); } final Identity identity = new Identity(authenticationIdentity, authorizationIdentities); ok = true; return identity; } finally { if (!ok) { authenticationIdentity.dispose(); for (RealmIdentity current : authorizationIdentities) { if (current != null) current.dispose(); } } } }", "output": "Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected void doStart() throws Exception { super.doStart(); if (!Files.exists(baseDirectory)) { if (getEndpoint().isAutoCreate()) { baseDirectory = Files.createDirectories(baseDirectory); } else { throw new RuntimeCamelException(\"Path must exists when autoCreate = false\"); } } if (!Files.isDirectory(baseDirectory)) { throw new RuntimeCamelException(String.format(\"Parameter path must be directory, %s given\", baseDirectory.toString())); } DirectoryWatcher.Builder watcherBuilder = DirectoryWatcher.builder() .path(this.baseDirectory) .logger(log) .listener(new FileWatchDirectoryChangeListener()); if (!System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) { watcherBuilder.watchService(this.baseDirectory.getFileSystem().newWatchService()); } watcherBuilder.fileHashing(getEndpoint().isUseFileHashing()); if (getEndpoint().getFileHasher() != null && getEndpoint().isUseFileHashing()) { watcherBuilder.fileHasher(getEndpoint().getFileHasher()); } this.watcher = watcherBuilder.build(); watchDirExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, \"CamelFileWatchService\", getEndpoint().getPollThreads()); pollExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, \"CamelFileWatchPoll\", getEndpoint().getConcurrentConsumers()); for (int i = 0; i < getEndpoint().getPollThreads(); i++) { this.watcher.watchAsync(watchDirExecutorService); } for (int i = 0; i < getEndpoint().getConcurrentConsumers(); i++) { pollExecutorService.submit(new PollRunnable()); } }", "output": "We tend to use IllegalArgumentException for these kind"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public String getDescription() { return Localization.lang( \"Removes all {} brackets around words.\"); }", "output": "add \"balanced\" ?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException { ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile()); if (useSsl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, \"true\"); } if (useSasl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, \"true\"); } if (getZooKeeperInstance().size() > 0) { List<String> zkOpts = getZooKeeperInstance(); String instanceName = zkOpts.get(0); String hosts = zkOpts.get(1); clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, hosts); clientConfig.setProperty(ClientProperty.INSTANCE_NAME, instanceName); } if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) { AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig)); clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST)); } if (null != zooKeeperHosts) { clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts); } return clientConfig; }", "output": "Conditional is more clear as: !getZooKeeperInstance().isEmpty()"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void recordLatency(Response<? extends Request> response, String operation) { Serializable start = response.getRequest().getPropertyValue(METRICS_OPERATION_START); long latency = calculateLatency((Long) start); if (latency > 0) { DistributionSummary.builder(metricName(METRIC_PREFIX, operation, \"latency\")) .baseUnit(\"milliseconds\") .tags(\"successful\", Boolean.toString(response.getProcessingErrors().isEmpty())) .publishPercentiles(0.5, 0.95) .register(Metrics.globalRegistry) .record(latency); } }", "output": "If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(\"Computed a suspicious latency of {} for {}\", latency, operation); return; } DistributionSummary.builder(...)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Object execute(ExecutionEvent event) throws ExecutionException { final Repository repo = getRepository(true, event); IResource[] resources = getSelectedResources(event); if (repo == null) return null; CommitSelectionDialog dlg = new CommitSelectionDialog(getShell(event), repo, resources); if (dlg.open() != Window.OK) return null; if (resources.length == 1 && resources[0] instanceof IFile) { final IFile baseFile = (IFile) resources[0]; final ITypedElement base = SaveableCompareEditorInput .createFileElement(baseFile); final ITypedElement next; ITypedElement ancestor = null; RevCommit commonAncestor = null; try { RepositoryMapping mapping = RepositoryMapping .getMapping(resources[0]); next = getElementForCommit(mapping.getRepository(), mapping .getRepoRelativePath(baseFile), dlg.getCommitId()); commonAncestor = RevUtils.getCommonAncestor(repo, repo.resolve(Constants.HEAD), dlg.getCommitId()); if (commonAncestor != null) ancestor = CompareUtils.getFileRevisionTypedElement( mapping .getRepoRelativePath(baseFile), commonAncestor, mapping.getRepository()); } catch (IOException e) { Activator.handleError( UIText.CompareWithIndexAction_errorOnAddToIndex, e, true); return null; } final GitCompareFileRevisionEditorInput in = new GitCompareFileRevisionEditorInput( base, next, ancestor, null); in.getCompareConfiguration() .setRightLabel(dlg.getCommitId().name()); if (commonAncestor != null) in.getCompareConfiguration() .setAncestorLabel(commonAncestor.name()); CompareUI.openCompareEditor(in); } else { CompareTreeView view; try { view = (CompareTreeView) PlatformUI.getWorkbench() .getActiveWorkbenchWindow().getActivePage().showView( CompareTreeView.ID); view.setInput(resources, dlg.getCommitId().name()); } catch (PartInitException e) { Activator.handleError(e.getMessage(), e, true); } } return null; }", "output": "This seems to be unnecessary. I also get the label after removing this."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( \"org.Address\", new ModelField[]{ new ModelField( \"this\", \"org.Address\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, \"this\" ), new ModelField( \"street\", \"String\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( \"homeAddress\", \"Boolean\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( \"number\", \"java.lang.Integer\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }", "output": "@jomarko Thanks.. I'd have made this Integer.class.getName() too"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private boolean processRow(String line) { List<String> values = ImmutableList.copyOf(ON_COMMA.split(line)); if (Iterables.size(values) < 8) { return true; } BbcGenreTree.Builder genreTree = BbcGenreTree.builder(genresPrefix + values.get(0)); if (!Strings.isNullOrEmpty(values.get(1))) { genreTree.withSecondLevelGenre(genresPrefix + stripQuotationMarks(values.get(1))); } if (!Strings.isNullOrEmpty(values.get(2))) { genreTree.withThirdLevelGenre(genresPrefix + stripQuotationMarks(values.get(2))); } mapping.put(genreTree.build(), parseYouViewGenres(Iterables.skip(values, 4))); return true; }", "output": "Log/throw?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static String doGetFeatureUrl(String srs, JSONObject download, boolean addNameSpace) throws JSONException { String getFeatureUrl = \"\"; StringWriter s = new StringWriter(); s.append(PropertyUtil.get(\"download.basket.wfs.service.url\")); if (addNameSpace) { s.append(\"?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName=\" + srs + \"&outputFormat=SHAPE-ZIP&typeNames=\" + download.getString(PARAM_LAYER)); } else { s.append(\"?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName=\" + srs + \"&outputFormat=SHAPE-ZIP&typeNames=\" + Helpers.getLayerNameWithoutNameSpace(download.getString(PARAM_LAYER))); } getFeatureUrl = s.toString(); return getFeatureUrl; }", "output": "StringBuilder instead of StringWriter would be more traditional choice, not that big of a deal though."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void init() throws DBException { _db.init(); this.reportLatencyForEachError = Boolean.parseBoolean(getProperties(). getProperty(\"reportlatencyforeacherror\", \"false\")); String latencyTrackedErrors = getProperties().getProperty( \"latencytrackederrors\", null); if (latencyTrackedErrors != null) { this.latencyTrackedErrors = new HashSet<String>(Arrays.asList( latencyTrackedErrors.split(\",\"))); } System.out.println(\"DBWrapper: report latency for each error is \" + this.reportLatencyForEachError + \" and specific error codes to track\" + \" for latency are: \" + this.latencyTrackedErrors.toString()); }", "output": "this should be on System.err"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ProductInfo createProduct(ProductInfo pinfo) { if (pinfo == null) { throw new IllegalArgumentException(\"pinfo is null\"); } if (StringUtils.isBlank(pinfo.getId())) { throw new IllegalArgumentException(\"product is lacking an identifier: \" + pinfo); } if (this.productMap.containsKey(pinfo.getId())) { throw new IllegalStateException(\"product already exists: \" + pinfo.getId()); } ProductData pdata = new ProductData(); pdata.setId(pinfo.getId()); pdata.setProductContent(this.resolveProductContent(pinfo.getProductContent())); pdata.setName(pinfo.getName()); pdata.setMultiplier(pinfo.getMultiplier()); pdata.setAttributes(pinfo.getAttributes()); pdata.setDependentProductIds(pinfo.getDependentProductIds()); pdata.setCreated(new Date()); pdata.setUpdated(new Date()); pdata.setBranding(this.resolveBranding(pinfo.getBranding())); pdata.setProvidedProducts(this.resolveProvidedProducts(pinfo.getProvidedProducts())); this.productMap.put(pdata.getId(), pdata); this.productSubscriptionMap.put(pdata.getId(), new HashSet<>()); this.updateProductContentMappings(pdata); return pdata; }", "output": "I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public PcapPacket(PcapFile file, @Nullable Packet parent, boolean isPcapNg, ByteBuffer header, @Nullable ByteBuffer payload, long index) throws BadPacketException { super(file, parent, PcapProtocol.PCAP); if (header.array().length < PcapFileValues.PACKET_HEADER_SIZE) { fChildPacket = null; throw new BadPacketException(\"The Pcap packet header is too small.\"); } fSourceEndpoint = null; fDestinationEndpoint = null; fFields = null; fPacketIndex = index; header.order(getPcapFile().getByteOrder()); header.position(0); if (isPcapNg) { header.getInt(); header.getInt(); header.getInt(); } long timestampMostSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); long timestampLeastSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); switch (getTimestampScale()) { case MICROSECOND: if (timestampLeastSignificant > TIMESTAMP_MICROSECOND_MAX) { fChildPacket = null; throw new BadPacketException(\"The timestamp is erroneous.\"); } fTimestamp = TIMESTAMP_MICROSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; case NANOSECOND: if (timestampLeastSignificant > TIMESTAMP_NANOSECOND_MAX) { fChildPacket = null; throw new BadPacketException(\"The timestamp is erroneous.\"); } fTimestamp = TIMESTAMP_NANOSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; default: throw new IllegalArgumentException(\"The timestamp precision is not valid!\"); } fIncludedLength = ConversionHelper.unsignedIntToLong(header.getInt()); fOriginalLength = ConversionHelper.unsignedIntToLong(header.getInt()); final ByteBuffer pcapPacket = payload; if (pcapPacket == null) { fChildPacket = null; fPayload = null; return; } pcapPacket.order(ByteOrder.BIG_ENDIAN); pcapPacket.position(0); fPayload = pcapPacket; fChildPacket = findChildPacket(); }", "output": "read the values and validate"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); System.out.println(headers.get(name)); return headers.get(name); }", "output": "Need to remove this leftover debug output"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Boolean call() throws Exception { long sleepBackoff = 200L, maxSleep = 0L; do { final PoolEntry poolEntry = createPoolEntry(); if (poolEntry != null) { connectionBag.add(poolEntry); return Boolean.TRUE; } else if (poolEntry == MAXED_POOL_MARKER) { return Boolean.FALSE; } else if (maxSleep == sleepBackoff) { return Boolean.FALSE; } maxSleep = sleepBackoff; quietlySleep(sleepBackoff); sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3)); } while (true); }", "output": "How can this work? This is going to insert MAXED_POOL_MARKER into the bag."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void createFeatures(ArcGISMap map){ LayerList layers = map.getOperationalLayers(); for(Layer layer: layers){ FeatureLayer fLayer = (FeatureLayer) layer; if(fLayer.getName().contains(\"Alaska National Parks\")){ mOperationalLayers.add(fLayer); } } List<ArcGISFeatureTable> tables = map.getTables(); final ArcGISFeatureTable speciesFeatureTable = tables.get(0); speciesFeatureTable.addDoneLoadingListener(new Runnable() { @Override public void run() { Log.d(TAG, \"Found table: \" + speciesFeatureTable.getTableName()); } }); speciesFeatureTable.loadAsync(); }", "output": "No need to explicitly load tables with query if you are using the latest build"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) { if (clazz == null || json == null) { return; } for (int i = 0; i < json.length(); i++) { try { configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false); } catch (JSONException e) { throw new RealmException(\"Could not map Json\", e); } } }", "output": "Json -> \"JSON\" (do a search-n-replace)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected ClusterState execute(ClusterState currentState, AlterTableRequest request) throws Exception { Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.tableIdent().indexNameOrAlias()); if (request.isPartitioned()) { if (request.partitionIndexName() != null) { concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.partitionIndexName()); currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } else { currentState = updateTemplate(currentState, request); if (!request.excludePartitions()) { List<String> supportedSettings = TableParameters.PARTITIONED_TABLE_PARAMETER_INFO_FOR_TEMPLATE_UPDATE .supportedSettings() .values() .stream() .map(Setting::getKey) .collect(Collectors.toList()); supportedSettings.add(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS); TableParameter parameterWithFilteredSettings = new TableParameter(request.settings(), supportedSettings); currentState = updateSettings(currentState, parameterWithFilteredSettings.settings(), concreteIndices); currentState = updateMapping(currentState, request, concreteIndices); } } } else { currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } return currentState; }", "output": "Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject fDiffProject : fDiffProjects) { IProject tempProject = Utilities.getProject(fDiffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }", "output": "not a field"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static void fillReleasesTable(XWPFTable table, Collection<LicenseInfoParsingResult> projectLicenseInfoResults) { for (LicenseInfoParsingResult result : projectLicenseInfoResults) { String releaseName = nullToEmptyString(result.getName()); String version = nullToEmptyString(result.getVersion()); if (result.getStatus()== LicenseInfoRequestStatus.SUCCESS) { Set<String> copyrights = Collections.emptySet(); Set<LicenseNameWithText> licenseNamesWithTexts = Collections.emptySet(); Set<String> acknowledgements = Collections.emptySet(); if (result.isSetLicenseInfo()) { LicenseInfo licenseInfo = result.getLicenseInfo(); if (licenseInfo.isSetCopyrights()) { copyrights = licenseInfo.getCopyrights(); } if (licenseInfo.isSetLicenseNamesWithTexts()) { licenseNamesWithTexts = licenseInfo.getLicenseNamesWithTexts(); acknowledgements = licenseNamesWithTexts.stream() .map(LicenseNameWithText::getAcknowledgements) .filter(Objects::nonNull).collect(Collectors.toSet()); } } addReleaseTableRow(table, releaseName, version, licenseNamesWithTexts, acknowledgements, copyrights); } else { String filename = Optional.ofNullable(result.getLicenseInfo()) .map(LicenseInfo::getFilenames) .map(l -> l.stream().findFirst().orElse(null)) .orElse(\"\"); addReleaseTableErrorRow(table, releaseName, version, nullToEmptyString(result.getMessage()), filename); } } }", "output": "the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst())."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { throw new IllegalArgumentException( \"startTimeNanos should be greater than 0!\" ); } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = \"SlowQuery: \" + queryExecutionMillis + \" milliseconds. SQL: '\" + sql + \"'\"; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }", "output": "I would suggest providing more clue about the exception like  throw new IllegalArgumentException( \"startTimeNanos [\" + startTimeNanos + \"] should be greater than 0!\" );  to help debugger a little bit."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void bucketLoaded(AbstractBucket<Object> bucket) { try { super.bucketLoaded(bucket); logger.debug(\"Bucket {} loaded\", bucket.bucketKey); eventBucketExchanger.exchange(bucket.bucketKey, 1, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { logger.debug(\"Timeout happened\"); } catch (InterruptedException e) { e.printStackTrace(); } }", "output": "why swallowing?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ControllerFactory() { }", "output": "Why public?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void inputReady(NHttpServerConnection conn, ContentDecoder decoder) { try { ProtocolState protocolState = SourceContext.getState(conn); if (protocolState != ProtocolState.REQUEST_HEAD && protocolState != ProtocolState.REQUEST_BODY) { handleInvalidState(conn, \"Request message body data received\"); return; } log.info(\"point 1\"); SourceContext.updateState(conn, ProtocolState.REQUEST_BODY); SourceRequest request = SourceContext.getRequest(conn); int readBytes = request.read(conn, decoder); if (isMessageSizeValidationEnabled) { HttpContext httpContext = conn.getContext(); if (httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM) == null) { httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, 0); } int messageSizeSum = (int) httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM); messageSizeSum += readBytes; if (messageSizeSum > validMaxMessageSize) { log.warn(\"Payload exceeds valid payload size range, hence discontinuing chunk stream at \" + messageSizeSum + \" bytes to prevent OOM.\"); dropSourceConnection(conn); conn.getContext().setAttribute(PassThroughConstants.SOURCE_CONNECTION_DROPPED, true); request.getPipe().forceProducerComplete(decoder); } httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, messageSizeSum); } if (readBytes > 0) { metrics.incrementBytesReceived(readBytes); } } catch (IOException e) { logIOException(conn, e); informReaderError(conn); SourceContext.updateState(conn, ProtocolState.CLOSED); sourceConfiguration.getSourceConnections().shutDownConnection(conn, true); } }", "output": "remove this log"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private ColumnChunk readStruct(GroupField field) throws IOException { List<TypeSignatureParameter> fields = field.getType().getTypeSignature().getParameters(); Block[] blocks = new Block[fields.size()]; ColumnChunk columnChunk = null; List<Optional<Field>> parameters = field.getChildren(); for (int i = 0; i < fields.size(); i++) { Optional<Field> parameter = parameters.get(i); if (parameter.isPresent()) { columnChunk = readColumnChunk(parameter.get()); blocks[i] = columnChunk.getBlock(); } } for (int i = 0; i < fields.size(); i++) { if (blocks[i] == null) { blocks[i] = RunLengthEncodedBlock.create(field.getType(), null, columnChunk.getBlock().getPositionCount()); } } BooleanList structIsNull = ParquetStructColumnReader.calculateStructOffsets(field, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); Block rowBlock = RowBlock.fromFieldBlocks(structIsNull.toBooleanArray(), blocks, structIsNull.toBooleanArray().length); return new ColumnChunk(rowBlock, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); }", "output": "is double call to structIsNull.toBooleanArray() intentional?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void regenerateCertificatesImpl(Iterable<Entitlement> entitlements) { if (entitlements != null) { Set<String> deadCertIds = new HashSet<>(); for (Entitlement entitlement : entitlements) { Set<EntitlementCertificate> existing = entitlement.getCertificates(); try { entitlement.setCertificates(null); EntitlementCertificate generated = this.generateEntitlementCertificate( entitlement.getPool(), entitlement); entitlement.setDirty(false); this.eventSink.queueEvent(this.eventFactory.entitlementChanged(entitlement)); log.debug(\"Generated entitlementCertificate: #{}\", generated.getId()); if (existing != null) { for (EntitlementCertificate cert : existing) { if (cert != null) { deadCertIds.add(cert.getId()); this.entitlementCertificateCurator.evict(cert); } } } } catch (CertificateSizeException cse) { entitlement.setCertificates(existing); log.warn(\"The certificate cannot be regenerated at this time: {}\", cse.getMessage()); } } this.entitlementCurator.saveOrUpdateAll(entitlements, false, false); int count = this.entitlementCertificateCurator.deleteByIds(deadCertIds); log.debug(\"{} old entitlement certificates deleted\"); } }", "output": "suggestion log.debug(\"{} old entitlement certificates deleted\", count);"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean delete(final Identifier queryId) { if(queryStateMap.containsKey(queryId)) { queryStateMap.remove(queryId); return true; } else { return false; } }", "output": "replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean onOptionsItemSelected(MenuItem item) { Intent intent = null; switch (item.getItemId()) { case R.id.menu_load: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, \"No connection found, please connect your device and try again\", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, \"Already fetching forms, ignored the request\", Toast.LENGTH_SHORT).show(); return true; } if (hasFormsWithData()) { Toast.makeText(this, \"There is existing form data for selected form(s). Finish Incomplete data and sync Complete data to Server first before downloading selected forms\", Toast.LENGTH_SHORT).show(); return true; } syncAllFormsInBackgroundService(); return true; case R.id.menu_upload: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, \"No connection found, please connect your device and try again\", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, \"Already uploading forms, ignored the request\", Toast.LENGTH_SHORT).show(); return true; } uploadAllFormsInBackgroundService(); return true; case R.id.menu_client_add: intent = new Intent(this, RegistrationFormsActivity.class); startActivity(intent); return true; case R.id.menu_tags: if (mainLayout.isDrawerOpen(GravityCompat.END)) { mainLayout.closeDrawer(GravityCompat.END); } else { mainLayout.openDrawer(GravityCompat.END); } return true; default: return super.onOptionsItemSelected(item); } }", "output": "Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void handle(XFormParser p, Element e, Object parent) { String event = e.getAttributeValue(null, \"event\"); FormDef form = (FormDef) parent; PollSensorAction action; String ref = e.getAttributeValue(null, \"ref\"); if (ref != null) { IDataReference dataRef = new XPathReference(ref); if (dataRef != null) { dataRef = XFormParser.getAbsRef(dataRef, TreeReference.rootRef()); } TreeReference treeRef = FormInstance.unpackReference(dataRef); p.registerActionTarget(treeRef); action = new PollSensorAction(treeRef); } else { action = new PollSensorAction(); } form.registerEventListener(event, action); }", "output": "Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void setQuotaMode(QuotaMode mode) { logger.info(\"Setting Quota mode to \" + mode.name()); this.mode = mode; }", "output": "nit: try to avoid string concatenation in the log.  logger.info(\"Setting Quota mode to {}\", mode.name());"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static boolean isPreJava8() { final String version = System.getProperty(\"java.version\"); final String[] parts = version.split(\"\\\\.\"); try { int major = Integer.parseInt(parts[1]); final int token = Integer.parseInt(parts[0]); boolean isJEP223 = token != 1; if (isJEP223) { major = token; } return major < 8; } catch (final Exception ex) { return true; } }", "output": "Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public PagingProvider<ReconnectableConnection, ReconnectableConnection> pagedOperation(Integer failOn) { return new PagingProvider<ReconnectableConnection, ReconnectableConnection>() { Integer counter = 0; @Override public List<ReconnectableConnection> getPage(ReconnectableConnection connection) { counter++; if (counter == failOn) { throw new ModuleException(MuleErrors.CONNECTIVITY, new ConnectionException(\"Failed to retrieve Page\")); } return Collections.singletonList(connection); } @Override public Optional<Integer> getTotalResults(ReconnectableConnection connection) { return Optional.empty(); } @Override public void close(ReconnectableConnection connection) { } }; }", "output": "static import"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean writeMutexCell(String tenantId, String schemaName, String tableName, String columnName, String familyName) throws SQLException { try { byte[] rowKey = columnName != null ? SchemaUtil.getColumnKey(tenantId, schemaName, tableName, columnName, familyName) : SchemaUtil.getTableKey(tenantId, schemaName, tableName); byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); try (Table sysMutexTable = getTable(sysMutexPhysicalTableNameBytes)) { byte[] family = PhoenixDatabaseMetaData.SYSTEM_MUTEX_FAMILY_NAME_BYTES; byte[] qualifier = PhoenixDatabaseMetaData.SYSTEM_MUTEX_COLUMN_NAME_BYTES; byte[] value = MUTEX_LOCKED; Put put = new Put(rowKey); put.addColumn(family, qualifier, value); boolean checkAndPut = sysMutexTable.checkAndPut(rowKey, family, qualifier, null, put); String processName = ManagementFactory.getRuntimeMXBean().getName(); String msg = \" tenantId : \" + tenantId + \" schemaName : \" + schemaName + \" tableName : \" + tableName + \" columnName : \" + columnName + \" familyName : \" + familyName; if (!checkAndPut) { LOGGER.error(processName + \" failed to acquire mutex for \"+ msg); } else { LOGGER.debug(processName + \" acquired mutex for \"+ msg); } return checkAndPut; } } catch (IOException e) { throw ServerUtil.parseServerException(e); } }", "output": "byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public ReadableByteChannel get(PageId pageId, int pageOffset) throws IOException, PageNotFoundException { Path p = getFilePath(pageId); if (!Files.exists(p)) { throw new PageNotFoundException(p.toString()); } FileInputStream fis = new FileInputStream(p.toFile()); fis.skip(pageOffset); return fis.getChannel(); }", "output": "[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "String extractMetadataFromSlots(List<oasis.names.tc.ebxml_regrep.xsd.rim._3.SlotType1> documentSlots, String slotName, int valueIndex) { LOG.debug(\"extractMetadataFromSlots slotname: {}; index: {}\", slotName, valueIndex); String slotValue = null; for (SlotType1 slot : documentSlots) { if (slotName.equals(slot.getName())) { LOG.debug(\"Found {}: {}\", slotName, slot.getValueList().getValue()); if (valueIndex < 0) { slotValue = StringUtils.join(slot.getValueList().getValue(), VALUE_LIST_SEPERATOR); } else if (slot.getValueList() != null && slot.getValueList().getValue() != null && !slot.getValueList().getValue().isEmpty()) { slotValue = slot.getValueList().getValue().get(valueIndex); } else { slotValue = \"\"; } break; } } LOG.debug(\"{}: {}\", slotName, slotValue); return slotValue; }", "output": "This statement slot.getValueList().getValue()) could cause an NPE"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public PartitionStatistics getTableStatistics(String databaseName, String tableName) { try { Table table = getTable(databaseName, tableName).orElseThrow( () -> new PrestoException(HIVE_METASTORE_ERROR, String.format(\"Could not retrieve table %s.%s\", databaseName, tableName))); HiveBasicStatistics basicStats = getHiveBasicStatistics(table.getParameters()); List<Column> columns = table.getPartitionColumns(); List<String> columnNames = columns.stream().map(Column::getName).collect(toImmutableList()); List<ColumnStatisticsInfo> colStatsList = client.getTableColumnStatistics(table.getDatabaseName(), table.getTableName(), columnNames); return new PartitionStatistics(basicStats, groupStatisticsByColumn(colStatsList, basicStats.getRowCount())); } catch (Exception e) { throw new PrestoException(HIVE_METASTORE_ERROR, e); } }", "output": "columnStatistics"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void lazyLoadModulesConfig() throws IOException, ConfigInvalidException { if (modulesConfig == null) { loadModulesConfig(); } }", "output": "curly braces aren't required"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void run() { try { if (!makeResourceWritable(provider.getShell())) { return; } } catch (CoreException e) { MessageDialog.openWarning(provider.getShell(), \"Resource Not Accessible\", e.getMessage()); return; } if (LaunchUtils.hasLaunchedTestCases()) { MessageDialog.openWarning(provider.getShell(), Messages.RenameAction_ErrorDialogTitle, Messages.RenameAction_ErrorDialogMsg); return; } if (!RefactoringSaveHelper.checkDirtyEditors(provider.getShell())) { return; } if (containsSingleTag(getStructuredSelection())) { RenameTagWizard wizard = new RenameTagWizard(getSelectedTag()); run(wizard, provider.getShell()); } else { List<?> resources = getSelectedResources(); if (resources.size() == 1) { IResource resource = (IResource) resources.get(0); Q7RenameResourceWizard wizard = new Q7RenameResourceWizard( resource); run(wizard, provider.getShell()); } } }", "output": "Why do we handle error like this?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void setValue(Type type, BlockBuilder blockBuilder, String value) { if (value == null) { blockBuilder.appendNull(); return; } if (!(type instanceof FixedWidthType) && !(type instanceof VarcharType)) { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), \"type '\" + type + \"' not supported\"); } if (type instanceof FixedWidthType) { completedBytes += ((FixedWidthType) type).getFixedSize(); if (type instanceof BigintType) { type.writeLong(blockBuilder, parseDouble(value).longValue()); } else if (type instanceof IntegerType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else if (type instanceof TinyintType) { blockBuilder.writeByte(parseDouble(value).byteValue()); } else if (type instanceof SmallintType) { blockBuilder.writeShort(parseDouble(value).shortValue()); } else if (type instanceof BooleanType) { type.writeBoolean(blockBuilder, parseBoolean(value)); } else if (type instanceof DecimalType || type instanceof DoubleType) { type.writeDouble(blockBuilder, parseDouble(value)); } else if (type instanceof TimestampType) { type.writeLong(blockBuilder, parseLong(value)); } else if (type instanceof DateType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), \"type '\" + type + \"' not supported\"); } } else { Slice slice = Slices.utf8Slice(value); blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry(); completedBytes += slice.length(); } }", "output": "Why parseDouble and then convert that to int instead of directly parsing to int ?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void initialize() { this.setName(Constant.messages.getString(\"proxies.options.title\")); this.add(getScrollPane()); this.setLayout(new GridBagLayout()); this.add(getMainProxyPanel(), LayoutHelper.getGBC(0, 0, 1, 0.0)); this.add(getSecurityProtocolsPanel(), LayoutHelper.getGBC(0, 1, 1, 0.0)); this.add(getScrollPane(), LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0)); }", "output": "This can be removed? (Being added later.)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } ImageTransfer other = (ImageTransfer) obj; return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && type == other.type && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal); }", "output": "please move it to line 168, just to make it look cleaner :)"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static void printNetworkParameters(NetworkParams networkParams) { oshi.add(\"Network parameters:\" + networkParams.toString()); }", "output": "To match the old format, do \"Network parameters:\\n \" here."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public static OzoneAcl convertOzoneAcl(OzoneAclInfo aclInfo) { ACLIdentityType aclType; switch(aclInfo.getType()) { case USER: aclType = ACLIdentityType.USER; break; case GROUP: aclType = ACLIdentityType.GROUP; break; case WORLD: aclType = ACLIdentityType.WORLD; break; default: throw new IllegalArgumentException(\"ACL type is not recognized\"); } List<IAccessAuthorizer.ACLType> aclRights = new ArrayList<>(); for(OzoneAclRights acl:aclInfo.getRightsList()) { try { aclRights.add(ACLType.valueOf(acl.name())); } catch(IllegalArgumentException iae) { LOG.error(\"ACL:{} right is not recognized.\", acl); } } return new OzoneAcl(aclType, aclInfo.getName(), aclRights); }", "output": "Do we missing some enums here?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void shouldSubstituteHexValuesInReplacementString() { String replacement = \"abc\\\\x01\\\\xaadef\"; ReplacerParamRule nonAsciiRegexRule = new ReplacerParamRule( \"\", REQ_HEADER_STR, \"anyMatchString\", true, replacement, null, true); assertThat( nonAsciiRegexRule.getEscapedReplacement(), equalTo(new String(new byte[] {'a', 'b', 'c', 1, (byte) 170, 'd', 'e', 'f'}))); }", "output": "These could be renamed to not use nonAscii."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "protected Object transform( Message in, String mimeType, String transformerId, MimeTypeToTransformerMapper mapper) throws MimeTypeParseException, CatalogTransformerException { MimeType derivedMimeType = null; try (InputStream message = in.getBody(InputStream.class); TemporaryFileBackedOutputStream tfbos = new TemporaryFileBackedOutputStream()) { if (message == null) { throw new CatalogTransformerException( \"Message body was null; unable to generate Metacard!\"); } IOUtils.copy(message, tfbos); String fileExtensionHeader = getHeaderAsStringAndRemove(in, FILE_EXTENSION_HEADER); if (StringUtils.isNotEmpty(fileExtensionHeader)) { Optional<String> fileMimeType = getMimeTypeFor(tfbos.asByteSource().openBufferedStream(), fileExtensionHeader); if (fileMimeType.isPresent()) { LOGGER.trace( \"Setting mimetype to [{}] from Message header [{}]\", fileMimeType.get(), FILE_EXTENSION_HEADER); derivedMimeType = new MimeType(fileMimeType.get()); } } if (derivedMimeType == null) { if (StringUtils.isNotEmpty(mimeType)) { if (StringUtils.isNotEmpty(transformerId)) { derivedMimeType = new MimeType( mimeType + \";\" + MimeTypeToTransformerMapper.ID_KEY + \"=\" + transformerId); LOGGER.trace(\"Using mimeType to [{}]\", derivedMimeType); } else { LOGGER.trace(\"Using CatalogEndpoint's configured mimeType [{}]\", mimeType); derivedMimeType = new MimeType(mimeType); } } else { LOGGER.debug(\"Unable to determine mimeType. Defaulting to [{}]\", DEFAULT_MIME_TYPE); derivedMimeType = new MimeType(DEFAULT_MIME_TYPE); } } String metacardUpdateID = getHeaderAsStringAndRemove(in, METACARD_ID_HEADER); return generateMetacard(derivedMimeType, mapper, tfbos, metacardUpdateID) .orElseThrow( () -> new CatalogTransformerException( String.format( \"Did not find an InputTransformer for MIME Type [%s] and %s [%s]\", mimeType, MimeTypeToTransformerMapper.ID_KEY, transformerId))); } catch (IOException e) { LOGGER.debug(\"Failed to get mimeType by reading input stream\", e); } throw new CatalogTransformerException(\"Unable to transform incoming product\"); }", "output": "The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public Map<String, Discrepancy> getDiscrepanciesList() { Map<String, Discrepancy> toReturn = new HashMap<String, Discrepancy>(); String discrepanciesJson = artifact.getSoleAttributeAsString(DispoConstants.DispoDiscrepanciesJson, \"{}\"); try { JsonNode node = JsonUtil.getMapper().readTree(discrepanciesJson); Iterator<JsonNode> elements = node.getElements(); while (elements.hasNext()) { Discrepancy discrepancy = JsonUtil.getMapper().readValue(elements.next().toString(), Discrepancy.class); toReturn.put(discrepancy.getId(), discrepancy); } } catch (Exception ex) { throw new OseeCoreException(\"Could not parse Discrepancies Json\", ex); } return toReturn; }", "output": "Suggest JSON related capabilities be isolated to the JsonUtil class."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void setup() throws IOException, InterruptedException { m_eventdIpcMgr.setEventWriter(m_database); OnmsMonitoringLocation location = new OnmsMonitoringLocation(); location.setLocationName(\"Default\"); m_locationDao.save(location); final OnmsNode node = new OnmsNode(location, \"node1\"); node.setId(NODE_ID_ONE); m_nodeDao.save(node); Hashtable<String, Object> producerConfig = new Hashtable<String, Object>(); producerConfig.put(\"group.id\", \"OpenNMS\"); producerConfig.put(\"bootstrap.servers\", kafkaServer.getKafkaConnectString()); ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class, RETURNS_DEEP_STUBS); when(configAdmin.getConfiguration(KAFKA_PRODUCER_CLIENT_PID).getProperties()).thenReturn(producerConfig); ExecutorService executor = Executors.newSingleThreadExecutor(); kafkaConsumer = new KafkaMessageConsumerRunner(kafkaServer.getKafkaConnectString()); executor.execute(kafkaConsumer); kafkaProducer = new OpennmsKafkaProducer(protobufMapper, nodeCache, configAdmin, m_eventdIpcMgr, alarmLifecycleListenerManager); kafkaProducer.setEventTopic(\"events\"); kafkaProducer.setEventFilter(\"getUei().equals(\\\"uei.opennms.org/internal/discovery/newSuspect\\\")\"); kafkaProducer.setNodeTopic(\"nodes\"); kafkaProducer.init(); Thread.sleep(2000); }", "output": "What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public long updateHash( HashFunction hashFunction, long hash ) { class CodePointCursor { byte[] values; int i; @SuppressWarnings( \"WeakerAccess\" ) int codePointCount; @SuppressWarnings( \"WeakerAccess\" ) long next() { codePointCount++; byte b = values[i]; if ( b >= 0 ) { i++; return b; } int bytesNeeded = 0; while ( b < 0 ) { bytesNeeded++; b = (byte) (b << 1); } int codePoint = codePoint( values, b, i, bytesNeeded ); i += bytesNeeded; return codePoint; } } CodePointCursor cpc = new CodePointCursor(); cpc.values = bytes; cpc.i = offset; int len = offset + byteLength; while ( cpc.i < len ) { long codePointA = cpc.next() << 32; long codePointB = 0L; if ( cpc.i < len ) { codePointB = cpc.next(); } hash = hashFunction.update( hash, codePointA + codePointB ); } return hashFunction.update( hash, cpc.codePointCount ); }", "output": "The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void triggerCompleted() { getProcessInstance().removeEventListener(getEventType(), getEventListener(), true); ((org.jbpm.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).setCurrentLevel(getLevel()); ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()).removeNodeInstance(this); NodeInstanceContainer container = ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()); NodeInstance instance = container.getNodeInstance(getNode()); triggerNodeInstance((org.jbpm.workflow.instance.NodeInstance) instance, NodeImpl.CONNECTION_DEFAULT_TYPE); }", "output": "what's the reason for this extra variable container?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "void mapActionItemsToSelection(ISelection selection) { setMoveItemsEnabled(false); if (selection == null || selection.isEmpty()) return; if (selection instanceof IStructuredSelection) { IStructuredSelection structured = (IStructuredSelection) selection; Object obj = structured.getFirstElement(); if (!(obj instanceof PlanElement)) return; PlanElement firstSelectedEntry = (PlanElement) obj; PlanElement lastSelectedEntry = firstSelectedEntry; ElementAction type = firstSelectedEntry.getPlanElementAction(); unselectAllActionItemsExecpt(getItemFor(type)); if (structured.size() > 1) { for (Iterator iterator = structured.iterator(); iterator .hasNext();) { Object selectedObj = iterator.next(); if (!(selectedObj instanceof PlanElement)) continue; PlanElement entry = lastSelectedEntry = (PlanElement) selectedObj; if (type != entry.getPlanElementAction()) { unselectAllActionItemsExecpt(null); } } } enableMoveButtons(firstSelectedEntry, lastSelectedEntry); } }", "output": "We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(\"P60000000000000D\"); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); assertThat(e.getMessage(), is(\"Error during type conversion from type: java.time.Duration to the required type: \" + \"long with value PT1440000000000000H due java.lang.ArithmeticException: long overflow\")); } }", "output": "I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void publishChildren(IModule[] module, ArrayList<IStatus> results, IModule[] children, File parentModule, IProgressMonitor monitor) { if( children == null ) return; monitor.beginTask(\"Assembling child modules\", children.length * 100); for( int i = 0; i < children.length; i++ ) { if( ServerModelUtilities.isBinaryModule(children[i])) results.addAll(Arrays.asList(fullBinaryPublish(module, children[i], ProgressMonitorUtil.submon(monitor, 100)))); else results.addAll(Arrays.asList(fullPublish(combine(module, children[i]), parentModule, ProgressMonitorUtil.submon(monitor, 100)))); } }", "output": "check if monitor is cancelled?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean isReady() { return false; }", "output": "@Irenyak1 why return false here?"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) { synchronized (lock) { final long id = idGenerator.getAndIncrement(); final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter); final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work); EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get(); workProcessor.onNext(syncSubscriber); Disposable thisWorkSubscriber = workSubscriber.get(); if (thisWorkSubscriber != null) { logger.info(\"[{}]: Receive request is placed in queue to process.\", id); return; } EmitterProcessor<ServiceBusReceivedMessageContext> source = messageSource.get(); if (source == null) { source = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS) .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false)); messageSource.set(source); logger.info(\"Created source for receiving messages.\"); } EmitterProcessor<ServiceBusReceivedMessageContext> finalSource = source; thisWorkSubscriber = workProcessor .subscribe(currentWork -> finalSource.subscribe(currentWork), error -> { logger.error(\"Error in processing messages [{}]\", error); }, () -> { logger.info(\"Receiving messages completed.\"); }); workSubscriber.set(thisWorkSubscriber); } }", "output": "These should be done through a sink."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "private static String truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName(String legalLastName, String legalFirstName) { int maxAllowedLengthOfFirstName = VendorConstants.MAX_VENDOR_NAME_LENGTH - VendorConstants.NAME_DELIM.length() - legalLastName.length(); if (legalFirstName.length() <= maxAllowedLengthOfFirstName) { return legalFirstName; } else { String truncatedLegalFirstName = legalFirstName.substring(0, maxAllowedLengthOfFirstName); LOG.info(\"truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName: Received legalFirstName '\" + legalFirstName + \"' with length of \" + legalFirstName.length() + \" and it is being truncated to '\" + truncatedLegalFirstName + \"' with length of \" + truncatedLegalFirstName.length()); return truncatedLegalFirstName; } }", "output": "If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood."}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) { GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId)); GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity(); snapshot.setClusterId(volume.getClusterId()); snapshot.setVolumeId(new Guid(volumeId)); DateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\"); String snapshotName = snapshotNamePrefix + \"-snap-\" + df.format(new Date()); snapshot.setSnapshotName(snapshotName); snapshot.setDescription(description); VDSReturnValue returnValue = getBackend().getResourceManager() .RunVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new GlusterVolumeCreateSnapshotVDSParameters(new Guid(serverId), volume.getName(), snapshotName, description, force)); if (returnValue.getSucceeded()) { snapshot.setSnapshotId((Guid) returnValue.getReturnValue()); snapshot.setCreatedAt(new Date()); snapshot.setStatus(GlusterSnapshotStatus.STARTED); getGlusterVolumeSnapshotDao().save(snapshot); } else { log.error(\"Error while creating snapshot for volume '{}': {}\", volume.getName(), returnValue.getVdsError() .getMessage()); log.debug(returnValue.getVdsError().getMessage()); } }", "output": "How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed"}, {"instruction": "Your task is to write a concise code review for the given code snippet. Your output should only be a brief code review, no extra information.", "input": "public boolean removeFileEntry(String index, TransientStore ts) { BatchFileEntry fileEntry = getFileEntry(index, false); if (fileEntry != null) { if (fileEntry.isChunked()) { for (String chunkEntryKey : fileEntry.getChunkEntryKeys()) { List<Blob> chunkBlobs = ts.getBlobs(chunkEntryKey); if (chunkBlobs != null) { for (Blob blob : chunkBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(\"Error while deleting chunk parent directory\", e); } } } ts.remove(chunkEntryKey); } fileEntry.beforeRemove(); } String fileEntryKey = fileEntry.getKey(); List<Blob> fileBlobs = ts.getBlobs(fileEntryKey); if (fileBlobs != null) { for (Blob blob : fileBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(\"Error while deleting file parent directory\", e); } } } ts.remove(fileEntryKey); return true; } else { return false; } }", "output": "I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case."}]