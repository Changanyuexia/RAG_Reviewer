code,review,top_1,top_2,top_3,top_4,top_5,top_6,top_7,top_8,top_9,top_10
"private ByteArrayInputStream uploadPackV2(String... inputLines) throws Exception { ByteArrayOutputStream send = new ByteArrayOutputStream(); PacketLineOut pckOut = new PacketLineOut(send); for (String line : inputLines) { if (line == PacketLineIn.END) { pckOut.end(); } else if (line == PacketLineIn.DELIM) { pckOut.writeDelim(); } else { pckOut.writeString(line); } } UploadPack up = new UploadPack(server); up.setUseProtocolV2(true); ByteArrayOutputStream recv = new ByteArrayOutputStream(); up.upload(new ByteArrayInputStream(send.toByteArray()), recv, null); ByteArrayInputStream recvStream = new ByteArrayInputStream(recv.toByteArray()); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(""version 2"")); assertThat(pckIn.readString(), is(""ls-refs"")); assertThat(pckIn.readString(), is(""fetch=shallow"")); assertTrue(pckIn.readString() == PacketLineIn.END); return recvStream; }","Let's add a constant for ""version 2""","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",read the values and validate,is double call to structIsNull.toBooleanArray() intentional?,remove this log,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,I think this test should be moved to options instead,"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",columnStatistics,throw exception?
"private void repaint() { if (graph != null) { System.out.println(""repainting graph...""); Tile model = new Tile(graph); TileView view = new TileView(); TileController tc = new TileController(view, model); Group root = new Group(); wrapper.hvalueProperty().addListener( (ChangeListener<Number>) (ov, oldVal, newVal) -> { repaintPosition(tc, root, newVal.doubleValue()); }); Rectangle clip = new Rectangle(getMaxUnifiedEnd(graph) * VertexView.HORIZONTALSCALE, 0); root.getChildren().add(clip); repaintPosition(tc, root, wrapper.hvalueProperty().doubleValue()); } }",Iffy formatting,No need to explicitly load tables with query if you are using the latest build,we should probably check in the canExecute whether we reached the start of the list,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,columnStatistics,This seems to be unnecessary. I also get the label after removing this.,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",why var4? Resources.NotFoundException e would be a bit nicer..,@snleee This is handled with the API refreshSegment(),is double call to structIsNull.toBooleanArray() intentional?,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update."
"public Request iterate(final Request req, final Coordinates cords) { return null; }","don't return NULL, throw UnsupportedOperatedException instead",Check for illegal arg or are we happy with a ClassCastException here?,should be possible to provide one,"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",Is there a reason this isn't implemented?,as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",Remove cast,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",Here too we may use IanaLinkRelation.EDIT?
"public MamQueryIQ parse(XmlPullParser parser, int initialDepth) throws Exception { String queryId = null; String node = null; DataForm dataForm = null; if (parser.getName().equals(MamQueryIQ.ELEMENT)) { queryId = parser.getAttributeValue("""", ""queryid""); node = parser.getAttributeValue("""", ""node""); boolean done = false; while (!done) { int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) { if (parser.getName().equals(DataForm.ELEMENT)) { dataForm = new DataFormProvider().parse(parser); } } else if (eventType == XmlPullParser.END_TAG) { if (parser.getName().equals(MamQueryIQ.ELEMENT)) { done = true; } } } } return new MamQueryIQ(queryId, node, dataForm); }","That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?",Can this be changed to createSubjectRoleAttribute?,Does it make sense to continue here? Or just return false.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",Suggest JSON related capabilities be isolated to the JsonUtil class.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,UtilKtKt isn't a great name.,"Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?",This statement slot.getValueList().getValue()) could cause an NPE,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"public static <T> TypeToken<T> getTypeToken(TypeToken<T> token, Class<? super T> raw) { if (raw!=null) return TypeToken.of((Class<T>)raw); if (token!=null) return token; throw new IllegalStateException(""Both indicators of type are null""); }",Should this not prefer the token over the raw?,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,nit: unnecessary generic type declaration,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",I think it would be good to perform this logic in OutputEmitter.,Why does this need to be ordered by the synthetic primary key?,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,"What do we do, if the result is null?",this.redisTemplate,Should we also validate that DataType != null.
private void initPlugins() throws Exception { Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps(); for (InitStep initStep : pluginsInitSteps) { initStep.run(); } },It would have been shorter to inline this variable and not have it in scope. :-),curly braces aren't required,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"This bloc of code is repeated many times, should be centralized in a single method.",this can be reduced to protected.,Floating semicolon,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,A future refactor might place this method in the enum directly.,Why not use capabilities directly here?
"public <T> T cast(FormField<?> formField) { if (getDefaultOrNull(formField)) { return null; } if (this == formField.getValueType()) { return (T) formField.getValue(); } else if (STRING == formField.getValueType()) { return (T) formField.getValue().toString(); } else { throw LOGGER.logExceptionAsError(new UnsupportedOperationException(String.format(""Cannot cast from "" + ""field value of type %s to type %s"", formField.getValueType(), PHONE_NUMBER))); } }",Is toString() required? It's already of STRING type.,"Json -> ""JSON"" (do a search-n-replace)",Suggest JSON related capabilities be isolated to the JsonUtil class.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",suggestion this.ignoreAbove = mw.ignoreAbove;,ImplUtils has a isNullOrEmpty method that should handle these checks.,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Let's make this InternalServerError
"public LengthFieldBasedFrameDecoder( ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, boolean failFast) { checkPositive(maxFrameLength, ""maxFrameLength""); checkPositiveOrZero(lengthFieldOffset, ""lengthFieldOffset""); checkPositiveOrZero(initialBytesToStrip, ""initialBytesToStrip""); if (lengthFieldOffset > maxFrameLength - lengthFieldLength) { throw new IllegalArgumentException( ""maxFrameLength ("" + maxFrameLength + "") "" + ""must be equal to or greater than "" + ""lengthFieldOffset ("" + lengthFieldOffset + "") + "" + ""lengthFieldLength ("" + lengthFieldLength + "").""); } this.byteOrder = checkNotNull(byteOrder, ""byteOrder""); this.maxFrameLength = maxFrameLength; this.lengthFieldOffset = lengthFieldOffset; this.lengthFieldLength = lengthFieldLength; this.lengthAdjustment = lengthAdjustment; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength; this.initialBytesToStrip = initialBytesToStrip; this.failFast = failFast; }",move the check and assignment before the other checks to ensure the behaviour is not changed.,"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood.",Replace with logger,read the values and validate,edgeCacheDNS as a static variable since it's used a few times?,nit: call it uae?,Replace with Objects.requireNotNull.,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",Let's make this InternalServerError,I think this test should be moved to options instead
"public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - 1 - endOfTableName); return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }",might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,We have a StringMarshal helper class that does all of this UTF8 logic for a string.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",not a field,Replace with Objects.requireNotNull.,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }",Log/throw?,Replace with logger,Similar to DistinctCountAggregator,Suggest JSON related capabilities be isolated to the JsonUtil class.
"public void ThrottleForNormalizeTestWithinIdeal() throws Exception { List<RateLimit> scenarios = new ArrayList<>(); int limit = 5000; int buffer = ApiRateLimitChecker.calculateBuffer(limit); int approximateIdeal = 4000; scenarios.add(new RateLimit(limit, approximateIdeal + buffer - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 101, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, limit, soon)); setupStubs(scenarios); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(1, countOfOutputLinesContaining(""under budget"")); assertFalse(handler.getView().stream().anyMatch(m -> m.getMessage().contains(""Sleeping""))); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(2, countOfOutputLinesContaining(""rechecking"")); assertEquals(3, countOfOutputLinesContaining(""Still sleeping"")); assertEquals(2, countOfOutputLinesContaining(""Sleeping for"")); assertEquals(1, countOfOutputLinesContaining(""under budget"")); assertEquals(10, handler.getView().size()); }","EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>","I should probably have asked this in the previous review, but why ""addFollowingAccounts""? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.",Please don't do unrelated refactor work next time,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Should TREEHASH be a HashCode?,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",I think this test should be moved to options instead,Why use a java.lang.Boolean and not a primitive boolean?,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","verify(client != null, ""client cannot be null"");",power down
"public boolean cleanupNode(final String id) { RegionAndId regionAndId = RegionAndId.fromSlashEncoded(id); ResourceGroup resourceGroup = resourceGroupMap.getUnchecked(regionAndId.region()); String group = resourceGroup.name(); VirtualMachine virtualMachine = api.getVirtualMachineApi(group).get(regionAndId.id()); if (virtualMachine == null) { return true; } logger.debug("">> destroying %s ..."", regionAndId.slashEncode()); boolean vmDeleted = deleteVirtualMachine(group, virtualMachine); cleanupVirtualMachineNICs(group, virtualMachine); cleanupVirtualMachineStorage(group, virtualMachine); return vmDeleted; }",[minor] could you name it resourceGroupName,Similar to DistinctCountAggregator,isn't the topology always a LocalizedCacheTopology?,you don't take any resourcees from player when buying dev card,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,not a field,Replace with logger,do you clean up these files on exit? or the root level dir is deleted on exit ?,1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?,consider 'ternary if' here
"public Factory(long nowMillis, Request request, Response cacheResponse) { this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; if (cacheResponse != null) { this.sentRequestMillis = cacheResponse.sentRequestAtMillis(); this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis(); Headers headers = cacheResponse.headers(); for (int i = 0, size = headers.size(); i < size; i++) { String fieldName = headers.name(i); String value = headers.value(i); if (""Date"".equalsIgnoreCase(fieldName)) { servedDate = HttpDate.parse(value); servedDateString = value; } else if (""Expires"".equalsIgnoreCase(fieldName)) { expires = HttpDate.parse(value); } else if (""Last-Modified"".equalsIgnoreCase(fieldName)) { lastModified = HttpDate.parse(value); lastModifiedString = value; } else if (""ETag"".equalsIgnoreCase(fieldName)) { etag = value; } else if (""Age"".equalsIgnoreCase(fieldName)) { ageSeconds = UtilKtKt.toNonNegativeInt(value, -1); } } } }",UtilKtKt isn't a great name.,This check seems a little fragile at first glance (not sure why.),Replace with logger,edgeCacheDNS as a static variable since it's used a few times?,you can use parameterized logging here,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),Suggest JSON related capabilities be isolated to the JsonUtil class.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.","I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid."
"protected void doResolveAll(String inetHost, DnsRecord[] additionals, Promise<List<InetAddress>> promise, DnsCache resolveCache) throws Exception { if (inetHost == null || inetHost.isEmpty()) { promise.setSuccess(Collections.singletonList(loopbackAddress())); return; } final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost); if (bytes != null) { promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes))); return; } final String hostname = hostname(inetHost); InetAddress hostsFileEntry = resolveHostsFileEntry(hostname); if (hostsFileEntry != null) { promise.setSuccess(Collections.singletonList(hostsFileEntry)); return; } CacheResult res = doResolveAllCached(hostname, additionals, promise, resolveCache, resolvedInternetProtocolFamilies); if (res == CacheResult.CACHED) { return; } if (res == CacheResult.CACHED_EXPIRED) { promise = executor().newPromise(); } doResolveAllUncached(hostname, additionals, promise, promise, resolveCache, completeOncePreferredResolved); }",consider using a switch(res) {...},nit: call it uae?,"Let's add a constant for ""version 2""",I think this test should be moved to options instead,"Good catch, thanks. Fixed <LINK_0>",the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,edgeCacheDNS as a static variable since it's used a few times?,Two ;;,@snleee This is handled with the API refreshSegment(),columnStatistics,Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.
"private List<Resource> filterNotAuthorizedResource(PerunSession sess, List<Resource> resources) throws InternalErrorException { Iterator<Resource> resIterator = resources.iterator(); while(resIterator.hasNext()) { Resource resource = resIterator.next(); if(!AuthzResolver.isAuthorized(sess, Role.RESOURCEADMIN, resource) && !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) resIterator.remove(); } return resources; }",For PerunObserver you can return all resources immediately.,nit: unnecessary generic type declaration,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),"If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }","What do we do, if the result is null?","Should this support a null address? Same with the other one, which make support a null or empty address.","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","suggestion Objects.requireNonNull(filter, ""filter cannot be null"");","Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.
"public void initTrackerServers(List<TrackerServer> serverList) { serverList.add(new TrackerServer(new ServerBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(""frameDecoder"", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(""objectDecoder"", new AstraProtocolDecoder(AstraProtocol.this)); } }); serverList.add(new TrackerServer(new ConnectionlessBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(""frameDecoder"", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(""objectDecoder"", new AstraProtocolDecoder(AstraProtocol.this)); } }); }","UDP is a datagram protocol, so it doesn't require frame decoder.",Let's do the same way @jleandroperez did on iOS here <LINK_0>,No need to explicitly load tables with query if you are using the latest build,columnStatistics,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,suggestion this.ignoreAbove = mw.ignoreAbove;,This commandContext seems unused.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,Iffy formatting
protected Properties getIntegrationProperties() { if (this.beanFactory != null) { return IntegrationContextUtils.getIntegrationProperties(this.beanFactory); } else { return null; } },Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"This bloc of code is repeated many times, should be centralized in a single method.",Floating semicolon,curly braces aren't required,this can be reduced to protected.,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),Why not use capabilities directly here?,"To match the old format, do ""Network parameters:\n "" here.",A future refactor might place this method in the enum directly.,Why does this need to be ordered by the synthetic primary key?
"public void testShowStatsSelectNonStarFails() { assertQueryFails(""SHOW STATS FOR (SELECT nationkey FROM nation_partitioned)"", "".*Only SELECT \\* is supported in SHOW STATS SELECT clause""); }",Why this change?,"you should check the cache doesn't exist, plus that no suggestion to use the cache is logged",Isn't this dataset automatically executed?,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",There should be a space here between expected and school.roster(),nit: any chance to make the message assertion more specific? :),@Serranya The same here. See above.,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,Could you use Strings.repeat or something?,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,assertEquals and remove the expected value from message string
"protected static ConnectionFactory getConnectionFactory( IDatabaseConnection databaseConnection, String url ) { ConnectionFactory factory = null; if ( url.startsWith( ""jdbc:mysql:"" ) || ( url.startsWith( ""jdbc:mariadb:"" ) ) ) { Properties props = new Properties(); props.put( ""user"", StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ) ); props.put( ""password"", StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); props.put( ""socketTimeout"", ""0"" ); props.put( ""connectTimeout"", ""5000"" ); factory = new DriverManagerConnectionFactory( url, props ); } else { factory = new DriverManagerConnectionFactory( url, StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ), StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); } return factory; }","We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",ImplUtils has a isNullOrEmpty method that should handle these checks.,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.",Replace with logger,The same.,The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,Suggest JSON related capabilities be isolated to the JsonUtil class.,not good to add sth when calling getter,coudl be just ArrayList since now it is imported ^^ vv,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"public void testDisableIncrementalAnalysis() { executeTarget(""testDisableIncrementalAnalysis""); assertOutputContaining(""Avoid really long methods""); }","you should check the cache doesn't exist, plus that no suggestion to use the cache is logged","add ""balanced"" ?",Floating semicolon,Why not use capabilities directly here?,Why this change?,@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",Isn't this dataset automatically executed?,"This bloc of code is repeated many times, should be centralized in a single method.","To match the old format, do ""Network parameters:\n "" here.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"public void preInstall() { resolver = Entities.newDownloader(this); String subpath = entity.getConfig(BrooklynNode.SUBPATH_IN_ARCHIVE); if (subpath==null) { String uploadUrl = entity.getConfig(BrooklynNode.DISTRO_UPLOAD_URL); String origDownloadName = uploadUrl; if (origDownloadName==null) { String downloadUrlTemplate = entity.getAttribute(BrooklynNode.DOWNLOAD_URL); if (downloadUrlTemplate!=null) { origDownloadName = DownloadSubstituters.substitute(downloadUrlTemplate, DownloadSubstituters.getBasicEntitySubstitutions(this)); } } if (origDownloadName!=null) { origDownloadName = Urls.getBasename(origDownloadName); String downloadName = origDownloadName; downloadName = Strings.removeFromEnd(downloadName, "".tar.gz""); downloadName = Strings.removeFromEnd(downloadName, "".tgz""); downloadName = Strings.removeFromEnd(downloadName, "".zip""); if (!downloadName.equals(origDownloadName)) { downloadName = Strings.removeFromEnd(downloadName, ""-dist""); subpath = downloadName; } } } if (subpath==null) subpath = format(""brooklyn-%s"", getVersion()); setExpandedInstallDir(Os.mergePaths(getInstallDir(), resolver.getUnpackedDirectoryName(subpath))); }",Make sure to unescape the url path before using it. I've hit this in actual usage.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed","suggestion log.debug(""{} old entitlement certificates deleted"", count);",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,Why use a java.lang.Boolean and not a primitive boolean?,The output of this call should be checked and if it's false I think it should bail.,"verify(client != null, ""client cannot be null"");"
public boolean isLaunchedFromIntent() { return invokeSource.equals(InvokeSource.WIDGET) || invokeSource.equals(InvokeSource.INTENT_SHARE) || invokeSource.equals(InvokeSource.INTENT_PROCESS_TEXT); },A future refactor might place this method in the enum directly.,any reason for disabling cache for descending order queries ?,Why not use capabilities directly here?,this can be reduced to protected.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"This bloc of code is repeated many times, should be centralized in a single method.",Floating semicolon,"To match the old format, do ""Network parameters:\n "" here.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),I think it would be good to perform this logic in OutputEmitter.
"private void initializeAsyncCancelAndVerifyCancelled(AlwaysFailingInitializer initializer, Runnable cleanupTask) throws InterruptedException { initializer.initialize(true); initializer.cancelInitialization(cleanupTask); int numberOfAttemptsWhenCancelled = initializer.initializationAttempts; initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY * 5 + 1, TimeUnit.MILLISECONDS); assertThat(initializer.initializationAttempts).isEqualTo(numberOfAttemptsWhenCancelled); }","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?","minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,why swallowing?,"If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }",Out of interest why can you not do BuiltinAggregator.values()?,check to make sure notificationUUID is not null,you don't take any resourcees from player when buying dev card,do you clean up these files on exit? or the root level dir is deleted on exit ?,"this is followup of above, it should not be required.",How can this work? This is going to insert MAXED_POOL_MARKER into the bag.
"public ExecutorService getExecutor(Properties p) { TypedProperties tp = TypedProperties.toTypedProperties(p); int maxThreads = tp.getIntProperty(""maxThreads"", 1); int queueSize = tp.getIntProperty(""queueSize"", 100000); long keepAliveTime = tp.getLongProperty(""keepAlive"", 10000); final int threadPrio = tp.getIntProperty(""threadPriority"", Thread.MIN_PRIORITY); final String threadNamePrefix = tp.getProperty(""threadNamePrefix"", tp.getProperty(""componentName"", ""Thread"")); final String threadNameSuffix = tp.getProperty(""threadNameSuffix"", """"); ThreadFactory tf = new ThreadFactory() { @Override public Thread newThread(Runnable r) { String threadName = threadNamePrefix + ""-"" + counter.getAndIncrement() + threadNameSuffix; Thread th = new Thread(r, threadName); th.setDaemon(true); th.setPriority(threadPrio); return th; } }; ThreadPoolExecutor tpe = new ThreadPoolExecutor(maxThreads, maxThreads, keepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(queueSize), tf, new ThreadPoolExecutor.CallerRunsPolicy()); tpe.allowCoreThreadTimeOut(true); return tpe; }","I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.",fetch should already happen in Service,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,I think this test should be moved to options instead,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",@snleee This is handled with the API refreshSegment(),"Let's add a constant for ""version 2""",read the values and validate,just pass sparkJarFilePath.toString less number of changes will be required in the code.,The output of this call should be checked and if it's false I think it should bail.,"verify(client != null, ""client cannot be null"");"
public GWCConfig getConfig() { if (gsEnvironment != null && gsEnvironment.isStale()) { syncEnvironment(); } return gwcConfigPersister.getConfig(); },"This bloc of code is repeated many times, should be centralized in a single method.",Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,curly braces aren't required,Why not use capabilities directly here?,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,this can be reduced to protected.,Floating semicolon,"To match the old format, do ""Network parameters:\n "" here.",I think it would be good to perform this logic in OutputEmitter.,A future refactor might place this method in the enum directly.,It would have been shorter to inline this variable and not have it in scope. :-)
"private void captureScreenshot(String comment, WebDriver driver, WebElement element, boolean errorMessage) { if (getMessage(errorMessage) != null) { comment = getMessage(errorMessage); } LOGGER.debug(""DriverListener->captureScreenshot starting...""); try { if (errorMessage) { LOGGER.error(comment); Screenshot.captureFailure(driver, comment); } else { LOGGER.info(comment); if (MobileContextHelper.isInWebViewContext()) { MobileContextHelper.backUpContext(driver); Screenshot.capture(driver, comment); MobileContextHelper.restoreContext(driver); } else { Screenshot.capture(driver, comment); } } } catch (Exception e) { LOGGER.debug(""Unrecognized failure detected in DriverListener->captureScreenshot: "" + e.getMessage(), e); } finally { resetMessages(); } LOGGER.debug(""DriverListener->captureScreenshot finished...""); }",I don't see sense from this if (MobileContextHelper.isInWebViewContext()),I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",Two ;;,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.","Good catch, thanks. Fixed <LINK_0>",log,Unrelated change. Should be in a separate commit.,Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Let's do the same way @jleandroperez did on iOS here <LINK_0>
"public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) { super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.my_courses, menu); final Config config = environment.getConfig(); if (config.isTabsLayoutEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(false); menu.findItem(R.id.menu_item_account).setVisible(true); menu.findItem(R.id.menu_item_account).setIcon( new IconDrawable(getContext(), FontAwesomeIcons.fa_gear) .colorRes(getContext(), R.color.white) .actionBarSize(getContext())); } else { menu.findItem(R.id.menu_item_account).setVisible(false); if (config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(true); } else { menu.findItem(R.id.menu_item_search).setVisible(false); } } }",This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()),Why do we handle error like this?,Why use a java.lang.Boolean and not a primitive boolean?,"verify(client != null, ""client cannot be null"");","Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Make sure to unescape the url path before using it. I've hit this in actual usage.,Remove /Dev Team,The output of this call should be checked and if it's false I think it should bail.,why var4? Resources.NotFoundException e would be a bit nicer..,what is a PropertyValueWrapper? Why do you need it?
"protected List<AttributeStatement> createSubjectRoleStatement(final CallbackProperties properties) throws SAMLAssertionBuilderException { final String userCode = properties.getUserCode(); final String userSystem = properties.getUserSystem(); final String userSystemName = properties.getUserSystemName(); final String userDisplay = properties.getUserDisplay(); if (Arrays.asList(userCode, userSystem, userSystemName, userDisplay).contains(null)) { LOG.error(""No information provided to fill in user role attribute..""); throw new SAMLAssertionBuilderException(""No information provided to fill in user role attribute.""); } final List<AttributeStatement> statements = new ArrayList<>(); final List<Attribute> attributes = new ArrayList<>(); attributes.add(componentBuilder.createUserRoleAttribute(userCode, userSystem, userSystemName, userDisplay)); if (!attributes.isEmpty()) { statements.addAll(componentBuilder.createAttributeStatement(attributes)); } return statements; }",Can this be changed to createSubjectRoleAttribute?,Please change user back to USER_YODA here.,Suggest JSON related capabilities be isolated to the JsonUtil class.,Replace with logger,Do we missing some enums here?,repeating code line.,"I see no reason to introduce msg here, you could just use serializedPayload",This statement slot.getValueList().getValue()) could cause an NPE,not a field,Add invariants,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).
public LineRanges within(final LineRanges ranges) { final LineRanges result = new LineRanges(); final Iterator<LineRange> iterator = ranges.iterate(); while (iterator.hasNext()) { final LineRange next = iterator.next(); for (final LineRange line : this.lines.collection()) { if (next.within(line)) { result.add(line); } } } return result; },@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,"Maybe using a constant here for ""://""","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",I think we need to close this InputStream at some point,Wrapper#getX() : float Use float instead of double.,not good to add sth when calling getter,"What do we do, if the result is null?",I think it would be good to perform this logic in OutputEmitter.,"Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
"public GlusterServersListReturnForXmlRpc(Map<String, Object> innerMap) { super(innerMap); List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>(); Object[] serversArr = (Object[]) innerMap.get(GLUSTER_HOSTS); if (serversArr != null) { for (int i = 0; i < serversArr.length; i++) { glusterServers.add(prepareServerInfo((Map<String, Object>) serversArr[i])); } } setServer(glusterServers); }",Do not try to parse the sever list if the command has failed (mStatus.code != 0),"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",coudl be just ArrayList since now it is imported ^^ vv,Suggest JSON related capabilities be isolated to the JsonUtil class.,Let's make this InternalServerError,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"Json -> ""JSON"" (do a search-n-replace)",I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Replace with logger,@ekondrashev why not just rsp = opt?,"This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()"
"private void buildTestedInstance() { ; this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }",Floating semicolon,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),this can be reduced to protected.,"To match the old format, do ""Network parameters:\n "" here.",It would have been shorter to inline this variable and not have it in scope. :-),It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"This bloc of code is repeated many times, should be centralized in a single method.",Why not use capabilities directly here?,A future refactor might place this method in the enum directly.,I think it would be good to perform this logic in OutputEmitter.
"public void parentIsNotCalledIfAccountStatusExceptionIsThrown() { AuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(new AccountStatusException( """", new Throwable()) { }); AuthenticationManager parent = mock(AuthenticationManager.class); ProviderManager mgr = new ProviderManager( Collections.singletonList(iThrowAccountStatusException), parent); try { mgr.authenticate(mock(Authentication.class)); fail(""Expected exception""); } catch (AccountStatusException expected) { } verifyZeroInteractions(parent); }","Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.","I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",@Serranya The same here. See above.,@ikhvostenkov please name it json,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,The Exception is never thrown.,"if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.",May be static imports for TimeUnit values here and below?,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",this should be on System.err,what's the reason for this extra variable container?
"private void initScanner(Schema projected) throws IOException { this.projector = new Projector(inSchema, outSchema, plan.getTargets()); System.out.println(""=======================>"" + plan.getTableDesc().getName()); for (FragmentProto f: fragments) { FileFragment ff = (FileFragment)FragmentConvertor.convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), f); System.out.println("">>>>>>>>>>>>>>>>>>>"" + ff.getPath()); } if (fragments != null) { if (fragments.length > 1) { this.scanner = new MergeScanner(context.getConf(), plan.getPhysicalSchema(), plan.getTableDesc().getMeta(), FragmentConvertor.<FileFragment>convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), fragments), projected ); } else { this.scanner = StorageManagerFactory.getStorageManager( context.getConf()).getScanner(plan.getTableDesc().getMeta(), plan.getPhysicalSchema(), fragments[0], projected); } scanner.init(); } }",Please remove debug codes.,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,call intValue() and then there is no cast,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),suggestion deletedAlarmIds.forEach(alarmId -> {,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",this may impact web-ui code. Do we want to expose Snapshot in API?,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.","verify(client != null, ""client cannot be null"");",power down,@snleee This is handled with the API refreshSegment()
"public boolean put(ConflictTxStream conflictStream) { Long val = cacheConflictKeys.get(conflictStream); if (val != null && val >= conflictStream.txVersion) { log.error(""For key {}, the value {} is not smaller than the expected value {} or maxWildCard"", conflictStream, cacheConflictKeys.get(conflictStream), conflictStream.txVersion, maxConflictWildcard); return false; } if (cacheConflictKeys.size() == cacheSize) { invalidateFirst(); } cacheEntries.add(conflictStream); cacheConflictKeys.put(conflictStream, conflictStream.txVersion); cacheEntriesBytes += conflictStream.size(); return true; }",please use long,Replace with Objects.requireNotNull.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,[minor] could you name it resourceGroupName,How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Replace with logger,Similar to DistinctCountAggregator,static import,nit: maybe we can save the result of getPartition(topicPartition),isn't the topology always a LocalizedCacheTopology?
"public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(final Collection<BindingSet> bindingSets) throws QueryEvaluationException { return null; }",Is there a reason this isn't implemented?,"don't return NULL, throw UnsupportedOperatedException instead",It would have been shorter to inline this variable and not have it in scope. :-),replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,Remove cast,This should be in the if(v != null) check I am thinking,any reason for disabling cache for descending order queries ?,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",this can be reduced to protected.,Check for illegal arg or are we happy with a ClassCastException here?,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());"
"public static <T> void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }",nit: unnecessary generic type declaration,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,It would have been shorter to inline this variable and not have it in scope. :-),Why not use capabilities directly here?,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }",Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",I think it would be good to perform this logic in OutputEmitter.
public Integer getPartition() { String changelogPartition = getMessageValue(CHANGELOG_VALUE_KEY); return (changelogPartition != null) ? Integer.parseInt(changelogPartition) : null; },Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),Need to remove this leftover debug output,magic number,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,It would have been shorter to inline this variable and not have it in scope. :-),We don't need super here,A future refactor might place this method in the enum directly.,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,This should be in the if(v != null) check I am thinking,nit: unnecessary generic type declaration,Why does this need to be ordered by the synthetic primary key?
"public void testInitAggregator() throws Exception { final List<BuiltinAggregator> aggregators = Arrays.asList(BuiltinAggregator.COUNT, BuiltinAggregator.MAX, BuiltinAggregator.MIN, BuiltinAggregator.SUM); testedView.initBuiltinAggregators(aggregators); aggregators.stream().forEach(agg -> verify(lstBuiltinAggregator).addOption(agg.value())); }",Out of interest why can you not do BuiltinAggregator.values()?,May be static imports for TimeUnit values here and below?,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?","The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;",check to make sure notificationUUID is not null,Similar to DistinctCountAggregator,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,you don't take any resourcees from player when buying dev card,[minor] could you name it resourceGroupName,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,consider 'ternary if' here
"private void doCopyRetry(FileSystem sourceFs, List<ReplChangeManager.FileInfo> srcFileList, FileSystem destinationFs, Path destination, boolean useRegularCopy) throws IOException, LoginException { int repeat = 0; boolean isCopyError; List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath); while (!pathList.isEmpty() && (repeat < MAX_COPY_RETRY)) { LOG.info(""Attempt: "" + (repeat+1) + "". Copying files: "" + pathList); try { isCopyError = false; doCopyOnce(sourceFs, pathList, destinationFs, destination, useRegularCopy); } catch (IOException e) { if (!(e instanceof FileNotFoundException)) { LOG.info("" File operation failed with error : "" + e.getMessage()); sourceFs = pathList.get(0).getFileSystem(hiveConf); destinationFs = destination.getFileSystem(hiveConf); } isCopyError = true; } pathList = getFilesToRetry(sourceFs, srcFileList, destinationFs, destination, isCopyError); repeat++; } if (!pathList.isEmpty()) { LOG.error(""File copy failed even after several attempts. Files list: "" + srcFileList); throw new IOException(""File copy failed even after several attempts.""); } }",Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,This seems to be unnecessary. I also get the label after removing this.,check if monitor is cancelled?,What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,Iffy formatting,why var4? Resources.NotFoundException e would be a bit nicer..,remove this log,"Let's add a constant for ""version 2""",@snleee This is handled with the API refreshSegment(),rename 'variableName'
public long forceNext() { long l = longs.incrementAndGet(INDEX_HEAD); if (((l >> 3) << 3) == l && concurrentInvocations() > 10) { concurrencyDetection.onDetected(); } return l; },"minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.","Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,I think it would be good to perform this logic in OutputEmitter.,nit: any chance to make the message assertion more specific? :),How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,Similar to DistinctCountAggregator,Out of interest why can you not do BuiltinAggregator.values()?,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,"this is followup of above, it should not be required.","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?"
public boolean needsSequentialWriting() { return !vfsList.get(0).getCapabilities().contains(Capabilities.PARALLEL_WRITE); },Why not use capabilities directly here?,any reason for disabling cache for descending order queries ?,A future refactor might place this method in the enum directly.,"This bloc of code is repeated many times, should be centralized in a single method.",this can be reduced to protected.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,It would have been shorter to inline this variable and not have it in scope. :-),"To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,I think it would be good to perform this logic in OutputEmitter.
"private static NewIssueLocation locationForIssue(InputFile inputFile, HtmlIssue issue, NewIssue newIssue) { NewIssueLocation location = newIssue.newLocation() .on(inputFile) .message(issue.message()); Integer line = issue.line(); if (issue.startColumn() != null) { location.at(inputFile.newRange(issue.line(), issue.startColumn(), issue.endLine(), issue.endColumn())); } else if (line != null) { location.at(inputFile.selectLine(line)); } return location; }","Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!","Maybe using a constant here for ""://""",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,not good to add sth when calling getter,"[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",Put the test in the same package (not directory) and you can at least use package private or protected,Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
public FbChain(final Iterable<Fallback> fallbacks) { super( new Fallback() { @Override public Opt<Response> route(final RqFallback req) throws IOException { Opt<Response> rsp = new Opt.Empty<Response>(); for (final Fallback fbk : fallbacks) { final Opt<Response> opt = fbk.route(req); if (opt.has()) { rsp = new Opt.Single<Response>(opt.get()); break; } } return rsp; } } ); },@ekondrashev why not just rsp = opt?,I think we need to close this InputStream at some point,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"UDP is a datagram protocol, so it doesn't require frame decoder.",The same.,static import,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",Do not try to parse the sever list if the command has failed (mStatus.code != 0),"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,ImplUtils has a isNullOrEmpty method that should handle these checks.
"protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); Boolean dbShouldBeUpdated = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }",Why use a java.lang.Boolean and not a primitive boolean?,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",power down,suggestion deletedAlarmIds.forEach(alarmId -> {,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.","verify(client != null, ""client cannot be null"");",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Make sure to unescape the url path before using it. I've hit this in actual usage.,Why do we handle error like this?,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?"
"public void modifyAST(IIndex index, IMarker marker) { IASTTranslationUnit ast; try { ITranslationUnit tu = getTranslationUnitViaEditor(marker); ast = tu.getAST(index, ITranslationUnit.AST_SKIP_INDEXED_HEADERS); } catch (CoreException e) { CheckersUiActivator.log(e); return; } IASTNode astNode = null; if (isCodanProblem(marker)) { astNode = getASTNodeFromMarker(marker, ast); } if (astNode == null || !(astNode instanceof IASTCastExpression)) { return; } ASTRewrite r = ASTRewrite.create(ast); INodeFactory factory = ast.getASTNodeFactory(); IASTCastExpression oldcast = (IASTCastExpression) astNode; IASTCastExpression newcast = factory.newCastExpression(getCastType(), oldcast.getTypeId().copy(CopyStyle.withLocations), oldcast.getOperand().copy(CopyStyle.withLocations)); r.replace(oldcast, newcast, null); Change c = r.rewriteAST(); try { c.perform(new NullProgressMonitor()); } catch (CoreException e) { CheckersUiActivator.log(e); return; } try { marker.delete(); } catch (CoreException e) { CheckersUiActivator.log(e); } }",merge the try/catch with the one below?,This seems to be unnecessary. I also get the label after removing this.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,Remove /Dev Team,We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,@snleee This is handled with the API refreshSegment(),why var4? Resources.NotFoundException e would be a bit nicer..,fetch should already happen in Service,The output of this call should be checked and if it's false I think it should bail.,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",read the values and validate
"synchronized public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) { List<String> newSegments = new ArrayList<>(); for (String onlineSegment : onlineSegments) { if (!_segmentToTimeRangeMSCache.containsKey(onlineSegment)) { newSegments.add(onlineSegment); } } List<String> newSegmentZKMetadataPaths = new ArrayList<>(); for (String segment: newSegments) { newSegmentZKMetadataPaths.add(_segmentZKMetadataPathPrefix + segment); } List<ZNRecord> znRecords = _propertyStore.get(newSegmentZKMetadataPaths, null, AccessOption.PERSISTENT, true); for (int i = 0; i < newSegments.size(); i++) { String segment = newSegments.get(i); Interval range = extractTimeRangeMSFromSegmentZKMetaZNRecord(segment, znRecords.get(i)); _segmentToTimeRangeMSCache.put(segment, range); } _segmentToTimeRangeMSCache.keySet().retainAll(onlineSegments); _timeRangeMSToSegmentSearchTree = new IntervalST<String>(_segmentToTimeRangeMSCache); }",@snleee This is handled with the API refreshSegment(),What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,what is a PropertyValueWrapper? Why do you need it?,This seems to be unnecessary. I also get the label after removing this.,Iffy formatting,suggestion deletedAlarmIds.forEach(alarmId -> {,why var4? Resources.NotFoundException e would be a bit nicer..,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",consider using a switch(res) {...},"verify(client != null, ""client cannot be null"");"
"private TracingContext traceToMap(Map<String, Object> map) { long startParse = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - startParse; long startOffset = now - startRequestNanos; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }",Probably just wants to be start or startPhase or something if now generic.,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,"This bloc of code is repeated many times, should be centralized in a single method.",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?",why swallowing?,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,"this is followup of above, it should not be required.",I think it would be good to perform this logic in OutputEmitter.
"public void testIllegalMinMax() { try { new FixedDoubleHistogram(-200, 3.0, 3.0); fail(""exception expected""); } catch (IllegalArgumentException e) { assertTrue(e.getMessage().contains(""bucketCount"")); } }",nit: any chance to make the message assertion more specific? :),There should be a space here between expected and school.roster(),Why this change?,@Serranya The same here. See above.,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",Could you use Strings.repeat or something?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,check to make sure notificationUUID is not null,assertEquals and remove the expected value from message string,"if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task."
"public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(baseDir, false); return p4.latestChange(); }","We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }","This bloc of code is repeated many times, should be centralized in a single method.",Why not use capabilities directly here?,nit: unnecessary generic type declaration,Floating semicolon,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,I think it would be good to perform this logic in OutputEmitter.,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");","Should this support a null address? Same with the other one, which make support a null or empty address.",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public void putJobCompletedNotification() throws IOException, SignatureException { UUID notificationUUID = null; try { final PutJobCompletedNotificationRegistrationSpectraS3Response response = client .putJobCompletedNotificationRegistrationSpectraS3( new PutJobCompletedNotificationRegistrationSpectraS3Request(""test@test.test"")); notificationUUID = response.getJobCompletedNotificationRegistrationResult().getId(); assertThat(response.getStatusCode(), is(201)); } finally { client.deleteJobCompletedNotificationRegistrationSpectraS3( new DeleteJobCompletedNotificationRegistrationSpectraS3Request(notificationUUID)); } }",check to make sure notificationUUID is not null,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,The Exception is never thrown.,Please change user back to USER_YODA here.,do you clean up these files on exit? or the root level dir is deleted on exit ?,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,This commandContext seems unused.,ImplUtils has a isNullOrEmpty method that should handle these checks.,It's better to use **isBlank** here
"public static Pair<Boolean, String> checkFingerPrint(String expected, PublicKey key) throws Exception { if (key == null) { return null; } if (expected == null) { return new Pair<>(false, getFingerPrint(key)); } String comps[] = expected.split("":"", 2); DigestFactory factory; if (comps[0].length() > 2) { factory = BuiltinDigests.fromString(comps[0]); if (factory == null) { return new Pair<>(false, getFingerPrint(key)); } } else { factory = BuiltinDigests.md5; expected = ""MD5:"" + expected; } String fingerprint = getFingerPrint(factory, key); return new Pair<>(expected.equals(fingerprint), fingerprint); }","java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }",Suggest JSON related capabilities be isolated to the JsonUtil class.,might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,Extra space,ImplUtils has a isNullOrEmpty method that should handle these checks.,Is toString() required? It's already of STRING type.,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","Maybe using a constant here for ""://""",Similar to DistinctCountAggregator,Style nit: unneeded curlies,Log/throw?
private boolean isValidationNecessaryOnReads(TableReference tableRef) { return isValidationNecessary(tableRef) && validateLocksOnReads; },"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",any reason for disabling cache for descending order queries ?,this can be reduced to protected.,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.","don't return NULL, throw UnsupportedOperatedException instead",Remove cast,"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",should be possible to provide one,Is there a reason this isn't implemented?,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());"
"public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }",We don't need super here,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Need to remove this leftover debug output,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),magic number,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Should we also validate that DataType != null.,It would have been shorter to inline this variable and not have it in scope. :-),Why does this need to be ordered by the synthetic primary key?,I think it would be good to perform this logic in OutputEmitter.,this.redisTemplate
public boolean isEnabled() { GitHistoryPage page = getPage(); if (page == null) return false; String head; try { head = page.getInputInternal().getRepository().getFullBranch(); } catch (IOException e) { head = null; } IStructuredSelection sel = getSelection(page); if (sel.size() != 1) return false; Object o = sel.getFirstElement(); if (!(o instanceof PlotCommit)) return false; PlotCommit commit = (PlotCommit) o; int refCount = commit.getRefCount(); for (int i = 0; i < refCount; i++) { String refName = commit.getRef(i).getName(); if (refName.equals(head)) continue; if (refName.startsWith(Constants.R_HEADS) || refName.startsWith(Constants.R_REMOTES)) return true; } return false; },Does it make sense to continue here? Or just return false.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",Suggest JSON related capabilities be isolated to the JsonUtil class.,you can use parameterized logging here,UtilKtKt isn't a great name.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.","That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?","Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,rename 'variableName',No need to explicitly load tables with query if you are using the latest build
"public void testStartProcessFromNodeIdsWithTimer() throws Exception { final String processId = ""simple.restartWithTimer""; assertNotNull(deploymentService); KModuleDeploymentUnit deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION); deploymentService.deploy(deploymentUnit); units.add(deploymentUnit); assertNotNull(processService); Long processInstanceId = processService.startProcess(deploymentUnit.getIdentifier(), processId, singletonMap(""var_a"", 3)); assertNotNull(processInstanceId); Thread.sleep(3000); processService.abortProcessInstance(processInstanceId); Collection<NodeInstanceDesc> timed = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.SKIPPED, new QueryContext(0, 0)); assertThat(timed.size(), is(1)); Collection<NodeInstanceDesc> aborted = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.ABORTED, new QueryContext(0, 0)); assertThat(aborted.size(), is(1)); String[] nodeIds = aborted.stream().map(e -> e.getNodeId()).toArray(String[]::new); processInstanceId = processService.startProcessFromNodeIds(deploymentUnit.getIdentifier(), processId, singletonMap(""var_a"", 3), nodeIds); runtimeDataService.getTasksByProcessInstanceId(processInstanceId).forEach(e -> { Task task = this.userTaskService.getTask(e); assertThat(task.getName(), is(""Third Task"")); this.userTaskService.start(e, ""katy""); this.userTaskService.complete(e, ""katy"", emptyMap()); }); ProcessInstance pi = processService.getProcessInstance(processInstanceId); assertNull(pi); }",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Please don't do unrelated refactor work next time,Should TREEHASH be a HashCode?,Sounds like a workaround for host misconfiguration issue.,"EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Why use a java.lang.Boolean and not a primitive boolean?,suggestion deletedAlarmIds.forEach(alarmId -> {,"verify(client != null, ""client cannot be null"");",power down
"protected boolean isAnyAppConfiguredInSourceServerXml() { boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); bConfigured = true; } return bConfigured; }","Here I would just say return true. Then fall through return false, instead of creating a variable.",consider 'ternary if' here,Suggest JSON related capabilities be isolated to the JsonUtil class.,Put the test in the same package (not directory) and you can at least use package private or protected,The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,No need to explicitly load tables with query if you are using the latest build,Replace with logger,do you clean up these files on exit? or the root level dir is deleted on exit ?,not a field,The same.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"protected void exportAsContext() { if (EDatabaseConnTemplate.isSchemaNeeded(getConnection().getDatabaseType()) && schemaText != null && StringUtils.isEmpty(schemaText.getText())) { MessageDialog.openWarning(getShell(), Messages.getString(""AbstractForm.ExportAsContext""), Messages.getString(""DatabaseForm.checkSchema"")); } collectContextParams(); super.exportAsContext(); }",It's better to use **isBlank** here,suggestion this.ignoreAbove = mw.ignoreAbove;,this should be on System.err,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,This commandContext seems unused.,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",The Exception is never thrown.,Could you please rename also _result?,what's the reason for this extra variable container?,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap"
"public boolean validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().asConvertible().integer(); getModel().getNumOfDesktops().validateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().getMaxAssignedVmsPerUser().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 1000000) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid()); getModel().setIsPoolTabValid(true); return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid(); }",also here please use Short.MAX_VALUE,Why use a java.lang.Boolean and not a primitive boolean?,power down,"Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0",@jomarko Thanks.. I'd have made this Integer.class.getName() too,Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e),"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",call intValue() and then there is no cast,"EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>","verify(client != null, ""client cannot be null"");",Conditional is more clear as: !getZooKeeperInstance().isEmpty()
private void doConcurrentPutInTx(String s) throws Exception { for (int i = 0; i < totalNumberOfBuckets; i++) { synchronized (list) { list.add(i); } } Thread[] threads = new Thread[totalNumberOfBuckets]; for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i] = new Thread(() -> doPutOpInTx(s)); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].start(); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].join(); } },"This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()",Do not try to parse the sever list if the command has failed (mStatus.code != 0),"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",@ekondrashev why not just rsp = opt?,do you clean up these files on exit? or the root level dir is deleted on exit ?,static import,How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,Replace with logger,Wrapper#getX() : float Use float instead of double.,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,why swallowing?
"private void addEditLink(WebMvcLinkBuilder selfLinkBuilder, GoalDto goalResource) { goalResource.add(selfLinkBuilder.withRel(JsonRootLinkRelationProvider.EDIT_REL)); }",Here too we may use IanaLinkRelation.EDIT?,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),any reason for disabling cache for descending order queries ?,"To match the old format, do ""Network parameters:\n "" here.",It would have been shorter to inline this variable and not have it in scope. :-),A future refactor might place this method in the enum directly.,Floating semicolon,"add ""balanced"" ?",Why not use capabilities directly here?,this can be reduced to protected.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.
"public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = """"; mFloppyPath = """"; mRunAndPause = false; _diskSize = 0; }",coudl be just ArrayList since now it is imported ^^ vv,Do not try to parse the sever list if the command has failed (mStatus.code != 0),Suggest JSON related capabilities be isolated to the JsonUtil class.,consider 'ternary if' here,"Json -> ""JSON"" (do a search-n-replace)",I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,The same.,ImplUtils has a isNullOrEmpty method that should handle these checks.,This can be removed? (Being added later.),@ekondrashev why not just rsp = opt?,Replace with logger
"private void setCurentCommitInfo(String revision) { fCommitInfo.reset(); Iterator<Map.Entry<String, RevisionInfo>> itr1 = fRevisions.entrySet().iterator(); while (itr1.hasNext()) { Entry<String, RevisionInfo> entry = itr1.next(); if (entry.getKey().equals(revision)) { System.out.println(""Looking at the Current patchset : "" + entry.getValue().getNumber()); fCommitInfo.setCommit(revision); fCommitInfo.setMessage(entry.getValue().getCommit().getMessage()); fCommitInfo.setParents(entry.getValue().getCommit().getParents()); fCommitInfo.setAuthor(entry.getValue().getCommit().getAuthor()); fCommitInfo.setCommitter(entry.getValue().getCommit().getCommitter()); } else { System.out.println(""Looking at the other patchset : "" + entry.getValue().getNumber()); } } }",log,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",this should be on System.err,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,columnStatistics,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,suggestion this.ignoreAbove = mw.ignoreAbove;,"Let's add a constant for ""version 2""","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")"
"public void testQueryProcessByVariables() { Map<String, Object> variables = Collections.<String, Object> singletonMap(""var_a"", ""a1""); Map<String, Object> attributes = Collections.<String, Object> singletonMap(""processId"", ""test.test_A""); List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext()); Assert.assertEquals(3, data.size()); for (ProcessInstanceWithVarsDesc p : data) { Assert.assertEquals(""a1"", p.getVariables().get(""var_a"")); Assert.assertEquals(""test.test_A"", p.getProcessId()); } }","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",log,this should be on System.err,suggestion this.ignoreAbove = mw.ignoreAbove;,The Exception is never thrown.,This commandContext seems unused.,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",columnStatistics,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,Could you please rename also _result?,It's better to use **isBlank** here
"void updateThreadPoolSize(int numThreads) { m_scheduler.setCorePoolSize(numThreads); LOG.info(""Updated PBD to use "" + numThreads + "" threads to enforce retention policy""); }",Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,Floating semicolon,nit: unnecessary generic type declaration,"To match the old format, do ""Network parameters:\n "" here.","Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",Why not use capabilities directly here?,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,"This bloc of code is repeated many times, should be centralized in a single method.",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,I think it would be good to perform this logic in OutputEmitter.
"protected void postProcessHeaderLines() { final List<String> headerLines = getHeaderLines(); final Pattern blankLine = Pattern.compile(EMPTY_LINE_PATTERN); for (final String line : headerLines) { try { if (line.isEmpty()) { headerRegexps.add(blankLine); } else { headerRegexps.add(Pattern.compile(line)); } } catch (final PatternSyntaxException ex) { throw new IllegalArgumentException(""line "" + (headerRegexps.size() + 1) + "" in header specification"" + "" is not a regular expression"", ex); } } }","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",suggestion this.ignoreAbove = mw.ignoreAbove;,Add invariants,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",you can use parameterized logging here,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",this should be on System.err,log,"Let's add a constant for ""version 2""",columnStatistics,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace."
"public void setActivePart(IAction action, IWorkbenchPart targetPart) { if(targetPart instanceof IMavenProjectHolder) { this.projectHolder = (IMavenProjectHolder) targetPart; } else { this.projectHolder = null; } }",I don't like IMavenProjectHolder. I think targetPart.getAdapter(MavenProject.class) is more appropriate here.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,A future refactor might place this method in the enum directly.,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),nit: unnecessary generic type declaration,"We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }","a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",It would have been shorter to inline this variable and not have it in scope. :-),Floating semicolon,Here too we may use IanaLinkRelation.EDIT?,I think it would be good to perform this logic in OutputEmitter.
"private void parseConfiguration(Config config, FailureCollector collector) { if (!config.defaults.isEmpty()) { String[] defaultsList = config.defaults.split("",""); for (String defaultValue : defaultsList) { String[] defaultsArray = defaultValue.split("":""); if (defaultsArray.length != 2) { collector.addFailure( String.format(""Invalid default: %s."", defaultValue), ""Defaults should contain source field and its corresponding default "" + ""value in the format: <source-field>:<default-value>[,<source-field>:<default-value>]* "" + ""For example: lang_code:English,country_code:Britain"").withConfigElement(DEFAULTS, defaultValue); } else { defaultsMapping.put(defaultsArray[0], defaultsArray[1]); } } } String[] mappingArray = config.mapping.split("",""); for (String mapping : mappingArray) { String[] mappingValueArray = mapping.split("":""); if (mappingValueArray.length != 3) { collector.addFailure(String.format(""Invalid mapping: %s."", mapping), ""Mapping should contain source field, lookup table name, "" + ""and target field in the format: "" + ""<source-field>:<lookup-table-name>:<target-field>"" + ""[,<source-field>:<lookup-table-name>:<target-field>]* "" + ""For example: lang_code:language_code_lookup:lang_desc,"" + ""country_code:country_lookup:country_name"").withConfigElement(MAPPING, mapping); } else { String defaultValue = null; if (defaultsMapping.containsKey(mappingValueArray[0])) { defaultValue = defaultsMapping.get(mappingValueArray[0]); } ValueMapping valueMapping = new ValueMapping(mappingValueArray[2], mappingValueArray[1], defaultValue); mappingValues.put(mappingValueArray[0], valueMapping); } } collector.getOrThrowException(); }","indentation, here and rest of PR",throw exception?,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,log,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",edgeCacheDNS as a static variable since it's used a few times?,This statement slot.getValueList().getValue()) could cause an NPE,"Let's add a constant for ""version 2""","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle."
"public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(""eventData cannot be null.""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }",Replace with Objects.requireNotNull.,please use long,Replace with logger,Please change user back to USER_YODA here.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"I see no reason to introduce msg here, you could just use serializedPayload",Suggest JSON related capabilities be isolated to the JsonUtil class.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"private static void doAppendEscapedIdentifier(Appendable sbuf, String value) throws SQLException { try { sbuf.append('""'); for (char ch : value.toCharArray()) { if (ch == '\0') { throw new PSQLException(GT.tr(""Zero bytes may not occur in identifiers.""), PSQLState.INVALID_PARAMETER_VALUE); } if (ch == '""') { sbuf.append(ch); } sbuf.append(ch); } sbuf.append('""'); } catch (IOException e) { throw new PSQLException(GT.tr(""No IOException expected from StringBuffer or StringBuilder""), PSQLState.UNEXPECTED_ERROR, e); } }",I wonder if this change would result array allocation and extra cpu/memory consumption issues,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",@ikhvostenkov please name it json,Why do we handle error like this?,I assume this was meant to be removed?,Unrelated change. Should be in a separate commit.,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",columnStatistics,this should be on System.err,These could be renamed to not use nonAscii.
"public void shouldScheduleDelayedActionOnHandlerThread() { Handler handler = mock(Handler.class); @SuppressWarnings(""unchecked"") Action0 action = mock(Action0.class); Scheduler scheduler = HandlerScheduler.create(handler); Worker inner = scheduler.createWorker(); inner.schedule(action, 1L, TimeUnit.SECONDS); ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class); verify(handler).postDelayed(runnable.capture(), eq(1000L)); runnable.getValue().run(); verify(action).call(); }",May be static imports for TimeUnit values here and below?,"Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.",Out of interest why can you not do BuiltinAggregator.values()?,@Serranya The same here. See above.,"if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",The Exception is never thrown.,@ikhvostenkov please name it json,what's the reason for this extra variable container?,Could you please rename also _result?
"public void aggregate(ByteBuffer buf, int position) { boolean countNulls = !selector.nameLookupPossibleInAdvance() || NullHandlingHelper.useDefaultValuesForNull(); MutableBitmap mutableBitmap = getMutableBitmap(position); IndexedInts row = selector.getRow(); for (int i = 0; i < row.size(); i++) { int index = row.get(i); if (countNulls || selector.lookupName(index) != null) { mutableBitmap.add(index); } } buf.putLong(position, mutableBitmap.size()); }",Similar to DistinctCountAggregator,Style nit: unneeded curlies,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,not a field,consider 'ternary if' here,[minor] could you name it resourceGroupName,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,suggestion this.ignoreAbove = mw.ignoreAbove;,The Exception is never thrown.,isn't the topology always a LocalizedCacheTopology?,Could you please rename also _result?
"private List<ModelNode> adjustInfinispan(final PathAddress subsystem) throws Exception { final List<ModelNode> list = new ArrayList<>(); list.add(getWriteAttributeOperation(subsystem.append(""cache-container"", ""server"").append(""transport"", ""jgroups""), ""stack"", new ModelNode(""udp""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""server""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""server"").append(""replicated-cache"", ""default""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""web""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""web"").append(""distributed-cache"", ""dist""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""ejb""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""ejb"").append(""distributed-cache"", ""dist""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""invalidation-cache"", ""entity""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""local-cache"", ""local-query""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""replicated-cache"", ""timestamps""))); return list; }","Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0","EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>",@jomarko Thanks.. I'd have made this Integer.class.getName() too,Please remove debug codes.,Should TREEHASH be a HashCode?,Why use a java.lang.Boolean and not a primitive boolean?,suggestion deletedAlarmIds.forEach(alarmId -> {,call intValue() and then there is no cast,also here please use Short.MAX_VALUE,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",power down
"EventBus eventBus() { EventBus bus = new EventBus((exception, context) -> exception.printStackTrace()); bus.register(new DeadEventHandler()); return bus; }",printStackTrace() must not be used. Use a logger instead.,Floating semicolon,"This bloc of code is repeated many times, should be centralized in a single method.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),this can be reduced to protected.,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,A future refactor might place this method in the enum directly.,I think it would be good to perform this logic in OutputEmitter.,Should we also validate that DataType != null.
"ObjectLoader openPackedObject(WindowCursor curs, AnyObjectId objectId) { PackList pList; do { pList = packList.get(); SEARCH: for (;;) { for (PackFile p : pList.packs) { try { ObjectLoader ldr = p.get(curs, objectId); if (ldr != null) return ldr; } catch (PackMismatchException e) { PackList nList = scanPacks(pList); if (pList != nList) { pList = nList; continue SEARCH; } } catch (IOException e) { removePack(p); } } break SEARCH; } } while (searchPacksAgain(pList)); return null; }",I think this could just be: if (searchPacksAgain(pList)) continue SEARCH;,Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?,This seems to be unnecessary. I also get the label after removing this.,Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,Add invariants,Two ;;,why var4? Resources.NotFoundException e would be a bit nicer..,@snleee This is handled with the API refreshSegment(),No need to explicitly load tables with query if you are using the latest build,rename 'variableName'
"public void bufferExactFailingSupplier() { Scheduler.Worker w = new TestScheduler().createWorker(); TestSubscriber<List<Integer>> observer = new TestSubscriber<List<Integer>>(); FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>> buf = new FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>>(observer, ArrayListSupplier.<Integer>asCallable(), 100, TimeUnit.MILLISECONDS, 10, false, w); buf.onError(new Throwable()); buf.onComplete(); }","The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;",May be static imports for TimeUnit values here and below?,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",nit: any chance to make the message assertion more specific? :),@Serranya The same here. See above.,check to make sure notificationUUID is not null,The Exception is never thrown.,static import,Out of interest why can you not do BuiltinAggregator.values()?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,what's the reason for this extra variable container?
"private Image getImageForDraw() { if (sprite.look.getLookData() != null) { if (sprite.look.getLookData().getCollisionInformation().getLeftBubblePos() == null || sprite.look.getLookData().getCollisionInformation().getRightBubblePos() == null) { sprite.look.getLookData().getCollisionInformation().loadOrCreateCollisionPolygon(); } CollisionInformation collisionInformation = sprite.look.getLookData().getCollisionInformation(); Pair<Integer, Integer> bubblePosRight = collisionInformation.getRightBubblePos(); Pair<Integer, Integer> bubblePosLeft = collisionInformation.getLeftBubblePos(); imageLeft.setX(calculateLeftImageX(bubblePosLeft.first)); imageLeft.setY(calculateImageY(bubblePosLeft.second)); imageRight.setX(calculateRightImageX(bubblePosRight.first)); imageRight.setY(calculateImageY(bubblePosRight.second)); } else { if (drawRight) { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() + (sprite.look .getWidthInUserInterfaceDimensionUnit() / 2)); } else { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() - sprite.look .getWidthInUserInterfaceDimensionUnit() / 2 - image.getWidth()); } image.setY(sprite.look.getYInUserInterfaceDimensionUnit() + (sprite.look .getHeightInUserInterfaceDimensionUnit() / 2)); } return image; }",I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction(),Iffy formatting,Why parseDouble and then convert that to int instead of directly parsing to int ?,suggestion deletedAlarmIds.forEach(alarmId -> {,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,I think this test should be moved to options instead,Unrelated change. Should be in a separate commit.,Why use a java.lang.Boolean and not a primitive boolean?,Make sure to unescape the url path before using it. I've hit this in actual usage.,@snleee This is handled with the API refreshSegment(),Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.
"public static User toUser(DecodedJWT jwt) { final String subject = jwt.getSubject(); final List<Role> roles = jwt.getClaims().entrySet().stream() .filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) .map(entry -> { final String roleName = entry.getKey(); final Claim claim = entry.getValue(); final List<Permission> permissions = claim.asList(String.class).stream().map(Permission::valueOf).collect(Collectors.toList()); return new Role(roleName.substring(roleName.indexOf(""_"") + 1, roleName.length()), permissions); }).collect(Collectors.toList()); return new User(subject, roles); }","You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,","I don't think ""resolveMember"" should create a new symbol. We should find another approach",I think we need to close this InputStream at some point,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"The phrase ""repartition"" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data.",Shouldn't it be No handler was subscribed **for** command?,Log/throw?,"Json -> ""JSON"" (do a search-n-replace)",Suggest JSON related capabilities be isolated to the JsonUtil class.
"public void readInfo() { this.mvnInfo = null; this.mvnName = null; if (!infofile.exists()) { return; } try { final String content = FileUtils.readFileToString(infofile, Charsets.UTF_8); final int i = content.indexOf(','); LOGGER.log(Level.FINE, ""The "" + name + "" artifact info cached is: "" + content); if (i != -1) { this.mvnInfo = content.substring(0, i); this.mvnName = content.substring(i + 1); } else { LOGGER.log(Level.WARNING, ""The "" + name + "" artifact info is invalid""); } } catch (IOException e) { LOGGER.log(Level.WARNING, ""The "" + name + "" artifact info failed to be loaded"", e); } }",you can use parameterized logging here,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),this should be on System.err,Suggest JSON related capabilities be isolated to the JsonUtil class.,The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",This statement slot.getValueList().getValue()) could cause an NPE,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",columnStatistics,log,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace."
"private void refreshSignedOffBy() { String curText = commitText.getText(); if (signedOff) { commitText.setText(signOff(curText)); } else { String s = getSignedOff(); if (s != null) { curText = replaceSignOff(curText, s, EMPTY_STRING); if (curText.endsWith(Text.DELIMITER + Text.DELIMITER)) curText = curText.substring(0, curText.length() - Text.DELIMITER.length()); commitText.setText(curText); } } }",Style nit: unneeded curlies,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",It's better to use **isBlank** here,ImplUtils has a isNullOrEmpty method that should handle these checks.,Extra space,Similar to DistinctCountAggregator,"I would suggest providing more clue about the exception like  throw new IllegalArgumentException( ""startTimeNanos ["" + startTimeNanos + ""] should be greater than 0!"" );  to help debugger a little bit.","maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",consider 'ternary if' here,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.
"public void put(String key, String value) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); ops.set(value); }",this.redisTemplate,Need to remove this leftover debug output,We don't need super here,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),nit: unnecessary generic type declaration,This should be in the if(v != null) check I am thinking,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,magic number,Should we also validate that DataType != null.,I think it would be good to perform this logic in OutputEmitter.,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");"
"public ResponseEntity<?> createDilution(@RequestBody DilutionDto dilutionDto, UriComponentsBuilder b) throws IOException { if (dilutionDto == null) { log.error( ""Received null dilutionDto from front end; cannot convert to Dilution. Something likely went wrong in the JS DTO conversion.""); throw new RestException(""Cannot convert null to Dilution"", Status.BAD_REQUEST); } Long id = null; LibraryDilution dilution; try { dilution = Dtos.to(dilutionDto); dilution.setLibrary(libraryService.get(dilutionDto.getLibrary().getId())); id = populateAndSaveDilutionFromDto(dilutionDto, dilution, true); } catch (ConstraintViolationException e) { log.error(""Error while creating dilution"", e); RestException restException = new RestException(e.getMessage(), Status.BAD_REQUEST); restException.addData(""constraintName"", e.getConstraintName()); throw restException; } UriComponents uriComponents = b.path(""/library/{id}"").buildAndExpand(dilution.getLibrary().getId()); HttpHeaders headers = new HttpHeaders(); headers.setLocation(uriComponents.toUri()); headers.set(""Id"", id.toString()); return new ResponseEntity<>(headers, HttpStatus.CREATED); }",fetch should already happen in Service,"Good catch, thanks. Fixed <LINK_0>",just pass sparkJarFilePath.toString less number of changes will be required in the code.,Unrelated change. Should be in a separate commit.,Should TREEHASH be a HashCode?,remove this log,The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again.,merge the try/catch with the one below?,Remove /Dev Team,read the values and validate,The output of this call should be checked and if it's false I think it should bail.
"public void start(SocketAddress endpoint) throws IOException { if (isListening()) { throw new IllegalStateException(""Cannot start when already listening for messages""); } bindToAddress(endpoint); new Thread(() -> { while (!configServerSocket.isClosed()) { acceptConnection(); } }, ""configurationListener"").start(); }",thread.isUnterupted not necessary?,check to make sure notificationUUID is not null,"if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.","UDP is a datagram protocol, so it doesn't require frame decoder.","this is followup of above, it should not be required.",what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still","The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,This commandContext seems unused.,It's better to use **isBlank** here
"public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(""Launch batch job (makeUnique=false) twice""); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + "" --makeUnique=false""); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + "" --makeUnique=false"", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(""job launch --name "" + MY_JOB); System.out.println(""*************************"" + result.getException().getMessage()); assertThat( result.getException().getMessage(), containsString(""A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters."")); }",I assume this was meant to be removed?,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,I wonder if this change would result array allocation and extra cpu/memory consumption issues,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",Should TREEHASH be a HashCode?,this should be on System.err,Please don't do unrelated refactor work next time,assertEquals and remove the expected value from message string
"public List<GenericVertex> resolve(GraphService graphService, SearchCriteria searchCriteria) { GenericGraph graph = graphService.getGraph(searchCriteria.getNamespace()); return graph.getVertices() .stream() .map(ApplicationVertex::new) .filter(v -> filter(v, searchCriteria.getCriteria())) .map(ApplicationVertex::asGenericVertex) .collect(Collectors.toList()); }","What do we do, if the result is null?",nit: unnecessary generic type declaration,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,I think it would be good to perform this logic in OutputEmitter.,"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,"Should this support a null address? Same with the other one, which make support a null or empty address.",Should this not prefer the token over the raw?
"protected Location manageRecursive(Location loc, final ManagementTransitionMode initialMode) { AccessController.Response access = managementContext.getAccessController().canManageLocation(loc); if (!access.isAllowed()) { throw new IllegalStateException(""Access controller forbids management of ""+loc+"": ""+access.getMsg()); } if (log.isDebugEnabled()) { String msg = ""Managing location "" + loc + "" (""+initialMode+""), from "" + Tasks.current()+"" / ""+Entitlements.getEntitlementContext(); long count = LOCATION_CNT.incrementAndGet(); if (count % 100 == 0) { log.debug(msg, new Exception(""Informational stack trace of call to manage location ""+loc+"" (""+count+"" calls; ""+getLocations().size()+"" currently managed)"")); } else { log.debug(msg); } } recursively(loc, new Predicate<AbstractLocation>() { public boolean apply(AbstractLocation it) { ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId()); if (mode==null) { setManagementTransitionMode(it, mode = initialMode); } if (it.isManaged()) { if (mode==ManagementTransitionMode.CREATING) { return false; } else { } } boolean result = manageNonRecursive(it, null); if (result) { it.setManagementContext(managementContext); if (!mode.isReadOnly()) { it.onManagementStarted(); recordLocationEvent(it, Lifecycle.CREATED); } managementContext.getRebindManager().getChangeListener().onManaged(it); } return result; } }); return loc; }","I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",Sounds like a workaround for host misconfiguration issue.,this may impact web-ui code. Do we want to expose Snapshot in API?,Please don't do unrelated refactor work next time,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Remove /Dev Team,Should TREEHASH be a HashCode?,Please remove debug codes.,power down,suggestion deletedAlarmIds.forEach(alarmId -> {,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class."
"void start(int slot) { mSlot = slot; int error = isValid(); if (error == SUCCESS) { Log.d(TAG, ""Starting keepalive "" + mSlot + "" on "" + mNai.name()); switch (mType) { case TYPE_NATT: mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; case TYPE_TCP: mTcpController.startSocketMonitor(mFd, this, mSlot); mNai.asyncChannel .sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0 , mPacket); mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; default: Log.wtf(TAG, ""Starting keepalive with unknown type: "" + mType); } mStartedState = STARTING; } else { handleStopKeepalive(mNai, mSlot, error); return; } }",Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,remove this log,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Please change user back to USER_YODA here.,Two ;;,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"Good catch, thanks. Fixed <LINK_0>",This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,read the values and validate,Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0
"public NewTmfViewAction(TmfView view) { super(MessageFormat.format(Messages.TmfView_NewTmfViewNameText, view.getTitle().toLowerCase()), IAction.AS_PUSH_BUTTON); setToolTipText(MessageFormat.format(Messages.TmfView_NewTmfViewToolTipText, view.getTitle())); }",I think we always display view names capitalized to users.,There should be a space here between expected and school.roster(),It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,Out of interest why can you not do BuiltinAggregator.values()?,Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,It's better to use **isBlank** here,check to make sure notificationUUID is not null,This can be removed? (Being added later.),Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.
"public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(""message must be non-empty""); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(); } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }",Unrelated change. Should be in a separate commit.,Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,"Good catch, thanks. Fixed <LINK_0>",We tend to use IllegalArgumentException for these kind,I think this test should be moved to options instead,fetch should already happen in Service,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",@snleee This is handled with the API refreshSegment(),edgeCacheDNS as a static variable since it's used a few times?,columnStatistics,Conditional is more clear as: !getZooKeeperInstance().isEmpty()
"public CompletableFuture<Snapshot> copyTo(FileWrapper target, UserContext context) { ensureUnmodified(); NetworkAccess network = context.network; SafeRandom random = context.crypto.random; Hasher hasher = context.crypto.hasher; if (! target.isDirectory()) { return Futures.errored(new IllegalStateException(""CopyTo target "" + target + "" must be a directory"")); } return context.network.synchronizer.applyComplexUpdate(target.owner(), target.signingPair(), (base, committer) -> { return target.hasChildWithName(base.get(target.writer()).props, getFileProperties().name, network).thenCompose(childExists -> { if (childExists) { CompletableFuture<Snapshot> error = new CompletableFuture<>(); error.completeExceptionally(new IllegalStateException(""CopyTo target "" + target + "" already has child with name "" + getFileProperties().name)); return error; } if (isDirectory()) { byte[] newMapKey = random.randomBytes(32); SymmetricKey newBaseKey = SymmetricKey.random(); SymmetricKey newWriterBaseKey = SymmetricKey.random(); WritableAbsoluteCapability newCap = new WritableAbsoluteCapability(target.owner(), target.writer(), newMapKey, newBaseKey, newWriterBaseKey); SymmetricKey newParentParentKey = target.getParentKey(); return pointer.fileAccess.copyTo(base, committer, pointer.capability, newBaseKey, target.writableFilePointer(), target.entryWriter, newParentParentKey, newMapKey, network, random, hasher) .thenCompose(updatedBase -> { return target.addLinkTo(updatedBase, committer, getName(), newCap, network, random, hasher); }); } else { return base.withWriter(owner(), writer(), network).thenCompose(snapshot -> getInputStream(snapshot.get(writer()).props, network, random, x -> {}) .thenCompose(stream -> target.uploadFileSection(snapshot, committer, getName(), stream, false, 0, getSize(), Optional.empty(), false, network, random, hasher, x -> {}, target.generateChildLocations(props.getNumberOfChunks(), random)))); } }); }); }",this may impact web-ui code. Do we want to expose Snapshot in API?,fetch should already happen in Service,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",Should TREEHASH be a HashCode?,@snleee This is handled with the API refreshSegment(),suggestion deletedAlarmIds.forEach(alarmId -> {,Please remove debug codes.,why var4? Resources.NotFoundException e would be a bit nicer..,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,read the values and validate,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class."
"public void testBlogPosting() { onView(withText(""Log In"")) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserEmail), closeSoftKeyboard()); onView(withText(""Next"")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.login_enter_password)) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserPassword), closeSoftKeyboard()); onView(withText(""Next"")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(""Continue"")) .perform(click()); onView(withId(R.id.viewpager_main)) .perform(ViewPagerActions.scrollToFirst()); onView(withId(R.id.fab_button)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.title)) .perform(replaceText(""Hello""), closeSoftKeyboard()); onView(withId(R.id.aztec)) .perform(replaceText(""World""), closeSoftKeyboard()); onView(withId(R.id.menu_save_post)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.promo_dialog_button_positive)) .perform(click()); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(R.string.uploading_post)).inRoot(new ToastMatcher()) .check(matches(isDisplayed())); }",This seems to fail the test when SmartLock for Passwords pops up the dialog for selecting a saved email/pass combination.,Why do we handle error like this?,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Please don't use sysout. Logging is your friend.,assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?,also here please use Short.MAX_VALUE,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction(),@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail(),We tend to use IllegalArgumentException for these kind,Conditional is more clear as: !getZooKeeperInstance().isEmpty()
public void placeOnTop(Node pNode) { assert pNode != null; if( aType == DiagramType.SEQUENCE && pNode.getClass() == CallNode.class ) { return; } if( pNode.hasParent() ) { Node parent = pNode.getParent(); parent.placeLast(pNode); placeOnTop(parent); } else if( containsAsRoot(pNode) ) { removeRootNode(pNode); addRootNode(pNode); } },"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","Please make sure this is properly formatted. ""else"" should be on the same line as the }.","Should this support a null address? Same with the other one, which make support a null or empty address.",Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,The same.,@ekondrashev why not just rsp = opt?,Wrapper#getX() : float Use float instead of double.,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"Json -> ""JSON"" (do a search-n-replace)",Don't we need to reset alpha here? Drawables share a global state.
"public int[] downloadSetupConfigurationTemplate(String uuid){ int[] result = new int[2]; try { SetupConfigurationTemplate setupConfigurationTemplate = setupConfigurationController.downloadSetupConfigurationTemplate(uuid); result[0] = SyncStatusConstants.SUCCESS; if(setupConfigurationTemplate != null) { result[1] = 1; } System.out.println(""MuzimaSyncService: ""+setupConfigurationTemplate.getConfigJson()); setupConfigurationController.saveSetupConfigurationTemplate(setupConfigurationTemplate); } catch (SetupConfigurationController.SetupConfigurationDownloadException e){ Log.e(TAG, ""Exception when trying to download setup configs""); result[0] = SyncStatusConstants.DOWNLOAD_ERROR; } catch (SetupConfigurationController.SetupConfigurationSaveException e){ Log.e(TAG, ""Exception when trying to save setup configs""); result[0] = SyncStatusConstants.SAVE_ERROR; } return result; }",Replace with logger,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Suggest JSON related capabilities be isolated to the JsonUtil class.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Do we missing some enums here?,The same.,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",Replace with Objects.requireNotNull.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"I see no reason to introduce msg here, you could just use serializedPayload",do you clean up these files on exit? or the root level dir is deleted on exit ?
"public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); if (orientation != newConfig.orientation) { try { orientation = newConfig.orientation; getFragmentManager().beginTransaction().remove(this).commit(); getFragmentManager().beginTransaction() .replace(R.id.cover_fragment_container, CoverFragment.class.newInstance()) .commitAllowingStateLoss(); } catch (Exception e) { Log.e(TAG, ""onConfigurationChanged "" + e.toString()); } } }",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,This commandContext seems unused.,It's better to use **isBlank** here,suggestion this.ignoreAbove = mw.ignoreAbove;,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Add invariants,Let's do the same way @jleandroperez did on iOS here <LINK_0>,ImplUtils has a isNullOrEmpty method that should handle these checks.
"protected void serviceStart() throws Exception { super.serviceStart(); if (UserGroupInformation.isSecurityEnabled()) { delegationTokenManager.startThreads(); } InetSocketAddress connectAddress = NetUtils.getConnectAddress(this.heartbeatListener.getAddress()); URI connectUri = RecoverableRpcProxy.toConnectURI(connectAddress); FSRecoveryHandler recoveryHandler = new FSRecoveryHandler(dag.assertAppPath(), getConfig()); recoveryHandler.writeConnectUri(connectUri.toString()); try { org.mortbay.log.Log.setLog(null); } catch (Throwable throwable) { } try { Configuration config = getConfig(); if (SecurityUtils.isStramWebSecurityEnabled()) { config = new Configuration(config); config.set(""hadoop.http.filter.initializers"", StramWSFilterInitializer.class.getCanonicalName()); } addSSLConfigResource(config); WebApp webApp = WebApps.$for(""stram"", StramAppContext.class, appContext, ""ws"").with(config).start(new StramWebApp(this.dnmgr)); LOG.info(""Started web service at port: "" + webApp.port()); appMasterTrackingUrl = NetUtils.getConnectAddress(webApp.getListenerAddress()).getAddress().getCanonicalHostName() + "":"" + webApp.port(); if (ConfigUtils.isSSLEnabled(config)) { appMasterTrackingUrl = ""https://"" + appMasterTrackingUrl; } LOG.info(""Setting tracking URL to: "" + appMasterTrackingUrl); } catch (Exception e) { LOG.error(""Webapps failed to start. Ignoring for now:"", e); } }",Sounds like a workaround for host misconfiguration issue.,Why do we handle error like this?,Should TREEHASH be a HashCode?,Please don't do unrelated refactor work next time,We tend to use IllegalArgumentException for these kind,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",power down,"verify(client != null, ""client cannot be null"");","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",The output of this call should be checked and if it's false I think it should bail.
"protected void executeVdsBrokerCommand() { String storageDomainId = getParameters().getStorageDomainId().toString(); List<String> deviceList = getParameters().getDeviceList(); String[] deviceArray = deviceList.toArray(new String[deviceList.size()]); boolean isForce = getParameters().isForce(); boolean supportForceCreateVG = Config.<Boolean> getValue( ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString()); _result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray); proceedProxyReturnValue(); setReturnValue(_result.uuid); }",Could you please rename also _result?,It's better to use **isBlank** here,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",this should be on System.err,Similar to DistinctCountAggregator,The Exception is never thrown.,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Please change user back to USER_YODA here.,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,what's the reason for this extra variable container?
"public boolean addNextEvent(final MistEvent event, final Direction direction) { if (operatorChainManager != null && queue.isEmpty()) { operatorChainManager.insert(this); } return queue.add(new Tuple<>(event, direction)); }",I think it would be good to perform this logic in OutputEmitter.,"This bloc of code is repeated many times, should be centralized in a single method.",You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",Why not use capabilities directly here?,Floating semicolon,nit: unnecessary generic type declaration,A future refactor might place this method in the enum directly.,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public void freeUnderlyingResources() { int spi = mSpi.getSpi(); try { mSrvConfig .getNetdInstance() .ipSecDeleteSecurityAssociation( 0, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, 0, mConfig.getMarkMask()); } catch (RemoteException | ServiceSpecificException e) { Log.e(TAG, ""Failed to delete SA with ID: "" + mResourceId, e); } getResourceTracker().give(); }",I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,this should be on System.err,Could you please rename also _result?,assertEquals and remove the expected value from message string,what's the reason for this extra variable container?,"if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,isn't the topology always a LocalizedCacheTopology?,Two ;;,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?
"public void execute() { final Setting setting = getActionContext().getSetting(); final EObject eObject = setting.getEObject(); final EStructuralFeature eStructuralFeature = setting.getEStructuralFeature(); final List<?> containments = (List<?>) eObject.eGet(eStructuralFeature, true); final List<?> moveUpList = Arrays.asList( ((IStructuredSelection) getTableViewer().getSelection()).toArray()); sortSelectionBasedOnIndex(moveUpList, containments); final EditingDomain editingDomain = getActionContext().getEditingDomain(); for (final Object moveUpObject : moveUpList) { final int currentIndex = containments.indexOf(moveUpObject); if (currentIndex <= 0) { return; } editingDomain.getCommandStack() .execute( new MoveCommand( editingDomain, eObject, eStructuralFeature, currentIndex, currentIndex - 1)); } }",we should probably check in the canExecute whether we reached the start of the list,We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,Add invariants,Iffy formatting,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",merge the try/catch with the one below?,The output of this call should be checked and if it's false I think it should bail.,This seems to be unnecessary. I also get the label after removing this.,@snleee This is handled with the API refreshSegment(),is double call to structIsNull.toBooleanArray() intentional?,what is a PropertyValueWrapper? Why do you need it?
"protected Array createArrayOf(String typeName, Object[] array) { Connection connection = null; try { connection = getJdbcTemplate().getDataSource().getConnection(); return connection.createArrayOf(typeName, array); } catch (SQLException e) { throw new RuntimeException(e); } finally { if (connection != null) { try { connection.close();} catch (SQLException e) {} } } }","Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"Json -> ""JSON"" (do a search-n-replace)",why swallowing?,Wrapper#getX() : float Use float instead of double.,Should we also validate that DataType != null.,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,not good to add sth when calling getter
public byte[] serialize() { ByteBuffer buffer = ByteBuffer.allocate(9); buffer.put(TYPE_LONG); buffer.putLong(value); return buffer.array(); },magic number,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),"This bloc of code is repeated many times, should be centralized in a single method.",You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Why not use capabilities directly here?,this can be reduced to protected.,Need to remove this leftover debug output,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-)
"public ServiceReference[] getServiceReferences(String clazz, String filter) { ServiceReference[] refs = null; try { if (bundleContext != null) { refs = bundleContext.getServiceReferences(clazz, filter); } } catch (InvalidSyntaxException e) { if (log.isLoggable(Level.SEVERE)) { log.log(Level.SEVERE, e.getMessage(), e); } } return refs; }",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }","Please make sure this is properly formatted. ""else"" should be on the same line as the }.",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","What do we do, if the result is null?",why swallowing?,Put the test in the same package (not directory) and you can at least use package private or protected,not good to add sth when calling getter,Should we also validate that DataType != null.,For PerunObserver you can return all resources immediately.
"private boolean execute(final IProcessDMContext processDmc, final IDebugCommandRequest request) { try { fExecutor.execute(new DsfRunnable() { @Override public void run() { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null) { procService.terminate(processDmc, new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!getStatus().isOK()) { request.setStatus(getStatus()); request.done(); } else { WaitForTerminationJob job = new WaitForTerminationJob(fSession.getId(), request); job.schedule(); } }; }); } else { request.done(); } } }); } catch (RejectedExecutionException e) { request.done(); } return false; }",Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?,Let's do the same way @jleandroperez did on iOS here <LINK_0>,Two ;;,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,@ekondrashev why not just rsp = opt?
"void deleteProperty(AccumuloElement element, Property property, Authorizations authorizations) { if (!element.getFetchHints().isIncludeAllProperties()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), ""All Properties""); } if (!element.getFetchHints().isIncludeAllPropertyMetadata()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), ""All Property Metadata""); } Mutation m = new Mutation(element.getId()); elementMutationBuilder.addPropertyDeleteToMutation(m, property); addMutations(element, m); getSearchIndex().deleteProperty( this, element, PropertyDescriptor.fromProperty(property), authorizations ); if (hasEventListeners()) { queueEvent(new DeletePropertyEvent(this, element, property)); } }",Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,The Exception is never thrown.,"Good catch, thanks. Fixed <LINK_0>","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Could you please rename also _result?,isn't the topology always a LocalizedCacheTopology?,@snleee This is handled with the API refreshSegment(),columnStatistics,what's the reason for this extra variable container?,Should the condition here and the condition on 153 the same?
"public List<ExperimentSpotDesignReadSpec> list() { List expmts = this.getHibernateTemplate().find(""from ExperimentSpotDesignReadSpec as readSpec order by readSpec.experimentSpotDesignReadSpecId asc"" ); return expmts; }",Why does this need to be ordered by the synthetic primary key?,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Floating semicolon,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),this can be reduced to protected.,Why not use capabilities directly here?,any reason for disabling cache for descending order queries ?,It would have been shorter to inline this variable and not have it in scope. :-),A future refactor might place this method in the enum directly.,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public void testToFlowElement_autostart() throws Exception { final ReusableSubprocess definition = new ReusableSubprocess(); definition.getExecutionSet().setAdHocAutostart(new AdHocAutostart(true)); final View<BaseReusableSubprocess> view = new ViewImpl<>(definition, Bounds.create()); final Node<View<BaseReusableSubprocess>, ?> node = new NodeImpl<>(java.util.UUID.randomUUID().toString()); node.setContent(view); final PropertyWriter propertyWriter = tested.toFlowElement(node); assertTrue(CallActivityPropertyWriter.class.isInstance(propertyWriter)); assertTrue(CustomElement.autoStart.of(propertyWriter.getFlowElement()).get()); }",The Exception is never thrown.,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,@ikhvostenkov please name it json,Please change user back to USER_YODA here.,check to make sure notificationUUID is not null,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,not a field,what's the reason for this extra variable container?,Could you please rename also _result?,It's better to use **isBlank** here
"public static Date parseDate(String date, String format) { return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); }","Is a null check for the passed in ""date"" required here for safety?","Looks like a duplication to me. How about this.json().getString(""name"")?",Need to remove this leftover debug output,this can be reduced to protected.,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),magic number,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),Check for illegal arg or are we happy with a ClassCastException here?
public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); } return false; },"Since numberOfVotes can be null you should replace this with Objects.equals(numberOfVotes, other.numberOfVotes)",replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,This should be in the if(v != null) check I am thinking,"Is a null check for the passed in ""date"" required here for safety?",Check for illegal arg or are we happy with a ClassCastException here?,We don't need super here,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",Is there a reason this isn't implemented?,this.redisTemplate,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.
"public static void connect(Socket socket, SocketAddress endpoint, SocketAddress localAddr, int timeout) throws IOException { if (socket == null || endpoint == null || timeout < 0) { throw new IllegalArgumentException(""Illegal argument for connect()""); } SocketChannel ch = socket.getChannel(); if (localAddr != null) { Class localClass = localAddr.getClass(); Class remoteClass = endpoint.getClass(); Preconditions.checkArgument(localClass.equals(remoteClass), ""Local address %s must be of same family as remote address %s."", localAddr, endpoint); socket.bind(localAddr); } try { if (ch == null) { socket.connect(endpoint, timeout); } else { SocketIOWithTimeout.connect(ch, endpoint, timeout); } } catch (SocketTimeoutException ste) { throw new ConnectTimeoutException(ste.getMessage()); } catch (UnresolvedAddressException ue) { throw new UnknownHostException(ue.getMessage()); } if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) { LOG.info(""Detected a loopback TCP socket, disconnecting it""); socket.close(); throw new ConnectException( ""Localhost targeted connection resulted in a loopback. "" + ""No daemon is listening on the target port.""); } }",nit: call it uae?,This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,Unrelated change. Should be in a separate commit.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","Good catch, thanks. Fixed <LINK_0>",consider using a switch(res) {...},edgeCacheDNS as a static variable since it's used a few times?,I think this test should be moved to options instead,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",columnStatistics
"public void testReviewForm() throws ParseException { final DeliveryReviewView view = getDeliveryReviewView(); final DeliveryReviewView.DeliveryForm deliveryForm = view.getDelivery(); deliveryForm.setGrade(""4.0""); deliveryForm.setState(""Rejected""); deliveryForm.setCommentary(""Hello World!""); assertTrue(deliveryForm.getGrade() == 4.0D); assertEquals(Delivery.State.REJECTED, deliveryForm.getSelectedState()); assertEquals(""Hello World!"", deliveryForm.getCommentary()); }",Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,The Exception is never thrown.,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",check to make sure notificationUUID is not null,It's better to use **isBlank** here,Is toString() required? It's already of STRING type.,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",This can be removed? (Being added later.),consider 'ternary if' here,Style nit: unneeded curlies
"private static void addRequestParameter(SOAPFactory soapFactory, OMElement bodyFirstChild, OMNamespace ns, String key, Object parameter) { if (parameter instanceof DataHandler) { DataHandler dataHandler = (DataHandler)parameter; OMText dataText = bodyFirstChild.getOMFactory().createOMText( dataHandler, true); OMElement omElement = soapFactory.createOMElement(key, ns, bodyFirstChild); omElement.addChild(dataText); omElement.addAttribute(""filename"",((DataHandler) parameter).getDataSource().getName(),ns); omElement.addAttribute(""filename"", ((DataHandler) parameter).getDataSource().getName(), ns); } else { String textValue = parameter.toString(); soapFactory.createOMElement(key, ns, bodyFirstChild).setText( textValue); } }",repeating code line.,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Let's make this InternalServerError,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),Add invariants,the original code does not make toLowerCase(). Why did you add it?,Suggest JSON related capabilities be isolated to the JsonUtil class.,Can this be changed to createSubjectRoleAttribute?,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?
"public Future<Void> executeFailed(Stage stage, Class<?> executingClass, ConsumerRecord<byte[], byte[]> consumerRecord, Throwable error) { if (!withinToleranceLimits()) { errorHandlingMetrics.recordFailure(); markAsFailed(); throw new ConnectException(""Tolerance exceeded in the errant record reporter"", error); } context.consumerRecord(consumerRecord); context.currentContext(stage, executingClass); context.error(error); errorHandlingMetrics.recordError(); return context.report(); }","if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.",I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,The Exception is never thrown.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,assertEquals and remove the expected value from message string,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,"Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",isn't the topology always a LocalizedCacheTopology?,May be static imports for TimeUnit values here and below?,what's the reason for this extra variable container?,It's better to use **isBlank** here
"public OutputWriter createOutputWriter() { if (file.exists()) { ExcelDatastore datastore = new ExcelDatastore(file.getName(), new FileResource(file), file.getAbsolutePath()); try (final UpdateableDatastoreConnection connection = datastore.openConnection()) { final DataContext dataContext = connection.getDataContext(); final Schema[] schemas = dataContext.getSchemas(); if (schemas.length >= 1) { final String[] tableNames = schemas[1].getTableNames(); for (int i = 0; i < tableNames.length; i++) { if (tableNames[i].equals(sheetName)) { if (overwriteSheetIfExists) { final Table tableSheet = dataContext.getTableByQualifiedLabel(sheetName); final UpdateableDataContext updateableDataContext = connection .getUpdateableDataContext(); updateableDataContext.executeUpdate(new UpdateScript() { @Override public void run(UpdateCallback callback) { callback.dropTable(tableSheet).execute(); ; } }); } } } } } } String[] headers = new String[columns.length]; for (int i = 0; i < headers.length; i++) { headers[i] = columns[i].getName(); } return ExcelOutputWriterFactory.getWriter(file.getPath(), sheetName, columns); }","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)",is double call to structIsNull.toBooleanArray() intentional?,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),Why do we handle error like this?,We tend to use IllegalArgumentException for these kind,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.","Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"verify(client != null, ""client cannot be null"");",Sounds like a workaround for host misconfiguration issue.,power down
public boolean isQueryCacheable(Query query) { return !query.isDescending() && !unCacheable.contains(query.getType()); },any reason for disabling cache for descending order queries ?,Why not use capabilities directly here?,as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },this can be reduced to protected.,A future refactor might place this method in the enum directly.,"This bloc of code is repeated many times, should be centralized in a single method.",Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),Why does this need to be ordered by the synthetic primary key?
"public void testBacktickEscapedIdentifier() { assertTrue(CharFormatUtil.unescapeIdentifier(""``"").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier("""").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(""`s`"").equals(""s"")); assertTrue(CharFormatUtil.unescapeIdentifier(""`self`"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""`self"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""self`"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""``self`"").equals(""self"")); }",assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,The Exception is never thrown.,check to make sure notificationUUID is not null,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",@Serranya The same here. See above.,These could be renamed to not use nonAscii.,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail(),I wonder if this change would result array allocation and extra cpu/memory consumption issues
"protected void validateAuthenticationState(HttpClient httpClient) throws GerritLoginException { Optional<Cookie> cookie = findCookieWithName(LOGIN_COOKIE_NAME, httpClient); cookie.ifPresent(this::setXsrfCookie); if (!cookie.isPresent()) { if (CoreUtil.TEST_MODE) { System.err.println("" Authentication failed: "" + httpClient.getState()); } throw new GerritLoginException(); } }","maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,check to make sure notificationUUID is not null,static import,This commandContext seems unused.,"I would suggest providing more clue about the exception like  throw new IllegalArgumentException( ""startTimeNanos ["" + startTimeNanos + ""] should be greater than 0!"" );  to help debugger a little bit.",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,ImplUtils has a isNullOrEmpty method that should handle these checks.,It's better to use **isBlank** here,Replace with logger,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)"
"private void testGetForDeletedBlobWithoutIncludeExpiredOption(List<BlobId> blobIds) { try { store.get(blobIds, EnumSet.noneOf(StoreGetOptions.class)); assertTrue( ""get should fail for a expired blob, if StoreGetOptions.Store_Include_Expired is not set in get options"", false); } catch (StoreException e) { assertTrue( ""get for expired blob with with StoreGetOptions.Store_Include_Expired not set in get options should throw exception with "" + StoreErrorCodes.TTL_Expired + "" error code."", e.getErrorCode().equals(StoreErrorCodes.TTL_Expired)); } }",assertEquals and remove the expected value from message string,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,check to make sure notificationUUID is not null,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,"Good catch, thanks. Fixed <LINK_0>",isn't the topology always a LocalizedCacheTopology?,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still","if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.",this should be on System.err,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception."
public Publisher<Integer> createFailedPublisher() { return null; },should be possible to provide one,@Irenyak1 why return false here?,"don't return NULL, throw UnsupportedOperatedException instead","What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",Check for illegal arg or are we happy with a ClassCastException here?,Remove cast,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"public String name() { return Json.createReader(new StringReader(this.obj)) .readObject() .getString(""name""); }","Looks like a duplication to me. How about this.json().getString(""name"")?","add ""balanced"" ?",Why not use capabilities directly here?,"To match the old format, do ""Network parameters:\n "" here.",this can be reduced to protected.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Floating semicolon,curly braces aren't required,It would have been shorter to inline this variable and not have it in scope. :-),hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Why does this need to be ordered by the synthetic primary key?
"protected FieldBase(String name, DataType dataType) { if (CoreUtils.isNullOrEmpty(name)) { throw logger.logExceptionAsError(new IllegalArgumentException(""The name of field cannot be null"")); } this.name = name; this.dataType = dataType; }",Should we also validate that DataType != null.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,printStackTrace() must not be used. Use a logger instead.,nit: unnecessary generic type declaration,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Floating semicolon,Should this not prefer the token over the raw?,I think it would be good to perform this logic in OutputEmitter.,Why does this need to be ordered by the synthetic primary key?,this.redisTemplate
"public Map<?, ?> read() { final Yaml yaml = new Yaml(); final Map<String, String> properties = new HashMap<>(); try (InputStream in = inputStream) { yaml.loadAll(in).forEach((Object obj) -> this.loadValue(properties, """", obj)); return properties; } catch (IOException e) { throw new IllegalStateException(""Cannot load environment"", e); } }",I think we need to close this InputStream at some point,"Json -> ""JSON"" (do a search-n-replace)","You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",Suggest JSON related capabilities be isolated to the JsonUtil class.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,why swallowing?,Put the test in the same package (not directory) and you can at least use package private or protected,"UDP is a datagram protocol, so it doesn't require frame decoder.","Maybe using a constant here for ""://""",@ekondrashev why not just rsp = opt?,"in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?"
"private static String createOrUpdateAccountsAndWait(Collection<Account> accounts) throws Exception { String jsonFilePath = tempDirPath + File.separator + UUID.randomUUID().toString() + "".json""; writeAccountsToFile(accounts, jsonFilePath); int numOfAccounts = AccountUpdater.createOrUpdate(jsonFilePath, ZK_SERVER_ADDRESS, HELIX_STORE_ROOT_PATH, null, null); Thread.sleep(100); return numOfAccounts == -1 ? null : jsonFilePath; }",do you clean up these files on exit? or the root level dir is deleted on exit ?,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",you don't take any resourcees from player when buying dev card,check to make sure notificationUUID is not null,ImplUtils has a isNullOrEmpty method that should handle these checks.,The same.,Replace with logger,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",consider 'ternary if' here,Put the test in the same package (not directory) and you can at least use package private or protected,[minor] could you name it resourceGroupName
"private Integer extractCount(HttpServletRequest request) { Integer count = Integer.valueOf(getParameter(request, ""count"")); checkArgument(COUNT_RANGE.contains(count), ""'count' must be in range %s, was %s"", COUNT_RANGE, count); return count; }","in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,Probably just wants to be start or startPhase or something if now generic.,not good to add sth when calling getter,"Should this support a null address? Same with the other one, which make support a null or empty address.",I think it would be good to perform this logic in OutputEmitter.,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",why swallowing?,Put the test in the same package (not directory) and you can at least use package private or protected,I think we need to close this InputStream at some point,Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
private void dismissToast() { try { toast.cancel(); } catch (NullPointerException e) { ZLog.logException(e); } },hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),curly braces aren't required,this can be reduced to protected.,"This bloc of code is repeated many times, should be centralized in a single method.",It would have been shorter to inline this variable and not have it in scope. :-),as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,"add ""balanced"" ?",A future refactor might place this method in the enum directly.
"public boolean hasDeploymentSubModel(final String subsystemName, final PathElement address) { final Resource root = deploymentUnit.getAttachment(DEPLOYMENT_RESOURCE); final PathElement subsystem = PathElement.pathElement(SUBSYSTEM, subsystemName); return root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address); }","Should this support a null address? Same with the other one, which make support a null or empty address.","We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }","a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",nit: unnecessary generic type declaration,I think it would be good to perform this logic in OutputEmitter.,"in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",Put the test in the same package (not directory) and you can at least use package private or protected,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",why swallowing?,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"void scheduleKeepAliveHeartbeat() { Scheduler.get().scheduleFixedDelay(new RepeatingCommand() { @Override public boolean execute() { boolean sessionInUse = restApiSessionId != null; if (sessionInUse && refreshRestApiSession) { sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback()); refreshRestApiSession = false; } return sessionInUse; } }, SESSION_HEARTBEAT_MS); }","this is followup of above, it should not be required.","minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",May be static imports for TimeUnit values here and below?,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,Out of interest why can you not do BuiltinAggregator.values()?,check to make sure notificationUUID is not null,do you clean up these files on exit? or the root level dir is deleted on exit ?,[minor] could you name it resourceGroupName
"public void marriedKeychainBloomFilter() throws Exception { wallet = new Wallet(params); blockStore = new MemoryBlockStore(params); chain = new BlockChain(params, wallet, blockStore); String XPUB = ""xpub68KFnj3bqUx1s7mHejLDBPywCAKdJEu1b49uniEEn2WSbHmZ7xbLqFTjJbtx1LUcAt1DwhoqWHmo2s5WMJp6wi38CiF2hYD49qVViKVvAoi""; wallet.addFollowingAccounts(ImmutableList.of(DeterministicKey.deserializeB58(null, XPUB))); Address address = wallet.currentReceiveAddress(); assertTrue(wallet.getBloomFilter(1e-12).contains(address.getHash160())); Transaction t1 = createFakeTx(params, CENT, address); StoredBlock b1 = createFakeBlock(blockStore, t1).storedBlock; TransactionOutPoint outPoint = new TransactionOutPoint(params, 0, t1); assertFalse(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); wallet.receiveFromBlock(t1, b1, BlockChain.NewBlockType.BEST_CHAIN, 0); assertTrue(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); }","I should probably have asked this in the previous review, but why ""addFollowingAccounts""? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.",Please don't do unrelated refactor work next time,Should TREEHASH be a HashCode?,"Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0","EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",@jomarko Thanks.. I'd have made this Integer.class.getName() too,Why use a java.lang.Boolean and not a primitive boolean?,power down
"public boolean test(Object receiver, String property, Object[] args, Object expectedValue) { IMonitorControl monitor = null; if (receiver instanceof IMonitorControl) { monitor = (IMonitorControl) receiver; } else { if (selectedMonitorId != null) { monitor = MonitorControlManager.getInstance().getMonitorControl(selectedMonitorId); } } if (monitor != null) { if (IS_ACTIVE.equals(property)) { return monitor.isActive() == toBoolean(expectedValue); } } return false; }","Please make sure this is properly formatted. ""else"" should be on the same line as the }.",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,The same.,Is toString() required? It's already of STRING type.,"Json -> ""JSON"" (do a search-n-replace)","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB."
"public WorkspaceConfigImpl devFileToWorkspaceConfig(Devfile devfile) throws DevfileFormatException { validateCurrentVersion(devfile); WorkspaceConfigImpl config = new WorkspaceConfigImpl(); config.setName(devfile.getName()); List<ProjectConfigImpl> projects = new ArrayList<>(); devfile.getProjects().forEach(project -> projects.add(devProjectToProjectConfig(project))); config.setProjects(projects); Map<String, String> attributes = new HashMap<>(); StringJoiner pluginsStringJoiner = new StringJoiner("",""); StringJoiner toolIdToNameMappingStringJoiner = new StringJoiner("",""); for (Tool tool : devfile.getTools()) { switch (tool.getType()) { case EDITOR_TOOL_TYPE: attributes.put(WORKSPACE_TOOLING_EDITOR_ATTRIBUTE, tool.getId()); break; case PLUGIN_TOOL_TYPE: pluginsStringJoiner.add(tool.getId()); break; case KUBERNETES_TOOL_TYPE: continue; default: throw new DevfileFormatException( format(""Unsupported tool %s type provided: %s"", tool.getName(), tool.getType())); } toolIdToNameMappingStringJoiner.add(tool.getId() + ""="" + tool.getName()); } if (pluginsStringJoiner.length() > 0) { attributes.put(WORKSPACE_TOOLING_PLUGINS_ATTRIBUTE, pluginsStringJoiner.toString()); } if (toolIdToNameMappingStringJoiner.length() > 0) { attributes.put(ALIASES_WORKSPACE_ATTRIBUTE_NAME, toolIdToNameMappingStringJoiner.toString()); } config.setAttributes(attributes); List<CommandImpl> commands = new ArrayList<>(); devfile .getCommands() .forEach(command -> commands.addAll(devCommandToCommandImpls(devfile, command))); config.setCommands(commands); return config; }",throw exception?,@snleee This is handled with the API refreshSegment(),is double call to structIsNull.toBooleanArray() intentional?,just pass sparkJarFilePath.toString less number of changes will be required in the code.,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",suggestion deletedAlarmIds.forEach(alarmId -> {,"verify(client != null, ""client cannot be null"");","Let's add a constant for ""version 2""",I think this test should be moved to options instead,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.
"public void testGetTaskRawFormViaUIClient() throws Exception { long processInstanceId = processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID); assertThat(processInstanceId).isGreaterThan(0); try { List<TaskSummary> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); assertThat(tasks).isNotNull().hasSize(1); Long taskId = tasks.get(0).getId(); String result = uiServicesClient.getTaskRawForm( CONTAINER_ID, taskId ); logger.debug(""Form content is '{}'"", result); assertThat(result).isNotNull().isNotEmpty(); } finally { processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); } }",Please change user back to USER_YODA here.,check to make sure notificationUUID is not null,The Exception is never thrown.,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",columnStatistics,This commandContext seems unused.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,Could you please rename also _result?
"private void buyCard(GameUserBean gameUser, GameBean game, Map<String, String> returnedParams) throws PlayException, GameException { DevelopmentCards availableDevelopmentCards = game.getAvailableDevelopmentCards(); DevelopmentCard obtainedDevelopmentCard = cardUtil.pullDevelopmentCard(availableDevelopmentCards); DevelopmentCards usersDevelopmentCards = gameUser.getDevelopmentCards(); usersDevelopmentCards.increaseQuantityByOne(obtainedDevelopmentCard); availableDevelopmentCards.decreaseQuantityByOne(obtainedDevelopmentCard); returnedParams.put(""card"", obtainedDevelopmentCard.name()); }",you don't take any resourcees from player when buying dev card,Out of interest why can you not do BuiltinAggregator.values()?,check to make sure notificationUUID is not null,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",Replace with logger,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,do you clean up these files on exit? or the root level dir is deleted on exit ?,consider 'ternary if' here,[minor] could you name it resourceGroupName,Similar to DistinctCountAggregator,not a field
"public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(""Stream returnsCorrectInput!"").asBytes(); MatcherAssert.assertThat( ""Stream doesn't provide correct bytes"", new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }",@Serranya The same here. See above.,@ikhvostenkov please name it json,check to make sure notificationUUID is not null,The Exception is never thrown.,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",These could be renamed to not use nonAscii.,"Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.",nit: any chance to make the message assertion more specific? :),"The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;",May be static imports for TimeUnit values here and below?,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception."
"private void handleSelectorEvents(List<ResponseInfo> responseInfoList) { long handleSelectorEventsStartTimeMs = System.currentTimeMillis(); for (String connId : selector.connected()) { connectionTracker.checkInConnection(connId); } List<String> disconnectedList = selector.disconnected(); networkMetrics.connectionsDisconnectedCount.mark(disconnectedList.size()); for (String connId : disconnectedList) { connectionTracker.removeConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); if (requestMetadata != null) { responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), NetworkClientErrorCode.NetworkError, null)); } } for (NetworkReceive recv : selector.completedReceives()) { String connId = recv.getConnectionId(); connectionTracker.checkInConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), null, recv.getReceivedBytes().getPayload())); requestMetadata.onResponseReceive(); } networkMetrics.handleSelectorEventsTime.update(System.currentTimeMillis() - handleSelectorEventsStartTimeMs); }",What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,remove this log,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",suggestion deletedAlarmIds.forEach(alarmId -> {,I think this test should be moved to options instead,"verify(client != null, ""client cannot be null"");",the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Please remove debug codes.,throw exception?,@snleee This is handled with the API refreshSegment()
"public Void visitInstanceOf(InstanceOfTree node, Void p) { if (node.getType().getKind() == Kind.ANNOTATED_TYPE) { AnnotatedTypeMirror type = atypeFactory.fromExpression((ExpressionTree) node.getType()); if (type.hasAnnotation(Nullable.class)) { checker.reportError(node, ""instanceof.nullable.error""); } if (type.hasAnnotation(NonNull.class)) { checker.reportWarning(node, ""instanceof.nonnull.redundant""); } } return super.visitInstanceOf(node, p); }",Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","Json -> ""JSON"" (do a search-n-replace)",Is toString() required? It's already of STRING type.,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Suggest JSON related capabilities be isolated to the JsonUtil class.,The same.,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,"Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.
"public void onStartup(ServletContext servletContext) { LongTaskTimer longTaskTimer = LongTaskTimer .builder(""spring.cloud.dataflow.server"").description(""DataFlow duration timer"") .tags(Tags.empty()).register(Metrics.globalRegistry); this.longTaskSample = longTaskTimer.start(); if (StringUtils.hasText(dataSourceUrl) && dataSourceUrl.startsWith(""jdbc:h2:tcp://localhost:"")) { logger.info(""Start Embedded H2""); initH2TCPServer(); } }","Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",@ikhvostenkov please name it json,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",I think this test should be moved to options instead,This commandContext seems unused.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Sounds like a workaround for host misconfiguration issue.,Two ;;,this should be on System.err,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)","I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task."
"public String getJournalKeyFromDoi(String doi, Site site) { Map<String, Object> journalDoiRegexList = getJournalDoiRegexList(site); for (Map.Entry<String, Object> entry : journalDoiRegexList.entrySet()) { if (doi.matches(entry.getValue().toString())) { return entry.getKey(); } } return null; }","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",not good to add sth when calling getter,"What do we do, if the result is null?",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,Put the test in the same package (not directory) and you can at least use package private or protected,@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,"Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,"Maybe using a constant here for ""://"""
"private void addSidecar( PodData pod, CheContainer container, ChePlugin chePlugin, KubernetesEnvironment kubernetesEnvironment, Collection<CommandImpl> sidecarRelatedCommands) throws InfrastructureException { K8sContainerResolver k8sContainerResolver = new K8sContainerResolverBuilder() .setContainer(container) .setImagePullPolicy(sidecarImagePullPolicy) .setPluginName(chePlugin.getName()) .setPluginEndpoints(chePlugin.getEndpoints()) .build(); List<ChePluginEndpoint> containerEndpoints = k8sContainerResolver.getEndpoints(); Container k8sContainer = k8sContainerResolver.resolve(); String machineName = Names.machineName(pod, k8sContainer); pod.getSpec().getContainers().add(k8sContainer); MachineResolver machineResolver = new MachineResolverBuilder() .setCheContainer(container) .setContainer(k8sContainer) .setContainerEndpoints(containerEndpoints) .setDefaultSidecarMemorySizeAttribute(defaultSidecarMemoryLimitBytes) .setAttributes(kubernetesEnvironment.getAttributes()) .build(); InternalMachineConfig machineConfig = machineResolver.resolve(); machineConfig.getAttributes().put(CONTAINER_TYPE_ATTRIBUTE, ""tool-container""); kubernetesEnvironment.getMachines().put(machineName, machineConfig); sidecarRelatedCommands.forEach(c -> c.getAttributes().put(""machineName"", machineName)); container .getCommands() .stream() .map(c -> asCommand(machineName, c)) .forEach(c -> kubernetesEnvironment.getCommands().add(c)); SidecarServicesProvisioner sidecarServicesProvisioner = new SidecarServicesProvisioner(containerEndpoints, pod.getMetadata().getName()); sidecarServicesProvisioner.provision(kubernetesEnvironment); }",It would be better to make value a constant too,consider using a switch(res) {...},Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),@snleee This is handled with the API refreshSegment(),Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,I think this test should be moved to options instead,"verify(client != null, ""client cannot be null"");",The output of this call should be checked and if it's false I think it should bail.,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Should the condition here and the condition on 153 the same?,just pass sparkJarFilePath.toString less number of changes will be required in the code.
@Override public void draw(Canvas canvas) { if (!animating) { image.draw(canvas); } else { if (placeholder != null) { placeholder.draw(canvas); } float normalized = (SystemClock.uptimeMillis() - startTimeMillis) / FADE_DURATION; int alpha = (int) (0xFF * normalized); if (normalized >= 1f) { animating = false; placeholder = null; image.setAlpha(0xFF); image.draw(canvas); } else { image.setAlpha(alpha); image.draw(canvas); invalidateSelf(); } } if (debugging) { drawDebugIndicator(canvas); } },Don't we need to reset alpha here? Drawables share a global state.,Wrapper#getX() : float Use float instead of double.,Feels like this null check can be included above.,The same.,"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","Please make sure this is properly formatted. ""else"" should be on the same line as the }.",How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",why swallowing?,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,Missing Unstable attribute.
"public void addingAStudentAddsThemToTheSortedRoster() { school = new School(); school.add(""Aimee"", 2); List<String> expected = Arrays.asList(""Aimee""); assertEquals(expected,school.roster()); }",There should be a space here between expected and school.roster(),Isn't this dataset automatically executed?,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",Why this change?,Could you use Strings.repeat or something?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,@Serranya The same here. See above.,nit: any chance to make the message assertion more specific? :),I think we always display view names capitalized to users.,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,check to make sure notificationUUID is not null
"public static <T extends RemoteJsonService> T create(Class<T> serviceClass, GerritHttpClient gerritHttpClient, Version version) { String uri = GerritVersion.isVersion26OrLater(version) ? ""/gerrit_ui/rpc/"" : ""/gerrit/rpc/""; InvocationHandler handler = new GerritService(gerritHttpClient, uri + serviceClass.getSimpleName()); return serviceClass.cast(Proxy.newProxyInstance(GerritService.class.getClassLoader(), new Class<?>[] { serviceClass }, handler)); }",We should put the URL fragments into static vars in a common file then select them based on version in one place rather than scatterred throughout code.,Put the test in the same package (not directory) and you can at least use package private or protected,"Json -> ""JSON"" (do a search-n-replace)",[minor] could you name it resourceGroupName,Out of interest why can you not do BuiltinAggregator.values()?,do you clean up these files on exit? or the root level dir is deleted on exit ?,check to make sure notificationUUID is not null,The same.,@ekondrashev why not just rsp = opt?,you don't take any resourcees from player when buying dev card,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still"
"public V replace(K key, V value) { V v = delegate.replace(key, value); if (v != null) { stats.incrementCacheHits(); } else { stats.incrementCacheMisses(); } stats.incrementCachePuts(); return v; }",This should be in the if(v != null) check I am thinking,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,Check for illegal arg or are we happy with a ClassCastException here?,Need to remove this leftover debug output,nit: unnecessary generic type declaration,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),magic number,We don't need super here,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",It would have been shorter to inline this variable and not have it in scope. :-),this.redisTemplate
"public JCloudsSlave( @Nonnull ProvisioningActivity.Id id, @Nonnull Server metadata, @Nonnull String labelString, @Nonnull SlaveOptions slaveOptions ) throws IOException, Descriptor.FormException { super( metadata.getName(), null, slaveOptions.getFsRoot(), slaveOptions.getNumExecutors(), Mode.NORMAL, labelString, null, new JCloudsRetentionStrategy(), Collections.singletonList(new EnvironmentVariablesNodeProperty( new EnvironmentVariablesNodeProperty.Entry(""OPENSTACK_PUBLIC_IP"", Openstack.getPublicAddress(metadata)) )) ); this.cloudName = id.getCloudName(); this.provisioningId = id; this.options = slaveOptions; this.nodeId = metadata.getId(); final Map<String, String> instanceMetaData = metadata.getMetadata(); if (instanceMetaData != null && !instanceMetaData.isEmpty()) { this.openstackMetaData = new TreeMap<>(instanceMetaData); } else { this.openstackMetaData = null; } setLauncher(new JCloudsLauncher(getLauncherFactory().createLauncher(this))); }",Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",Please remove debug codes.,this may impact web-ui code. Do we want to expose Snapshot in API?,Sounds like a workaround for host misconfiguration issue.,I think this test should be moved to options instead,These should be done through a sink.,"verify(client != null, ""client cannot be null"");",@snleee This is handled with the API refreshSegment(),call intValue() and then there is no cast,suggestion deletedAlarmIds.forEach(alarmId -> {
"protected List<SurveyGroupDto> parseSurveyGroups(String response) throws Exception { List<SurveyGroupDto> dtoList = new ArrayList<SurveyGroupDto>(); JSONArray jsonArray = getJsonArray(response); if (jsonArray == null) { return dtoList; } for (int i = 0; i < jsonArray.length(); i++) { JSONObject o = jsonArray.getJSONObject(i); if (o != null) { try { SurveyGroupDto dto = new SurveyGroupDto(); if (o.has(""name"") && o.isNull(""name"")) { dto.setName(o.getString(""name"")); } if (!o.has(""monitoringGroup"") || o.isNull(""monitoringGroup"")) { dto.setMonitoringGroup(false); } else { dto.setMonitoringGroup(o.getBoolean(""monitoringGroup"")); } dtoList.add(dto); } catch (Exception e) { System.out.println(""Error in json parsing: "" + e.getMessage()); e.printStackTrace(); } } } return dtoList; }","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",Suggest JSON related capabilities be isolated to the JsonUtil class.,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Let's add a constant for ""version 2""",log,you can use parameterized logging here,edgeCacheDNS as a static variable since it's used a few times?,columnStatistics,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace."
"public Factory build() { BitSet redacted = new BitSet(); List<String> fields = new ArrayList<>(), keys = new ArrayList<>(); List<Integer> keyToFieldList = new ArrayList<>(); int i = 0; for (String fieldName : fieldNames) { if (redactedFieldNames.contains(fieldName)) redacted.set(i); fields.add(fieldName); keys.add(fieldName); keyToFieldList.add(i++); } for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) { String nextPrefix = entry.getKey(); String[] nextFieldNames = entry.getValue(); for (i = 0; i < nextFieldNames.length; i++) { String nextFieldName = nextFieldNames[i]; int index = fields.indexOf(nextFieldName); if (index == -1) { index = fields.size(); fields.add(nextFieldName); } keys.add(nextPrefix + nextFieldName); keyToFieldList.add(index); } } int[] keyToField = new int[keys.size()]; for (i = 0; i < keyToField.length; i++) { keyToField[i] = keyToFieldList.get(i); } String[] validated = fields.toArray(new String[0]); if (validated.length == 0) return new Factory(delegate); return new RealFactory(delegate, validated, keys.toArray(new String[0]), keyToField, redacted); }","Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)","verify(client != null, ""client cannot be null"");",We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,Please don't use sysout. Logging is your friend.,We tend to use IllegalArgumentException for these kind,"Let's add a constant for ""version 2""",is double call to structIsNull.toBooleanArray() intentional?,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),we should probably check in the canExecute whether we reached the start of the list,"This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name ""verify"" which makes it clear that the intent of the method is to do some state checks..."
public static String minimalEscape(Object content) { if (content == null) { return null; } String str = String.valueOf(content); StringBuilder result = new StringBuilder((int) (str.length() * 1.1)); int length = str.length(); char c; for (int i = 0; i < length; ++i) { c = str.charAt(i); switch (c) { case '&': result.append(AMP); break; case '<': result.append(LT); break; default: result.append(c); } } return result.toString(); },Missing Unstable attribute.,Is toString() required? It's already of STRING type.,Extra space,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Style nit: unneeded curlies,"We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.","Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,Wrapper#getX() : float Use float instead of double.,Don't we need to reset alpha here? Drawables share a global state.
"public void overloadedMethodsGetResolved() throws Exception { provider = new ExtensionAwareEvaluationContextProvider( Collections.singletonList(new DummyExtension(""_first"", ""first"") { @Override public Object getRootObject() { return new RootWithOverloads(); } })); assertThat(evaluateExpression(""method()"")).isEqualTo(""zero""); assertThat(evaluateExpression(""method(23)"")).isEqualTo(""single-int""); assertThat(evaluateExpression(""method('hello')"")).isEqualTo(""single-string""); assertThat(evaluateExpression(""method('one', 'two')"")).isEqualTo(""two""); assertThat(evaluateExpression(""method(1, 2)"")).isEqualTo(""two-ints""); assertThat(evaluateExpression(""method(1, 'two')"")).isEqualTo(""int-and-string""); }",Shall we extract that setup step? It's repeated in every test below.,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",@ikhvostenkov please name it json,this should be on System.err,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,Should TREEHASH be a HashCode?,Mutualize with the other matcher on tags,what's the reason for this extra variable container?,Could you please rename also _result?
"public static String getPreferredVariable(IPath[] paths, IContainer target) { IPath commonRoot = null; for (IPath path : paths) { if (path != null) { if (commonRoot == null) commonRoot = path; else { int count = commonRoot.matchingFirstSegments(path); int remainingSegments = commonRoot.segmentCount() - count; if (remainingSegments <= 0) return null; commonRoot = commonRoot.removeLastSegments(remainingSegments); } } } String mostAppropriate = null; String mostAppropriateToParent = null; int mostAppropriateCount = Integer.MAX_VALUE; int mostAppropriateCountToParent = Integer.MAX_VALUE; IPathVariableManager pathVariableManager = target.getPathVariableManager(); for (String variable : pathVariableManager.getPathVariableNames()) { if (isPreferred(variable)) { URI rawValue = pathVariableManager.getURIValue(variable); URI value = pathVariableManager.resolveURI(rawValue); if (value != null) { IPath path = URIUtil.toPath(value); if (path != null) { int difference = path.matchingFirstSegments(commonRoot); if (difference > 0) { if (difference < mostAppropriateCount) { mostAppropriateCount = difference; mostAppropriate = variable; } } else { difference = commonRoot.matchingFirstSegments(path); if (difference > 0) { if (difference < mostAppropriateCountToParent) { mostAppropriateCountToParent = difference; mostAppropriateToParent = variable; } } } } } } } if (mostAppropriate == null) { if (mostAppropriateToParent == null) return ""PROJECT_LOC""; return mostAppropriateToParent; } return mostAppropriate; }",rename 'variableName',"suggestion log.debug(""{} old entitlement certificates deleted"", count);",This check seems a little fragile at first glance (not sure why.),This seems to be unnecessary. I also get the label after removing this.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,consider using a switch(res) {...},Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,Add invariants,@snleee This is handled with the API refreshSegment(),why var4? Resources.NotFoundException e would be a bit nicer..
"public void deleteStorage(final String id, final Optional<String> user) throws DbWriteOperationsBlockedException, NoSuchStorageException, StorageIsUsedException, InternalNakadiException { if (featureToggleService.isFeatureEnabled(FeatureToggleService.Feature.DISABLE_DB_WRITE_OPERATIONS)) { throw new DbWriteOperationsBlockedException(""Cannot delete storage: write operations on DB "" + ""are blocked by feature flag.""); } try { final Optional<Object> storageOrNone = storageDbRepository.getStorage(id) .map(Function.identity()); storageDbRepository.deleteStorage(id); auditLogPublisher.publish( Optional.empty(), storageOrNone, NakadiAuditLogPublisher.ResourceType.STORAGE, NakadiAuditLogPublisher.ActionType.DELETED, id, user); } catch (final RepositoryProblemException e) { LOG.error(""DB error occurred when deleting storage"", e); throw new InternalNakadiException(e.getMessage()); } catch (final TransactionException e) { LOG.error(""Error with transaction handling when deleting storage"", e); throw new InternalNakadiException(""Transaction error occurred when deleting storage""); } }","Good catch, thanks. Fixed <LINK_0>",Why not extract receivedId before switch block? (reduce the duplicate code),edgeCacheDNS as a static variable since it's used a few times?,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,I think this test should be moved to options instead,Unrelated change. Should be in a separate commit.,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Two ;;,fetch should already happen in Service,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?
"private static String loadFile(String fileName) { String content = """"; fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName); File file = new File(fileName); if (file.exists()) { try { content = new String(Files.readAllBytes(file.toPath())); } catch (Exception e) { log.error(""Failed to read sysprep template '{}': {}"", fileName, e.getMessage()); log.debug(""Exception"", e); } } else { log.error(""Sysprep template: '{}' not found"", fileName); } return content; }",The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,Extra space,you can use parameterized logging here,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",Suggest JSON related capabilities be isolated to the JsonUtil class.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Replace with logger,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Here I would just say return true. Then fall through return false, instead of creating a variable.",columnStatistics
"public boolean invalidateIfNecessary(BaragonRequest request) { if (request.getLoadBalancerService().getOptions().get(""edgeCacheDNS"") == null) { return false; } try { String edgeCacheDNS = ((String) request.getLoadBalancerService().getOptions().get(""edgeCacheDNS"")); Optional<CloudflareZone> matchingZone = getCloudflareZone(edgeCacheDNS); if (!matchingZone.isPresent()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but no matching Cloudflare Zone was found!""); return false; } String zoneId = matchingZone.get().getId(); Optional<CloudflareDnsRecord> matchingDnsRecord = getCloudflareDnsRecord(edgeCacheDNS, zoneId); if (!matchingDnsRecord.isPresent()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but no matching Cloudflare DNS Record was found!""); return false; } if (!matchingDnsRecord.get().isProxied()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but {} is not a proxied DNS record!"", edgeCacheDNS); return false; } return cf.purgeCache( zoneId, Collections.singletonList( String.format(CACHE_TAG_FORMAT, request.getLoadBalancerService().getServiceId(), environment.getName()) ) ); } catch (CloudflareClientException e) { LOG.error(""Unable to invalidate Cloudflare cache for request {}"", request, e); return false; } }",edgeCacheDNS as a static variable since it's used a few times?,nit: call it uae?,I think this test should be moved to options instead,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","Good catch, thanks. Fixed <LINK_0>",Let's make this InternalServerError,just pass sparkJarFilePath.toString less number of changes will be required in the code.,consider using a switch(res) {...},"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",Unrelated change. Should be in a separate commit.
"private <V> void addCallback(CompletableFuture<V> cfuture, CommitData cd, OnSuccessInterface<V> onSuccessInterface) { cfuture.handleAsync((result, exception) -> { if (result != null) { try { onSuccessInterface.onSuccess(cd, result); return null; } catch (Exception e) { cd.commitObserver.failed(e); return null; } } else { cd.commitObserver.failed(exception); return null; } }, env.getSharedResources().getAsyncCommitExecutor()); }","If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }",It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,I think it would be good to perform this logic in OutputEmitter.,you don't take any resourcees from player when buying dev card,"Json -> ""JSON"" (do a search-n-replace)","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",@ekondrashev why not just rsp = opt?,Put the test in the same package (not directory) and you can at least use package private or protected,The same.,why swallowing?,"Should this support a null address? Same with the other one, which make support a null or empty address."
"public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) { log.debug(""deleteAsyncQueryAndResultCollection""); Collection<AsyncQuery> asyncQueryList = null; try { asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> { EntityProjection asyncQueryCollection = EntityProjection.builder() .type(AsyncQuery.class) .filterExpression(filterExpression) .build(); Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope); Iterator<Object> itr = loaded.iterator(); while (itr.hasNext()) { AsyncQuery query = (AsyncQuery) itr.next(); if (query != null) { tx.delete(query, scope); } } return loaded; }); } catch (Exception e) { log.error(""Exception: {}"", e); } return asyncQueryList; }",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.,Replace with Objects.requireNotNull.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,columnStatistics,Suggest JSON related capabilities be isolated to the JsonUtil class.,Add invariants,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Can this be changed to createSubjectRoleAttribute?,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));"
"public static void markNoteAsRead(final Note note) { if (note == null) { return; } if (note.isUnread()) { WordPress.getRestClientUtilsV1_1().decrementUnreadCount(note.getId(), ""10"", new RestRequest.Listener() { @Override public void onResponse(JSONObject response) { note.setRead(); NotificationsTable.saveNote(note); } }, new RestRequest.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { AppLog.e(AppLog.T.NOTIFS, ""Could not mark note as read via API.""); } }); } }",Let's do the same way @jleandroperez did on iOS here <LINK_0>,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",This commandContext seems unused.,Please change user back to USER_YODA here.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"Good catch, thanks. Fixed <LINK_0>","If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Two ;;,I don't see sense from this if (MobileContextHelper.isInWebViewContext())
"public Set<String> map(Set<String> genres) { Set<String> tags = Sets.newHashSet(); for (String genre : genres) { if (genre.contains(""<LINK_0>"")) { tags.add(paTagMap.get(genre)); } } if (tags.size() == 1 && tags.contains(""film"")) { tags.add(""action""); } return tags; }",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,not good to add sth when calling getter,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","Maybe using a constant here for ""://""",Put the test in the same package (not directory) and you can at least use package private or protected,Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,consider 'ternary if' here,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Style nit: unneeded curlies,This can be removed? (Being added later.)
"public void checkWebJavaSpringCommands() { consoles.startCommandAndCheckResult(WEB_JAVA_SPRING, BUILD, ""build"", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, BUILD, ""web-java-spring:build"", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, ""web-java-spring:build and run"", ""Server startup in""); consoles.startCommandAndCheckApp(currentWindow, "" consoles.closeProcessTabWithAskDialog(""web-java-spring:build and run""); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, ""web-java-spring:run tomcat"", ""Server startup in""); consoles.startCommandAndCheckApp(currentWindow, "" projectExplorer.invokeCommandWithContextMenu( RUN, WEB_JAVA_SPRING, ""web-java-spring:stop tomcat""); consoles.selectProcessInProcessConsoleTreeByName(""Terminal""); terminal.typeIntoTerminal(""ps ax""); terminal.typeIntoTerminal(ENTER.toString()); terminal.waitExpectedTextNotPresentTerminal(""/bin/bash -c $TOMCAT_HOME/bin/catalina.sh""); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, DEBUG, ""web-java-spring:debug"", ""Listening for transport dt_socket at address: 8000""); }","let's make constant with ""web-java-spring:stop tomcat"" command: STOP_TOMCAT_COMMAND_ITEM_NAME",Should TREEHASH be a HashCode?,"EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>","I should probably have asked this in the previous review, but why ""addFollowingAccounts""? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.",I assume this was meant to be removed?,Please don't do unrelated refactor work next time,power down,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,"Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",@jomarko Thanks.. I'd have made this Integer.class.getName() too
"public abstract BufferedSink valueSink() throws IOException; public final JsonWriter jsonValue(@Nullable Object value) throws IOException { if (value instanceof Map<?, ?>) { beginObject(); for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { Object key = entry.getKey(); if (!(key instanceof String)) { throw new IllegalArgumentException( ""Map keys must be of type String: "" + key.getClass().getName()); } name(((String) key)); jsonValue(entry.getValue()); } endObject(); } else if (value instanceof List<?>) { beginArray(); for (Object element : ((List<?>) value)) { jsonValue(element); } endArray(); } else if (value instanceof String) { value(((String) value)); } else if (value instanceof Boolean) { value(((Boolean) value).booleanValue()); } else if (value instanceof Double) { value(((Double) value).doubleValue()); } else if (value instanceof Long) { value(((Long) value).longValue()); } else if (value instanceof Number) { value(((Number) value)); } else if (value == null) { nullValue(); } else { throw new IllegalArgumentException(""Unsupported type: "" + value.getClass().getName()); } return this; }",what does this do if key is null?,@ikhvostenkov please name it json,we should probably check in the canExecute whether we reached the start of the list,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",Why parseDouble and then convert that to int instead of directly parsing to int ?,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),Unrelated change. Should be in a separate commit.,is double call to structIsNull.toBooleanArray() intentional?,"verify(client != null, ""client cannot be null"");",We tend to use IllegalArgumentException for these kind
"void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) { this.context = context; String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME; File dir = new File(modOutPath); if (dir.exists() == false) { dir.mkdirs(); } extractPrefetchFiles(dataSource); final String prefetchDumper = getPathForPrefetchDumper(); if (prefetchDumper == null) { logger.log(Level.SEVERE, ""Error finding parse_prefetch program""); return; } if (context.dataSourceIngestIsCancelled()) { return; } String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE; try { String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME ); parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath); createAppExecArtifacts(modOutFile); } catch (IOException ex) { logger.log(Level.WARNING, ""Error runing parse_prefetch or creating artifacts."", ex); } }",The output of this call should be checked and if it's false I think it should bail.,fetch should already happen in Service,Why do we handle error like this?,Remove /Dev Team,Sounds like a workaround for host misconfiguration issue.,merge the try/catch with the one below?,Make sure to unescape the url path before using it. I've hit this in actual usage.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.",Should the condition here and the condition on 153 the same?
"public void parsesInvalidIdField() throws IOException { final MemberProfileJson memberprofilejson = Mockito.mock(MemberProfileJson.class); Mockito.when( memberprofilejson.fetch( Mockito.anyString(), Mockito.anyString(), Mockito.any(Href.class) ) ).thenReturn( Json.createReader( new FileInputStream( PsLinkedinTest.class.getResource( ""linkedinTestUserInvalidId.json"" ).getPath() ) ).readObject() ); try { new PsLinkedin(memberprofilejson) .enter(REQUEST); } catch (final ClassCastException ex) { MatcherAssert.assertThat( ex.getMessage(), Matchers.containsString(""cannot be cast to"") ); throw ex; } }",@ikhvostenkov please name it json,The Exception is never thrown.,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",Why do we handle error like this?,Should TREEHASH be a HashCode?,is double call to structIsNull.toBooleanArray() intentional?,this should be on System.err,"verify(client != null, ""client cannot be null"");",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),We tend to use IllegalArgumentException for these kind
"public Matcher<View> atPositionOnView(final int position, final int targetViewId) { return new TypeSafeMatcher<View>() { Resources resources = null; View childView; public void describeTo(Description description) { String idDescription = Integer.toString(recyclerViewId); if (this.resources != null) { try { idDescription = this.resources.getResourceName(recyclerViewId); } catch (Resources.NotFoundException var4) { idDescription = String.format(""%s (resource name not found)"", recyclerViewId); } } description.appendText(""with id: "" + idDescription); } public boolean matchesSafely(View view) { this.resources = view.getResources(); if (childView == null) { RecyclerView recyclerView = (RecyclerView) view.getRootView().findViewById(recyclerViewId); if (recyclerView != null && recyclerView.getId() == recyclerViewId) { childView = recyclerView.findViewHolderForAdapterPosition(position).itemView; } else { return false; } } if (targetViewId == -1) { return view == childView; } else { View targetView = childView.findViewById(targetViewId); return view == targetView; } } }; }",why var4? Resources.NotFoundException e would be a bit nicer..,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",merge the try/catch with the one below?,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",This seems to be unnecessary. I also get the label after removing this.,Remove /Dev Team,Iffy formatting,fetch should already happen in Service,rename 'variableName',@snleee This is handled with the API refreshSegment()
public I setContext(HttpRequest request) { this.request = GeneratedHttpRequest.class.cast(request); return (I) this; },Check for illegal arg or are we happy with a ClassCastException here?,"don't return NULL, throw UnsupportedOperatedException instead",Remove cast,This should be in the if(v != null) check I am thinking,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());","Is a null check for the passed in ""date"" required here for safety?",Is there a reason this isn't implemented?,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",It would have been shorter to inline this variable and not have it in scope. :-)
"private <T extends Enum<T>> void registerStatistic(String statNameSuffix, StatisticType type, final OperationStatisticDescriptor<T> descriptor, final EnumSet<T> outcomes) { if (contextObject == null) { return; } Set<TreeNode> result = queryBuilder() .descendants() .filter(context(attributes(Matchers.<Map<String, Object>>allOf( hasAttribute(""type"", descriptor.getType()), hasAttribute(""name"", descriptor.getObserverName()), hasAttribute(""tags"", new Matcher<Set<String>>() { @Override protected boolean matchesSafely(Set<String> object) { return object.containsAll(descriptor.getTags()); } }))))) .filter(context(identifier(subclassOf(OperationStatistic.class)))) .build().execute(Collections.singleton(ContextManager.nodeFor(contextObject))); if (!result.isEmpty()) { for (TreeNode node : result) { String discriminator = null; Map<String, Object> properties = (Map<String, Object>) node.getContext().attributes().get(""properties""); if (properties != null && properties.containsKey(""discriminator"")) { discriminator = properties.get(""discriminator"").toString(); } String fullStatName = (discriminator == null ? """" : (discriminator + "":"")) + statNameSuffix; final OperationStatistic<T> statistic = (OperationStatistic<T>) node.getContext().attributes().get(""this""); registerStatistic(fullStatName, type, new ValueStatistic<Number>() { @Override public Number value() { return statistic.sum(outcomes); } }); } } }",Mutualize with the other matcher on tags,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,suggestion deletedAlarmIds.forEach(alarmId -> {,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",call intValue() and then there is no cast,Please remove debug codes.,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.","verify(client != null, ""client cannot be null"");",Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e),this may impact web-ui code. Do we want to expose Snapshot in API?
"private void setPublicURIs(final FileSystem fileSystem) { final String[] uris = fileSystem.toString().split(""\\r?\\n""); final List<PublicURI> publicURIs = new ArrayList<>(uris.length); for (final String s : uris) { final int protocolStart = s.indexOf(""://""); publicURIs.add(getPublicURI(s, protocolStart)); } repo.setPublicURIs(publicURIs); }","Maybe using a constant here for ""://""",I think we need to close this InputStream at some point,@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,not good to add sth when calling getter,"[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE",Put the test in the same package (not directory) and you can at least use package private or protected,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",do you clean up these files on exit? or the root level dir is deleted on exit ?,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",Suggest JSON related capabilities be isolated to the JsonUtil class.,Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
"private void handleRelatedAlarms(OnmsAlarm situation) { if (!situation.isSituation()) { return; } alarmAssociationById.putIfAbsent(situation.getId(), new HashMap<>()); final Map<Integer, AlarmAssociationAndFact> associationFacts = alarmAssociationById.get(situation.getId()); for (AlarmAssociation association : situation.getAssociatedAlarms()) { Integer alarmId = association.getRelatedAlarm().getId(); AlarmAssociationAndFact assocationFact = associationFacts.get(alarmId); if (assocationFact == null) { LOG.debug(""Inserting alarm association into session: {}"", association); final FactHandle fact = getKieSession().insert(association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } else { FactHandle fact = assocationFact.getFact(); LOG.trace(""Updating alarm assocation in session: {}"", assocationFact); getKieSession().update(fact, association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } } Set<Integer> deletedAlarmIds = associationFacts.values().stream() .map(fact -> fact.getAlarmAssociation().getRelatedAlarm().getId()) .filter(alarmId -> !situation.getRelatedAlarmIds().contains(alarmId)) .collect(Collectors.toSet()); deletedAlarmIds.stream().forEach(alarmId -> { final AlarmAssociationAndFact associationAndFact = associationFacts.remove(alarmId); if (associationAndFact != null) { LOG.debug(""Deleting AlarmAssociationAndFact from session: {}"", associationAndFact.getAlarmAssociation()); getKieSession().delete(associationAndFact.getFact()); } }); }",suggestion deletedAlarmIds.forEach(alarmId -> {,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",throw exception?,"verify(client != null, ""client cannot be null"");",What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,this may impact web-ui code. Do we want to expose Snapshot in API?,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Please remove debug codes.,power down,@snleee This is handled with the API refreshSegment(),Why use a java.lang.Boolean and not a primitive boolean?
"public Obs saveObs(Obs obs, String changeMessage) throws APIException { if(obs == null){ throw new APIException(""Obs.error.cannot.be.null"", (Object[]) null); } if(obs.getId() != null && changeMessage == null){ throw new APIException(""Obs.error.ChangeMessage.required"", (Object[]) null); } handleExistingObsWithComplexConcept(obs); ensureRequirePrivilege(obs); if (obs.getObsId() == null || obs.getVoided()) { return saveNewOrVoidedObs(obs,changeMessage); } else if(!obs.isDirty()){ setPersonFromEncounter(obs); return saveObsNotDirty(obs, changeMessage); } else { Errors errors = new BindException(obs, ""obs""); new ObsValidator().validate(obs, errors); if (!errors.hasFieldErrors(""person"")){ setPersonFromEncounter(obs); return saveExistingObs(obs,changeMessage); } else{ throw new APIException(""Obs.error.PersonId.mismatch"", (Object[]) null); } } }","You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),Should TREEHASH be a HashCode?,Why do we handle error like this?,We tend to use IllegalArgumentException for these kind,Sounds like a workaround for host misconfiguration issue.,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)",Why use a java.lang.Boolean and not a primitive boolean?,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",power down,"verify(client != null, ""client cannot be null"");"
protected void onExportChanged() { boolean externalNetwork = (Boolean) getExport().getEntity(); getQos().setIsChangable(!externalNetwork); getAddQosCommand().setIsExecutionAllowed(!externalNetwork); String label = getNetworkLabel().getSelectedItem(); if (externalNetwork) { getNetworkLabel().setItems(new HashSet<String>()); } else { getNetworkLabel().setItems(dcLabels); } getNetworkLabel().setSelectedItem(label); },consider 'ternary if' here,Could you please rename also _result?,Similar to DistinctCountAggregator,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,you don't take any resourcees from player when buying dev card,what's the reason for this extra variable container?,The same.,not a field,[minor] could you name it resourceGroupName
"protected void executeCommand() { setVds(null); if (getVds() == null) { setCommandShouldBeLogged(false); log.infoFormat(""SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore."", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } if (getVds().getStatus() != VDSStatus.Maintenance) { setCommandShouldBeLogged(false); log.infoFormat(""SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance."", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString()); if (result) { getVds().setStatus(VDSStatus.Down); if (!getParameters().getKeepPolicyPMEnabled()) { getVds().setPowerManagementControlledByPolicy(false); } getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData()); } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) { FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop); parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled()); Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext()); } getReturnValue().setSucceeded(result); }",power down,Why use a java.lang.Boolean and not a primitive boolean?,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",We tend to use IllegalArgumentException for these kind,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",Please remove debug codes.,Why do we handle error like this?,Sounds like a workaround for host misconfiguration issue.,"verify(client != null, ""client cannot be null"");","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {
public Optional<Symbol> resolveMember(String memberName) { if (types.stream().anyMatch(type -> type instanceof RuntimeType && ((RuntimeType) type).hasUnresolvedHierarchy())) { return Optional.empty(); } Set<Optional<Symbol>> resolved = types.stream() .map(t -> t.resolveMember(memberName)) .filter(Optional::isPresent) .collect(Collectors.toSet()); if (resolved.isEmpty()) { return Optional.empty(); } else if (resolved.size() == 1) { return resolved.iterator().next(); } return Optional.of(AmbiguousSymbolImpl.create(resolved.stream().map(s -> s.orElse(null)).filter(Objects::nonNull).collect(Collectors.toSet()))); },"I don't think ""resolveMember"" should create a new symbol. We should find another approach","You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,",Log/throw?,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,Suggest JSON related capabilities be isolated to the JsonUtil class.,@ekondrashev why not just rsp = opt?,Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.",So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,"Json -> ""JSON"" (do a search-n-replace)",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).
"public static BlobProperties buildBlobProperties(Map<String, Object> args) throws RestServiceException { Account account = (Account) args.get(InternalKeys.TARGET_ACCOUNT_KEY); if (account == null) { throw new RestServiceException(InternalKeys.TARGET_ACCOUNT_KEY + "" is not set"", RestServiceErrorCode.MissingArgs); } Container container = (Container) args.get(InternalKeys.TARGET_CONTAINER_KEY); if (container == null) { throw new RestServiceException(InternalKeys.TARGET_CONTAINER_KEY + "" is not set"", RestServiceErrorCode.MissingArgs); } String serviceId = getHeader(args, Headers.SERVICE_ID, true); String contentType = getHeader(args, Headers.AMBRY_CONTENT_TYPE, true); String ownerId = getHeader(args, Headers.OWNER_ID, false); long ttl = Utils.Infinite_Time; String ttlStr = getHeader(args, Headers.TTL, false); if (ttlStr != null) { try { ttl = Long.parseLong(ttlStr); if (ttl < -1) { throw new RestServiceException(Headers.TTL + ""["" + ttl + ""] is not valid (has to be >= -1)"", RestServiceErrorCode.InvalidArgs); } } catch (NumberFormatException e) { throw new RestServiceException(Headers.TTL + ""["" + ttlStr + ""] could not parsed into a number"", RestServiceErrorCode.InvalidArgs); } } return new BlobProperties(-1, serviceId, ownerId, contentType, isPrivate(args), ttl, account.getId(), container.getId()); }",Let's make this InternalServerError,"If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",Replace with logger,Why not extract receivedId before switch block? (reduce the duplicate code),ImplUtils has a isNullOrEmpty method that should handle these checks.,Is toString() required? It's already of STRING type.,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","Good catch, thanks. Fixed <LINK_0>",Unrelated change. Should be in a separate commit.,edgeCacheDNS as a static variable since it's used a few times?
"public AlphaRejectBlocksNode(Context context) { Config config = context.get(Config.class); DisplayResolutionDependentFBOs displayResolutionDependentFBOs = context.get(DisplayResolutionDependentFBOs.class); worldRenderer = context.get(WorldRenderer.class); renderQueues = context.get(RenderQueuesHelper.class); wireframeStateChange = new SetWireframe(true); RenderingDebugConfig renderingDebugConfig = config.getRendering().getDebug(); new WireframeTrigger(renderingDebugConfig, this); playerCamera = worldRenderer.getActiveCamera(); addDesiredStateChange(new LookThrough(playerCamera)); addDesiredStateChange(new BindFBO(READONLY_GBUFFER, displayResolutionDependentFBOs)); addDesiredStateChange(new EnableMaterial(CHUNK_SHADER.toString())); chunkShader = getMaterial(CHUNK_SHADER); }",1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,consider 'ternary if' here,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,not a field,Similar to DistinctCountAggregator,The Exception is never thrown.,It would be better to make value a constant too,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,[minor] could you name it resourceGroupName,Could you please rename also _result?
"public static String print(Node n, String encoding) { if (n == null) { return null; } try { Document document = null; if (n instanceof Document) { document = (Document) n; } else { document = n.getOwnerDocument(); } StringWriter stringOut = new StringWriter(); DOMImplementationLS domImpl = (DOMImplementationLS) document.getImplementation(); LSSerializer lsSerializer = domImpl.createLSSerializer(); lsSerializer.getDomConfig().setParameter(XML_DECLARATION, false); LSOutput lsout = domImpl.createLSOutput(); lsout.setEncoding(encoding); lsout.setCharacterStream(stringOut); NodeList childNodes = n.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { lsSerializer.write(childNodes.item(i), lsout); } return stringOut.toString(); } catch (DOMException | LSException e) { LOGGER.debug(e.getMessage(), e); } return null; }","Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?",Missing Unstable attribute.,Does it make sense to continue here? Or just return false.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",UtilKtKt isn't a great name.,Suggest JSON related capabilities be isolated to the JsonUtil class.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",the original code does not make toLowerCase(). Why did you add it?,"That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).
"public void onCompletion(Void result, Exception exception) { callbackTracker.markOperationEnd(); if (exception == null) { try { RestMethod restMethod = restRequest.getRestMethod(); logger.trace(""Forwarding {} to the IdConverter/Router"", restMethod); switch (restMethod) { case GET: String receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); InboundIdConverterCallback idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, getCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case HEAD: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, headCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case DELETE: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, deleteCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; default: exception = new IllegalStateException(""Unrecognized RestMethod: "" + restMethod); } } catch (Exception e) { exception = extractExecutionExceptionCause(e); } } if (exception != null) { submitResponse(restRequest, restResponseChannel, null, exception); } callbackTracker.markCallbackProcessingEnd(); }",Why not extract receivedId before switch block? (reduce the duplicate code),Let's make this InternalServerError,Please change user back to USER_YODA here.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,"Good catch, thanks. Fixed <LINK_0>",edgeCacheDNS as a static variable since it's used a few times?,static import,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Two ;;
@OnClick(R.id.gallery_cta_button) void onTranslateClick(View v) { GalleryItemFragment item = getCurrentItem(); if (item == null || item.getImageTitle() == null || item.getMediaInfo() == null || item.getMediaInfo().getMetadata() == null) { return; } if (imageEditType != null) { switch (imageEditType) { case ADD_TAGS: startTagsEdit(item); break; case ADD_CAPTION_TRANSLATION: startCaptionTranslation(item); break; default: startCaptionEdit(item); } } },Feels like this null check can be included above.,"Json -> ""JSON"" (do a search-n-replace)","CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Wrapper#getX() : float Use float instead of double.,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.",Don't we need to reset alpha here? Drawables share a global state.,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.","You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.
"private static String toHex(String s) { StringBuffer buf = null; try { buf = new StringBuffer(s.getBytes(""UTF-8"").length); for (byte x : s.getBytes(""UTF-8"")) { buf.append(""%""); buf.append(Integer.toHexString(x & 0xFF)); } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return buf.toString().toUpperCase(); }",Extra space,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Missing Unstable attribute.,"java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }",The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,Is toString() required? It's already of STRING type.,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,Style nit: unneeded curlies,"Maybe using a constant here for ""://""",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
"private SmooshedWriter delegateSmooshedWriter(final String name,final long size) throws IOException { final File tmpFile = new File(baseDir, name); createFiles.add(tmpFile); return new SmooshedWriter () { private int currOffset = 0; private boolean open = true; private final FileOutputStream out = new FileOutputStream(tmpFile); @Override public void close() throws IOException { open = false; out.close(); files.add(tmpFile); if(!writerCurrentlyInUse ) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { FileChannel channel = out.getChannel(); int bytesWritten = channel.write(buffer); return addToOffset(bytesWritten); } @Override public int write(InputStream in) throws IOException { return addToOffset(Ints.checkedCast(java.nio.file.Files.copy(in, tmpFile.toPath()))); } public int addToOffset(int numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return numBytesWritten; } @Override public boolean isOpen() { return open; } }; }","This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name ""verify"" which makes it clear that the intent of the method is to do some state checks...",read the values and validate,is double call to structIsNull.toBooleanArray() intentional?,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)","Let's add a constant for ""version 2""",Make sure to unescape the url path before using it. I've hit this in actual usage.,Remove /Dev Team,"Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...",The output of this call should be checked and if it's false I think it should bail.
"public DnsClientImpl(VertxInternal vertx, DnsClientOptions options) { Objects.requireNonNull(options, ""no null options accepted""); Objects.requireNonNull(options.getHost(), ""no null host accepted""); if (options.getPort() < 1) { throw new IllegalArgumentException(""DNS client port "" + options.getPort() + "" must be > 0""); } if (options.getQueryTimeout() < 0) { throw new IllegalArgumentException(""DNS client timeout "" + options.getQueryTimeout() + "" must be > 0""); } this.options = new DnsClientOptions(options); ContextInternal creatingContext = vertx.getContext(); if (creatingContext != null && creatingContext.isMultiThreadedWorkerContext()) { throw new IllegalStateException(""Cannot use DnsClient in a multi-threaded worker verticle""); } this.dnsServer = new InetSocketAddress(options.getHost(), options.getPort()); this.vertx = vertx; Transport transport = vertx.transport(); actualCtx = vertx.getOrCreateContext(); channel = transport.datagramChannel(InternetProtocolFamily.IPv4); channel.config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true); channel.config().setMaxMessagesPerRead(1); channel.config().setAllocator(PartialPooledByteBufAllocator.INSTANCE); actualCtx.nettyEventLoop().register(channel); if (options.getLogActivity()) { channel.pipeline().addLast(""logging"", new LoggingHandler()); } channel.pipeline().addLast(new DatagramDnsQueryEncoder()); channel.pipeline().addLast(new DatagramDnsResponseDecoder()); channel.pipeline().addLast(new SimpleChannelInboundHandler<DnsResponse>() { @Override protected void channelRead0(ChannelHandlerContext ctx, DnsResponse msg) throws Exception { int id = msg.id(); Query query = inProgressMap.get(id); if (query != null) { query.handle(msg); } } }); }",I think this test should be moved to options instead,edgeCacheDNS as a static variable since it's used a few times?,We tend to use IllegalArgumentException for these kind,"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",nit: call it uae?,Unrelated change. Should be in a separate commit.,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"verify(client != null, ""client cannot be null"");","Let's add a constant for ""version 2""",The output of this call should be checked and if it's false I think it should bail.
"public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager( getResources().getInteger(R.integer.news_fragment_column_count), StaggeredGridLayoutManager.VERTICAL); getListView().setLayoutManager(layoutManager); mAdapter = new NewsAdapter(getActivity(), ((GdgActivity) getActivity()).getGoogleApiClient()); setRecyclerAdapter(mAdapter); setOnRefreshListener(this); final String plusId = getArguments().getString(Const.EXTRA_PLUS_ID); if (Utils.isOnline(getActivity())) { new Builder<>(String.class, Activities.class) .addParameter(plusId) .setOnPreExecuteListener(new CommonAsyncTask.OnPreExecuteListener() { @Override public void onPreExecute() { setIsLoading(true); } }) .setOnBackgroundExecuteListener( new CommonAsyncTask.OnBackgroundExecuteListener<String, Activities>() { @Override public Activities doInBackground(String... params) { Activities feed = (Activities) App.getInstance().getModelCache().get(Const.CACHE_KEY_NEWS + params[0]); if (feed == null) { feed = getActivityFeedSync(params[0]); } return feed; } }) .setOnPostExecuteListener(new CommonAsyncTask.OnPostExecuteListener<String, Activities>() { @Override public void onPostExecute(String[] params, Activities activityFeed) { if (activityFeed != null) { mAdapter.addAll(activityFeed.getItems()); setIsLoading(false); } } }) .buildAndExecute(); } else { App.getInstance().getModelCache().getAsync(Const.CACHE_KEY_NEWS + plusId, false, new ModelCache.CacheListener() { @Override public void onGet(Object item) { Activities feed = (Activities) item; if (isAdded()) { Snackbar snackbar = Snackbar.make(getView(), R.string.cached_content, Snackbar.LENGTH_SHORT); ColoredSnackBar.info(snackbar).show(); } mAdapter.addAll(feed.getItems()); setIsLoading(false); } @Override public void onNotFound(String key) { showError(R.string.offline_alert); } }); } }","Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,This seems to be unnecessary. I also get the label after removing this.,suggestion deletedAlarmIds.forEach(alarmId -> {,we should probably check in the canExecute whether we reached the start of the list,This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()),why var4? Resources.NotFoundException e would be a bit nicer..,@snleee This is handled with the API refreshSegment(),throw exception?,what is a PropertyValueWrapper? Why do you need it?,Iffy formatting
"public String[] getSupportedExtensions() { return new String[] { ""at3"", ""oma"", ""aa3"", ""at9"", }; }",@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.,"add ""balanced"" ?",Why not use capabilities directly here?,"you should check the cache doesn't exist, plus that no suggestion to use the cache is logged",Why public?,"This bloc of code is repeated many times, should be centralized in a single method.",Isn't this dataset automatically executed?,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Floating semicolon,curly braces aren't required,"To match the old format, do ""Network parameters:\n "" here."
"public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }",SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,Isn't this dataset automatically executed?,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",There should be a space here between expected and school.roster(),Out of interest why can you not do BuiltinAggregator.values()?,Could you use Strings.repeat or something?,"this is followup of above, it should not be required.",check to make sure notificationUUID is not null,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,do you clean up these files on exit? or the root level dir is deleted on exit ?,you don't take any resourcees from player when buying dev card
"public String buildRunCommand() { final List<String> runCommand; if (importsZip == null || abstractEntryClient instanceof ToolClient || Objects.equals(languageType, LanguageType.WDL)) { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), ""--inputs"", provisionedParameterFile.getAbsolutePath()); } else { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), ""--inputs"", provisionedParameterFile.getAbsolutePath(), ""--imports"", importsZip.getAbsolutePath()); } System.out.println(""Calling out to "" + LAUNCHER_NAME + "" to run your workflow""); final String[] s = { ""java"", ""-jar"", exectionFile.getAbsolutePath(), ""run"" }; List<String> arguments = new ArrayList<>(); arguments.addAll(Arrays.asList(s)); arguments.addAll(runCommand); final String join = Joiner.on("" "").join(arguments); System.out.println(""Executing: "" + join); return join; }","You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",log,this should be on System.err,Please change user back to USER_YODA here.,This commandContext seems unused.,The output of this call should be checked and if it's false I think it should bail.,Do we missing some enums here?,columnStatistics,This statement slot.getValueList().getValue()) could cause an NPE
"public Mono<CloseableChannel> start(ConnectionAcceptor acceptor, int mtu) { Objects.requireNonNull(acceptor, ""acceptor must not be null""); return server .handle( (request, response) -> { transportHeaders.get().forEach(response::addHeader); return response.sendWebsocket( null, Math.max(DEFAULT_FRAME_SIZE, mtu == 0 ? FRAME_MAX_SIZE : mtu), (in, out) -> { DuplexConnection connection = new WebsocketDuplexConnection((Connection) in); if (mtu > 0) { connection = new FragmentationDuplexConnection( connection, ByteBufAllocator.DEFAULT, mtu, false); } return acceptor.apply(connection).then(out.neverComplete()); }); }) .bind() .map(CloseableChannel::new); }",what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,"UDP is a datagram protocol, so it doesn't require frame decoder.",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Shouldn't it be No handler was subscribed **for** command?,@ekondrashev why not just rsp = opt?,Replace with Objects.requireNotNull.,nit: maybe we can save the result of getPartition(topicPartition),"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
"private ClusteringModel pmmlClusteringModel(KMeansModel model, Map<Integer,Long> clusterSizesMap) { ClusteringModel clusteringModel = new ClusteringModel(AppPMMLUtils.buildMiningSchema(inputSchema), new ComparisonMeasure(ComparisonMeasure.Kind.DISTANCE) .withMeasure(new SquaredEuclidean()), MiningFunctionType.CLUSTERING, ClusteringModel.ModelClass.CENTER_BASED, model.clusterCenters().length) .withNumberOfClusters(model.k()); if (initializationStrategy.equals(KMeans.K_MEANS_PARALLEL())) { clusteringModel.setAlgorithmName(""K-Means||""); } else if (initializationStrategy.equals(KMeans.RANDOM())) { clusteringModel.setAlgorithmName(""random""); } Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { FieldName field = FieldName.create(""field_"" + i); clusteringModel.getClusteringFields().add( new ClusteringField(field).withCompareFunction(CompareFunctionType.ABS_DIFF)); clusteringModel.getClusters().add(toCluster(clusterCenters[i], i, (int)clusterSizesMap.get(i).longValue())); } return clusteringModel; }",call intValue() and then there is no cast,Mutualize with the other matcher on tags,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",@snleee This is handled with the API refreshSegment(),Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),suggestion deletedAlarmIds.forEach(alarmId -> {,Please remove debug codes.,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,"verify(client != null, ""client cannot be null"");",this may impact web-ui code. Do we want to expose Snapshot in API?,Should the condition here and the condition on 153 the same?
"private List<Target> computeTargets(final ArgumentParser parser, final List<String> explicitEndpoints, final List<String> domainsArguments, final String srvName) { if (explicitEndpoints != null && !explicitEndpoints.isEmpty()) { final List<Target> targets = Lists.newArrayListWithExpectedSize(explicitEndpoints.size()); for (final String endpoint : explicitEndpoints) { targets.add(ExplicitTarget.from(URI.create(endpoint))); } return targets; } else if (domainsArguments != null && !domainsArguments.isEmpty()) { final Iterable<String> sites = parseDomains(domainsArguments); return SrvTarget.from(srvName, sites); } else if (!cliConfig.getMasterEndpoints().isEmpty()) { final List<URI> cliConfigMasterEndpoints = cliConfig.getMasterEndpoints(); List<Target> targets = Lists.newArrayListWithExpectedSize(cliConfigMasterEndpoints.size()); for (final URI endpoint : cliConfigMasterEndpoints) { targets.add(ExplicitTarget.from(endpoint)); } return targets; } else if (!cliConfig.getSitesString().isEmpty()) { final Iterable<String> sites = parseDomainsString(cliConfig.getSitesString()); return SrvTarget.from(srvName, sites); } handleError(parser, new ArgumentParserException( ""no masters specified. Use the -z or -d option to specify which helios "" + ""cluster/master to connect to"", parser)); return ImmutableList.of(); }",I think you can probably change the return type to List<? extends Target>,Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,@snleee This is handled with the API refreshSegment(),"suggestion log.debug(""{} old entitlement certificates deleted"", count);",throw exception?,I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,suggestion deletedAlarmIds.forEach(alarmId -> {,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Please remove debug codes.,is double call to structIsNull.toBooleanArray() intentional?,"indentation, here and rest of PR"
"void processNotification(OSNotification originalNotification, @Nullable OSNotification notification) { OneSignal.onesignalLog(OneSignal.LOG_LEVEL.DEBUG, ""processNotification called from Thread: "" + Thread.currentThread().toString()); if (notification != null) { boolean display = isStringEmpty(notification.getBody()); if (!display) { notDisplayNotificationLogic(originalNotification); } else { notificationJob.setNotification(notification); NotificationBundleProcessor.processJobForDisplay(this, isBackgroundLogic); } if (isRestoring) OSUtils.sleep(100); } else { notDisplayNotificationLogic(originalNotification); } }",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Please change user back to USER_YODA here.,It's better to use **isBlank** here,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Let's do the same way @jleandroperez did on iOS here <LINK_0>,Two ;;,This commandContext seems unused.,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),"Good catch, thanks. Fixed <LINK_0>"
"public void missingMapping(RegistryEvent.MissingMappings<Item> event) { for (MissingMappings.Mapping<Item> entry : event.getAllMappings()) { if (entry.key.toString().equals(""minecraft:totem"")) { ResourceLocation newTotem = new ResourceLocation(""minecraft:totem_of_undying""); entry.remap(ForgeRegistries.ITEMS.getValue(newTotem)); } if (entry.key.toString().equals(""forge:bucketFilled"")) { ResourceLocation newBucket = new ResourceLocation(""forge:bucket_filled""); entry.remap(ForgeRegistries.ITEMS.getValue(newBucket)); } } }",I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Do not try to parse the sever list if the command has failed (mStatus.code != 0),I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,check to make sure notificationUUID is not null,Suggest JSON related capabilities be isolated to the JsonUtil class.,"If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",ImplUtils has a isNullOrEmpty method that should handle these checks.,suggestion this.ignoreAbove = mw.ignoreAbove;,Replace with logger,Is toString() required? It's already of STRING type.,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));"
"public ProductInfo updateProduct(String productId, ProductInfo pinfo) { if (productId == null) { throw new IllegalArgumentException(""productId is null""); } if (pinfo == null) { throw new IllegalArgumentException(""pinfo is null""); } ProductData pdata = this.productMap.get(productId); if (pdata == null) { throw new IllegalStateException(""product does not exist: "" + productId); } Collection<ProductContentData> pcdata = this.resolveProductContent(pdata.getProductContent()); if (pcdata != null) { pdata.setProductContent(pcdata); } if (pinfo.getName() != null) { pdata.setName(pinfo.getName()); } if (pinfo.getMultiplier() != null) { pdata.setMultiplier(pinfo.getMultiplier()); } if (pinfo.getAttributes() != null) { pdata.setAttributes(pinfo.getAttributes()); } if (pinfo.getDependentProductIds() != null) { pdata.setDependentProductIds(pinfo.getDependentProductIds()); } if (pinfo.getBranding() != null) { pdata.setBranding(this.resolveBranding(pinfo.getBranding())); } this.updateProductContentMappings(pdata); pdata.setUpdated(new Date()); return pdata; }",Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",nit: call it uae?,Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",edgeCacheDNS as a static variable since it's used a few times?,Unrelated change. Should be in a separate commit.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",columnStatistics,log
"public void injectHooks() { HookFile hookFile = fetchHookFile(); if (hookFile == null) { return; } HookParser parser = hookFile.getParser(); Injectable[] injectables = parser.getInjectables(); if (injectables == null) { return; } int index = 0; try { for (Injectable inj : injectables) { inj.inject(); index++; } } catch (NullPointerException ex) { if(!crashed) { Injectable inj = injectables[index]; int resp = UILog.alert(""Outdated client"", ""This server currently has outdated hooks, please report it to a member of the Parabot staff/Dev Team.\r\n\r\n"" + ""Broken hook:\r\n""+inj, new Object[]{""Close"", ""Report here...""}, JOptionPane.ERROR_MESSAGE); if(resp == 1) { URI uri = URI.create(Configuration.COMMUNITY + ""forum/135-reports/""); try { Desktop.getDesktop().browse(uri); } catch (IOException ignore) {} } } crashed = true; throw ex; } Context.getInstance().setHookParser(parser); }",Remove /Dev Team,merge the try/catch with the one below?,Sounds like a workaround for host misconfiguration issue.,The output of this call should be checked and if it's false I think it should bail.,Should TREEHASH be a HashCode?,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",fetch should already happen in Service,Why do we handle error like this?,why var4? Resources.NotFoundException e would be a bit nicer..,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",Make sure to unescape the url path before using it. I've hit this in actual usage.
"public void execute(TupleWindow inputWindow) { for (Tuple tuple : inputWindow.get()) { sum += tuple.getLongByField(""value""); } state.put(""sum"", sum); collector.emit(new Values(sum)); }",You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,nit: unnecessary generic type declaration,"This bloc of code is repeated many times, should be centralized in a single method.",Why not use capabilities directly here?,"To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,I think it would be good to perform this logic in OutputEmitter.,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");"
"private CDPStructuredNotificationDetails getNotificationDetails(ResourceEvent resourceEvent, String resourceCrn, String resourceType, Object payload) { String serializedPayload; try { serializedPayload = new Gson().toJson(payload); LOGGER.debug(""CDPStructuredNotificationDetails' payload has been serialized with ResourceEvent[{}], resource type[{}], CRN[{}]"", resourceEvent.name(), resourceType, resourceCrn); } catch (RuntimeException re) { String msg = String.format(""CDPStructuredNotificationDetails' payload couldn't be serialized with ResourceEvent[%s], resource type[%s], CRN[%s]"", resourceEvent.name(), resourceType, resourceCrn); LOGGER.warn(msg, re); serializedPayload = msg; } return new CDPStructuredNotificationDetails(resourceEvent, resourceCrn, resourceType, serializedPayload); }","I see no reason to introduce msg here, you could just use serializedPayload","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",repeating code line.,Replace with logger,Can this be changed to createSubjectRoleAttribute?,Replace with Objects.requireNotNull.,Do we missing some enums here?,Why not extract receivedId before switch block? (reduce the duplicate code),Suggest JSON related capabilities be isolated to the JsonUtil class.,[minor] could you name it resourceGroupName,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?
"public static Map<String, String> getInputFiles(String descriptorAbsolutePath) { WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, ""Problem parsing WDL file: "" + ex.getMessage(), API_ERROR); } return wdlInputs; }",Put the test in the same package (not directory) and you can at least use package private or protected,I think we need to close this InputStream at some point,"[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE","Here I would just say return true. Then fall through return false, instead of creating a variable.",not good to add sth when calling getter,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",check to make sure notificationUUID is not null,do you clean up these files on exit? or the root level dir is deleted on exit ?,The same.,"in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?","Maybe using a constant here for ""://"""
"public List<Timeline> listTimelines(final String eventType) { return jdbcTemplate.query( BASE_TIMELINE_QUERY + "" WHERE t.et_name=? order by t.t_order"", new Object[]{eventType}, timelineRowMapper); }","a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",any reason for disabling cache for descending order queries ?,nit: unnecessary generic type declaration,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,Floating semicolon,A future refactor might place this method in the enum directly.,Why does this need to be ordered by the synthetic primary key?,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",I think it would be good to perform this logic in OutputEmitter.,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","suggestion Objects.requireNonNull(filter, ""filter cannot be null"");","We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }",nit: unnecessary generic type declaration,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",Why not use capabilities directly here?,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Why does this need to be ordered by the synthetic primary key?,"What do we do, if the result is null?",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,I think it would be good to perform this logic in OutputEmitter.
"private void write(Object msg, boolean flush, ChannelPromise promise) { final AbstractChannelHandlerContext next; if (flush) { AbstractChannelHandlerContext ctx = this; do { ctx = ctx.prev; } while ((ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0); next = ctx; } else { next = findContextOutbound(MASK_WRITE); } final Object m = pipeline.touch(msg, next); EventExecutor executor = next.executor(); if (executor.inEventLoop()) { if (flush) { next.invokeWriteAndFlush(m, promise); } else { next.invokeWrite(m, promise); } } else { final AbstractWriteTask task; if (flush) { task = WriteAndFlushTask.newInstance(next, m, promise); } else { task = WriteTask.newInstance(next, m, promise); } if (!safeExecute(executor, task, promise, m)) { task.cancel(); } } }",Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,Two ;;,Add invariants,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,nit: call it uae?,read the values and validate,merge the try/catch with the one below?,consider using a switch(res) {...},This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?
"public void serialize_test() { Note note = new Note() .setAuthor(HARDCODED_AUTHOR) .setDate(HARDCODED_DATE) .setUserIdsToNotify(Arrays.asList(HARDCODED_USER_IDS)) .setId(HARDCODED_ID) .setContactId(HARDCODED_CONTACT_ID) .setLinkedDealId(HARDCODED_LINKED_ID) .setModifiedAt(HARDCODED_MODIFY_DATE) .setCreatedAt(HARDCODED_CREATE_DATE); String json = NoteSerializer.toJsonObject(note); try { Note parsedNote = NoteSerializer.fromString(json); assertEquals(HARDCODED_AUTHOR, parsedNote.getAuthor()); assertEquals(HARDCODED_CONTACT_ID, parsedNote.getContactId()); assertEquals(HARDCODED_DATE, parsedNote.getDate()); assertEquals(HARDCODED_MODIFY_DATE, parsedNote.getModifiedAt()); assertEquals(HARDCODED_CREATE_DATE, parsedNote.getCreatedAt()); assertEquals(HARDCODED_ID, parsedNote.getId()); List<String> parsedUserIds = parsedNote.getUserIdsToNotify(); List<String> originalUserIds = Arrays.asList(HARDCODED_USER_IDS); assertTrue( parsedUserIds.containsAll(originalUserIds) && originalUserIds.containsAll(parsedUserIds)); } catch (OnePageException e) { e.printStackTrace(); } }",@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail(),"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",The Exception is never thrown.,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed","byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that.",Please don't use sysout. Logging is your friend.,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,We tend to use IllegalArgumentException for these kind,"verify(client != null, ""client cannot be null"");"
"public Owner updateOwner(@PathParam(""owner_key"") @Verify(Owner.class) String key, @ApiParam(name = ""owner"", required = true) Owner owner) { Owner toUpdate = findOwner(key); EventBuilder eventBuilder = eventFactory.getEventBuilder(Target.OWNER, Type.MODIFIED) .setOldEntity(toUpdate); log.debug(""Updating owner: {}"", key); if (owner.getDisplayName() != null) { toUpdate.setDisplayName(owner.getDisplayName()); } if (owner.getParentOwner() != null) { toUpdate.setParentOwner(owner.getParentOwner()); } if (owner.getDefaultServiceLevel() != null) { if (owner.getDefaultServiceLevel().equals("""")) { toUpdate.setDefaultServiceLevel(null); } else { serviceLevelValidator.validate(toUpdate, owner.getDefaultServiceLevel()); toUpdate.setDefaultServiceLevel(owner.getDefaultServiceLevel()); } } if (owner.getAutobindDisabled() != null) { toUpdate.setAutobindDisabled(owner.getAutobindDisabled()); } if (config.getBoolean(ConfigProperties.STANDALONE) && !toUpdate.getContentAccessMode().equals(owner.getContentAccessMode()) && owner.getContentAccessMode() != null) { throw new BadRequestException( i18n.tr(""The owner content access mode cannot be set directly in standalone mode."")); } boolean refreshContentAccess = false; if (owner.getContentAccessMode() != null) { if (toUpdate.isAllowedContentAccessMode(owner.getContentAccessMode())) { String before = toUpdate.getContentAccessMode(); String after = owner.getContentAccessMode(); if (!after.equals(before)) { toUpdate.setContentAccessMode(owner.getContentAccessMode()); refreshContentAccess = true; } } else { throw new BadRequestException( i18n.tr(""The content access mode is not allowed for this owner."")); } } ownerCurator.merge(toUpdate); ownerCurator.flush(); if (refreshContentAccess) { ownerManager.refreshOwnerForContentAccess(toUpdate); } Event e = eventBuilder.setNewEntity(toUpdate).buildEvent(); sink.queueEvent(e); return toUpdate; }",Need a null check here.,"If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",Suggest JSON related capabilities be isolated to the JsonUtil class.,Let's make this InternalServerError,"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",Is toString() required? It's already of STRING type.,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),edgeCacheDNS as a static variable since it's used a few times?,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",ImplUtils has a isNullOrEmpty method that should handle these checks.
"public void testAcquireLockWithLockNotAvailableException() { JedisOps ops = mock(JedisOps.class); when(ops.setnx(eq(""key""), anyString())).thenReturn(0L); when(ops.ttl(""key"")).thenReturn(30L); RedisLock lock = new RedisLock(ops); try { lock.acquireLock(""key"", 10); } catch (LockNotAvailableException e) { assertTrue(""LockNotAvailableException expected"", true); } InOrder inOrder = inOrder(ops); inOrder.verify(ops, times(1)).setnx(eq(""key""), anyString()); inOrder.verify(ops, times(1)).expire(""key"", 10); }","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",@ikhvostenkov please name it json,"I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.","Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.",I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,The Exception is never thrown.,assertEquals and remove the expected value from message string,May be static imports for TimeUnit values here and below?,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,I assume this was meant to be removed?,this should be on System.err
public List<DataType> all() { return new ArrayList<>(dataTypes.values()); },as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",should be possible to provide one,"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",any reason for disabling cache for descending order queries ?,"add ""balanced"" ?",this can be reduced to protected.,Why not use capabilities directly here?,"To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"private void startSequencesAtBeginning(TopicPartition topicPartition, ProducerIdAndEpoch newProducerIdAndEpoch) { final PrimitiveRef.IntRef sequence = PrimitiveRef.ofInt(0); getPartition(topicPartition).resetSequenceNumbers(inFlightBatch -> { inFlightBatch.resetProducerState(newProducerIdAndEpoch, sequence.value, inFlightBatch.isTransactional()); sequence.value += inFlightBatch.recordCount; }); getPartition(topicPartition).nextSequence = sequence.value; getPartition(topicPartition).lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER; }",nit: maybe we can save the result of getPartition(topicPartition),Out of interest why can you not do BuiltinAggregator.values()?,you don't take any resourcees from player when buying dev card,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,isn't the topology always a LocalizedCacheTopology?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"UDP is a datagram protocol, so it doesn't require frame decoder.",Replace with Objects.requireNotNull.,Similar to DistinctCountAggregator,please use long,[minor] could you name it resourceGroupName
"private String getDataSourceName(DataSource dataSource) { Preconditions.checkArgument( dataSource instanceof TableDataSource, ""Subqueries and Unions are only supported in the broker"" ); return Iterables.getOnlyElement(dataSource.getNames()); }",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,"This bloc of code is repeated many times, should be centralized in a single method.","We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }",You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Why not use capabilities directly here?,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.","in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?",Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,"Should this support a null address? Same with the other one, which make support a null or empty address.",I think it would be good to perform this logic in OutputEmitter.,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");"
"private void canTerminate(IProcessDMContext[] procDmcs, DataRequestMonitor<Boolean> rm) { if (procDmcs.length == 0) { IGDBControl gdbControl = fTracker.getService(IGDBControl.class); if (gdbControl != null) { rm.setData(true); } else { rm.setStatus(new Status(IStatus.ERROR, GdbUIPlugin.PLUGIN_ID, ""Service is not available."")); } rm.done(); return; } IMultiTerminate multiTerminate = fTracker.getService(IMultiTerminate.class); if (multiTerminate != null) { multiTerminate.canTerminateSome(procDmcs, rm); } else { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null && procDmcs.length == 1) { procService.canTerminate(procDmcs[0], rm); } else { rm.setData(false);; rm.done(); } } }",Two ;;,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Add invariants,"Good catch, thanks. Fixed <LINK_0>",Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,consider using a switch(res) {...},@snleee This is handled with the API refreshSegment()
"public AbfsRestOperation createPath(final String path, final boolean isFile, final boolean overwrite, final String permission, final String umask, final boolean appendBlob) throws AzureBlobFileSystemException { final List<AbfsHttpHeader> requestHeaders = createDefaultHeaders(); if (!overwrite) { requestHeaders.add(new AbfsHttpHeader(IF_NONE_MATCH, AbfsHttpConstants.STAR)); } if (permission != null && !permission.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_PERMISSIONS, permission)); } if (umask != null && !umask.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_UMASK, umask)); } final AbfsUriQueryBuilder abfsUriQueryBuilder = createDefaultUriQueryBuilder(); abfsUriQueryBuilder.addQuery(QUERY_PARAM_RESOURCE, isFile ? FILE : DIRECTORY); if (appendBlob) { abfsUriQueryBuilder.addQuery(QUERY_PARAM_BLOBTYPE, APPEND_BLOB_TYPE); } final URL url = createRequestUrl(path, abfsUriQueryBuilder.toString()); final AbfsRestOperation op = new AbfsRestOperation( AbfsRestOperationType.CreatePath, this, HTTP_METHOD_PUT, url, requestHeaders); op.execute(); return op; }",Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,I think you can probably change the return type to List<? extends Target>,edgeCacheDNS as a static variable since it's used a few times?,Make sure to unescape the url path before using it. I've hit this in actual usage.,Let's make this InternalServerError,Unrelated change. Should be in a separate commit.,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),just pass sparkJarFilePath.toString less number of changes will be required in the code.,It would be better to make value a constant too,@snleee This is handled with the API refreshSegment()
"private void buildColumns(ElasticsearchTableDescription tableDescription) { Set<ElasticsearchColumn> columns = new HashSet(); Client client = clients.get(tableDescription.getClusterName()); verify(client != null); try { GetMappingsRequest mappingsRequest = new GetMappingsRequest().types(tableDescription.getType()); String index = tableDescription.getIndex(); if (!isNullOrEmpty(index)) { mappingsRequest.indices(index); } ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = client.admin().indices().getMappings(mappingsRequest).actionGet(timeout.toMillis()).getMappings(); Iterator<String> indexIterator = mappings.keysIt(); while (indexIterator.hasNext()) { MappingMetaData mappingMetaData = mappings.get(indexIterator.next()).get(tableDescription.getType()); JSONObject mappingObject = new JSONObject(mappingMetaData.source().toString()).getJSONObject(tableDescription.getType()); JSONObject properties = mappingObject.getJSONObject(""properties""); List<String> lists = new ArrayList<String>(); if (properties.has(""_meta"")) { JSONObject meta = mappingObject.getJSONObject(""_meta""); if (meta.has(""lists"")) { JSONArray arrays = meta.getJSONArray(""lists""); for (int i = 0; i < arrays.length(); i++) { lists.add(arrays.getString(i)); } } } for (String columnMetadata : getColumnsMetadata(null, properties)) { Optional<ElasticsearchColumn> column = createColumn(columnMetadata, lists); if (!column.isPresent()) { continue; } if (columns.stream().noneMatch(col -> col.getName().equals(column.get().getName()))) { columns.add(column.get()); } } } columns.add(createColumn(""_id.type:string"", ImmutableList.of()).get()); columns.add(createColumn(""_index.type:string"", ImmutableList.of()).get()); tableDescription.setColumns(ImmutableList.copyOf(columns)); tableDescription.setColumnsMetadata(columns.stream().map(ElasticsearchColumnMetadata::new).collect(Collectors.toList())); } catch (JSONException e) { throw new PrestoException(ELASTIC_SEARCH_MAPPING_REQUEST_ERROR, e); } }","verify(client != null, ""client cannot be null"");",power down,Why use a java.lang.Boolean and not a primitive boolean?,is double call to structIsNull.toBooleanArray() intentional?,We tend to use IllegalArgumentException for these kind,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)",@snleee This is handled with the API refreshSegment(),Conditional is more clear as: !getZooKeeperInstance().isEmpty()
"private static SecretKeyEncryptionStrategy instantiateSecreteKeyEncryptionStrategy(String className) { log.debug(""About to instantiate secret key encryption strategy {}"", className); SecretKeyEncryptionStrategy strategy = null; Class keyEncryptionStrategyClazz = null; try { keyEncryptionStrategyClazz = AccumuloVFSClassLoader.loadClass(className); } catch (ClassNotFoundException e1) { throw new RuntimeException(""Could not find configured secret key encryption strategy: "" + className); } Class[] interfaces = keyEncryptionStrategyClazz.getInterfaces(); boolean implementsSecretKeyStrategy = false; for (Class clazz : interfaces) { if (clazz.equals(SecretKeyEncryptionStrategy.class)) { implementsSecretKeyStrategy = true; break; } } if (!implementsSecretKeyStrategy) { throw new RuntimeException(""Configured Accumulo secret key encryption strategy \""%s\"" does not implement the SecretKeyEncryptionStrategy interface.""); } else { try { strategy = (SecretKeyEncryptionStrategy) keyEncryptionStrategyClazz.newInstance(); log.debug(""Successfully instantiated secret key encryption strategy {}"", className); } catch (InstantiationException e) { throw new RuntimeException(""Got instantiation exception {} when instantiating secret key encryption strategy "" + className); } catch (IllegalAccessException e) { throw new RuntimeException(""Got illegal access exception when trying to instantiate secret key encryption strategy "" + className); } } return strategy; }","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",nit: call it uae?,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",I don't see sense from this if (MobileContextHelper.isInWebViewContext()),consider using a switch(res) {...},Do we missing some enums here?,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",edgeCacheDNS as a static variable since it's used a few times?,log,I think this test should be moved to options instead,"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task."
public void removeAllChangeListeners() { realm.checkIfValid(); realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE); collection.removeAllListeners(); },"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",Isn't this dataset automatically executed?,Why not use capabilities directly here?,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,"This bloc of code is repeated many times, should be centralized in a single method.",Floating semicolon,I think it would be good to perform this logic in OutputEmitter.,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,"this is followup of above, it should not be required.",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), buildPayload(4 * MiB))).isEqualTo(HashCode.fromString(TREEHASH)); RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), ""PUT /-/vaults/"" + VAULT_NAME + ""/multipart-uploads/"" + MULTIPART_UPLOAD_ID + "" "" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), ""bytes 0-4194303/*""); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), ""4194304""); }",Should TREEHASH be a HashCode?,"EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>",Please don't do unrelated refactor work next time,@ikhvostenkov please name it json,Sounds like a workaround for host misconfiguration issue.,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.","I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",fetch should already happen in Service,power down
"public String render(final ListAllMyBucketsResult obj) throws JsonProcessingException { if (obj == null) { return ""You do not have any buckets""; } ObjectMapper mapper = new ObjectMapper(); return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); }",final,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,nit: unnecessary generic type declaration,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",Why does this need to be ordered by the synthetic primary key?,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",Should we also validate that DataType != null.,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"protected void doMerge(Mapper mergeWith, boolean updateAllTypes) { super.doMerge(mergeWith, updateAllTypes); var mw = ((KeywordFieldMapper) mergeWith); this.ignoreAbove = ((KeywordFieldMapper) mergeWith).ignoreAbove; if (!Objects.equals(this.lengthLimit, mw.lengthLimit)) { throw new IllegalArgumentException( ""mapper ["" + name() + ""] has different length_limit settings, current ["" + this.fieldType().lengthLimit + ""], merged ["" + mw.fieldType().lengthLimit + ""]""); } }",suggestion this.ignoreAbove = mw.ignoreAbove;,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,It's better to use **isBlank** here,Could you please rename also _result?,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Add invariants,Similar to DistinctCountAggregator,this should be on System.err,log,columnStatistics
"private void storeReleasedTime(AndroidCommCarePlatform platform, Reference ref) { long releasedOnTime = -1; if (ref instanceof JavaHttpReference) { Headers responseHeaders = ((JavaHttpReference)ref).getResponseHeaders(); if (responseHeaders != null) { String releasedOnStr = responseHeaders.get(HEADER_APP_RELEASED_ON); try { if (releasedOnStr != null) { releasedOnTime = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"").parse(releasedOnStr).getTime(); } } catch (ParseException e) { e.printStackTrace(); } } } if (releasedOnTime == -1) { releasedOnTime = new Date().getTime(); } HiddenPreferences.setReleasedOnTimeForOngoingAppDownload(platform, releasedOnTime); }","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",This commandContext seems unused.,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Replace with logger,Suggest JSON related capabilities be isolated to the JsonUtil class.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Replace with Objects.requireNotNull.,consider 'ternary if' here,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.
public void centerOnNode(DataNode node) throws NodeNotFoundException { double x = -1; for (WrapperClone wrapperClone : graphData) { if (wrapperClone.getDataNodes().contains(node)) { x = wrapperClone.getX(); break; } } if (x != -1) { setZoomCenter(x); } else { throw new NodeNotFoundException(); } },Wrapper#getX() : float Use float instead of double.,"[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE","Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }","Json -> ""JSON"" (do a search-n-replace)",Do not try to parse the sever list if the command has failed (mStatus.code != 0),why swallowing?,"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,not good to add sth when calling getter,Don't we need to reset alpha here? Drawables share a global state.
"public SourceRecord extractRecord() throws SQLException { Struct record = new Struct(schemaMapping.schema()); for (FieldSetter setter : schemaMapping.fieldSetters()) { try { setter.setField(record, resultSet); } catch (IOException e) { log.warn(""Ignoring record because processing failed:"", e); } catch (SQLException e) { log.warn(""Ignoring record due to SQL error:"", e); } } offset = criteria.extractValues(schemaMapping.schema(), record, offset); final String topic; final Map<String, String> partition; switch (mode) { case TABLE: if (useFqn) { String fqn = ExpressionBuilder.create().append(tableId, false).toString(); partition = new HashMap<>(); partition.put(JdbcSourceConnectorConstants.TABLE_NAME_KEY, fqn); partition.put(JdbcSourceConnectorConstants.OFFSET_PROTOCOL_VERSION, ""1""); topic = topicPrefix + fqn; } else { String name = tableId.tableName(); partition = Collections.singletonMap(JdbcSourceConnectorConstants.TABLE_NAME_KEY, name); topic = topicPrefix + name; } break; case QUERY: partition = Collections.singletonMap(JdbcSourceConnectorConstants.QUERY_NAME_KEY, JdbcSourceConnectorConstants.QUERY_NAME_VALUE); topic = topicPrefix; break; default: throw new ConnectException(""Unexpected query mode: "" + mode); } return new SourceRecord(partition, offset.toMap(), topic, record.schema(), record); }","Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),Remove /Dev Team,fetch should already happen in Service,Please remove debug codes.,suggestion deletedAlarmIds.forEach(alarmId -> {,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",merge the try/catch with the one below?,"verify(client != null, ""client cannot be null"");",is double call to structIsNull.toBooleanArray() intentional?,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)"
"protected void decodeValue(Klv klv) { byte[] bytes = klv.getValue(); CharsetDetector charsetDetector = new CharsetDetector(); charsetDetector.setText(bytes); CharsetMatch charsetMatch = charsetDetector.detect(); Charset charset = Charset.defaultCharset(); if (charsetMatch != null) { try { charset = Charset.forName(charsetMatch.getName()); } catch (IllegalArgumentException e) { LOGGER.trace( ""Unsupported encoding of %s, falling back to default encoding"", charsetMatch.getName()); } } value = new String(bytes, charset); }",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",Is toString() required? It's already of STRING type.,Style nit: unneeded curlies,"Maybe using a constant here for ""://""",The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Extra space,Suggest JSON related capabilities be isolated to the JsonUtil class.,might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,We have a StringMarshal helper class that does all of this UTF8 logic for a string.,"java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }"
"private AzureBlobStorageImpl constructImpl() { Objects.requireNonNull(blobName, ""'blobName' cannot be null.""); if (Objects.isNull(containerName) || containerName.isEmpty()) { containerName = BlobContainerAsyncClient.ROOT_CONTAINER_NAME; } checkValidEncryptionParameters(); HttpPipeline pipeline = super.getPipeline(); if (pipeline == null) { pipeline = buildPipeline(); } return new AzureBlobStorageBuilder() .url(String.format(""%s/%s/%s"", endpoint, containerName, blobName)) .pipeline(pipeline) .build(); }",ImplUtils has a isNullOrEmpty method that should handle these checks.,Let's make this InternalServerError,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",This commandContext seems unused.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Style nit: unneeded curlies,check to make sure notificationUUID is not null,Is toString() required? It's already of STRING type.,"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",It's better to use **isBlank** here,The Exception is never thrown.
"public void testLongFileNameThatDoesNotRequireEncoding() { String str = StringUtils.repeat(""1"", 256); assertEquals( ""11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.71634944"", fileManager.getFileName(TaskTestUtil.createMockTask(str), true)); }",Could you use Strings.repeat or something?,There should be a space here between expected and school.roster(),Why this change?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,@Serranya The same here. See above.,nit: any chance to make the message assertion more specific? :),"this is followup of above, it should not be required.",These could be renamed to not use nonAscii.,SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,check to make sure notificationUUID is not null,do you clean up these files on exit? or the root level dir is deleted on exit ?
"public boolean applyCSSProperty(Object element, String property, CSSValue value, String pseudo, CSSEngine engine) throws Exception { if (!(element instanceof ISelectionBackgroundCustomizationElement && element instanceof ElementAdapter) || !(((ElementAdapter) element).getNativeWidget() instanceof Widget) || property == null || value.getCssValueType() != CSSValue.CSS_PRIMITIVE_VALUE) { return false; } Widget widget = (Widget) ((ElementAdapter) element).getNativeWidget(); ISelectionBackgroundCustomizationElement treeElement = (ISelectionBackgroundCustomizationElement) element; Color newColor = (Color) engine.convert(value, Color.class, widget.getDisplay()); switch (property.toLowerCase()) { case SWT_SELECTION_FOREGROUND_COLOR: treeElement.setSelectionForegroundColor(newColor); break; case SWT_SELECTION_BACKGROUND_COLOR: treeElement.setSelectionBackgroundColor(newColor); break; case SWT_SELECTION_BORDER_COLOR: treeElement.setSelectionBorderColor(newColor); break; case SWT_HOT_BACKGROUND_COLOR: treeElement.setHotBackgroundColor(newColor); break; case SWT_HOT_BORDER_COLOR: treeElement.setHotBorderColor(newColor); break; } return true; }",the original code does not make toLowerCase(). Why did you add it?,Is toString() required? It's already of STRING type.,edgeCacheDNS as a static variable since it's used a few times?,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Iffy formatting,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),we should probably check in the canExecute whether we reached the start of the list,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",repeating code line.,Add invariants
public Optional<Guid> getUserIdIfExternal() { return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId()); },this can be reduced to protected.,any reason for disabling cache for descending order queries ?,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Why not use capabilities directly here?,"This bloc of code is repeated many times, should be centralized in a single method.",A future refactor might place this method in the enum directly.,Floating semicolon,curly braces aren't required,"To match the old format, do ""Network parameters:\n "" here.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-)
"protected DatabaseName unmarshal0( ReadableChannel channel ) throws IOException { byte nullMarker = channel.get(); if ( nullMarker == 0 ) { return null; } else { int nameLength = (int) channel.get(); byte[] nameBytes = new byte[nameLength]; channel.get( nameBytes, nameLength ); return new DatabaseName( UTF8.decode( nameBytes ) ); } }",We have a StringMarshal helper class that does all of this UTF8 logic for a string.,"[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE","This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()",@ekondrashev why not just rsp = opt?,check to make sure notificationUUID is not null,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.",static import,Replace with logger,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here
"protected <C, R> void doDispatch(CommandMessage<C> command, CommandCallback<? super C, R> callback) { MessageMonitor.MonitorCallback monitorCallback = messageMonitor.onMessageIngested(command); MessageHandler<? super CommandMessage<?>> handler = findCommandHandlerFor(command).orElseThrow(() -> { NoHandlerForCommandException exception = new NoHandlerForCommandException( format(""No handler was subscribed to command [%s]"", command.getCommandName())); monitorCallback.reportFailure(exception); return exception; }); try { Object result = doDispatch(command, handler); monitorCallback.reportSuccess(); callback.onSuccess(command, (R) result); } catch (Exception throwable) { monitorCallback.reportFailure(throwable); callback.onFailure(command, throwable); } }",Shouldn't it be No handler was subscribed **for** command?,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?,"UDP is a datagram protocol, so it doesn't require frame decoder.",@ekondrashev why not just rsp = opt?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,Iffy formatting,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,This seems to be unnecessary. I also get the label after removing this.,May be static imports for TimeUnit values here and below?
"private void processNewResponses() throws InterruptedException, IOException { SocketServerResponse curr = (SocketServerResponse) channel.receiveResponse(id); while (curr != null) { curr.onDequeueFromResponseQueue(); SocketServerRequest request = (SocketServerRequest) curr.getRequest(); String connectionId = request.getConnectionId(); try { if (curr.getPayload() == null) { logger.trace(""Socket server received no response and hence closing the connection""); selector.close(connectionId); } else { logger.trace(""Socket server received response to send, registering for write: {}"", curr); NetworkSend networkSend = new NetworkSend(connectionId, curr.getPayload(), curr.getMetrics(), time); selector.send(networkSend); } } catch (IllegalStateException e) { logger .error(""Attempt to write to socket for which there is no open connection. Connection id {}"", connectionId); } finally { curr = (SocketServerResponse) channel.receiveResponse(id); } } }",This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,nit: call it uae?,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",fetch should already happen in Service,Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,Remove /Dev Team,read the values and validate,remove this log
"public static boolean postHasEdits(@Nullable PostImmutableModel oldPost, PostImmutableModel newPost) { if (oldPost == null) { return newPost != null; } return newPost == null || !(StringUtils.equals(oldPost.getTitle(), newPost.getTitle()) && StringUtils.equals(oldPost.getContent(), newPost.getContent()) && StringUtils.equals(oldPost.getExcerpt(), newPost.getExcerpt()) && StringUtils.equals(oldPost.getStatus(), newPost.getStatus()) && StringUtils.equals(oldPost.getPassword(), newPost.getPassword()) && StringUtils.equals(oldPost.getPostFormat(), newPost.getPostFormat()) && StringUtils.equals(oldPost.getDateCreated(), newPost.getDateCreated()) && StringUtils.equals(oldPost.getSlug(), newPost.getSlug()) && oldPost.getFeaturedImageId() == newPost.getFeaturedImageId() && oldPost.getTagNameList().containsAll(newPost.getTagNameList()) && newPost.getTagNameList().containsAll(oldPost.getTagNameList()) && oldPost.getCategoryIdList().containsAll(newPost.getCategoryIdList()) && newPost.getCategoryIdList().containsAll(oldPost.getCategoryIdList()) && oldPost.getLocation().equals(newPost.getLocation()) && oldPost.getChangesConfirmedContentHashcode() == newPost .getChangesConfirmedContentHashcode() ); }",Shouldn't we call PostLocation.companion.equals here?,This check seems a little fragile at first glance (not sure why.),Why parseDouble and then convert that to int instead of directly parsing to int ?,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Iffy formatting,I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction(),Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),columnStatistics,@snleee This is handled with the API refreshSegment(),"Let's add a constant for ""version 2""",Unrelated change. Should be in a separate commit.
"public void noConflictTable() throws Exception, UpdateException { long baseline = System.currentTimeMillis(); final DataBuilderProvider.DataBuilder builder = DataBuilderProvider .row(-1, true); for (int i = 0; i < 1000; i++) { builder .row(i, true); } final Object[][] end = builder.end(); long now = System.currentTimeMillis(); System.out.println(""Loading of model took.. "" + (now - baseline) + "" ms""); baseline = now; final GuidedDecisionTable52 table52 = analyzerProvider.makeAnalyser() .withPersonAgeColumn(""=="") .withPersonApprovedActionSetField() .withData(end) .buildTable(); now = System.currentTimeMillis(); System.out.println(""Made table.. "" + (now - baseline) + "" ms""); baseline = now; final Analyzer analyzer = analyzerProvider.makeAnalyser(table52); now = System.currentTimeMillis(); System.out.println(""Indexing.. "" + (now - baseline) + "" ms""); baseline = now; analyzer.analyze(); now = System.currentTimeMillis(); System.out.println(""Validated.. "" + (now - baseline) + "" ms""); baseline = now; table52.getData() .get(1) .get(2) .setNumericValue(3); List<Coordinate> updates = new ArrayList<>(); updates.add(new Coordinate(1, 2)); analyzerProvider.getUpdateManager(table52, analyzer) .update(table52, updates); now = System.currentTimeMillis(); System.out.println(""Update.. "" + (now - baseline) + "" ms""); assertContains(REDUNDANT_ROWS, analyzerProvider.getAnalysisReport()); }",Please don't use sysout. Logging is your friend.,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,columnStatistics,I think this test should be moved to options instead,just pass sparkJarFilePath.toString less number of changes will be required in the code.,Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,"verify(client != null, ""client cannot be null"");","Let's add a constant for ""version 2""",this should be on System.err,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",The output of this call should be checked and if it's false I think it should bail.
"private void makeDependences(Job job, Map<String, ArrayList<String>> dependencies) throws JobCreationException { if (dependencies != null && dependencies.size() > 0 && job.getType() == JobType.TASKSFLOW) { TaskFlowJob tfj = (TaskFlowJob) job; for (Task t : tfj.getTasks()) { ArrayList<String> names = dependencies.get(t.getName()); if (names != null) { for (String name : names) { if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); } } } } } }","You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",suggestion this.ignoreAbove = mw.ignoreAbove;,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Two ;;,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Add invariants,ImplUtils has a isNullOrEmpty method that should handle these checks.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle."
"private SubPlan reassignPartitioningHandleIfNecessaryHelper(Session session, Metadata metadata, SubPlan subPlan, PartitioningHandle newOutputPartitioningHandle) { PlanFragment fragment = subPlan.getFragment(); PartitioningHandleReassigner partitioningHandleReassigner = new PartitioningHandleReassigner(fragment.getPartitioning(), metadata, session); PlanNode newRoot; if (fragment.getPartitioning().isSingleNode()) { newRoot = fragment.getRoot(); } else { newRoot = SimplePlanRewriter.rewriteWith(partitioningHandleReassigner, fragment.getRoot()); } PartitioningScheme outputPartitioningScheme = fragment.getPartitioningScheme(); Partitioning newOutputPartitioning = outputPartitioningScheme.getPartitioning(); if (outputPartitioningScheme.getPartitioning().getHandle().getConnectorId().isPresent()) { newOutputPartitioning = newOutputPartitioning.withAlternativePartitiongingHandle(newOutputPartitioningHandle); } PlanFragment newFragment = new PlanFragment( fragment.getId(), newRoot, fragment.getSymbols(), fragment.getPartitioning(), fragment.getPartitionedSources(), new PartitioningScheme( newOutputPartitioning, outputPartitioningScheme.getOutputLayout(), outputPartitioningScheme.getHashColumn(), outputPartitioningScheme.isReplicateNullsAndAny(), outputPartitioningScheme.getBucketToPartition()), fragment.getStageExecutionStrategy(), fragment.getStatsAndCosts()); ImmutableList.Builder<SubPlan> childrenBuilder = ImmutableList.builder(); for (SubPlan child : subPlan.getChildren()) { childrenBuilder.add(reassignPartitioningHandleIfNecessaryHelper(session, metadata, child, fragment.getPartitioning())); } return new SubPlan(newFragment, childrenBuilder.build()); }",Should the condition here and the condition on 153 the same?,Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),The output of this call should be checked and if it's false I think it should bail.,Please remove debug codes.,"verify(client != null, ""client cannot be null"");",It would be better to make value a constant too,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,Why use a java.lang.Boolean and not a primitive boolean?,@snleee This is handled with the API refreshSegment(),read the values and validate
"public void doPolling(Guid cmdId, List<Guid> childCmdIds) { RebootVmCommand<P> command = getCommand(cmdId); boolean anyFailed = false; for (Guid childCmdId : childCmdIds) { CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId); switch (entity.getCommandStatus()) { case FAILED: case FAILED_RESTARTED: case UNKNOWN: anyFailed = true; break; default: break; } } if (anyFailed) { command.setCommandStatus(CommandStatus.FAILED); } else { VM vm = DbFacade.getInstance().getVmDao().get(command.getParameters().getVmId()); if (isVmDownForColdReboot(vm)) { command.proceedWithColdRun(); } } }",what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Please change user back to USER_YODA here.,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,"Good catch, thanks. Fixed <LINK_0>",Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,Two ;;,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",log
public void run() { if (!mServiceConnection.isBound()) { mServiceConnection.unBindService(mContext); mCallback.onError(new AuthenticationException(ADALError.BROKER_BIND_SERVICE_FAILED)); } },It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,Isn't this dataset automatically executed?,"This bloc of code is repeated many times, should be centralized in a single method.",Floating semicolon,nit: unnecessary generic type declaration,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,I think it would be good to perform this logic in OutputEmitter.,why swallowing?,"this is followup of above, it should not be required.",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public int hashCode() { return Objects.hash(machine, content); }","-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.","What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",@Irenyak1 why return false here?,as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },should be possible to provide one,"don't return NULL, throw UnsupportedOperatedException instead","add ""balanced"" ?","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",Remove cast,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"private Stream<Map<Address, InternalCacheEntry<K, V>>> getConflicts(LocalizedCacheTopology topology) { if (stateConsumer.isStateTransferInProgress()) throw log.getConflictsStateTransferInProgress(cacheName); if (!streamInProgress.compareAndSet(false, true)) throw log.getConflictsAlreadyInProgress(); try { return StreamSupport .stream(new ReplicaSpliterator(topology), false) .filter(filterConsistentEntries()); } finally { streamInProgress.compareAndSet(true, false); } }",isn't the topology always a LocalizedCacheTopology?,consider using a switch(res) {...},"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",suggestion this.ignoreAbove = mw.ignoreAbove;,Similar to DistinctCountAggregator,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,@snleee This is handled with the API refreshSegment(),Could you please rename also _result?,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,columnStatistics
"public void testMergeRunnersEnsureGroupMerging() throws Exception { GroupByQuery query = GroupByQuery .builder() .setDataSource(""xx"") .setQuerySegmentSpec(new LegacySegmentSpec(""1970/3000"")) .setGranularity(QueryGranularities.ALL) .setDimensions(Lists.<DimensionSpec>newArrayList(new DefaultDimensionSpec(""tags"", ""tags""))) .setAggregatorSpecs( Arrays.asList( new AggregatorFactory[] { new CountAggregatorFactory(""count"") } ) ) .build(); final QueryRunnerFactory factory = GroupByQueryRunnerTest.makeQueryRunnerFactory(new GroupByQueryConfig()); QueryRunner mergedRunner = factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { return factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { try { return new MergeSequence( query.getResultOrdering(), Sequences.simple( Arrays.asList( factory.createRunner(createSegment()).run(query, responseContext), factory.createRunner(createSegment()).run(query, responseContext) ) ) ); } catch (Exception e) { Assert.fail(e.getMessage()); return null; } } } ).run(query, responseContext); } } ); Sequence<Row> result = mergedRunner.run(query, Maps.newHashMap()); List<Row> expectedResults = Arrays.asList( GroupByQueryRunnerTestHelper.createExpectedRow(""1970-01-01T00:00:00.000Z"", ""tags"", ""t1"", ""count"", 2L), GroupByQueryRunnerTestHelper.createExpectedRow(""1970-01-01T00:00:00.000Z"", ""tags"", ""t2"", ""count"", 4L) ); TestHelper.assertExpectedObjects(expectedResults, Sequences.toList(result, new ArrayList<Row>()), """"); }",Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e),Mutualize with the other matcher on tags,"I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",also here please use Short.MAX_VALUE,call intValue() and then there is no cast,"Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0","verify(client != null, ""client cannot be null"");",@jomarko Thanks.. I'd have made this Integer.class.getName() too,power down
"public WTextAreaUI() { panel.add(messages); WFieldLayout fieldLayout = new WFieldLayout(LAYOUT_FLAT); fieldLayout.setTitle(""this is a bunch of fields""); WTextArea wTextField = new WTextArea(); fieldLayout.addField(""this is a textarea"", wTextField); wTextField.setMandatory(true); panel.add(fieldLayout); add(createWButton()); add(panel); }",Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,not good to add sth when calling getter,I think we always display view names capitalized to users.,"Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Put the test in the same package (not directory) and you can at least use package private or protected,consider 'ternary if' here,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"Maybe using a constant here for ""://""",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,This can be removed? (Being added later.)
"public String toString() { StringBuilder result = new StringBuilder(""[Test: \"""" + m_name + ""\"""").append("" verbose:"").append(m_verbose); result.append(""[parameters:""); for (Map.Entry<String, String> entry : m_parameters.entrySet()) { result.append(entry.getKey()).append(""=>"").append(entry.getValue()); } result.append(""]""); result.append(""[metagroups:""); for (Map.Entry<String, List<String>> entry : m_metaGroups.entrySet()) { result.append(entry.getKey()).append(""=""); for (String n : entry.getValue()) { result.append(n).append("",""); } } result.append(""] ""); result.append(""[included: ""); for (String g : m_includedGroups) { result.append(g).append("" ""); } result.append(""]""); result.append(""[excluded: ""); for (String g : m_excludedGroups) { result.append(g).append(""""); } result.append(""] ""); result.append("" classes:""); for (XmlClass cl : m_xmlClasses) { result.append(cl).append("" ""); } result.append("" packages:""); for (XmlPackage p : m_xmlPackages) { result.append(p).append("" ""); } result.append(""] ""); return result.toString(); }","You missed new StringBuilder().append(""[Test: \"""").append(m_name).append(""\"""")",log,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",this should be on System.err,"Let's add a constant for ""version 2""",Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,We tend to use IllegalArgumentException for these kind,"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"indentation, here and rest of PR","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")"
"public void testRename() throws Exception { typeContext = new LabelClientTypeContext(store, LabelType.METRIC, metrics, eventBus, MAX_CACHE_SIZE); final LabelId labelId = typeContext.createId(""oldName"").get(); ListenableFuture<Void> response = typeContext.rename(""oldName"", ""newName""); Futures.addCallback(response, new FutureCallback<Void>() { @Override public void onSuccess(final Void result) { Futures.addCallback(typeContext.getName(labelId), new FutureCallback<Optional<String>>() { @Override public void onSuccess(final Optional<String> result) { if (!result.isPresent()) { fail(); } assertEquals(""newName"", result.get()); } @Override public void onFailure(final Throwable throwable) { fail(); } }); } @Override public void onFailure(final Throwable throwable) { fail(); } }); }","See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,Sounds like a workaround for host misconfiguration issue.,Should TREEHASH be a HashCode?,@ikhvostenkov please name it json,why var4? Resources.NotFoundException e would be a bit nicer..,"Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",fetch should already happen in Service,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Iffy formatting,"verify(client != null, ""client cannot be null"");"
public void setLibraryAliasGenerator(NameGenerator<Library> generator) { this.libraryAliasGenerator = (DefaultLibraryAliasGenerator) generator; },Remove cast,Check for illegal arg or are we happy with a ClassCastException here?,"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",@Irenyak1 why return false here?,"don't return NULL, throw UnsupportedOperatedException instead",should be possible to provide one,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",Is there a reason this isn't implemented?,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode."
public Set<Field> getFields() { return fields.keySet(); },"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",should be possible to provide one,@Irenyak1 why return false here?,as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.","add ""balanced"" ?","don't return NULL, throw UnsupportedOperatedException instead",this can be reduced to protected.,any reason for disabling cache for descending order queries ?,"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"protected void deleteLog() { CommandContext commandContext = new CommandContext(); commandContext.setData(""SingleRun"", ""true""); commandContext.setData(""OlderThan"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"").format(new Date())); synchronized (this) { jobServicesClient.scheduleRequest(CONTAINER_ID, JobRequestInstance.builder().command(""org.jbpm.executor.commands.LogCleanupCommand"").build()); } }",This commandContext seems unused.,check to make sure notificationUUID is not null,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,It's better to use **isBlank** here,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)","Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Let's do the same way @jleandroperez did on iOS here <LINK_0>,this should be on System.err,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap"
"private ContextMenuHandler showContextMenu() { if (contextMenuHandler == null) { contextMenuHandler = event -> { event.preventDefault(); event.stopPropagation(); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().show(); }; } return contextMenuHandler; }",Twice the same call.,printStackTrace() must not be used. Use a logger instead.,Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }","Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Wrapper#getX() : float Use float instead of double.,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,Feels like this null check can be included above.,not good to add sth when calling getter,why swallowing?,Don't we need to reset alpha here? Drawables share a global state.
"protected Control renderControl(SWTGridCell cell, Composite parent) throws NoRendererFoundException, NoPropertyDescriptorFoundExeption { final CTabFolder folder = new CTabFolder(parent, SWT.BOTTOM); folder.setBackground(parent.getBackground()); final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); final AdapterFactoryItemDelegator adapterFactoryItemDelegator = new AdapterFactoryItemDelegator( composedAdapterFactory); final EList<VAbstractCategorization> categorizations = getCategorizations(); for (final VAbstractCategorization categorization : categorizations) { final CTabItem item = new CTabItem(folder, SWT.NULL); final IItemPropertyDescriptor itemPropertyDescriptor = adapterFactoryItemDelegator.getPropertyDescriptor( categorization, VViewPackage.eINSTANCE.getElement_Name()); String categorizationName; if (itemPropertyDescriptor == null) { categorizationName = ""Categorization""; } else { final PropertyValueWrapper valueWrapper = (PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization); if (valueWrapper == null) { categorizationName = itemPropertyDescriptor.getDisplayName(categorization); } else { categorizationName = (String) ((PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization)).getEditableValue(categorization); } } item.setText(categorizationName); final AbstractSWTRenderer<VElement> renderer = getSWTRendererFactory().getRenderer(categorization, getViewModelContext()); final SWTGridDescription gridDescription = renderer.getGridDescription(GridDescriptionFactory.INSTANCE .createEmptyGridDescription()); for (final SWTGridCell gridCell : gridDescription.getGrid()) { final Control render = renderer.render(gridCell, folder); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.FILL).grab(true, true) .applyTo(render); item.setControl(render); } } composedAdapterFactory.dispose(); if (folder.getItemCount() > 0) { folder.setSelection(0); } return folder; }",what is a PropertyValueWrapper? Why do you need it?,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",just pass sparkJarFilePath.toString less number of changes will be required in the code.,merge the try/catch with the one below?,is double call to structIsNull.toBooleanArray() intentional?,The output of this call should be checked and if it's false I think it should bail.,This seems to be unnecessary. I also get the label after removing this.,"verify(client != null, ""client cannot be null"");",throw exception?,@snleee This is handled with the API refreshSegment()
"public static void copy(File source, File dest) throws IOException { try (InputStream in = new FileInputStream(source)) { try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } } }",consider replacing 96-97 with just one try block (see line 455),curly braces aren't required,It would have been shorter to inline this variable and not have it in scope. :-),"Looks like a duplication to me. How about this.json().getString(""name"")?","[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE",Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",Should we also validate that DataType != null.
"public boolean includeMethod( IMethodSelectorContext context, ITestNGMethod tm, boolean isTestMethod) { if (!m_isInitialized) { m_isInitialized = true; init(context); } if (script != null) { return getScriptSelector(script.getLanguage()).includeMethodFromExpression(script.getExpression(), tm); } return includeMethodFromIncludeExclude(tm, isTestMethod); }",So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Out of interest why can you not do BuiltinAggregator.values()?,It's better to use **isBlank** here,Similar to DistinctCountAggregator,[minor] could you name it resourceGroupName,"UDP is a datagram protocol, so it doesn't require frame decoder.",not a field
"public String getUpload() { Desktop desktop = getDesktop(); String upload = _auxinf != null ? _auxinf.upload : null; if (desktop != null && !Strings.isEmpty(upload) && !upload.contains(""maxsize="")) upload = upload.concat("",maxsize="" + desktop.getWebApp().getConfiguration().getMaxUploadSize()); return upload; }",not good to add sth when calling getter,"String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.","Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,Wrapper#getX() : float Use float instead of double.,Put the test in the same package (not directory) and you can at least use package private or protected,"Maybe using a constant here for ""://""","We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,"in range yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?"
"public void testSendCloseSession() throws Exception { assertTrue(""Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!"", serverFactory instanceof NettyServerCnxnFactory); try (ZooKeeper zk = createClient()) { final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer(); final String path = ""/a""; zk.create(path, ""test"".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); assertNotNull(""Didn't create znode:"" + path, zk.exists(path, true)); assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount()); Iterable<ServerCnxn> connections = serverFactory.getConnections(); assertEquals(""Mismatch in number of live connections!"", 1, serverFactory.getNumAliveConnections()); for (ServerCnxn serverCnxn : connections) { serverCnxn.sendCloseSession(); } LOG.info(""Waiting for the channel disconnected event""); int timeout = 0; while (serverFactory.getNumAliveConnections() != 0) { Thread.sleep(1000); timeout += 1000; if (timeout > CONNECTION_TIMEOUT) { fail(""The number of live connections should be 0""); } } assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount()); } }",Please don't do unrelated refactor work next time,"EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>",Should TREEHASH be a HashCode?,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Sounds like a workaround for host misconfiguration issue.,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?","I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",I assume this was meant to be removed?,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",We tend to use IllegalArgumentException for these kind,power down
"public static SentryStackTraceElement[] fromStackTraceElements(StackTraceElement[] stackTraceElements) { Frame[] localsCache = LocalsCache.getCache(); SentryStackTraceElement[] sentryStackTraceElements = new SentryStackTraceElement[stackTraceElements.length]; boolean mayHaveLocals = localsCache.length == stackTraceElements.length; for (int i = 0; i < stackTraceElements.length; i++) { Map<String, Object> vars = null; if (mayHaveLocals) { Frame frame = localsCache[i]; Frame.LocalVariable[] frameLocals = frame.getLocals(); if (frameLocals != null && frameLocals.length > 0) { for (Frame.LocalVariable localVariable : frameLocals) { if (localVariable != null) { if (vars == null) { vars = new HashMap<>(); } vars.put(localVariable.getName(), localVariable.getValue()); } } } } sentryStackTraceElements[i] = fromStackTraceElement(stackTraceElements[i], vars); } return sentryStackTraceElements; }",This check seems a little fragile at first glance (not sure why.),"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",UtilKtKt isn't a great name.,is double call to structIsNull.toBooleanArray() intentional?,@snleee This is handled with the API refreshSegment(),This seems to be unnecessary. I also get the label after removing this.,Add invariants,Iffy formatting,rename 'variableName',we should probably check in the canExecute whether we reached the start of the list,No need to explicitly load tables with query if you are using the latest build
public void runBeforeAllTests() { conceptService = Context.getConceptService(); executeDataSet(STANDARD_TEST_DATASET_XML); },Isn't this dataset automatically executed?,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"This bloc of code is repeated many times, should be centralized in a single method.",There should be a space here between expected and school.roster(),"To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,Why this change?,"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?","you should check the cache doesn't exist, plus that no suggestion to use the cache is logged",SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
"public static void setParamsWithRegistrationConfigurationMappings(RegistrationConfiguration registrationConfiguration, ImportFromConfParameters params) { if (registrationConfiguration.getAffinityGroupMappings() != null && registrationConfiguration.isSetAffinityGroupMappings()) { Map<String, Object> affinityGroupMap = new HashMap<>(); affinityGroupMap.put(AFFINITY_GROUP_KEY, mapAffinityGroupMapping(registrationConfiguration.getAffinityGroupMappings())); params.setAffinityGroupMap(affinityGroupMap); } if (registrationConfiguration.getAffinityLabelMappings() != null && registrationConfiguration.isSetAffinityLabelMappings()) { Map<String, Object> affinityLabelMap = new HashMap<>(); affinityLabelMap.put(AFFINITY_LABEL_KEY, mapAffinityLabelMapping(registrationConfiguration.getAffinityLabelMappings())); params.setAffinityLabelMap(affinityLabelMap); } if (registrationConfiguration.getClusterMappings() != null && registrationConfiguration.isSetClusterMappings()) { Map<String, Object> clusterMap = new HashMap<>(); clusterMap.put(CLUSTER_KEY, mapClusterMapping(registrationConfiguration.getClusterMappings())); params.setClusterMap(clusterMap); } if (registrationConfiguration.getLunMapping() != null && registrationConfiguration.isSetLunMapping()) { Map<String, Object> lunMap = new HashMap<>(); lunMap.put(EXTERNAL_LUN_KEY, mapExternalLunMapping(registrationConfiguration.getLunMapping())); params.setExternalLunMap(lunMap); } if (registrationConfiguration.getRoleMappings() != null && registrationConfiguration.isSetRoleMappings()) { Map<String, Object> roleMap = new HashMap<>(); roleMap.put(ROLE_KEY, mapExternalRoleMapping(registrationConfiguration.getRoleMappings())); params.setRoleMap(roleMap); } if (registrationConfiguration.getDomainMappings() != null && registrationConfiguration.isSetDomainMappings()) { Map<String, Object> domainMap = new HashMap<>(); domainMap.put(DOMAIN_KEY, mapExternalDomainMapping(registrationConfiguration.getDomainMappings())); params.setDomainMap(domainMap); } }","If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",Do not try to parse the sever list if the command has failed (mStatus.code != 0),Let's make this InternalServerError,Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),edgeCacheDNS as a static variable since it's used a few times?,"I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",ImplUtils has a isNullOrEmpty method that should handle these checks.
"private void fillDriverSpecificChannelConfiguration(final Tocd mainOcd, final List<Tad> driverSpecificChannelConfiguration) { final ChannelDescriptor basicChanneldescriptor = new BaseChannelDescriptor(); final Object baseChannelDescriptor = basicChanneldescriptor.getDescriptor(); if (nonNull(baseChannelDescriptor) && baseChannelDescriptor instanceof List<?>) { List<Tad> channelConfiguration = (List<Tad>) baseChannelDescriptor; channelConfiguration.addAll(driverSpecificChannelConfiguration); for (final Tad attribute : channelConfiguration) { final Set<String> channelPrefixes = retrieveChannelPrefixes(this.assetConfiguration.getAssetChannels()); for (final String prefix : channelPrefixes) { final Tad newAttribute = cloneAd(attribute, prefix); mainOcd.addAD(newAttribute); } } } }",Add invariants,log,Two ;;,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",No need to explicitly load tables with query if you are using the latest build,suggestion this.ignoreAbove = mw.ignoreAbove;,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Do we missing some enums here?,This statement slot.getValueList().getValue()) could cause an NPE,@snleee This is handled with the API refreshSegment()
"protected ACTION getUserAction(Cluster cluster, Path buildPath) throws FalconException { ACTION action = unmarshalAction(ACTION_TEMPLATE); JAXBElement<org.apache.falcon.oozie.spark.ACTION> actionJaxbElement = OozieUtils.unMarshalSparkAction(action); org.apache.falcon.oozie.spark.ACTION sparkAction = actionJaxbElement.getValue(); String sparkMasterURL = entity.getSparkAttributes().getMaster(); Path sparkJarFilePath = new Path(entity.getSparkAttributes().getJar()); String sparkJobName = entity.getSparkAttributes().getName(); String sparkOpts = entity.getSparkAttributes().getSparkOpts(); String sparkClassName = entity.getSparkAttributes().getClazz(); String clusterEntitySparkMasterURL = getClusterEntitySparkMaster(cluster); sparkMasterURL = (sparkMasterURL == null) ? clusterEntitySparkMasterURL : sparkMasterURL; if (StringUtils.isBlank(sparkMasterURL)) { throw new FalconException(""Spark Master URL can'be empty""); } sparkAction.setMaster(sparkMasterURL); sparkAction.setName(sparkJobName); addPrepareDeleteOutputPath(sparkAction); if (StringUtils.isNotEmpty(sparkOpts)) { sparkAction.setSparkOpts(sparkOpts); } if (StringUtils.isNotEmpty(sparkClassName)) { sparkAction.setClazz(sparkClassName); } List<String> argList = sparkAction.getArg(); List<String> sparkArgs = entity.getSparkAttributes().getArgs(); if (sparkArgs != null) { argList.addAll(sparkArgs); } addOutputFeedsAsArgument(argList, cluster); addInputFeedsAsArgument(argList, cluster); validateSparkJarFilePath(sparkJarFilePath); sparkAction.setJar(getSparkJarFileName(sparkJarFilePath)); setSparkLibFileToWorkflowLib(sparkJarFilePath, entity); propagateEntityProperties(sparkAction); OozieUtils.marshalSparkAction(action, actionJaxbElement); return action; }",just pass sparkJarFilePath.toString less number of changes will be required in the code.,Make sure to unescape the url path before using it. I've hit this in actual usage.,merge the try/catch with the one below?,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",throw exception?,@snleee This is handled with the API refreshSegment(),edgeCacheDNS as a static variable since it's used a few times?,The output of this call should be checked and if it's false I think it should bail.,fetch should already happen in Service,Should the condition here and the condition on 153 the same?,"verify(client != null, ""client cannot be null"");"
"public ArrayList<Pojo> getResults(String query) { ArrayList<Pojo> pojos = new ArrayList<>(); if (android.os.Build.VERSION.SDK_INT >= 11) { Set<String> selectedProviders = new TreeSet<>(); selectedProviders.addAll(PreferenceManager.getDefaultSharedPreferences(this).getStringSet(""search-providers"", new HashSet<>(Arrays.asList(""Google"")))); for (String searchProvider : selectedProviders) { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.url = searchProviderUrls.get(searchProvider); pojo.name = searchProvider; pojos.add(pojo); } } else { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.name=""Google""; pojo.url = searchProviderUrls.get(""Google""); pojos.add(pojo); } Pattern p = Pattern.compile(URL_REGEX); Matcher m = p.matcher(query); if(m.find()) { String guessedUrl = URLUtil.guessUrl(query).toString(); if(URLUtil.isValidUrl (guessedUrl)) { SearchPojo pojo = new SearchPojo(); pojo.query = """"; pojo.relevance = 50; pojo.name = guessedUrl; pojo.url = guessedUrl; pojo.direct = true; pojos.add(pojo); } } return pojos; }",Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,this should be on System.err,@snleee This is handled with the API refreshSegment(),Please don't use sysout. Logging is your friend.,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",just pass sparkJarFilePath.toString less number of changes will be required in the code.,throw exception?,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",columnStatistics,"verify(client != null, ""client cannot be null"");"
public AutoRegisterModules discover() throws InvalidPluginException { sysSingletons = Sets.newHashSet(); sysListen = LinkedListMultimap.create(); if (sshGen != null) { sshGen.setPluginName(pluginName); } if (httpGen != null) { httpGen.setPluginName(pluginName); } scan(); if (!sysSingletons.isEmpty() || !sysListen.isEmpty()) { sysModule = makeSystemModule(); } if (sshGen != null) { sshModule = sshGen.create(); } if (httpGen != null) { httpModule = httpGen.create(); } return this; },The same.,@ekondrashev why not just rsp = opt?,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Replace with logger,consider 'ternary if' here,coudl be just ArrayList since now it is imported ^^ vv,"Here I would just say return true. Then fall through return false, instead of creating a variable.",[minor] could you name it resourceGroupName,ImplUtils has a isNullOrEmpty method that should handle these checks.,do you clean up these files on exit? or the root level dir is deleted on exit ?
"public <K, V> MessageStream<KV<K, V>> partitionBy(Function<? super M, ? extends K> keyExtractor, Function<? super M, ? extends V> valueExtractor, KVSerde<K, V> serde) { int opId = this.graph.getNextOpId(); String opName = String.format(""%s-%s"", OperatorSpec.OpCode.PARTITION_BY.name().toLowerCase(), opId); IntermediateMessageStreamImpl<KV<K, V>> intermediateStream = this.graph.getIntermediateStream(opName, serde); PartitionByOperatorSpec<M, K, V> partitionByOperatorSpec = OperatorSpecs.createRepartitionOperatorSpec( intermediateStream.getOutputStream(), keyExtractor, valueExtractor, opId); this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return intermediateStream; }","The phrase ""repartition"" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data.",Is toString() required? It's already of STRING type.,Suggest JSON related capabilities be isolated to the JsonUtil class.,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.",Do not try to parse the sever list if the command has failed (mStatus.code != 0),Replace with logger,might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,@ekondrashev why not just rsp = opt?,Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.
"public RealmIdentity getRealmIdentity(final Principal principal) throws RealmUnavailableException { boolean ok = false; final RealmIdentity authenticationIdentity = authenticationRealm.getRealmIdentity(principal); Principal authorizationPrincipal = principal; if(principalTransformer != null) { authorizationPrincipal = principalTransformer.apply(authorizationPrincipal); if (authorizationPrincipal == null) return null; } final RealmIdentity[] authorizationIdentities = new RealmIdentity[authorizationRealms.length]; try { for (int i = 0; i < authorizationIdentities.length; i++) { SecurityRealm authorizationRealm = authorizationRealms[i]; authorizationIdentities[i] = authorizationRealm == authenticationRealm && principalTransformer == null ? authenticationIdentity : authorizationRealm.getRealmIdentity(authorizationPrincipal); } final Identity identity = new Identity(authenticationIdentity, authorizationIdentities); ok = true; return identity; } finally { if (!ok) { authenticationIdentity.dispose(); for (RealmIdentity current : authorizationIdentities) { if (current != null) current.dispose(); } } } }",Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",Two ;;,Replace with logger,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Can this be changed to createSubjectRoleAttribute?,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,Do we missing some enums here?,Add invariants,Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,repeating code line.
"protected void doStart() throws Exception { super.doStart(); if (!Files.exists(baseDirectory)) { if (getEndpoint().isAutoCreate()) { baseDirectory = Files.createDirectories(baseDirectory); } else { throw new RuntimeCamelException(""Path must exists when autoCreate = false""); } } if (!Files.isDirectory(baseDirectory)) { throw new RuntimeCamelException(String.format(""Parameter path must be directory, %s given"", baseDirectory.toString())); } DirectoryWatcher.Builder watcherBuilder = DirectoryWatcher.builder() .path(this.baseDirectory) .logger(log) .listener(new FileWatchDirectoryChangeListener()); if (!System.getProperty(""os.name"").toLowerCase().contains(""mac"")) { watcherBuilder.watchService(this.baseDirectory.getFileSystem().newWatchService()); } watcherBuilder.fileHashing(getEndpoint().isUseFileHashing()); if (getEndpoint().getFileHasher() != null && getEndpoint().isUseFileHashing()) { watcherBuilder.fileHasher(getEndpoint().getFileHasher()); } this.watcher = watcherBuilder.build(); watchDirExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, ""CamelFileWatchService"", getEndpoint().getPollThreads()); pollExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, ""CamelFileWatchPoll"", getEndpoint().getConcurrentConsumers()); for (int i = 0; i < getEndpoint().getPollThreads(); i++) { this.watcher.watchAsync(watchDirExecutorService); } for (int i = 0; i < getEndpoint().getConcurrentConsumers(); i++) { pollExecutorService.submit(new PollRunnable()); } }",We tend to use IllegalArgumentException for these kind,Sounds like a workaround for host misconfiguration issue.,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)","You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Why do we handle error like this?,I think this test should be moved to options instead,"verify(client != null, ""client cannot be null"");",power down,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),Unrelated change. Should be in a separate commit.
"public String getDescription() { return Localization.lang( ""Removes all {} brackets around words.""); }","add ""balanced"" ?","-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.","Looks like a duplication to me. How about this.json().getString(""name"")?",this can be reduced to protected.,Why not use capabilities directly here?,as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },Floating semicolon,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Why does this need to be ordered by the synthetic primary key?,"To match the old format, do ""Network parameters:\n "" here."
"public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException { ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile()); if (useSsl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, ""true""); } if (useSasl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, ""true""); } if (getZooKeeperInstance().size() > 0) { List<String> zkOpts = getZooKeeperInstance(); String instanceName = zkOpts.get(0); String hosts = zkOpts.get(1); clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, hosts); clientConfig.setProperty(ClientProperty.INSTANCE_NAME, instanceName); } if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) { AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig)); clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST)); } if (null != zooKeeperHosts) { clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts); } return clientConfig; }",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),I think this test should be moved to options instead,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Why do we handle error like this?,"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Sounds like a workaround for host misconfiguration issue.,"verify(client != null, ""client cannot be null"");",We tend to use IllegalArgumentException for these kind,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",power down
"private void recordLatency(Response<? extends Request> response, String operation) { Serializable start = response.getRequest().getPropertyValue(METRICS_OPERATION_START); long latency = calculateLatency((Long) start); if (latency > 0) { DistributionSummary.builder(metricName(METRIC_PREFIX, operation, ""latency"")) .baseUnit(""milliseconds"") .tags(""successful"", Boolean.toString(response.getProcessingErrors().isEmpty())) .publishPercentiles(0.5, 0.95) .register(Metrics.globalRegistry) .record(latency); } }","If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Please change user back to USER_YODA here.,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",This commandContext seems unused.,"Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,isn't the topology always a LocalizedCacheTopology?,"Good catch, thanks. Fixed <LINK_0>",Let's do the same way @jleandroperez did on iOS here <LINK_0>,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,columnStatistics
"public Object execute(ExecutionEvent event) throws ExecutionException { final Repository repo = getRepository(true, event); IResource[] resources = getSelectedResources(event); if (repo == null) return null; CommitSelectionDialog dlg = new CommitSelectionDialog(getShell(event), repo, resources); if (dlg.open() != Window.OK) return null; if (resources.length == 1 && resources[0] instanceof IFile) { final IFile baseFile = (IFile) resources[0]; final ITypedElement base = SaveableCompareEditorInput .createFileElement(baseFile); final ITypedElement next; ITypedElement ancestor = null; RevCommit commonAncestor = null; try { RepositoryMapping mapping = RepositoryMapping .getMapping(resources[0]); next = getElementForCommit(mapping.getRepository(), mapping .getRepoRelativePath(baseFile), dlg.getCommitId()); commonAncestor = RevUtils.getCommonAncestor(repo, repo.resolve(Constants.HEAD), dlg.getCommitId()); if (commonAncestor != null) ancestor = CompareUtils.getFileRevisionTypedElement( mapping .getRepoRelativePath(baseFile), commonAncestor, mapping.getRepository()); } catch (IOException e) { Activator.handleError( UIText.CompareWithIndexAction_errorOnAddToIndex, e, true); return null; } final GitCompareFileRevisionEditorInput in = new GitCompareFileRevisionEditorInput( base, next, ancestor, null); in.getCompareConfiguration() .setRightLabel(dlg.getCommitId().name()); if (commonAncestor != null) in.getCompareConfiguration() .setAncestorLabel(commonAncestor.name()); CompareUI.openCompareEditor(in); } else { CompareTreeView view; try { view = (CompareTreeView) PlatformUI.getWorkbench() .getActiveWorkbenchWindow().getActivePage().showView( CompareTreeView.ID); view.setInput(resources, dlg.getCommitId().name()); } catch (PartInitException e) { Activator.handleError(e.getMessage(), e, true); } } return null; }",This seems to be unnecessary. I also get the label after removing this.,Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,The output of this call should be checked and if it's false I think it should bail.,merge the try/catch with the one below?,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",we should probably check in the canExecute whether we reached the start of the list,We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,what is a PropertyValueWrapper? Why do you need it?,why var4? Resources.NotFoundException e would be a bit nicer..,@snleee This is handled with the API refreshSegment(),Iffy formatting
"private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( ""org.Address"", new ModelField[]{ new ModelField( ""this"", ""org.Address"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, ""this"" ), new ModelField( ""street"", ""String"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( ""homeAddress"", ""Boolean"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( ""number"", ""java.lang.Integer"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }",@jomarko Thanks.. I'd have made this Integer.class.getName() too,call intValue() and then there is no cast,"Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0",Why use a java.lang.Boolean and not a primitive boolean?,also here please use Short.MAX_VALUE,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"verify(client != null, ""client cannot be null"");",Please don't do unrelated refactor work next time,Should TREEHASH be a HashCode?,Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e),"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed"
"private boolean processRow(String line) { List<String> values = ImmutableList.copyOf(ON_COMMA.split(line)); if (Iterables.size(values) < 8) { return true; } BbcGenreTree.Builder genreTree = BbcGenreTree.builder(genresPrefix + values.get(0)); if (!Strings.isNullOrEmpty(values.get(1))) { genreTree.withSecondLevelGenre(genresPrefix + stripQuotationMarks(values.get(1))); } if (!Strings.isNullOrEmpty(values.get(2))) { genreTree.withThirdLevelGenre(genresPrefix + stripQuotationMarks(values.get(2))); } mapping.put(genreTree.build(), parseYouViewGenres(Iterables.skip(values, 4))); return true; }",Log/throw?,"Maybe using a constant here for ""://""",might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,Suggest JSON related capabilities be isolated to the JsonUtil class.,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",Similar to DistinctCountAggregator,Style nit: unneeded curlies,columnStatistics,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Replace with logger,Can this be changed to createSubjectRoleAttribute?
"public static String doGetFeatureUrl(String srs, JSONObject download, boolean addNameSpace) throws JSONException { String getFeatureUrl = """"; StringWriter s = new StringWriter(); s.append(PropertyUtil.get(""download.basket.wfs.service.url"")); if (addNameSpace) { s.append(""?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName="" + srs + ""&outputFormat=SHAPE-ZIP&typeNames="" + download.getString(PARAM_LAYER)); } else { s.append(""?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName="" + srs + ""&outputFormat=SHAPE-ZIP&typeNames="" + Helpers.getLayerNameWithoutNameSpace(download.getString(PARAM_LAYER))); } getFeatureUrl = s.toString(); return getFeatureUrl; }","StringBuilder instead of StringWriter would be more traditional choice, not that big of a deal though.",Please change user back to USER_YODA here.,Do we missing some enums here?,Suggest JSON related capabilities be isolated to the JsonUtil class.,Replace with logger,Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,edgeCacheDNS as a static variable since it's used a few times?,columnStatistics,this should be on System.err,"You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.",just pass sparkJarFilePath.toString less number of changes will be required in the code.
"public void init() throws DBException { _db.init(); this.reportLatencyForEachError = Boolean.parseBoolean(getProperties(). getProperty(""reportlatencyforeacherror"", ""false"")); String latencyTrackedErrors = getProperties().getProperty( ""latencytrackederrors"", null); if (latencyTrackedErrors != null) { this.latencyTrackedErrors = new HashSet<String>(Arrays.asList( latencyTrackedErrors.split("",""))); } System.out.println(""DBWrapper: report latency for each error is "" + this.reportLatencyForEachError + "" and specific error codes to track"" + "" for latency are: "" + this.latencyTrackedErrors.toString()); }",this should be on System.err,It's better to use **isBlank** here,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",I think this test should be moved to options instead,columnStatistics,log,Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,suggestion this.ignoreAbove = mw.ignoreAbove;,This commandContext seems unused.
"public ProductInfo createProduct(ProductInfo pinfo) { if (pinfo == null) { throw new IllegalArgumentException(""pinfo is null""); } if (StringUtils.isBlank(pinfo.getId())) { throw new IllegalArgumentException(""product is lacking an identifier: "" + pinfo); } if (this.productMap.containsKey(pinfo.getId())) { throw new IllegalStateException(""product already exists: "" + pinfo.getId()); } ProductData pdata = new ProductData(); pdata.setId(pinfo.getId()); pdata.setProductContent(this.resolveProductContent(pinfo.getProductContent())); pdata.setName(pinfo.getName()); pdata.setMultiplier(pinfo.getMultiplier()); pdata.setAttributes(pinfo.getAttributes()); pdata.setDependentProductIds(pinfo.getDependentProductIds()); pdata.setCreated(new Date()); pdata.setUpdated(new Date()); pdata.setBranding(this.resolveBranding(pinfo.getBranding())); pdata.setProvidedProducts(this.resolveProvidedProducts(pinfo.getProvidedProducts())); this.productMap.put(pdata.getId(), pdata); this.productSubscriptionMap.put(pdata.getId(), new HashSet<>()); this.updateProductContentMappings(pdata); return pdata; }","I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),Let's make this InternalServerError,edgeCacheDNS as a static variable since it's used a few times?,"If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?",I think this test should be moved to options instead,ImplUtils has a isNullOrEmpty method that should handle these checks.,Unrelated change. Should be in a separate commit.,columnStatistics,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",log
"public PcapPacket(PcapFile file, @Nullable Packet parent, boolean isPcapNg, ByteBuffer header, @Nullable ByteBuffer payload, long index) throws BadPacketException { super(file, parent, PcapProtocol.PCAP); if (header.array().length < PcapFileValues.PACKET_HEADER_SIZE) { fChildPacket = null; throw new BadPacketException(""The Pcap packet header is too small.""); } fSourceEndpoint = null; fDestinationEndpoint = null; fFields = null; fPacketIndex = index; header.order(getPcapFile().getByteOrder()); header.position(0); if (isPcapNg) { header.getInt(); header.getInt(); header.getInt(); } long timestampMostSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); long timestampLeastSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); switch (getTimestampScale()) { case MICROSECOND: if (timestampLeastSignificant > TIMESTAMP_MICROSECOND_MAX) { fChildPacket = null; throw new BadPacketException(""The timestamp is erroneous.""); } fTimestamp = TIMESTAMP_MICROSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; case NANOSECOND: if (timestampLeastSignificant > TIMESTAMP_NANOSECOND_MAX) { fChildPacket = null; throw new BadPacketException(""The timestamp is erroneous.""); } fTimestamp = TIMESTAMP_NANOSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; default: throw new IllegalArgumentException(""The timestamp precision is not valid!""); } fIncludedLength = ConversionHelper.unsignedIntToLong(header.getInt()); fOriginalLength = ConversionHelper.unsignedIntToLong(header.getInt()); final ByteBuffer pcapPacket = payload; if (pcapPacket == null) { fChildPacket = null; fPayload = null; return; } pcapPacket.order(ByteOrder.BIG_ENDIAN); pcapPacket.position(0); fPayload = pcapPacket; fChildPacket = findChildPacket(); }",read the values and validate,remove this log,is double call to structIsNull.toBooleanArray() intentional?,merge the try/catch with the one below?,The output of this call should be checked and if it's false I think it should bail.,"Let's add a constant for ""version 2""",@snleee This is handled with the API refreshSegment(),"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.",fetch should already happen in Service,Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,Should the condition here and the condition on 153 the same?
"public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); System.out.println(headers.get(name)); return headers.get(name); }",Need to remove this leftover debug output,nit: unnecessary generic type declaration,replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,Why not use capabilities directly here?,Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),any reason for disabling cache for descending order queries ?,this can be reduced to protected.,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Why does this need to be ordered by the synthetic primary key?,this.redisTemplate,"suggestion Objects.requireNonNull(filter, ""filter cannot be null"");"
"public Boolean call() throws Exception { long sleepBackoff = 200L, maxSleep = 0L; do { final PoolEntry poolEntry = createPoolEntry(); if (poolEntry != null) { connectionBag.add(poolEntry); return Boolean.TRUE; } else if (poolEntry == MAXED_POOL_MARKER) { return Boolean.FALSE; } else if (maxSleep == sleepBackoff) { return Boolean.FALSE; } maxSleep = sleepBackoff; quietlySleep(sleepBackoff); sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3)); } while (true); }",How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,Replace with Objects.requireNotNull.,The same.,"We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?","This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()",Replace with logger,static import,why swallowing?,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.",Don't we need to reset alpha here? Drawables share a global state.,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"private void createFeatures(ArcGISMap map){ LayerList layers = map.getOperationalLayers(); for(Layer layer: layers){ FeatureLayer fLayer = (FeatureLayer) layer; if(fLayer.getName().contains(""Alaska National Parks"")){ mOperationalLayers.add(fLayer); } } List<ArcGISFeatureTable> tables = map.getTables(); final ArcGISFeatureTable speciesFeatureTable = tables.get(0); speciesFeatureTable.addDoneLoadingListener(new Runnable() { @Override public void run() { Log.d(TAG, ""Found table: "" + speciesFeatureTable.getTableName()); } }); speciesFeatureTable.loadAsync(); }",No need to explicitly load tables with query if you are using the latest build,Let's do the same way @jleandroperez did on iOS here <LINK_0>,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",Do we missing some enums here?,Add invariants,Iffy formatting,suggestion this.ignoreAbove = mw.ignoreAbove;,Suggest JSON related capabilities be isolated to the JsonUtil class.,not a field,columnStatistics
"public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) { if (clazz == null || json == null) { return; } for (int i = 0; i < json.length(); i++) { try { configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false); } catch (JSONException e) { throw new RealmException(""Could not map Json"", e); } } }","Json -> ""JSON"" (do a search-n-replace)",I think we need to close this InputStream at some point,Suggest JSON related capabilities be isolated to the JsonUtil class.,The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,Do not try to parse the sever list if the command has failed (mStatus.code != 0),why swallowing?,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Is toString() required? It's already of STRING type.,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,I'm pretty sure it ends up being lower cased because the registries do not support capital letters.
"protected ClusterState execute(ClusterState currentState, AlterTableRequest request) throws Exception { Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.tableIdent().indexNameOrAlias()); if (request.isPartitioned()) { if (request.partitionIndexName() != null) { concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.partitionIndexName()); currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } else { currentState = updateTemplate(currentState, request); if (!request.excludePartitions()) { List<String> supportedSettings = TableParameters.PARTITIONED_TABLE_PARAMETER_INFO_FOR_TEMPLATE_UPDATE .supportedSettings() .values() .stream() .map(Setting::getKey) .collect(Collectors.toList()); supportedSettings.add(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS); TableParameter parameterWithFilteredSettings = new TableParameter(request.settings(), supportedSettings); currentState = updateSettings(currentState, parameterWithFilteredSettings.settings(), concreteIndices); currentState = updateMapping(currentState, request, concreteIndices); } } } else { currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } return currentState; }",Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",Please remove debug codes.,Why use a java.lang.Boolean and not a primitive boolean?,"verify(client != null, ""client cannot be null"");",power down,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",suggestion deletedAlarmIds.forEach(alarmId -> {,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),@snleee This is handled with the API refreshSegment(),Should the condition here and the condition on 153 the same?
"public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject fDiffProject : fDiffProjects) { IProject tempProject = Utilities.getProject(fDiffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }",not a field,Do we missing some enums here?,No need to explicitly load tables with query if you are using the latest build,Could you please rename also _result?,suggestion this.ignoreAbove = mw.ignoreAbove;,Similar to DistinctCountAggregator,[minor] could you name it resourceGroupName,The Exception is never thrown.,columnStatistics,Suggest JSON related capabilities be isolated to the JsonUtil class.,consider 'ternary if' here
"public static void fillReleasesTable(XWPFTable table, Collection<LicenseInfoParsingResult> projectLicenseInfoResults) { for (LicenseInfoParsingResult result : projectLicenseInfoResults) { String releaseName = nullToEmptyString(result.getName()); String version = nullToEmptyString(result.getVersion()); if (result.getStatus()== LicenseInfoRequestStatus.SUCCESS) { Set<String> copyrights = Collections.emptySet(); Set<LicenseNameWithText> licenseNamesWithTexts = Collections.emptySet(); Set<String> acknowledgements = Collections.emptySet(); if (result.isSetLicenseInfo()) { LicenseInfo licenseInfo = result.getLicenseInfo(); if (licenseInfo.isSetCopyrights()) { copyrights = licenseInfo.getCopyrights(); } if (licenseInfo.isSetLicenseNamesWithTexts()) { licenseNamesWithTexts = licenseInfo.getLicenseNamesWithTexts(); acknowledgements = licenseNamesWithTexts.stream() .map(LicenseNameWithText::getAcknowledgements) .filter(Objects::nonNull).collect(Collectors.toSet()); } } addReleaseTableRow(table, releaseName, version, licenseNamesWithTexts, acknowledgements, copyrights); } else { String filename = Optional.ofNullable(result.getLicenseInfo()) .map(LicenseInfo::getFilenames) .map(l -> l.stream().findFirst().orElse(null)) .orElse(""""); addReleaseTableErrorRow(table, releaseName, version, nullToEmptyString(result.getMessage()), filename); } } }",the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,@snleee This is handled with the API refreshSegment(),throw exception?,suggestion deletedAlarmIds.forEach(alarmId -> {,Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,columnStatistics,"verify(client != null, ""client cannot be null"");",Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,is double call to structIsNull.toBooleanArray() intentional?,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","Let's add a constant for ""version 2"""
"public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { throw new IllegalArgumentException( ""startTimeNanos should be greater than 0!"" ); } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = ""SlowQuery: "" + queryExecutionMillis + "" milliseconds. SQL: '"" + sql + ""'""; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }","I would suggest providing more clue about the exception like  throw new IllegalArgumentException( ""startTimeNanos ["" + startTimeNanos + ""] should be greater than 0!"" );  to help debugger a little bit.",static import,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still",Replace with logger,do you clean up these files on exit? or the root level dir is deleted on exit ?,This commandContext seems unused.,this should be on System.err,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Style nit: unneeded curlies,"If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",ImplUtils has a isNullOrEmpty method that should handle these checks.
"public void bucketLoaded(AbstractBucket<Object> bucket) { try { super.bucketLoaded(bucket); logger.debug(""Bucket {} loaded"", bucket.bucketKey); eventBucketExchanger.exchange(bucket.bucketKey, 1, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { logger.debug(""Timeout happened""); } catch (InterruptedException e) { e.printStackTrace(); } }",why swallowing?,It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",Probably just wants to be start or startPhase or something if now generic.,"Json -> ""JSON"" (do a search-n-replace)",How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,Wrapper#getX() : float Use float instead of double.,Put the test in the same package (not directory) and you can at least use package private or protected,I think it would be good to perform this logic in OutputEmitter.,"If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }"
public ControllerFactory() { },Why public?,"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.","-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.,"add ""balanced"" ?",curly braces aren't required,"To match the old format, do ""Network parameters:\n "" here.","you should check the cache doesn't exist, plus that no suggestion to use the cache is logged",Floating semicolon,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"public void inputReady(NHttpServerConnection conn, ContentDecoder decoder) { try { ProtocolState protocolState = SourceContext.getState(conn); if (protocolState != ProtocolState.REQUEST_HEAD && protocolState != ProtocolState.REQUEST_BODY) { handleInvalidState(conn, ""Request message body data received""); return; } log.info(""point 1""); SourceContext.updateState(conn, ProtocolState.REQUEST_BODY); SourceRequest request = SourceContext.getRequest(conn); int readBytes = request.read(conn, decoder); if (isMessageSizeValidationEnabled) { HttpContext httpContext = conn.getContext(); if (httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM) == null) { httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, 0); } int messageSizeSum = (int) httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM); messageSizeSum += readBytes; if (messageSizeSum > validMaxMessageSize) { log.warn(""Payload exceeds valid payload size range, hence discontinuing chunk stream at "" + messageSizeSum + "" bytes to prevent OOM.""); dropSourceConnection(conn); conn.getContext().setAttribute(PassThroughConstants.SOURCE_CONNECTION_DROPPED, true); request.getPipe().forceProducerComplete(decoder); } httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, messageSizeSum); } if (readBytes > 0) { metrics.incrementBytesReceived(readBytes); } } catch (IOException e) { logIOException(conn, e); informReaderError(conn); SourceContext.updateState(conn, ProtocolState.CLOSED); sourceConfiguration.getSourceConnections().shutDownConnection(conn, true); } }",remove this log,read the values and validate,I think this test should be moved to options instead,These should be done through a sink.,Should TREEHASH be a HashCode?,This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,fetch should already happen in Service,"Let's add a constant for ""version 2""",Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,@snleee This is handled with the API refreshSegment(),The output of this call should be checked and if it's false I think it should bail.
"private ColumnChunk readStruct(GroupField field) throws IOException { List<TypeSignatureParameter> fields = field.getType().getTypeSignature().getParameters(); Block[] blocks = new Block[fields.size()]; ColumnChunk columnChunk = null; List<Optional<Field>> parameters = field.getChildren(); for (int i = 0; i < fields.size(); i++) { Optional<Field> parameter = parameters.get(i); if (parameter.isPresent()) { columnChunk = readColumnChunk(parameter.get()); blocks[i] = columnChunk.getBlock(); } } for (int i = 0; i < fields.size(); i++) { if (blocks[i] == null) { blocks[i] = RunLengthEncodedBlock.create(field.getType(), null, columnChunk.getBlock().getPositionCount()); } } BooleanList structIsNull = ParquetStructColumnReader.calculateStructOffsets(field, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); Block rowBlock = RowBlock.fromFieldBlocks(structIsNull.toBooleanArray(), blocks, structIsNull.toBooleanArray().length); return new ColumnChunk(rowBlock, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); }",is double call to structIsNull.toBooleanArray() intentional?,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)",@ikhvostenkov please name it json,"Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...",@snleee This is handled with the API refreshSegment(),the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,"Let's add a constant for ""version 2""","Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.","verify(client != null, ""client cannot be null"");",columnStatistics,read the values and validate
"private void regenerateCertificatesImpl(Iterable<Entitlement> entitlements) { if (entitlements != null) { Set<String> deadCertIds = new HashSet<>(); for (Entitlement entitlement : entitlements) { Set<EntitlementCertificate> existing = entitlement.getCertificates(); try { entitlement.setCertificates(null); EntitlementCertificate generated = this.generateEntitlementCertificate( entitlement.getPool(), entitlement); entitlement.setDirty(false); this.eventSink.queueEvent(this.eventFactory.entitlementChanged(entitlement)); log.debug(""Generated entitlementCertificate: #{}"", generated.getId()); if (existing != null) { for (EntitlementCertificate cert : existing) { if (cert != null) { deadCertIds.add(cert.getId()); this.entitlementCertificateCurator.evict(cert); } } } } catch (CertificateSizeException cse) { entitlement.setCertificates(existing); log.warn(""The certificate cannot be regenerated at this time: {}"", cse.getMessage()); } } this.entitlementCurator.saveOrUpdateAll(entitlements, false, false); int count = this.entitlementCertificateCurator.deleteByIds(deadCertIds); log.debug(""{} old entitlement certificates deleted""); } }","suggestion log.debug(""{} old entitlement certificates deleted"", count);",suggestion deletedAlarmIds.forEach(alarmId -> {,I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",@snleee This is handled with the API refreshSegment(),Make sure to unescape the url path before using it. I've hit this in actual usage.,What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",why var4? Resources.NotFoundException e would be a bit nicer..,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Unrelated change. Should be in a separate commit.
public boolean delete(final Identifier queryId) { if(queryStateMap.containsKey(queryId)) { queryStateMap.remove(queryId); return true; } else { return false; } },replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,Check for illegal arg or are we happy with a ClassCastException here?,Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,This should be in the if(v != null) check I am thinking,any reason for disabling cache for descending order queries ?,"nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());","probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",this can be reduced to protected.,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),It would have been shorter to inline this variable and not have it in scope. :-)
"public boolean onOptionsItemSelected(MenuItem item) { Intent intent = null; switch (item.getItemId()) { case R.id.menu_load: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, ""No connection found, please connect your device and try again"", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, ""Already fetching forms, ignored the request"", Toast.LENGTH_SHORT).show(); return true; } if (hasFormsWithData()) { Toast.makeText(this, ""There is existing form data for selected form(s). Finish Incomplete data and sync Complete data to Server first before downloading selected forms"", Toast.LENGTH_SHORT).show(); return true; } syncAllFormsInBackgroundService(); return true; case R.id.menu_upload: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, ""No connection found, please connect your device and try again"", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, ""Already uploading forms, ignored the request"", Toast.LENGTH_SHORT).show(); return true; } uploadAllFormsInBackgroundService(); return true; case R.id.menu_client_add: intent = new Intent(this, RegistrationFormsActivity.class); startActivity(intent); return true; case R.id.menu_tags: if (mainLayout.isDrawerOpen(GravityCompat.END)) { mainLayout.closeDrawer(GravityCompat.END); } else { mainLayout.openDrawer(GravityCompat.END); } return true; default: return super.onOptionsItemSelected(item); } }",Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,fetch should already happen in Service,"Good catch, thanks. Fixed <LINK_0>",Let's do the same way @jleandroperez did on iOS here <LINK_0>,This seems to be unnecessary. I also get the label after removing this.,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,I don't see sense from this if (MobileContextHelper.isInWebViewContext()),Two ;;,Please change user back to USER_YODA here.,remove this log
"public void handle(XFormParser p, Element e, Object parent) { String event = e.getAttributeValue(null, ""event""); FormDef form = (FormDef) parent; PollSensorAction action; String ref = e.getAttributeValue(null, ""ref""); if (ref != null) { IDataReference dataRef = new XPathReference(ref); if (dataRef != null) { dataRef = XFormParser.getAbsRef(dataRef, TreeReference.rootRef()); } TreeReference treeRef = FormInstance.unpackReference(dataRef); p.registerActionTarget(treeRef); action = new PollSensorAction(treeRef); } else { action = new PollSensorAction(); } form.registerEventListener(event, action); }",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,repeating code line.,"Please make sure this is properly formatted. ""else"" should be on the same line as the }.","CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.","That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?",Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,Is toString() required? It's already of STRING type.,Suggest JSON related capabilities be isolated to the JsonUtil class.,":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge."
"public void setQuotaMode(QuotaMode mode) { logger.info(""Setting Quota mode to "" + mode.name()); this.mode = mode; }","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Check for illegal arg or are we happy with a ClassCastException here?,magic number,Remove cast,this can be reduced to protected.,"Is a null check for the passed in ""date"" required here for safety?","probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.",Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),It would have been shorter to inline this variable and not have it in scope. :-)
"private static boolean isPreJava8() { final String version = System.getProperty(""java.version""); final String[] parts = version.split(""\\.""); try { int major = Integer.parseInt(parts[1]); final int token = Integer.parseInt(parts[0]); boolean isJEP223 = token != 1; if (isJEP223) { major = token; } return major < 8; } catch (final Exception ex) { return true; } }","Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",Extra space,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,you can use parameterized logging here,Replace with logger,"You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",UtilKtKt isn't a great name.,Missing Unstable attribute.
"public PagingProvider<ReconnectableConnection, ReconnectableConnection> pagedOperation(Integer failOn) { return new PagingProvider<ReconnectableConnection, ReconnectableConnection>() { Integer counter = 0; @Override public List<ReconnectableConnection> getPage(ReconnectableConnection connection) { counter++; if (counter == failOn) { throw new ModuleException(MuleErrors.CONNECTIVITY, new ConnectionException(""Failed to retrieve Page"")); } return Collections.singletonList(connection); } @Override public Optional<Integer> getTotalResults(ReconnectableConnection connection) { return Optional.empty(); } @Override public void close(ReconnectableConnection connection) { } }; }",static import,Let's do the same way @jleandroperez did on iOS here <LINK_0>,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,check to make sure notificationUUID is not null,Replace with logger,@ekondrashev why not just rsp = opt?,isn't the topology always a LocalizedCacheTopology?,what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,Two ;;,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still"
"public boolean writeMutexCell(String tenantId, String schemaName, String tableName, String columnName, String familyName) throws SQLException { try { byte[] rowKey = columnName != null ? SchemaUtil.getColumnKey(tenantId, schemaName, tableName, columnName, familyName) : SchemaUtil.getTableKey(tenantId, schemaName, tableName); byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); try (Table sysMutexTable = getTable(sysMutexPhysicalTableNameBytes)) { byte[] family = PhoenixDatabaseMetaData.SYSTEM_MUTEX_FAMILY_NAME_BYTES; byte[] qualifier = PhoenixDatabaseMetaData.SYSTEM_MUTEX_COLUMN_NAME_BYTES; byte[] value = MUTEX_LOCKED; Put put = new Put(rowKey); put.addColumn(family, qualifier, value); boolean checkAndPut = sysMutexTable.checkAndPut(rowKey, family, qualifier, null, put); String processName = ManagementFactory.getRuntimeMXBean().getName(); String msg = "" tenantId : "" + tenantId + "" schemaName : "" + schemaName + "" tableName : "" + tableName + "" columnName : "" + columnName + "" familyName : "" + familyName; if (!checkAndPut) { LOGGER.error(processName + "" failed to acquire mutex for ""+ msg); } else { LOGGER.debug(processName + "" acquired mutex for ""+ msg); } return checkAndPut; } } catch (IOException e) { throw ServerUtil.parseServerException(e); } }","byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that.",consider using a switch(res) {...},"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail(),"What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Please don't use sysout. Logging is your friend.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,"verify(client != null, ""client cannot be null"");",columnStatistics,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Let's make this InternalServerError
"public ReadableByteChannel get(PageId pageId, int pageOffset) throws IOException, PageNotFoundException { Path p = getFilePath(pageId); if (!Files.exists(p)) { throw new PageNotFoundException(p.toString()); } FileInputStream fis = new FileInputStream(p.toFile()); fis.skip(pageOffset); return fis.getChannel(); }","[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE",I think we need to close this InputStream at some point,why swallowing?,check to make sure notificationUUID is not null,static import,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,Put the test in the same package (not directory) and you can at least use package private or protected,ImplUtils has a isNullOrEmpty method that should handle these checks.,"Maybe using a constant here for ""://""","Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",do you clean up these files on exit? or the root level dir is deleted on exit ?
"String extractMetadataFromSlots(List<oasis.names.tc.ebxml_regrep.xsd.rim._3.SlotType1> documentSlots, String slotName, int valueIndex) { LOG.debug(""extractMetadataFromSlots slotname: {}; index: {}"", slotName, valueIndex); String slotValue = null; for (SlotType1 slot : documentSlots) { if (slotName.equals(slot.getName())) { LOG.debug(""Found {}: {}"", slotName, slot.getValueList().getValue()); if (valueIndex < 0) { slotValue = StringUtils.join(slot.getValueList().getValue(), VALUE_LIST_SEPERATOR); } else if (slot.getValueList() != null && slot.getValueList().getValue() != null && !slot.getValueList().getValue().isEmpty()) { slotValue = slot.getValueList().getValue().get(valueIndex); } else { slotValue = """"; } break; } } LOG.debug(""{}: {}"", slotName, slotValue); return slotValue; }",This statement slot.getValueList().getValue()) could cause an NPE,"suggestion log.debug(""{} old entitlement certificates deleted"", count);",Do we missing some enums here?,"indentation, here and rest of PR","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.",Add invariants,"please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",log,columnStatistics,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).
"public PartitionStatistics getTableStatistics(String databaseName, String tableName) { try { Table table = getTable(databaseName, tableName).orElseThrow( () -> new PrestoException(HIVE_METASTORE_ERROR, String.format(""Could not retrieve table %s.%s"", databaseName, tableName))); HiveBasicStatistics basicStats = getHiveBasicStatistics(table.getParameters()); List<Column> columns = table.getPartitionColumns(); List<String> columnNames = columns.stream().map(Column::getName).collect(toImmutableList()); List<ColumnStatisticsInfo> colStatsList = client.getTableColumnStatistics(table.getDatabaseName(), table.getTableName(), columnNames); return new PartitionStatistics(basicStats, groupStatisticsByColumn(colStatsList, basicStats.getRowCount())); } catch (Exception e) { throw new PrestoException(HIVE_METASTORE_ERROR, e); } }",columnStatistics,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Please change user back to USER_YODA here.,"I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",this should be on System.err,suggestion this.ignoreAbove = mw.ignoreAbove;,log,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,consider using a switch(res) {...},@snleee This is handled with the API refreshSegment(),"verify(client != null, ""client cannot be null"");"
"private void lazyLoadModulesConfig() throws IOException, ConfigInvalidException { if (modulesConfig == null) { loadModulesConfig(); } }",curly braces aren't required,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),It would have been shorter to inline this variable and not have it in scope. :-),Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,"To match the old format, do ""Network parameters:\n "" here.","This bloc of code is repeated many times, should be centralized in a single method.",this can be reduced to protected.,Floating semicolon,Why not use capabilities directly here?,"Looks like a duplication to me. How about this.json().getString(""name"")?",A future refactor might place this method in the enum directly.
"public void run() { try { if (!makeResourceWritable(provider.getShell())) { return; } } catch (CoreException e) { MessageDialog.openWarning(provider.getShell(), ""Resource Not Accessible"", e.getMessage()); return; } if (LaunchUtils.hasLaunchedTestCases()) { MessageDialog.openWarning(provider.getShell(), Messages.RenameAction_ErrorDialogTitle, Messages.RenameAction_ErrorDialogMsg); return; } if (!RefactoringSaveHelper.checkDirtyEditors(provider.getShell())) { return; } if (containsSingleTag(getStructuredSelection())) { RenameTagWizard wizard = new RenameTagWizard(getSelectedTag()); run(wizard, provider.getShell()); } else { List<?> resources = getSelectedResources(); if (resources.size() == 1) { IResource resource = (IResource) resources.get(0); Q7RenameResourceWizard wizard = new Q7RenameResourceWizard( resource); run(wizard, provider.getShell()); } } }",Why do we handle error like this?,Sounds like a workaround for host misconfiguration issue.,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()),Remove /Dev Team,"You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),The output of this call should be checked and if it's false I think it should bail.,power down,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)",We tend to use IllegalArgumentException for these kind
"private void setValue(Type type, BlockBuilder blockBuilder, String value) { if (value == null) { blockBuilder.appendNull(); return; } if (!(type instanceof FixedWidthType) && !(type instanceof VarcharType)) { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), ""type '"" + type + ""' not supported""); } if (type instanceof FixedWidthType) { completedBytes += ((FixedWidthType) type).getFixedSize(); if (type instanceof BigintType) { type.writeLong(blockBuilder, parseDouble(value).longValue()); } else if (type instanceof IntegerType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else if (type instanceof TinyintType) { blockBuilder.writeByte(parseDouble(value).byteValue()); } else if (type instanceof SmallintType) { blockBuilder.writeShort(parseDouble(value).shortValue()); } else if (type instanceof BooleanType) { type.writeBoolean(blockBuilder, parseBoolean(value)); } else if (type instanceof DecimalType || type instanceof DoubleType) { type.writeDouble(blockBuilder, parseDouble(value)); } else if (type instanceof TimestampType) { type.writeLong(blockBuilder, parseLong(value)); } else if (type instanceof DateType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), ""type '"" + type + ""' not supported""); } } else { Slice slice = Slices.utf8Slice(value); blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry(); completedBytes += slice.length(); } }",Why parseDouble and then convert that to int instead of directly parsing to int ?,Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),what does this do if key is null?,"verify(client != null, ""client cannot be null"");",is double call to structIsNull.toBooleanArray() intentional?,"Let's add a constant for ""version 2""",columnStatistics,read the values and validate,I think this test should be moved to options instead,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Unrelated change. Should be in a separate commit.
"private void initialize() { this.setName(Constant.messages.getString(""proxies.options.title"")); this.add(getScrollPane()); this.setLayout(new GridBagLayout()); this.add(getMainProxyPanel(), LayoutHelper.getGBC(0, 0, 1, 0.0)); this.add(getSecurityProtocolsPanel(), LayoutHelper.getGBC(0, 1, 1, 0.0)); this.add(getScrollPane(), LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0)); }",This can be removed? (Being added later.),It's better to use **isBlank** here,Style nit: unneeded curlies,consider 'ternary if' here,ImplUtils has a isNullOrEmpty method that should handle these checks.,Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,why swallowing?,Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,coudl be just ArrayList since now it is imported ^^ vv,Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,check to make sure notificationUUID is not null
"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } ImageTransfer other = (ImageTransfer) obj; return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && type == other.type && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal); }","please move it to line 168, just to make it look cleaner :)","Please make sure this is properly formatted. ""else"" should be on the same line as the }.",@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,Wrapper#getX() : float Use float instead of double.,"I don't think ""resolveMember"" should create a new symbol. We should find another approach","You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,",Missing Unstable attribute.,"We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.","Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?",Don't we need to reset alpha here? Drawables share a global state.
"private static void printNetworkParameters(NetworkParams networkParams) { oshi.add(""Network parameters:"" + networkParams.toString()); }","To match the old format, do ""Network parameters:\n "" here.",Floating semicolon,"you should check the cache doesn't exist, plus that no suggestion to use the cache is logged",this can be reduced to protected.,Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),"This bloc of code is repeated many times, should be centralized in a single method.",Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,A future refactor might place this method in the enum directly.,Why not use capabilities directly here?,"add ""balanced"" ?"
"public static OzoneAcl convertOzoneAcl(OzoneAclInfo aclInfo) { ACLIdentityType aclType; switch(aclInfo.getType()) { case USER: aclType = ACLIdentityType.USER; break; case GROUP: aclType = ACLIdentityType.GROUP; break; case WORLD: aclType = ACLIdentityType.WORLD; break; default: throw new IllegalArgumentException(""ACL type is not recognized""); } List<IAccessAuthorizer.ACLType> aclRights = new ArrayList<>(); for(OzoneAclRights acl:aclInfo.getRightsList()) { try { aclRights.add(ACLType.valueOf(acl.name())); } catch(IllegalArgumentException iae) { LOG.error(""ACL:{} right is not recognized."", acl); } } return new OzoneAcl(aclType, aclInfo.getName(), aclRights); }",Do we missing some enums here?,Suggest JSON related capabilities be isolated to the JsonUtil class.,not a field,"Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",edgeCacheDNS as a static variable since it's used a few times?,No need to explicitly load tables with query if you are using the latest build,Can this be changed to createSubjectRoleAttribute?,Replace with logger,columnStatistics,Add invariants,log
"public void shouldSubstituteHexValuesInReplacementString() { String replacement = ""abc\\x01\\xaadef""; ReplacerParamRule nonAsciiRegexRule = new ReplacerParamRule( """", REQ_HEADER_STR, ""anyMatchString"", true, replacement, null, true); assertThat( nonAsciiRegexRule.getEscapedReplacement(), equalTo(new String(new byte[] {'a', 'b', 'c', 1, (byte) 170, 'd', 'e', 'f'}))); }",These could be renamed to not use nonAscii.,@ikhvostenkov please name it json,@Serranya The same here. See above.,"This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",Similar to DistinctCountAggregator,The Exception is never thrown.,Could you please rename also _result?,this should be on System.err,I wonder if this change would result array allocation and extra cpu/memory consumption issues,"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test."
"protected Object transform( Message in, String mimeType, String transformerId, MimeTypeToTransformerMapper mapper) throws MimeTypeParseException, CatalogTransformerException { MimeType derivedMimeType = null; try (InputStream message = in.getBody(InputStream.class); TemporaryFileBackedOutputStream tfbos = new TemporaryFileBackedOutputStream()) { if (message == null) { throw new CatalogTransformerException( ""Message body was null; unable to generate Metacard!""); } IOUtils.copy(message, tfbos); String fileExtensionHeader = getHeaderAsStringAndRemove(in, FILE_EXTENSION_HEADER); if (StringUtils.isNotEmpty(fileExtensionHeader)) { Optional<String> fileMimeType = getMimeTypeFor(tfbos.asByteSource().openBufferedStream(), fileExtensionHeader); if (fileMimeType.isPresent()) { LOGGER.trace( ""Setting mimetype to [{}] from Message header [{}]"", fileMimeType.get(), FILE_EXTENSION_HEADER); derivedMimeType = new MimeType(fileMimeType.get()); } } if (derivedMimeType == null) { if (StringUtils.isNotEmpty(mimeType)) { if (StringUtils.isNotEmpty(transformerId)) { derivedMimeType = new MimeType( mimeType + "";"" + MimeTypeToTransformerMapper.ID_KEY + ""="" + transformerId); LOGGER.trace(""Using mimeType to [{}]"", derivedMimeType); } else { LOGGER.trace(""Using CatalogEndpoint's configured mimeType [{}]"", mimeType); derivedMimeType = new MimeType(mimeType); } } else { LOGGER.debug(""Unable to determine mimeType. Defaulting to [{}]"", DEFAULT_MIME_TYPE); derivedMimeType = new MimeType(DEFAULT_MIME_TYPE); } } String metacardUpdateID = getHeaderAsStringAndRemove(in, METACARD_ID_HEADER); return generateMetacard(derivedMimeType, mapper, tfbos, metacardUpdateID) .orElseThrow( () -> new CatalogTransformerException( String.format( ""Did not find an InputTransformer for MIME Type [%s] and %s [%s]"", mimeType, MimeTypeToTransformerMapper.ID_KEY, transformerId))); } catch (IOException e) { LOGGER.debug(""Failed to get mimeType by reading input stream"", e); } throw new CatalogTransformerException(""Unable to transform incoming product""); }",The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again.,just pass sparkJarFilePath.toString less number of changes will be required in the code.,@ikhvostenkov please name it json,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"Let's add a constant for ""version 2""",fetch should already happen in Service,remove this log,"verify(client != null, ""client cannot be null"");",The output of this call should be checked and if it's false I think it should bail.,Make sure to unescape the url path before using it. I've hit this in actual usage.,"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task."
"public Map<String, Discrepancy> getDiscrepanciesList() { Map<String, Discrepancy> toReturn = new HashMap<String, Discrepancy>(); String discrepanciesJson = artifact.getSoleAttributeAsString(DispoConstants.DispoDiscrepanciesJson, ""{}""); try { JsonNode node = JsonUtil.getMapper().readTree(discrepanciesJson); Iterator<JsonNode> elements = node.getElements(); while (elements.hasNext()) { Discrepancy discrepancy = JsonUtil.getMapper().readValue(elements.next().toString(), Discrepancy.class); toReturn.put(discrepancy.getId(), discrepancy); } } catch (Exception ex) { throw new OseeCoreException(""Could not parse Discrepancies Json"", ex); } return toReturn; }",Suggest JSON related capabilities be isolated to the JsonUtil class.,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,Replace with logger,Can this be changed to createSubjectRoleAttribute?,Do we missing some enums here?,The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,"I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,not a field
"public void setup() throws IOException, InterruptedException { m_eventdIpcMgr.setEventWriter(m_database); OnmsMonitoringLocation location = new OnmsMonitoringLocation(); location.setLocationName(""Default""); m_locationDao.save(location); final OnmsNode node = new OnmsNode(location, ""node1""); node.setId(NODE_ID_ONE); m_nodeDao.save(node); Hashtable<String, Object> producerConfig = new Hashtable<String, Object>(); producerConfig.put(""group.id"", ""OpenNMS""); producerConfig.put(""bootstrap.servers"", kafkaServer.getKafkaConnectString()); ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class, RETURNS_DEEP_STUBS); when(configAdmin.getConfiguration(KAFKA_PRODUCER_CLIENT_PID).getProperties()).thenReturn(producerConfig); ExecutorService executor = Executors.newSingleThreadExecutor(); kafkaConsumer = new KafkaMessageConsumerRunner(kafkaServer.getKafkaConnectString()); executor.execute(kafkaConsumer); kafkaProducer = new OpennmsKafkaProducer(protobufMapper, nodeCache, configAdmin, m_eventdIpcMgr, alarmLifecycleListenerManager); kafkaProducer.setEventTopic(""events""); kafkaProducer.setEventFilter(""getUei().equals(\""uei.opennms.org/internal/discovery/newSuspect\"")""); kafkaProducer.setNodeTopic(""nodes""); kafkaProducer.init(); Thread.sleep(2000); }","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Please don't use sysout. Logging is your friend.,Sounds like a workaround for host misconfiguration issue.,I think this test should be moved to options instead,"How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,"verify(client != null, ""client cannot be null"");",just pass sparkJarFilePath.toString less number of changes will be required in the code.,"I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),The output of this call should be checked and if it's false I think it should bail.
"public long updateHash( HashFunction hashFunction, long hash ) { class CodePointCursor { byte[] values; int i; @SuppressWarnings( ""WeakerAccess"" ) int codePointCount; @SuppressWarnings( ""WeakerAccess"" ) long next() { codePointCount++; byte b = values[i]; if ( b >= 0 ) { i++; return b; } int bytesNeeded = 0; while ( b < 0 ) { bytesNeeded++; b = (byte) (b << 1); } int codePoint = codePoint( values, b, i, bytesNeeded ); i += bytesNeeded; return codePoint; } } CodePointCursor cpc = new CodePointCursor(); cpc.values = bytes; cpc.i = offset; int len = offset + byteLength; while ( cpc.i < len ) { long codePointA = cpc.next() << 32; long codePointB = 0L; if ( cpc.i < len ) { codePointB = cpc.next(); } hash = hashFunction.update( hash, codePointA + codePointB ); } return hashFunction.update( hash, cpc.codePointCount ); }","The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?","Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...",is double call to structIsNull.toBooleanArray() intentional?,"This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name ""verify"" which makes it clear that the intent of the method is to do some state checks...",merge the try/catch with the one below?,Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,rename 'variableName',read the values and validate,why var4? Resources.NotFoundException e would be a bit nicer..,We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,"Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class."
"public void triggerCompleted() { getProcessInstance().removeEventListener(getEventType(), getEventListener(), true); ((org.jbpm.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).setCurrentLevel(getLevel()); ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()).removeNodeInstance(this); NodeInstanceContainer container = ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()); NodeInstance instance = container.getNodeInstance(getNode()); triggerNodeInstance((org.jbpm.workflow.instance.NodeInstance) instance, NodeImpl.CONNECTION_DEFAULT_TYPE); }",what's the reason for this extra variable container?,Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,May be static imports for TimeUnit values here and below?,The Exception is never thrown.,this should be on System.err,Iffy formatting,This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,It's better to use **isBlank** here,Could you please rename also _result?
"void mapActionItemsToSelection(ISelection selection) { setMoveItemsEnabled(false); if (selection == null || selection.isEmpty()) return; if (selection instanceof IStructuredSelection) { IStructuredSelection structured = (IStructuredSelection) selection; Object obj = structured.getFirstElement(); if (!(obj instanceof PlanElement)) return; PlanElement firstSelectedEntry = (PlanElement) obj; PlanElement lastSelectedEntry = firstSelectedEntry; ElementAction type = firstSelectedEntry.getPlanElementAction(); unselectAllActionItemsExecpt(getItemFor(type)); if (structured.size() > 1) { for (Iterator iterator = structured.iterator(); iterator .hasNext();) { Object selectedObj = iterator.next(); if (!(selectedObj instanceof PlanElement)) continue; PlanElement entry = lastSelectedEntry = (PlanElement) selectedObj; if (type != entry.getPlanElementAction()) { unselectAllActionItemsExecpt(null); } } } enableMoveButtons(firstSelectedEntry, lastSelectedEntry); } }",We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,merge the try/catch with the one below?,This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()),Why do we handle error like this?,"Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.",we should probably check in the canExecute whether we reached the start of the list,This seems to be unnecessary. I also get the label after removing this.,@snleee This is handled with the API refreshSegment(),why var4? Resources.NotFoundException e would be a bit nicer..,is double call to structIsNull.toBooleanArray() intentional?,rename 'variableName'
"public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(""P60000000000000D""); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); assertThat(e.getMessage(), is(""Error during type conversion from type: java.time.Duration to the required type: "" + ""long with value PT1440000000000000H due java.lang.ArithmeticException: long overflow"")); } }","I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",@ikhvostenkov please name it json,@Serranya The same here. See above.,I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,assertEquals and remove the expected value from message string,nit: any chance to make the message assertion more specific? :),"Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",I assume this was meant to be removed?,this should be on System.err,I wonder if this change would result array allocation and extra cpu/memory consumption issues
"private void publishChildren(IModule[] module, ArrayList<IStatus> results, IModule[] children, File parentModule, IProgressMonitor monitor) { if( children == null ) return; monitor.beginTask(""Assembling child modules"", children.length * 100); for( int i = 0; i < children.length; i++ ) { if( ServerModelUtilities.isBinaryModule(children[i])) results.addAll(Arrays.asList(fullBinaryPublish(module, children[i], ProgressMonitorUtil.submon(monitor, 100)))); else results.addAll(Arrays.asList(fullPublish(combine(module, children[i]), parentModule, ProgressMonitorUtil.submon(monitor, 100)))); } }",check if monitor is cancelled?,call intValue() and then there is no cast,Iffy formatting,@snleee This is handled with the API refreshSegment(),Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,Shouldn't it be No handler was subscribed **for** command?,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",This seems to be unnecessary. I also get the label after removing this.,Please remove debug codes.,These should be done through a sink.
public boolean isReady() { return false; },@Irenyak1 why return false here?,"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.",should be possible to provide one,"-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },"don't return NULL, throw UnsupportedOperatedException instead","probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",Check for illegal arg or are we happy with a ClassCastException here?,Remove cast,hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
"private void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) { synchronized (lock) { final long id = idGenerator.getAndIncrement(); final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter); final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work); EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get(); workProcessor.onNext(syncSubscriber); Disposable thisWorkSubscriber = workSubscriber.get(); if (thisWorkSubscriber != null) { logger.info(""[{}]: Receive request is placed in queue to process."", id); return; } EmitterProcessor<ServiceBusReceivedMessageContext> source = messageSource.get(); if (source == null) { source = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS) .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false)); messageSource.set(source); logger.info(""Created source for receiving messages.""); } EmitterProcessor<ServiceBusReceivedMessageContext> finalSource = source; thisWorkSubscriber = workProcessor .subscribe(currentWork -> finalSource.subscribe(currentWork), error -> { logger.error(""Error in processing messages [{}]"", error); }, () -> { logger.info(""Receiving messages completed.""); }); workSubscriber.set(thisWorkSubscriber); } }",These should be done through a sink.,this may impact web-ui code. Do we want to expose Snapshot in API?,"See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.",remove this log,suggestion deletedAlarmIds.forEach(alarmId -> {,Please remove debug codes.,Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,@snleee This is handled with the API refreshSegment(),What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,This seems to be unnecessary. I also get the label after removing this.,why var4? Resources.NotFoundException e would be a bit nicer..
"private static String truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName(String legalLastName, String legalFirstName) { int maxAllowedLengthOfFirstName = VendorConstants.MAX_VENDOR_NAME_LENGTH - VendorConstants.NAME_DELIM.length() - legalLastName.length(); if (legalFirstName.length() <= maxAllowedLengthOfFirstName) { return legalFirstName; } else { String truncatedLegalFirstName = legalFirstName.substring(0, maxAllowedLengthOfFirstName); LOG.info(""truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName: Received legalFirstName '"" + legalFirstName + ""' with length of "" + legalFirstName.length() + "" and it is being truncated to '"" + truncatedLegalFirstName + ""' with length of "" + truncatedLegalFirstName.length()); return truncatedLegalFirstName; } }","If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood.",Please change user back to USER_YODA here.,"maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",log,move the check and assignment before the other checks to ensure the behaviour is not changed.,Do we missing some enums here?,Replace with logger,These could be renamed to not use nonAscii.,suggestion this.ignoreAbove = mw.ignoreAbove;
"public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) { GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId)); GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity(); snapshot.setClusterId(volume.getClusterId()); snapshot.setVolumeId(new Guid(volumeId)); DateFormat df = new SimpleDateFormat(""yyyyMMddHHmmss""); String snapshotName = snapshotNamePrefix + ""-snap-"" + df.format(new Date()); snapshot.setSnapshotName(snapshotName); snapshot.setDescription(description); VDSReturnValue returnValue = getBackend().getResourceManager() .RunVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new GlusterVolumeCreateSnapshotVDSParameters(new Guid(serverId), volume.getName(), snapshotName, description, force)); if (returnValue.getSucceeded()) { snapshot.setSnapshotId((Guid) returnValue.getReturnValue()); snapshot.setCreatedAt(new Date()); snapshot.setStatus(GlusterSnapshotStatus.STARTED); getGlusterVolumeSnapshotDao().save(snapshot); } else { log.error(""Error while creating snapshot for volume '{}': {}"", volume.getName(), returnValue.getVdsError() .getMessage()); log.debug(returnValue.getVdsError().getMessage()); } }","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",Why use a java.lang.Boolean and not a primitive boolean?,power down,Should TREEHASH be a HashCode?,Why do we handle error like this?,Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,Conditional is more clear as: !getZooKeeperInstance().isEmpty(),"verify(client != null, ""client cannot be null"");","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Sounds like a workaround for host misconfiguration issue.,We tend to use IllegalArgumentException for these kind
"public boolean removeFileEntry(String index, TransientStore ts) { BatchFileEntry fileEntry = getFileEntry(index, false); if (fileEntry != null) { if (fileEntry.isChunked()) { for (String chunkEntryKey : fileEntry.getChunkEntryKeys()) { List<Blob> chunkBlobs = ts.getBlobs(chunkEntryKey); if (chunkBlobs != null) { for (Blob blob : chunkBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(""Error while deleting chunk parent directory"", e); } } } ts.remove(chunkEntryKey); } fileEntry.beforeRemove(); } String fileEntryKey = fileEntry.getKey(); List<Blob> fileBlobs = ts.getBlobs(fileEntryKey); if (fileBlobs != null) { for (Blob blob : fileBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(""Error while deleting file parent directory"", e); } } } ts.remove(fileEntryKey); return true; } else { return false; } }",I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,"suggestion log.debug(""{} old entitlement certificates deleted"", count);","Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",I think you can probably change the return type to List<? extends Target>,"indentation, here and rest of PR",Remove /Dev Team,What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,is double call to structIsNull.toBooleanArray() intentional?,the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,Make sure to unescape the url path before using it. I've hit this in actual usage.,"Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)"
