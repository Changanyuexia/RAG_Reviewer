code,review,top_1,top_2,top_3,top_4,top_5,top_6,top_7,top_8,top_9,top_10
"private ByteArrayInputStream uploadPackV2(String... inputLines) throws Exception { ByteArrayOutputStream send = new ByteArrayOutputStream(); PacketLineOut pckOut = new PacketLineOut(send); for (String line : inputLines) { if (line == PacketLineIn.END) { pckOut.end(); } else if (line == PacketLineIn.DELIM) { pckOut.writeDelim(); } else { pckOut.writeString(line); } } UploadPack up = new UploadPack(server); up.setUseProtocolV2(true); ByteArrayOutputStream recv = new ByteArrayOutputStream(); up.upload(new ByteArrayInputStream(send.toByteArray()), recv, null); ByteArrayInputStream recvStream = new ByteArrayInputStream(recv.toByteArray()); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(""version 2"")); assertThat(pckIn.readString(), is(""ls-refs"")); assertThat(pckIn.readString(), is(""fetch=shallow"")); assertTrue(pckIn.readString() == PacketLineIn.END); return recvStream; }","Let's add a constant for ""version 2""","Is this order guaranteed, ie ls-refs before fetch?",Define a string constant for this?,nit: lowercase header,readString() for the version so you can ignore the LF?,"This doesn't quite work. You need to call matches() before you can access the group: Matcher m = versionPattern.matcher(pckIn.readStringRaw()); if (!m.matches()) { throw new IOException(... invalid cert ...) } String version = m.group(1); This is one reason we don't bother with regex. Especially for simple patterns like this. It can be easier to just say: private static final String VERSION = ""version ""; String s = pckIn.readStringRaw(); if (!s.startsWith(VERSION)) throw ... String version = s.substring(VERSION.length());",Accidental squash?,catch NumberFormatException and throw PackProtocolException just in case?,"optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.","shouldn't you clear out restartToken and lastPackId at the start? The way you are using class variables is error prone. Any thing that should be remembered across sessions should be stored in the Session, otherwise pass the information as arguments. This will require you to create some helper types to hold data e.g. a Header class with two fields, restartToken and lastPackId. This does not apply to in and out, since they are used everywhere.",Can you point me out where did you have this embedded email sever approach from ? Thanks
"private void repaint() { if (graph != null) { System.out.println(""repainting graph...""); Tile model = new Tile(graph); TileView view = new TileView(); TileController tc = new TileController(view, model); Group root = new Group(); wrapper.hvalueProperty().addListener( (ChangeListener<Number>) (ov, oldVal, newVal) -> { repaintPosition(tc, root, newVal.doubleValue()); }); Rectangle clip = new Rectangle(getMaxUnifiedEnd(graph) * VertexView.HORIZONTALSCALE, 0); root.getChildren().add(clip); repaintPosition(tc, root, wrapper.hvalueProperty().doubleValue()); } }",Iffy formatting,"I know it's for debug, but calling getBoundingRectangle many times isn't great.",This debug output should be deleted,Maybe we should also do a getRGB/setRGB for completeness?,"this if-else if-else block (and the one below for the Shape) is similarly confusing: why are we not considering these questions (is the view transformer a LensTransformer? is the layout transformer a LensTransformer?) separately, and why are we assuming that the appropriate default is a basic transformation using the layout layer?","Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.",You don't need the fully-qualified name here now that this is targeting 1.12 - might as well take advantage of the name change.,zoomIn and zoomOut code differe only in single line 'plot.zoom[Out](zoom)' please avoid code duplication,I'm pretty sure we can remove this now. If necessary the default state change task will do it. Just verify enabling/disabling the outline still works ok.,Please make sure you are removing all console spam before submitting PRs.,"Unnecessary variable, the iteration variable should be called valueMap itself."
"public Request iterate(final Request req, final Coordinates cords) { return null; }","don't return NULL, throw UnsupportedOperatedException instead",it's better to throw UnsupportedOperationException when something is not implemented yet,Please address <LINK_0>,In case self is a BufferedIterator should this return self instead of re-wrapping?,I think you can skip this.,"Minor, but how about Collections.<SQLCloseable>emptyList() instead here so we don't have to worry about null?",perhaps just successfulRequests++ ?,So... what's the purpose of this...?,ration == relation?,good!,Need to implement
"public MamQueryIQ parse(XmlPullParser parser, int initialDepth) throws Exception { String queryId = null; String node = null; DataForm dataForm = null; if (parser.getName().equals(MamQueryIQ.ELEMENT)) { queryId = parser.getAttributeValue("""", ""queryid""); node = parser.getAttributeValue("""", ""node""); boolean done = false; while (!done) { int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) { if (parser.getName().equals(DataForm.ELEMENT)) { dataForm = new DataFormProvider().parse(parser); } } else if (eventType == XmlPullParser.END_TAG) { if (parser.getName().equals(MamQueryIQ.ELEMENT)) { done = true; } } } } return new MamQueryIQ(queryId, node, dataForm); }","That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?",Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.,"Oh, do we need one? If we have an empty fixture, I don't think we need to add a record to our DB. I think an empty <fixture/> tag should either delete an existing fixture or be ignored entirely. We can't really make a meaningful ""Base"" element like this",Here is also that unusual check.,Why is this not conditional?,This line looks indented too far,Should use nextTag() and switch-case instead.,"I usually prefer the depth comparison, a single integer comparison, over two String equality checks.",getPrefix returns null if there is no prefix so this will throw an NPE.,"Not sure if it would not be better to follow the way we parse xml files in JavaHandler, XmlFileHandler etc.","Minor, but ""extra"".equals(tagname) would make this more concise. Java and its endless checking for nulls..."
"public static <T> TypeToken<T> getTypeToken(TypeToken<T> token, Class<? super T> raw) { if (raw!=null) return TypeToken.of((Class<T>)raw); if (token!=null) return token; throw new IllegalStateException(""Both indicators of type are null""); }",Should this not prefer the token over the raw?,Cant it loop?,"That's a good point, but my plan was to move OBJECT_TYPE to TypeTokens and make it public, which in theory allows users to pass it to get(). So it might be better to use null to indicate getObject (as you initially did).","How about ""Type is not supported""?",Can you leave this method as-is and create a new method to strip wildcards?,Does the @SuppressWarnings here have any effect? Can't really see what could cause a unchecked warning right now.,This is a fun one,"shall we do the check like **""int"".equals(expectedType)** . So that we can avoid null check at the beginning.",final is unnecessary.,"Should this check Collection as that is the super type for List and will capture Set, Queue, etc.","very nit: Isn't it because those are parameterized types rather than ""pure internal""?"
private void initPlugins() throws Exception { Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps(); for (InitStep initStep : pluginsInitSteps) { initStep.run(); } },It would have been shorter to inline this variable and not have it in scope. :-),Wrap it with Collections#unmodifyableList()? I assume it should be read-only,In which case would this print useful information?,"We are on Java 7 now, consider to make usage of AutoClosable and try-with-resource block.",please just use arraylist,"Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: ""Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception."" So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?",Probably better to just shut up.,Why not make it final and return an empty list? It seems better to avoid using null if possible,Unchecked.consumer(plugin::customizeJdbi).accept(this); is the right mantra :),"Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.","This should have braces. Oh, and a space after for."
"public <T> T cast(FormField<?> formField) { if (getDefaultOrNull(formField)) { return null; } if (this == formField.getValueType()) { return (T) formField.getValue(); } else if (STRING == formField.getValueType()) { return (T) formField.getValue().toString(); } else { throw LOGGER.logExceptionAsError(new UnsupportedOperationException(String.format(""Cannot cast from "" + ""field value of type %s to type %s"", formField.getValueType(), PHONE_NUMBER))); } }",Is toString() required? It's already of STRING type.,"try prefix is used to distinguish this method from public toMessageClass(). I find it better than innerToMessageClass() or something. I use try prefix for such methods as Bob Martin does in his great book, Clean Code.",Everywhere else in ESH we are using BigDecimal for INTEGER and DECIMAL configuration values. Is that an option here as well?,Why is this here with such a wide exception type?,"Minor: same as in other number check, WDYT about checking for the decimal point?","I wonder why it is fine for DoubleValidation if the value is not String or Double? IIUC it should not pass the validation if you send here any other object that has nothing to do with any number. IMO you should check if the value is String or Number, if not return fail.","We may want to handle this to IllegalArgumentException, and change above forEach to catch IllegalArgumentException and wrap with SchemaValidationFailedException. Bubbling up NullPointerException or IllegalArgumentException to the REST API response would be bad for end users. If you just want to ensure denying null, I'm OK to leave it as it is, and I could handle it.",Wouldn't instanceof work here? To check the Types?,Change to use a length check instead of a ... getTimeZoneFormat().length() instead of relying on an exception. Need to try and remove and recreate and then add the length check.,Please use { } even if it is one line.,We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); }
"public LengthFieldBasedFrameDecoder( ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, boolean failFast) { checkPositive(maxFrameLength, ""maxFrameLength""); checkPositiveOrZero(lengthFieldOffset, ""lengthFieldOffset""); checkPositiveOrZero(initialBytesToStrip, ""initialBytesToStrip""); if (lengthFieldOffset > maxFrameLength - lengthFieldLength) { throw new IllegalArgumentException( ""maxFrameLength ("" + maxFrameLength + "") "" + ""must be equal to or greater than "" + ""lengthFieldOffset ("" + lengthFieldOffset + "") + "" + ""lengthFieldLength ("" + lengthFieldLength + "").""); } this.byteOrder = checkNotNull(byteOrder, ""byteOrder""); this.maxFrameLength = maxFrameLength; this.lengthFieldOffset = lengthFieldOffset; this.lengthFieldLength = lengthFieldLength; this.lengthAdjustment = lengthAdjustment; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength; this.initialBytesToStrip = initialBytesToStrip; this.failFast = failFast; }",move the check and assignment before the other checks to ensure the behaviour is not changed.,"typo ""should"", also ""In case"".",it might help if this exception class knew about the type - so that it only has to print relevant details in the exception.,I think we need to add the offset here,I think the endOffset < 0 check is redundant here.,Doesn't hurt to validate MAF.,"Unless you have reason to do otherwise, you should just return an int not an Integer and you shouldn't set the value to 0 by default. That way, if they call getPreKmerLength() before initializing, they'll get a NPE (which is better than the corresponding bug!)",why not use MaxMessageSizeExceeded?,we need to also keep the old constructor for backward combat.,typo,IllegalArgumentException?
"public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - 1 - endOfTableName); return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }",might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here,"If the buffer isn't reused, then it is safe to cache a copy of the bytes and use it each time unsafe is called rather than copying all the time.",bytes are always non null,I would prefer to move this call to the private ReleasableBytesReference constructor.,missing .duplicate,Case 3 is redundant,"Shouldn't here throw EOFException instead of MessageFormatException? Because readPayload, unpackString and getNextFormat throws EOFException.",Can StringUtils.fromUtf8 be used?,This can be simplified to (char3 & 0x3F),"Usually you can just leave the exception on at the end without needing to wrap it in an Arg. This way you get the stack trace (which is considered safe), though the (possibly unsafe) message is redacted.","so if you make this private that would prevent subclasses other than Some, right?"
"public void ThrottleForNormalizeTestWithinIdeal() throws Exception { List<RateLimit> scenarios = new ArrayList<>(); int limit = 5000; int buffer = ApiRateLimitChecker.calculateBuffer(limit); int approximateIdeal = 4000; scenarios.add(new RateLimit(limit, approximateIdeal + buffer - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 101, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, limit, soon)); setupStubs(scenarios); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(1, countOfOutputLinesContaining(""under budget"")); assertFalse(handler.getView().stream().anyMatch(m -> m.getMessage().contains(""Sleeping""))); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(2, countOfOutputLinesContaining(""rechecking"")); assertEquals(3, countOfOutputLinesContaining(""Still sleeping"")); assertEquals(2, countOfOutputLinesContaining(""Sleeping for"")); assertEquals(1, countOfOutputLinesContaining(""under budget"")); assertEquals(10, handler.getView().size()); }","EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>","Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount(""Sleeping"", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.",We could also have a test to establish that we can be rate limited on one read and then have a smaller read succeed.,Maybe move these stubbings to independent setup methods that can be reused by both checkers. Probably have one method per pair of test methods. (This might mean calling checkApiRateLimit a few extra times in ThrottleOnOver case since it will probably check a different number of times.),"the default one should be fine, isn't it?",Could be inlined here by using test(),"My checkstyle is exploding with ""magic numbers"" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic",If I'm understanding this correctly this one should read suggestion assertThat(delay.getNextPause(SUCCESS_TOO_SLOW)).isLessThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));,is tolerance needed here?,"Do you still need the two threads with this eventuallyEquals? I would rather move that on the beginning of the test method, as this line may not be reached upon test failure (and you don't want to fail the next test method).",Not used.
"public boolean cleanupNode(final String id) { RegionAndId regionAndId = RegionAndId.fromSlashEncoded(id); ResourceGroup resourceGroup = resourceGroupMap.getUnchecked(regionAndId.region()); String group = resourceGroup.name(); VirtualMachine virtualMachine = api.getVirtualMachineApi(group).get(regionAndId.id()); if (virtualMachine == null) { return true; } logger.debug("">> destroying %s ..."", regionAndId.slashEncode()); boolean vmDeleted = deleteVirtualMachine(group, virtualMachine); cleanupVirtualMachineNICs(group, virtualMachine); cleanupVirtualMachineStorage(group, virtualMachine); return vmDeleted; }",[minor] could you name it resourceGroupName,"Should this better be a return false, to cover the case when an official Image is provided and also cover the return value with the catch block is executed?",Can the container be removed even if the stop operation fails?,Lets add an assert that this is the first snapshot in the snapshottable dir ?,"I prefer stream+collect rather than foreach and adding element to an external list eg (please note I'm using default naming generated by idea here):  List<CloudResourceStatus> collect = findResources(resources, List.of(AZURE_DATABASE)) .stream() .map(r -> getCloudResourceStatus(cloudContext, force, client, persistenceNotifier, r)) .collect(Collectors.toList()); return collect; } private CloudResourceStatus getCloudResourceStatus(CloudContext cloudContext, boolean force, AzureClient client, PersistenceNotifier persistenceNotifier, CloudResource r) { LOGGER.debug(""Deleting postgres server {}"", r.getReference()); azureUtils.deleteDatabaseServer(client, r.getReference(), force); persistenceNotifier.notifyDeletion(r, cloudContext); return new CloudResourceStatus(CloudResource.builder() .type(AZURE_DATABASE) .name(r.getReference()) .build(), ResourceStatus.DELETED); }",Is this really needed here and in the next state-change methods?,"This local variable is only used once. Please consider collapsing into lint 1122. Also, please add the message from the exception to the message to provide greater detail for debugging efforts.",creation -> deletion,[minor] maybe resourceGroupName?,Should we additionally check if we are not destroying the default group?,Unused args?
"public Factory(long nowMillis, Request request, Response cacheResponse) { this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; if (cacheResponse != null) { this.sentRequestMillis = cacheResponse.sentRequestAtMillis(); this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis(); Headers headers = cacheResponse.headers(); for (int i = 0, size = headers.size(); i < size; i++) { String fieldName = headers.name(i); String value = headers.value(i); if (""Date"".equalsIgnoreCase(fieldName)) { servedDate = HttpDate.parse(value); servedDateString = value; } else if (""Expires"".equalsIgnoreCase(fieldName)) { expires = HttpDate.parse(value); } else if (""Last-Modified"".equalsIgnoreCase(fieldName)) { lastModified = HttpDate.parse(value); lastModifiedString = value; } else if (""ETag"".equalsIgnoreCase(fieldName)) { etag = value; } else if (""Age"".equalsIgnoreCase(fieldName)) { ageSeconds = UtilKtKt.toNonNegativeInt(value, -1); } } } }",UtilKtKt isn't a great name.,Please add isDebugEnabled check to prevent varyUrl computation in debug disabled case.,Better to have a meaningful name?,"The getExpirationTime getter is missing, isn't it?","Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?",Can header name and value be null?,Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?,"not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.","Not sure whether this needs to be there. This duplicates a header. Also, HttpCacheEntry's constructor doesn't accept the ""date"" Date, only ""request/responseDate"".",Don't need to index. Use StoredField instead.,will .toString() result in same as .getHeader()
"protected void doResolveAll(String inetHost, DnsRecord[] additionals, Promise<List<InetAddress>> promise, DnsCache resolveCache) throws Exception { if (inetHost == null || inetHost.isEmpty()) { promise.setSuccess(Collections.singletonList(loopbackAddress())); return; } final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost); if (bytes != null) { promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes))); return; } final String hostname = hostname(inetHost); InetAddress hostsFileEntry = resolveHostsFileEntry(hostname); if (hostsFileEntry != null) { promise.setSuccess(Collections.singletonList(hostsFileEntry)); return; } CacheResult res = doResolveAllCached(hostname, additionals, promise, resolveCache, resolvedInternetProtocolFamilies); if (res == CacheResult.CACHED) { return; } if (res == CacheResult.CACHED_EXPIRED) { promise = executor().newPromise(); } doResolveAllUncached(hostname, additionals, promise, promise, resolveCache, completeOncePreferredResolved); }",consider using a switch(res) {...},Is reentrancy a problem? It looks like it would be possible.,Can we check records length and log a WARN or INFO if more than one record was returned? This probably would also need to implement logging flood control.,ipString - Abbreviation should be used Did you install the pearl of the GridGain - an abbreviation plugin?,What's the point of throwing UnknownHostException and caching it within few lines?,Should log the exception here. Does the caller handle the unknown address correctly?,"IIUC, there is a chance that users will never hit this path. Therefore, there is no need to load and initialize DnsServerAddressStreamProviders in advance. Can we use DnsServerAddressStreamProviders.unixDefault() here instead of a static constant?",shouldn't we add into names?,Could you please explain this change?,This should be kept so we can use the resolvedDestinationAddress passed in to the constructor.,"I know this was like this when you got here but we can make it a bit more functional. Something like this: java return reverseDnsLookup(ipAddress).map(host -> { if (!host.endsWith(domain + ""."")) { logger.error(""Reverse DNS lookup on ip '{}' - resolved domain '{}' does not match '{}'"", ipAddress, host, domain); return false; } return true; }).orElseThrow(() -> new Exception(format(""Host not found for ip address '%s'"", ipAddress)));"
"private List<Resource> filterNotAuthorizedResource(PerunSession sess, List<Resource> resources) throws InternalErrorException { Iterator<Resource> resIterator = resources.iterator(); while(resIterator.hasNext()) { Resource resource = resIterator.next(); if(!AuthzResolver.isAuthorized(sess, Role.RESOURCEADMIN, resource) && !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) resIterator.remove(); } return resources; }",For PerunObserver you can return all resources immediately.,"This String should correspond to the name of the called method. suggestion throw new PrivilegeException(sess, ""getResourcesWhereUserIsAdmin"");",I don't remember: have we planned to have simple guava cache in this implementation or not? I checked - currently reading events endpoint (both hila and lola) is called ~25 times/sec.,"The same question about "", "" as above.",suggestion if (a) {,rename 'wSetResource' (wSet ^= working set),"I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.","There are a few issues with this line: - Set<String is missing a closing angle bracket. - Errai 3.x targets Java 1.6 so we can't use the <> operator. It should be <String> instead. - This is the first usage of HashSet in this file, so there's a missing import for java.util.HashSet.",Same here. Does it need to be synchronized?,Could use resultCache.computeIfAbsent,"We may need an ""internal-session"" as the userSession will likely not have permissions to read the ACL resources."
"public void initTrackerServers(List<TrackerServer> serverList) { serverList.add(new TrackerServer(new ServerBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(""frameDecoder"", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(""objectDecoder"", new AstraProtocolDecoder(AstraProtocol.this)); } }); serverList.add(new TrackerServer(new ConnectionlessBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(""frameDecoder"", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(""objectDecoder"", new AstraProtocolDecoder(AstraProtocol.this)); } }); }","UDP is a datagram protocol, so it doesn't require frame decoder.",Why do you use 3-argument constructor here?,4 should be a constant somewhere. Do we really need both encoder and decoder on both the server and client?,Initialize in declaration,why pass in a SocketChannel when you could pass in whatever .pipeline() returns,magic numbers. Some explanation would be good.,in other examples we usually inject the SslContext if ssl should be used and so build it in the main method. Consider doing this here as well to keep it consistent.,Move to the beginning of the pipeline and call .addLast instead?,"For consistency, can you move this between passport and http handlers (line 65) and change the method to addLast?",Same here: before the codec was set previously to traffic shaping... Maybe this is the right place there ?,For http2 is it even an option to not set up SSL? You could use Objects.requireNonNull in the constructor
protected Properties getIntegrationProperties() { if (this.beanFactory != null) { return IntegrationContextUtils.getIntegrationProperties(this.beanFactory); } else { return null; } },Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.,Maybe store it as an Optional instead? Prevents accidental NPEs if used within this class. Is the 'noinspection unchecked' an annotation?,I think we should putAll() the defaults - a common java developer error is to use get() instead of getProperty() on a Properties object. Only getProperty() looks for the defaults if not found.,Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?,- log warning that option is not supported by SNMP,"@Nullable on this getter? Or, maybe we should just always return it, even if empty. Also, now that we have a mechanism to modify the map, maybe we should return an UnmodifableMap - if so, it should be a field instead of wrapping the map on every call.",Can we move this prefix spring.cloud.stream.bindings to a constant? and probably use a constant for spring.cloud.stream prefix in ChannelBindingServiceProperties itself?,why are we doing a bean lookup here?,"I think caculatePrefix cannot be used here because the previous snippet will possibly try 2 times in the case when both neither and id are not empty. But with the new logic applies, it will only try once with the prefix returned in caculatePrefix.","M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.",I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
"public void testShowStatsSelectNonStarFails() { assertQueryFails(""SHOW STATS FOR (SELECT nationkey FROM nation_partitioned)"", "".*Only SELECT \\* is supported in SHOW STATS SELECT clause""); }",Why this change?,Reformat this as SELECT * FROM nation ORDER BY n_nationkey,Why this change?,Would you mind improving this test to use executeFile() instead of executeString()?,Why this change?,Construct this dynamically with a reference to the enum value for the error code instead of hardcoding 28,put each arg in separate line,"what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?","Please avoid to reformat automatically our files. It makes it very difficult to find the real changes in there. To fix it, use your IDE to compare both versions then bring back all the changes that are purely reformatting. Thanks!",( and ) braces are redundant here,"If set to ERROR, the MDX should _fail_. The fallback should only be used if the property is not ERROR. The idea of the property is that users who need the MDX to be nativized will prefer failure over attempting to run a query which may bog down the system, so ERROR should abort."
"protected static ConnectionFactory getConnectionFactory( IDatabaseConnection databaseConnection, String url ) { ConnectionFactory factory = null; if ( url.startsWith( ""jdbc:mysql:"" ) || ( url.startsWith( ""jdbc:mariadb:"" ) ) ) { Properties props = new Properties(); props.put( ""user"", StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ) ); props.put( ""password"", StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); props.put( ""socketTimeout"", ""0"" ); props.put( ""connectTimeout"", ""5000"" ); factory = new DriverManagerConnectionFactory( url, props ); } else { factory = new DriverManagerConnectionFactory( url, StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ), StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); } return factory; }","We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.",Should we log this?,"+1 The error is re-thrown, so logging level could be reduced.",Why do you replace ex1 with getServerErrorMessage?,"This happens during connector validation, right? When a connector config is submitted to a distributed worker, it gets validated as soon as the worker has a chance to look at it. Then, if the worker isn't the leader, it forwards the config to the leader, which validates it _again_, and then finally writes it to the config topic. When all of this is done, the user's REST request is given a 200-level response. Given that this means the connector config will possibly (even likely, since in any cluster of two or more workers you have a <=50% chance of hitting the leader with a request) be validated twice, and the REST request timeout in distributed mode is 90 seconds, maybe something like 40-45 seconds would be more appropriate here? That way we could avoid the scenario of the connection taking 60 seconds to succeed during the first worker's validation, then taking another 60 seconds to succeed during the leader's validation, then the config getting written to the config topic--even though at that point the user's REST request will have been met with a 500 timeout response.","Would be better to validate the seconds here again, because this is a public API, users may directly use it in JdbcSink.",join this 4 log statements into one,Use OseeClient.OSEE_APPLICATION_SERVER,"should a """" password be allowed? (I have no idea if that is valid)","Error message could be more specific: ""Is the timeout of the DB connection disabled as expected?""","could you please move it to the constructor? configure is for dynamic things like the admin password, everything else should be configured in the constructor, so that it can be overridden externally without extending the class"
"public void testDisableIncrementalAnalysis() { executeTarget(""testDisableIncrementalAnalysis""); assertOutputContaining(""Avoid really long methods""); }","you should check the cache doesn't exist, plus that no suggestion to use the cache is logged","you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present",nit: please use a static import for assertEquals,"assertThat(Sets.intersection(generatedMethods, originalMethods)).isEmpty()?",Abbreviation should be used for variable name: Result -> res. See abbreviation rules.,Abbreviation should be used for variable name: Result -> res. See abbreviation rules.,"Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.",Abbreviation should be used for variable name: Result -> res. See abbreviation rules.,static import,This can be ignored as @romani wants the method removed.,static import
"public void preInstall() { resolver = Entities.newDownloader(this); String subpath = entity.getConfig(BrooklynNode.SUBPATH_IN_ARCHIVE); if (subpath==null) { String uploadUrl = entity.getConfig(BrooklynNode.DISTRO_UPLOAD_URL); String origDownloadName = uploadUrl; if (origDownloadName==null) { String downloadUrlTemplate = entity.getAttribute(BrooklynNode.DOWNLOAD_URL); if (downloadUrlTemplate!=null) { origDownloadName = DownloadSubstituters.substitute(downloadUrlTemplate, DownloadSubstituters.getBasicEntitySubstitutions(this)); } } if (origDownloadName!=null) { origDownloadName = Urls.getBasename(origDownloadName); String downloadName = origDownloadName; downloadName = Strings.removeFromEnd(downloadName, "".tar.gz""); downloadName = Strings.removeFromEnd(downloadName, "".tgz""); downloadName = Strings.removeFromEnd(downloadName, "".zip""); if (!downloadName.equals(origDownloadName)) { downloadName = Strings.removeFromEnd(downloadName, ""-dist""); subpath = downloadName; } } } if (subpath==null) subpath = format(""brooklyn-%s"", getVersion()); setExpandedInstallDir(Os.mergePaths(getInstallDir(), resolver.getUnpackedDirectoryName(subpath))); }",Make sure to unescape the url path before using it. I've hit this in actual usage.,"Use Os.mergePathsUnix, in case installBaseDir ends in slash already? Looks like that is what it used to handle. Same for runBaseDir below.",This case looks redundant with the default.,why 'else'? i think always do this,Could you use camelCase instead of underscores for variable names? It's just a convention and helps with a more coherent source code.,I would rather check all configured remotes not only default one.,"You could directly use replace without if block/check, because with contains and replace you are doing double look-up anyway.",Appreciate there wasn't one before but would make sense to include a failOnNonZeroResultCode to this step.,"This condition is always false now: originalName = ""foo.jar"" And the name of plugin can be ""foo"" or ""bar"" if plugin defines its own name, but it is never ""foo.jar"".","In getBaseDownloadUrl you can't really identify what the context is. Instead you should just do a url.startsWith(Framework.getProperty(""nuxeo.url"")) I think, and drop getBaseDownloadUrl.","Yeah, I think so."
public boolean isLaunchedFromIntent() { return invokeSource.equals(InvokeSource.WIDGET) || invokeSource.equals(InvokeSource.INTENT_SHARE) || invokeSource.equals(InvokeSource.INTENT_PROCESS_TEXT); },A future refactor might place this method in the enum directly.,IDE says to use Collections.singletonList,Please use host.id instead of name,"Since it's present in all configurations, consider moving this object creation to the top of the method to occur unconditionally.","this is a public method so better perform some null checks, or at least use assert statements",The statement return parameters.flowControl == FLOW_CONTROL_HW; should be enough.,Maybe use a proper error msg,Just call ActionUtil.share?,Perhaps add further information to this exception,"please use line number of lamba in argument of method , it is really cool idea to make it more visual.",ServedService.class should be replaced with WifiService.class as it was before in both the lines.
"private void initializeAsyncCancelAndVerifyCancelled(AlwaysFailingInitializer initializer, Runnable cleanupTask) throws InterruptedException { initializer.initialize(true); initializer.cancelInitialization(cleanupTask); int numberOfAttemptsWhenCancelled = initializer.initializationAttempts; initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY * 5 + 1, TimeUnit.MILLISECONDS); assertThat(initializer.initializationAttempts).isEqualTo(numberOfAttemptsWhenCancelled); }","We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?",private static final int FIVE = 5,Let's change this one to 1/week on Friday night,It looks like we'd want to verify the third code path where task.waitForCompletion returns true if it isn't already completed when calling it.,"For me, interrupting here is like having a smaller timeout. So we should go out of the loop directly. Because it means someone has explicitly called interrupt on this thread. If having a too short timeout breaks everything, than we have another problem.",assertEquals() instead of assert keyword :),We required braces for single-line if statements.,should be Repeater.RAND,Why not this::refresh ?,Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.,Shouldn't you call cdl2. countDown() before you check the state again?
"public ExecutorService getExecutor(Properties p) { TypedProperties tp = TypedProperties.toTypedProperties(p); int maxThreads = tp.getIntProperty(""maxThreads"", 1); int queueSize = tp.getIntProperty(""queueSize"", 100000); long keepAliveTime = tp.getLongProperty(""keepAlive"", 10000); final int threadPrio = tp.getIntProperty(""threadPriority"", Thread.MIN_PRIORITY); final String threadNamePrefix = tp.getProperty(""threadNamePrefix"", tp.getProperty(""componentName"", ""Thread"")); final String threadNameSuffix = tp.getProperty(""threadNameSuffix"", """"); ThreadFactory tf = new ThreadFactory() { @Override public Thread newThread(Runnable r) { String threadName = threadNamePrefix + ""-"" + counter.getAndIncrement() + threadNameSuffix; Thread th = new Thread(r, threadName); th.setDaemon(true); th.setPriority(threadPrio); return th; } }; ThreadPoolExecutor tpe = new ThreadPoolExecutor(maxThreads, maxThreads, keepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(queueSize), tf, new ThreadPoolExecutor.CallerRunsPolicy()); tpe.allowCoreThreadTimeOut(true); return tpe; }","I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.",Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads,"I thought format used ""%s"" and ""%d""?",This is a String so use final String id = THREAD_ID.get(thread) ; and then you don't need to do the cast on the next line.,"Possible _NumberFormatException_ if the key has a text value like ""abc""",probably don't need to read this but instead use fiq.crawlDelay as you do in line 534,break is missing,could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?,"Shouldn't it be priority - Thread.MIN_PRIORITY (which is the same as priority - 1, but just by accident)?",let's make a meaningful constant for 5,"The initial pool size is set to 0, according to the doc any idle thread above the core number of threads will be terminated after time-out. I think that having the core threads at 0 can trash the system with creating and terminating threads all the time. Why not have it configurable as before, and set it to a number that seems reasonable as the constant number of threads once they started (100 for example - should be tested of course)"
public GWCConfig getConfig() { if (gsEnvironment != null && gsEnvironment.isStale()) { syncEnvironment(); } return gwcConfigPersister.getConfig(); },"This bloc of code is repeated many times, should be centralized in a single method.",I would use FlowLogDBService#findAllByResourceIdAndFinalizedIsFalseOrderByCreatedDesc here as it would spare some resources: - won't fetch db again for the environment - you could loose the finalized check in the next if - you could loose try-catch and use isEmpty instead,wrap this line?,Add one log here? Update from xxx to xxx?,this needs to be called for all configs,"you should mock external components, not the one you are testing",use a for-each,code dup. would be better to move it to private saveInternal(),Log statement here to catch missing/duplicate invocations of this.,please extract into a separate method,I think if you switch to safeFromString method it should guarantee that it's a valid crn and it has account id or an Exception would be thrown
"private void captureScreenshot(String comment, WebDriver driver, WebElement element, boolean errorMessage) { if (getMessage(errorMessage) != null) { comment = getMessage(errorMessage); } LOGGER.debug(""DriverListener->captureScreenshot starting...""); try { if (errorMessage) { LOGGER.error(comment); Screenshot.captureFailure(driver, comment); } else { LOGGER.info(comment); if (MobileContextHelper.isInWebViewContext()) { MobileContextHelper.backUpContext(driver); Screenshot.capture(driver, comment); MobileContextHelper.restoreContext(driver); } else { Screenshot.capture(driver, comment); } } } catch (Exception e) { LOGGER.debug(""Unrecognized failure detected in DriverListener->captureScreenshot: "" + e.getMessage(), e); } finally { resetMessages(); } LOGGER.debug(""DriverListener->captureScreenshot finished...""); }",I don't see sense from this if (MobileContextHelper.isInWebViewContext()),Format,Let's not add a separate dependency to do base64 decode. Can't we use <LINK_0>,Format,Good. The view is now very easy to understand. And the biz logic is somewhere else.,I think this string needs to be externalized so it can be translated,"this seems like a bad idea, I'd rather wrap the IOException into a MessagingException further down the stack where it's still visible why IOExceptions can happen and why they are handled this way.",use ExceptionUtils from import org.apache.commons.lang.exception.ExceptionUtils to convert to String,Amen. This bothered me for ages :D,Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?,This first part seems to share logic with the existing screenshot functionality. Can you see whether that can be extracted to reduce code/functionality duplication?
"public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) { super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.my_courses, menu); final Config config = environment.getConfig(); if (config.isTabsLayoutEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(false); menu.findItem(R.id.menu_item_account).setVisible(true); menu.findItem(R.id.menu_item_account).setIcon( new IconDrawable(getContext(), FontAwesomeIcons.fa_gear) .colorRes(getContext(), R.color.white) .actionBarSize(getContext())); } else { menu.findItem(R.id.menu_item_account).setVisible(false); if (config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(true); } else { menu.findItem(R.id.menu_item_search).setVisible(false); } } }",This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()),"Can you not just check for searchView.hasFocus(), instead of having to set this flag?","If the feed is null, the menu items should still be setup. Just the feed title can be left out. That prevents possible flickering when menu items are displayed/hidden for some feeds.",This should be with the rest of the findViewByIds.,"Maybe this method could be extracted to a new class, so it can be shared between episodes list and feed details list. This class is already quite big.","better to add type abbrevation like 'll_graded_content_layout', tv_prop_msg.","nobody will see this printing, I fear.",Please move this ) to the line above,"I don't think we want to prepend the host URL here; I think the course video uri is expected to be a full video URI, no? It might be a <LINK_0> URL for example.",There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround],Load this using a CallbackGroup at the same time as myAccount. Add the ScreenLoadCallback as the 2nd callback to display the screen after both callbacks are finished successfully.
"protected List<AttributeStatement> createSubjectRoleStatement(final CallbackProperties properties) throws SAMLAssertionBuilderException { final String userCode = properties.getUserCode(); final String userSystem = properties.getUserSystem(); final String userSystemName = properties.getUserSystemName(); final String userDisplay = properties.getUserDisplay(); if (Arrays.asList(userCode, userSystem, userSystemName, userDisplay).contains(null)) { LOG.error(""No information provided to fill in user role attribute..""); throw new SAMLAssertionBuilderException(""No information provided to fill in user role attribute.""); } final List<AttributeStatement> statements = new ArrayList<>(); final List<Attribute> attributes = new ArrayList<>(); attributes.add(componentBuilder.createUserRoleAttribute(userCode, userSystem, userSystemName, userDisplay)); if (!attributes.isEmpty()) { statements.addAll(componentBuilder.createAttributeStatement(attributes)); } return statements; }",Can this be changed to createSubjectRoleAttribute?,Consider to use StringUtils.hasLength(str) to check,use getOrDefault(),"Since these methods for optional fields can now return a null value here instead of an empty list, we should have an appropriate null check before adding it to the list.","This approach is not going to work, as otherwise it will always URL encode values that are not supposed to be URL encoded. Instead something like this should work: URI attrName = parseAttributeName(attribute); ... private URI parseAttributeName(Attribute attribute) { try { return URI.create(attribute.getName()); } catch (IllegalArgumentException ex) { // Maybe the attribute name has a space in it... try { return URI.create(URLEncoder.encode(attribute.getName(), StandardCharsets.UTF_8.name())); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(""Unsupported Claim type""); } } }","It's good practice to provide as much inforamtion as possible. Please, use constructor of WrongAttributeValueException with additional parameters Attribute and AttributeHolder.",This syntax is quite confusing.,Lambda could be replaced by the method reference Attribute::getAttributeName,Remove this whole block (l49-54) since this has moved to static initialization above.,the attributes can be changed by client since this method returns the original reference. Is this intended?,Travis CI is throwing a compilation error for cannot find symbol Base64 on line 208. ref: <LINK_0>
public LineRanges within(final LineRanges ranges) { final LineRanges result = new LineRanges(); final Iterator<LineRange> iterator = ranges.iterate(); while (iterator.hasNext()) { final LineRange next = iterator.next(); for (final LineRange line : this.lines.collection()) { if (next.within(line)) { result.add(line); } } } return result; },@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?,make this method private ?,"The innerIterator is not thread-safe, meaning if two threads access next() in parallel, they may get junk. By synchronizing the wrapper, only one thread at a time gets through to the inner interator, other threads are blocked in the wrapper until the thread inside is done. That way, this method returns a thread-safe iterator.","Fine to move the command, but since you try to refactor the code, this method should be private",(nit) s/actual/current/g,"@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)",java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.,"minor suggestions: please, check the formatting (need some whitespaces). I would also personally use !this.hasNext() instead of explicit check with false. if (next == null && !this.hasNext()) {",@winteryoung Could you explain for me why you changed the argument from lineIO to lineI here? It's not immediately obvious to me why you think it's correct.,This method can return void.,Please give this exception a name
"public GlusterServersListReturnForXmlRpc(Map<String, Object> innerMap) { super(innerMap); List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>(); Object[] serversArr = (Object[]) innerMap.get(GLUSTER_HOSTS); if (serversArr != null) { for (int i = 0; i < serversArr.length; i++) { glusterServers.add(prepareServerInfo((Map<String, Object>) serversArr[i])); } } setServer(glusterServers); }",Do not try to parse the sever list if the command has failed (mStatus.code != 0),Shouldn't index be initialized to MAX_INT in order to trigger this on 1st call ?,"In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.",I would suggest naming this variable as 'serversArr' instead of 'temp',Suggested more old-style to avoid list reallocation: java int historicalServers = historicals.values().stream().mapToInt(Collection::size).sum(); int allServers = historicalServers + realtimes.size(); List<ServerHolder> result = new ArrayList<>(allServers); historicals.values().forEach(tierServers -> result.addAll(tierServers)); result.addAll(realtimes); return result;,only instanciate ret and mt if servers != null and length > 0,"suggestion if (server == null || server.getUrl() == null)) { return this; } if (servers == null) { servers = createList(); } for (Server existingServer : getServers()) { // If a server with the same URL is found, merge them if (server.getUrl().equals(existingServer.getUrl())) { ModelUtils.merge(server, existingServer, true); return this; } } // If a server with the same URL doesn't exist, create it servers.add(server);  reduces complexity","I'd say it's a bit hard to read such constructions, do you think it is possible to simplify that?",Looks like this code is not tested,Couldn't shuffle be called once after adding discovered and then configured?,"It might be better to wrap the reflection in an abstraction in a static block in this file so inspection of the class will be done only once, save some runtime inspection cycles."
"private void buildTestedInstance() { ; this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }",Floating semicolon,please leave it that way - it's intentionally referencing the deprecated version.,Is there a reason to not make it protected ?,it is missing the verify of the commandRegisteredEvent fire on the tests. You can use the EventSourceMock to mock the event.,yeah let's remove this :),Spaces around the ==,Maybe pull creation of this exception in a method so it is not duplicated here and in assertOpen,I understand this method calls hibernatUtil.getSessionFactory. Should we consolidate it or refactoring?,I think we should keep this synchronized.,Typically I do all the Spec only visible for the factory methods to instantiate. Is there any purpose to let this be created directly from end-user level?,A single test shouldn't run the context twice ideally.
"public void parentIsNotCalledIfAccountStatusExceptionIsThrown() { AuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(new AccountStatusException( """", new Throwable()) { }); AuthenticationManager parent = mock(AuthenticationManager.class); ProviderManager mgr = new ProviderManager( Collections.singletonList(iThrowAccountStatusException), parent); try { mgr.authenticate(mock(Authentication.class)); fail(""Expected exception""); } catch (AccountStatusException expected) { } verifyZeroInteractions(parent); }","Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.","This is nitpicky, but you could use assertFalse instead of assertEquals for these.","If we already have existing constants for these various account types, it would be better to use those here (and in the other relevant test methods below).",Why aren't there any assertions in this test method? Seems like it should at least validate the response returned by createSnapshotCmd.execute().,This seems to be failing compilation.,shouldn't you need to sleep here too ?,getTestAccount() is called in several places and the method instantiates same account/container several times. Why not have a global testAccount?,are we missing an assertion for serviceReference here? should it be null/empty? or will it be generated?,We should use a thenAnswer() on accountDao.updateAccount() and then verified that the commit hook is being passed in and called.,Should we verify that commitAssign() is never called?,why twice?
"private void initScanner(Schema projected) throws IOException { this.projector = new Projector(inSchema, outSchema, plan.getTargets()); System.out.println(""=======================>"" + plan.getTableDesc().getName()); for (FragmentProto f: fragments) { FileFragment ff = (FileFragment)FragmentConvertor.convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), f); System.out.println("">>>>>>>>>>>>>>>>>>>"" + ff.getPath()); } if (fragments != null) { if (fragments.length > 1) { this.scanner = new MergeScanner(context.getConf(), plan.getPhysicalSchema(), plan.getTableDesc().getMeta(), FragmentConvertor.<FileFragment>convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), fragments), projected ); } else { this.scanner = StorageManagerFactory.getStorageManager( context.getConf()).getScanner(plan.getTableDesc().getMeta(), plan.getPhysicalSchema(), fragments[0], projected); } scanner.init(); } }",Please remove debug codes.,Wired Path,:heart:,remove?,Please remove debug codes.,"pass e as the second parameter, so the entire stack trace is not lost.","assuming this was for debugging, should remove.","can you split these into separate methods, configurePipeline is pretty long.",nit - just say schema fields is empty,remove?,Log level should be trace or remove the log line
"public boolean put(ConflictTxStream conflictStream) { Long val = cacheConflictKeys.get(conflictStream); if (val != null && val >= conflictStream.txVersion) { log.error(""For key {}, the value {} is not smaller than the expected value {} or maxWildCard"", conflictStream, cacheConflictKeys.get(conflictStream), conflictStream.txVersion, maxConflictWildcard); return false; } if (cacheConflictKeys.size() == cacheSize) { invalidateFirst(); } cacheEntries.add(conflictStream); cacheConflictKeys.put(conflictStream, conflictStream.txVersion); cacheEntriesBytes += conflictStream.size(); return true; }",please use long,is it necessary to check if trace is enabled? The message will not get logged if logging level is > trace,Why not taking the value from the entry set instead of getIfpresent?,"Shouldn't this be Caffeine<String, Entries<E>> ?",Typo: let's use performanceStatsEnabled name here and in all other cases.,throw an exception ?,Shouldn't this go to the Single as an error?,I don't get how what is replaced maps to a checkAndMutate instance? There is no matching in previous impl?,Missing Java doc.,Do we need the memory semantics of an AtomicBoolean or could we get away with a boolean[] here?,"""put(key, val)"" will take extra lock that you don't need."
"public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(final Collection<BindingSet> bindingSets) throws QueryEvaluationException { return null; }",Is there a reason this isn't implemented?,"Minor, but how about Collections.<SQLCloseable>emptyList() instead here so we don't have to worry about null?",Can we return an empty list here instead?,Null check,"So there is still just one result provider per query, not one result provider per query and hint? If this is true, why are getResultProvider() calls restructured, and why is the field 'hints' removes, what is the point?","Don't use a nullable parameter, use Function.identity(). Even more since this is never null.","This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.",Shouldn't this return a Page<T> instead of a List<T>?,can be java public Seq<E> getErrors(),Collections.emptyList() or UnsupportedOperationException.,This change is potentially significant. The execution context can change during execution where a new context derived from the current one is produced so please keep L108/L109.
"public static <T> void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }",nit: unnecessary generic type declaration,"ERR_DELETE_ERROR, add if there isn't one already","This could also be updated to use TransactionHelper.runInNewTransaction I suppose, like you did for RunInNewTransaction.java",Would it work to drop the iterator and just execute  operations.forEach(this::add);,"This seems redundant. notifyError(ErrorResponse response) doesn't care about ErrorResponse object, it just unwraps the cause. I think existing version is better, no need to wrap/unwrap.",is this method needed for implementation (other implementation classes accessing the operations list) or is that needed as part of the public api?,I don't see the api for CosmosContianer (sync version). could you please add that too.,"I guess the reason for using self here is because compiler won't allow using non-final variable inside .then() In that case, we should just make self explicitly final so its more clear to the reader of the code.","should we close currentOperationContext here too? From the code in loadBatch(), it could be removed from the activeContexts, so it may not be in the activeContexts when close() is called.",That's the only bit which would not be converted when using reactive type adoption from the repository layer.,"addAll(int, Collection)"
public Integer getPartition() { String changelogPartition = getMessageValue(CHANGELOG_VALUE_KEY); return (changelogPartition != null) ? Integer.parseInt(changelogPartition) : null; },Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition),Can we return the primitive integer ? Don't see a reason to create integer objects here.,It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.,Same. No need to autobox?,StringUtils.isEmpty,Do we need separate getter for partitionField? partitionField has a public access modifier,"nitpick: I used to write it this way, but I think it's not obvious what it's doing. Even though it's more code, I think it's clearer to write:  if (myPartitionId == null) { return ""null"" } return myPartitionId.toString();","That would still log a warning, which should not happen. Also if the prop is not set, I think we should keep it this way.","In which case we could try making #getRepository to return AggregatePartRepository<I, S>. This way you'll have the checks and type cast in the same #getRepository method. Then you'll have S as a result of #getState and will be able to get rid of this suppression.","findValue(x) searches x recursively in the node, or its children. Is this really what you want here? I think you should use get(x).",Integer.valueOf
"public void testInitAggregator() throws Exception { final List<BuiltinAggregator> aggregators = Arrays.asList(BuiltinAggregator.COUNT, BuiltinAggregator.MAX, BuiltinAggregator.MIN, BuiltinAggregator.SUM); testedView.initBuiltinAggregators(aggregators); aggregators.stream().forEach(agg -> verify(lstBuiltinAggregator).addOption(agg.value())); }",Out of interest why can you not do BuiltinAggregator.values()?,"toString() on Set<> and List<> automatically output as comma-delimited stuff, so there's no need for the Joiner.",Why does this need to be public?,otherOutputNames looks quite broad. Docs will be useful to understand and use this method.,"Like PvaluefromZscorePostAggregator, this should recursively decorate the post-aggregators from fields.","should be ""leastPostAggregator"", in testComparator() as well","Class<? extends T>..., to be exact ;-)",Please remove debug code.,This seems like a dangerous approach in case we added AggregationOps that didn't make sense for double (say boolean operators).,Is this supposed to be true?,"groupedPartialAggregation and distinctAggregation appear to use Assert.assertEquals to check aggregation results. Is this the case? If so, we need to pass a different version of Assert.assertEquals."
"private void doCopyRetry(FileSystem sourceFs, List<ReplChangeManager.FileInfo> srcFileList, FileSystem destinationFs, Path destination, boolean useRegularCopy) throws IOException, LoginException { int repeat = 0; boolean isCopyError; List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath); while (!pathList.isEmpty() && (repeat < MAX_COPY_RETRY)) { LOG.info(""Attempt: "" + (repeat+1) + "". Copying files: "" + pathList); try { isCopyError = false; doCopyOnce(sourceFs, pathList, destinationFs, destination, useRegularCopy); } catch (IOException e) { if (!(e instanceof FileNotFoundException)) { LOG.info("" File operation failed with error : "" + e.getMessage()); sourceFs = pathList.get(0).getFileSystem(hiveConf); destinationFs = destination.getFileSystem(hiveConf); } isCopyError = true; } pathList = getFilesToRetry(sourceFs, srcFileList, destinationFs, destination, isCopyError); repeat++; } if (!pathList.isEmpty()) { LOG.error(""File copy failed even after several attempts. Files list: "" + srcFileList); throw new IOException(""File copy failed even after several attempts.""); } }",Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.,This is File copy error not file system retry case.,in what scenario path list will be empty with copy error set to true ?,"Shall check if CM path exist and if not, shall throw the error/exception as in base code.",use srcPath instead,Shouldn't this method should be private?,"In what scenario, fileInfoList can be empty?",I think var args make new Object[] not required if memory serves. Same in several other places.,This was mistakenly moved,"This might be paranoid, but you may want to catch UncheckedIOException as well.",It can be just info or debug.
public long forceNext() { long l = longs.incrementAndGet(INDEX_HEAD); if (((l >> 3) << 3) == l && concurrentInvocations() > 10) { concurrencyDetection.onDetected(); } return l; },"minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.",As I understand here and in other methods super.{method} should be used.,so you can invoke next() until infinite?,"Method body could be replaced by Unsafe.getAndAddInt(null, ptr, 1) + 1.",I'm concerned that this might not be inlined.,unnecessary cast to long,"Over time I've generally found it a best practice not to synchronize on your object directly because other users may end up doing the same which can lead to surprising locking issues. You can use a private Object as a lock. However, given that there is no real coordination of state here, you could opt to make currentGeneration an AtomicInt and use CAS to update it. Reads should be cheaper too.",public keyword is not needed in interfaces. All of them are public by default,why don't u support reentrancy for local threads,Could we go and use some constants here to improve readability? It's really hard to follow.,"could initialize with cardinality of bits, e.g. List<Long> indexes = new ArrayList<Long>((int) bits.cardinality());"
public boolean needsSequentialWriting() { return !vfsList.get(0).getCapabilities().contains(Capabilities.PARALLEL_WRITE); },Why not use capabilities directly here?,We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;,IMO it should be synchronized as well,Shouldn't this API call be guarded by a check for Android version M?,"This this isn't needed. Generally, we only use the this keyword where it makes code unambiguous.",// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off,I am leaning toward moving this back to requiring Jenkins.ADMINISTER,There should be a null check for permissions here. Because Subject.testPermission(String) does not accept null permissions as input.,I think the 'vf' data meber is redundant. The 'isVf()' method can return- physicalFunction != null,"Once the isReadOnly field is removed, change this method to  return this.cache.isReadOnly();",Please remove diagnostic modifications before merging.
"private static NewIssueLocation locationForIssue(InputFile inputFile, HtmlIssue issue, NewIssue newIssue) { NewIssueLocation location = newIssue.newLocation() .on(inputFile) .message(issue.message()); Integer line = issue.line(); if (issue.startColumn() != null) { location.at(inputFile.newRange(issue.line(), issue.startColumn(), issue.endLine(), issue.endColumn())); } else if (line != null) { location.at(inputFile.selectLine(line)); } return location; }","Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!",Why LOG.trace?,Before we always had non-null returns,"should we use ""this"" on line to make more evident what we are doing",I think we should behave like in.line and only modify the range if the range or line is provided. if (in.range != null || in.line != null) { e.setRange(in.range); } This should also assert the line == range.end_line. If in.line is not supplied but in.range is we should set e.steLine to range.end_line.,Remember the special case of issues having only flows with a single location (like cognitive complexity). Here all (single) locations of all flows should be highlighted.,"@inverno Why don't you use an ""else"" here? With an ""else"", without reading the implementation of methods isJust/FarBelow, we know that all cases are covered, that is, that we will always hit one of the 2 cases. Further advantage: either of the two methods isJust/FarBelow can be removed.","As a safety precaution, should we make this assignment just once to grab only the very first line number in case generated synthetic lambda method contains more than one line numbers?","please keep there method with name 'shouldBeAloneOnLine' (only name not a logic), it is the same in naming form as others.","If it's of the form uri#lineNumber, wouldn't a simple uri.lastIndexOf('#') do the same trick?",Should this be in line with YEdit's spaces-per-tab preference?
public FbChain(final Iterable<Fallback> fallbacks) { super( new Fallback() { @Override public Opt<Response> route(final RqFallback req) throws IOException { Opt<Response> rsp = new Opt.Empty<Response>(); for (final Fallback fbk : fallbacks) { final Opt<Response> opt = fbk.route(req); if (opt.has()) { rsp = new Opt.Single<Response>(opt.get()); break; } } return rsp; } } ); },@ekondrashev why not just rsp = opt?,@ekondrashev move this assignment to line 103 above.,@fanifieiev the same above.,"@fanifieiev please, fix the indentation here.",@fanifieiev ResponseOf is a better name than RsOf.,let's return getOption();,@fanifieiev the same above.,"this is not safe, what if there will be HTTP/2.0? I would rather do .split(""\\s"", 2)[1]",I didn't get this... why can't you just do return resp.head()?,I didn't realise RetroLambda supported backporting try-with-resources until now. :),"maybe: ""String wantLine;"" Or ""l"", or ""lineWithoutCaps"""
"protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); Boolean dbShouldBeUpdated = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }",Why use a java.lang.Boolean and not a primitive boolean?,either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.,"Highly unlikely, but what if you have one lun on the storage with lunIdX and a DIFFERENT one with pvIdX?",You should use getLuNDao().updateAllInBatch(lunsToUpdateInDb) Also - this should be done in the same compensation context as the storage domain update.,just a reminder about the db lock for better user experience so we can see more opinions about that,"you are matching LUNs with a complexity of luns.size() * lunsFromDeviceList.size(). Consider converting one list into a map, and then iterating over the other, resulting in a complexity of luns.size() + lunsFromDeviceList.size().",Consider refactoring DbFacade.getInstance().getLunDao() to StorageHandlingCommandBase.,maybe log the old and new sizes as well? (could help with debugging when things go awry),"getStorageConnectionsByStorageType is a horrible method that contains business logic in the DAO layer. Having said that, you should just fix it to make sure that the frontend and the backend are aligned. (Or better yet, remove it altogether)",space after comma?,"Liran I am thinking what should the implementation be in order to easily extend it to other places One of my concerns is that IMHO usages should call only update and know nothing about the internal implementation that will check if update needed Other is that we have IIRC infrastructure hierarchy that might help us implement that in a higher level I think that the solution should be more general than that , lets discuss that offline"
"public void modifyAST(IIndex index, IMarker marker) { IASTTranslationUnit ast; try { ITranslationUnit tu = getTranslationUnitViaEditor(marker); ast = tu.getAST(index, ITranslationUnit.AST_SKIP_INDEXED_HEADERS); } catch (CoreException e) { CheckersUiActivator.log(e); return; } IASTNode astNode = null; if (isCodanProblem(marker)) { astNode = getASTNodeFromMarker(marker, ast); } if (astNode == null || !(astNode instanceof IASTCastExpression)) { return; } ASTRewrite r = ASTRewrite.create(ast); INodeFactory factory = ast.getASTNodeFactory(); IASTCastExpression oldcast = (IASTCastExpression) astNode; IASTCastExpression newcast = factory.newCastExpression(getCastType(), oldcast.getTypeId().copy(CopyStyle.withLocations), oldcast.getOperand().copy(CopyStyle.withLocations)); r.replace(oldcast, newcast, null); Change c = r.rewriteAST(); try { c.perform(new NullProgressMonitor()); } catch (CoreException e) { CheckersUiActivator.log(e); return; } try { marker.delete(); } catch (CoreException e) { CheckersUiActivator.log(e); } }",merge the try/catch with the one below?,"The problem is that by default, CDT will ""helpfully"" auto-insert a trailing newline on file save. We can disable this behaviour in the test with: PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false);",never use new String(String),change order of branches to show similarity NameQualifiedType ~ QualifiedType,should rather use astRewrite.createMoveTarget(..),"PS. For what its worth, the example here has ""Copyrsight"" miss spelt.",First is redundant check !(binding instanceof ILabel) would be sufficient to catch the null case,Please use a switch:  java switch (initializer.getNodeType()) { case CAST_EXPRESSION: initializer = ((CastExpression) initializer).getExpression(); break; case CLASS_INSTANCE_CREATION: ...,it looks like you're trying to mimic having some kind of label.isFunction method without actually having one. Is there a reason you didn't go that route?,Should this be limited to declarations that are located in the translation unit file?,You should probably abstract the duration into a named constant.
"synchronized public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) { List<String> newSegments = new ArrayList<>(); for (String onlineSegment : onlineSegments) { if (!_segmentToTimeRangeMSCache.containsKey(onlineSegment)) { newSegments.add(onlineSegment); } } List<String> newSegmentZKMetadataPaths = new ArrayList<>(); for (String segment: newSegments) { newSegmentZKMetadataPaths.add(_segmentZKMetadataPathPrefix + segment); } List<ZNRecord> znRecords = _propertyStore.get(newSegmentZKMetadataPaths, null, AccessOption.PERSISTENT, true); for (int i = 0; i < newSegments.size(); i++) { String segment = newSegments.get(i); Interval range = extractTimeRangeMSFromSegmentZKMetaZNRecord(segment, znRecords.get(i)); _segmentToTimeRangeMSCache.put(segment, range); } _segmentToTimeRangeMSCache.keySet().retainAll(onlineSegments); _timeRangeMSToSegmentSearchTree = new IntervalST<String>(_segmentToTimeRangeMSCache); }",@snleee This is handled with the API refreshSegment(),"This won't take effect... Here is the Helix code for it (I would count it as a bug):  @Override public List<T> getChildren(String parentPath, List<Stat> stats, int options, int retryCount, int retryInterval) throws HelixException { return getChildren(parentPath, stats, options); }  I don't see an easy way to throw exception for this API unless we create the children paths manually.","I am unclear on the extensibility of the code in future. Will we add more selectors and cascade them in future, for example versionBasedSelector/Pruner?",You may refer to PartitionSegmentPruner where we do batch read for init() and single read for onExternalViewChange() because usually external view change only involves change for one segment.,Put the getStat call inside the recordPathStat parameter list is no longer clean. Please create a local var for the state and pass it to the record method.,minor: idsOfUpdatedAccounts,IMHO error is fine but better to keep it warn. We anyways have warn for InterruptedException also.,You avoided the notificationTime report on the deleting events with this change. Please keep the original order.,"This should not use putIfAbsent, since there are side effects.","IMO if you already have the iterator instance, then a regular while (iter.hasNext()) loop would be best for inlining and for memory (metaspace) usage.",Visibility missing. Synchronized comes before static Why return an Iterable here? It would be better just to return a List<TerminatlInfoView>
"private TracingContext traceToMap(Map<String, Object> map) { long startParse = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - startParse; long startOffset = now - startRequestNanos; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }",Probably just wants to be start or startPhase or something if now generic.,"I'm concerned about the stopTimer method. My thoughts: - the get() method of optional generally should be avoided. This is a pretty good article on optional usage: <LINK_0>, it sums up a number of similar points. I think one to help this is to mark startNanos as @Nullable and just use a null value and do a classic if( null )  type of check. Though, we still have a lot of internal state going that route. Even if we allow for disabled timers, assigning startNanos always to System.nanoTime would not hurt that much (we are still talking a ns operation, that is not a place to make performance improvements).","Should the createdTimestamp be passed as an argument? When you read it out of the store, it seems like it should be set to what is in the store and not the current time.",nitty nit: move ) { to the next line,why are we sending 0? does 0 have special meaning? if so shouldn't 0 be used a constant?,"Please do check on null for all such getters. I believe we previously returned null in such case, because object was a Date, now we return primitive long which isn't an object. We should probably return Long so its serialized either as null or long value.",I don't see any reason to encapsulate the one function call with another one.,I would prefer these returned a DateTime to improve the model and instead used Jackson annotations to control the render format. Thoughts?,Would it be better if use StringUtils.defaultString() on the string methods?,"Why replace null with ""null"" ? (similar for value)",static for the 3 methods
"public void testIllegalMinMax() { try { new FixedDoubleHistogram(-200, 3.0, 3.0); fail(""exception expected""); } catch (IllegalArgumentException e) { assertTrue(e.getMessage().contains(""bucketCount"")); } }",nit: any chance to make the message assertion more specific? :),"Similarly here, use Double.valueOf(actual)",I'm wondering whether we should actually not allow negative deltas. What do you think?,totalLow,"will be better with: ""by less than 10.0% but difference was 20.0% percent.","This actually isn't an optimization; Double.valueOf(double d) just calls 'new Double(d)' Let's just remove this change. Since this class is deprecated, I want to minimize changes to it wherever possible.",not your code...(perhaps...) but should try-with-resources,A percentage is between 0 and 100,nit: maybe replace } with a blank line? There is no such code style in druid. The same for the { and } below.,Let's see...,"We should not use Java assert statement but proper unit testing asserts, ie, assertThat(e.getMessage(), equalTo(""...""));"
"public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(baseDir, false); return p4.latestChange(); }","We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }",return setExecution ...,"Based on whether the directory is cleaned, etc. there's a [different sync happening](<LINK_0>","Same as other review, it would be nice to simplify and abstract the serialization concerns.","SubMonitor progress = SubMonitor.convert(monitor,2); then pass on progress.newChild(1) twice.","guess returning a copy of the list might be a better idea as the in memory list is your only ""data of truth"", you may not want the list to be messed up by the caller.",Do we really want this to be public?,I would put the return 0L here. This is probably the one and only place where you do not propagate the exception,rename to file or modifiedFile,"minor suggestion to move length check outside unrelated try-catch, and put in a continue statement instead.",assertThat(entries).hasSize(3); the same for several occurances below
"public void putJobCompletedNotification() throws IOException, SignatureException { UUID notificationUUID = null; try { final PutJobCompletedNotificationRegistrationSpectraS3Response response = client .putJobCompletedNotificationRegistrationSpectraS3( new PutJobCompletedNotificationRegistrationSpectraS3Request(""test@test.test"")); notificationUUID = response.getJobCompletedNotificationRegistrationResult().getId(); assertThat(response.getStatusCode(), is(201)); } finally { client.deleteJobCompletedNotificationRegistrationSpectraS3( new DeleteJobCompletedNotificationRegistrationSpectraS3Request(notificationUUID)); } }",check to make sure notificationUUID is not null,This should check to make sure that notificationUUID is not null before attempting to delete it.,check to make sure notificationUUID is not null,"Nitpick: controller.deleteSurvey() throws, so the assert will never be checked.","should we test CouponDeleted like you did for Card (if so, applies to all delete)",Why do we need these three assertions??,If you're expecting an exception you could just invoke fail() after the call to builder.post() on line 47.,"I'd have an ""expects exception"" rule in your test, in case the exception isn't thrown.",Locale.English and timezone GMT,This isn't a job. Please rename the object to match what the object actually is.,Same question about this finally
"public static Pair<Boolean, String> checkFingerPrint(String expected, PublicKey key) throws Exception { if (key == null) { return null; } if (expected == null) { return new Pair<>(false, getFingerPrint(key)); } String comps[] = expected.split("":"", 2); DigestFactory factory; if (comps[0].length() > 2) { factory = BuiltinDigests.fromString(comps[0]); if (factory == null) { return new Pair<>(false, getFingerPrint(key)); } } else { factory = BuiltinDigests.md5; expected = ""MD5:"" + expected; } String fingerprint = getFingerPrint(factory, key); return new Pair<>(expected.equals(fingerprint), fingerprint); }","java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }","I recommend the following (D.R.Y ...):  java String algo = d.getAlgorithm(); if (BuiltinDigests.md5.getAlgorithm().equals(algo)) { return algo + "":"" + BufferUtils.printHex(':', data); } else { return algo.replace(""-"", """").toUpperCase() + "":"" + Base64.encodeToString(data).replaceAll(""="", """"); }",s/uninitilized/null,why not reuse fingerprint1 to build the good fingerprint ?,Can you please add some debug messages here and is the relevant methods as well?,Better to have 16 here instead of 8.,why do you need to make this so complex? if (words.length < 2) { } please.,"Hmm, there's not really a need for this since verify(PublicKey) is calling verifyInternal(PublicKey, String). The other new method can simply be inlined here. The intent here is to create a fast path to go directly to BoringSSL, so perhaps this can check: if (key instanceof OpenSSLKeyHolder && sigProvider instanceof OpenSSLProvider) { OpenSSLKey pkey = ((OpenSSLKeyHolder) key).getOpenSSLKey(); verifyOpenSSL(pkey); return; }",it cannot be > 3 if you split with 3.,Looks wrong. Did you mean for one of the Objects.equal to compare the getPublic()?,Can we define a final CONSTANT for the MD5 ?
private boolean isValidationNecessaryOnReads(TableReference tableRef) { return isValidationNecessary(tableRef) && validateLocksOnReads; },"probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.","you should use here acquireLockAsyncTask(), we need to acquire locks only for commands that require to hold them for the entire execution flow (including endAction()).","Once the isReadOnly field is removed, change this method to  return this.cache.isReadOnly();",source.getOriginalConstraint() is marked as nullable,"Maybe, this is final?","Isn't this potentially risky? We could see the empty table, but then another node could fill the table before we get round to dropping it. What happens in that case?",Do you really need ReentrantReadWriteLockWithTracking.ReadLock here? Maybe it makes sense to change it to java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock?,"This method does not utilize the rows cached conditions which get cached during SecurityRow.evaluate(). This will result in conditions getting create at least twice for non-mutable cases, but for mutable cases we will now create conditions every permission check. Could the mutable flag be encoded into the Decision.decision bit such that the row.eveluate could return the Decision along with if the decision is mutable? I think this would require you to create three more constants for the mutable instances of the following: static final Decision DECISION_ABSTAIN = new Decision(SecurityTable.ABSTAIN, null, null, null); static final Decision DECISION_GRANTED = new Decision(SecurityTable.GRANTED, null, null, null); static final Decision DECISION_DENIED = new Decision(SecurityTable.DENIED, null, null, null); But if you do encode the mutability into the Decision object then you would not need this method here or the looping above to determine if the row decision is mutable.",As I understand here and in other methods super.{method} should be used.,"we should refactor out all the dupe code here, so that there is a helper method like:  boolean hasFlag(Read read, int flag) { ... }  also, if that method exists, it might not be necessary to make all these wrappers",t.key()
"public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }",We don't need super here,Unnecessary call to super,Unnecessary call to super(),this method should be changed to private,Consider extracting this into its own method called addBuyOrderToOrderBook or simply addBuyOrder.,Consider refactoring this into a function named addBuyOrderToOrderBook or simply addBuyOrder. Extract method refactoring.,super() is not necessary,S is not a good variable name. Rename it to something more descriptive.,"Was not addressed in patch, still need a space before the '{' at the end here to match your formatting elsewhere.",needs to be named something more relevant like market,Consider rename this variable
public boolean isEnabled() { GitHistoryPage page = getPage(); if (page == null) return false; String head; try { head = page.getInputInternal().getRepository().getFullBranch(); } catch (IOException e) { head = null; } IStructuredSelection sel = getSelection(page); if (sel.size() != 1) return false; Object o = sel.getFirstElement(); if (!(o instanceof PlotCommit)) return false; PlotCommit commit = (PlotCommit) o; int refCount = commit.getRefCount(); for (int i = 0; i < refCount; i++) { String refName = commit.getRef(i).getName(); if (refName.equals(head)) continue; if (refName.startsWith(Constants.R_HEADS) || refName.startsWith(Constants.R_REMOTES)) return true; } return false; },Does it make sense to continue here? Or just return false.,Why it creates a new instance instead of looking up issue home implementation from container?,"Maybe use a final string refsHeads = ""refs/heads/"" and use it here and for the length?","Would replace that with: String fullBranch = head.getObjectId().name(); and rename fullBranch to objectId, to make it clear that this is an ID, not a branch name.","The objectId == null case should not be possible. Could simplify by making the code match the intent more directly: if (headRef.isSymbolic()) { return Repository.shortenRefName(headRef.getTarget().getName()); } // detached HEAD ObjectId id = headRef.getObjectId(); if (id == null) { throw new AssertionError( String.format(""HEAD is neither a symref nor an ObjectIdRef: %s"", headRef)); } return id.getName();","no, don't resolve the symbolic link here otherwise you get the reflog for the branch HEAD is pointing at, instead I would like to see the extra reflog maintained for HEAD which follows all updates of HEAD including branch switches with is not the case for git reflog for a branch. Use just refName = Constants.HEAD instead of refName = ref.getTarget().getName() then you'll see the difference, select master to see the difference. Also the branch selection dialog of the reflog view needs to show HEAD otherwise this cannot be selected explicitly.",exactRef,should be: if (!name.startsWith(Branch.R_HEADS)),Needs way better name. Static?,use ternary operator and keep this variable final then you don't need to define another variable below.,don't declare JGitInternalException
"public void testStartProcessFromNodeIdsWithTimer() throws Exception { final String processId = ""simple.restartWithTimer""; assertNotNull(deploymentService); KModuleDeploymentUnit deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION); deploymentService.deploy(deploymentUnit); units.add(deploymentUnit); assertNotNull(processService); Long processInstanceId = processService.startProcess(deploymentUnit.getIdentifier(), processId, singletonMap(""var_a"", 3)); assertNotNull(processInstanceId); Thread.sleep(3000); processService.abortProcessInstance(processInstanceId); Collection<NodeInstanceDesc> timed = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.SKIPPED, new QueryContext(0, 0)); assertThat(timed.size(), is(1)); Collection<NodeInstanceDesc> aborted = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.ABORTED, new QueryContext(0, 0)); assertThat(aborted.size(), is(1)); String[] nodeIds = aborted.stream().map(e -> e.getNodeId()).toArray(String[]::new); processInstanceId = processService.startProcessFromNodeIds(deploymentUnit.getIdentifier(), processId, singletonMap(""var_a"", 3), nodeIds); runtimeDataService.getTasksByProcessInstanceId(processInstanceId).forEach(e -> { Task task = this.userTaskService.getTask(e); assertThat(task.getName(), is(""Third Task"")); this.userTaskService.start(e, ""katy""); this.userTaskService.complete(e, ""katy"", emptyMap()); }); ProcessInstance pi = processService.getProcessInstance(processInstanceId); assertNull(pi); }",Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {,I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);,unboxing not needed,Same here. And later you can again call await on the same countDownListener.,"I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().","No, this method should not throw interrupted exceptions.",Is it possible to make the sleeps shorter? (max 2 seconds?) What is the thread waiting for?,"No, this method should not throw interrupted exceptions.","Same here, this test is only works if time elapses between deployments. Please also verify that the returned definitions are actually the ones you expect and not just that the count is correct.",This and the above try-catch block could be likely refactored to a standalone method.,I think that Kie server should return HTTP status 4xx in this case (possibly 400) as request parameter cannot be parsed.
"protected boolean isAnyAppConfiguredInSourceServerXml() { boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); bConfigured = true; } return bConfigured; }","Here I would just say return true. Then fall through return false, instead of creating a variable.","Seems like there's a spacing issue here, two spaces instead of 4.","log.info. The yaml may not define a location, so we shouldn't warn.",Why create a list above and then return a tree set? Why not simply create the tree set above and add to it before returning?,change to private or just use configured directly,This file update needs to be removed because you are no longer using it. This is what codacy is complaining about too.,should we throw an exception IlleagalState?,I don't believe appLocation can be null here as if it was we would have gotten a NullPointerException above so calling appLocation.isEmpty() should be good enough.,"#2935 forces the null check (so #3021 does not save us here), but if it _is_ null, we should just do nothing because Jenkins has not even started up yet anyway. Thus java return loc != null && loc.getUrl() == null;",Can a running server have no server.xml file?,"Did you respect to the server parameters precedence? That is, bootstrip.properties in ${configDirectory} first, then <bootstrapProperties> in pom.xml, and ${bootstrapPropertiesFile} last. I don't see the condition involving ${configDirectory}."
"protected void exportAsContext() { if (EDatabaseConnTemplate.isSchemaNeeded(getConnection().getDatabaseType()) && schemaText != null && StringUtils.isEmpty(schemaText.getText())) { MessageDialog.openWarning(getShell(), Messages.getString(""AbstractForm.ExportAsContext""), Messages.getString(""DatabaseForm.checkSchema"")); } collectContextParams(); super.exportAsContext(); }",It's better to use **isBlank** here,same pattern :),"This only works because ExpressionFormatter produces DECIMAL 'xxx' for DecimalLiteral. I think that might be required for a while to avoid incompatibilities when creating views, for instance. Eventually, we need to change it to produce simple decimal literals. Add a TODO in ExpressionFormatter.visitDecimal to clean that up once the parse-as-double flag is removed.",use {} for single statements,You broke the arguments list convention here :),"This is less readable. The ""not"" is too far away from the method call.","It doesn't make sense to me that these signatures are changed to void, even if they're deprecated.",rawSql.isEmpty() ?,This can now cause an NPE. See also failing test. Please also check all other changes regarding the same failing pattern.,"The above is not quite right, because first and last may not be the same. For example, SQLServerDialect.openQuote() returns '[', and closeQuote() returns ']'.",Should we remove the spaces at the beginning and the end of the text? Users can still send the description if they add a space to the end even if the text contains an invalid format.
"public boolean validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().asConvertible().integer(); getModel().getNumOfDesktops().validateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().getMaxAssignedVmsPerUser().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 1000000) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid()); getModel().setIsPoolTabValid(true); return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid(); }",also here please use Short.MAX_VALUE,"after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().ValidateEntity( } remove union (like you did in name validation)",Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.,This shouldn't be necessary. gwtorm should add the new column and initialize it to false by default.,"maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?",Also add group.setType(AccountGroup.Type.SYSTEM),"This method is logically correct. But its basically what we call canPerform(...) in ProjectControl. Maybe you should abstract it into a canPerform here, because then you can reuse this new canPerform function inside of canUpload() too, and reduce code duplication.",I think also the description needs validation: getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });,Does A indicates active? we might want to insert record for signup as inactive once approved we can set it to active user.,"Is there value in testing with more than one setting here? I agree this is the highest priority since it is the default, but the extremes of 0 and 9 are also worth checking.",Is it possible the field exists but is not a long? That would make this fail wouldn't it?
private void doConcurrentPutInTx(String s) throws Exception { for (int i = 0; i < totalNumberOfBuckets; i++) { synchronized (list) { list.add(i); } } Thread[] threads = new Thread[totalNumberOfBuckets]; for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i] = new Thread(() -> doPutOpInTx(s)); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].start(); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].join(); } },"This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()",Just out of curiosity: does this test fail with 60 seconds timeout?,make this a synchronizedSet instead of synchronizing inside the trhead.,batch -> put ? Should there be a test to catch it?,Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.,What is this 4? Is it a numPushThreads / 2?,All of this can be replaced with an ExecutorService,Why '-lock'?,Add space = new,why not use the foreach pattern instead of iterator?,"@Vladlis This makes sense. Since you are expanding the case of the issue, please update original issue with this too. Release notes only go by issue title, so if we don't update it users won't know about us including default too."
"private void addEditLink(WebMvcLinkBuilder selfLinkBuilder, GoalDto goalResource) { goalResource.add(selfLinkBuilder.withRel(JsonRootLinkRelationProvider.EDIT_REL)); }",Here too we may use IanaLinkRelation.EDIT?,"why you creating new Link?, Link is a super of DetailedLink and should already have ref & rel, so (Link)link should do the job for you. btw: i'd rename /link/ parameter to /detailedLink/ as it a bit confusing","line 86, it's already a teamWf I'd just send the teamWf as a separate parameter and then use it in your method","The relationship should be ""userPhoto"". The curie is added by the HAL serialization.",The link member should be removed and this line may be replaced with:  java return this.baseStyleGuideLink + this.name;,Missing NLS,"I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.",Is this logging statement still required?,"What exactly makes you think it's unnecessary ? From what I understand step 4 is actually what happen most of the time (we almost never have interwiki links and in the context of a running XWiki instance you are on wiki mode). Seems to me you are over thinking this. You are not supposed to modify the logic of the method, just improve the codestyle.",No need to use UriBuilder,"![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private ""getEditUrl"" method. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AUnusedPrivateMethod)"
"public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = """"; mFloppyPath = """"; mRunAndPause = false; _diskSize = 0; }",coudl be just ArrayList since now it is imported ^^ vv,"Good, if there are no other places where it may be set to null. But I would rather fix the comparison.",maybe makes sense to refactor the CpuName to get/setCpuVerb and CustomCpuVerb?,Consider moving the static method to VmHandler,"I would .setOs(0); // 0 = Unassigned but I would do this if only relevant to unitests. however, in multiple places in the code you use IDs - please define constants for them in a single place (OsRepo?)","We will never get to this ""else"" section in code for both run & run-once actions since getVm().getCpuName() is set to NULL at this point when you start the VM (a VmDynamic property). So since you will never set host's cpu flags as required, the filter will always fail finding an appropriate host to run on.",please remove alias setting (should be encapsulated in addManagedDevice,Why this change?,"If above command is also doing DbFacade.getInstance(), why not reuse it?",why this was changed here and not in the master?,"consoleEnabled = Boolean.FALSE, you already did it in the default ctor"
"private void setCurentCommitInfo(String revision) { fCommitInfo.reset(); Iterator<Map.Entry<String, RevisionInfo>> itr1 = fRevisions.entrySet().iterator(); while (itr1.hasNext()) { Entry<String, RevisionInfo> entry = itr1.next(); if (entry.getKey().equals(revision)) { System.out.println(""Looking at the Current patchset : "" + entry.getValue().getNumber()); fCommitInfo.setCommit(revision); fCommitInfo.setMessage(entry.getValue().getCommit().getMessage()); fCommitInfo.setParents(entry.getValue().getCommit().getParents()); fCommitInfo.setAuthor(entry.getValue().getCommit().getAuthor()); fCommitInfo.setCommitter(entry.getValue().getCommit().getCommitter()); } else { System.out.println(""Looking at the other patchset : "" + entry.getValue().getNumber()); } } }",log,"You should still pass Integer.MAX_VALUE here to getBytes(). This is needed to allow opening a note that is large, like 12 MiB worth of text. These shouldn't happen, but if they do we should still make a good effort at displaying it. When the note is bigger than the default or the size passed here, we throw LargeObjectException. Maybe you want to trap it here and display a warning that the note is too big to display? And you might as well use getCachedBytes() too to avoid copying.",remove or log,"Interesting. This means that trying to build info/refs if there's a symref-to-unborn-branch other than HEAD would fail. For comparison, C git skips those unless GIT_REF_PARANOIA is set to 1 or true. This step comes after the actual push has occurred so it seems safer to skip the symref like C git does: if (objectId == null) { // Symrefs to unborn branches aren't advertised in the info/refs file. continue; }",should \r be in there?,"I'm not sure what other places in the CLI are doing with error handling, but System.err might be more appropriate than System.out here?",Should this method be private? Or protected? I don't see a need for package visibility.,"Why is this constructor public? If its to permit copying a Line (so an application can take a ""snapshot""), we should instead support some sort of copy constructor that takes a Line object, or a cloneLine() method that returns a copied Line object. Otherwise, I think this should be package-private. Only the BlameGenerator should need to construct a Line object.","This could be a big oneline summary. Maybe instead we do: StringBuilder message = new StringBuilder(); message.append(""Update notes for submitted changes\n\n""); for (CodeReviewCommit c : commits) { ... message.append(""* "").append(c.getShortMessage()).append(""\n""); }",add status.getConflicting() as 'unmerged'?,"I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>"
"public void testQueryProcessByVariables() { Map<String, Object> variables = Collections.<String, Object> singletonMap(""var_a"", ""a1""); Map<String, Object> attributes = Collections.<String, Object> singletonMap(""processId"", ""test.test_A""); List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext()); Assert.assertEquals(3, data.size()); for (ProcessInstanceWithVarsDesc p : data) { Assert.assertEquals(""a1"", p.getVariables().get(""var_a"")); Assert.assertEquals(""test.test_A"", p.getProcessId()); } }","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap","Number of instances matching search criteria ( processVariable = ""var_a"", ""a1"" ) are 3, or am I missing something?. If I change it to the following below, I get data size = 3 (which I presume it is correct): Map<String, Object> variables = Collections.<String, Object> singletonMap(""task_in_a1"", ""a1"");",I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.,"The sort order seems to be really reversed .... the variable is called asc, and when false, we're happy with values being in ... ascending order.","Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap",Renaming this method to constructDbObject would improve readability (I know it was like that before but still).,How would you get the next batch for pagination?,"why is this true, shouldn't it be false since neither of the attributes have a kind?",No need to throw Exception - never thrown in this method.,This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.,perhaps we could use assertj here ?
"void updateThreadPoolSize(int numThreads) { m_scheduler.setCorePoolSize(numThreads); LOG.info(""Updated PBD to use "" + numThreads + "" threads to enforce retention policy""); }",Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling,primitive (int) would be sufficient,"While I understand your question, I have no clue how this code is supposed to work even when there are no exceptions. What will be the difference for an event updating the heap resource and one the disk resource?",queueLength should be >= 0 or change the createExecutor(ThreadFactory threadFactory) to create a SynchronousQueue if queueLength <= 0,could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?,"suggestion throw new IllegalArgumentException(""maxPoolSize must be greater than corePoolSize"");","style nit: Line is too long, please insert a newline after ""="".",I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.,"As we create here a implementation of the ThreadPoolExecutor.DiscardPolicy class, shouldn't we add a logger to that implementation using the class it implements?","Is this is safe? I think the scheduled repeating trimming task could be run on an arbitrary thread, i.e. not necessarily the one from which it was scheduled that owns the referenced PoolThreadCache instance. Maybe for this one the scheduled task could just call PoolThreadCache.trimCurrentThreadCache()?","What's the difference between the if and the else part? Looks same to me. So if this really works in both cases, I'd change it to ...  threadPool.setMaximumPoolSize(dynamicMaximumSize); threadPool.setCorePoolSize(dynamicCoreSize);  :slightly_smiling_face:"
"protected void postProcessHeaderLines() { final List<String> headerLines = getHeaderLines(); final Pattern blankLine = Pattern.compile(EMPTY_LINE_PATTERN); for (final String line : headerLines) { try { if (line.isEmpty()) { headerRegexps.add(blankLine); } else { headerRegexps.add(Pattern.compile(line)); } } catch (final PatternSyntaxException ex) { throw new IllegalArgumentException(""line "" + (headerRegexps.size() + 1) + "" in header specification"" + "" is not a regular expression"", ex); } } }","please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.",Why LOG.trace?,"Replace for loop with addAll method example: public void makeCopies(String[] source) { this.array = Arrays.copyOf(source, source.length); Collections.addAll(this.list, source); }","please name it as line ,as term header we use for block of lines.",we don't need this anymore,regionMatches?,@pynicolas imo it's better to use while and rename i to currentIndex (but that's really imo :)),consider saving the value of group 1 and group 2 here rather than the whole matcher,Too broad a catch. IndexOutOfBoundsException should be enough.,"please keep there method with name 'shouldBeAloneOnLine' (only name not a logic), it is the same in naming form as others.",Unneccessary
"public void setActivePart(IAction action, IWorkbenchPart targetPart) { if(targetPart instanceof IMavenProjectHolder) { this.projectHolder = (IMavenProjectHolder) targetPart; } else { this.projectHolder = null; } }",I don't like IMavenProjectHolder. I think targetPart.getAdapter(MavenProject.class) is more appropriate here.,"This causes now editor not to open (sometimes) on BP hit if the debug view is hidden - all in a single window. Open Java perspective, start debugging, close editor, hide view, resume after few times editor is not opened...",In case of Multipage editor this will be called twice. Is this intended?,We still need to call to deactivateParticipants(),"This pattern is good, but you need to go up a level. So window.getWorkbench().addWindowListener(...) and on close remove the window action. You can probably add this listener once and manage all windows that way.","BTW this block is legacy code, predating QueueItemAuthenticator; I thought @ikedam had already cleaned the permission system in this plugin up, but perhaps there is still some junk left behind. At any rate, it should be a no-op for Workflow since this constructor is called during the build, when there is no active web request. (It can _also_ be called by the snippet generator, when there is, but then there will be no AbstractProject in the context-only a [Workflow]Job.",You should access static variables directly from MainWindow.KODEBEAGLE .,Do we need this method public ? The place where it's used is in the same package so protected/default should work ?,"This handler is at the application level. That means with multiple windows, you need to return the build action for that window and also add a window listener so that you can clear a window entry if that window closes.",Ideall in super constructor,Can we simplify this nested structure? At first do the check for null and open project explorer in this case. Next do the check 'instanceof' if active part is not null WDYT?
"private void parseConfiguration(Config config, FailureCollector collector) { if (!config.defaults.isEmpty()) { String[] defaultsList = config.defaults.split("",""); for (String defaultValue : defaultsList) { String[] defaultsArray = defaultValue.split("":""); if (defaultsArray.length != 2) { collector.addFailure( String.format(""Invalid default: %s."", defaultValue), ""Defaults should contain source field and its corresponding default "" + ""value in the format: <source-field>:<default-value>[,<source-field>:<default-value>]* "" + ""For example: lang_code:English,country_code:Britain"").withConfigElement(DEFAULTS, defaultValue); } else { defaultsMapping.put(defaultsArray[0], defaultsArray[1]); } } } String[] mappingArray = config.mapping.split("",""); for (String mapping : mappingArray) { String[] mappingValueArray = mapping.split("":""); if (mappingValueArray.length != 3) { collector.addFailure(String.format(""Invalid mapping: %s."", mapping), ""Mapping should contain source field, lookup table name, "" + ""and target field in the format: "" + ""<source-field>:<lookup-table-name>:<target-field>"" + ""[,<source-field>:<lookup-table-name>:<target-field>]* "" + ""For example: lang_code:language_code_lookup:lang_desc,"" + ""country_code:country_lookup:country_name"").withConfigElement(MAPPING, mapping); } else { String defaultValue = null; if (defaultsMapping.containsKey(mappingValueArray[0])) { defaultValue = defaultsMapping.get(mappingValueArray[0]); } ValueMapping valueMapping = new ValueMapping(mappingValueArray[2], mappingValueArray[1], defaultValue); mappingValues.put(mappingValueArray[0], valueMapping); } } collector.getOrThrowException(); }","indentation, here and rest of PR",So EncodeType eType = EncodeType.valueOf(type) will not work?,is incorrectly formed.,"When there's so many function calls within function calls, it gets hard to read. Break this up into 2 statements.",It should be possible to use DecompressorType.valueOf(type) instead of this switch case?,"Will never return Optional.absent(), since result is always non-null. Unwrap from Optional?","Maybe missing something between name and the errorMessage, such as space or some separator","Use ""JsonSerialization.readValue""","We really should define an order here. Right now you might get a random localized name, if I understand the code right. I suggest: housename, int, loc, reg, alt, old Also, note that again only NAME has other names than the default and localised ones. So a special handling of the name would be a good idea.",Made some changes for you:  Illegal key-value format. The value should be separated with a single : character.,"""NULL"".equals(lineValues[i]) || CSV_NULL.equals(lineValues[i])"
"public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(""eventData cannot be null.""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }",Replace with Objects.requireNotNull.,"This is out of scope of this PR but while you are modifying this file, could you also instead import the package and remove this fully-qualified class name?",Does this get overridden in the subtypes?,Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.,Never use getBytes() without setting the default locale. Please always pass <LINK_0> object into that function. Actually we have to check that we do not use cases where this stupid getByte() is done.,@imoldovan-intacct why not newcapacity >= this.buffer.capacity() ?,"Should make sure this aligns with the track 1 serialization code for a service bus message. iirc, it's different.",Can you use MediaType.PLAIN_TEXT_UTF_8 instead?,I think configurable makes sense,"this should be a ServiceException, since it'll be serialized as such.","Does this method have to be synchronized, considering that capacity is final?"
"private static void doAppendEscapedIdentifier(Appendable sbuf, String value) throws SQLException { try { sbuf.append('""'); for (char ch : value.toCharArray()) { if (ch == '\0') { throw new PSQLException(GT.tr(""Zero bytes may not occur in identifiers.""), PSQLState.INVALID_PARAMETER_VALUE); } if (ch == '""') { sbuf.append(ch); } sbuf.append(ch); } sbuf.append('""'); } catch (IOException e) { throw new PSQLException(GT.tr(""No IOException expected from StringBuffer or StringBuilder""), PSQLState.UNEXPECTED_ERROR, e); } }",I wonder if this change would result array allocation and extra cpu/memory consumption issues,I wonder if this change would result array allocation and extra cpu/memory consumption issues,"What if value contains both ' and "" ? Should the code fail?",nit: missing space after if. We also traditionally put null on the right.,"![CRITICAL](<LINK_0> The Cyclomatic Complexity of this method ""quote"" is 14 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>","I believe final can be removed. IDEA resource: As private methods cannot be meaningfully overridden, declaring them final is redundant.","this will replace CRLF to 2 blanks, is this intended ?","suggestion for (char i = SPACE; i <= TILDE; i++) {  Can you do that? Can remove need for casting below, and can make SPACE and TILDE chars.",there is already some escape method/utility/lib so take a look if this can be reused here,This could be made static,The name is now no longer accurate. Maybe don't replace the line delimiters inside this method.
"public void shouldScheduleDelayedActionOnHandlerThread() { Handler handler = mock(Handler.class); @SuppressWarnings(""unchecked"") Action0 action = mock(Action0.class); Scheduler scheduler = HandlerScheduler.create(handler); Worker inner = scheduler.createWorker(); inner.schedule(action, 1L, TimeUnit.SECONDS); ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class); verify(handler).postDelayed(runnable.capture(), eq(1000L)); runnable.getValue().run(); verify(action).call(); }",May be static imports for TimeUnit values here and below?,This assertion method is obscure. You shouldn't have to read the methods implementation to see what is being asserted.,Should this executor specify the Looper too?,Use: Looper.myLooper() == handler.getLooper(),The proper way is arguments[arguments.length - 1] instead of arguments[0].,Runnable's don't have checked exceptions and don't need this statement.,"@zxw1962 assert will not work in production, if you could change this to an actual if() statement it will be great.",assertEquals() instead of assert keyword :),"Is there anything we can assert to ensure that it actually works? Otherwise, this test will pass if I make withFunctionsWorker NO-OP","It was okay with the named class, we should be moving away from anonymous inner classes.","make this a constant, or make it static"
"public void aggregate(ByteBuffer buf, int position) { boolean countNulls = !selector.nameLookupPossibleInAdvance() || NullHandlingHelper.useDefaultValuesForNull(); MutableBitmap mutableBitmap = getMutableBitmap(position); IndexedInts row = selector.getRow(); for (int i = 0; i < row.size(); i++) { int index = row.get(i); if (countNulls || selector.lookupName(index) != null) { mutableBitmap.add(index); } } buf.putLong(position, mutableBitmap.size()); }",Similar to DistinctCountAggregator,new ValueMatcher[0] can be a static constant,"could initialize with cardinality of bits, e.g. List<Long> indexes = new ArrayList<Long>((int) bits.cardinality());","Could be cached, SingleIndexedInt.of() and cache 0-127 :)",Align logic and method order with double and float.,BooleanValueMatcher(false)?,"Can you add some more description on what ""name"" refers to here (relating to ObjectBinding), was a little confused when I first saw this","We should check if defaultValueRow.getColumn(i+1) is null or not, as the column's value may not be populated.","Please align the logic with double. And if there is just one method, it checks anyway and returns an optimized impl.","Could not happen, this block could be removed","Should this create an empty bitmap if only one of the dims has no values? Should the condition instead be that all dims have no values? e.g., what if the predicate is (dimA == null && dimB == 'X)?"
"private List<ModelNode> adjustInfinispan(final PathAddress subsystem) throws Exception { final List<ModelNode> list = new ArrayList<>(); list.add(getWriteAttributeOperation(subsystem.append(""cache-container"", ""server"").append(""transport"", ""jgroups""), ""stack"", new ModelNode(""udp""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""server""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""server"").append(""replicated-cache"", ""default""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""web""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""web"").append(""distributed-cache"", ""dist""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""ejb""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""ejb"").append(""distributed-cache"", ""dist""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""invalidation-cache"", ""entity""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""local-cache"", ""local-query""))); list.add(setStatisticsEnabledTrue( subsystem.append(""cache-container"", ""hibernate"").append(""replicated-cache"", ""timestamps""))); return list; }","Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0",We could add assertTrue to result of this operation ...,"If this println is removed, sb variable is is useless and can be removed too, right? Wouldn't be better to replace this println with LOGGER.trace?",i personally prefer lower case urls ie /debug/routeoverview **Done.**,"I don't think you want to call the super implementation, as you are handling capability registration conditionally.","I remember why I removed this line: it doesn't belong here, because configuring the SCI should be part of the test setup, and this method just clones an existing configuration and replaces some instances that are not safe to reuse. A better solution IMO would be to only put it where it's needed, in this case in BaseSiteUnreachableTest.createSites()","From look in GitHub UI, this one seems to be unused?","The reject xml should not use statistics-enabled=true, and this should be added as a failed attribute in the relevant cases.","I don't think you want to call the super implementation, as you are handling capability registration conditionally.",RuntimeException?,"Instead of WRITE_ATTRIBUTE_OPERATION, should not be used opName here?"
"EventBus eventBus() { EventBus bus = new EventBus((exception, context) -> exception.printStackTrace()); bus.register(new DeadEventHandler()); return bus; }",printStackTrace() must not be used. Use a logger instead.,Better to log instead of e.printStackTrace,Should this be System.err instead?,Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,This is printed out once on class loading? We can prettify later.,remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.,Please extract toJson(Event) into a variable. We use it in both if branches.,should we add a more detailed log and set currentProductVersion to null,"Cool, didn't know about DeadEvent. When you switch to slf4j, make sure to use playerholders {} instead of string concatenation and follow the [logging format guidelines](<LINK_0>",why is required?,"I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: ""nonNullString"".equals(nullableString) instead of nullableString != null && nullableString.equals(""nonNullString"") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ..."
"ObjectLoader openPackedObject(WindowCursor curs, AnyObjectId objectId) { PackList pList; do { pList = packList.get(); SEARCH: for (;;) { for (PackFile p : pList.packs) { try { ObjectLoader ldr = p.get(curs, objectId); if (ldr != null) return ldr; } catch (PackMismatchException e) { PackList nList = scanPacks(pList); if (pList != nList) { pList = nList; continue SEARCH; } } catch (IOException e) { removePack(p); } } break SEARCH; } } while (searchPacksAgain(pList)); return null; }",I think this could just be: if (searchPacksAgain(pList)) continue SEARCH;,Same as above: could use searchPacksAgain,You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.,I think this could be Integer.valueOf(entry.getType()) to fix the warning.,why not use the field directly ?,Also include the values here?,"Is there a way to ""track"" the number of consecutive failed attempts to open that pack file?",Yea I agree that is premature optimization. Lets avoid something that ugly unless data shows this is a horrible source of garbage that has to be fixed.,"This seems unnecessary. The caller invokes us once on an empty set, and then again only if matches.size() < MAX_RESOLVE_MATCHES so we shouldn't need this redundant check.",I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate,same nit about 'final' (and likewise below)
"public void bufferExactFailingSupplier() { Scheduler.Worker w = new TestScheduler().createWorker(); TestSubscriber<List<Integer>> observer = new TestSubscriber<List<Integer>>(); FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>> buf = new FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>>(observer, ArrayListSupplier.<Integer>asCallable(), 100, TimeUnit.MILLISECONDS, 10, false, w); buf.onError(new Throwable()); buf.onComplete(); }","The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;","The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;",minor: can be final,"this is currently not working I guess, but it will if we don't wrap in RuntimeException",Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes),"Not sure if it tests ""immediately"", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?","I'd instead throw TestException(""Forced failure"") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, ""Forced failure"");","Why not assertFailure(MissingBackpressureException.class, 1) to make sure 1 got through.",Bump all the numbers,assertEquals() instead of assert keyword :),"Any reason why we can't pass 1 to thread.join()? At this point, the test either completed (in which case this should return right away) or the test timed out (in which case the thread will likely take more than 100ms to exit). Waiting extra time just makes the test run longer. In fact, maybe we shouldn't call join at all. thread.join() can throw InterruptedException."
"private Image getImageForDraw() { if (sprite.look.getLookData() != null) { if (sprite.look.getLookData().getCollisionInformation().getLeftBubblePos() == null || sprite.look.getLookData().getCollisionInformation().getRightBubblePos() == null) { sprite.look.getLookData().getCollisionInformation().loadOrCreateCollisionPolygon(); } CollisionInformation collisionInformation = sprite.look.getLookData().getCollisionInformation(); Pair<Integer, Integer> bubblePosRight = collisionInformation.getRightBubblePos(); Pair<Integer, Integer> bubblePosLeft = collisionInformation.getLeftBubblePos(); imageLeft.setX(calculateLeftImageX(bubblePosLeft.first)); imageLeft.setY(calculateImageY(bubblePosLeft.second)); imageRight.setX(calculateRightImageX(bubblePosRight.first)); imageRight.setY(calculateImageY(bubblePosRight.second)); } else { if (drawRight) { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() + (sprite.look .getWidthInUserInterfaceDimensionUnit() / 2)); } else { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() - sprite.look .getWidthInUserInterfaceDimensionUnit() / 2 - image.getWidth()); } image.setY(sprite.look.getYInUserInterfaceDimensionUnit() + (sprite.look .getHeightInUserInterfaceDimensionUnit() / 2)); } return image; }",I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction(),Should different aspect ratios be considered here as well?,Shouldn't this have the log level ERROR? <naming,"Any chance-even if remote-that rowsPerStrip could be zero? One of the reasons why 1.0-alpha1 took so long (couple years after the work started?) was largely due to CVE's created for sanselan. One of the CVE, if I am not mistaken, was about a division by zero (or another sort of arithmetic error?), that caused an exception and some infinite loop or large memory allocation (allowing users to perform DDOS). If it's never zero, then no need to worry. Otherwise, if there's any risk, better set a quick validation somewhere (here or constructor).",Indeed IllegalArgumentException is an unchecked exception. You should remove it from the method signature.,"Are you sure the if...else transformation is correct here? I think it will only hold true for the same axis, and you could have, say, moving the position in both the Y and Z axis.",there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same,"LGTM in general. There might be performance/less memory consumption gain by declaring Color pixelColor outside of the loops and then just updating it, however I'm not sure about it - maybe it is optimization that JVM is able to do itself. Not a merge blocker in my opinion.",Current assumption why we see some missing parts in WS is that we should apply the current transform to the clipping before we intersect it with requested one. We are investigating in this direction.,"Is there a reason for this short circuit? I know I'm probably nit-picking here, but I feel that this would be ""slower"" than not having it, due to extra complexity preventing JVM optimisations.","probably miss the ""!"" . it makes no sense to ""continue"" if camera exists."
"public static User toUser(DecodedJWT jwt) { final String subject = jwt.getSubject(); final List<Role> roles = jwt.getClaims().entrySet().stream() .filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) .map(entry -> { final String roleName = entry.getKey(); final Claim claim = entry.getValue(); final List<Permission> permissions = claim.asList(String.class).stream().map(Permission::valueOf).collect(Collectors.toList()); return new Role(roleName.substring(roleName.indexOf(""_"") + 1, roleName.length()), permissions); }).collect(Collectors.toList()); return new User(subject, roles); }","You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,","If the application sets the authorities claim name, then there is no need to search for it. Did you run into difficulties with something more like: java if (this.authoritiesClaimName != null) { return this.authoritiesClaimName; } for (String claimName : WELL_KNOWN...",return List.of(new SimpleGrantedAuthority(getUser().getRole().getShortName())),Please remove diagnostic modifications before merging.,inline permissions and then remove redundant this,Please move this method just below getClaims(),"To conform with our team standard, would you please prefix the field with this.?",should be aliases,s.a.,let's rename this too.,"You can use ArrayList constructor instead of going through stream. java new ArrayList<UserDTO>(users)  Second point. I know it was already there, but peek is intended mainly for debugging. Map would be much clearer. java .map(e -> e.users(new ArrayList<>(users)));"
"public void readInfo() { this.mvnInfo = null; this.mvnName = null; if (!infofile.exists()) { return; } try { final String content = FileUtils.readFileToString(infofile, Charsets.UTF_8); final int i = content.indexOf(','); LOGGER.log(Level.FINE, ""The "" + name + "" artifact info cached is: "" + content); if (i != -1) { this.mvnInfo = content.substring(0, i); this.mvnName = content.substring(i + 1); } else { LOGGER.log(Level.WARNING, ""The "" + name + "" artifact info is invalid""); } } catch (IOException e) { LOGGER.log(Level.WARNING, ""The "" + name + "" artifact info failed to be loaded"", e); } }",you can use parameterized logging here,"Suggest:  version = value.replaceAll(""BUILD-SNAPSHOT"", ""SNAP"").replaceAll(""-RELEASE"", """");","Please use a instance-variable for the version, this way we can configure it for each service instance separately. Also extend the service-descritor to support the version-field (and add a default-value)",Do no-op if version is already set in another thread. java if (version.get() != null) { return; },Would be more readable with static import.,"Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.",unused,"I don't think null can ever be returned, so this if may be redundant.","This is a bug in the build system, not the code.",Optional<String> ?,url should be checked for null.
"private void refreshSignedOffBy() { String curText = commitText.getText(); if (signedOff) { commitText.setText(signOff(curText)); } else { String s = getSignedOff(); if (s != null) { curText = replaceSignOff(curText, s, EMPTY_STRING); if (curText.endsWith(Text.DELIMITER + Text.DELIMITER)) curText = curText.substring(0, curText.length() - Text.DELIMITER.length()); commitText.setText(curText); } } }",Style nit: unneeded curlies,"please break this method into smaller methods to make it more readable. E.g.: private String getValign() { if (getVerticalAlignment() == SwingConstants.CENTER) { return ""middle""; } else if (getVerticalAlignment() == SwingConstants.BOTTOM) { return ""bottom""; } return ""top""; }",style nit: we don't use braces around single line blocks,could be made static,"Shouldn't we use StringUtils.defaultString() here, like elsewhere?",this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?,"Since this section is being shared between this method and the setAuthorAttributionText() method, it might make sense to create a local private utility method to do it, that would be invoked from both of these methods.",I believe the Sanitizer call is not needed here.,we have a method in the OS class which already returns the system line separator,emptyTextView can be made View.GONE?,text != null is on the wrong side of && operator.
"public void put(String key, String value) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); ops.set(value); }",this.redisTemplate,this.redisTemplate,Need it be public?,checkValue,UnsupportedOperationException ?,You have missed oldValue in the criteria. See the replace contract in the ConcurrentMap.replace,might change to assertEquals ?,throw new UnsupportedOperationException,am i missing something this seems like a duplicate method call.,Made some changes for you:  Illegal key-value format. The value should be separated with a single : character.,I think this is the same as this.newValue = newValue; ??
"public ResponseEntity<?> createDilution(@RequestBody DilutionDto dilutionDto, UriComponentsBuilder b) throws IOException { if (dilutionDto == null) { log.error( ""Received null dilutionDto from front end; cannot convert to Dilution. Something likely went wrong in the JS DTO conversion.""); throw new RestException(""Cannot convert null to Dilution"", Status.BAD_REQUEST); } Long id = null; LibraryDilution dilution; try { dilution = Dtos.to(dilutionDto); dilution.setLibrary(libraryService.get(dilutionDto.getLibrary().getId())); id = populateAndSaveDilutionFromDto(dilutionDto, dilution, true); } catch (ConstraintViolationException e) { log.error(""Error while creating dilution"", e); RestException restException = new RestException(e.getMessage(), Status.BAD_REQUEST); restException.addData(""constraintName"", e.getConstraintName()); throw restException; } UriComponents uriComponents = b.path(""/library/{id}"").buildAndExpand(dilution.getLibrary().getId()); HttpHeaders headers = new HttpHeaders(); headers.setLocation(uriComponents.toUri()); headers.set(""Id"", id.toString()); return new ResponseEntity<>(headers, HttpStatus.CREATED); }",fetch should already happen in Service,"Since the creator isn't modifiable, it doesn't need to be loaded from the database for an update. (It'll already be fully loaded in the managed dilution [here](<LINK_0> ).","It's probably the same, but shouldn't be comparing dilution's ID to AbstractLibrary's",RestExceptions already get logged,"We could add also the identifier and the exception message, as it is not very useful.",entity,"Should attach the logged AppUser to the Loan Entity, and also check if Counterparty is already attached to the entity",This will cause creator to change on every update,"suggestion String errorMessage = ""Error while updating label : "" + labelId;","Please add the Identifier of the Contentlet, for troubleshooting purposes.",Does this have to be public and declared in the interface? It seems like it should only be called by the create and update methods in this class - especially for create since save will fail if no name has been generated
"public void start(SocketAddress endpoint) throws IOException { if (isListening()) { throw new IllegalStateException(""Cannot start when already listening for messages""); } bindToAddress(endpoint); new Thread(() -> { while (!configServerSocket.isClosed()) { acceptConnection(); } }, ""configurationListener"").start(); }",thread.isUnterupted not necessary?,You'll want this to be fail.getAndSet(true) in order to get the benefits.,"Code isnt compiling right here - an extra ""f"" at the start is throwing things off.",we can take a change to print the socket#toString result here,"This could use some localization. Even original code should have it. Looking at it, also message is wrong, as this code handles all listeners not only http ones. Could you look into this?",why do you need both 'if' and 'while' with the same condition ? why isn't the 'while' loop enough ?,why we need to move code block **Line650-Line652** to code block **Line665-Line667** ?,Code style: please use brackets,"Could you wrap the acceptedChannels.remove() into a method? It would be a cleaner way. I think, the !success check is not needed here - the remove will take care of it (i.e. we want to remove it in either case). If the connectionManager.newConnection() implementation is changed in a future and it doesn't remove the channel, this would be a guard.","IMHO it depends if a a closed socket is the only reason for an IOException. Do you know if it is the only one? If it is not the only possible reason, we should check if the exception is an instance of java.net.SocketException and if the socket is closed. In this case we can use debug level or not logging anything. If there are other cases and it is not a closed socket, we should keep level error. WDYT?",Printing to stdout doesn't guarantee that the stacktrace is shown with the failure logs? How about: fail(printStacktraceToString(e)); where printStacktraceToString a helper function like the one in ThrowableTest - there might even be a general one in libcore? (I'm not 100% sure if there's any assert*() overload that takes a Throwable/Exception).
"public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(""Launch batch job (makeUnique=false) twice""); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + "" --makeUnique=false""); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + "" --makeUnique=false"", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(""job launch --name "" + MY_JOB); System.out.println(""*************************"" + result.getException().getMessage()); assertThat( result.getException().getMessage(), containsString(""A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters."")); }",I assume this was meant to be removed?,@marchof I'm wondering why in case of invalid command exit code is still zero?  $ java -jar jacococli.jar test $ echo $? 0,looks like this was meant to be print() not println()...,Should probably be an assert here?,How about displaying the values that were set in the UIInputMany?,This is fragile. Something like ExecutorTest.BlockingBuilder should be used.,I think you need to handle windows new lines as well,"""robot explain --input <file> --axiom <axiom> --output <output>""  Default reasoner should is ELK (returned by CommandLineHelper.getReasonerFactory(...)) so the user wouldn't need to specify that. Maybe make a note in the docs? And if you link to the reason docs, they can see all available reasoners.","In both instances, the string should be on the LHS of the equation.","some issues with indentation ? "" should be alligned",This might be always true.
"public List<GenericVertex> resolve(GraphService graphService, SearchCriteria searchCriteria) { GenericGraph graph = graphService.getGraph(searchCriteria.getNamespace()); return graph.getVertices() .stream() .map(ApplicationVertex::new) .filter(v -> filter(v, searchCriteria.getCriteria())) .map(ApplicationVertex::asGenericVertex) .collect(Collectors.toList()); }","What do we do, if the result is null?",Should use constants here instead,Shouldn't this be a field so we don't have to create one each time,"I'm usually not a fan of static imports except for this, I usually static import StreamUtils.stream but doesn't matter to much to me","This method is called on every operation call for which IMHO a string concatenation may be too expensive. The cache API allows the usage of Object keys, thus you could use a single object (or a Pair of class+helper.getCalledQuery) instead.","hmm, shouldn't this be at most 1 vertex? Since the quicksearch vs Id functions aren't the same signature anyway we might return just an Optional<vertex> instead of a GraphTraversal.",Add active filter and return only the ID and CONCEPT_ID fields.,Is there a particular reason to not use java.util.HashMap?,should be not equal to version_of,i just started to merge this and i think that change might have been an artifact from your rebase at some point as i see that style in tp34. sorry about making you change that. i will probably go back and add that change to tp33 after this merge is done.,I don't think this is necessary for the test is it? Vertex is just a token. You should be able to pass mock(Vertex.class) This code suggests a dependency to readers of the test and it makes changing the database model a bit harder (cause we have to change this test as well)
"protected Location manageRecursive(Location loc, final ManagementTransitionMode initialMode) { AccessController.Response access = managementContext.getAccessController().canManageLocation(loc); if (!access.isAllowed()) { throw new IllegalStateException(""Access controller forbids management of ""+loc+"": ""+access.getMsg()); } if (log.isDebugEnabled()) { String msg = ""Managing location "" + loc + "" (""+initialMode+""), from "" + Tasks.current()+"" / ""+Entitlements.getEntitlementContext(); long count = LOCATION_CNT.incrementAndGet(); if (count % 100 == 0) { log.debug(msg, new Exception(""Informational stack trace of call to manage location ""+loc+"" (""+count+"" calls; ""+getLocations().size()+"" currently managed)"")); } else { log.debug(msg); } } recursively(loc, new Predicate<AbstractLocation>() { public boolean apply(AbstractLocation it) { ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId()); if (mode==null) { setManagementTransitionMode(it, mode = initialMode); } if (it.isManaged()) { if (mode==ManagementTransitionMode.CREATING) { return false; } else { } } boolean result = manageNonRecursive(it, null); if (result) { it.setManagementContext(managementContext); if (!mode.isReadOnly()) { it.onManagementStarted(); recordLocationEvent(it, Lifecycle.CREATED); } managementContext.getRebindManager().getChangeListener().onManaged(it); } return result; } }); return loc; }","I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.",Is RebindManagerImpl ever be used with a NonDeploymentManagementContext? This will throw an NPE if it yes. Safer to return an empty iterable.,"Use the ""Unspecified Location"" constant in Middleware",I'd use containsKey(id) in preference,"This should at a minimum restore the thread's interrupted status with Thread.currentThread().interrupt(). Throwing an exception is typically poor form, but it depends on the thread's context. There is a chapter in Effective Java with specifics if you are interested.",rlly nit-picky: would turn that around from: is our location precise and do we actually have one to do we have a location and is it precise,Not using Singles here?,"Instead of hardcoding 300 here, could you reference the variable defined elsewhere (I think) for the Get Ready notification?",Should this really be ll.getAllConfig(true) for LOCAL_EXCLUDING_SECRET? Will that not include inherited as well?,nit: you could skip this announcement if details.location was already same as location.,Why is this null checking before requesting locations? I would think it's ok to request new locations even if we didn't have a last known location in the GPS provider.
"void start(int slot) { mSlot = slot; int error = isValid(); if (error == SUCCESS) { Log.d(TAG, ""Starting keepalive "" + mSlot + "" on "" + mNai.name()); switch (mType) { case TYPE_NATT: mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; case TYPE_TCP: mTcpController.startSocketMonitor(mFd, this, mSlot); mNai.asyncChannel .sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0 , mPacket); mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; default: Log.wtf(TAG, ""Starting keepalive with unknown type: "" + mType); } mStartedState = STARTING; } else { handleStopKeepalive(mNai, mSlot, error); return; } }",Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?,"Usually (especially for loop conditions) I like this style but in this case this is a mask, so if we ever go up to the top bit this becomes broken unexpectedly. Let's use == instead.","This is called twice, could that be your issue?",reduce to debug,maybe put this in else {} ? Not very important because the messages will be removed in exit() anyway,@luyangco Why the handler is always ClientInputHandler in the PG branch?,reduce to debug,Consider putting UID and PID before the packet data which is very long.,"Please define resultcode before using it. int resultCode = intent != null ? intent.getIntExtra(""result"", 0) : 0;",reduce to debug and pass the message on to closeConnection to update the Thing status accordingly.,You can reference upstreamWanted() related code which is currently use for local only hotspot to skip forwarding.
"public NewTmfViewAction(TmfView view) { super(MessageFormat.format(Messages.TmfView_NewTmfViewNameText, view.getTitle().toLowerCase()), IAction.AS_PUSH_BUTTON); setToolTipText(MessageFormat.format(Messages.TmfView_NewTmfViewToolTipText, view.getTitle())); }",I think we always display view names capitalized to users.,Should this be String.valueOf or is cnn the way to go?,"yeah, this was a rush patch to get the -2 issues out of the way. I didn't have time to look at code quality yet","As mentioned below, here I would reshuffle the entries in hierarchical order. You have to go through each trace separately using: for (ITmfTrace trace : TmfTraceManager.getTraceSet(getTrace())) since each trace has its own state system and corresponding entry list.","I am thinking that enabling/disabling these UI components would be better than hiding/showing them. I'm thinking this primarily because we have had problems in the past with layout when components come and go, which seems especially appropriate here, where future additions are likely. Also, having the disabled but visible components lets the user know that there exists the possibility of adding a translation service. Perhaps even someone will be motivated to provide such a service in the open source world.",This creates a deprecated warning. Why not using non-deprecated API?,"Is it a good idea to do file I/O on the UI thread? I love the way you've componetized this HTML blob but I think it would be better in strings_no_translate.xml or strings_view_description_edit_help.xml if you don't want it translated. That said, I think we will want to translate these strings so maybe a template string in strings_no_translate and placeholders in strings.xml?","This kind of verbage is full of some dangerous assumptions about the nature of the language involved. If we were in a right-to-left language this would be really confusing to put together. Two options that might help: 1) Use the localization keys to do the construction, IE: Localization.get(""cancelling.title"", new String[] {titleText}) where cancelling.title=Cancelling: ${0} or something similar. Alternatively, you could only use the message view for the cancel message (although I'd put the ""..."" in the message itself for the same reason)",probably should have a cdt in there. How about: org.eclipse.cdt.debug.ui.toolbar.openNewView,Use Timber for printing exceptions,We can use the getTitleView function here instead.
"public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(""message must be non-empty""); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(); } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }",Unrelated change. Should be in a separate commit.,"This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.","Do we need this? Before it was InvalidChangeOperationException, so the message was useful to distinguish what the error was. But now it's UnchangedCommitMessage, which is already descriptive of the exact problem. Or, rather than passing in the message here, put it in the constructor itself?","This is now frozen to server startup (or first rebase request). It should always be ""now"".",Assert in.range and in.line make sense.,Unnecessary delta.,new OrmException(e),When do you need to create an edit ref with no changes? Why not just create the ref on the first modification?,never thrown?,"Optional: ""patch set""",Would it perhaps be better to require the psid in the message constructor to prevent any future coders from not adding one?
"public CompletableFuture<Snapshot> copyTo(FileWrapper target, UserContext context) { ensureUnmodified(); NetworkAccess network = context.network; SafeRandom random = context.crypto.random; Hasher hasher = context.crypto.hasher; if (! target.isDirectory()) { return Futures.errored(new IllegalStateException(""CopyTo target "" + target + "" must be a directory"")); } return context.network.synchronizer.applyComplexUpdate(target.owner(), target.signingPair(), (base, committer) -> { return target.hasChildWithName(base.get(target.writer()).props, getFileProperties().name, network).thenCompose(childExists -> { if (childExists) { CompletableFuture<Snapshot> error = new CompletableFuture<>(); error.completeExceptionally(new IllegalStateException(""CopyTo target "" + target + "" already has child with name "" + getFileProperties().name)); return error; } if (isDirectory()) { byte[] newMapKey = random.randomBytes(32); SymmetricKey newBaseKey = SymmetricKey.random(); SymmetricKey newWriterBaseKey = SymmetricKey.random(); WritableAbsoluteCapability newCap = new WritableAbsoluteCapability(target.owner(), target.writer(), newMapKey, newBaseKey, newWriterBaseKey); SymmetricKey newParentParentKey = target.getParentKey(); return pointer.fileAccess.copyTo(base, committer, pointer.capability, newBaseKey, target.writableFilePointer(), target.entryWriter, newParentParentKey, newMapKey, network, random, hasher) .thenCompose(updatedBase -> { return target.addLinkTo(updatedBase, committer, getName(), newCap, network, random, hasher); }); } else { return base.withWriter(owner(), writer(), network).thenCompose(snapshot -> getInputStream(snapshot.get(writer()).props, network, random, x -> {}) .thenCompose(stream -> target.uploadFileSection(snapshot, committer, getName(), stream, false, 0, getSize(), Optional.empty(), false, network, random, hasher, x -> {}, target.generateChildLocations(props.getNumberOfChunks(), random)))); } }); }); }",this may impact web-ui code. Do we want to expose Snapshot in API?,Drop the 'you' from start of sentence. Use 'Unable to rename..',maybe current or latest is a better name than finished?,You shouldn't call onXXX methods while holding a lock.,Please change the name of scheduler to something like currentScheduler in order to avoid that someone mistakes it for this.scheduler.,"We can close the scope as soon as we are done with it to reduce indentation hell. here, line 593.",You shouldn't call onXXX methods while holding a lock.,"If it's theoretically possible that ISPN might call these methods more than once (for a given transaction), then the implementation needs to do more than just ensure synchronized access to the methods: it needs to ensure the methods have an effect only once, the first time each method is called.",Uncomfortable with ignoring qc==null - I think we should tell the caller that this method did not do as they expected by throwing exception. Similar to Preconditions.checkNotNull in others.,I think we should null _callback whenever we take it.,It makes sense for this method to be boolean. I am not sure we should be throwing an exception here. The caller can decide that based on the return value.
"public void testBlogPosting() { onView(withText(""Log In"")) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserEmail), closeSoftKeyboard()); onView(withText(""Next"")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.login_enter_password)) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserPassword), closeSoftKeyboard()); onView(withText(""Next"")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(""Continue"")) .perform(click()); onView(withId(R.id.viewpager_main)) .perform(ViewPagerActions.scrollToFirst()); onView(withId(R.id.fab_button)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.title)) .perform(replaceText(""Hello""), closeSoftKeyboard()); onView(withId(R.id.aztec)) .perform(replaceText(""World""), closeSoftKeyboard()); onView(withId(R.id.menu_save_post)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.promo_dialog_button_positive)) .perform(click()); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(R.string.uploading_post)).inRoot(new ToastMatcher()) .check(matches(isDisplayed())); }",This seems to fail the test when SmartLock for Passwords pops up the dialog for selecting a saved email/pass combination.,"Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.","Should we log this to TRACE at least? Just in case we need to see this happening? As long as any formatting happens in varargs / parameters, we can avoid the cost of formatting a string in case TRACE is turned off.","As you noted this should be resolved once we're mocking the network requests, but for now this sleep is causing the test to fail for me. The upload happens faster on my end and so by the time the test moves on the snackbar is already gone from the screen. I'm hesitant to spend too much time on fixing this as-is since we plan to set up mocking before we start really using these tests, though.","30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.",I would use LOG.error here,- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.,Maybe use an uppercase in the text: 'Thread sleep was interrupted'.,"This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.","FYI, TimeUnit.SECONDS.sleep(seconds.longValue())","LoggerUtils.logErrorWithStackTrace(LOG, e.getMessage(), e) ?"
public void placeOnTop(Node pNode) { assert pNode != null; if( aType == DiagramType.SEQUENCE && pNode.getClass() == CallNode.class ) { return; } if( pNode.hasParent() ) { Node parent = pNode.getParent(); parent.placeLast(pNode); placeOnTop(parent); } else if( containsAsRoot(pNode) ) { removeRootNode(pNode); addRootNode(pNode); } },"CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.",I would suggest moving pNode.getClass() == PointNode.class before the for loop,"Shorter that way: return ifNode.hasDirectChildren(PuppetGrammar.ELSEIF_STMT, PuppetGrammar.ELSE_STMT);","This doesn't check that the IIFE is an expr-result. Does that matter, or do you want to do this optimization for all iifes?",The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.,suggestion return (node.access & Opcodes.ACC_SYNTHETIC) == Opcodes.ACC_SYNTHETIC);,chields?,"Not sure, whether that's a bug or not. It probably just evolved in that way and now it is that way - this/super probably have been integrated later into the grammar. I've added a note to #1019 as changing this would break a lot of things... so for now we need to live with it, but we can change it for 7.0.0.","Use an interface instead of a concrete class. Same below. Space is missing before ""else"".",Use IASTUnaryExpression instead of CASTUnaryExpression.,"Rather than child, let's call the loop variable statement to make it a bit clearer what it represents."
"public int[] downloadSetupConfigurationTemplate(String uuid){ int[] result = new int[2]; try { SetupConfigurationTemplate setupConfigurationTemplate = setupConfigurationController.downloadSetupConfigurationTemplate(uuid); result[0] = SyncStatusConstants.SUCCESS; if(setupConfigurationTemplate != null) { result[1] = 1; } System.out.println(""MuzimaSyncService: ""+setupConfigurationTemplate.getConfigJson()); setupConfigurationController.saveSetupConfigurationTemplate(setupConfigurationTemplate); } catch (SetupConfigurationController.SetupConfigurationDownloadException e){ Log.e(TAG, ""Exception when trying to download setup configs""); result[0] = SyncStatusConstants.DOWNLOAD_ERROR; } catch (SetupConfigurationController.SetupConfigurationSaveException e){ Log.e(TAG, ""Exception when trying to save setup configs""); result[0] = SyncStatusConstants.SAVE_ERROR; } return result; }",Replace with logger,Replace with logger,"I don't like this change. Having a switch statement for an enum that does not cover all enum constants is an error in my book. Consequently, the code should remain unchanged.",you may return the ExitCode instead,+1 for SystemClock.elapsedRealTime().,"Don't we want to keep consistency - either use "":"" or use "","" at FAILED and SUCCEEDED messages?",<LINK_0>,Formatting,let's use tiles names that are specific for transformations; not just failure and success,inline to its declaration.,Same here. Should likely be DataVersions.Potions.CURRENT_VERSION
"public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); if (orientation != newConfig.orientation) { try { orientation = newConfig.orientation; getFragmentManager().beginTransaction().remove(this).commit(); getFragmentManager().beginTransaction() .replace(R.id.cover_fragment_container, CoverFragment.class.newInstance()) .commitAllowingStateLoss(); } catch (Exception e) { Log.e(TAG, ""onConfigurationChanged "" + e.toString()); } } }",I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?,"I don't think that you need this, since your NoteEditFragment.getNote() saves the note automatically, when called (I don't like this, but that's how it's currently works).","This forbids moving lightweight tags, and keeps the overwrite button disabled. This should be improved; it's very strange that I can move annotated tags but not lightweight tags. Command-line git allows me to move a lightweight tag with git tag -f myLighweightTag <commitId>. I see no reason why TagOperation shouldn't be able to move a lightweight tag?",Can this be within the if statement above?,"To keep same format, could we use Timber.e(message) ?",This isn't immediately obvious to me. Why are we only clearing the field on landscape mode? Wouldn't it be whenever the orientation changes?,"This is fine, but if we ever need two kinds of cases (one where we add to back stack and one where we don't then let's change this class to take that as a boolean parameter.",can you remove this try/catch? it could cause the sample app to get in a weird state,"Pass an array instead of typing colors here. Like this  <resources> <array name=""swipeRefreshColors""> <item>@color/pink</item> <item>@color/green</item> </array> </resources>   swipeRefreshLayout.setColorSchemeColors(getResources().getIntArray(R.array.swipeRefreshColors));","You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)",This is nicely simpler!
"protected void serviceStart() throws Exception { super.serviceStart(); if (UserGroupInformation.isSecurityEnabled()) { delegationTokenManager.startThreads(); } InetSocketAddress connectAddress = NetUtils.getConnectAddress(this.heartbeatListener.getAddress()); URI connectUri = RecoverableRpcProxy.toConnectURI(connectAddress); FSRecoveryHandler recoveryHandler = new FSRecoveryHandler(dag.assertAppPath(), getConfig()); recoveryHandler.writeConnectUri(connectUri.toString()); try { org.mortbay.log.Log.setLog(null); } catch (Throwable throwable) { } try { Configuration config = getConfig(); if (SecurityUtils.isStramWebSecurityEnabled()) { config = new Configuration(config); config.set(""hadoop.http.filter.initializers"", StramWSFilterInitializer.class.getCanonicalName()); } addSSLConfigResource(config); WebApp webApp = WebApps.$for(""stram"", StramAppContext.class, appContext, ""ws"").with(config).start(new StramWebApp(this.dnmgr)); LOG.info(""Started web service at port: "" + webApp.port()); appMasterTrackingUrl = NetUtils.getConnectAddress(webApp.getListenerAddress()).getAddress().getCanonicalHostName() + "":"" + webApp.port(); if (ConfigUtils.isSSLEnabled(config)) { appMasterTrackingUrl = ""https://"" + appMasterTrackingUrl; } LOG.info(""Setting tracking URL to: "" + appMasterTrackingUrl); } catch (Exception e) { LOG.error(""Webapps failed to start. Ignoring for now:"", e); } }",Sounds like a workaround for host misconfiguration issue.,"if you find that this is too late, consider moving to for example after line 208?",Use constants,Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());,I think we can remove this line.,It will bind the filter only to an app context you are trying to bootstrap here. To make it work you should bind this filter to every single http client in Presto core. This is totally different Guice context. And i'm not sure if it is available from inside of a plugin.,Can we combine these two 'if' into one?,"what happened here? For OpenSsl, we don't do warmup?",this should re throw as a RuntimeException,"would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/ .... maybe make the test do foreach(String zk : new String[]{""localhost"", ""localhost/"", etc}",Why not just modify the existing SeleniumHttpInitializer to accept a null sslCtx and have it only add the SSL handler if the value is not null?
"protected void executeVdsBrokerCommand() { String storageDomainId = getParameters().getStorageDomainId().toString(); List<String> deviceList = getParameters().getDeviceList(); String[] deviceArray = deviceList.toArray(new String[deviceList.size()]); boolean isForce = getParameters().isForce(); boolean supportForceCreateVG = Config.<Boolean> getValue( ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString()); _result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray); proceedProxyReturnValue(); setReturnValue(_result.uuid); }",Could you please rename also _result?,"Use the foreeach syntax, it's be more readable",weren't you going to inject this?,Do you want to update the database while retrieving this data here? or leave it to the sync job?,There is not stop happening here at all. Only status!!,how does this help? this class is not a singleton,Could you please rename also _result?,Shouldn't the name of the meta-volume be a parameter to vdsm?,"setReturnValue can be Guid? As the snapshot entity is not populated apart from Id, so is there any need in returning this?","Please pay attention if runVdsCommand will fail, exception will be thrown, so returnValue.getSucceeded() never will be false and the line 284 will not be executed",What is the purpose of this statement?
"public boolean addNextEvent(final MistEvent event, final Direction direction) { if (operatorChainManager != null && queue.isEmpty()) { operatorChainManager.insert(this); } return queue.add(new Tuple<>(event, direction)); }",I think it would be good to perform this logic in OutputEmitter.,Why didn't the sharedLock used in here but did used in addNextEvent?,Why synchronised here? The previous code already synchronized and also checked if it is ready and the queue is empty.,"throw new IllegalStateException(""Current thread "" + Thread.currentThread().getName() + "" is different from the operator thread "" + operatorThread.getName());",I think there is a concurrency issue. Multiple threads can insert the same query in this line and DefaultOperatorChainImpl 145 line.,The lines 185-191 are same as 167-171,"Why do we compare event timestamp and watermark timestamp? Is it not enough to compare only the watermark timestamps? (ex. Math.min(leftWatermarkTimestamp, rightWatermarkTimestamp))","Why don't you create a close method in EventProcessor and call this method from ThreadManager? Then, we don't have to have a reference of ThreadManager in EventProcessor",nested ifs could be collapsed with &&,"same here, make sure we have room to fit the new element",why do we need this new method?
"public void freeUnderlyingResources() { int spi = mSpi.getSpi(); try { mSrvConfig .getNetdInstance() .ipSecDeleteSecurityAssociation( 0, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, 0, mConfig.getMarkMask()); } catch (RemoteException | ServiceSpecificException e) { Log.e(TAG, ""Failed to delete SA with ID: "" + mResourceId, e); } getResourceTracker().give(); }",I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).,"This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?",performance: update he ACL once after updating the ACE list instead of for each ACE,Does it really?,"When an endpoint is marked as bad, it is evicted from the service cache. Since you are sharing service handles, you will now, potentially, be destroying handles that are still in use. There is also, potentially, a race condition here with checkOut where checkOut could return an evicted handle.",remove extra lines,"The change looks okay, but you also need the modify phone state or carrier privilege permission to do this, see TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege","do we want to keep this non-null if there is an issue with dispose? Basically, should we set it to null in finally or here?","This looks wrong: * The rule is already being deleted in line 297. * You are passing the security group name to the delete method, not the rule name. Remove this line, capture the URL in line 297 and check on that.","I'd write: LOGGER.warn(""Setting \""{}\"" does not exist."", id); And below: LOGGER.warn(""Setting \""{}\"" cannot be removed while it has subscribers."", id);",creation -> deletion
"public void execute() { final Setting setting = getActionContext().getSetting(); final EObject eObject = setting.getEObject(); final EStructuralFeature eStructuralFeature = setting.getEStructuralFeature(); final List<?> containments = (List<?>) eObject.eGet(eStructuralFeature, true); final List<?> moveUpList = Arrays.asList( ((IStructuredSelection) getTableViewer().getSelection()).toArray()); sortSelectionBasedOnIndex(moveUpList, containments); final EditingDomain editingDomain = getActionContext().getEditingDomain(); for (final Object moveUpObject : moveUpList) { final int currentIndex = containments.indexOf(moveUpObject); if (currentIndex <= 0) { return; } editingDomain.getCommandStack() .execute( new MoveCommand( editingDomain, eObject, eStructuralFeature, currentIndex, currentIndex - 1)); } }",we should probably check in the canExecute whether we reached the start of the list,we should probably check in the canExecute whether we reached the end of the list,Why does it return null? Should it not throw an exception on no more elements? Also I do not like the explicit null init. Usually this is a sign for some hack. ;),This is not what I would expect. I would expect a comparison between index and HEAD.,"If it fails out and we don't know what to do with it, please log an error with appropriate information. You can use WorkbenchPlugin.log(*). Throwing an exception might kill the workbench startup completely.","If the list is empty, we must change the selection to select nothing (erase the current editor selection). For example, for diagram editor, we must select the diagram in this case.",null must be the first operand,reachable,"getActiveEditorInput is ""since 3.7"". AFAIK we still support 3.5. I don't like making code more complicated for compatibility, but in this case I think it's not that bad to copy the implementation with getVariable. What do you think?",I think all three skins require both mappedElements.size() > oldValueIndex && oldValueIndex != -1. I think container.getSelectionModel().clearSelection(oldValueIndex) will throw a NullPointerException if the index is larger than the number of shown elements.,"See my suggestion above, I think this method isn't really necessary."
"protected Array createArrayOf(String typeName, Object[] array) { Connection connection = null; try { connection = getJdbcTemplate().getDataSource().getConnection(); return connection.createArrayOf(typeName, array); } catch (SQLException e) { throw new RuntimeException(e); } finally { if (connection != null) { try { connection.close();} catch (SQLException e) {} } } }","Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }",Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.,"please replace tabs with spaces. Adding the warning won't change the fact an unused code was added :-) if wishes to solve it completely, create the ResultSet before the try block and close the result set in the finally block, before closing the prepared statement. I'd take it one step further and introducing a new method to org.ovirt.engine.core.utils.db.DbUtils that performs closeQuitely for the result set and for the statement (or just call DbUtils.closeQuietly(rs, statement, null)",wait 15 seconds to match the code?,"Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.",need formatting.,we have IOUtils.closeSilently for this,It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?,I think it would be better to remove the catch block just let the exception propagate (the method already declares to throw Exception) and put the dataSource.stop() call into the finally block of the try-finally statement.,"It would be better to fix the indentation issues, can see in couple of places.","Note: There are *two* updateDatabase() methods (with different params) in this class, and it seems you only removed the synchronized from one of them. Is that on purpose?"
public byte[] serialize() { ByteBuffer buffer = ByteBuffer.allocate(9); buffer.put(TYPE_LONG); buffer.putLong(value); return buffer.array(); },magic number,"I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?",This will be faster:  buffer[offset] = (byte) (val >>> 24); buffer[offset + 1] = (byte) (val >>> 16); buffer[offset + 2] = (byte) (val >>> 8); buffer[offset + 3] = (byte) val;  :),final,"Why 17, is there some magic where value needs to be one byte bigger or something, or is it just for fun?",these arrays could be static finals. That would save allocating new ones all the time.,"Minor nit, the code does have a legacy style convention that we should follow (braces on its own line).",Check if byte[] b is null.,No need for >>> 0,"So, ByteBuffer does. Are you concerned that they may change the implementation? Seems like they cannot without basically breaking everyone, right? java private ByteBuffer putDouble(long a, double x) { try { long y = Double.doubleToRawLongBits(x); UNSAFE.putLongUnaligned(null, a, y, bigEndian); } finally { Reference.reachabilityFence(this); } return this; }",Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
"public ServiceReference[] getServiceReferences(String clazz, String filter) { ServiceReference[] refs = null; try { if (bundleContext != null) { refs = bundleContext.getServiceReferences(clazz, filter); } } catch (InvalidSyntaxException e) { if (log.isLoggable(Level.SEVERE)) { log.log(Level.SEVERE, e.getMessage(), e); } } return refs; }",I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.,drop the comma,"Seems like after OSGI it should be a period instead of a comma, but a nit and may be just how I'm reading it.",Please use Collections.emptyList() otherwise the gradle build emits warnings. I had to fix an issue like this already in this project.,"why ConfigurableApplicationContext, not ApplicationContext?",Calling the get method multiple times will cause the counter to be incremented multiple times. However the close method will only release once. So again this implementation seems unbalanced to me.,This line seems long; has this bundle passed format checks?,"I don't think we need to initialize the refs array first, then fetch the correct one with catching the error (that should never be thrown) and at last evaluate -- if the error has been catched -- the null array... If you want to move the code outside of the try-block then you can keep the final and remove the initialization with the null array. Just add a return -1; to the catch block.",I think we should not make this protected; it would needlessly increase our API surface area (and there's no guarantee we wouldn't want to refactor at this level). Package-private is probably the better choice here.,Why is this not directly injected into the component? Is it not available at construction time?,"this is also the wrong way around and should be  private <T, I extends T> @Nullable I getSingleServiceInstance(Class<T> clazz, final List<I> filteredServices)"
"private boolean execute(final IProcessDMContext processDmc, final IDebugCommandRequest request) { try { fExecutor.execute(new DsfRunnable() { @Override public void run() { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null) { procService.terminate(processDmc, new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!getStatus().isOK()) { request.setStatus(getStatus()); request.done(); } else { WaitForTerminationJob job = new WaitForTerminationJob(fSession.getId(), request); job.schedule(); } }; }); } else { request.done(); } } }); } catch (RejectedExecutionException e) { request.done(); } return false; }",Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?,If we are not running the full console (i.e. not async) we should not interrupt like this but use ^C instead.,Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?,Can we make this test use a Query instead?,"Please update the error message, or do an if (threadNamesSupported()) and use two different asserts with their corresponding error message","Since this is a new method you can use a much simpler way than using the waitor. You can use a Query instead, this is safe on this context as we don't have to worry about hanging the UI thread on these tests. You can use the method above as an example: i.e. getFrameData","Sorry, I forgot that the re-enablement wasn't done automatically. Please set this back to true. Technically, double-clicking on the button _could_ trigger two dialogs to come up, but in this case, the command is fast enough that it does not happen. If you want to see it happen, you can set a breakpoint in the code that executes the command, then double-click on the command; because of the delay of the bp, you will see two dialogs. FYI, the way we handled this before is by extending RefreshableDebugCommand (written just for that case) and mimic the logic in GdbConnectCommand. But it is overly complicated in your situation, which does not need it anyway.",Add the exception to the Status message,You should check for null just in case,space before catch,"I think ""filtered running threads"" should be localized."
"void deleteProperty(AccumuloElement element, Property property, Authorizations authorizations) { if (!element.getFetchHints().isIncludeAllProperties()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), ""All Properties""); } if (!element.getFetchHints().isIncludeAllPropertyMetadata()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), ""All Property Metadata""); } Mutation m = new Mutation(element.getId()); elementMutationBuilder.addPropertyDeleteToMutation(m, property); addMutations(element, m); getSearchIndex().deleteProperty( this, element, PropertyDescriptor.fromProperty(property), authorizations ); if (hasEventListeners()) { queueEvent(new DeletePropertyEvent(this, element, property)); } }",Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.,We should wait in the BulkUpdateService when the batch is converted to a request.,"By the way, if you see an opportunity to replace the com.google.common.eventbus handler by JavaFX observable listeners, please go ahead and migrate them!","switch to regular for to avoid Iterator allocation, ditto for the teams method","I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.",What happens when fetch hints don't include extended data table names?,Could this method be gutted and just call the new deleteElements method?,Could specific exception be used here?,Can we add a andFilter method that takes a single filter and calls the addFilter(filters[])?,why?,"I think for removing a thing the order was already fine. If we remove the thing from the ThingManager before notifying listeners, they could try to disable the thing in that short gap. Moreover, if we leave the order in this method unchanged, then it will be exactly the reverse order from the notifyListenersAboutAddedElement method, which is also what I would expect."
"public List<ExperimentSpotDesignReadSpec> list() { List expmts = this.getHibernateTemplate().find(""from ExperimentSpotDesignReadSpec as readSpec order by readSpec.experimentSpotDesignReadSpecId asc"" ); return expmts; }",Why does this need to be ordered by the synthetic primary key?,Possible copy/paste bug in the order by clause.,use final,WebApplicationException is a RuntimeException you don't need a throws clause for it,use final,nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.,ImmutableList,shouldn't this be ArticleRelationship?,We don't usually have public getter methods in Builder class. Is there a reason for having this getter?,Casting to ArrayList is brittle. Could we return List<> from here instead?,Fix formatting
"public void testToFlowElement_autostart() throws Exception { final ReusableSubprocess definition = new ReusableSubprocess(); definition.getExecutionSet().setAdHocAutostart(new AdHocAutostart(true)); final View<BaseReusableSubprocess> view = new ViewImpl<>(definition, Bounds.create()); final Node<View<BaseReusableSubprocess>, ?> node = new NodeImpl<>(java.util.UUID.randomUUID().toString()); node.setContent(view); final PropertyWriter propertyWriter = tested.toFlowElement(node); assertTrue(CallActivityPropertyWriter.class.isInstance(propertyWriter)); assertTrue(CustomElement.autoStart.of(propertyWriter.getFlowElement()).get()); }",The Exception is never thrown.,The Exception is never thrown.,The Exception is never thrown.,The Exception is never thrown.,The Exception is never thrown.,The Exception is never thrown.,"just for a better readability, better creating a new typed variable and avoid doing same cast to ReusableSubprocessTaskExecutionSet on each line","implicitly tested by the assertion below, hence drop it here.",add // NOOP or use the following syntax: new Runnable() { },"setBounds(Bounds rect) has protected access in BasePropertyWriter and that's why jenkins fail (it is not possible to compile this PR). Will check the code, but I need Full downstream build to test this PR properly.",nit ;; (and in other places in this PR)
"public static Date parseDate(String date, String format) { return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); }","Is a null check for the passed in ""date"" required here for safety?","why not just do java this(df.toPattern(), df.getTimeZone(), targetType);","should really be stored as a long in UTC, or at least ISO 8601.",The codacy issue is because you reassigned this object here. This check ensures that you do not accidentally modify an object in a function. Using a new variable like newDate would fix the issue.,"You shouldn't use 'Z'... it's just Z it is the flag for the timezone. 'Z' is UTC, but if I put +03:00 it's also valid ISO.",Constant simpleSum could even removed as this constant is never used outside this class.,probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.,"Great idea! Can we use Locale.ROOT instead, though?","please change the order and start with iso8601Format, because it should be the most popular","This logging doesn't really mean anything as it doesn't contain any information about the pattern. It could better be removed, I guess...","For error logger stack trace is already quiet wanted: suggestion logger.error(e.getLocalizedMessage(), e);"
public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); } return false; },"Since numberOfVotes can be null you should replace this with Objects.equals(numberOfVotes, other.numberOfVotes)",Hash code,Use another example of expression than a return statement... That example is hard to follow.,replace with return this == other;,"Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.",I prefer if (o instanceof LabelVote) { LabelVote l = (LabelVote) o; ... } return false;,Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...),Manual equals/hashCode are avoided by using DoubleArray.,This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.,"Please change to this.getVal() == that.getVal(). This will reduce the number of throwaway return objects (TaintedBooleanWithObjTag) that we are creating - any call to an instrumented method (like Objects.equals) from Phosphor code will result in a new one of these things being made. Please also add wrappers for equals and hashCode for each of the appropriate modes (for int, one that returns TaintedBooleanWithIntTag, for obj, one that returns TaintedBooleanWithObjTag, and also one for obj that *also* takes a ControlTaintTagStack).",@Override
"public static void connect(Socket socket, SocketAddress endpoint, SocketAddress localAddr, int timeout) throws IOException { if (socket == null || endpoint == null || timeout < 0) { throw new IllegalArgumentException(""Illegal argument for connect()""); } SocketChannel ch = socket.getChannel(); if (localAddr != null) { Class localClass = localAddr.getClass(); Class remoteClass = endpoint.getClass(); Preconditions.checkArgument(localClass.equals(remoteClass), ""Local address %s must be of same family as remote address %s."", localAddr, endpoint); socket.bind(localAddr); } try { if (ch == null) { socket.connect(endpoint, timeout); } else { SocketIOWithTimeout.connect(ch, endpoint, timeout); } } catch (SocketTimeoutException ste) { throw new ConnectTimeoutException(ste.getMessage()); } catch (UnresolvedAddressException ue) { throw new UnknownHostException(ue.getMessage()); } if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) { LOG.info(""Detected a loopback TCP socket, disconnecting it""); socket.close(); throw new ConnectException( ""Localhost targeted connection resulted in a loopback. "" + ""No daemon is listening on the target port.""); } }",nit: call it uae?,"LOG.info(""endpoint : {} , timeout : {}, connected successfully"", endpoint, timeout);",Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here,Isn't InetAddress.getAllByName(addrStr) equivalent to addresses here?,"Instead of hardcoding 2000 here, we can have a constant variable represent the timeout value at the beginning of QuorumPeer.java. [QuorumCnxManager](<LINK_0> is a good example on how it uses constants.",why is this called channelwrapper?,Should log the exception here. Does the caller handle the unknown address correctly?,"Slight wording change - the ""by searching"" bit is unnecessary and also irks me because you never say what or where you were searching suggestion logger.log(Level.FINE, ""Could not find an appropriate address, falling back to local host"");",log the exception the first time only,here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.,fix the spelling.
"public void testReviewForm() throws ParseException { final DeliveryReviewView view = getDeliveryReviewView(); final DeliveryReviewView.DeliveryForm deliveryForm = view.getDelivery(); deliveryForm.setGrade(""4.0""); deliveryForm.setState(""Rejected""); deliveryForm.setCommentary(""Hello World!""); assertTrue(deliveryForm.getGrade() == 4.0D); assertEquals(Delivery.State.REJECTED, deliveryForm.getSelectedState()); assertEquals(""Hello World!"", deliveryForm.getCommentary()); }",Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.,This should be fine on the previous line.,This should be fine on the previous line.,should be setContext,Use a mock here too. Don't stick to default.,"You should also verify that the span encompasses the whole of the author text, e.g.:  java assertEquals(start, spannableString.getSpanStart(span)); assertEquals(end, spannableString.getSpanEnd(span));","- Test case for two references to the same question details? - Test case for null input? Basically, try to cover every statement for equal() you introduced.",Assert values,"The coverage is not the only important thing in a unit test. Notice that the getValue method is **100%** covered, however, I could change it to this: java @Override public String getValue() { view.getValue(); return ""Wrong value!!!""; }  ..and the test testGetValue would still pass. We need to **really** test the logic of the method. See the following unit test (now, it really tests the method and breaks when the logic changes): java @Test public void testGetValue() { final String expectedValue = ""value""; when(view.getValue()).thenReturn(expectedValue); final String actualValue = dateSelector.getValue(); assertEquals(expectedValue, actualValue); }","To be clearer for what you're testing (the function setAnswer), you should test that the initial value isn't testValue i.e. suggestion assertNotEquals(feedbackTextResponseDetails.getAnswerString(), SanitizationHelper.sanitizeForRichText(testValue));","What do you think about changing this to java assertEquals(""Qinghui Zhang, Editor, Surachai Supattapone, Editor"", doc.select("".review-history .decision-letter span[itemprop=name]"").get(0).text());  so that we catch an accidental trailing ,?"
"private static void addRequestParameter(SOAPFactory soapFactory, OMElement bodyFirstChild, OMNamespace ns, String key, Object parameter) { if (parameter instanceof DataHandler) { DataHandler dataHandler = (DataHandler)parameter; OMText dataText = bodyFirstChild.getOMFactory().createOMText( dataHandler, true); OMElement omElement = soapFactory.createOMElement(key, ns, bodyFirstChild); omElement.addChild(dataText); omElement.addAttribute(""filename"",((DataHandler) parameter).getDataSource().getName(),ns); omElement.addAttribute(""filename"", ((DataHandler) parameter).getDataSource().getName(), ns); } else { String textValue = parameter.toString(); soapFactory.createOMElement(key, ns, bodyFirstChild).setText( textValue); } }",repeating code line.,"no need to store this variable. put it directly into the method below. Also, it is safer to use equals instead of ==","This name should reflect that there is more escaping than the ""writeAttribute"" function does","I think there are a few more types here that are relevant like XSBoolean, XSDateTime, XSInteger, and XSURI.",This needs to allocate five times (for each replace) and does the full search five times. Is there any better way to do this in Java?,"Use the new ModelNode op:  if (resourceMode.hasDefined(attribute.getName(), valueType.getName())) {  That call has no chance of mutating a ModelNode where doing so isn't wanted, so I want us to start using it.",can be inlined i think,Can we move to <LINK_0> yet?,Consider to put into constant variable,nit: it seems a bit weird that we are passing around the implementation type. Is there a reason that we are not using the interface?,"Shouldn't it be better introducing new constants for WRITE_XML_DECLARATION, XML_DECLARATION_ENCODING, XML_DECLARATION_STANDALONE ?"
"public Future<Void> executeFailed(Stage stage, Class<?> executingClass, ConsumerRecord<byte[], byte[]> consumerRecord, Throwable error) { if (!withinToleranceLimits()) { errorHandlingMetrics.recordFailure(); markAsFailed(); throw new ConnectException(""Tolerance exceeded in the errant record reporter"", error); } context.consumerRecord(consumerRecord); context.currentContext(stage, executingClass); context.error(error); errorHandlingMetrics.recordError(); return context.report(); }","if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.","What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.","Hi Emmanuel, I'm not convinced by this move. The API change above says it's deprecated but it's in fact totally ignored. As a user, I would prefer an API break so that I have a chance to fix my apps.",Suggestion (can't add because of the deleted line):  List<Future<RecordMetadata>> futures = reporters.stream() .map(r -> r.report(this)) .filter(Future::isDone) .collect(Collectors.toCollection(LinkedList::new));,We could replace it by an throwable instanceof RetryDueToResultException,In separate line ?,i think java return vv -> connection.getContext().runOnContext(handler);  Would have the same result and it avoid 1 extra lambda,Do we need FQCN?,please use curly braces even though this is a Oneliner,"It looks like you are casting result from Object to ListenableFuture<?>; can you do this without a check? (It looks to me like the check above is checking context's return type, but I don't know if that is guaranteed to be the same as the type of result).",Our standard convention is to prefix with this for instance members - return this.context
"public OutputWriter createOutputWriter() { if (file.exists()) { ExcelDatastore datastore = new ExcelDatastore(file.getName(), new FileResource(file), file.getAbsolutePath()); try (final UpdateableDatastoreConnection connection = datastore.openConnection()) { final DataContext dataContext = connection.getDataContext(); final Schema[] schemas = dataContext.getSchemas(); if (schemas.length >= 1) { final String[] tableNames = schemas[1].getTableNames(); for (int i = 0; i < tableNames.length; i++) { if (tableNames[i].equals(sheetName)) { if (overwriteSheetIfExists) { final Table tableSheet = dataContext.getTableByQualifiedLabel(sheetName); final UpdateableDataContext updateableDataContext = connection .getUpdateableDataContext(); updateableDataContext.executeUpdate(new UpdateScript() { @Override public void run(UpdateCallback callback) { callback.dropTable(tableSheet).execute(); ; } }); } } } } } } String[] headers = new String[columns.length]; for (int i = 0; i < headers.length; i++) { headers[i] = columns[i].getName(); } return ExcelOutputWriterFactory.getWriter(file.getPath(), sheetName, columns); }","Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after ""information_schema"" :-)","_configuration is a field of this class, so why pass it to an internal (non-static) class method? On line 156, you can just do _configuration.isValidateColumnTypes().","Note: There are *two* updateDatabase() methods (with different params) in this class, and it seems you only removed the synchronized from one of them. Is that on purpose?",Clickhouse has a different rename syntax (<LINK_0>,Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.,This implementation is identical to just returning nameToSheet.get(sheetName). It will return null if the key is not present.,"It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error(""Workbook creation exception"", e); ? Is there a reason behind using 2 different ways of logging errors?",The duplicate close looks strange to me. I think @rmetzger gave a nice idea above. You can just catch and log the error and move each close in a separate try block. You can take org.apache.flink.connector.hbase.sink.HBaseSinkFunction#close as an example. That will be much clean.,Should this return the AzureTable?,"Eeek, eatin away exceptions?","This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error."
public boolean isQueryCacheable(Query query) { return !query.isDescending() && !unCacheable.contains(query.getType()); },any reason for disabling cache for descending order queries ?,no need to create a set here..,"I'm not sure this works for varchar and char, which have an override for TypeInfo.getTypeName() that returns a qualified name like varchar(30). You probably want to use type.getTypeSignature().getBase(), which will return the base Presto type name.",isCacheable is now true? I guess this was supposed to be false for generic extractors. Or am I wrong?,Is the sort field used at all? I see it being set but don't see it used anywhere.,||?,I see getSearchManager().unwrap(SearchManagerImplementor.class) being called a few times. I think at this point it is better to modify QueryEngine.getSearchManager() to return SearchManagerImplementor and do the unwrapping only first time it is obtained.,What consumes this new field?,This recursive invocation never ends.,"Currently, query cache indexes are always on-heap (global), so it might be a good idea to replace that with an assert, just to remove QueryCacheRecordStoreAdapter and lower the complexity a bit.",maybe we can use LazyMapEntry as in [ClientMapProxy#entrySet](<LINK_0>
"public void testBacktickEscapedIdentifier() { assertTrue(CharFormatUtil.unescapeIdentifier(""``"").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier("""").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(""`s`"").equals(""s"")); assertTrue(CharFormatUtil.unescapeIdentifier(""`self`"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""`self"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""self`"").equals(""self"")); assertFalse(CharFormatUtil.unescapeIdentifier(""``self`"").equals(""self"")); }",assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?,"This isn't quite the test you wanted, I think. Shouldn't it be ""\""\n\"""" ?",I find it safer to assert the exact output and not whether the output contains some strings. It's not like the input string is that long. It's also easier to see the difference between the expected and the actual value when the test fails.,"The two escape methods can stay private, right?",One thing that I've just checked is that you can also use br and not just rb. Can you check that too?,This check immediately after Preconditions.checkNotNull?,there is already some escape method/utility/lib so take a look if this can be reused here,I think this can also be  java applyCollection(CharSeq::of);,isNull()?,Why do we _still_ need to escape the colon character?,"this will replace CRLF to 2 blanks, is this intended ?"
"protected void validateAuthenticationState(HttpClient httpClient) throws GerritLoginException { Optional<Cookie> cookie = findCookieWithName(LOGIN_COOKIE_NAME, httpClient); cookie.ifPresent(this::setXsrfCookie); if (!cookie.isPresent()) { if (CoreUtil.TEST_MODE) { System.err.println("" Authentication failed: "" + httpClient.getState()); } throw new GerritLoginException(); } }","maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still","Maybe it's just me, but I would find a simple if-else clause more readable.",this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method,releasing method and then executing it?,nit: duplicate code in these two tests: java ByteArrayOutputStream output = new ByteArrayOutputStream(); PrintStream outputStream = new PrintStream(output); PrintStream originalStream = System.out; System.setOut(outputStream);  java TwilioRestClient twilioRestClient = Twilio.getRestClient(); twilioRestClient.logRequest(request); System.out.flush(); System.setOut(originalStream);,Place these last two lines within the try block,Why the block?,"Can we log this entire exception, instead of printing the stack trace?","This breaks binary compatibility, since the next main release is expected to be binary compatible the ""old method"" should be deprecated instead.","Not sure what this would assert, it is the same call as before (username and password are unused). How do you know the cookie is used and not recreated? What exactly is tested here? Needs more doc IMO.",line length
"private void testGetForDeletedBlobWithoutIncludeExpiredOption(List<BlobId> blobIds) { try { store.get(blobIds, EnumSet.noneOf(StoreGetOptions.class)); assertTrue( ""get should fail for a expired blob, if StoreGetOptions.Store_Include_Expired is not set in get options"", false); } catch (StoreException e) { assertTrue( ""get for expired blob with with StoreGetOptions.Store_Include_Expired not set in get options should throw exception with "" + StoreErrorCodes.TTL_Expired + "" error code."", e.getErrorCode().equals(StoreErrorCodes.TTL_Expired)); } }",assertEquals and remove the expected value from message string,fail,"This begin/commit/rollback pattern is present all around the source code and we've encapsulated into TestingUtil.withTx, could you use that instead? :)",why is this condition required?,Here it would be nice to use a static import - that would make it more consistent with the other code,Here it would be nice to use a static import - that would make it more consistent with the other code,A message might be helpful,Should this method be private?,"same, ""error"" seems redundant here",s/remoteRetryMaxAttempts/remoteMaxRetryAttempts/,This try block and fail construct is unnecessary. Changing @Test to @Test(expected = CloudRuntimeException.class) accomplishes the same thing.
public Publisher<Integer> createFailedPublisher() { return null; },should be possible to provide one,Should we also throw a IllegalPublisherException like in RxJava2?,:bug: This will cause backward compatibility issues.,"If this class does not extend AbstractIDGenerator any more, this method and and should be also removed.",Use P.lazy.,Good!,"(again, threw)",As ApplicationSources are immutable and cached it makes sense to create this set in the constructor.,"this noopSubscription seems used in many places, create a single one and reuse?",Put this string in a final static so it can be updated in a single location?,Add CheckForNull.
"public String name() { return Json.createReader(new StringReader(this.obj)) .readObject() .getString(""name""); }","Looks like a duplication to me. How about this.json().getString(""name"")?",you should give the ability to the user to specify the name,while (jsonReader.hasNext()) ... Unless you're going for symmetry with the other libraries!,Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?,Do we use IVdcQueryable somewhere in AAA?,neat,"Hmm, I'm not too sure that we should export a GSON type as part of our public API. What do you think about making this a more opaque data type (like you did with []byte in Go)?",Same final question.,"two arguments is iffy. e.g. if you just want to enable -nestedLoading, you also need to specify 'org.apache.hadoop.mapreduce.input.TextInputForamt'. we can move input format also to arguments (-inputFormat). '-inputFormat' will be rarely used.",Do we want to return null or throw an exception here?,"jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils"
"protected FieldBase(String name, DataType dataType) { if (CoreUtils.isNullOrEmpty(name)) { throw logger.logExceptionAsError(new IllegalArgumentException(""The name of field cannot be null"")); } this.name = name; this.dataType = dataType; }",Should we also validate that DataType != null.,fieldName,"Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);",Better to write unit tests for these conditions,what Aaron said. This is not needed,"used only here, I think we can call directly AsyncDataProvider.getInstance().getMaxVmNameLength();",Should probably use the constant inplace of this String. <LINK_0>,So is there value of having a whole class that just does such a simple thing? Perhaps a static method in a utility class is easier and adds less to the heap?,It might be better to override toString rather than append ValidationError because now you will get org.voltdb.exception.ValidationError: ValidationError: MESSAGE when toString is called or the stack trace is printed,check the message code,"I think you need to wrap the NullPointerException in a runtime exception to make sure that behaviour is maintained.  .logAndThrow(new RuntimeException(ex), ""NullPointerException when calling TimeSeriesCellWriter"")"
"public Map<?, ?> read() { final Yaml yaml = new Yaml(); final Map<String, String> properties = new HashMap<>(); try (InputStream in = inputStream) { yaml.loadAll(in).forEach((Object obj) -> this.loadValue(properties, """", obj)); return properties; } catch (IOException e) { throw new IllegalStateException(""Cannot load environment"", e); } }",I think we need to close this InputStream at some point,Should we be closing these readers?,See StandardCharsets.UTF_8,Can we get a java stream here? We can use collector to collect it and do more complex operations,"we probably can use myClazz directly here, without JavaType conversion.",I feel like we need an assertion about the content of the Environment as well to make sure it is consistent with the YAML.,"What's the scenario in which in could be null at this point? if the file doesn't exist, getInputStream will throw a FileNotFoundException per FileResource.java. Maybe add a catch with FileNotFoundException? Then, you could get rid of the null check, yes?","Is it possible to close this one and the ones below on the same method where it is created? To avoid further problems such as when adding new methods. I see some code paths also close it, e.g. YamlClientConfigBuilder#build and  YamlClientFailoverConfigBuilder#build but not YamlConfigBuilder#build","hm, in theory this shouldn't be necessary. Following the call stack, the stack trace will be printed at: <LINK_0> , maybe logging level was set to something >debug ?",Please close the stream in finally block.,"I don't think this method is really necessary. If this is just about initializing the transient map, just do it in the field declaration"
"private static String createOrUpdateAccountsAndWait(Collection<Account> accounts) throws Exception { String jsonFilePath = tempDirPath + File.separator + UUID.randomUUID().toString() + "".json""; writeAccountsToFile(accounts, jsonFilePath); int numOfAccounts = AccountUpdater.createOrUpdate(jsonFilePath, ZK_SERVER_ADDRESS, HELIX_STORE_ROOT_PATH, null, null); Thread.sleep(100); return numOfAccounts == -1 ? null : jsonFilePath; }",do you clean up these files on exit? or the root level dir is deleted on exit ?,What happens later if the backup file wasn't created? We skip the backups?,Code style issue: if body is not wrapped in braces.,"You are using data.close after every account but data.open only once. Do I miss something or will this fail with more than one account? Also, we should not keep the DataSource open during network operations to prevent concurrency issues. Therefore, we should close it after line 76 and open it again just before line 87.",why not public?,int userEnable = accountJSON.getInt(AccountJSONEnum.ENABLE);,why twice?,"In order to keep the persisted profile image fields up to date, you'll need to also update it from the setProfileImage(), and deleteProfileImage() methods, and maybe even from the updateAccount() method as well.",int enbale = 1;,"I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.","possibly, it would be good to add check for null == account"
"private Integer extractCount(HttpServletRequest request) { Integer count = Integer.valueOf(getParameter(request, ""count"")); checkArgument(COUNT_RANGE.contains(count), ""'count' must be in range %s, was %s"", COUNT_RANGE, count); return count; }","""in range"" yet you're not providing a range; perhaps ""'count' must be at most %s""? Also, shouldn't that be %d?",return (Number) config.getAny(parameterName);,"why are we casting to ""int"" ? it the value is a ""long"" we must return a ""long"" or we have to handle the overflow some way",This _is_ a DeveloperError :D,"Extract this validation logic into an immutable value class, Rule, to encapsulate this validation logic and provide strong type specification in lower layers. Also, to improve performance, represent ALLOWED_PATTERN as a Pattern and pre-compile it. Each match operation is also compiling the expression which is expensive.","similarly:  if (!expression) { throw new BadRequestException(String.format(messageTemplate, messageArgs)); }",Weird sentence structure. Why not Illegal choice for parameter foo: bar?,"since the rangeMessage is relevant only in case of a failure, it could be locally evaluated here. There is no motivation to have the rangeMessage as an instance variable.","This should throw an UnsupportedOperationException instead of a RuntimeException. Also, standardize the error message with the other UOEs throughout this package.","use ... between 0 and 100., it's more user friendly","This message seems odd to me. ""Invalid params: <some message>""?"
private void dismissToast() { try { toast.cancel(); } catch (NullPointerException e) { ZLog.logException(e); } },hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e),Won't we land here for expected network errors as well? Should this be in the catch block itself?,"Let's put a meaningful message on our exception. Something like ""Exception thrown while trying to find unmap method on MappedByteBuffer, this method must exist on your VM in order for this to work.""","Just handleIssue(IStatus.WARNING, message, thr, false); will do the trick. And do we need warning(...) at all? If you want to provide it for symmetry with the createErrorStatus() methods below, then it should be named createWarningStatus, and be implemented using toStatus().","We should log this error, so that it is clear that we are not able to leverage this feature","Why do we have return values on these when they end up just throwing? I just noticed that. We can't change it, but it's very odd.",We can't change the signature of published methods,indentation. please see the code style guidelines on the wiki,"RealmLog.debug(e, ""onError has thrown an exception that is being ignored"");",Is this change related to updating apache velocity?,There is openWarning() ;)
"public boolean hasDeploymentSubModel(final String subsystemName, final PathElement address) { final Resource root = deploymentUnit.getAttachment(DEPLOYMENT_RESOURCE); final PathElement subsystem = PathElement.pathElement(SUBSYSTEM, subsystemName); return root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address); }","Should this support a null address? Same with the other one, which make support a null or empty address.",At WARN this requires a method in ControllerLogger for i18n. But this is so unlikely that I think debug is fine. If this were to happen it's almost certain the child would be runtime and thus not relevant anyway. A resource that's an actual feature wouldn't work without a registration.,OT: this is a poorly named variable!,I think you mean javax.xml.validation.SchemaFactory?,This should be PathAddress address = context.getCurrentAddress(); The result is the same but ^^^ is more efficient and is the preferred idiom because it's simpler.,"Is this directly related to the JMX problem, or just something you noticed as you were working this issue? If the latter please file a separate JIRA and split the commit. I can certainly see why this would need to be fixed, so no problem with the change.",This is model validation and hence needs to be in Stage.MODEL. So it needs to be moved out of performRuntime().,"This is an argument against #199. You're getting a ref to the read-only model with the intent to modify it. Safer here is to clone it first, but it's still an argument against that PR.","I don't think this is equivalent. There are other variants of DOWN than WONT_START and if those are true the existing code drops into a call to AbstractDeploymentUnitService.getStatus. And that checks a StabilityMonitor for both failed and problems and if either are found the result is DeploymentStatus.FAILED, not DeploymentStatus.STOPPED. In other words, DOWN due to missing dependencies -> DeploymentStatus.FAILED.","this is wrong. if (!subModel.hasDefined(absoluteParentName, subAttributeName)) { would work","It would be better to just read the subsystem children and avoid read the model recursively. I suggest using context.readResourceFromRoot(PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM)), false).getChildrenNames(SUBSYSTEM); instead"
"void scheduleKeepAliveHeartbeat() { Scheduler.get().scheduleFixedDelay(new RepeatingCommand() { @Override public boolean execute() { boolean sessionInUse = restApiSessionId != null; if (sessionInUse && refreshRestApiSession) { sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback()); refreshRestApiSession = false; } return sessionInUse; } }, SESSION_HEARTBEAT_MS); }","this is followup of above, it should not be required.",I think we should keep this synchronized.,"Hm, to avoid duplicating code, I suggest to create small methods: void processSessionId(String sessionId) { assert sessionId != null : ""Session ID must not be null""; RestApiSessionAcquiredEvent.fire(eventBus, sessionId); scheduleKeepAliveHeartbeat(); } void processSessionIdError(Throwable t) { RestApiSessionManager.logger.log(Level.SEVERE, ""Session ID is not available, this might break UI plugins"", t); }","Question: in the normal login scenario, reuseSession is called right after setSessionId. As both reuseSession (using getSessionId) & setSessionId are async now, I think we should utilize result callback when doing setSessionId, and only after setSessionId completes (result callback executes), we should proceed with reuseSession. This complicates the current code a bit, I can help with modifications/testing here.","Same as earlier. Also, I had the code in a private class on purpose. When exceptions are thrown, it's much easier to pick out the cause with named inner classes versus the anonymous inner class names that are autogenerated.",Is there a reason to not make it protected ?,Right now this is experimental and deeply flaky. We left this at info to make debugging user reports a lot easier.,this can be removed,"If you decide to keep _timer, we can stash this variable in a private field since we don't need to create a new one every time this method is called.",This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?,I think you want an additional null check here - since multiple concurrent threads can reach this synchronized block resulting in multiple expire task creation. e.g. java synchronized (this) { if (expireTask == null) { expireTask = ...; } }
"public void marriedKeychainBloomFilter() throws Exception { wallet = new Wallet(params); blockStore = new MemoryBlockStore(params); chain = new BlockChain(params, wallet, blockStore); String XPUB = ""xpub68KFnj3bqUx1s7mHejLDBPywCAKdJEu1b49uniEEn2WSbHmZ7xbLqFTjJbtx1LUcAt1DwhoqWHmo2s5WMJp6wi38CiF2hYD49qVViKVvAoi""; wallet.addFollowingAccounts(ImmutableList.of(DeterministicKey.deserializeB58(null, XPUB))); Address address = wallet.currentReceiveAddress(); assertTrue(wallet.getBloomFilter(1e-12).contains(address.getHash160())); Transaction t1 = createFakeTx(params, CENT, address); StoredBlock b1 = createFakeBlock(blockStore, t1).storedBlock; TransactionOutPoint outPoint = new TransactionOutPoint(params, 0, t1); assertFalse(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); wallet.receiveFromBlock(t1, b1, BlockChain.NewBlockType.BEST_CHAIN, 0); assertTrue(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); }","I should probably have asked this in the previous review, but why ""addFollowingAccounts""? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.","This version of createFakeTx also creates feeder transactions which you throw away. Is this needed? Probably we could use the ""one address"" version here?",I guess the else case should be P2WPKH,CustomTransactionSigner is a StatelessTransactionSigner thus I think this override is unnecessary.,Please don't reformat this method signature (and the 5 above).,Seems like this logic will include keys in the following keychain even though they are not expected to ever actually receive money by themselves?,"I notice at several places, you drop the @Nullable. Why?","Can you use Guava here?  Block block = params.getDefaultSerializer().makeBlock( ByteStreams.toByteArray(getClass().getResourceAsStream(""block.dat"")));",This might also cause trouble for TradeManager at startup,Do we need this checked exception here?,"It looks like keyPaths is only updated in the single-key case and when local signing is possible, in which case, what is it for?"
"public boolean test(Object receiver, String property, Object[] args, Object expectedValue) { IMonitorControl monitor = null; if (receiver instanceof IMonitorControl) { monitor = (IMonitorControl) receiver; } else { if (selectedMonitorId != null) { monitor = MonitorControlManager.getInstance().getMonitorControl(selectedMonitorId); } } if (monitor != null) { if (IS_ACTIVE.equals(property)) { return monitor.isActive() == toBoolean(expectedValue); } } return false; }","Please make sure this is properly formatted. ""else"" should be on the same line as the }.",Same remark about the constant,Do you think it is worthwhile to track the number other failures as well?,there is no need for casting here,"Isn't there something missing here? Like: ""if (JsonSerialization.readValue(desiredValue, JsonNode.class).equals(value)) return true"" like in other types? As it is currently, it will always fall to the bottom in case that ""value"" is JsonNode and method will return false always.",leftovers from StatusDTOTest. just return input; is enough here since this DTO has no primitives.,This should be simplified to just: >return value;,might change to assertEquals ?,This.,1. It exists a util method for that. 2. !=null is not an option 3. NatTable.hasFocus() doesn't resovle the problem ? 4. Maybe this new condition should be tested for each property of the tester ? (not sure),Make it localizable?
"public WorkspaceConfigImpl devFileToWorkspaceConfig(Devfile devfile) throws DevfileFormatException { validateCurrentVersion(devfile); WorkspaceConfigImpl config = new WorkspaceConfigImpl(); config.setName(devfile.getName()); List<ProjectConfigImpl> projects = new ArrayList<>(); devfile.getProjects().forEach(project -> projects.add(devProjectToProjectConfig(project))); config.setProjects(projects); Map<String, String> attributes = new HashMap<>(); StringJoiner pluginsStringJoiner = new StringJoiner("",""); StringJoiner toolIdToNameMappingStringJoiner = new StringJoiner("",""); for (Tool tool : devfile.getTools()) { switch (tool.getType()) { case EDITOR_TOOL_TYPE: attributes.put(WORKSPACE_TOOLING_EDITOR_ATTRIBUTE, tool.getId()); break; case PLUGIN_TOOL_TYPE: pluginsStringJoiner.add(tool.getId()); break; case KUBERNETES_TOOL_TYPE: continue; default: throw new DevfileFormatException( format(""Unsupported tool %s type provided: %s"", tool.getName(), tool.getType())); } toolIdToNameMappingStringJoiner.add(tool.getId() + ""="" + tool.getName()); } if (pluginsStringJoiner.length() > 0) { attributes.put(WORKSPACE_TOOLING_PLUGINS_ATTRIBUTE, pluginsStringJoiner.toString()); } if (toolIdToNameMappingStringJoiner.length() > 0) { attributes.put(ALIASES_WORKSPACE_ATTRIBUTE_NAME, toolIdToNameMappingStringJoiner.toString()); } config.setAttributes(attributes); List<CommandImpl> commands = new ArrayList<>(); devfile .getCommands() .forEach(command -> commands.addAll(devCommandToCommandImpls(devfile, command))); config.setCommands(commands); return config; }",throw exception?,Please add java doc,Is there a corresponding constant for cheEditor tool type?,"hello, is it possible to grab the latest version from the registry instead of using 1.0.0 ? the same for machine exec plug-in ?","I disagree with putting some specific behaviour in a common class, especially if it requires putting some enums. Another way to do that would be, in this class to have this empty method stub: protected void appendDefinitions(StringBuilder out, String indent) {} And in config tool, we are using it like that:  CustomJCommander jCommander = new CustomJCommander(""config-tool"", commandRepository, mainCommand) { @Override protected void appendDefinitions(StringBuilder out, String indent) { // place the code here } }; jCommander.  There are also several other ways to do that. But please remove all the specific code from this common class ;-)This defies the purpose of having such common class there, and makes it harder to change and leads to more code smell like putting enums there.",Can you elaborate on why provisioning on environemnt variables is not needed anymore?,Component must not be null,I think you don't need to collect all items and findAny will be enough here,It could be cool if we have the corresponding test case for it.,This looks the same as the V1 version except for the Class of the version. I think you can just use a template here As an example <LINK_0>,recipeFileContentProvider param is missing in java doc. DevfileRecipeFormatException is not desribed in @throws section
"public void testGetTaskRawFormViaUIClient() throws Exception { long processInstanceId = processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID); assertThat(processInstanceId).isGreaterThan(0); try { List<TaskSummary> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); assertThat(tasks).isNotNull().hasSize(1); Long taskId = tasks.get(0).getId(); String result = uiServicesClient.getTaskRawForm( CONTAINER_ID, taskId ); logger.debug(""Form content is '{}'"", result); assertThat(result).isNotNull().isNotEmpty(); } finally { processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); } }",Please change user back to USER_YODA here.,"Basically the same issue as mentioned above, I believe.","It seems this method does similar thing 3 times - if a new method, e.g. ""assertImageViaUIClient"" were introduced, it would prevent code duplication.",Can't we use Collections.emptyMap(),please no embedded json,Initializing ArrayList size when possible is better.,Will . work as a thousand delimiter?,IMO this assertion is not necessary.,Would be good to check also HTTP status code.,Would be good to check also HTTP status code.,"I would not mix jUnit Asserts with AssertJ. Would you mind changing it back to AssertJ, please? Assertions.assertThat(taskEvents.get(1).getMessage()).isEqualTo(expectedMessage); And in other places too, please. Thanks."
"private void buyCard(GameUserBean gameUser, GameBean game, Map<String, String> returnedParams) throws PlayException, GameException { DevelopmentCards availableDevelopmentCards = game.getAvailableDevelopmentCards(); DevelopmentCard obtainedDevelopmentCard = cardUtil.pullDevelopmentCard(availableDevelopmentCards); DevelopmentCards usersDevelopmentCards = gameUser.getDevelopmentCards(); usersDevelopmentCards.increaseQuantityByOne(obtainedDevelopmentCard); availableDevelopmentCards.decreaseQuantityByOne(obtainedDevelopmentCard); returnedParams.put(""card"", obtainedDevelopmentCard.name()); }",you don't take any resourcees from player when buying dev card,"test case works good but it is not clear where did I have got the resources for second card. how about splitting a method playPreparationStageAndBuyCardYearOfPlentyAndPassCycle() on several parts? for example: playPreparationStage() .nextRandomDiceValues(asList(1, 1)) // P1, P2, P3: -- .THROW_DICE(1) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) also create separate method passCycleAfterFirstPlayerTrewDice() when needed.",Seems this is optional and later on you do a != null so this might be better returning Optional<String>,"I don't like that controller returns Map instead of DTO, we should create separate Java class for each controller's response",i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable,"it is not the same test case, if I don't return bought card (like it happened today), this test case will pass and 'should_return_bought_card_in_response' will fail. And wise versa, if I return bought card but don't increase user's dev cards, current test case will fail and 'should_return_bought_card_in_response' will pass. So I don't think that we should combine test cases that test different things. But we can check everything in a single test case like it was done in PreparationStageTest, but I think that it was very bad idea","I guess we're not consistent across the codebase on whether method annotations should be on the same line as the method signature or on their own line(s). Let's pick one or the other and stick to it on at least a per-class basis, though.",Do we need Optional<> pattern here ? Probably makes it easy to use Optional when updating database or anywhere it is used,This return value is incorrect. Please create a new card type to represent this card.,"Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture",CardType.values() instead of EnumSet.allOf(...)
"public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(""Stream returnsCorrectInput!"").asBytes(); MatcherAssert.assertThat( ""Stream doesn't provide correct bytes"", new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }",@Serranya The same here. See above.,@Serranya The same here. See above.,@Serranya The same here. See above.,"@Serranya Please, add the name ""body content"" into the message to be more clear and specific. It's too much generic.",Would be nice to check different lengths and empty.,@fanifieiev refactor this string to put it in a variable.,"@olenagerasimova it's better to use assertions in tests instead of exception throwing: java MatcherAssert.assertThat(""wrong exception"", ex, new IsEquals(exception));","@Iprogrammerr Same as above, use new IsEqual to these two assertions","@dalifreire this doesn't throw IOException anymore now, you're just creating a stream on a Strings bytes :)",@dalifreire why we can't use StandardCharsets.UTF_8 ?,do we need to specify content type here?
"private void handleSelectorEvents(List<ResponseInfo> responseInfoList) { long handleSelectorEventsStartTimeMs = System.currentTimeMillis(); for (String connId : selector.connected()) { connectionTracker.checkInConnection(connId); } List<String> disconnectedList = selector.disconnected(); networkMetrics.connectionsDisconnectedCount.mark(disconnectedList.size()); for (String connId : disconnectedList) { connectionTracker.removeConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); if (requestMetadata != null) { responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), NetworkClientErrorCode.NetworkError, null)); } } for (NetworkReceive recv : selector.completedReceives()) { String connId = recv.getConnectionId(); connectionTracker.checkInConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), null, recv.getReceivedBytes().getPayload())); requestMetadata.onResponseReceive(); } networkMetrics.handleSelectorEventsTime.update(System.currentTimeMillis() - handleSelectorEventsStartTimeMs); }",What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.,not useful I think,"It seems in SSLTransmission this handshaking time is already reported. metrics.sslHandshakeTime.update(time.milliseconds() - handshakeStartTime); There may be some difference in value if compared to selectorPerceivedSslHandshakeTime, but I guess it would not be so big. Do we still want to keep this?","Why add in multiple places, looks like processResponse(call) is the place where the actual change is happening, so move most updates to that method? if (!call.response.hasRemaining()) { call.done(); // Remove here <==== return true; } else { // update here <===== return false; // Socket can't take more, we will have to come back. }","failedAttempts isn't really the number of failed connections, so not sure what we are setting timeout to.",Will it a little bit cleaner if we call it in the caller of sendAndPoll?,"This operation can be O(n), though the size of the list may be small. Making sense to use a set instead?",Isn't this better done at the beginning of onResponse() instead of here?,"we just log, update metric and move ahead with next iteration?","Should we check if the connectionId actually belongs to this <host, port> pair? There could be possibly error cases that connections to <host1, port1> are checked into <host2, port2>.",minor: This can probably be in one line connectionIdToPoolManager.remove(connectionId).removeConnection(connectionId);
"public Void visitInstanceOf(InstanceOfTree node, Void p) { if (node.getType().getKind() == Kind.ANNOTATED_TYPE) { AnnotatedTypeMirror type = atypeFactory.fromExpression((ExpressionTree) node.getType()); if (type.hasAnnotation(Nullable.class)) { checker.reportError(node, ""instanceof.nullable.error""); } if (type.hasAnnotation(NonNull.class)) { checker.reportWarning(node, ""instanceof.nonnull.redundant""); } } return super.visitInstanceOf(node, p); }",Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.,Why do we ignore annotations under ANNOTATION_DEF?,getAnnotations().contains can be replaced with hasAnnotation.,Use reportError rather than report.,"As discussed, this visit of annotations should be generalized to also catch parameters, field and variables. The following cases should raise issues:  class A { @Nullable // Noncompliant Optional<String> myField; void foo(@Nullable Optional<String> s) { // Noncompliant - Optional should not be null } }","if the class has a constructor we ignore it, but non-static initializer aren't? I'm not sure with the criteria...","Note how the logic in addAnnotationsFromElement is different: it only checks whether the annotation is part of the org.checkerframework package, not that it is a declaration annotation. Shouldn't the logic between these two be the same?",Note that this only validates explicit annotations in source code. You could instead validate all methods/fields to ensure correct usage to also ensure stub files are correct.,You should try to avoid operations on strings. Is there no TypeKind to compare against?,"Thanks, this will allow us to create lazy singleton providers with optional dependencies to reduce transitive dependency footprint while still fully participating in DI framework object management. The addition of class name to the info message should be really helpful for people investigating unexpected behaviors. Would class name also be useful in the NoSuchFieldException message?",please sort that expression by complexity of execution for performance reasons.
"public void onStartup(ServletContext servletContext) { LongTaskTimer longTaskTimer = LongTaskTimer .builder(""spring.cloud.dataflow.server"").description(""DataFlow duration timer"") .tags(Tags.empty()).register(Metrics.globalRegistry); this.longTaskSample = longTaskTimer.start(); if (StringUtils.hasText(dataSourceUrl) && dataSourceUrl.startsWith(""jdbc:h2:tcp://localhost:"")) { logger.info(""Start Embedded H2""); initH2TCPServer(); } }","Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow",I'd just go for URI.create(url.toString()) probably; added benefit that it fails fast if it's null.,"Instead of using TaskRunner here I would suggest using a LazyRef. Normally we only use the task runner at the job-execution level and in this case I guess you _always_ want multithreading (whereas TaskRunner allows e.g. singlethreaded implementations). The LazyRef also uses a shared thread pool and it has methods built-in for checking the status, so you can also get rid of the CountDownLatch in here.","This hack produce invalid result when jdbc url already contains some parameters. java String jdbcUrl = ""jdbc:mysql://zml:totallymypassword@localhost/sponge?useSSL=false""; SqlServiceImpl.ConnectionInfo subject = SqlServiceImpl.ConnectionInfo.fromUrl(null, jdbcUrl); System.out.println(subject.getAuthlessUrl()); // outputs: jdbc:mysql://localhost/sponge?useSSL=false?disableMariaDbDriver  Checking for question mark and appending &disableMariaDbDriver is not a solution. Possibility of setting custom data source properties by user as key-value map in sponge configs needed. Also there is need to maintain backward compatibility with already existing configurations which put properties in jdbc url. This involves parsing of query string in fromUrl factory method as well.",Let's make a defensive copy of the passed in Collection here using new HashSet<String>(protocols),suggestion HttpGet request = new HttpGet(uri);,this isn't doing anything,Delete blank lines,why do you need this sleep?,Just td-client seems better.,"this line is repeated in the else statement, so can be moved to above the if"
"public String getJournalKeyFromDoi(String doi, Site site) { Map<String, Object> journalDoiRegexList = getJournalDoiRegexList(site); for (Map.Entry<String, Object> entry : journalDoiRegexList.entrySet()) { if (doi.matches(entry.getValue().toString())) { return entry.getKey(); } } return null; }","String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.",nit: Can replace dois.size() == 0 with dois.isEmpty().,"You can just call the forEach on the docs instance directly, rather than creating a **stream()** first. For example:  docs.forEach(...)","Shouldn't the return type be: List<Map<String, ?>>?","This looks like a perfectly correct use of the cross-theme config values. :+1: A possible alternative: the Ambra schema actually does define a single journal of ""original"" publication, though it's modeled in a roundabout way. (Brief diversion to Rhino land here.) The ""original"" journal is the one whose eIssn, as defined in ambra.xml, matches the article's eIssn value. There's also a free-text field for the journal title, which is inconsistently populated and not to be trusted. (End diversion.) For the more general case of cross-publishing, it would be more robust to return that journal than an arbitrary non-collection one. That would require access here to the article metadata from Rhino. A query to Rhino per search result would be prohibitive on performance, I suppose? Or else we could add/backfill the data into the Solr index, but that sounds costly. Unless maybe the Solr data includes the eIssn, which we could match to a journal eIssn right here (assuming we somehow retrieve the journals' eIssn values)? Anyway, your call on whether it's worth it. I'm okay with this as is.","There is .orElseThrow(...) in optionals. Rewriting is difficult here. And it was like that before you touched the code, so no importance here.",suggestion return databaseContext.getEntries().stream() .map(bibEntry -> bibEntry.getField(StandardField.DOI)) .filter(Optional::isPresent) .map(Optional::get) .filter(bibEntryDoi.equals(doi)) .findFirst();,please remove empty line,"I know you're just extending an existing method here, and Optional seems better than a naked NULL, but I just think it's weird to do it this way instead of just erroring out when an article that's not an amendment is fed inappropriately as an argument. Couldn't we use a private method called isAnAmmendment() for example, and use it as a filter instead?",This can be static.,this should be renamed to doiMetadata
"private void addSidecar( PodData pod, CheContainer container, ChePlugin chePlugin, KubernetesEnvironment kubernetesEnvironment, Collection<CommandImpl> sidecarRelatedCommands) throws InfrastructureException { K8sContainerResolver k8sContainerResolver = new K8sContainerResolverBuilder() .setContainer(container) .setImagePullPolicy(sidecarImagePullPolicy) .setPluginName(chePlugin.getName()) .setPluginEndpoints(chePlugin.getEndpoints()) .build(); List<ChePluginEndpoint> containerEndpoints = k8sContainerResolver.getEndpoints(); Container k8sContainer = k8sContainerResolver.resolve(); String machineName = Names.machineName(pod, k8sContainer); pod.getSpec().getContainers().add(k8sContainer); MachineResolver machineResolver = new MachineResolverBuilder() .setCheContainer(container) .setContainer(k8sContainer) .setContainerEndpoints(containerEndpoints) .setDefaultSidecarMemorySizeAttribute(defaultSidecarMemoryLimitBytes) .setAttributes(kubernetesEnvironment.getAttributes()) .build(); InternalMachineConfig machineConfig = machineResolver.resolve(); machineConfig.getAttributes().put(CONTAINER_TYPE_ATTRIBUTE, ""tool-container""); kubernetesEnvironment.getMachines().put(machineName, machineConfig); sidecarRelatedCommands.forEach(c -> c.getAttributes().put(""machineName"", machineName)); container .getCommands() .stream() .map(c -> asCommand(machineName, c)) .forEach(c -> kubernetesEnvironment.getCommands().add(c)); SidecarServicesProvisioner sidecarServicesProvisioner = new SidecarServicesProvisioner(containerEndpoints, pod.getMetadata().getName()); sidecarServicesProvisioner.provision(kubernetesEnvironment); }",It would be better to make value a constant too,InfrastructureException can not be thrown here,"I feel like we're stretching our use of Lists and Maps in the signature here, by passing a mutable list of containers and a map of containers to instance lists. Instead can we use an object that encapsulated all of that? Like a PackingPlan object or a variant of it? Some container object that is able to effectively mutate a plan? Maybe a Builder that takes a packing plan, allows update methods to be called to change internal state, and then produces a new plan with a build() method?",Have you considered filtering of containers in Docker API? <LINK_0>,"getKind() is string value, test itself is parametrized with enum, so you can do it easy with getFactoryType() == JERSEY","nit: imageName field can be changed to DockerImageName, to make tests' bodies a little bit smaller",I would test if imageStream is not null before using it,"Use Resources.clone(Resources.none()). That way, you could do Resources.clone( getReservedContainer() != null ? getReservedContainer.getAllocatedResource() : Resources.none())",It can be a costly operation. Can we cache runtime and return it in case it is not null?,we do know the size of the hashet so we could set it with the expected size,is the intent here not to decouple our classes from the docker api? then it seems bad to pass Container type to DockerContainer ?
@Override public void draw(Canvas canvas) { if (!animating) { image.draw(canvas); } else { if (placeholder != null) { placeholder.draw(canvas); } float normalized = (SystemClock.uptimeMillis() - startTimeMillis) / FADE_DURATION; int alpha = (int) (0xFF * normalized); if (normalized >= 1f) { animating = false; placeholder = null; image.setAlpha(0xFF); image.draw(canvas); } else { image.setAlpha(alpha); image.draw(canvas); invalidateSelf(); } } if (debugging) { drawDebugIndicator(canvas); } },Don't we need to reset alpha here? Drawables share a global state.,This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.,Still no magic numbers...,"Is there a reason for this short circuit? I know I'm probably nit-picking here, but I feel that this would be ""slower"" than not having it, due to extra complexity preventing JVM optimisations.",Let's make this non-static and non-private. It seems like it's a function that might be useful down the line.,I suggest to use positive case for more often scenarios when SDK >= 11,Nit: should we also avoid starting an animation if requestStopAnimating_ is set?,"If you have the time, I'd suggest using the ender fluid tag since you're checking both fluid types",Let's pull 75 up to a constant or something.,How do you control drawing the debug lines? It should be conditioned by a global variable that sets the editor in debug (pass as command line argument).,Errr... you should verify this before you even push a new commit! =)
"public void addingAStudentAddsThemToTheSortedRoster() { school = new School(); school.add(""Aimee"", 2); List<String> expected = Arrays.asList(""Aimee""); assertEquals(expected,school.roster()); }",There should be a space here between expected and school.roster(),I think it might be easier to create a list and compare that?,usually we use assertEquals ;),StringHelper.splitName will help you :P,Why this?,I think having each argument on a new line is a bit more readable :),"Comparators classes don't generally have to implement equals (i.e. is this comparator the same as this other comparator?), so this is effectively ""assertSame"" because it's probably relying on Object.equals(). I don't think it's particularly rigorous to test for equality by using the comparator so I can't think of something better and I'm happy enough if we just compare instances. So, I think we should probably assertSame where we're expecting the same instance returned to make it clear.",Consider moving these assertions to separate method.,You could use IsIterableContainingInAnyOrder.containsInAnyOrder instead.,FEATURE_OWNED_GROUP_STUDENTS_RESTRICTION,"Why does roundtrip(""[] a"") succeed? I would expect that ""[] a"" comes out as the special cased haskell type ""[a]"""
"public static <T extends RemoteJsonService> T create(Class<T> serviceClass, GerritHttpClient gerritHttpClient, Version version) { String uri = GerritVersion.isVersion26OrLater(version) ? ""/gerrit_ui/rpc/"" : ""/gerrit/rpc/""; InvocationHandler handler = new GerritService(gerritHttpClient, uri + serviceClass.getSimpleName()); return serviceClass.cast(Proxy.newProxyInstance(GerritService.class.getClassLoader(), new Class<?>[] { serviceClass }, handler)); }",We should put the URL fragments into static vars in a common file then select them based on version in one place rather than scatterred throughout code.,inline OBJECT_MAPPER or pull out the one below,"This will change default behavior that you would expect if a service was created with just Retrofit, which kind of sucks. **On the other hand Retrofit would not accept URL and just throw some exception, right?** In such case it is probably not a big deal to accept more URLs.","no more need for public, I guess","Use String.format instead. It'll make the code more readable. E.g.  java String.format(""%s://%s:%d/%s"", protocol, host, port, path);","for this to work well with router nodes, filter implementations must be able to handle async servlet request propertly. Maybe we should add a note in the ServletFilterHolder on that.",:x: this belongs in the BuildConfig --> create a field in the base.properties file and read it in BuildProperties#configure. See what we do for the other fields in there as a reference.,"This should be moved into the HttpConfig object, so its part of the cached HttpConfig we obtain from the repository config file when no changes have been made to the file.",nit: you can use Map::computeIfAbsent,I think this is where the timeouts need to be set.,style nit: we don't use braces around single line blocks
"public V replace(K key, V value) { V v = delegate.replace(key, value); if (v != null) { stats.incrementCacheHits(); } else { stats.incrementCacheMisses(); } stats.incrementCachePuts(); return v; }",This should be in the if(v != null) check I am thinking,Do we need the memory semantics of an AtomicBoolean or could we get away with a boolean[] here?,Same issue as with putIfAbsent. There is a disconnect between the way we track statistics and the way 107 requires them to be represented.,Why doing this only in one branch? What happens otherwise if expiry or evictions were triggered by the logic?,why do you define the class at all? You can just inline the call...,Shouldn't this go to the Single as an error?,Quite a number of the changes here are the same. Refactor into a new method like setAccessTimeAndExpiryThenReturnMapping which clarifies intent and includes expiration notification when needed. Then you can have the few places where it happens differently still invoke a refactored setAccessTimeAndExpiry.,We need to change the method names to be more descriptive.,"Here, not sure about the now... given it's in a conditional compute, which way would be best?",Please add the parenthesis as done in the change above this one,"No returns here, so call can be moved outside of the if"
"public JCloudsSlave( @Nonnull ProvisioningActivity.Id id, @Nonnull Server metadata, @Nonnull String labelString, @Nonnull SlaveOptions slaveOptions ) throws IOException, Descriptor.FormException { super( metadata.getName(), null, slaveOptions.getFsRoot(), slaveOptions.getNumExecutors(), Mode.NORMAL, labelString, null, new JCloudsRetentionStrategy(), Collections.singletonList(new EnvironmentVariablesNodeProperty( new EnvironmentVariablesNodeProperty.Entry(""OPENSTACK_PUBLIC_IP"", Openstack.getPublicAddress(metadata)) )) ); this.cloudName = id.getCloudName(); this.provisioningId = id; this.options = slaveOptions; this.nodeId = metadata.getId(); final Map<String, String> instanceMetaData = metadata.getMetadata(); if (instanceMetaData != null && !instanceMetaData.isEmpty()) { this.openstackMetaData = new TreeMap<>(instanceMetaData); } else { this.openstackMetaData = null; } setLauncher(new JCloudsLauncher(getLauncherFactory().createLauncher(this))); }",Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.,Nice! I just wanted to ask for tests,Should log the exception.,"can you just call this(template, nodeDescription, cloud, label, new OnceRetentionStrategy(cloud.getRetentionTimeout())) to avoid duplicated code","I think you'd better do it the other way around, call this(template, nodeDescription, cloud, labelStr, rs); in the first constructor, call super in the second one","Send to logger, instead.",Same backward compatibility concern as in EC2AbstractSlave.,"Make ""jclouds-group"" a constant, seeing as it's used in a couple of other classes too?",Spacing?,"Minor: I would rather directly throw BadRequestException since the latter more appropriately expresses that the problem is due to a conflict of cluster settings vs IDBroker mappings. IdbmmsOperationException is supposed to denote problems specific to IDBMMS, e.g. due to missing mappings, communication error or some other internal service error.",[minor] static import Iterables.find? And OK if this blows up if the region cannot be found?
"protected List<SurveyGroupDto> parseSurveyGroups(String response) throws Exception { List<SurveyGroupDto> dtoList = new ArrayList<SurveyGroupDto>(); JSONArray jsonArray = getJsonArray(response); if (jsonArray == null) { return dtoList; } for (int i = 0; i < jsonArray.length(); i++) { JSONObject o = jsonArray.getJSONObject(i); if (o != null) { try { SurveyGroupDto dto = new SurveyGroupDto(); if (o.has(""name"") && o.isNull(""name"")) { dto.setName(o.getString(""name"")); } if (!o.has(""monitoringGroup"") || o.isNull(""monitoringGroup"")) { dto.setMonitoringGroup(false); } else { dto.setMonitoringGroup(o.getBoolean(""monitoringGroup"")); } dtoList.add(dto); } catch (Exception e) { System.out.println(""Error in json parsing: "" + e.getMessage()); e.printStackTrace(); } } } return dtoList; }","I guess you mean !o.isNull(""name"")? Which by itself would be enough. No need for the o.has(""name"")","this function should return something, not just print to the console.",Please extract toJson(Event) into a variable. We use it in both if branches.,you can just inline this,"This should be in a finally clause. Ideally, use a try-with-resources statement.",This seems like duplicate code from a similar block I saw above. Should it be refactored?,Don't leave System.out calls in the code after you're done. Other use LOG.debug' or delete them.,nit: duplicate code in these two tests: java ByteArrayOutputStream output = new ByteArrayOutputStream(); PrintStream outputStream = new PrintStream(output); PrintStream originalStream = System.out; System.setOut(outputStream);  java TwilioRestClient twilioRestClient = Twilio.getRestClient(); twilioRestClient.logRequest(request); System.out.flush(); System.setOut(originalStream);,Trivial but is Exception the most narrow fit for this try ?,"pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures",Same as before regarding interchangeability of arguments
"public Factory build() { BitSet redacted = new BitSet(); List<String> fields = new ArrayList<>(), keys = new ArrayList<>(); List<Integer> keyToFieldList = new ArrayList<>(); int i = 0; for (String fieldName : fieldNames) { if (redactedFieldNames.contains(fieldName)) redacted.set(i); fields.add(fieldName); keys.add(fieldName); keyToFieldList.add(i++); } for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) { String nextPrefix = entry.getKey(); String[] nextFieldNames = entry.getValue(); for (i = 0; i < nextFieldNames.length; i++) { String nextFieldName = nextFieldNames[i]; int index = fields.indexOf(nextFieldName); if (index == -1) { index = fields.size(); fields.add(nextFieldName); } keys.add(nextPrefix + nextFieldName); keyToFieldList.add(index); } } int[] keyToField = new int[keys.size()]; for (i = 0; i < keyToField.length; i++) { keyToField[i] = keyToFieldList.get(i); } String[] validated = fields.toArray(new String[0]); if (validated.length == 0) return new Factory(delegate); return new RealFactory(delegate, validated, keys.toArray(new String[0]), keyToField, redacted); }","Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...",I would prefer some brackets around the logic elements for readability,You can make it new ArrayList<>();,I'd add an always-printed log message here too to make sure it's remembered.,"for the field-counts we're dealing with (10s), keys.indexOf() should be good enough",style nit: we don't use braces around single line blocks,"This same fix should apply to get( int ) as well, I think, so that we are consistent.","could initialize with cardinality of bits, e.g. List<Long> indexes = new ArrayList<Long>((int) bits.cardinality());",I wonder if you can change by  newFields.removeIf(next -> next.id() != null && next.id().equals(field.id()));,Can this be made private?,This should return an immutable collection.
public static String minimalEscape(Object content) { if (content == null) { return null; } String str = String.valueOf(content); StringBuilder result = new StringBuilder((int) (str.length() * 1.1)); int length = str.length(); char c; for (int i = 0; i < length; ++i) { c = str.charAt(i); switch (c) { case '&': result.append(AMP); break; case '<': result.append(LT); break; default: result.append(c); } } return result.toString(); },Missing Unstable attribute.,why make this method final?,there is already some escape method/utility/lib so take a look if this can be reused here,Why do we _still_ need to escape the colon character?,This duplicates the relationship already established in the enum definition. Instead you could write  for (Strand strand : values()) { if (strand.charEncoding == ch) { return strand; } } throw new ...,Java 7 only - inline. Similarly for Integer.compare.,Ditto. suggestion String getCharset() {  (or just remove private from the field),"How can you be sure of that? If you transpile these files, while not using directly a predefined charset such as UTF-8?","The two escape methods can stay private, right?",@johnou this is not thread-safe... You will need todo this in the handlerAdded(...) method as CharsetUtil.encoder(...) looks up its encoder via a thread-local. So we need to ensure we call this from the same thread as we use to encode later on.,"My suggestion to not use ByteArrayOutputStream is because it really adds little value here. The result cannot be longer than bytes.length. We copy the result twice right now, just because you are don't want to keep an output index counter. If the loop was using a new-style for loop with an iterator, maybe it would make sense to try and use a result buffer type that hides the result buffer pointer. But its not, its heavily relying on the index and direct array access because this is more efficient than doing a new substring call on each character position as you walk down the string. At that point it can be easier to follow the code if both the source and destination buffers are using the same approach, a direct pointer into the array. Whatever, we can keep the ByteArrayOutputStream. I just think its silly to allocate that, and a temporary byte array, and copy the temporary byte array over to a real byte array, just so you can call RawParseUtils.decode(), which accepts an array, a starting position, and an ending position, and thus does not need the temporary array."
"public void overloadedMethodsGetResolved() throws Exception { provider = new ExtensionAwareEvaluationContextProvider( Collections.singletonList(new DummyExtension(""_first"", ""first"") { @Override public Object getRootObject() { return new RootWithOverloads(); } })); assertThat(evaluateExpression(""method()"")).isEqualTo(""zero""); assertThat(evaluateExpression(""method(23)"")).isEqualTo(""single-int""); assertThat(evaluateExpression(""method('hello')"")).isEqualTo(""single-string""); assertThat(evaluateExpression(""method('one', 'two')"")).isEqualTo(""two""); assertThat(evaluateExpression(""method(1, 2)"")).isEqualTo(""two-ints""); assertThat(evaluateExpression(""method(1, 'two')"")).isEqualTo(""int-and-string""); }",Shall we extract that setup step? It's repeated in every test below.,Could we add a check on the node being replaced having a null parent?,"Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.",nit: please use a static import for assertEquals,all \n should be replaced by %n with String.format being used for being truly OS independent (thank you windows \n\r line separator).,Both good ideas :+1:,"this case also has a PrimarySuffix for .this. Considering the prefix (classname) has a type, is there any reason for the suffix not having one? If it has one, we should probably add an assertion",Can this return Increment so we can test the code that allows methods annotated with @Rule to return a subclass of MethodRule?,I think the assert should be that value is null. It looks like it's your assert that is throwing the NPE,Abbreviation should be used for variable name: Result -> res. See abbreviation rules.,Would prefer this as Hamcrest assertThat for consistency.
"public static String getPreferredVariable(IPath[] paths, IContainer target) { IPath commonRoot = null; for (IPath path : paths) { if (path != null) { if (commonRoot == null) commonRoot = path; else { int count = commonRoot.matchingFirstSegments(path); int remainingSegments = commonRoot.segmentCount() - count; if (remainingSegments <= 0) return null; commonRoot = commonRoot.removeLastSegments(remainingSegments); } } } String mostAppropriate = null; String mostAppropriateToParent = null; int mostAppropriateCount = Integer.MAX_VALUE; int mostAppropriateCountToParent = Integer.MAX_VALUE; IPathVariableManager pathVariableManager = target.getPathVariableManager(); for (String variable : pathVariableManager.getPathVariableNames()) { if (isPreferred(variable)) { URI rawValue = pathVariableManager.getURIValue(variable); URI value = pathVariableManager.resolveURI(rawValue); if (value != null) { IPath path = URIUtil.toPath(value); if (path != null) { int difference = path.matchingFirstSegments(commonRoot); if (difference > 0) { if (difference < mostAppropriateCount) { mostAppropriateCount = difference; mostAppropriate = variable; } } else { difference = commonRoot.matchingFirstSegments(path); if (difference > 0) { if (difference < mostAppropriateCountToParent) { mostAppropriateCountToParent = difference; mostAppropriateToParent = variable; } } } } } } } if (mostAppropriate == null) { if (mostAppropriateToParent == null) return ""PROJECT_LOC""; return mostAppropriateToParent; } return mostAppropriate; }",rename 'variableName',"storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, I think we should stick to it as far as possible.",Adapters.adapt,Many roads lead to Rome... I would have done return FileUtils.canonicalize(new File(result)).toString(); (using org.eclipse.jgit.util.FileUtils),try to avoid reusing local variables,"The templates used are already UnderscoreTemplates, so is it necessary to replace '.' with '_'?",Will also be handled by Adapters.adapt,Extract method maybe? Altering a parameter is a code smell (doesn't SonarQube warn about this? It did before),will properties provider return the defaultValue in case of no network or value not found ?,make static,Is there a reason to set the strength? None of the Platform/UI nor JDT code does so.
"public void deleteStorage(final String id, final Optional<String> user) throws DbWriteOperationsBlockedException, NoSuchStorageException, StorageIsUsedException, InternalNakadiException { if (featureToggleService.isFeatureEnabled(FeatureToggleService.Feature.DISABLE_DB_WRITE_OPERATIONS)) { throw new DbWriteOperationsBlockedException(""Cannot delete storage: write operations on DB "" + ""are blocked by feature flag.""); } try { final Optional<Object> storageOrNone = storageDbRepository.getStorage(id) .map(Function.identity()); storageDbRepository.deleteStorage(id); auditLogPublisher.publish( Optional.empty(), storageOrNone, NakadiAuditLogPublisher.ResourceType.STORAGE, NakadiAuditLogPublisher.ActionType.DELETED, id, user); } catch (final RepositoryProblemException e) { LOG.error(""DB error occurred when deleting storage"", e); throw new InternalNakadiException(e.getMessage()); } catch (final TransactionException e) { LOG.error(""Error with transaction handling when deleting storage"", e); throw new InternalNakadiException(""Transaction error occurred when deleting storage""); } }","Good catch, thanks. Fixed <LINK_0>",do we really need this catch block ?,I believe this call is useless when we have 150 instances,Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?,"Use com.b2international.index.Writer.removeAll(Map<Class<?>, Set<String>>).",declare throws please,"I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.",Should you pass the valid item id here? Since the test is for invalid item type and not for id,Please log Bundle ID data here.,"Also happens for ""GET"" endpoints, ""WRITABLE"" is not correct in those cases",DateTimeZone.UTC
"private static String loadFile(String fileName) { String content = """"; fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName); File file = new File(fileName); if (file.exists()) { try { content = new String(Files.readAllBytes(file.toPath())); } catch (Exception e) { log.error(""Failed to read sysprep template '{}': {}"", fileName, e.getMessage()); log.debug(""Exception"", e); } } else { log.error(""Sysprep template: '{}' not found"", fileName); } return content; }",The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada,why charset == null? if charset is not available it should use default charset.,We could inline encoding.,"It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?",please dont remove explicit initialization,"Do you need this try-catch block around IOUtils.closeQuietly? I was under the impression that that method was null-safe, and would avoid throwing exceptions if the close failed. If this try-catch truly is needed, then please fix the typo in this error message (should be ""to close"" instead of ""tlose"").","Resources.toByteArray(Resources.getResource(""README.blank"")); wdyt?","This should probably throw an exception so that the caller can decide what to do if it fails. The way the code is here, returning null here would cause the string ""null"" to be printed into the styles tag. Better to just not print anything if loading this fails.",contents may be a better name,There is no reason to catch all exceptions like this.,stacktrace displayed would be nice.
"public boolean invalidateIfNecessary(BaragonRequest request) { if (request.getLoadBalancerService().getOptions().get(""edgeCacheDNS"") == null) { return false; } try { String edgeCacheDNS = ((String) request.getLoadBalancerService().getOptions().get(""edgeCacheDNS"")); Optional<CloudflareZone> matchingZone = getCloudflareZone(edgeCacheDNS); if (!matchingZone.isPresent()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but no matching Cloudflare Zone was found!""); return false; } String zoneId = matchingZone.get().getId(); Optional<CloudflareDnsRecord> matchingDnsRecord = getCloudflareDnsRecord(edgeCacheDNS, zoneId); if (!matchingDnsRecord.isPresent()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but no matching Cloudflare DNS Record was found!""); return false; } if (!matchingDnsRecord.get().isProxied()) { LOG.warn(""`edgeCacheDNS` was defined on the request, but {} is not a proxied DNS record!"", edgeCacheDNS); return false; } return cf.purgeCache( zoneId, Collections.singletonList( String.format(CACHE_TAG_FORMAT, request.getLoadBalancerService().getServiceId(), environment.getName()) ) ); } catch (CloudflareClientException e) { LOG.error(""Unable to invalidate Cloudflare cache for request {}"", request, e); return false; } }",edgeCacheDNS as a static variable since it's used a few times?,we already have the Stack so we can avoid a redundant read by calling getFreeIpaClientForStack instead of getFreeIpaClientByAccountAndEnvironment,a log line would be nice here,is it ok to be the empty string?,please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition,This seems brittle.,"If some but not all of these are null, that would suggest an unintentional error condition. Perhaps it's worth failing loudly.","I know this was like this when you got here but we can make it a bit more functional. Something like this: java return reverseDnsLookup(ipAddress).map(host -> { if (!host.endsWith(domain + ""."")) { logger.error(""Reverse DNS lookup on ip '{}' - resolved domain '{}' does not match '{}'"", ipAddress, host, domain); return false; } return true; }).orElseThrow(() -> new Exception(format(""Host not found for ip address '%s'"", ipAddress)));",We reuse the ignoresCase a lot with treating checks for the cloud platform. Lets put that in a variable so we can just do an enum comparison.,how expensive is this call? Should this be cached at all?,"How about this: if networkaddress.cache.ttl is -1 _and_ host names are being used for Riak node addresses, we set the TTL to 60 seconds as recommended everywhere on the internets. A setting could be added to override this behavior."
"private <V> void addCallback(CompletableFuture<V> cfuture, CommitData cd, OnSuccessInterface<V> onSuccessInterface) { cfuture.handleAsync((result, exception) -> { if (result != null) { try { onSuccessInterface.onSuccess(cd, result); return null; } catch (Exception e) { cd.commitObserver.failed(e); return null; } } else { cd.commitObserver.failed(exception); return null; } }, env.getSharedResources().getAsyncCommitExecutor()); }","If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }",You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...,"I don't think you want to give every callback every failure. I think you want to give a callback only its own failure and just stop processing. Most callbacks will show an error message to the user, and that's that.",You should have moved it here.,Is this wrapping necessary? Why not just pass out sub through the result?,"I wasn't sure if this was necessary, so looked into it and found this [SOQ](<LINK_1> For this issue I think nulling updates, weakNotifications, observedColumns, and columnsRead would be good. These can be found starting at [TransactionImpl line 109](<LINK_0>","If it's theoretically possible that ISPN might call these methods more than once (for a given transaction), then the implementation needs to do more than just ensure synchronized access to the methods: it needs to ensure the methods have an effect only once, the first time each method is called.",add an import instead of using fully qualified name,This can be removed now.,This isn't worth the effort. If an exception happens during onSuccess just let it go up the call stack and crash the event loop.,This isn't worth the effort. Just let it go up the call stack and crash the event loop.
"public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) { log.debug(""deleteAsyncQueryAndResultCollection""); Collection<AsyncQuery> asyncQueryList = null; try { asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> { EntityProjection asyncQueryCollection = EntityProjection.builder() .type(AsyncQuery.class) .filterExpression(filterExpression) .build(); Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope); Iterator<Object> itr = loaded.iterator(); while (itr.hasNext()) { AsyncQuery query = (AsyncQuery) itr.next(); if (query != null) { tx.delete(query, scope); } } return loaded; }); } catch (Exception e) { log.error(""Exception: {}"", e); } return asyncQueryList; }",The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).,you can directly check if loaded != null in the next line.,This can be moved outside the try block (by making it final).,This is too broad and is swallowing exceptions that need to be propagated.,You don't need to call run() here. Calling queryResult.get() should invoke queryResult.run(),Null check,Move all this math to a separate function: java boolean isTimedOut(AsyncQuery query) { .. },"Ideally, I think this is where the cache ought to be queried for entries. This would allow the same cache to be used for multiple engines (Fili, SQL, etc). I think the cache key generation logic itself could be common as well. The key could be derived from the Query object itself (rather than the generated SQL) plus data freshness key (which the query engine could surface).","Instead of using DBUtil, this could take the DefaultAysyncQueryDAO - and use the load object method there.",IOExceptions are handled by throwing a TransactionException in Elide. We should be consistent here.,"If this is what is causing the NPE, instead of passing null, we can create an empty HashMap here."
"public static void markNoteAsRead(final Note note) { if (note == null) { return; } if (note.isUnread()) { WordPress.getRestClientUtilsV1_1().decrementUnreadCount(note.getId(), ""10"", new RestRequest.Listener() { @Override public void onResponse(JSONObject response) { note.setRead(); NotificationsTable.saveNote(note); } }, new RestRequest.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { AppLog.e(AppLog.T.NOTIFS, ""Could not mark note as read via API.""); } }); } }",Let's do the same way @jleandroperez did on iOS here <LINK_0>,"It's unlikely that the note is null here, but better to have a check before replacing the note in the adapter.","Sorry, I missed this on my first pass. Is it possible to work this into the timer interval itself? It's nice that after a day we won't make a network request every x minutes but we're still launching the app to do nothing. It seems like the alarm shouldn't be enabled at all if the user isn't logged in or hasn't edited recently. The benefit of this change would be that code would only run for users who actually needed it instead of frequently for all users","is there a race condition? since runParagraph is a loop, what if we abort para 1 but there threadpool thread runs para 2?","Is it normal to have a an m named member used in this way? I always considered them to be private, so you would use something like event.noteId here.",Is it possible to break this out into a separate file as a subclass? I think adding too much to an Activity or Fragment is tempting but once we get a third card type in will start getting a bit hazy.,"Sure, add a private static final int DEFAULT_DECK_ID = 1;","We're running this service every time the app comes to foreground. What do you think if we use a RateLimitedTask, or something similar, that starts the service if last started time is > 30 minutes or so. That way we can avoid the overload of creating a new service, starting it, etc.",Please move this ) to the line above,Would it be better to hold this a member variable or maybe even break it out and put the resonsbility on the client?,"When settings a duration of actionable Snackbars, I suggest using AccessibilityUtils.getSnackbarDuration. It designed to provide a longer delay for users who have accessibility services enabled."
"public Set<String> map(Set<String> genres) { Set<String> tags = Sets.newHashSet(); for (String genre : genres) { if (genre.contains(""<LINK_0>"")) { tags.add(paTagMap.get(genre)); } } if (tags.size() == 1 && tags.contains(""film"")) { tags.add(""action""); } return tags; }",Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise,Why all this extra code with the StringBuilder here? What's wrong with TextUtils.join()? If it's for performance it just looks like premature optimization resulting in unnecessary code.,Better to reference the crawler attribute instead of using a hard coded string value: Crawler.Attributes.CATEGORIES,"This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use ""Code -> Reformat Code"" from AndroidStudio's menu. Thanks!","@dmzaytsev what is ""2"" in this case?",Why ++i? Unconventional.,"Is this the right abstraction level to throw RestApiExceptions? RestApiExceptions make sense when this is called in the context of the REST API, but not when called from other places like from the ChangeInserter.","You can achieve the same thing by calling doNotAquireClass(""org.scalatest"") on the builder... I think I'd prefer not to hard code exclusions for various random libraries in here.",Nit: space before ':',"Sorry Nick, I suggest you to track media details but noticed that our utility routine doesn't work for remote files. I suggest to remove this call here, and create just an empty properties Map. Maybe adding a TODO to improve the routine to take in consideration remote files as well as local files. Other than that I think it's ok and ready to be merged.",does the order not matter ? is sorting not something UI should do rather than the model ?
"public void checkWebJavaSpringCommands() { consoles.startCommandAndCheckResult(WEB_JAVA_SPRING, BUILD, ""build"", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, BUILD, ""web-java-spring:build"", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, ""web-java-spring:build and run"", ""Server startup in""); consoles.startCommandAndCheckApp(currentWindow, "" consoles.closeProcessTabWithAskDialog(""web-java-spring:build and run""); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, ""web-java-spring:run tomcat"", ""Server startup in""); consoles.startCommandAndCheckApp(currentWindow, "" projectExplorer.invokeCommandWithContextMenu( RUN, WEB_JAVA_SPRING, ""web-java-spring:stop tomcat""); consoles.selectProcessInProcessConsoleTreeByName(""Terminal""); terminal.typeIntoTerminal(""ps ax""); terminal.typeIntoTerminal(ENTER.toString()); terminal.waitExpectedTextNotPresentTerminal(""/bin/bash -c $TOMCAT_HOME/bin/catalina.sh""); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, DEBUG, ""web-java-spring:debug"", ""Listening for transport dt_socket at address: 8000""); }","let's make constant with ""web-java-spring:stop tomcat"" command: STOP_TOMCAT_COMMAND_ITEM_NAME","Defining ""//h2[text()='Health Check Booster']"" string as a constant will make the code clear, IMHO, and will allow to avoid duplication.","boolean strict = Boolean.getBoolean(""nuxeo.start.strict"")",Shouldn't you pass false on the call to runLibertyMojoDeploy?,Could this be replaced with a foreach ?,"Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: ""Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception."" So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?",":bug: this is not reliable. I presume you are attempting to somehow detect the case that a user ""did stuff"" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly:  java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured  (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)",The throws looks like overhead here.,I don't like this. I think it is important to have as little interference between tests and background jobs as possible. Turned this on by default will make many tests unreliable I am afraid.,Add a yield.,This can delegate to the two-argument createSystem variant.
"public abstract BufferedSink valueSink() throws IOException; public final JsonWriter jsonValue(@Nullable Object value) throws IOException { if (value instanceof Map<?, ?>) { beginObject(); for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { Object key = entry.getKey(); if (!(key instanceof String)) { throw new IllegalArgumentException( ""Map keys must be of type String: "" + key.getClass().getName()); } name(((String) key)); jsonValue(entry.getValue()); } endObject(); } else if (value instanceof List<?>) { beginArray(); for (Object element : ((List<?>) value)) { jsonValue(element); } endArray(); } else if (value instanceof String) { value(((String) value)); } else if (value instanceof Boolean) { value(((Boolean) value).booleanValue()); } else if (value instanceof Double) { value(((Double) value).doubleValue()); } else if (value instanceof Long) { value(((Long) value).longValue()); } else if (value instanceof Number) { value(((Number) value)); } else if (value == null) { nullValue(); } else { throw new IllegalArgumentException(""Unsupported type: "" + value.getClass().getName()); } return this; }",what does this do if key is null?,Same final question.,"Should check if value == null and then emit JSON null, like it is done by JsonWriter.jsonValue(...). suggestion if (value == null) { return nullValue(); } else { put(new JsonValue(value)); return this; }",Closing is an odd choice. What if you're writing JSON to a file that contains mixed data?,return value(value.booleanValue()) ?,I'd almost expect the opposite . . . if it's the default then we should serialize nulls?,why are you changing these?,I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); },"This is not safe: generator may have existing escapes user has specified, and this would just replace them.",catch on new-line,needsComma I think would be a better name than hasComma
"void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) { this.context = context; String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME; File dir = new File(modOutPath); if (dir.exists() == false) { dir.mkdirs(); } extractPrefetchFiles(dataSource); final String prefetchDumper = getPathForPrefetchDumper(); if (prefetchDumper == null) { logger.log(Level.SEVERE, ""Error finding parse_prefetch program""); return; } if (context.dataSourceIngestIsCancelled()) { return; } String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE; try { String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME ); parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath); createAppExecArtifacts(modOutFile); } catch (IOException ex) { logger.log(Level.WARNING, ""Error runing parse_prefetch or creating artifacts."", ex); } }",The output of this call should be checked and if it's false I think it should bail.,It would help when debugging with the logs if we listed both the IngestJob ID and the IngestJobPipeline ID. This applies throughout the package.,Are these files typically named the same across multiple data sources?,"If we are doing a REST import (for example), is there any way of viewing capturing this error? As it stands, it looks like there is no way (without looking at the GeoServer logs) of telling the difference between an empty remote directory and an error - both result in a completed import with no tasks/layers. Maybe an error field could be included in the import context, similar to tasks?","Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.",Does this method need to be public?,"I see that this dataFound field is yet another protected field in the super class. For this story, let's do the partial fix of adding a protected setter for the super class field and then this new code can use that instead of writing directly to the field.","As @bcarrier suggested, I would make knownPathIDs a set.","It's a little cleaner to build the path using Paths. Then you don't have to worry about File.separator. You need the \\NON-NLS at the end of this line or you could use ""OpenIDE-Module-Name"" from bundles.properties.","This should all go away when we throw only IngestModuleExceptions. And, we should never just print the stack. We need to log it or act on it.",java @Override protected void setUp() throws Exception { super.setUp();
"public void parsesInvalidIdField() throws IOException { final MemberProfileJson memberprofilejson = Mockito.mock(MemberProfileJson.class); Mockito.when( memberprofilejson.fetch( Mockito.anyString(), Mockito.anyString(), Mockito.any(Href.class) ) ).thenReturn( Json.createReader( new FileInputStream( PsLinkedinTest.class.getResource( ""linkedinTestUserInvalidId.json"" ).getPath() ) ).readObject() ); try { new PsLinkedin(memberprofilejson) .enter(REQUEST); } catch (final ClassCastException ex) { MatcherAssert.assertThat( ex.getMessage(), Matchers.containsString(""cannot be cast to"") ); throw ex; } }",@ikhvostenkov please name it json,@ikhvostenkov please name it just json,@ikhvostenkov please name it json,"@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.","What do you think about changing this to java assertEquals(""Qinghui Zhang, Editor, Surachai Supattapone, Editor"", doc.select("".review-history .decision-letter span[itemprop=name]"").get(0).text());  so that we catch an accidental trailing ,?","I would replace with java relation(""author"", TO_ONE","I think we're better off getting a Markdown instance from Github.Markdown() method, as it is in the other unit tests for the com.jcabi.github.mock package, i.e. use new MkGithub().markdown().",It would be better to stop container in finally block to guaranty that is stopped in case of exception during test execution,"Instead of using constant please use, for example, Tv.THREE",Can you please use the static import for these in all of the classes? It's convention to use static import for Junit methods because it reduces the verbosity and its more clear. <LINK_0>,"Why didn't we use MockPostRepository and save likedPost, then we won't have to deal with postId !"
"public Matcher<View> atPositionOnView(final int position, final int targetViewId) { return new TypeSafeMatcher<View>() { Resources resources = null; View childView; public void describeTo(Description description) { String idDescription = Integer.toString(recyclerViewId); if (this.resources != null) { try { idDescription = this.resources.getResourceName(recyclerViewId); } catch (Resources.NotFoundException var4) { idDescription = String.format(""%s (resource name not found)"", recyclerViewId); } } description.appendText(""with id: "" + idDescription); } public boolean matchesSafely(View view) { this.resources = view.getResources(); if (childView == null) { RecyclerView recyclerView = (RecyclerView) view.getRootView().findViewById(recyclerViewId); if (recyclerView != null && recyclerView.getId() == recyclerViewId) { childView = recyclerView.findViewHolderForAdapterPosition(position).itemView; } else { return false; } } if (targetViewId == -1) { return view == childView; } else { View targetView = childView.findViewById(targetViewId); return view == targetView; } } }; }",why var4? Resources.NotFoundException e would be a bit nicer..,Why the [Joda notation](<LINK_0>,"LogUtil -- I don't know what this means in practice; if it ever happens, I want more info :)",display is duplicate,"for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.",it should called read() by default,"You should be able to specify description.addProperty(""value"", findMethod(""getValue""), Representation.REF)",Can we make these static accessors? Lots of risk of typos.,Why not leave Representation.REF on condition for only the default representation?,better to use a view holder to get view,why do you need context var at getMyApp method's signature?
public I setContext(HttpRequest request) { this.request = GeneratedHttpRequest.class.cast(request); return (I) this; },Check for illegal arg or are we happy with a ClassCastException here?,"This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.",No need for super(),Shouldn't you be able to replace this with:  java return requestContext.getWebRequest()  If it's unset then there's a bug somewhere.,Please remove the public modifier,I think this is a bit too early. We support loading from many places other than the internet.,I would probably merge the two lines into one: isRequestContextActive.set(beanManager.getContext(RequestScoped.class).isActive()); Same goes for the other interceptor (AfterActivationInterceptor). Though its just my preference I guess :),this constructor can be package protected if it supposed to be used for test only,"IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts","Woa, I'm not sure I like this being public.",We need to optimize here (cache the event instance or something like this) - this would probably degrade the performance significantly.
"private <T extends Enum<T>> void registerStatistic(String statNameSuffix, StatisticType type, final OperationStatisticDescriptor<T> descriptor, final EnumSet<T> outcomes) { if (contextObject == null) { return; } Set<TreeNode> result = queryBuilder() .descendants() .filter(context(attributes(Matchers.<Map<String, Object>>allOf( hasAttribute(""type"", descriptor.getType()), hasAttribute(""name"", descriptor.getObserverName()), hasAttribute(""tags"", new Matcher<Set<String>>() { @Override protected boolean matchesSafely(Set<String> object) { return object.containsAll(descriptor.getTags()); } }))))) .filter(context(identifier(subclassOf(OperationStatistic.class)))) .build().execute(Collections.singleton(ContextManager.nodeFor(contextObject))); if (!result.isEmpty()) { for (TreeNode node : result) { String discriminator = null; Map<String, Object> properties = (Map<String, Object>) node.getContext().attributes().get(""properties""); if (properties != null && properties.containsKey(""discriminator"")) { discriminator = properties.get(""discriminator"").toString(); } String fullStatName = (discriminator == null ? """" : (discriminator + "":"")) + statNameSuffix; final OperationStatistic<T> statistic = (OperationStatistic<T>) node.getContext().attributes().get(""this""); registerStatistic(fullStatName, type, new ValueStatistic<Number>() { @Override public Number value() { return statistic.sum(outcomes); } }); } } }",Mutualize with the other matcher on tags,We should mutualize a hasTag (probably in stats),Replace by Collections.singleton,"you need to get the Transport from the AbstractProtocolServer. The service, only keeps the first instance instantiated by the endpoint.",You need to get the Transport from the RestServer. Same reason as above.,Any particular reason an import wasn't used here?,duplicate code starting at line 134,This should be a boolean... no reason to use Strings,"What if the filter itself contains a comma? (a CQL filter can contain a ""in"" operator that uses it, or might have a string literal containing it).","Where does this come from? It seems to be the wrong place to define this. An object should not need to care about how it is serialized. If anything, it should be in the attributesDelegate",could use CollectionUtils.isNotEmpty(featureMemberNodeNames)
"private void setPublicURIs(final FileSystem fileSystem) { final String[] uris = fileSystem.toString().split(""\\r?\\n""); final List<PublicURI> publicURIs = new ArrayList<>(uris.length); for (final String s : uris) { final int protocolStart = s.indexOf(""://""); publicURIs.add(getPublicURI(s, protocolStart)); } repo.setPublicURIs(publicURIs); }","Maybe using a constant here for ""://""","Better to return a new copy of the list. It's not obvious for the caller that this method modifies the list that is passed in. Allocating a new List is a cheap operation. ""Premature optimization is the root of all evil"".",RuntimeIOException maybe?,"It would be nice to have these new methods unit tested. Also String#replaceFirst is calling Pattern.compile internally. Based on how often we're expected to call this method, wouldn't it make sense to pre-compile the pattern in private static final field of this class?","I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.",Missing codes.,Spacing is off,Should this try to create a URI with the old logic when it's null for retro compatibility ?,"This should really be an ImmutableList. All the more since BaseVocabularyDecl iterates through it via indices (LinkedList is a SequentialList but not RandomAccess). (yes, I know, this is minor as it is probably only called once).","Don't use addFileUrls, just add to your urlList",Dont log at ERROR as there is nothing the user can do. Log a DEBUG or something and say in the error message that this exception is ignored.
"private void handleRelatedAlarms(OnmsAlarm situation) { if (!situation.isSituation()) { return; } alarmAssociationById.putIfAbsent(situation.getId(), new HashMap<>()); final Map<Integer, AlarmAssociationAndFact> associationFacts = alarmAssociationById.get(situation.getId()); for (AlarmAssociation association : situation.getAssociatedAlarms()) { Integer alarmId = association.getRelatedAlarm().getId(); AlarmAssociationAndFact assocationFact = associationFacts.get(alarmId); if (assocationFact == null) { LOG.debug(""Inserting alarm association into session: {}"", association); final FactHandle fact = getKieSession().insert(association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } else { FactHandle fact = assocationFact.getFact(); LOG.trace(""Updating alarm assocation in session: {}"", assocationFact); getKieSession().update(fact, association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } } Set<Integer> deletedAlarmIds = associationFacts.values().stream() .map(fact -> fact.getAlarmAssociation().getRelatedAlarm().getId()) .filter(alarmId -> !situation.getRelatedAlarmIds().contains(alarmId)) .collect(Collectors.toSet()); deletedAlarmIds.stream().forEach(alarmId -> { final AlarmAssociationAndFact associationAndFact = associationFacts.remove(alarmId); if (associationAndFact != null) { LOG.debug(""Deleting AlarmAssociationAndFact from session: {}"", associationAndFact.getAlarmAssociation()); getKieSession().delete(associationAndFact.getFact()); } }); }",suggestion deletedAlarmIds.forEach(alarmId -> {,ack vs association,This should probably be issued after the call to alarmDao#delete. Won't situation.getRelatedAlarms() still contain the given alarm we deleted.,why a change here?,Simplify method to: m_associatedAlarms.removeIf(associatedAlarm -> associatedAlarm.getRelatedAlarm().getId().equals(alarm.getId()));,Should this be an error?,"replaceThing is a private method and access the new thing handler already. So, if your replaceThing returns the thing handler of the second argument, there is no need to do it twice.",It's really hard to come up with a name for this.. not happy with this because it suggests action with DO but doesnt specify the action. I am unable to come up with any better though. Will post if I do.,Should propagate the interruption here Thread.currentThread().interrupt();,"I have been told some time ago that it is not the thing that is (or is not) initialized, it is the handler only. It is currently derived by the thing status, but that should be already abstracted by the isHandlerInitialized function above.","nit: unrelated in general it's better to make dedicated patches for cleanups, it's clearer when digging through the git history"
"public Obs saveObs(Obs obs, String changeMessage) throws APIException { if(obs == null){ throw new APIException(""Obs.error.cannot.be.null"", (Object[]) null); } if(obs.getId() != null && changeMessage == null){ throw new APIException(""Obs.error.ChangeMessage.required"", (Object[]) null); } handleExistingObsWithComplexConcept(obs); ensureRequirePrivilege(obs); if (obs.getObsId() == null || obs.getVoided()) { return saveNewOrVoidedObs(obs,changeMessage); } else if(!obs.isDirty()){ setPersonFromEncounter(obs); return saveObsNotDirty(obs, changeMessage); } else { Errors errors = new BindException(obs, ""obs""); new ObsValidator().validate(obs, errors); if (!errors.hasFieldErrors(""person"")){ setPersonFromEncounter(obs); return saveExistingObs(obs,changeMessage); } else{ throw new APIException(""Obs.error.PersonId.mismatch"", (Object[]) null); } } }","You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.",Isn't obs.getObsId() already tested on the previous line?,Why not just pass in only the message?,"This change is unnecessary, datatype is required, i would rather leave it the way it was before so that atleast a NullPointerException is thrown",do we need to split. I mean isn't there any method to get the uuid of method directly using a available method? If not this is fine.,unretire or unvoid?,Would be nice to also have an assertion here that the person objects are different just in case the test data changes,"Since the list contains 1 item, why not just get the first item instead of looping over the collection to check concept ids",you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...,Use RS_MAINTAINER instead of ALLOC_MAINTAINER ?,Index will build with stale data.
protected void onExportChanged() { boolean externalNetwork = (Boolean) getExport().getEntity(); getQos().setIsChangable(!externalNetwork); getAddQosCommand().setIsExecutionAllowed(!externalNetwork); String label = getNetworkLabel().getSelectedItem(); if (externalNetwork) { getNetworkLabel().setItems(new HashSet<String>()); } else { getNetworkLabel().setItems(dcLabels); } getNetworkLabel().setSelectedItem(label); },consider 'ternary if' here,Both are equivalent but Kanagaraj generally prefers use of !ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly) :),Is setting entity based on app_mode also required?,"Both of these lines should be moved into corresponding methods calculating the desired state according to the two dependencies, as I described in another file.",Please use networkClusters instead of getNetworkClusterList().getItems(),The reason the visibility of messageLabel is controlled form here is because the messageLabel is not part of the NetworkModel. All the other fields have a representation in NetworkModel so please control their visibility via the model (the model method for controlling the visibility is- setIsAvailiable(..)).,"logically the code is OK, but stopped me to read carefully twice :( Following has same outcome with less reading time consumed: StringHelper.isNotNullOrEmpty(label) ? label : null","Continuation of the comme?t on line #242 - Please notice 'messageLabel' and 'externalLabel' doesn't have representation in the model. The fields you're manipulating in 'onPhysicalNetworkChange()' do have, so please move this logic to the model.",please remove the 'this'.,"Why do you need two listeners (53-54), please move 'selectDefaultProvider()' to the callback of the first listener.","consider the following flow: - user selects a cluster on which the enableSinglePCI is disabled. - than the user selects the QXL driver which causes this ""displayProtocol_SelectedItemChanged"" to be called - result: the enableSinglePCI will be enabled even the cluster does not support it What you need to do is to have some method like ""updateSinglePciEnabled()"" which will be called from the following places: - displayProtocol_SelectedItemChanged - dataCenterWithClusterSelectedItemChanged - oSType_SelectedItemChanged And inside this method handle all the conditions."
"protected void executeCommand() { setVds(null); if (getVds() == null) { setCommandShouldBeLogged(false); log.infoFormat(""SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore."", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } if (getVds().getStatus() != VDSStatus.Maintenance) { setCommandShouldBeLogged(false); log.infoFormat(""SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance."", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString()); if (result) { getVds().setStatus(VDSStatus.Down); if (!getParameters().getKeepPolicyPMEnabled()) { getVds().setPowerManagementControlledByPolicy(false); } getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData()); } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) { FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop); parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled()); Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext()); } getReturnValue().setSucceeded(result); }",power down,getActionState,Why do we need to check that gluster service status here? Shouldn't this be checked in MaintenanceVdsCommand or HostMaintenanceCallback itself?,i meant that the if statement should check for the return value of the GlusterHostRemove since getSucceeded will always return true here (same for add as well),"Please reformat: int secondsLeftToNextPmOp = (isInternalExecution() || (getParameters().getParentCommand() == VdcActionType.RestartVds)) ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp( getVds().getName(), event);","just set result to false first, and use that all over this function",Do we really need to check? Can't we always pass stopGlusterServices=true and leave the logic to really stop ore not to MaintenanceVdsCommand/HostUpgradeCallback,You could simply use getVdsGroup() if you extend VdsCommand,"As Dan asked, if nothing is done please change to AuditLogType.UNASSIGNED",that's unneeded..it will be false by default.,I think now it is more easy to read if we would use the common code structure like: switch (getActionState()) { case EXECUTE: return getSucceeded() ? ...
public Optional<Symbol> resolveMember(String memberName) { if (types.stream().anyMatch(type -> type instanceof RuntimeType && ((RuntimeType) type).hasUnresolvedHierarchy())) { return Optional.empty(); } Set<Optional<Symbol>> resolved = types.stream() .map(t -> t.resolveMember(memberName)) .filter(Optional::isPresent) .collect(Collectors.toSet()); if (resolved.isEmpty()) { return Optional.empty(); } else if (resolved.size() == 1) { return resolved.iterator().next(); } return Optional.of(AmbiguousSymbolImpl.create(resolved.stream().map(s -> s.orElse(null)).filter(Objects::nonNull).collect(Collectors.toSet()))); },"I don't think ""resolveMember"" should create a new symbol. We should find another approach","You should annotate parameter with @Nullable , or if you don't need to handle null argument, you don't need ofNullable",why 2 operations ? only one flatmap is sufficient no ?,Just add them all unconditionally and then remove None.INSTANCE after.,Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.,Logic: Similar change to LazyFluentIterable#first(),Why are you changing this to ImmutableSet?,"Don't we risk that this loops infinitely in cases like the following? If so, we might fix this by putting an upper bound (100?).  type A:B type B:A",I would just not negate the condition.,"Minor improvement: you could use suggestion if (!visitedSymbols.add(symbol) || symbol.type().is(""java.lang.Object"")) {  instead",Similar change as first(count).
"public static BlobProperties buildBlobProperties(Map<String, Object> args) throws RestServiceException { Account account = (Account) args.get(InternalKeys.TARGET_ACCOUNT_KEY); if (account == null) { throw new RestServiceException(InternalKeys.TARGET_ACCOUNT_KEY + "" is not set"", RestServiceErrorCode.MissingArgs); } Container container = (Container) args.get(InternalKeys.TARGET_CONTAINER_KEY); if (container == null) { throw new RestServiceException(InternalKeys.TARGET_CONTAINER_KEY + "" is not set"", RestServiceErrorCode.MissingArgs); } String serviceId = getHeader(args, Headers.SERVICE_ID, true); String contentType = getHeader(args, Headers.AMBRY_CONTENT_TYPE, true); String ownerId = getHeader(args, Headers.OWNER_ID, false); long ttl = Utils.Infinite_Time; String ttlStr = getHeader(args, Headers.TTL, false); if (ttlStr != null) { try { ttl = Long.parseLong(ttlStr); if (ttl < -1) { throw new RestServiceException(Headers.TTL + ""["" + ttl + ""] is not valid (has to be >= -1)"", RestServiceErrorCode.InvalidArgs); } } catch (NumberFormatException e) { throw new RestServiceException(Headers.TTL + ""["" + ttlStr + ""] could not parsed into a number"", RestServiceErrorCode.InvalidArgs); } } return new BlobProperties(-1, serviceId, ownerId, contentType, isPrivate(args), ttl, account.getId(), container.getId()); }",Let's make this InternalServerError,"why accountId and containerId is not verified from BlobProperties, whereas every other property is verified?",stray system out,Constant,"You should be able to replace the upper code by: java containerName = Optional.ofNullable(args.get(CONTAINER_NAME)).filter(container -> ! container.toString().isEmpty()).orElseThrow( () -> new IllegalArgumentException(""You have to specify a container name. Empty value is not allowed."");","Got confused, does BP include flag and dcId?","Maybe I had a misunderstanding, but seems aid and cid are serialized last, but deserialized first in case Version2? Would this be a problem?","For a get blob response, this should be set as the HTTP standard Content-Encoding header instead of x-ambry-content-encoding",Check null case?,why is this case allowed ?,"Was the change from parseLong to getLong intentional? It's making the number parsing more tolerant, which isn't bad in principle but it means the long parsing is now more tolerant than the number parsing in the MemorySizeParser, which might be confusing."
"public AlphaRejectBlocksNode(Context context) { Config config = context.get(Config.class); DisplayResolutionDependentFBOs displayResolutionDependentFBOs = context.get(DisplayResolutionDependentFBOs.class); worldRenderer = context.get(WorldRenderer.class); renderQueues = context.get(RenderQueuesHelper.class); wireframeStateChange = new SetWireframe(true); RenderingDebugConfig renderingDebugConfig = config.getRendering().getDebug(); new WireframeTrigger(renderingDebugConfig, this); playerCamera = worldRenderer.getActiveCamera(); addDesiredStateChange(new LookThrough(playerCamera)); addDesiredStateChange(new BindFBO(READONLY_GBUFFER, displayResolutionDependentFBOs)); addDesiredStateChange(new EnableMaterial(CHUNK_SHADER.toString())); chunkShader = getMaterial(CHUNK_SHADER); }",1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?,"Ok, with some difficulty, I'm going along with your thinking to see where that leads us. However, I'd like this to become: .getGBufferPair().getWriteOnlyFbo().","I didn't highlight this issue in previous nodes as it isn't overly important but perhaps we might want to decide if to consistently initialize the two rendering configs either by first obtaining the Config object from the context or, as you do here, by having everything in one line. I guess on one hand I feel that having a local variable helps with the readability given that getRendering() and getDebug() are a bit ambiguous as method names go. On the other I like the compactness of the one-line in this case. I'd say I'd prefer readability over compactness though. What do you think?",Let's rename these - setTerrainNormalsInputTexture - setTerrainHeightInputTexture please.,This line can go with the playerCamera line below.,Careful. This imply face culling must be enabled. We need an additional state change in this list.,"I'd move this above the shader-related lines, as it is related to the FBO instead.",Let's reorganize the section above so that there is the least distance between the line where the variables are first assigned and where the variables are used. I.e. the worldRenderer line can be followed by the playerCamera assignment.,"Generally speaking a RenderNode should somehow find everything it needs. This way the DAG remains agnostic of what a node does or needs and can treat all nodes the same. So: 1. let the node find the renderingConfig and the backdropProvider via a context object and let it obtain the playerCamera from the WorldRenderer instance. 2. GraphicState is a class I created to collect easily recognizable opengl directives in one place. Earlier they were ""visually polluting"" the renderer code making it hard to get an overview - like a picture with too many details and no focus to guide the eye. However, as we divide the code of the existing rendering engine into RenderNodes, it will make sense to move those gl directives into the nodes, near where it's needed. The code within a node will never be horribly big, probably. So, what you could do is to place the code currently in GraphicState.preRenderSetupSceneShadowMap() and GraphicState.postRenderCleanupSceneShadowMap() within the ShadowMapNode, eliminating the dependency on the graphicState instance. Word of caution though: I remind you that at this stage generating the ShadowMap or executing any other step in the rendering engine might still rely on state changes occurred much earlier in the flow of execution. Until every state change is first done and then undone immediately after use, leaving to the DAG to optimize the process, you must ensure that RenderNodes are executed in the current order. Let me know if you need me to further clarify this.","Move up, please.","So, do you expect the application to crash in those circumstances?"
"public static String print(Node n, String encoding) { if (n == null) { return null; } try { Document document = null; if (n instanceof Document) { document = (Document) n; } else { document = n.getOwnerDocument(); } StringWriter stringOut = new StringWriter(); DOMImplementationLS domImpl = (DOMImplementationLS) document.getImplementation(); LSSerializer lsSerializer = domImpl.createLSSerializer(); lsSerializer.getDomConfig().setParameter(XML_DECLARATION, false); LSOutput lsout = domImpl.createLSOutput(); lsout.setEncoding(encoding); lsout.setCharacterStream(stringOut); NodeList childNodes = n.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { lsSerializer.write(childNodes.item(i), lsout); } return stringOut.toString(); } catch (DOMException | LSException e) { LOGGER.debug(e.getMessage(), e); } return null; }","Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?","I hope, you are right.",Could you replace this and any occurrences of printStackTrace with logger.warn in the code (since you are making other fixes)? Bindings should not print to stdout or stderr but instead use log4j.,Are you using tab for indentation?,"We do not close this stream nowhere, or am I missing something?",extract method,"don't write to std out. use LOG.warn/error/info/debug, as appropriate. Also, do we want to return empty string in the case that there's a TransformerException? Or should the exception be propagated?",Use a logger object.,"subsystemWriters should now be a final local var in marshalAsXml. Then there is no need for the instance field any more and no need for the clear() call. If it's an instance var the ""clear"" call becomes a possible concurrency issue some day, e.g. concurrent CLI requests to read-config-as-xml.  final Map<String, XMLElementWriter<SubsystemMarshallingContext>> subsystemWriters = new HashMap<>(); ModelMarshallingContext extensibleModel = new ModelMarshallingContext() {","Simply: ""return builder.parse(id);""",overload please
"public void onCompletion(Void result, Exception exception) { callbackTracker.markOperationEnd(); if (exception == null) { try { RestMethod restMethod = restRequest.getRestMethod(); logger.trace(""Forwarding {} to the IdConverter/Router"", restMethod); switch (restMethod) { case GET: String receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); InboundIdConverterCallback idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, getCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case HEAD: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, headCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case DELETE: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, deleteCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; default: exception = new IllegalStateException(""Unrecognized RestMethod: "" + restMethod); } } catch (Exception e) { exception = extractExecutionExceptionCause(e); } } if (exception != null) { submitResponse(restRequest, restResponseChannel, null, exception); } callbackTracker.markCallbackProcessingEnd(); }",Why not extract receivedId before switch block? (reduce the duplicate code),"This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message",Why do you set headers irrespective of exception or not,"I have two questions here: 1. It is confusing seems that this convert() method does nothing here. I guess in the future there will be more meaningful method in the else block. 2. If 1 is true, the actual conversion method could be async (since you are returning Future here). If that is the case, time stamp in line 68 may not be accurate.",can you add blobId to the msg.,Use an AtomicBoolean and compareAndSet,this is wrong. HEAD by definition cannot return any body. Just remove the user metadata code completely from here - HEAD should be returning only blob properties anyway.,"redundant cast, can remove (UndeleteRequest)",is this supported in older java versions? Are we good to have this,don't we need to update metrics for this as well.,a quick question. Do we really need to update the idConverterProcessingTimeInMs twice since eventually the finally logic will do it.
@OnClick(R.id.gallery_cta_button) void onTranslateClick(View v) { GalleryItemFragment item = getCurrentItem(); if (item == null || item.getImageTitle() == null || item.getMediaInfo() == null || item.getMediaInfo().getMetadata() == null) { return; } if (imageEditType != null) { switch (imageEditType) { case ADD_TAGS: startTagsEdit(item); break; case ADD_CAPTION_TRANSLATION: startCaptionTranslation(item); break; default: startCaptionEdit(item); } } },Feels like this null check can be included above.,"This is now hardcoding the string ""Uploaded by: "" so it cannot be translated",Replace with lambda?,Could avoid code duplication (lines 184 and 188) by combining if statements,"Since both conditions show the same toast, we could make this if (mediaUri == null || !addMedia(mediaUri)).",Not needed I guess?,please replace with TextUtils.isEmpty (i.e. instead of the static import that's there now),"This shouldn't be a warning-level log. Also, is this log really necessary? We already generate quite a bit of logging per upload, with this there are three logs per tick:  05-05 08:27:02.034 31057-12701/org.wordpress.android.beta D/WordPress-API: Dispatching action: MediaAction-UPLOADED_MEDIA 05-05 08:27:02.082 31057-31057/org.wordpress.android.beta W/WordPress-MEDIA: EDITPOSTACTIVITY: 65 - 0.9653928 05-05 08:27:02.093 31057-31057/org.wordpress.android.beta D/WordPress-MEDIA: 65 - progressing 0.9653928  If they're helpful while working on async we could keep them but keep track that we should reduce them later - these logs make it into helpshift reports, and I think there's a size limit that can prevent earlier useful logs from being preserved.",I find it even easier to read without the (...),suggestion mPreviousButton.setEnabled(isInVisualPreview() && mPosition != 0);  We'll need to add this condition so that the previous button isn't _always_ enabled when toggling from visual view to HTML view.,uploadItem.setImageQuality(ImageUtils.IMAGE_KEEP); should be on a separate line to the { unless it is a statement lambda ie one method call or value For example deleteThisPicture(); below can have the braces and colon removed to become a statement lambda. It can also go further and become a method reference ::deleteThisPicture because the input parameters () are the same as the parameter for the method deleteThisPicture()
"private static String toHex(String s) { StringBuffer buf = null; try { buf = new StringBuffer(s.getBytes(""UTF-8"").length); for (byte x : s.getBytes(""UTF-8"")) { buf.append(""%""); buf.append(Integer.toHexString(x & 0xFF)); } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return buf.toString().toUpperCase(); }",Extra space,I'm not totally sure it is necessary but I would close the writer or use a try-with-resources.,Just do sw.toString().,should we add a more detailed log and set currentProductVersion to null,Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,technically if you're PrintWriter throws the exception your StringWriter will never be closed :-),I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET,Better to log instead of e.printStackTrace,can be static,This is printed out once on class loading? We can prettify later.,"Can we make these static? Also, missing docs"
"private SmooshedWriter delegateSmooshedWriter(final String name,final long size) throws IOException { final File tmpFile = new File(baseDir, name); createFiles.add(tmpFile); return new SmooshedWriter () { private int currOffset = 0; private boolean open = true; private final FileOutputStream out = new FileOutputStream(tmpFile); @Override public void close() throws IOException { open = false; out.close(); files.add(tmpFile); if(!writerCurrentlyInUse ) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { FileChannel channel = out.getChannel(); int bytesWritten = channel.write(buffer); return addToOffset(bytesWritten); } @Override public int write(InputStream in) throws IOException { return addToOffset(Ints.checkedCast(java.nio.file.Files.copy(in, tmpFile.toPath()))); } public int addToOffset(int numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return numBytesWritten; } @Override public boolean isOpen() { return open; } }; }","This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name ""verify"" which makes it clear that the intent of the method is to do some state checks...","This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)",suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.,yeah I don't think that's needed. Probably just misunderstanding of atomicity there.,"We can make this public, let the tests call it directly.",closeQuietly or whatever its called?,do we want eventually to have a writeTo(ByteBuffer) ?,UnsupportedOperationException (same with others),Are we sure this will not introduce risk of deadlock?,Use a compareAndSet here. Do we need synchronization on the flush method at all?,make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
"public DnsClientImpl(VertxInternal vertx, DnsClientOptions options) { Objects.requireNonNull(options, ""no null options accepted""); Objects.requireNonNull(options.getHost(), ""no null host accepted""); if (options.getPort() < 1) { throw new IllegalArgumentException(""DNS client port "" + options.getPort() + "" must be > 0""); } if (options.getQueryTimeout() < 0) { throw new IllegalArgumentException(""DNS client timeout "" + options.getQueryTimeout() + "" must be > 0""); } this.options = new DnsClientOptions(options); ContextInternal creatingContext = vertx.getContext(); if (creatingContext != null && creatingContext.isMultiThreadedWorkerContext()) { throw new IllegalStateException(""Cannot use DnsClient in a multi-threaded worker verticle""); } this.dnsServer = new InetSocketAddress(options.getHost(), options.getPort()); this.vertx = vertx; Transport transport = vertx.transport(); actualCtx = vertx.getOrCreateContext(); channel = transport.datagramChannel(InternetProtocolFamily.IPv4); channel.config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true); channel.config().setMaxMessagesPerRead(1); channel.config().setAllocator(PartialPooledByteBufAllocator.INSTANCE); actualCtx.nettyEventLoop().register(channel); if (options.getLogActivity()) { channel.pipeline().addLast(""logging"", new LoggingHandler()); } channel.pipeline().addLast(new DatagramDnsQueryEncoder()); channel.pipeline().addLast(new DatagramDnsResponseDecoder()); channel.pipeline().addLast(new SimpleChannelInboundHandler<DnsResponse>() { @Override protected void channelRead0(ChannelHandlerContext ctx, DnsResponse msg) throws Exception { int id = msg.id(); Query query = inProgressMap.get(id); if (query != null) { query.handle(msg); } } }); }",I think this test should be moved to options instead,Can't see where this is ever unregistered. Memory leak?,Shouldn't they be protected not public?,Why is the clusterHost required?,should be DEFAULT_JMX_ENABLED,"Please re-add the createChannelPool(final ChannelPool.ChannelFactory channelFactory, int count) method","Perhaps you should keep this, and at the close of the pool, then also close the PRNG object to avoid re-seediing in background when not needed.",This is initialized below on line 97,"no need to use String.format as there is no parameter. Either provide directly throw new IllegalArgumentException(""Port must be greater than 0""); or maybe improve message with somethign like: throw new IllegalArgumentException(String.format(""Port must be greater than 0 (provided {0})"", port));",nit: space between if and (,Is this related to metrics? Or something else?
"public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager( getResources().getInteger(R.integer.news_fragment_column_count), StaggeredGridLayoutManager.VERTICAL); getListView().setLayoutManager(layoutManager); mAdapter = new NewsAdapter(getActivity(), ((GdgActivity) getActivity()).getGoogleApiClient()); setRecyclerAdapter(mAdapter); setOnRefreshListener(this); final String plusId = getArguments().getString(Const.EXTRA_PLUS_ID); if (Utils.isOnline(getActivity())) { new Builder<>(String.class, Activities.class) .addParameter(plusId) .setOnPreExecuteListener(new CommonAsyncTask.OnPreExecuteListener() { @Override public void onPreExecute() { setIsLoading(true); } }) .setOnBackgroundExecuteListener( new CommonAsyncTask.OnBackgroundExecuteListener<String, Activities>() { @Override public Activities doInBackground(String... params) { Activities feed = (Activities) App.getInstance().getModelCache().get(Const.CACHE_KEY_NEWS + params[0]); if (feed == null) { feed = getActivityFeedSync(params[0]); } return feed; } }) .setOnPostExecuteListener(new CommonAsyncTask.OnPostExecuteListener<String, Activities>() { @Override public void onPostExecute(String[] params, Activities activityFeed) { if (activityFeed != null) { mAdapter.addAll(activityFeed.getItems()); setIsLoading(false); } } }) .buildAndExecute(); } else { App.getInstance().getModelCache().getAsync(Const.CACHE_KEY_NEWS + plusId, false, new ModelCache.CacheListener() { @Override public void onGet(Object item) { Activities feed = (Activities) item; if (isAdded()) { Snackbar snackbar = Snackbar.make(getView(), R.string.cached_content, Snackbar.LENGTH_SHORT); ColoredSnackBar.info(snackbar).show(); } mAdapter.addAll(feed.getItems()); setIsLoading(false); } @Override public void onNotFound(String key) { showError(R.string.offline_alert); } }); } }","Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.","Since you use this variable only once and only here, it should be a local field suggestion final boolean showDescriptionOnLoad = PreferenceManager.getDefaultSharedPreferences(activity)",Please move this ) to the line above,Shouldn't it be ACTIVITY_RESULT_IMAGE_TAG_ADDED? (or maybe it can be removed?),"Empty catches always wig me out, can we at least have an info log?",What are we doing in this custom margin code that we can't do in XML?,let's rename final PromoDialog asyncPromoDialog to final PromoDialog gbInformativeDialog,Why capitalised?,Why is this needed?,Nice to have: @LayoutRes annotation,Local variable 'builder' is redundant.
"public String[] getSupportedExtensions() { return new String[] { ""at3"", ""oma"", ""aa3"", ""at9"", }; }",@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.,"@Nadahar Isn't ""**oga**"" already there ?",I continue to think that **aifc** should to be here...,"You can change the 28 case to a default case, and remove this.",This struck me as odd - why would you want to create a schema for Kite's Format class? Could we have a simple class in the CLI package to use as an example?,"maybe we can simply return 'null' here as supportedExts is not set anywhere, so it will be null anyway... as a result that variable does not have to be declared at all?","@Nadahar Right, text/vtt, i was too fast...my bad.",don't we hv to send subscription related events?,I think version.value() might produce NullPointerEception here in case only ApiGroup annotation is provided.,Import?,Why this change?
"public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }",SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,SetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE,"if both have a non-empty list, the assertion is true replace it with assertTrue(configurationObjectDto.getConfigurationFlags().getConfigurationFlag().isEmpty())",asserttrue,"In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the installationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.",I think you should check if the response is OK? Otherwise a Not OK is also valid for a assertNotNull.,asserttrue....,"Prefere to write meaningful names, setPushSetupSmsAsyncRequest.","The method name has been refactored, but the log statement still uses the old name.",SetAlarmNotifications should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
"public String buildRunCommand() { final List<String> runCommand; if (importsZip == null || abstractEntryClient instanceof ToolClient || Objects.equals(languageType, LanguageType.WDL)) { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), ""--inputs"", provisionedParameterFile.getAbsolutePath()); } else { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), ""--inputs"", provisionedParameterFile.getAbsolutePath(), ""--imports"", importsZip.getAbsolutePath()); } System.out.println(""Calling out to "" + LAUNCHER_NAME + "" to run your workflow""); final String[] s = { ""java"", ""-jar"", exectionFile.getAbsolutePath(), ""run"" }; List<String> arguments = new ArrayList<>(); arguments.addAll(Arrays.asList(s)); arguments.addAll(runCommand); final String join = Joiner.on("" "").join(arguments); System.out.println(""Executing: "" + join); return join; }","You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.","check if there's an enum for ""WDL"", possibly use equalsignorecase",This will fail if there is no argument after --json; I don't think you want to do that here. You should probably call optVal and only do the check if the value is not null.,Move to internal utility class to ensure the URL validations are consistent and avoid duplication?,Why remove this? -p= is a lot easier to remember and type than -Dcom.carolinarollergirls.scoreboard.jetty.JettyServletScoreBoardController.port=. I'd rather think about adding something like -l and --localhost for that property.,would use either replaceFirst or substring(argPrefix.length() for the unlikely case that someone use a strange name for its build arg :),Could you rename importMap to something that reflects the purpose of this object? It's definitely not a map.,"I'm curious, why did you choose to make this private?",Error message doesn't match what you're actually checking (same with the previous two tests),You should use LOG.error,Can we create constants for these strings? They are being used more than once.
"public Mono<CloseableChannel> start(ConnectionAcceptor acceptor, int mtu) { Objects.requireNonNull(acceptor, ""acceptor must not be null""); return server .handle( (request, response) -> { transportHeaders.get().forEach(response::addHeader); return response.sendWebsocket( null, Math.max(DEFAULT_FRAME_SIZE, mtu == 0 ? FRAME_MAX_SIZE : mtu), (in, out) -> { DuplexConnection connection = new WebsocketDuplexConnection((Connection) in); if (mtu > 0) { connection = new FragmentationDuplexConnection( connection, ByteBufAllocator.DEFAULT, mtu, false); } return acceptor.apply(connection).then(out.neverComplete()); }); }) .bind() .map(CloseableChannel::new); }",what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?,As discussed this may result in early disposal of response before the inner response-body is fully consumed.,Seems like the buf.retain() is better put here.,we should use getAndSet(null) here to release the reference as well.,Missing check here for composer being null?,This method could call writeMutationsAsync(List<Mutation>),Release needs to happen here as well.,Shouldn't this return Flux.error(e) ?,"Bad rebase: this should be removed now, because of return Statement on line 138 below.",Several methods in this class do not need to be public and can be package local,"The cleaning case is handled in buffer == null branch on line 137 below. I would expect to add also closing of input stream there, where the output stream is closed: try { in.close(); out.close(); } finally { [...]"
"private ClusteringModel pmmlClusteringModel(KMeansModel model, Map<Integer,Long> clusterSizesMap) { ClusteringModel clusteringModel = new ClusteringModel(AppPMMLUtils.buildMiningSchema(inputSchema), new ComparisonMeasure(ComparisonMeasure.Kind.DISTANCE) .withMeasure(new SquaredEuclidean()), MiningFunctionType.CLUSTERING, ClusteringModel.ModelClass.CENTER_BASED, model.clusterCenters().length) .withNumberOfClusters(model.k()); if (initializationStrategy.equals(KMeans.K_MEANS_PARALLEL())) { clusteringModel.setAlgorithmName(""K-Means||""); } else if (initializationStrategy.equals(KMeans.RANDOM())) { clusteringModel.setAlgorithmName(""random""); } Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { FieldName field = FieldName.create(""field_"" + i); clusteringModel.getClusteringFields().add( new ClusteringField(field).withCompareFunction(CompareFunctionType.ABS_DIFF)); clusteringModel.getClusters().add(toCluster(clusterCenters[i], i, (int)clusterSizesMap.get(i).longValue())); } return clusteringModel; }",call intValue() and then there is no cast,GraphBased is not available,this change also needs to be made in KMeansPMMLUtils.read(),"Weight init, Keras -> DL4J mapping: glorot_normal is xavier glorot_uniform is xavier_uniform he_normal is relu he_uniform is relu_uniform Normal and lecun uniform might map uniform and sigmoid uniform? check math on that",quasiIdColumns and infoTypeNames  should be inlined,Please check guideline: <LINK_0>,Where do the results go?,"Not a big fan of ""friendly"" for scope. Could you do an explicit protected scope?",add a System.exit(-1) after the usage output,I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.,iteration = 1 should go after the logging.
"private List<Target> computeTargets(final ArgumentParser parser, final List<String> explicitEndpoints, final List<String> domainsArguments, final String srvName) { if (explicitEndpoints != null && !explicitEndpoints.isEmpty()) { final List<Target> targets = Lists.newArrayListWithExpectedSize(explicitEndpoints.size()); for (final String endpoint : explicitEndpoints) { targets.add(ExplicitTarget.from(URI.create(endpoint))); } return targets; } else if (domainsArguments != null && !domainsArguments.isEmpty()) { final Iterable<String> sites = parseDomains(domainsArguments); return SrvTarget.from(srvName, sites); } else if (!cliConfig.getMasterEndpoints().isEmpty()) { final List<URI> cliConfigMasterEndpoints = cliConfig.getMasterEndpoints(); List<Target> targets = Lists.newArrayListWithExpectedSize(cliConfigMasterEndpoints.size()); for (final URI endpoint : cliConfigMasterEndpoints) { targets.add(ExplicitTarget.from(endpoint)); } return targets; } else if (!cliConfig.getSitesString().isEmpty()) { final Iterable<String> sites = parseDomainsString(cliConfig.getSitesString()); return SrvTarget.from(srvName, sites); } handleError(parser, new ArgumentParserException( ""no masters specified. Use the -z or -d option to specify which helios "" + ""cluster/master to connect to"", parser)); return ImmutableList.of(); }",I think you can probably change the return type to List<? extends Target>,"Empty targets cannot exist. IMO, return null would be enough.",intentional?,Did you check if here is any chance to share code with the warning generation?,"no need to call String.format yourself, there is an overload of checkArgument that does:  public static void checkArgument(boolean expression, @Nullable String errorMessageTemplate, @Nullable Object... errorMessageArgs)",To handle cases where nonProxyHosts is empty or absent perhaps this needs a null/empty check to avoid --noproxy=null or --noproxy=  ?,What's the point of throwing UnknownHostException and caching it within few lines?,pleas use MoreCollectors.toImmutableSet() directly,F.isEmpty(),Lines 95-102 should be at the beginning of the execute method rather than in an accessor.,"I tend to don't like variable re-affectation.... Here I would prefer a variable called ""mutableDomains"" to be created rather than seing domains reused. By the way, nice spot."
"void processNotification(OSNotification originalNotification, @Nullable OSNotification notification) { OneSignal.onesignalLog(OneSignal.LOG_LEVEL.DEBUG, ""processNotification called from Thread: "" + Thread.currentThread().toString()); if (notification != null) { boolean display = isStringEmpty(notification.getBody()); if (!display) { notDisplayNotificationLogic(originalNotification); } else { notificationJob.setNotification(notification); NotificationBundleProcessor.processJobForDisplay(this, isBackgroundLogic); } if (isRestoring) OSUtils.sleep(100); } else { notDisplayNotificationLogic(originalNotification); } }",This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?,Why don't you call Thread.currentThread().interrupt() to restore the interrupted status?,This test is now taking ~35 seconds to complete when it wasn't before. I investigated this a bit and it is due to the Thread.sleep in notificationWillShowInForeground in the com.test.onesignal.GenerateNotificationRunner$NotificationExtensionService_workTimeLongerThanTimeout class never being interrupted. The other app specific one notificationWillShowInForeground is being interrupted correctly however.,"Need to compute end time outside of a while loop for this instance of i and compute the remaining time inside. Interruption should loop back for this particular loop. Outside the overall for(), propagate the interruption in a finally clause",This will run once every 500ms so there should be a loop sending all messages available at the start of the run. Just one seems delaying message delivery unnecessarily and substantially.,Took some eye squinting to get what this is doing. Might be a good idea to extract this and name it notifyFirstThenThrottle or something more descriptive.,do you want to create a new list if its null?,can we not use polymorphic deserialization here?,any reason for using a different api for new Notification?,Workbench.getDisplay,Why not natively subscribe with a subscriber that forwards to the action?
"public void missingMapping(RegistryEvent.MissingMappings<Item> event) { for (MissingMappings.Mapping<Item> entry : event.getAllMappings()) { if (entry.key.toString().equals(""minecraft:totem"")) { ResourceLocation newTotem = new ResourceLocation(""minecraft:totem_of_undying""); entry.remap(ForgeRegistries.ITEMS.getValue(newTotem)); } if (entry.key.toString().equals(""forge:bucketFilled"")) { ResourceLocation newBucket = new ResourceLocation(""forge:bucket_filled""); entry.remap(ForgeRegistries.ITEMS.getValue(newBucket)); } } }",I'm pretty sure it ends up being lower cased because the registries do not support capital letters.,Spacing java for (FMLMissingMappingsEvent.MissingMapping evt : event.getAll())  The variable is better called entry instead of evt (event),What's that one for? I can't see any assignments to it...,"It's quite unclear that there are actually two nested forEachs here, I would suggest using a -> {} block to make it more explicit.",same here 2 lines,"Add a single mod ID filter at the top, can save the whole effort of the loop if its not our mod",formatting,So there should be multiple keywords? If that's the case then the variable should be keywords instead of keyword,camelCase,"wut Okay, I fail to understand this. Why are you retrieving all spawnConfigs, instead of retrieving all musicConfigs and soundConfigs?",I'd rename this to something like commaSeparatedModules so it's immediately clear what's going on with the stream calls :)
"public ProductInfo updateProduct(String productId, ProductInfo pinfo) { if (productId == null) { throw new IllegalArgumentException(""productId is null""); } if (pinfo == null) { throw new IllegalArgumentException(""pinfo is null""); } ProductData pdata = this.productMap.get(productId); if (pdata == null) { throw new IllegalStateException(""product does not exist: "" + productId); } Collection<ProductContentData> pcdata = this.resolveProductContent(pdata.getProductContent()); if (pcdata != null) { pdata.setProductContent(pcdata); } if (pinfo.getName() != null) { pdata.setName(pinfo.getName()); } if (pinfo.getMultiplier() != null) { pdata.setMultiplier(pinfo.getMultiplier()); } if (pinfo.getAttributes() != null) { pdata.setAttributes(pinfo.getAttributes()); } if (pinfo.getDependentProductIds() != null) { pdata.setDependentProductIds(pinfo.getDependentProductIds()); } if (pinfo.getBranding() != null) { pdata.setBranding(this.resolveBranding(pinfo.getBranding())); } this.updateProductContentMappings(pdata); pdata.setUpdated(new Date()); return pdata; }",Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata),StringUtils.isBlank?,doppel space after equal sign.,"This block has shown up in another PR, which is a sign that we have dependent work, and is something we should strive to avoid in most cases. Additionally, database operations are slow, and lookups should be avoided in loops if at all possible. Change this to a bulk lookup.",Use null instead of Collections.emptySet() here,"minor nit: the exception message need not specify provided products here, as that's not an individual class of product, and the product's usage can be derived from the method generating the exception.","I'm a bit confused by this. Why are we calling the populate method recursively here, which will overwrite all the data on the marketing ProductData (this) we're populating already? If it is in order to turn the Product into a ProductData, new ProductData(Product product) is what we should be using instead.",I wonder if we're getting to a point where we should have an isComplete method on our entities to check this kind of thing without needing this kind of code in a number of places.,This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.,"I know this is old, but I've often wondered what the effect of this is on the overall process. Might be worth adding a little more context to the warning. Thoughts?","We should be more explicit when write a log message. Anyway, Are you sure that it should be a warning log message and not an error log message?"
"public void injectHooks() { HookFile hookFile = fetchHookFile(); if (hookFile == null) { return; } HookParser parser = hookFile.getParser(); Injectable[] injectables = parser.getInjectables(); if (injectables == null) { return; } int index = 0; try { for (Injectable inj : injectables) { inj.inject(); index++; } } catch (NullPointerException ex) { if(!crashed) { Injectable inj = injectables[index]; int resp = UILog.alert(""Outdated client"", ""This server currently has outdated hooks, please report it to a member of the Parabot staff/Dev Team.\r\n\r\n"" + ""Broken hook:\r\n""+inj, new Object[]{""Close"", ""Report here...""}, JOptionPane.ERROR_MESSAGE); if(resp == 1) { URI uri = URI.create(Configuration.COMMUNITY + ""forum/135-reports/""); try { Desktop.getDesktop().browse(uri); } catch (IOException ignore) {} } } crashed = true; throw ex; } Context.getInstance().setHookParser(parser); }",Remove /Dev Team,"Can this not just be LOGGER.warning(""msg..."", e) ? Also I think we nearly always use ""ex"" so that would be a bit better for consistency.","This method can be simplified into:  @Override public void onBlogClicked(Object item) { if (item instanceof ReaderRecommendedBlog) { ReaderRecommendedBlog blog = (ReaderRecommendedBlog) item; ReaderActivityLauncher.showReaderBlogPreview(getActivity(), blog.blogId); } else if (item instanceof ReaderBlog) { ReaderBlog blog = (ReaderBlog) item; ReaderActivityLauncher.showReaderBlogPreview(getActivity(), blog.blogId, blog.feedId); } }","The default constructor should assign ""null"" to connector.",Adding this to a field is good manner.,Truncate it when generating to reduce memory usage,Is it OK to swallow this entirely?,"Why is this a looper? As far as I can tell, it only runs once.","Will anything add exceptions to rootException? If not, we could use Arrays.asList(exception.getMessage()).",This should be a translated message. And instead of Window.alert use our ErrorDialog type.,Missing @since
"public void execute(TupleWindow inputWindow) { for (Tuple tuple : inputWindow.get()) { sum += tuple.getLongByField(""value""); } state.put(""sum"", sum); collector.emit(new Values(sum)); }",You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode,Leftover debugging changes?,What is the purpose of cumulative after this change? When is map cleared?,I would static import quantileBoundsToArray.,"Looks like this line is unnecessary? The ""values"" variable is never being used.",final,This ReduceByWindowOperator only supports time based window. How about other types of window?,Are locks needed in Build and Merge Aggregators alike?,final,I think applying null is not good,"I'm not sure we need to log applyStatefulFunction. Maybe we need to log the current state of the applyStatefulFunction. For this, we may need an interface, such as getCurrentState()."
"private CDPStructuredNotificationDetails getNotificationDetails(ResourceEvent resourceEvent, String resourceCrn, String resourceType, Object payload) { String serializedPayload; try { serializedPayload = new Gson().toJson(payload); LOGGER.debug(""CDPStructuredNotificationDetails' payload has been serialized with ResourceEvent[{}], resource type[{}], CRN[{}]"", resourceEvent.name(), resourceType, resourceCrn); } catch (RuntimeException re) { String msg = String.format(""CDPStructuredNotificationDetails' payload couldn't be serialized with ResourceEvent[%s], resource type[%s], CRN[%s]"", resourceEvent.name(), resourceType, resourceCrn); LOGGER.warn(msg, re); serializedPayload = msg; } return new CDPStructuredNotificationDetails(resourceEvent, resourceCrn, resourceType, serializedPayload); }","I see no reason to introduce msg here, you could just use serializedPayload","This would put a hard dependency on woodstox in the logging module. I believe the better option would be to catch RuntimeException and check the cause to see if the cause is a XMLStreamException. If not, rethrow the RuntimeException, otherwise treat it like the XMLStreamException.",Can you get just the crns from the database?,Why are we creating a new one here instead of having a private final one in the class?,wrap with try-with-resources,"What's left in terms of logging when we process a message? This message specifically has been helpful at least for debugging, can we just s/info/debug here?",check if you can use fluent api to add the storm tag,"1. I expect two exceptions here - one the user exception and the second the riemann exception. 2. loggers support exception stack trace built-in. This is the syntax: logger.warn(""Riemann error during exception send"",t);","Logging should be added here, just to ensure that we see if something is wrong...",Please don't return from if branch and reduce code duplication between branches,"maybe it is better to throw here a not found also, isn't it?"
"public static Map<String, String> getInputFiles(String descriptorAbsolutePath) { WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, ""Problem parsing WDL file: "" + ex.getMessage(), API_ERROR); } return wdlInputs; }",Put the test in the same package (not directory) and you can at least use package private or protected,"As you suggested in your PR description, I think this should be a 400 error.","Don't remove this code, backwards compatibility is important. Existing users might have custom mappings still using the old syntax, which will get broken after an upgrade. Add a new branch on top, checking if the content starts with {.","Please create a utility method getWorkflowConfigurationParser that contains these 3 lines ^, and also use it in makeDefaultScheduler.",dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods,Space after the for please.,"Which is perfectly valid, if there is no Internet access available. Hence this must not result in any errors being logged.","given the service scope and implementation I would say there is no kinda cache at all, right? I mean, once editing a process in VSCode, for example, we'll be performing the service queries, to obtain resource data, and also doing the parse operations over it, again and again, even if the work items on the project were not changed, right? I'm not complaining, that's fine for me now, because as I understand you can add / remove work item definitions at runtime, right? Anyway, jsut branistorming and trying to clarify the behavior of these implementations....",Shall we return Collections.unmodifiablemap?,"Hey @abatac while both of these Exception types are thrown from the single service, they are different Exceptions, and the type of Exception gives the user a clue as to what might have gone wrong. This is why Exceptions are typed in Java, so we can provide the User with more specific information about the problem. Please handle these Exceptions separately and provide extra information to help users understand what went wrong",should be the last instruction executed in the whole method.
"public List<Timeline> listTimelines(final String eventType) { return jdbcTemplate.query( BASE_TIMELINE_QUERY + "" WHERE t.et_name=? order by t.t_order"", new Object[]{eventType}, timelineRowMapper); }","a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.",What will happen if id is null?,What will happen if id is null?,I think you should also adjust saving of event-type. Because with current implementation it will not be possible for user to delete event-type and then create another one with the same name (method with throw DuplicatedEventTypeNameException),This might complain for some branches which need to be source compatible with Java 7 instead of 8,"The String for checkConnectionQuery() is SELECT 1 without a semicolon, but here there is one. Unless there's a reason for that, we should probably standardize one way or the other.",According to our code style . preceding method call (method response) should be on the same line with method name.,Good catch PostgreSQL's system catalog (e.g. pg_class) doesn't have table creation timestamp. So using CREATE TABLE AS SELECT is only an option to avoid creating an empty table. But I think we can go without it for the first release.,This belongs in the service that deals with the scheduler database,Can we please make this less than 80 characters wide?,you do not need InternalNakadiException on line <LINK_0>
"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","suggestion Objects.requireNonNull(filter, ""filter cannot be null"");",More accurate error message,"If we need to explicitly check that means we need to improve on this. Some type of filter abstraction needed. Maybe UnboundRecordFilter gets wrapped in a notion of Filter that does nothing on BlockMetadata?  interface Filter { List<BlockMetaData> filterRowGroups(List<BlockMetaData> rowGroups); ... } class UnbounRecordFilter { List<BlockMetaData> filterRowGroups(List<BlockMetaData> rowGroups) { return rowGroups; } } class PredicateFilter { List<BlockMetaData> filterRowGroups(List<BlockMetaData> rowGroups) { return ParquetInputFormat.applyRowGroupFilters(this, footer.getParquetMetadata().getFileMetaData().getSchema(), rowGroups); } }  or along those lines?","I think, this logging is not very useful. Other filters neither logs the dropped row groups. If you would like to have a more useful log, it might be a good idea to log the index of the row group as well and the filter type which triggered the drop. Also, please use curly braces for any blocks and format accordingly.",super is not needed.,functionResolution?,nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?,I doubt checkstyle like this much. Also I'm not sure what you feel the need to do this since parse() starts with a StringUtils.isEmpty check.,We can use ImmutableList.Builder<Optional<Field>> fieldsBuilder = ImmutableList.builder(); to be consistent with the other fields.,"getColumnIOByName can return null, and that will cause a NPE here in add call. If getColumnIOByName returns null it means a column with given name couldn't be found, and we get the column name from the Parquet file schema, so I feel like that's a serious error condition and instead of returning a null we should throw.","This method always returns true or throws an exception when it fails. It should either return void and throw the exception, or return true/false."
"private void write(Object msg, boolean flush, ChannelPromise promise) { final AbstractChannelHandlerContext next; if (flush) { AbstractChannelHandlerContext ctx = this; do { ctx = ctx.prev; } while ((ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0); next = ctx; } else { next = findContextOutbound(MASK_WRITE); } final Object m = pipeline.touch(msg, next); EventExecutor executor = next.executor(); if (executor.inEventLoop()) { if (flush) { next.invokeWriteAndFlush(m, promise); } else { next.invokeWrite(m, promise); } } else { final AbstractWriteTask task; if (flush) { task = WriteAndFlushTask.newInstance(next, m, promise); } else { task = WriteTask.newInstance(next, m, promise); } if (!safeExecute(executor, task, promise, m)) { task.cancel(); } } }",Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0,I think this is meant to be moved within the if (executor.inEventLoop()) { block below?,executor() -> executor,I think the else logic needs to be moved inside the synchronized block above to ensure ordering consistency between the array list and linked list,"We discussed offline, but should be the configured maximum capacity",Use a compareAndSet here. Do we need synchronization on the flush method at all?,execute on handlerContext directly and pass the handler as resultHandler of executeBlocking,"you can keep a single writeData method and add the handler as listener of the promise when it's not null and remove void writeData(Http2Stream stream, ByteBuf chunk, boolean end)",Lets change the default to GRACEFULLY,executor() -> executor,i think java return vv -> connection.getContext().runOnContext(handler);  Would have the same result and it avoid 1 extra lambda
"public void serialize_test() { Note note = new Note() .setAuthor(HARDCODED_AUTHOR) .setDate(HARDCODED_DATE) .setUserIdsToNotify(Arrays.asList(HARDCODED_USER_IDS)) .setId(HARDCODED_ID) .setContactId(HARDCODED_CONTACT_ID) .setLinkedDealId(HARDCODED_LINKED_ID) .setModifiedAt(HARDCODED_MODIFY_DATE) .setCreatedAt(HARDCODED_CREATE_DATE); String json = NoteSerializer.toJsonObject(note); try { Note parsedNote = NoteSerializer.fromString(json); assertEquals(HARDCODED_AUTHOR, parsedNote.getAuthor()); assertEquals(HARDCODED_CONTACT_ID, parsedNote.getContactId()); assertEquals(HARDCODED_DATE, parsedNote.getDate()); assertEquals(HARDCODED_MODIFY_DATE, parsedNote.getModifiedAt()); assertEquals(HARDCODED_CREATE_DATE, parsedNote.getCreatedAt()); assertEquals(HARDCODED_ID, parsedNote.getId()); List<String> parsedUserIds = parsedNote.getUserIdsToNotify(); List<String> originalUserIds = Arrays.asList(HARDCODED_USER_IDS); assertTrue( parsedUserIds.containsAll(originalUserIds) && originalUserIds.containsAll(parsedUserIds)); } catch (OnePageException e) { e.printStackTrace(); } }",@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail(),Can you please use the static import for these in all of the classes? It's convention to use static import for Junit methods because it reduces the verbosity and its more clear. <LINK_0>,"why creating new notebook instance here? can just reused previous one, isn't it","Mappers are quite expensive to create I believe, but are thread safe once constructed. Could this be a static?",@Dohbedoh Maybe it's like this in others tests but couldn't we move them to resources files and load them to have a better readability ?,Let's static import the assertions inside org.junit.Assert so we don't need to prefix them with Assert.,You should certainly change this also :),Here we should use getOwner()/setOwner(),should be setContext,Is this dependent on the computer's time zone?,"Should use newGson(), otherwise it's not actually going to exercise the ServerJsonDateAdapterFactory"
"public Owner updateOwner(@PathParam(""owner_key"") @Verify(Owner.class) String key, @ApiParam(name = ""owner"", required = true) Owner owner) { Owner toUpdate = findOwner(key); EventBuilder eventBuilder = eventFactory.getEventBuilder(Target.OWNER, Type.MODIFIED) .setOldEntity(toUpdate); log.debug(""Updating owner: {}"", key); if (owner.getDisplayName() != null) { toUpdate.setDisplayName(owner.getDisplayName()); } if (owner.getParentOwner() != null) { toUpdate.setParentOwner(owner.getParentOwner()); } if (owner.getDefaultServiceLevel() != null) { if (owner.getDefaultServiceLevel().equals("""")) { toUpdate.setDefaultServiceLevel(null); } else { serviceLevelValidator.validate(toUpdate, owner.getDefaultServiceLevel()); toUpdate.setDefaultServiceLevel(owner.getDefaultServiceLevel()); } } if (owner.getAutobindDisabled() != null) { toUpdate.setAutobindDisabled(owner.getAutobindDisabled()); } if (config.getBoolean(ConfigProperties.STANDALONE) && !toUpdate.getContentAccessMode().equals(owner.getContentAccessMode()) && owner.getContentAccessMode() != null) { throw new BadRequestException( i18n.tr(""The owner content access mode cannot be set directly in standalone mode."")); } boolean refreshContentAccess = false; if (owner.getContentAccessMode() != null) { if (toUpdate.isAllowedContentAccessMode(owner.getContentAccessMode())) { String before = toUpdate.getContentAccessMode(); String after = owner.getContentAccessMode(); if (!after.equals(before)) { toUpdate.setContentAccessMode(owner.getContentAccessMode()); refreshContentAccess = true; } } else { throw new BadRequestException( i18n.tr(""The content access mode is not allowed for this owner."")); } } ownerCurator.merge(toUpdate); ownerCurator.flush(); if (refreshContentAccess) { ownerManager.refreshOwnerForContentAccess(toUpdate); } Event e = eventBuilder.setNewEntity(toUpdate).buildEvent(); sink.queueEvent(e); return toUpdate; }",Need a null check here.,Embed the caught exception in the newly thrown exception,"Humm, JournalData is not really the place to log errors.",Wrap these long lines?,"If the level is set to """" in the activation key, it will unset the consumers value (from a prior activation key)",suggestion this.owner = Util.fixEmpty(owner);,LIR == OrgType.getFor(originalObject.getValueForAttribute(AttributeType.ORG_TYPE)) is a bit cleaner..?,"Let's not revert this code. The whole ""release as an object"" thing needs to go away, not be compounded. If this is causing difficulties in your code, let's discuss them and figure out a way to work around them such that we're cleaning this section up rather than doubling-down on the wrapped version string paradigm.","There is no guarantee that there will be exactly one admin user. In fact, if the XML config is not the configured authentication provider (let's say we're using LDAP), the configuration may be such that this user is no longer present, as the owner of the service may have decided to delete it and have the admins ""imported"" from LDAP.","We should be performing input validation before we go creating any model objects, or populating them with data.",and same here: you need to pass result._source instead of just result
"public void testAcquireLockWithLockNotAvailableException() { JedisOps ops = mock(JedisOps.class); when(ops.setnx(eq(""key""), anyString())).thenReturn(0L); when(ops.ttl(""key"")).thenReturn(30L); RedisLock lock = new RedisLock(ops); try { lock.acquireLock(""key"", 10); } catch (LockNotAvailableException e) { assertTrue(""LockNotAvailableException expected"", true); } InOrder inOrder = inOrder(ops); inOrder.verify(ops, times(1)).setnx(eq(""key""), anyString()); inOrder.verify(ops, times(1)).expire(""key"", 10); }","This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(""key"", 10); fail(""expected exception""); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.",These two are redundant now - shouldn't the test for the new logic be in a different test?,"nit: should this test start with the following? It _looks_ like it's not strictly needed, but for consistency with the others it seems like it should be there  when(lockService.refreshLockRefreshTokens(Collections.singleton(EXTERNAL_LOCK_REFRESH_TOKEN))) .thenReturn(ImmutableSet.of()); when(lockService.refreshLockRefreshTokens(Collections.singleton(TRANSACTION_LOCK_REFRESH_TOKEN))) .thenReturn(ImmutableSet.of());",in most tests; recommend stubbing out time rather than sleeping - it makes the tests unnecessarily long-running,"My suggestion was to do assertFalse(await(tryLock)); first and await(lock.unlock()); later, without other delays.",Why would these match?,registry.expireUnusedOlderThan(-1000); instead of Thread.sleep() I don't like any blocking in tests for nothing.,"Hmmm, I think this JMX attribute became kind of useless the moment we stopped allowing the mix of tx and non-tx operations in the same cache, and now even more so because the number of deadlock checks isn't deterministic. I'd deprecate the attribute and remove this check.","this is the same as the one above except for the extra. Can we combine them, or have mutually exclusive asserts?","you should never use assertEquals, it's too error-prone (people flip expected and actual all the time). Prefer using assertThat().isEqualTo() every time.","Please use AbstractInfinispanTest.testExecutor() in the tests, with the common pool it's impossible to filter logs by test."
public List<DataType> all() { return new ArrayList<>(dataTypes.values()); },as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); },Perhaps nameToDataType.,"Maybe also a case for mapLazy, or otherwise we should also change the function name, because the View implied that the structure is lazy.",Add this qualifier: this.data,this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?,or just java public static Object[] data() { return TestPlatform.values(); },"Use Jack utilities here, UnmodifableCollections.","public, same for the other one",This is bytecode equivalent to using the for-each syntax on an array.,"suggestion ResultSetStatement statement = (ResultSetStatement) analyzedStatement;  update in this context is too specific, this can be any kind of statement. Personally I'd also remove the local result variable and return directly (so you don't have to backtrack to see what has been assigned to result), but that's a personal preference so feel free to ignore.","this yields 2 boxing warnings, either suppress them or use Boolean.TRUE and FALSE"
"private void startSequencesAtBeginning(TopicPartition topicPartition, ProducerIdAndEpoch newProducerIdAndEpoch) { final PrimitiveRef.IntRef sequence = PrimitiveRef.ofInt(0); getPartition(topicPartition).resetSequenceNumbers(inFlightBatch -> { inFlightBatch.resetProducerState(newProducerIdAndEpoch, sequence.value, inFlightBatch.isTransactional()); sequence.value += inFlightBatch.recordCount; }); getPartition(topicPartition).nextSequence = sequence.value; getPartition(topicPartition).lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER; }",nit: maybe we can save the result of getPartition(topicPartition),This doesn't seem right. lastAckedSequence(topicPartition) may exist.,I don't think synchronized is necessary,this doesn't work; you can get to -1,"nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?","This occurs often enough to extract a method assertRefreshableContains(Refreshable, long)",You dont need to do this inside the iterator. You have the operation queue and only need be done once,"this class keep track of so much state, and they all need to be reset at restartFrom call. I'm wondering if pulling out the state tracking variable in one common place, and call reset on that one to start with clean state helps longer term maintainability of this class. What do you think?",constructor can be package private,field access?,why is this method not private? it's not used outside of this class
"private String getDataSourceName(DataSource dataSource) { Preconditions.checkArgument( dataSource instanceof TableDataSource, ""Subqueries and Unions are only supported in the broker"" ); return Iterables.getOnlyElement(dataSource.getNames()); }",I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?,"i think it's better to put requireNonNull(queryRunner.getDataSource(), ""data source must not be null."") before this.queryRunner = queryRunner.",Maybe replace this .map line with  .map(TableDescriptor::getTableDefinitionName) .map(tableDefinitionRepository::getForName) .map(MutableTableRequirement::builder) .map(builder -> ....)  Is that more readable?,Please throw UnsupportedException with UNIQUE constraint is not supported yet. message.,null check?,"Just noticed: this check is useless, these is no other QueryType at this moment.","In StringCapabilities we claim that we support ASCENDING index order. Why do we not allow it here?, and shouldn't we use capabilities here for validation of predicates as well?",can be java public Seq<E> getErrors(),Why is this done twice on table1?,does this need to be calculated on the fly each time or can we save the iterable?,It looks like equals:ImmutableDruidDataSource is not the Java convention. At least I'm not familiar with it. Would you tell me where this convention came from?
"private void canTerminate(IProcessDMContext[] procDmcs, DataRequestMonitor<Boolean> rm) { if (procDmcs.length == 0) { IGDBControl gdbControl = fTracker.getService(IGDBControl.class); if (gdbControl != null) { rm.setData(true); } else { rm.setStatus(new Status(IStatus.ERROR, GdbUIPlugin.PLUGIN_ID, ""Service is not available."")); } rm.done(); return; } IMultiTerminate multiTerminate = fTracker.getService(IMultiTerminate.class); if (multiTerminate != null) { multiTerminate.canTerminateSome(procDmcs, rm); } else { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null && procDmcs.length == 1) { procService.canTerminate(procDmcs[0], rm); } else { rm.setData(false);; rm.done(); } } }",Two ;;,"So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.","If there is no MultiDetach service, maybe we should revert to the previous behaviour of not allowing detaching when multiple elements are selected? It may be confusing to arbitrarily allow to detail because the first selection allows it. We would just need to add a check here if (contDmcs.length != 1) rm.done(false);",Can we make this test use a Query instead?,If we are not running the full console (i.e. not async) we should not interrupt like this but use ^C instead.,"Please update the error message, or do an if (threadNamesSupported()) and use two different asserts with their corresponding error message","Since this is a new method you can use a much simpler way than using the waitor. You can use a Query instead, this is safe on this context as we don't have to worry about hanging the UI thread on these tests. You can use the method above as an example: i.e. getFrameData","I think ""filtered running threads"" should be localized.","It is a good habit to avoid public methods unless you need them to be public. Here, since the class in internal, it does not matter, but normally it would be safer to put as private to avoid being stuck with an new API. Ok to leave it as is in this case though.",You can use if (event.getDMContext() instanceof IContainerDMContext) to know if you are dealing with a container or a thread.,"Variable context can be used from right above. Also, check for null, just in case. Note that the InstanceOf check below is an implicit check for null"
"public AbfsRestOperation createPath(final String path, final boolean isFile, final boolean overwrite, final String permission, final String umask, final boolean appendBlob) throws AzureBlobFileSystemException { final List<AbfsHttpHeader> requestHeaders = createDefaultHeaders(); if (!overwrite) { requestHeaders.add(new AbfsHttpHeader(IF_NONE_MATCH, AbfsHttpConstants.STAR)); } if (permission != null && !permission.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_PERMISSIONS, permission)); } if (umask != null && !umask.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_UMASK, umask)); } final AbfsUriQueryBuilder abfsUriQueryBuilder = createDefaultUriQueryBuilder(); abfsUriQueryBuilder.addQuery(QUERY_PARAM_RESOURCE, isFile ? FILE : DIRECTORY); if (appendBlob) { abfsUriQueryBuilder.addQuery(QUERY_PARAM_BLOBTYPE, APPEND_BLOB_TYPE); } final URL url = createRequestUrl(path, abfsUriQueryBuilder.toString()); final AbfsRestOperation op = new AbfsRestOperation( AbfsRestOperationType.CreatePath, this, HTTP_METHOD_PUT, url, requestHeaders); op.execute(); return op; }",Test the change against an account in prod tenant which still doesnt have Dec-12 bits .,prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;,"this is replicated enough it should be its own method, e.g  maybeAppendSASToken(path, operation, querybuilder) if (authType=SAS) { appendSASTokenToQuery(path, SASTokenProvider.RENAME_SOURCE_OPERATION, queryBuilder); }  and use wherever needed",Would adding a string error message including some context be helpful?,"style nit, put the { up with the if clause",Could this also be ContainerNotFound?,Same here - have an 'add'.,This loses information: after setAllowDeletes(true); setAllowBranchDeletes(true); setAllowDeletes(false); setAllowDeletes(true); what should isAllowBranchDeletes() say? I'd delete the above two lines and treat them as orthogonal (validateCommands would still prevent deleting branches when allowAnyDeletes is false).,Check null case?,This doesn't make sense.,what happens if it is not? should we warn or throw an exception?
"private void buildColumns(ElasticsearchTableDescription tableDescription) { Set<ElasticsearchColumn> columns = new HashSet(); Client client = clients.get(tableDescription.getClusterName()); verify(client != null); try { GetMappingsRequest mappingsRequest = new GetMappingsRequest().types(tableDescription.getType()); String index = tableDescription.getIndex(); if (!isNullOrEmpty(index)) { mappingsRequest.indices(index); } ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = client.admin().indices().getMappings(mappingsRequest).actionGet(timeout.toMillis()).getMappings(); Iterator<String> indexIterator = mappings.keysIt(); while (indexIterator.hasNext()) { MappingMetaData mappingMetaData = mappings.get(indexIterator.next()).get(tableDescription.getType()); JSONObject mappingObject = new JSONObject(mappingMetaData.source().toString()).getJSONObject(tableDescription.getType()); JSONObject properties = mappingObject.getJSONObject(""properties""); List<String> lists = new ArrayList<String>(); if (properties.has(""_meta"")) { JSONObject meta = mappingObject.getJSONObject(""_meta""); if (meta.has(""lists"")) { JSONArray arrays = meta.getJSONArray(""lists""); for (int i = 0; i < arrays.length(); i++) { lists.add(arrays.getString(i)); } } } for (String columnMetadata : getColumnsMetadata(null, properties)) { Optional<ElasticsearchColumn> column = createColumn(columnMetadata, lists); if (!column.isPresent()) { continue; } if (columns.stream().noneMatch(col -> col.getName().equals(column.get().getName()))) { columns.add(column.get()); } } } columns.add(createColumn(""_id.type:string"", ImmutableList.of()).get()); columns.add(createColumn(""_index.type:string"", ImmutableList.of()).get()); tableDescription.setColumns(ImmutableList.copyOf(columns)); tableDescription.setColumnsMetadata(columns.stream().map(ElasticsearchColumnMetadata::new).collect(Collectors.toList())); } catch (JSONException e) { throw new PrestoException(ELASTIC_SEARCH_MAPPING_REQUEST_ERROR, e); } }","verify(client != null, ""client cannot be null"");","IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?","It seems that result can be null, so the condition should probably be if (result == null || !result.isSucceeded()). Though even better would be to understand why thi result can be null.",this line is hard to read too:  String[] indices = client.admin() .indices() .getIndex(new GetIndexRequest()) .actionGet(timeout.toMillis()) .getIndices(); return Arrays.stream(indices) ...,static import SortOrder.ASC,ditto about InterruptedException,Formatting nit: this should be on previous line,"nit: You can just use an expression lambda here. Please also fix L236 and L317.  .run(""getIndices"", () -> client.admin() .indices() .getIndex(request) .actionGet(requestTimeout.toMillis()) .getIndices());",add a message to this exception.,Same here: I'd slightly prefer private.,"if (metric || metric.metric == null) as above? Also, mostly for aesthetics, but if we're going to make changes in this code, might as well refactor the metric var on lines 205,234 and 248 to metricinfo or currmetric"
"private static SecretKeyEncryptionStrategy instantiateSecreteKeyEncryptionStrategy(String className) { log.debug(""About to instantiate secret key encryption strategy {}"", className); SecretKeyEncryptionStrategy strategy = null; Class keyEncryptionStrategyClazz = null; try { keyEncryptionStrategyClazz = AccumuloVFSClassLoader.loadClass(className); } catch (ClassNotFoundException e1) { throw new RuntimeException(""Could not find configured secret key encryption strategy: "" + className); } Class[] interfaces = keyEncryptionStrategyClazz.getInterfaces(); boolean implementsSecretKeyStrategy = false; for (Class clazz : interfaces) { if (clazz.equals(SecretKeyEncryptionStrategy.class)) { implementsSecretKeyStrategy = true; break; } } if (!implementsSecretKeyStrategy) { throw new RuntimeException(""Configured Accumulo secret key encryption strategy \""%s\"" does not implement the SecretKeyEncryptionStrategy interface.""); } else { try { strategy = (SecretKeyEncryptionStrategy) keyEncryptionStrategyClazz.newInstance(); log.debug(""Successfully instantiated secret key encryption strategy {}"", className); } catch (InstantiationException e) { throw new RuntimeException(""Got instantiation exception {} when instantiating secret key encryption strategy "" + className); } catch (IllegalAccessException e) { throw new RuntimeException(""Got illegal access exception when trying to instantiate secret key encryption strategy "" + className); } } return strategy; }","Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.",Why do we need to .class.getName() here? It will just take up more time when the provider is loading.,"Big +1 to this change. Should never silently fall back to plaintext when there's an issue using the user-declared crypto. That said, I'm not sure the CryptoModule should even be configurable. It's too tightly coupled with crypto code outside of the module. I think maybe only the ciphers and crypto parameters should be configurable.","So in case if I have types= {BCFKS, PKCS12} and I dont have fips bouncy castle registered. Method tries BCFKS and return null. And dont try PKCS12?",Use double try block to make logic simplier.  java try { InputStream is = new FileInputStream(keyStore); try { ... } finally { Closeables.closeQuietly(is); } } catch (...) { },"Here, I think it would better by default to JavaSecureRandom as this is the one more likely to work if others ((OpensslSecureRandom or OSSecureRandom) failed.",will break in 0.11.0.4,LOG.error,"Return value should not be discarded: if the server starts with an invalid certificate, it should not start at all. Here, it will still be used, allowing insecure connections to be possible.",Can you fix the typo? :-),"Bug: Format string ""%s"" needs argument 1 but only 0 are provided"
public void removeAllChangeListeners() { realm.checkIfValid(); realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE); collection.removeAllListeners(); },"Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?",should have a space before null.,RealmList? Also we don't have Realm.refresh(),Perhaps just realm.where(AllTypes.class).count() instead?,better to have fail(); in the onSuccess()?,Don't you also need to include VIEW_CLIENTS and MANAGE_CLIENTS roles ?,"Weak suggestion to rename this ""enforceAtLeastOnePermissionOf"". It's to eliminate the interpretation ""enforce (any permission)"" which sounds like the code somehow chooses some permission in the list and enforces it's held. Then again that's pretty silly so it might not be a very relevant concern.",This is not necessary. This flaky test will be fixed by #4209,"thrown.expecteMessage(). minor thing, i am fine with this.",Removed -> NotRemoved?,Call last?
"public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), buildPayload(4 * MiB))).isEqualTo(HashCode.fromString(TREEHASH)); RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), ""PUT /-/vaults/"" + VAULT_NAME + ""/multipart-uploads/"" + MULTIPART_UPLOAD_ID + "" "" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), ""bytes 0-4194303/*""); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), ""4194304""); }",Should TREEHASH be a HashCode?,@Serranya use JoinedText to break this line and remove the checkstyle supression.,@raphaelln 4 spaces back,@exper0 Let's use HmRsHeader class here instead.,Looks like too many \r\n. Should we have only 2 pairs instead of 3?,"@essobedo same here, use throws Exception","can we also add a assertEquals(0, req.refCnt()); after the destroy() call ?","@raphaelln double space, please fix",@antonini if many lines are the same as in other test case maybe we can extract method to make it more DRY?,"@victornoel We have lots of assertions in the same method, let's break this method in parts with just one assertion each.",I would suggest to have these assertions to a private method. We might re-use it in future
"public String render(final ListAllMyBucketsResult obj) throws JsonProcessingException { if (obj == null) { return ""You do not have any buckets""; } ObjectMapper mapper = new ObjectMapper(); return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); }",final,final,"""You do not have any tapes""",Would it be cleaner to just do this: <LINK_0>,Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?,/** * Gson objects are very heavy. The app should ideally be using just one instance of it instead of creating new instances everywhere. * @return returns a singleton Gson instance */ @Provides @Singleton public Gson provideGson() { return GsonUtil.getDefaultGson(); }  It would be handy if we could not create Gsons here though I don't know how this class is instantiated by room,Do we use IVdcQueryable somewhere in AAA?,Could the iterator be empty? Or null?,add this (also below),Is this better than a boolean?,ObjectMapper is a thread safe object. You can create a static instance and reuse it.
"protected void doMerge(Mapper mergeWith, boolean updateAllTypes) { super.doMerge(mergeWith, updateAllTypes); var mw = ((KeywordFieldMapper) mergeWith); this.ignoreAbove = ((KeywordFieldMapper) mergeWith).ignoreAbove; if (!Objects.equals(this.lengthLimit, mw.lengthLimit)) { throw new IllegalArgumentException( ""mapper ["" + name() + ""] has different length_limit settings, current ["" + this.fieldType().lengthLimit + ""], merged ["" + mw.fieldType().lengthLimit + ""]""); } }",suggestion this.ignoreAbove = mw.ignoreAbove;,"for my info, are these newly introduced checks or were they just moved?",The Class objects can be compared directly with ==.,Will the {} at the end of this log line cause the StructuredArgument to be substituted into the string rather than appearing as a JSON field?,"This isn't worth a warning - probably trace, maybe debug. I don't think there's any need to special case String either.","Same as above, please prefer == for comparing enums.",nit: this line can move to above line,This'd probably be a little cleaner as a private final method with early returns.,"Good catch! But after looking at this beautiful code here: <LINK_0> I'm asking myself, maybe we should instead change Character.isUpperCase(fieldName.charAt(prefixLength) to !Character.isLowerCase(fieldName.charAt(prefixLength) ? What do you think?","Since originalType is an Enum, seems we can just do like:  if (getOriginalType() != toMerge.getOriginalType()) reportSchemaMergeError(toMerge);  which covers: 1. if both are null, the condition evals to false 2. if one is null and the other is not null, the condition evals to true 3. if both are not null, then the condition evals to false if they take different values, and evals to true otherwise. @liancheng what do you think?","you should not be checking if a field exists in the schema by doing .toString() on a list and checking the key field is part of that string, as you can get false positives that way. Instead, you need to iterate through the list and check that the configured key field matches one of the field names."
"private void storeReleasedTime(AndroidCommCarePlatform platform, Reference ref) { long releasedOnTime = -1; if (ref instanceof JavaHttpReference) { Headers responseHeaders = ((JavaHttpReference)ref).getResponseHeaders(); if (responseHeaders != null) { String releasedOnStr = responseHeaders.get(HEADER_APP_RELEASED_ON); try { if (releasedOnStr != null) { releasedOnTime = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm'Z'"").parse(releasedOnStr).getTime(); } } catch (ParseException e) { e.printStackTrace(); } } } if (releasedOnTime == -1) { releasedOnTime = new Date().getTime(); } HiddenPreferences.setReleasedOnTimeForOngoingAppDownload(platform, releasedOnTime); }","I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.",yuck,Not sure this is desired behavior if date time cannot be parsed,"please make logException return void. - the boolean return value is only utilized here. - its always going to be true, since in line 93 you made sure that its only reached when isReportingEnabled() is true",Should this be System.err instead?,"Instead of printing a stack trace to standard error, why not throw a SlimFixtureException with message that date can not be parsed and e as cause?","Instead of printing a stack trace to standard error, why not throw a SlimFixtureException with message that date can not be parsed and e as cause?",Better to log instead of e.printStackTrace,"I think this should be isCrashReportEnabled && isAnonymousReportEnabled(), right?",Why not directly return CommonsDateUtil.getIso8601DateFormatShort().parse(dateUploaded.getTimestamp()) or null if dateUploaded is null?,Is it possible the field exists but is not a long? That would make this fail wouldn't it?
public void centerOnNode(DataNode node) throws NodeNotFoundException { double x = -1; for (WrapperClone wrapperClone : graphData) { if (wrapperClone.getDataNodes().contains(node)) { x = wrapperClone.getX(); break; } } if (x != -1) { setZoomCenter(x); } else { throw new NodeNotFoundException(); } },Wrapper#getX() : float Use float instead of double.,Should be int or float. long is outdated & double won't be used.,Wonder if we should use float or double for these properties. I'd lean towards double as this is meant to be a generic class and double can store float but not vice-versa.,Have you intentionally omitted index check?,"just minor thing, but all these methods are duplicating code... probably you can create a common function that takes the shape and a Function<Bounds, Double> and does the different null checks etc, and then the methods xOfShape, yOfShape etc would be refactored by using as a second argument the function (bounds) -> bounds.getX(), and so on...",It might be faster to use Math.min and Math.max here.,It seems like it might be better to parse the x/y values when they are set rather than every time the leftX and topY properties need to be computed (which is more frequently than the property is set).,minX,Should currentEdge be allowed to dip below 0?,"set the local via eclipse preferences, reuse the formatter a field?",Where does the -1000000000 come from?
"public SourceRecord extractRecord() throws SQLException { Struct record = new Struct(schemaMapping.schema()); for (FieldSetter setter : schemaMapping.fieldSetters()) { try { setter.setField(record, resultSet); } catch (IOException e) { log.warn(""Ignoring record because processing failed:"", e); } catch (SQLException e) { log.warn(""Ignoring record due to SQL error:"", e); } } offset = criteria.extractValues(schemaMapping.schema(), record, offset); final String topic; final Map<String, String> partition; switch (mode) { case TABLE: if (useFqn) { String fqn = ExpressionBuilder.create().append(tableId, false).toString(); partition = new HashMap<>(); partition.put(JdbcSourceConnectorConstants.TABLE_NAME_KEY, fqn); partition.put(JdbcSourceConnectorConstants.OFFSET_PROTOCOL_VERSION, ""1""); topic = topicPrefix + fqn; } else { String name = tableId.tableName(); partition = Collections.singletonMap(JdbcSourceConnectorConstants.TABLE_NAME_KEY, name); topic = topicPrefix + name; } break; case QUERY: partition = Collections.singletonMap(JdbcSourceConnectorConstants.QUERY_NAME_KEY, JdbcSourceConnectorConstants.QUERY_NAME_VALUE); topic = topicPrefix; break; default: throw new ConnectException(""Unexpected query mode: "" + mode); } return new SourceRecord(partition, offset.toMap(), topic, record.schema(), record); }","Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.",you can keep deleted expression and then simplify the if statement readability with just a f.getProp(SnowflakeAvroRegistry.TALEND_FIELD_AUTOINCREMENTED) ? I understand your will but :kiss:,hoist all of this into a getTopic() private function,Isn't this constant and shared across all producers? Then can't it be static?,"suggestion throw new UnsupportedOperationException(""Computed columns is only supported by the Blink planner."");",Put this exception in the default branch of swith.,Could use a flipped equals...,you can use Schema's isNullable and getNonNullable methods to help out here.,Type for Field + config.field + must be String,"don't think anything throws an exception anymore. If not, you should remove this",hmmm this code looks suspicious. I think there are three different error scenarios: a) schema has one field and that field is the row field b) schema has one field and that field is different from the row field c) schema has more fields but does not contain the row field It looks as if case b) is not covered?
"protected void decodeValue(Klv klv) { byte[] bytes = klv.getValue(); CharsetDetector charsetDetector = new CharsetDetector(); charsetDetector.setText(bytes); CharsetMatch charsetMatch = charsetDetector.detect(); Charset charset = Charset.defaultCharset(); if (charsetMatch != null) { try { charset = Charset.forName(charsetMatch.getName()); } catch (IllegalArgumentException e) { LOGGER.trace( ""Unsupported encoding of %s, falling back to default encoding"", charsetMatch.getName()); } } value = new String(bytes, charset); }",":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.","Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?",A try/catch block (for IllegalArgumentException) should be added here around all TlvEncoder.encode() methods. And it may be cleaner to raise TlvException instead of IllegalArgumentException in the TlvEncoder class.,"I would suggest to keep this check, it gives a more specific error message.","I believe final can be removed. IDEA resource: As private methods cannot be meaningfully overridden, declaring them final is redundant.","Although somewhat of an edge case, but doesn't this lead to problems with the valid url jabref.org/test%5Ctest (which I guess would be reduced to jabref.org/test instead of the expected jabref.org/test\test?","How can you be sure of that? If you transpile these files, while not using directly a predefined charset such as UTF-8?",Should we include a charset when creating the string?,Ditto. suggestion String getCharset() {  (or just remove private from the field),"This should be a formatting call: LOGGER.debug(""{}{}"", indent(), value) This is also a place where it would make sense to check if debug is enabled around this call to avoid whatever indent() is doing if debug isn't enabled. The calls to this function are fine and it is fine to increment or decrement indent without checking if debug is enabled.",This message should be proposing creating an issue to the plugin developer IMHO.
"private AzureBlobStorageImpl constructImpl() { Objects.requireNonNull(blobName, ""'blobName' cannot be null.""); if (Objects.isNull(containerName) || containerName.isEmpty()) { containerName = BlobContainerAsyncClient.ROOT_CONTAINER_NAME; } checkValidEncryptionParameters(); HttpPipeline pipeline = super.getPipeline(); if (pipeline == null) { pipeline = buildPipeline(); } return new AzureBlobStorageBuilder() .url(String.format(""%s/%s/%s"", endpoint, containerName, blobName)) .pipeline(pipeline) .build(); }",ImplUtils has a isNullOrEmpty method that should handle these checks.,"Add a message. Without it, you just get a NullPointerException with no message. ie. ""'containerName' cannot be null."" Same with another usages of this.","You'd want to strip all but the first, not the last. Blob names can have forward slashes in them. Example: https://myaccoutn/blob.core.windows.net/containername/blobname/stillblobname/evenMoreOfTheSameBlobNameContainingSlashes. Unless I'm wrong as to what this utility method does, in which case I'd ask it be renamed to better represent what it's doing.",You can just set the property accessor directly into here - there is no need for an intermediate propertyAccessor variable.,"This is not always true. If the customer has set up a root container, it's possible to have a blobUrl of the format: myaccount.blob.core.windows.net/blobName","This type of URL parsing will be used a lot in the Storage SDKs, should we promote this functionality to a utility class in commons? Potentially move this into Azure Core if we see fit?",Could you add a check before this call to ensure there is a credential set in the builder? The changes made here no longer have it throw an IllegalArgumentException when no credential has been set.,"I know this was already public, but make it package private?","Can we check to ensure one isn't already present? I suppose it wouldn't matter because we remove the encryption metadata, so it wouldn't double decrypt, but it's probably safer if we check.",Isn't this the inverse of what it should be checking? ! isNullOrEmpty = false for null or empty values?,"You should be able to replace the upper code by: java containerName = Optional.ofNullable(args.get(CONTAINER_NAME)).filter(container -> ! container.toString().isEmpty()).orElseThrow( () -> new IllegalArgumentException(""You have to specify a container name. Empty value is not allowed."");"
"public void testLongFileNameThatDoesNotRequireEncoding() { String str = StringUtils.repeat(""1"", 256); assertEquals( ""11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.71634944"", fileManager.getFileName(TaskTestUtil.createMockTask(str), true)); }",Could you use Strings.repeat or something?,Seems like the previous tests should also assert on the length?,"This isn't quite the test you wanted, I think. Shouldn't it be ""\""\n\"""" ?","I'm hesitant to have quite so much duplicate code in a test - it seems too easy for someone to forget to update one branch in the future. Since bagit-java already requires Java 8, I was wondering whether this could be unified using java.nio.file.Path or at least File.separator","Please put @Test on the line above, not on the same line.",We have not been making changes to the code under junit.framework,public static otherwise sonar will complain.,factor out this line?,We don't expect a ConfigCompileException here,is Binary.equals() broken?,why make this method final?
"public boolean applyCSSProperty(Object element, String property, CSSValue value, String pseudo, CSSEngine engine) throws Exception { if (!(element instanceof ISelectionBackgroundCustomizationElement && element instanceof ElementAdapter) || !(((ElementAdapter) element).getNativeWidget() instanceof Widget) || property == null || value.getCssValueType() != CSSValue.CSS_PRIMITIVE_VALUE) { return false; } Widget widget = (Widget) ((ElementAdapter) element).getNativeWidget(); ISelectionBackgroundCustomizationElement treeElement = (ISelectionBackgroundCustomizationElement) element; Color newColor = (Color) engine.convert(value, Color.class, widget.getDisplay()); switch (property.toLowerCase()) { case SWT_SELECTION_FOREGROUND_COLOR: treeElement.setSelectionForegroundColor(newColor); break; case SWT_SELECTION_BACKGROUND_COLOR: treeElement.setSelectionBackgroundColor(newColor); break; case SWT_SELECTION_BORDER_COLOR: treeElement.setSelectionBorderColor(newColor); break; case SWT_HOT_BACKGROUND_COLOR: treeElement.setHotBackgroundColor(newColor); break; case SWT_HOT_BORDER_COLOR: treeElement.setHotBorderColor(newColor); break; } return true; }",the original code does not make toLowerCase(). Why did you add it?,typo,It's odd for getRGBFromTheme to call getImpliedBackground. Instead we should have a method getBackground that calls getRGBFromTheme and getImpliedBackground.,should we use the passed in display here?,"I think this reads better, if you extract the Display.getCurrent() to a local variable before this block.",This block should actually not return directly but set the color to the default background and the conversion itself should be out of the if block and directly returned.,"you have the key of the changed color, give to update colors and only update it","if (conditionalStyle instanceof EEFButtonConditionalStyle) { ... } Even if given the state of the code we could safely say today that we will not have a class cast exception, I can't condone casting something without testing its type first.","""uppercase"".equals(textTransform) && text != null","This resource needs to be managed and disposed when appropriate. Sometimes we use org.eclipse.jface.resource.LocalResourceManager. It also might be appropriate to change the org.eclipse.e4.ui.internal.css.swt.definition.IColorAndFontProvider interface so that it becomes responsible for managing the resource, if that can be done.","return a representation of the shown value, e.g. the formated string"
public Optional<Guid> getUserIdIfExternal() { return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId()); },this can be reduced to protected.,This can be simplified to Optional.ofNullable(id).,can you mark it with @Nullable?,put the uuid of any identifier source associated with a log entry,"This line could merge with the next line, making the next line return new UID(requireNonNull(v));",This is not correct for the same reason as i said above.,"This is wrong. getUuid should return the uuid in the class. Since this one has none, you can just return the string version of its id","Actually this is a mock patient, you should just return null here.","shouldn't this be ""flowInactiveTimeout""",Can we make it final?,"contains() would read more naturally here, is the performance gain here sufficient to justify not using it?"
"protected DatabaseName unmarshal0( ReadableChannel channel ) throws IOException { byte nullMarker = channel.get(); if ( nullMarker == 0 ) { return null; } else { int nameLength = (int) channel.get(); byte[] nameBytes = new byte[nameLength]; channel.get( nameBytes, nameLength ); return new DatabaseName( UTF8.decode( nameBytes ) ); } }",We have a StringMarshal helper class that does all of this UTF8 logic for a string.,Why do we need to copy it into array? I think it's unnecessary.,This code should be:  this.channel.close();,Why are you using getXxx methods instead of readXxx? I think it would simplify things if you just use read. And you won't need any offsets.,"when what is at the position is n array element and the element is an array, I was expecting to see a recursive kind of call here, is this correct code path? Is there a test where we have an array inside an array (do we even support it) ?","Why a maximum length? Not necessarily against it, just wondering. If we choose a maximum length then perhaps make it a bit longer (e.g. will for sure never bother anyone, 2048?) and extract it as a constant field. Having such logic in the Marshal might be the wrong place though. Should probably be validated upon reading the setting. Perhaps there is even some helper classes to aid this in the configuration-framework. Otherwise we could validate in CausalClusterConfigurationValidator. I would be totally fine with skipping a check altogether.",Names should be camel-case. Even abbreviations like UDP and TCP.,Let's just throw this exception to the caller than catch it here.,Case 3 is redundant,we can remove this exception logging since the exception is percolated up.,can this be readSafely instead of readBuffer so that read uses readSafely
"protected <C, R> void doDispatch(CommandMessage<C> command, CommandCallback<? super C, R> callback) { MessageMonitor.MonitorCallback monitorCallback = messageMonitor.onMessageIngested(command); MessageHandler<? super CommandMessage<?>> handler = findCommandHandlerFor(command).orElseThrow(() -> { NoHandlerForCommandException exception = new NoHandlerForCommandException( format(""No handler was subscribed to command [%s]"", command.getCommandName())); monitorCallback.reportFailure(exception); return exception; }); try { Object result = doDispatch(command, handler); monitorCallback.reportSuccess(); callback.onSuccess(command, (R) result); } catch (Exception throwable) { monitorCallback.reportFailure(throwable); callback.onFailure(command, throwable); } }",Shouldn't it be No handler was subscribed **for** command?,"I'd rather resolve return value if the handler is of type Void. In other situations, it's fine to return null:  @CommandHandler public MySuperAwesomeReturnType handle(MyCommand cmd) { if (iDontLikeMyCmd(cmd)) { return null; } return nonNullValue; }",This would be better named flatMap as it is called in Optional and Promise and other places.,This can be removed now.,"why do we need to pass ""t"" to ThrowableHandlers two times?",You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...,maybe check for start of file or newline also?,Same exception text adjustment suggestion as above.,I wonder if it may be proxy and therefore we need one more special interface... WDYT?,Debug has to be detected first otherwise we'll always take the INFO branch.,Using newIllegalStateException() which can format a string would make the above code more compact.
"private void processNewResponses() throws InterruptedException, IOException { SocketServerResponse curr = (SocketServerResponse) channel.receiveResponse(id); while (curr != null) { curr.onDequeueFromResponseQueue(); SocketServerRequest request = (SocketServerRequest) curr.getRequest(); String connectionId = request.getConnectionId(); try { if (curr.getPayload() == null) { logger.trace(""Socket server received no response and hence closing the connection""); selector.close(connectionId); } else { logger.trace(""Socket server received response to send, registering for write: {}"", curr); NetworkSend networkSend = new NetworkSend(connectionId, curr.getPayload(), curr.getMetrics(), time); selector.send(networkSend); } } catch (IllegalStateException e) { logger .error(""Attempt to write to socket for which there is no open connection. Connection id {}"", connectionId); } finally { curr = (SocketServerResponse) channel.receiveResponse(id); } } }",This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.,Isn't this better done at the beginning of onResponse() instead of here?,metric?,"Is this really necessary? If it was due to a read we will trigger a flush during channelReadComplete(). If it was due to a write, then there should be a flush following that write.",Will it a little bit cleaner if we call it in the caller of sendAndPoll?,do we need to unvoid..?,"you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}",@luyangco Why the handler is always ClientInputHandler in the PG branch?,"waitForCompletion(..) can still be outside the try-block, right?","1. I expect two exceptions here - one the user exception and the second the riemann exception. 2. loggers support exception stack trace built-in. This is the syntax: logger.warn(""Riemann error during exception send"",t);","Would be nice(r) if the pool didn't hand out nor keep inactive channels. This can be done by using sync() instead of await() when connecting (perhaps catch and wrap in CatchupClientException as well), and then register on the nettyChannel.closeFuture() some call into the pool which removes the channel if it is idle."
"public static boolean postHasEdits(@Nullable PostImmutableModel oldPost, PostImmutableModel newPost) { if (oldPost == null) { return newPost != null; } return newPost == null || !(StringUtils.equals(oldPost.getTitle(), newPost.getTitle()) && StringUtils.equals(oldPost.getContent(), newPost.getContent()) && StringUtils.equals(oldPost.getExcerpt(), newPost.getExcerpt()) && StringUtils.equals(oldPost.getStatus(), newPost.getStatus()) && StringUtils.equals(oldPost.getPassword(), newPost.getPassword()) && StringUtils.equals(oldPost.getPostFormat(), newPost.getPostFormat()) && StringUtils.equals(oldPost.getDateCreated(), newPost.getDateCreated()) && StringUtils.equals(oldPost.getSlug(), newPost.getSlug()) && oldPost.getFeaturedImageId() == newPost.getFeaturedImageId() && oldPost.getTagNameList().containsAll(newPost.getTagNameList()) && newPost.getTagNameList().containsAll(oldPost.getTagNameList()) && oldPost.getCategoryIdList().containsAll(newPost.getCategoryIdList()) && newPost.getCategoryIdList().containsAll(oldPost.getCategoryIdList()) && oldPost.getLocation().equals(newPost.getLocation()) && oldPost.getChangesConfirmedContentHashcode() == newPost .getChangesConfirmedContentHashcode() ); }",Shouldn't we call PostLocation.companion.equals here?,{} applies here too,"Can you use commons-lang for such thing ? For instance:  return EqualsBuilder.reflectionEquals(this, o);",Hi @adityabhaskar would this give the same result hence making the isEmpty() redundant? Let me know your thoughts. Thanks suggestion Boolean isPreviousPasswordBlank = previousPassword.trim().isEmpty();,recalculateModificationDate() is called in TransactionalPostService#deletePost we should not duplicate this call. You should investigate why this method was not called in TransactionalPostService#deletePost and fix.,"Do we want to check the isBookmarked field even if the is_bookmarked attribute is not supported by the server? Won't the effect be, that all posts from the server (which are saved for later) will be considered new/changed? I'm not sure about it, I just want to make sure, because I remember, I added this line as well, but I decided to remove it later.",Tell Dont Ask principal if (post.getAuthor().getUsername().compareTo(username) != 0) it's a good solution but in this way will create a anemic object(Post) i suggest to combine data and process them together in the Post object. if(post.isOwnedBy(username) is more expressive and readable [<LINK_0>](url),No parameter in setter method?,The isDiscardable method can be simplified to this:  java private boolean isDiscardable() { return !PostUtils.isPublishable(mPost) && isNewPost(); },value2 can get us ClassCastExceptions - I would make sure that both value1 and value2 are instances of the same object type,Should we compare only the first element of the list?
"public void noConflictTable() throws Exception, UpdateException { long baseline = System.currentTimeMillis(); final DataBuilderProvider.DataBuilder builder = DataBuilderProvider .row(-1, true); for (int i = 0; i < 1000; i++) { builder .row(i, true); } final Object[][] end = builder.end(); long now = System.currentTimeMillis(); System.out.println(""Loading of model took.. "" + (now - baseline) + "" ms""); baseline = now; final GuidedDecisionTable52 table52 = analyzerProvider.makeAnalyser() .withPersonAgeColumn(""=="") .withPersonApprovedActionSetField() .withData(end) .buildTable(); now = System.currentTimeMillis(); System.out.println(""Made table.. "" + (now - baseline) + "" ms""); baseline = now; final Analyzer analyzer = analyzerProvider.makeAnalyser(table52); now = System.currentTimeMillis(); System.out.println(""Indexing.. "" + (now - baseline) + "" ms""); baseline = now; analyzer.analyze(); now = System.currentTimeMillis(); System.out.println(""Validated.. "" + (now - baseline) + "" ms""); baseline = now; table52.getData() .get(1) .get(2) .setNumericValue(3); List<Coordinate> updates = new ArrayList<>(); updates.add(new Coordinate(1, 2)); analyzerProvider.getUpdateManager(table52, analyzer) .update(table52, updates); now = System.currentTimeMillis(); System.out.println(""Update.. "" + (now - baseline) + "" ms""); assertContains(REDUNDANT_ROWS, analyzerProvider.getAnalysisReport()); }",Please don't use sysout. Logging is your friend.,Shouldn't you explicitly save this?,"Don't test for the String content (that will change for other DBMSs), but instead call Base.exec(updateSQL) and check if it updated correctly, like this: 1. Do deleteAndPopulateTable(""students""); 2. Do Student s = Student.findById(1); and change some of the s attributes' values (including the ""dob"" and ""enrollment_date""). 3. Do Base.exec(updateSQL); 4. Do s = Student.findById(1); again and check if it has changed values. Check the ModelTest::shouldGenerateValidInsertSQL() test and do the same for the update as above.",I think this test is not very effective if we do not check the content of the set passed to the method update.,might want to remove :),we should use student.getName() instead of AdamUpdated,I think this test is not very effective if we do not check the content of the set passed to the method update.,"If there's a failure and rollback, the ongoing migration flag will be true until a relaunch, right? Does that mean that if the failure was caused by something that can be fixed, the user will need to also kill the app and relaunch for the migration to run? If so, that doesn't feel right to me.",Remove this,"You could print a result for println here and a different one for print later, so the output would be: println: X ms print: Y ms","Please also nullify the time stamp on {{BuddyAnonymized}}. With that, we prevent identity matching (the purpose of this ticket) and we can see how far we are with the migration."
"private void makeDependences(Job job, Map<String, ArrayList<String>> dependencies) throws JobCreationException { if (dependencies != null && dependencies.size() > 0 && job.getType() == JobType.TASKSFLOW) { TaskFlowJob tfj = (TaskFlowJob) job; for (Task t : tfj.getTasks()) { ArrayList<String> names = dependencies.get(t.getName()); if (names != null) { for (String name : names) { if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); } } } } } }","You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(""Unknown dependence: "" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(""Unknown dependence: "" + name));",Sometimes it produces non needed objects. Seems like wasting CPU time.,"you come rename this to, for example nonEligibleTaskNames",Consider adding a common utility method to check for duplicates in a list. I can't find a standard library to do so with a quick google search. Have you considered overriding the FlowTriggerDependency's equals method and hashCode method so that you may use a generic duplicate checking method?,attribute might depend only on single attribute? Isn't it possible to depend on more?,Set<String> = Collections.emptySet(),"You may just return Arrays.asList(""javax.inject.Inject"")",why not list.stream().forEach?,"I guess the list could be empty as well causing an indexoutofbounds on line 110. so adding "" || dispatchers.isEmpty()"" would make it safer.",This logic could also be moved into the Dependencies class.,"Also, it defeats any synchronization attempts. Returning a copy might be an option"
"private SubPlan reassignPartitioningHandleIfNecessaryHelper(Session session, Metadata metadata, SubPlan subPlan, PartitioningHandle newOutputPartitioningHandle) { PlanFragment fragment = subPlan.getFragment(); PartitioningHandleReassigner partitioningHandleReassigner = new PartitioningHandleReassigner(fragment.getPartitioning(), metadata, session); PlanNode newRoot; if (fragment.getPartitioning().isSingleNode()) { newRoot = fragment.getRoot(); } else { newRoot = SimplePlanRewriter.rewriteWith(partitioningHandleReassigner, fragment.getRoot()); } PartitioningScheme outputPartitioningScheme = fragment.getPartitioningScheme(); Partitioning newOutputPartitioning = outputPartitioningScheme.getPartitioning(); if (outputPartitioningScheme.getPartitioning().getHandle().getConnectorId().isPresent()) { newOutputPartitioning = newOutputPartitioning.withAlternativePartitiongingHandle(newOutputPartitioningHandle); } PlanFragment newFragment = new PlanFragment( fragment.getId(), newRoot, fragment.getSymbols(), fragment.getPartitioning(), fragment.getPartitionedSources(), new PartitioningScheme( newOutputPartitioning, outputPartitioningScheme.getOutputLayout(), outputPartitioningScheme.getHashColumn(), outputPartitioningScheme.isReplicateNullsAndAny(), outputPartitioningScheme.getBucketToPartition()), fragment.getStageExecutionStrategy(), fragment.getStatsAndCosts()); ImmutableList.Builder<SubPlan> childrenBuilder = ImmutableList.builder(); for (SubPlan child : subPlan.getChildren()) { childrenBuilder.add(reassignPartitioningHandleIfNecessaryHelper(session, metadata, child, fragment.getPartitioning())); } return new SubPlan(newFragment, childrenBuilder.build()); }",Should the condition here and the condition on 153 the same?,in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..,nit: temporaryTableHandle?,"hmm... I was thinking later we could also materialize a system partitioning (once we have native format)... Now I realized it might not be that straight.. But we don't need to think about it now :) . One thought is we can have a Exchange connector whose ConnectorPartitioning is SystemPartitioning.. And it actually writes to , for example HDFS...",nit: also check the exchange scope is REMOTE_MATERIALIZED,nit: Please consider filing an issue. -> Please file an issue.,change to:  !newLeft.isPresent() && !newRight.isPresent(),is this fix related to materialized exchanges or could it have been an issue before?,Using checkState like this looks weird. I'd just throw an IllegalXXXException.,nit: What about use switch here? (Together with the LOCAL before),"Please, move this variable up and reuse in the following places:  HiveMetadata hiveMetadata = getMetadata(tableScan.getTable()); ...tableScan.getTable().getConnectorHandle()"
"public void doPolling(Guid cmdId, List<Guid> childCmdIds) { RebootVmCommand<P> command = getCommand(cmdId); boolean anyFailed = false; for (Guid childCmdId : childCmdIds) { CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId); switch (entity.getCommandStatus()) { case FAILED: case FAILED_RESTARTED: case UNKNOWN: anyFailed = true; break; default: break; } } if (anyFailed) { command.setCommandStatus(CommandStatus.FAILED); } else { VM vm = DbFacade.getInstance().getVmDao().get(command.getParameters().getVmId()); if (isVmDownForColdReboot(vm)) { command.proceedWithColdRun(); } } }",what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..,This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.,I'm not sure if it is needed - wouldn't the command status be set to FAILED in this case?,so we get this every 10s for each and every snapshot?,"I have suggested that before... we can have the switch..case inside a try... catch block, IMHO.",same with setTaskGroupSuccess=false,"boolean failed = createAllSnapshotsFromVmCommand.finishCommand(); setCommandEndStatus(command, failed, status, childCmdIds);",You should add a warning log also here,here you can call endAction(). you'll need to set setTaskGroupSuccess to true. Look at ConvertVmCallback for reference.,please make this upper case,please make this upper case
public void run() { if (!mServiceConnection.isBound()) { mServiceConnection.unBindService(mContext); mCallback.onError(new AuthenticationException(ADALError.BROKER_BIND_SERVICE_FAILED)); } },It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).,"Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?",We should make removeConnectionCallbacks(...) and getServiceConnectionManager() package private since they are only used internally.,"When you bind here, you can hold a reference to the service so that this can be non-static. Also I'm not sure all the static access to the service is needed (regarding MigrationDownloadServiceBinder), you can check how is done here <LINK_0>",Can we add an error log here.,"This should be package scoped, not public.",Why we're adding the correlation id? Shouldn't it be already set when you start the event? #Closed,"Could not be posted, instead ... and you can fallback to print the error on the stderr",Could be declared final,Extract notification to own method notify...,"Formatting: Add delimiter at the end of the text, either colon or space before the thread id."
"public int hashCode() { return Objects.hash(machine, content); }","-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.",I think you need to add a null check; code in SourceFile assumes content can be null,can just be hash.hashcode(),"not consistent with equals, also the use of ID should be avoided",Just don't override the method instead of hashing the hash.,And this change should be reverted as well.,replicaList is not null so I would have just used replicaList.hashCode(). This might allocate a wrapper array for varargs. Objects.hashCode() is the single arg version that won't allocate.,Why are you overriding this ?,"Coud you rather use java.util.Objects.hash(_numeratorUnits, _denominatorUnits)?",HibernateUtils.unwrap(this) : the unwrap is useless. This can't be a proxy.,I think you can replace the code by  java 31 * Objects.hashCode(key) + Objects.hashCode(value)
"private Stream<Map<Address, InternalCacheEntry<K, V>>> getConflicts(LocalizedCacheTopology topology) { if (stateConsumer.isStateTransferInProgress()) throw log.getConflictsStateTransferInProgress(cacheName); if (!streamInProgress.compareAndSet(false, true)) throw log.getConflictsAlreadyInProgress(); try { return StreamSupport .stream(new ReplicaSpliterator(topology), false) .filter(filterConsistentEntries()); } finally { streamInProgress.compareAndSet(true, false); } }",isn't the topology always a LocalizedCacheTopology?,"This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.","This can just be  synchronized (this)  now. When I first saw this I expected it to be in a inner class, but it isn't any longer.",Should we make this a log message while we are here? :),typo: transfering => transferring,this is not the remote timeout. it is the state transfer timeout.,"Doesn't retrieveFromRemoteSources() need a loop, like retrieveFromRemoteSource()?",you could use Exceptions.expectExecutionException();,"The same argument as for GlobalStateStore should apply here -- StandbyTask don't write but only read, hence, no ProducerFencedException could ever happen here.",Use tabs,I don't see any waits to be woken up by this notify?
"public void testMergeRunnersEnsureGroupMerging() throws Exception { GroupByQuery query = GroupByQuery .builder() .setDataSource(""xx"") .setQuerySegmentSpec(new LegacySegmentSpec(""1970/3000"")) .setGranularity(QueryGranularities.ALL) .setDimensions(Lists.<DimensionSpec>newArrayList(new DefaultDimensionSpec(""tags"", ""tags""))) .setAggregatorSpecs( Arrays.asList( new AggregatorFactory[] { new CountAggregatorFactory(""count"") } ) ) .build(); final QueryRunnerFactory factory = GroupByQueryRunnerTest.makeQueryRunnerFactory(new GroupByQueryConfig()); QueryRunner mergedRunner = factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { return factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { try { return new MergeSequence( query.getResultOrdering(), Sequences.simple( Arrays.asList( factory.createRunner(createSegment()).run(query, responseContext), factory.createRunner(createSegment()).run(query, responseContext) ) ) ); } catch (Exception e) { Assert.fail(e.getMessage()); return null; } } } ).run(query, responseContext); } } ); Sequence<Row> result = mergedRunner.run(query, Maps.newHashMap()); List<Row> expectedResults = Arrays.asList( GroupByQueryRunnerTestHelper.createExpectedRow(""1970-01-01T00:00:00.000Z"", ""tags"", ""t1"", ""count"", 2L), GroupByQueryRunnerTestHelper.createExpectedRow(""1970-01-01T00:00:00.000Z"", ""tags"", ""t2"", ""count"", 4L) ); TestHelper.assertExpectedObjects(expectedResults, Sequences.toList(result, new ArrayList<Row>()), """"); }",Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e),[minor] ImmutableList.<Segment>of should also work and avoid the cast,Why called setDimensions two times?,Is this value right for the union dataSource? (hard to see since there's no non-union test to compare it to),"Here we have NULLIF(dim2, 'a') = NULL being translated as, - Old, when NullHandling.replaceWithDefault() is on: CASE WHEN dim2 = 'a' THEN TRUE ELSE dim2 IS NULL END - equivalent to dim2 = 'a' OR dim2 IS NULL - Old, when NullHandling.replaceWithDefault() is off: FALSE - New, when NullHandling.replaceWithDefault() is on: dim2 = 'a' - New, when NullHandling.replaceWithDefault() is off: FALSE I don't think the new dim2 = 'a' translation is really defensible: if it considers a null return from NULLIF due to dim2 = 'a' equal to null, then it should also count a null return due to dim2 IS NULL (or empty string, which should be equivalent if replaceWithDefault is on). The old translations are both correct, I think, in their respective modes. I just tried a similar query in PostgreSQL 9.6 and got zero back, which makes sense since PostgreSQL behaves in ""NullHandling.replaceWithDefault() is off"" (the SQL standard) mode, and should be treating this filter as ""always false"":  SELECT COUNT(*) FROM test WHERE NULLIF(NULL, 'a') = NULL OR NULLIF('a', 'a') = NULL  I looked into this for a few minutes but didn't see a reason yet why the translation changed. @xueyumusic - do you have any idea?",are we guaranteed the test won't get stuck if something fails the test?,"This should throw an exception. In general, groupBy v1 (which doesn't support outputType other than STRING) should throw an exception if outputType is anything other than STRING. The message should be something like ""groupBy v1 only supports outputType STRING"" which will give people a little push to use groupBy v2.","Here is an example: exception.expect(GerritHttpException.class); exception.expectMessage(HTTP_ERROR_400); executeQuery(query, option);",can you explain why this change ?,"suggest Assert.fail() here just to make sure the exception is actually thrown. Or, use the @Rule ExpectedException (example in FileTaskLogsTest)",The test would be somewhat more robust with an expectMessage too.
"public WTextAreaUI() { panel.add(messages); WFieldLayout fieldLayout = new WFieldLayout(LAYOUT_FLAT); fieldLayout.setTitle(""this is a bunch of fields""); WTextArea wTextField = new WTextArea(); fieldLayout.addField(""this is a textarea"", wTextField); wTextField.setMandatory(true); panel.add(fieldLayout); add(createWButton()); add(panel); }",Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?,Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.,This font resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the label.,"I don't think we want to clear out the existing styles. What if someone has defined some style classes in the ui binder file that uses this widget, this will wipe out those values.","This seems like a perfect case for a kotlin extension, don't you think? this.field.getTip().isNullOrEmpty() :) (just and idea)","the if can be inside the loop, right?",Can we extract this code to a utility class? It is repeated in several places,"Should be this.font(), and the same on the next line",we typically write the annotations on separate line,Give self-explanatory name here instead of p.,"Copying the style might not be what you want. It's nice for configuring a specific TextButton without affecting others, but you may want to use the same style everywhere so a change to the style affects all buttons. By using the style without copying, copying can be done before creating the TextButton, giving the flexibility of both at the cost of some boilerplate to do the copy."
"public String toString() { StringBuilder result = new StringBuilder(""[Test: \"""" + m_name + ""\"""").append("" verbose:"").append(m_verbose); result.append(""[parameters:""); for (Map.Entry<String, String> entry : m_parameters.entrySet()) { result.append(entry.getKey()).append(""=>"").append(entry.getValue()); } result.append(""]""); result.append(""[metagroups:""); for (Map.Entry<String, List<String>> entry : m_metaGroups.entrySet()) { result.append(entry.getKey()).append(""=""); for (String n : entry.getValue()) { result.append(n).append("",""); } } result.append(""] ""); result.append(""[included: ""); for (String g : m_includedGroups) { result.append(g).append("" ""); } result.append(""]""); result.append(""[excluded: ""); for (String g : m_excludedGroups) { result.append(g).append(""""); } result.append(""] ""); result.append("" classes:""); for (XmlClass cl : m_xmlClasses) { result.append(cl).append("" ""); } result.append("" packages:""); for (XmlPackage p : m_xmlPackages) { result.append(p).append("" ""); } result.append(""] ""); return result.toString(); }","You missed new StringBuilder().append(""[Test: \"""").append(m_name).append(""\"""")","Please use braces, even for single line statements.",'\t' is used more than once. Create a constant for this.,"This and following can be moved to the method as well, we just need to pass the matcher and the index (for appendFind we use index 0).",suggestion private void addMismatchReasonInternal(String reason) {,"why is this (and others) """"?",add assertion,"Change to: return new ToStringBuilder(this) .attr(""name"", m_name) .attr(""type"", m_type) .attr(""resolveMethod"", m_resolveMethod) .attr(""properties"", m_properties) .toString();",Looks like this toString() got generated before the tags field was added :P,"Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?","I assume this escaping won't work for other "" chars"
"public void testRename() throws Exception { typeContext = new LabelClientTypeContext(store, LabelType.METRIC, metrics, eventBus, MAX_CACHE_SIZE); final LabelId labelId = typeContext.createId(""oldName"").get(); ListenableFuture<Void> response = typeContext.rename(""oldName"", ""newName""); Futures.addCallback(response, new FutureCallback<Void>() { @Override public void onSuccess(final Void result) { Futures.addCallback(typeContext.getName(labelId), new FutureCallback<Optional<String>>() { @Override public void onSuccess(final Optional<String> result) { if (!result.isPresent()) { fail(); } assertEquals(""newName"", result.get()); } @Override public void onFailure(final Throwable throwable) { fail(); } }); } @Override public void onFailure(final Throwable throwable) { fail(); } }); }","See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.","This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail(""Rename should have failed when it did not find the current name"") would work otherwise?",This can be simplified to return Futures.immediateFuture(name);,This test will probably pass even though it should not. You need to block by calling #get on the result of both #createId and #rename.,Please use TestException so we don't mistake them with any other RuntimeException failures.,"This is a good way to handle exceptions in the CompletionStage. However, as you mentioned below, it makes sense to handle Try.NonFatalException in a special way. Because FatalException and NonFatalException cannot be created outside of a Try, they are under our control and it is safe to unbox them. I.e. we know that their only purpose is to wrap exceptions in a RuntimeException. From what I see the code should look look this: java final CompletableFuture<T> completableFuture = new CompletableFuture<>(); try { completableFuture.complete(get()); } catch(Try.FatalException x) { throw x; } catch(Try.NonFatalException x) { completableFuture.completeExceptionally(x.getCause()); } catch(Throwable x) { completableFuture.completeExceptionally(x); } return completableFuture;",Use 3-arg call with IMMEDIATE_EXECUTOR to lessen call depth,move this to the end of class,"Yes, or unbox a NonFatalException in the default toCompletableFuture impl. Unboxing it is perfectly ok because there is no public API that allows a call-site to construct a NonFatalException outside of a Try. Please find the suggested impl above...","Please add a java Objects.requireNonNull(computation, ""computation is null"");","java Objects.requireNonNull(callable, ""callable is null"");"
public void setLibraryAliasGenerator(NameGenerator<Library> generator) { this.libraryAliasGenerator = (DefaultLibraryAliasGenerator) generator; },Remove cast,"1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of ""alias is null"" -> alias is null. 5. Do the same for the other methods.",Qualify with this..,This means now that the conversion service can never be null. That means that all the checks for hasConversionService are no longer necessary. Would you mind creating a ticket to improve that (remove the hasConversionService checks) so that we remember for the future?,Need to declare lib as DetailedLibraryImpl above,Do you hate static imports? :),This is only called at the end of loadChildEntities. No need to re-fetch anything via DAOs below,Invalid parameter,"Perhaps you fix this in a later commit elsewhere, but there shouldn't be a setter here as this object is no longer immutable.","Is this just me, or this assignement became useless?  this.namespaceSupport = namespaceSupport;",Missing 'of'
public Set<Field> getFields() { return fields.keySet(); },"What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.","Minor: there is also a method, Predicates.asSet(In), that exposes the inner set. I think the purpose of that was to mimic the use of Ranges.asSet(Range), which has to be a static method because we allow ranges of objects that aren't Comparable but back the asSet method with a Guava range that requires a Comparable type. I'm fine with changing to use this method everywhere, since this is more straight-forward. But I'd like to either use Predicates.asSet(In) or In#getSet(), not both.",This should return an immutable collection.,"Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.",It is not possible to change field after instance creation. Why you create unmodifiable map each time this method is called? I would prefer use it once.,Using javax.Inject on Scout beans could have some unexpected behavior when running in a web container which includes its own DI mechanism (like CDI). I suggest to use an Scout-own inject annotation like @InjectBean,save an iterator by using index loop?,"This isn't right; requiredFields should be the names of fields that this aggregator is going to read, but makeFIeldNamesFromFields returns the output names. I think switching that to getDimension instead of getOutputName would work.",It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?,I think it makes sense to use builder and return ImmutableSet...,how come the set filters out nulls but the list does not? Seems like they should be consistent. My initial thought is that they should both include nulls.
"protected void deleteLog() { CommandContext commandContext = new CommandContext(); commandContext.setData(""SingleRun"", ""true""); commandContext.setData(""OlderThan"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"").format(new Date())); synchronized (this) { jobServicesClient.scheduleRequest(CONTAINER_ID, JobRequestInstance.builder().command(""org.jbpm.executor.commands.LogCleanupCommand"").build()); } }",This commandContext seems unused.,"We try to keep the list of registrations alphabetical here for readability, so it would be consistent to move this and the ActiveEntitlementJob above it to the start of the order.",My guess is that ResponseUrlDataCleanupJob.class should be used here in stead of ResponseDataCleanupJob.class?,"I know this is outside the scope of the PR but why did we do use ""delete"", when it should be a ""put"". The reason I say this is that we are stopping a resource (changing its state) not removing it.",style: extra parentheses,Not sure if we really need it. Half of the engine commands would probably not working correctly when you invoke commands before the backend initialization is done. Further I don't think that the REST api and the GWT frontend are even accessible until everything is properly initialized in the backend since they depend on it. @mperina is that correct?,Remove empty branch,"We shall use TestsPlugin.massageTimeout to allow for a tweak of timeout values when running on slow build machines. e.g. queueConsoleCommand(command, TestsPlugin.massageTimeout(DEFAULT_TIMEOUT), TimeUnit.MILLISECONDS);","Shouldn't this be done in transaction afterCommit block? Else, there is a chance that while the job-result is being updated, someone makes a get call (latestCompletedJobs), causing the cache to be updated with a supposedly stale object which wouldn't be invalidated.","The ""brackets for single statements"" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.",return setExecution ...
"private ContextMenuHandler showContextMenu() { if (contextMenuHandler == null) { contextMenuHandler = event -> { event.preventDefault(); event.stopPropagation(); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().show(); }; } return contextMenuHandler; }",Twice the same call.,do we want to schedule the timer for _all_ types of native events?,we have lambdas for this now.,"Please don't use null here. Just pass """" and make stateKey always concatenate.","If it's likely that we'll ever want to do something with the event in onCancel, it would be better to pass e here rather than null.",Alternatively you could use: java this.overlay.toBack();,"If you look at the hint lightbulbs in the IDE, you will see that you have a cluster of four of them for this constructor, and all of them are about calling overrideable methods in the constructor. This is something you should not do - see books like Java Concurrency in Practice or Effective Java for details. The short story is that for a class such as this, not final, you are calling methods that might be redefined by subclasses that have not been properly constructed yet. This is not thread safe. The solution is to use two part construction, which is something you can easily do here: 1) Make the constructor private. This needs to have been done anyway, since the class is a singleton. Allowing other classes in the package to construct an instance of this class breaks the singleton pattern. 2) Move the calls to the overrideable methods into a private init method, call it whatever you like. 3) Call the init method in getInstance, after the object is fully constructed.","It seems this variable is not used, can it be deleted?","Maybe extract all those menuContainer.xxx methods into some styleMenuContainer method? Also, do we need such styling to be applied on each context menu show? (If not, we can do it one-time inside the initWidget method.)","Maybe the method could be named in a way that doesn't mention implementation details, like startRename or something?","To make this work with Firefox too, this must be e.getNativeEvent().getKeyCode()"
"protected Control renderControl(SWTGridCell cell, Composite parent) throws NoRendererFoundException, NoPropertyDescriptorFoundExeption { final CTabFolder folder = new CTabFolder(parent, SWT.BOTTOM); folder.setBackground(parent.getBackground()); final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); final AdapterFactoryItemDelegator adapterFactoryItemDelegator = new AdapterFactoryItemDelegator( composedAdapterFactory); final EList<VAbstractCategorization> categorizations = getCategorizations(); for (final VAbstractCategorization categorization : categorizations) { final CTabItem item = new CTabItem(folder, SWT.NULL); final IItemPropertyDescriptor itemPropertyDescriptor = adapterFactoryItemDelegator.getPropertyDescriptor( categorization, VViewPackage.eINSTANCE.getElement_Name()); String categorizationName; if (itemPropertyDescriptor == null) { categorizationName = ""Categorization""; } else { final PropertyValueWrapper valueWrapper = (PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization); if (valueWrapper == null) { categorizationName = itemPropertyDescriptor.getDisplayName(categorization); } else { categorizationName = (String) ((PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization)).getEditableValue(categorization); } } item.setText(categorizationName); final AbstractSWTRenderer<VElement> renderer = getSWTRendererFactory().getRenderer(categorization, getViewModelContext()); final SWTGridDescription gridDescription = renderer.getGridDescription(GridDescriptionFactory.INSTANCE .createEmptyGridDescription()); for (final SWTGridCell gridCell : gridDescription.getGrid()) { final Control render = renderer.render(gridCell, folder); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.FILL).grab(true, true) .applyTo(render); item.setControl(render); } } composedAdapterFactory.dispose(); if (folder.getItemCount() > 0) { folder.setSelection(0); } return folder; }",what is a PropertyValueWrapper? Why do you need it?,isn't apply enable and apply readonly already called in the postinit call? Or is it to late?,I would prefer to move this to AbstractControlSWTRenderer as you rely on VControls,Ok for this correction. But here we have another issue: this class id defined in the common.ui plugn and could be used to rename somethinshg else. I think the title should be a parameter or have its setter.,Use a LInkedHashSet whenever the order is important or the set is used for iteration.,final,this must be disposed,typo,This font resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the label.,"This breaks our model, as we need the renderer to create a HandledContributionItem.",Double click on this table should cause the dialog to close and the selected commit to be used.
"public static void copy(File source, File dest) throws IOException { try (InputStream in = new FileInputStream(source)) { try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } } }",consider replacing 96-97 with just one try block (see line 455),source->bufferedSource & source2->source,UnsupportedOperationException (same with others),"If the code fails to close in, it will never try to close out","for such change. If the code fails to close in, it will never try to close out","Don't think we should catch all exceptions, like this the user won't see that the operation failed.",Wrap with try/finally to ensure the streams are closed in case of failure.,try with resources might be better here?,"This looks like a functional change, not a logging change?","You copied the file, not encrypted, right?","? (why is this needed, and if it is, why not a separate constructor?)"
"public boolean includeMethod( IMethodSelectorContext context, ITestNGMethod tm, boolean isTestMethod) { if (!m_isInitialized) { m_isInitialized = true; init(context); } if (script != null) { return getScriptSelector(script.getLanguage()).includeMethodFromExpression(script.getExpression(), tm); } return includeMethodFromIncludeExclude(tm, isTestMethod); }",So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.,Don't use string equals to evaluate a boolean.,@Override,I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?,What do you think if we add the parentModule logic directly into createInjector method?,Something is weird here: null is not logic and symmetry is lost. Maybe we need a setRetryAnalyzerClass and getRetryAnalyzerClass?,not working for null input,let's reduce complexity of this method,Don't you need a super.setUp() call here?,"How about giving the exact specific Gradle coordinates here, e.g ""org.beanshell:bsh:$version""?",No need of this..
"public String getUpload() { Desktop desktop = getDesktop(); String upload = _auxinf != null ? _auxinf.upload : null; if (desktop != null && !Strings.isEmpty(upload) && !upload.contains(""maxsize="")) upload = upload.concat("",maxsize="" + desktop.getWebApp().getConfiguration().getMaxUploadSize()); return upload; }",not good to add sth when calling getter,"could use general regex? like split "","" to get a map",suggestion return isBlank(str) ? str : defaultString(prefix) + str;,"suggestion Long multiplier = Double.valueOf(Math.pow(1024,pow)).longValue();","Just using plus + operators would be easier to read (and actually perform a little bit better). Also, inline this prefix.isEmpty() ? key : prefix + ""."" + key to the caller would save a method dispatch.",suggestion return isEmpty(str) ? str : defaultString(prefix) + str;,"Could this method, and setPurgeTimeout, be package-private? Still testable, and reduces risk of misuse.","should probably test for null delimiter and either ignore or preferably interpret null as ""no delimiter"" (the empty String)",Make it static,You should probably be using a StringBuilder instead of a String,Can you add this property in secor.common.properties with default value. We prefer setting the default value in properties file instead of java class. Is default value 3 better than 5?
"public void testSendCloseSession() throws Exception { assertTrue(""Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!"", serverFactory instanceof NettyServerCnxnFactory); try (ZooKeeper zk = createClient()) { final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer(); final String path = ""/a""; zk.create(path, ""test"".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); assertNotNull(""Didn't create znode:"" + path, zk.exists(path, true)); assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount()); Iterable<ServerCnxn> connections = serverFactory.getConnections(); assertEquals(""Mismatch in number of live connections!"", 1, serverFactory.getNumAliveConnections()); for (ServerCnxn serverCnxn : connections) { serverCnxn.sendCloseSession(); } LOG.info(""Waiting for the channel disconnected event""); int timeout = 0; while (serverFactory.getNumAliveConnections() != 0) { Thread.sleep(1000); timeout += 1000; if (timeout > CONNECTION_TIMEOUT) { fail(""The number of live connections should be 0""); } } assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount()); } }",Please don't do unrelated refactor work next time,I think the TEST_ROOT already contains the test method name.,"Actually this is no need. If exception is thrown here, test will fail.","this is generally an anti-pattern in the tests and leads to flakey tests. e.g. we can see on some test environments that are oversubscribed. I'd suggest something very large, e.g. 30 seconds or just using the session timeout.",This one can also be final.,typo: continuously,Exception as last argument,"I recall that you mentioned many times that the operator must be at the end of a line so I changed my formatter config to do this, so now you prefer the operator at the start of a line? I'm fine with both, just want to know which one do you want, or it is not important?",suggestion assertTrue(clientId1 < clientId2);,Where did the connectionloss keeper exception get converted to ZKTimeoutException?,Is this a race condition? I reverted this test and it seems to run fine for me (the 5 times I've run it)
"public static SentryStackTraceElement[] fromStackTraceElements(StackTraceElement[] stackTraceElements) { Frame[] localsCache = LocalsCache.getCache(); SentryStackTraceElement[] sentryStackTraceElements = new SentryStackTraceElement[stackTraceElements.length]; boolean mayHaveLocals = localsCache.length == stackTraceElements.length; for (int i = 0; i < stackTraceElements.length; i++) { Map<String, Object> vars = null; if (mayHaveLocals) { Frame frame = localsCache[i]; Frame.LocalVariable[] frameLocals = frame.getLocals(); if (frameLocals != null && frameLocals.length > 0) { for (Frame.LocalVariable localVariable : frameLocals) { if (localVariable != null) { if (vars == null) { vars = new HashMap<>(); } vars.put(localVariable.getName(), localVariable.getValue()); } } } } sentryStackTraceElements[i] = fromStackTraceElement(stackTraceElements[i], vars); } return sentryStackTraceElements; }",This check seems a little fragile at first glance (not sure why.),"If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?",check if current or next,"This seems odd, why are you popping based on currObjSize? pop() should only be called when END_* tokens are processed.","No need to have a final local var, please use an Immutable List from guava and please build it looping through the stack as it will involves less iterations than constructing a new list and slicing it.",what if already bound to a value (e.g. in case of loop edge)? Didn't you have to perform an equality check here for the analogous pattern call extend?,make this default,"What's the reasoning for returning a LocalVariable[] instead of a Map<String, Object> directly here?","Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)",This makes it technically possible to break usage of this method. (Calling it with a class that is not a Frame). Is that what you really wanted to do?,I think it should return Array here.
public void runBeforeAllTests() { conceptService = Context.getConceptService(); executeDataSet(STANDARD_TEST_DATASET_XML); },Isn't this dataset automatically executed?,You no longer need to set this locale here since the save handler does this for you,Can we remove these empty new lines?,let's use imports on this one and the following,"it's better to start this method name with assert verb, as that's what happens inside","This calls into JenaTextExample1.java which, after you reverted it, uses Lucene. I think you need to have an ES version of that class as well, something like JenaTextESExample1.java, and call that instead here.",Please use one column index.,"You need a test for elemMatch. I think one way you can do this is: - create a doc with CI index in array element field - manually modify array index so array._.field=""someValue"" and array._.@mongoHidden.field=""REALVALUE"" - regex search for ""realvalue"", it should find it.",You could factorize the 2 cases as the only difference is setting patterntofind or not.,"Since you are using OriginalText in more than one place, can you use a constant for it?",Why don't you put this in the setup method?
"public static void setParamsWithRegistrationConfigurationMappings(RegistrationConfiguration registrationConfiguration, ImportFromConfParameters params) { if (registrationConfiguration.getAffinityGroupMappings() != null && registrationConfiguration.isSetAffinityGroupMappings()) { Map<String, Object> affinityGroupMap = new HashMap<>(); affinityGroupMap.put(AFFINITY_GROUP_KEY, mapAffinityGroupMapping(registrationConfiguration.getAffinityGroupMappings())); params.setAffinityGroupMap(affinityGroupMap); } if (registrationConfiguration.getAffinityLabelMappings() != null && registrationConfiguration.isSetAffinityLabelMappings()) { Map<String, Object> affinityLabelMap = new HashMap<>(); affinityLabelMap.put(AFFINITY_LABEL_KEY, mapAffinityLabelMapping(registrationConfiguration.getAffinityLabelMappings())); params.setAffinityLabelMap(affinityLabelMap); } if (registrationConfiguration.getClusterMappings() != null && registrationConfiguration.isSetClusterMappings()) { Map<String, Object> clusterMap = new HashMap<>(); clusterMap.put(CLUSTER_KEY, mapClusterMapping(registrationConfiguration.getClusterMappings())); params.setClusterMap(clusterMap); } if (registrationConfiguration.getLunMapping() != null && registrationConfiguration.isSetLunMapping()) { Map<String, Object> lunMap = new HashMap<>(); lunMap.put(EXTERNAL_LUN_KEY, mapExternalLunMapping(registrationConfiguration.getLunMapping())); params.setExternalLunMap(lunMap); } if (registrationConfiguration.getRoleMappings() != null && registrationConfiguration.isSetRoleMappings()) { Map<String, Object> roleMap = new HashMap<>(); roleMap.put(ROLE_KEY, mapExternalRoleMapping(registrationConfiguration.getRoleMappings())); params.setRoleMap(roleMap); } if (registrationConfiguration.getDomainMappings() != null && registrationConfiguration.isSetDomainMappings()) { Map<String, Object> domainMap = new HashMap<>(); domainMap.put(DOMAIN_KEY, mapExternalDomainMapping(registrationConfiguration.getDomainMappings())); params.setDomainMap(domainMap); } }","If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to ""params.setAffinityGroupMap"" directly the result of ""mapAffinityGroupMapping"": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?","I don't think we can give RegistryConfig a default value RegistryConfig.NO_AVAILABLE, instead we should leave it empty. We will try to refresh this RegistryConfig later, if the user fails to set the right item for RegistryConfig, it will receive an Exception then when checking isValid. But if we give it this default value, it will always pass isValid and does register URL to Registry Center which can be unexpected behaviour.","suggestion if (System.getProperties().containsKey(""javax.net.ssl.trustStore"")) {  this suggestion would look clear to me.","This could be null, we should probably handle this if the JIRA api changes again",size can be provided as we iterate on registryPrefixes length,Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); },We have a removeConfiguration so let's not allow null value here?,RegistrationUpdate should be immutable,"Optionally, Files.readAllLines() provides a smoother way to read the definition file: I bet you can use its output directly as a stream.",Should there be RowKey#getColumnValue(String name)? This would make this code here a bit easier to grasp.,You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
"private void fillDriverSpecificChannelConfiguration(final Tocd mainOcd, final List<Tad> driverSpecificChannelConfiguration) { final ChannelDescriptor basicChanneldescriptor = new BaseChannelDescriptor(); final Object baseChannelDescriptor = basicChanneldescriptor.getDescriptor(); if (nonNull(baseChannelDescriptor) && baseChannelDescriptor instanceof List<?>) { List<Tad> channelConfiguration = (List<Tad>) baseChannelDescriptor; channelConfiguration.addAll(driverSpecificChannelConfiguration); for (final Tad attribute : channelConfiguration) { final Set<String> channelPrefixes = retrieveChannelPrefixes(this.assetConfiguration.getAssetChannels()); for (final String prefix : channelPrefixes) { final Tad newAttribute = cloneAd(attribute, prefix); mainOcd.addAD(newAttribute); } } } }",Add invariants,iteration over the entrySet is faster,"Please make a defensive copy of the list before returning to avoid side-effects on this class by potential mutations of the list by the caller. Ideally, return it as a Collections.unmodifiableList(channels).",Instead of iterating through this once to add to the map then again to check for duplicates - could we just check if it already exists here and do the logger warn in this initial iteration?,channelRecordsToWriteChannels,is uniqueness of channelTypes guaranteed? The former HashSet would have removed duplicates.,I would add a constructor with Collection<Attribute> to avoid to create unnecessary array. You can look at ObjectModel it's a bit the same idea.,"Shouldn't this be just one line above, before setOutputChannels() ?",@v-stepanov Is method marked as @Nullable ?,Doesn't this change mean you'll end up doing the update twice?,"Should we maybe also trim the strings? Keep in mind us poor human beings who were ~~forced~~ taught in school to waste paper with spaces like this extensible=""alarm, brightness, foo, bar"""
"protected ACTION getUserAction(Cluster cluster, Path buildPath) throws FalconException { ACTION action = unmarshalAction(ACTION_TEMPLATE); JAXBElement<org.apache.falcon.oozie.spark.ACTION> actionJaxbElement = OozieUtils.unMarshalSparkAction(action); org.apache.falcon.oozie.spark.ACTION sparkAction = actionJaxbElement.getValue(); String sparkMasterURL = entity.getSparkAttributes().getMaster(); Path sparkJarFilePath = new Path(entity.getSparkAttributes().getJar()); String sparkJobName = entity.getSparkAttributes().getName(); String sparkOpts = entity.getSparkAttributes().getSparkOpts(); String sparkClassName = entity.getSparkAttributes().getClazz(); String clusterEntitySparkMasterURL = getClusterEntitySparkMaster(cluster); sparkMasterURL = (sparkMasterURL == null) ? clusterEntitySparkMasterURL : sparkMasterURL; if (StringUtils.isBlank(sparkMasterURL)) { throw new FalconException(""Spark Master URL can'be empty""); } sparkAction.setMaster(sparkMasterURL); sparkAction.setName(sparkJobName); addPrepareDeleteOutputPath(sparkAction); if (StringUtils.isNotEmpty(sparkOpts)) { sparkAction.setSparkOpts(sparkOpts); } if (StringUtils.isNotEmpty(sparkClassName)) { sparkAction.setClazz(sparkClassName); } List<String> argList = sparkAction.getArg(); List<String> sparkArgs = entity.getSparkAttributes().getArgs(); if (sparkArgs != null) { argList.addAll(sparkArgs); } addOutputFeedsAsArgument(argList, cluster); addInputFeedsAsArgument(argList, cluster); validateSparkJarFilePath(sparkJarFilePath); sparkAction.setJar(getSparkJarFileName(sparkJarFilePath)); setSparkLibFileToWorkflowLib(sparkJarFilePath, entity); propagateEntityProperties(sparkAction); OozieUtils.marshalSparkAction(action, actionJaxbElement); return action; }",just pass sparkJarFilePath.toString less number of changes will be required in the code.,Shouldn't we throw an exception here ?,This should establish the region from the Lambda environment. Use System.getEnv().get('AWS_REGION').,"This first null check is not necessary, as String.equalsIgnoreCase() checks for null and returns false if it is false.","Should remove this logic. Enforcing node labels is the original queue enforcement mechanism. With the dynamic-allocation aware queue enforcement, we should use the logic for handling queue enforcement, and handleNodeLabeling method should now only deals with auto node labeling.",Perhaps we should name this directory _resources_...?,Lets create constants for these strings,"@zjffdu - I think we need a fast way to abstract out the different launchers, instead of bringing everything in here (plus artifacts like kubernetes-client). Do you have any thought on that?","Can you replace ""azkaban.flow.nested.path"" in line 160 above with CommonJobProperties.NESTED_FLOW_PATH?","Not important, but consider saving the result of jobName.indexOf('/') instead of calling it twice.",Are you aware of the BangBang project? Let's discuss with @cwsteinbach about future directions on how to manage user specified dependencies.
"public ArrayList<Pojo> getResults(String query) { ArrayList<Pojo> pojos = new ArrayList<>(); if (android.os.Build.VERSION.SDK_INT >= 11) { Set<String> selectedProviders = new TreeSet<>(); selectedProviders.addAll(PreferenceManager.getDefaultSharedPreferences(this).getStringSet(""search-providers"", new HashSet<>(Arrays.asList(""Google"")))); for (String searchProvider : selectedProviders) { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.url = searchProviderUrls.get(searchProvider); pojo.name = searchProvider; pojos.add(pojo); } } else { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.name=""Google""; pojo.url = searchProviderUrls.get(""Google""); pojos.add(pojo); } Pattern p = Pattern.compile(URL_REGEX); Matcher m = p.matcher(query); if(m.find()) { String guessedUrl = URLUtil.guessUrl(query).toString(); if(URLUtil.isValidUrl (guessedUrl)) { SearchPojo pojo = new SearchPojo(); pojo.query = """"; pojo.relevance = 50; pojo.name = guessedUrl; pojo.url = guessedUrl; pojo.direct = true; pojos.add(pojo); } } return pojos; }",Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.,not needed,"I think that there's probably a way for ListPreference to take care of updating the summary for you, so I think this preference change listener should just go in SearchEngineFactory. Then setDefault could be a private method.","Can you return listOpApps.size() > 0 ? listOfApps.last() : null; or maybe use listOfApps.pollLast() if you use TreeSet directly on line 354. I think this better communicates the intend of the code, and it removes the not so relevant variable declaration at line 353.","My inclination would be to make this regular expression a local variable, add a capture group for the integer, and then reuse that on lines 142 to get the version. Relying on a regular expression here and split below seems like it could create problems in the future if someone only updates this in one place.",Might be easier to understand and more efficient if you use the system provided arraycopy function,Use Constants.TAG,instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.,Is this a good way of converting the keys to a List? Why not similar to <LINK_0>,"Can you please show me, where the ""best_resolution"" comes from? I do not have time to look it up and you already managed to find it once :)","These four variables do not need to be declared globally, you can declare it directly in registerFabUploadListeners method, where are going to be used."
public AutoRegisterModules discover() throws InvalidPluginException { sysSingletons = Sets.newHashSet(); sysListen = LinkedListMultimap.create(); if (sshGen != null) { sshGen.setPluginName(pluginName); } if (httpGen != null) { httpGen.setPluginName(pluginName); } scan(); if (!sysSingletons.isEmpty() || !sysListen.isEmpty()) { sysModule = makeSystemModule(); } if (sshGen != null) { sshModule = sshGen.create(); } if (httpGen != null) { httpModule = httpGen.create(); } return this; },The same.,Why public? Gerrit conversion is to mark injected constructors as package provided,pluginsSubsections could be inlined,use setDirectory() ?,Unchecked.consumer(plugin::customizeJdbi).accept(this); is the right mantra :),Unnecessary. There is nothing in the Guice world to start or stop.,This can be replaced with NoopAuthorizationManager.,Google's Java style requires methods to be lower-camel-case. e.g. convertChunkSourcesToModules() This looks like Python code to me. :),Good job!,here it could be if(Android.SDK_BUILD >= 19) { static function to create that class (and specify full classpath to the class without imports) },A LinkedList is better since you don't seem to access specific indexes anyways.
"public <K, V> MessageStream<KV<K, V>> partitionBy(Function<? super M, ? extends K> keyExtractor, Function<? super M, ? extends V> valueExtractor, KVSerde<K, V> serde) { int opId = this.graph.getNextOpId(); String opName = String.format(""%s-%s"", OperatorSpec.OpCode.PARTITION_BY.name().toLowerCase(), opId); IntermediateMessageStreamImpl<KV<K, V>> intermediateStream = this.graph.getIntermediateStream(opName, serde); PartitionByOperatorSpec<M, K, V> partitionByOperatorSpec = OperatorSpecs.createRepartitionOperatorSpec( intermediateStream.getOutputStream(), keyExtractor, valueExtractor, opId); this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return intermediateStream; }","The phrase ""repartition"" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data.",Can't tell how this works from this RB alone. Is this going to become the logical id for the stream when you create a spec for it in the Planner? And then the physical name by default appends the JOB_NAME and JOB_ID?,Are these < 120 chars? Prefer older formatting (i.e. opId get call on its own line) for consistency.,"Would be nice to have all operator-specs being created consistently - instead of using statics for some and constructors for others. Also, would be great to do this as a separate clean-up so that it does not detract from the core-focus of this PR","Isn't the type parameter <JM, K,M, RM> inferable from the type of parJoin2?",Issue: Why create wrapper functions?,"minor: it seems that getNextOpId(code, null) was repeated many times. Might be better to add another getNextOpId(code) to avoid typing null repeatedly. But, you call.",Are these type annotations required?,Minor: would be cleaner to have an overload instead of multiple null versions.,"Maybe: ""keyFunction for partitionBy should not implement TimerFunction or WatermarkFunction.""","So, are we closing the door for any user-defined context to be used in window? i.e. if the fold function refers to a hashMap that is initialized in the task context? We already allowed user-defined context to be used in map/flatMap/filter/join, I don't see why not window? Is there any harm done in allowing optional init() function in window as well?"
"public RealmIdentity getRealmIdentity(final Principal principal) throws RealmUnavailableException { boolean ok = false; final RealmIdentity authenticationIdentity = authenticationRealm.getRealmIdentity(principal); Principal authorizationPrincipal = principal; if(principalTransformer != null) { authorizationPrincipal = principalTransformer.apply(authorizationPrincipal); if (authorizationPrincipal == null) return null; } final RealmIdentity[] authorizationIdentities = new RealmIdentity[authorizationRealms.length]; try { for (int i = 0; i < authorizationIdentities.length; i++) { SecurityRealm authorizationRealm = authorizationRealms[i]; authorizationIdentities[i] = authorizationRealm == authenticationRealm && principalTransformer == null ? authenticationIdentity : authorizationRealm.getRealmIdentity(authorizationPrincipal); } final Identity identity = new Identity(authenticationIdentity, authorizationIdentities); ok = true; return identity; } finally { if (!ok) { authenticationIdentity.dispose(); for (RealmIdentity current : authorizationIdentities) { if (current != null) current.dispose(); } } } }",Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.,"There's an inherent race here, if the following sequence occurs: 1. Thread A: getRealmIdentityForUpdate 2. Thread A: removeFromCache 3. Thread B: getRealmIdentity 4. Thread A: modify credentials 5. Thread B: authenticate with wrong credentials, which are cached forever The entry should only be removed from the cache *after* modifications occur, i.e. ModifiableRealmIdentity has to be wrapped as far as I can tell.",Why is this one DEBUG instead of TRACE?,"Why is not the check of presence of certificate with given alias left for the next processing, like in case (principal instanceof NamePrincipal) == true?","just remove this check and the corresponding else. managementRealmOpenTask permissionRealmOpenTask may finished at the different time, so you could have managementRealm != null but permissionRealm == null",Call last?,You can initiate it with RealmResult size.,RealmList? Also we don't have Realm.refresh(),why not just LOG.debug()? it doesn't look sensitive,what thread is this on that it has a looper but is called AsyncTask?,I think that this may overlap with concurrent updates to the authorities by other threads
"protected void doStart() throws Exception { super.doStart(); if (!Files.exists(baseDirectory)) { if (getEndpoint().isAutoCreate()) { baseDirectory = Files.createDirectories(baseDirectory); } else { throw new RuntimeCamelException(""Path must exists when autoCreate = false""); } } if (!Files.isDirectory(baseDirectory)) { throw new RuntimeCamelException(String.format(""Parameter path must be directory, %s given"", baseDirectory.toString())); } DirectoryWatcher.Builder watcherBuilder = DirectoryWatcher.builder() .path(this.baseDirectory) .logger(log) .listener(new FileWatchDirectoryChangeListener()); if (!System.getProperty(""os.name"").toLowerCase().contains(""mac"")) { watcherBuilder.watchService(this.baseDirectory.getFileSystem().newWatchService()); } watcherBuilder.fileHashing(getEndpoint().isUseFileHashing()); if (getEndpoint().getFileHasher() != null && getEndpoint().isUseFileHashing()) { watcherBuilder.fileHasher(getEndpoint().getFileHasher()); } this.watcher = watcherBuilder.build(); watchDirExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, ""CamelFileWatchService"", getEndpoint().getPollThreads()); pollExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, ""CamelFileWatchPoll"", getEndpoint().getConcurrentConsumers()); for (int i = 0; i < getEndpoint().getPollThreads(); i++) { this.watcher.watchAsync(watchDirExecutorService); } for (int i = 0; i < getEndpoint().getConcurrentConsumers(); i++) { pollExecutorService.submit(new PollRunnable()); } }",We tend to use IllegalArgumentException for these kind,"From a ""reading"" feature, I would not expect it to create folders. If a folder does not exist, it might rather throw an IllegalArgumentException. Who knows what nasty things you can do if you can trigger a folder creation using a relative path through ConfigAdmin!","use the supplier version  Logger.debug(PushPublishFiltersInitializer.class, ()-> "" dotcms filters files copied"");",extract DebugPlugin.getDefault()?,"Extra space before  + ""/logs"".",See also DefaultDockerClientConfig::dockerConfigPath field,Delete 'throws Exception'? Also above.,"Sorry for the confusion. We are already finding a random port in this way within our configuration support. The problem is sometimes the port gets resolved to an open port and assigned, the port is then taken up by another process or thread, and then this code tries to use the now taken port. To fix this we want to be able to pass in 0 to TcpTransport to avoid a race condition.",I know this is not your code ... but should we throw an exception instead of silently accepting the problem?,"suggestion throw new AbortException(""Unable to get valid Kubernetes authentication from given credentialsId "" + credentialsId,e);",Why close twice?
"public String getDescription() { return Localization.lang( ""Removes all {} brackets around words.""); }","add ""balanced"" ?",return LanguageUtil.LOCALE_CACHE.getUnchecked(this.locale);,"I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.",Doesn't this method accept nullable fields anyway?,This can / should probably be Locale.ROOT yeah?,"Parsing html should be done outside of Feed.java. Feed is the model that represents the actual feed. How we display the feed afterwards does not belong to the feed itself, in my opinion.","What's the reasoning for returning a LocalVariable[] instead of a Map<String, Object> directly here?",This kind of depends on the config patch but can we use optJSONArray() instead?,I would appreciate if you can split this in several lines with some temporary variables to make it more readable.,Should be 'contains',This method returns non-sense.. the list of locales that this instance of ProgramAB supports would be the list of locales for any of the bots that are currently available.. not this list. make it return null.. or something.. this list is just wrong.
"public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException { ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile()); if (useSsl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, ""true""); } if (useSasl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, ""true""); } if (getZooKeeperInstance().size() > 0) { List<String> zkOpts = getZooKeeperInstance(); String instanceName = zkOpts.get(0); String hosts = zkOpts.get(1); clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, hosts); clientConfig.setProperty(ClientProperty.INSTANCE_NAME, instanceName); } if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) { AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig)); clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST)); } if (null != zooKeeperHosts) { clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts); } return clientConfig; }",Conditional is more clear as: !getZooKeeperInstance().isEmpty(),can try with resources be used here?,"I actually think it's okay to preserve the code which filters out the invalid properties. This is a one-way conversion to what we need internally... it shouldn't contain anything that we don't recognize internally. If somehow keeping that stuff around avoids a failure, we should not mask that failure by including those unknown properties.","this block is repeated in AgentService and MasterService, just with a reversal of the labels, maybe it can be moved into the CuratorClientFactory?","shouldn't you close the client when it is done?  try (ZooKeeperClient client = new DefaultZooKeeperClient(curator, zooKeeperClusterId)) { client.start(); client.initializeAclRecursive(""/"", aclProvider); }",check for empty/null agent password,"It is not strictly necessary to make this method non-static, is it?","You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.",nit: throw new IOException....,"You can pass useNewZNodePath and mockRouter to the factory constructor. Then all the tests won't need the if/setupRouter code, the factory can do that.","This ""this"" is not necessary after we change the name to _zkClient."
"private void recordLatency(Response<? extends Request> response, String operation) { Serializable start = response.getRequest().getPropertyValue(METRICS_OPERATION_START); long latency = calculateLatency((Long) start); if (latency > 0) { DistributionSummary.builder(metricName(METRIC_PREFIX, operation, ""latency"")) .baseUnit(""milliseconds"") .tags(""successful"", Boolean.toString(response.getProcessingErrors().isEmpty())) .publishPercentiles(0.5, 0.95) .register(Metrics.globalRegistry) .record(latency); } }","If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(""Computed a suspicious latency of {} for {}"", latency, operation); return; } DistributionSummary.builder(...)",Again this in the one line looks really cumbersome. Also the fact it's used in at least 2 places means this should probably be a util method. Would make this clearer and avoid human error which is definitely possible for something like this.,"Start millis being either the reporting frequency or the actual start nano time is potentially confusing at two levels. 1. The variable says milli though we assign nanos to it. 2. The variable probably should be one value or another. Having a variable's meaning depend on the context and previous call history is a SRP violation. Perhaps we really want two different variables and make them internally nullable. Another option is to have a simple internal object to track this for us, that object could then provide a nice API to abstract away time keeping details.","Parameterized type, please change this to LatencyListener<T>... new LatencyListener<>(resultHandler, ...)",code style,main thing is to keep our Prometheus stable so folks using grafana dont wake up to have their graphs broken. I will look carefully though,I think the division is stil needed.,Better to create a setter for timeStart.,When is it possible that PrevStatus is not STOPPED but status is STARTING?,please apply the correct type literals,You are overwriting here the value of serverLatencyFeed calculated in connectServiceLatencySensor(). Why?
"public Object execute(ExecutionEvent event) throws ExecutionException { final Repository repo = getRepository(true, event); IResource[] resources = getSelectedResources(event); if (repo == null) return null; CommitSelectionDialog dlg = new CommitSelectionDialog(getShell(event), repo, resources); if (dlg.open() != Window.OK) return null; if (resources.length == 1 && resources[0] instanceof IFile) { final IFile baseFile = (IFile) resources[0]; final ITypedElement base = SaveableCompareEditorInput .createFileElement(baseFile); final ITypedElement next; ITypedElement ancestor = null; RevCommit commonAncestor = null; try { RepositoryMapping mapping = RepositoryMapping .getMapping(resources[0]); next = getElementForCommit(mapping.getRepository(), mapping .getRepoRelativePath(baseFile), dlg.getCommitId()); commonAncestor = RevUtils.getCommonAncestor(repo, repo.resolve(Constants.HEAD), dlg.getCommitId()); if (commonAncestor != null) ancestor = CompareUtils.getFileRevisionTypedElement( mapping .getRepoRelativePath(baseFile), commonAncestor, mapping.getRepository()); } catch (IOException e) { Activator.handleError( UIText.CompareWithIndexAction_errorOnAddToIndex, e, true); return null; } final GitCompareFileRevisionEditorInput in = new GitCompareFileRevisionEditorInput( base, next, ancestor, null); in.getCompareConfiguration() .setRightLabel(dlg.getCommitId().name()); if (commonAncestor != null) in.getCompareConfiguration() .setAncestorLabel(commonAncestor.name()); CompareUI.openCompareEditor(in); } else { CompareTreeView view; try { view = (CompareTreeView) PlatformUI.getWorkbench() .getActiveWorkbenchWindow().getActivePage().showView( CompareTreeView.ID); view.setInput(resources, dlg.getCommitId().name()); } catch (PartInitException e) { Activator.handleError(e.getMessage(), e, true); } } return null; }",This seems to be unnecessary. I also get the label after removing this.,Should we maybe check with instanceof GitCompareFileRevisionEditorInput.EmptyTypedElement directly?,Can't this line just live in try block above?,Shouldn't it the other way round? The eclipse standard is that the newer version is on the left side.,avoid unrelated formatting changes,This returns the parent of the HEAD commit but not the HEAD commit.,Should we size this?,"Please add missing braces, here and also above and below.",Could you extract the body of this into its own method? It's not very readable here.,"Might as well implement this, since it'll be the exact same as for a binary return dataLoader.getParentObject(this);",There should be a status bar indicating that the file contains errors and the renaming may be unsuccessful. Add a warning icon. Maybe you can use / reuse parts of the TitleAreaDialog <LINK_0>
"private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( ""org.Address"", new ModelField[]{ new ModelField( ""this"", ""org.Address"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, ""this"" ), new ModelField( ""street"", ""String"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( ""homeAddress"", ""Boolean"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( ""number"", ""java.lang.Integer"", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }",@jomarko Thanks.. I'd have made this Integer.class.getName() too,This looks like it's just for card payments so don't think we should add these her.e,"Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.",Recommend to use ToStringBuilder,Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method,nit: extra line after if,Check address == null once at the begin of the function and return early.,"Why not make this create simple string and then invoke the setAddress(simplestring) , there by not needing the two new methods and logic encapsulated in the setAddress(simplestring)","from what I remember, the addUnsavedProperty doesn't really do anything useful and therefore should be removed. So as not to pollute the code, please confirm it and refactor it as needed.",Please don't add more utility methods to Message. Instead you could create a method ListHeaders.getListPostAddress(Message) that gets the appropriate header from the message.,Tab... lol
"private boolean processRow(String line) { List<String> values = ImmutableList.copyOf(ON_COMMA.split(line)); if (Iterables.size(values) < 8) { return true; } BbcGenreTree.Builder genreTree = BbcGenreTree.builder(genresPrefix + values.get(0)); if (!Strings.isNullOrEmpty(values.get(1))) { genreTree.withSecondLevelGenre(genresPrefix + stripQuotationMarks(values.get(1))); } if (!Strings.isNullOrEmpty(values.get(2))) { genreTree.withThirdLevelGenre(genresPrefix + stripQuotationMarks(values.get(2))); } mapping.put(genreTree.build(), parseYouViewGenres(Iterables.skip(values, 4))); return true; }",Log/throw?,"Is there value in testing with more than one setting here? I agree this is the highest priority since it is the default, but the extremes of 0 and 9 are also worth checking.",u crazy?,"The indentation appears to be a bit off here. Please try to make it consistent with the rest of the file Also, I think the last two lines could be one line as before:  return ""..23456789TJQKA"".indexOf(card.charAt(0));  Or if you would rather extract the string as a variable, then it should be given a useful and descriptive name, e.g. possibleRanks","This should have = not -, that's why the build is failing","I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:","Should make sure the constructor and this method follow the same pattern around ensuring the internal values list isn't mutable. Right now the constructor will clone the list, effectively a deep clone based on how Strings work, ensuring it is immutable if the original list changes but this will return a reference to the internal list that could be mutated.","""NULL"".equals(lineValues[i]) || CSV_NULL.equals(lineValues[i])",How do we know whether values would contain strings parsable to int?,Maybe print a stacktrace here as well?,"Why Brrr? May be stick to existing logic and change to ""violation""?"
"public static String doGetFeatureUrl(String srs, JSONObject download, boolean addNameSpace) throws JSONException { String getFeatureUrl = """"; StringWriter s = new StringWriter(); s.append(PropertyUtil.get(""download.basket.wfs.service.url"")); if (addNameSpace) { s.append(""?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName="" + srs + ""&outputFormat=SHAPE-ZIP&typeNames="" + download.getString(PARAM_LAYER)); } else { s.append(""?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName="" + srs + ""&outputFormat=SHAPE-ZIP&typeNames="" + Helpers.getLayerNameWithoutNameSpace(download.getString(PARAM_LAYER))); } getFeatureUrl = s.toString(); return getFeatureUrl; }","StringBuilder instead of StringWriter would be more traditional choice, not that big of a deal though.","As above, since the two fields are independant, the checks for title and abstract should probably be seperate",you're never closing this,What's the point of sorting keys here?,Does the JSONObject type need to be fully qualified here?,The generics type signature here don't match LHS and RHS.,"Extract configuration.get(""applicationType"") into a variable.","LOG.debug(""Built url: {}"", url); so that .format() doesn't get evaluated if not in debug mode","I believe so, yes, the filtering should be uniform. When originally implemented workspace specific groups did not exist, and when they were added, this bit was forgotten about.",suggestion layer.setType(OskariLayer.TYPE_WFS);,"Use I18N, this description is seen on the SQL panel function list."
"public void init() throws DBException { _db.init(); this.reportLatencyForEachError = Boolean.parseBoolean(getProperties(). getProperty(""reportlatencyforeacherror"", ""false"")); String latencyTrackedErrors = getProperties().getProperty( ""latencytrackederrors"", null); if (latencyTrackedErrors != null) { this.latencyTrackedErrors = new HashSet<String>(Arrays.asList( latencyTrackedErrors.split("",""))); } System.out.println(""DBWrapper: report latency for each error is "" + this.reportLatencyForEachError + "" and specific error codes to track"" + "" for latency are: "" + this.latencyTrackedErrors.toString()); }",this should be on System.err,inline to its declaration.,"How about instead the following? - warn about deprecation if you do deprecation warnings - if argument is spaces only, set indentSize to the length - if argument contains anything else, throw exception (probably most users have couple of spaces or tabs, latter will maybe be added by my pending PR if you accept it, everything else is probably OK if it is not supported anymore) Would make exisiting code simply continue to work like before besides a deprecation warning.",May make sense to restore these in an after class method.,if (onlyverbose && !verbosemode),"The output should be as before. That means you should print what the sysout was printing: String.format( ""%s %s %s"", GdbPlugin.getDebugTime(), TIMEOUT_TRACE_IDENTIFIER, message )",throw on negative,Add brackets around loop body (required by code conventions).,This is a pretty good idea; it would let us look through eventlogging and see in which tables this ID pops up.,"This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use ""if (debug)"" because this is hardcoded and will never be enabled. Do not use ""setLogLevel()"" because you're overriding the system administrator's configuration.",Is hyphens200 the correct variable name? Or should it be hyphens50?
"public ProductInfo createProduct(ProductInfo pinfo) { if (pinfo == null) { throw new IllegalArgumentException(""pinfo is null""); } if (StringUtils.isBlank(pinfo.getId())) { throw new IllegalArgumentException(""product is lacking an identifier: "" + pinfo); } if (this.productMap.containsKey(pinfo.getId())) { throw new IllegalStateException(""product already exists: "" + pinfo.getId()); } ProductData pdata = new ProductData(); pdata.setId(pinfo.getId()); pdata.setProductContent(this.resolveProductContent(pinfo.getProductContent())); pdata.setName(pinfo.getName()); pdata.setMultiplier(pinfo.getMultiplier()); pdata.setAttributes(pinfo.getAttributes()); pdata.setDependentProductIds(pinfo.getDependentProductIds()); pdata.setCreated(new Date()); pdata.setUpdated(new Date()); pdata.setBranding(this.resolveBranding(pinfo.getBranding())); pdata.setProvidedProducts(this.resolveProvidedProducts(pinfo.getProvidedProducts())); this.productMap.put(pdata.getId(), pdata); this.productSubscriptionMap.put(pdata.getId(), new HashSet<>()); this.updateProductContentMappings(pdata); return pdata; }","I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.",StringUtils.isBlank?,doppel space after equal sign.,This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.,"This block has shown up in another PR, which is a sign that we have dependent work, and is something we should strive to avoid in most cases. Additionally, database operations are slow, and lookups should be avoided in loops if at all possible. Change this to a bulk lookup.","I'm a bit confused by this. Why are we calling the populate method recursively here, which will overwrite all the data on the marketing ProductData (this) we're populating already? If it is in order to turn the Product into a ProductData, new ProductData(Product product) is what we should be using instead.","This should be a WARN, not an ERROR. Also, drop the ALL CAPS text.","Idem, warning or error?",Use null instead of Collections.emptySet() here,StringUtils.isBlank?,"minor nit: the exception message need not specify provided products here, as that's not an individual class of product, and the product's usage can be derived from the method generating the exception."
"public PcapPacket(PcapFile file, @Nullable Packet parent, boolean isPcapNg, ByteBuffer header, @Nullable ByteBuffer payload, long index) throws BadPacketException { super(file, parent, PcapProtocol.PCAP); if (header.array().length < PcapFileValues.PACKET_HEADER_SIZE) { fChildPacket = null; throw new BadPacketException(""The Pcap packet header is too small.""); } fSourceEndpoint = null; fDestinationEndpoint = null; fFields = null; fPacketIndex = index; header.order(getPcapFile().getByteOrder()); header.position(0); if (isPcapNg) { header.getInt(); header.getInt(); header.getInt(); } long timestampMostSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); long timestampLeastSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); switch (getTimestampScale()) { case MICROSECOND: if (timestampLeastSignificant > TIMESTAMP_MICROSECOND_MAX) { fChildPacket = null; throw new BadPacketException(""The timestamp is erroneous.""); } fTimestamp = TIMESTAMP_MICROSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; case NANOSECOND: if (timestampLeastSignificant > TIMESTAMP_NANOSECOND_MAX) { fChildPacket = null; throw new BadPacketException(""The timestamp is erroneous.""); } fTimestamp = TIMESTAMP_NANOSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; default: throw new IllegalArgumentException(""The timestamp precision is not valid!""); } fIncludedLength = ConversionHelper.unsignedIntToLong(header.getInt()); fOriginalLength = ConversionHelper.unsignedIntToLong(header.getInt()); final ByteBuffer pcapPacket = payload; if (pcapPacket == null) { fChildPacket = null; fPayload = null; return; } pcapPacket.order(ByteOrder.BIG_ENDIAN); pcapPacket.position(0); fPayload = pcapPacket; fChildPacket = findChildPacket(); }",read the values and validate,I am pretty sure this has no effect ;),"There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).",nit; make this final by final long multiplier = pcapGlobalHeader.timestampsInNs() ? 1000000000 : 1000000,"If the if_tsresol is smaller than microseconds, you would lose precision! We should use nanoseconds as this is the smallest resolution that the framework supports.",tab to space,"fEndTime maybe? It's ""start"" as the noun, the start of the trace, not the verb. So the opposite of start is end in this case.",This method does not belong in PcapNgFile because there is no global timestamp precision per file.,"If this method gets called with a block that is smaller than the packet header size (28), we could get an exception. We should probably be parsing blocks instead of packets.","This is a local variable, should be camelCase not fCamelCase","This is impossible, blockLength is an int."
"public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); System.out.println(headers.get(name)); return headers.get(name); }",Need to remove this leftover debug output,this.collector = collector,You may want to test this with multi-line strings.,"first of all array.size() == DEFAULT_MAX_ROWS seems duff logic, surely if size > DEFAULT_MAX_ROWS is the logix expected based on the output below. surely better to have this as if maxRows >= array.size() this way even if someone sets it to some other value, thats still smaller than array.size then you want to ouytput that the output has been limited.",generics,"We should close the FileOutputStream, relying on finalizers is very finicky",s/usage/Usage/,inline to its declaration.,We don't really use final on variables anywhere as the Java compiler will automatically infer it now.,Use Dsl,Nit: increase indent here ?
"public Boolean call() throws Exception { long sleepBackoff = 200L, maxSleep = 0L; do { final PoolEntry poolEntry = createPoolEntry(); if (poolEntry != null) { connectionBag.add(poolEntry); return Boolean.TRUE; } else if (poolEntry == MAXED_POOL_MARKER) { return Boolean.FALSE; } else if (maxSleep == sleepBackoff) { return Boolean.FALSE; } maxSleep = sleepBackoff; quietlySleep(sleepBackoff); sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3)); } while (true); }",How can this work? This is going to insert MAXED_POOL_MARKER into the bag.,I prefer to keep the static import.,Why do we have min() within max()?,"> It's a 32 bit signed integer, so any value of retries exceeding 31 will cause the value to overflow. Yeah you're right on-I was raising a question around the implementation of the back-off in general. (EDIT to add quote)",Why don't you call the sleep method on line 45 instead of replicating this code?,"It's already calling Math.min(long, long).",Why 5? With the minimum connectionTimeout of 1000ms this will generate a constant load of 5 connection attempts per second (200ms apart). / 2 gives a much more reasonable retry value.,Should we really ignore an InterruptedException? let's talk it over with @akhanzode,braces,should be Repeater.RAND,"I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one."
"private void createFeatures(ArcGISMap map){ LayerList layers = map.getOperationalLayers(); for(Layer layer: layers){ FeatureLayer fLayer = (FeatureLayer) layer; if(fLayer.getName().contains(""Alaska National Parks"")){ mOperationalLayers.add(fLayer); } } List<ArcGISFeatureTable> tables = map.getTables(); final ArcGISFeatureTable speciesFeatureTable = tables.get(0); speciesFeatureTable.addDoneLoadingListener(new Runnable() { @Override public void run() { Log.d(TAG, ""Found table: "" + speciesFeatureTable.getTableName()); } }); speciesFeatureTable.loadAsync(); }",No need to explicitly load tables with query if you are using the latest build,let's write to the log too as per <LINK_0>,"Much simpler: java private Stream<Feature> featuresFromNames(String feature, String... additionalFeatures) { return toStream(feature, additionalFeatures) .map(this::foobar); } private Feature foobar(String f) { try { return featuresService.getFeature(f); } catch (Exception e) { throw new SynchronizedInstallerException( ""Failed to retrieve feature ["" + f + ""]"", e); } }","Use I18N, this description is seen on the SQL panel function list.",The if (property == WORKSPACE) segment above is probably invalid now if you are no longer displaying workspace?,remove unnecessary unboxing as you don't have to call Boolean constructor:  java if (mapViewResult.get()) {,Does it help to identify the layerId in this exception?,"I wonder should we put this try/catch inside the while loop, so we can try to read other resources?",You can use a Lambda here,"Not sure if this can happen, but perhaps you only want to load everything on the switch of the property to true.","The chest can only hold either casts or patterns, no need for a loop, the first item is enough."
"public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) { if (clazz == null || json == null) { return; } for (int i = 0; i < json.length(); i++) { try { configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false); } catch (JSONException e) { throw new RealmException(""Could not map Json"", e); } } }","""Json"" -> ""JSON"" (do a search-n-replace)",instead just write  final String json;,final and no assignment?,change to java this.myArrayList.ensureCapacity(this.myArrayList.size() + length);,I would keep this one separately as we shouldn't need more details on this if the JSON parsing fails.,I would include the next token as additional hint,is it possible for value to be null here?,@ekondrashev let's inline this variable,if you extract try/catch as method then you won't need result variable declaration without assigment,"Do we support this for JSONObject? If not, we should not support it for JSONArray either.",![MAJOR](<LINK_1> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_0>
"protected ClusterState execute(ClusterState currentState, AlterTableRequest request) throws Exception { Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.tableIdent().indexNameOrAlias()); if (request.isPartitioned()) { if (request.partitionIndexName() != null) { concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.partitionIndexName()); currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } else { currentState = updateTemplate(currentState, request); if (!request.excludePartitions()) { List<String> supportedSettings = TableParameters.PARTITIONED_TABLE_PARAMETER_INFO_FOR_TEMPLATE_UPDATE .supportedSettings() .values() .stream() .map(Setting::getKey) .collect(Collectors.toList()); supportedSettings.add(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS); TableParameter parameterWithFilteredSettings = new TableParameter(request.settings(), supportedSettings); currentState = updateSettings(currentState, parameterWithFilteredSettings.settings(), concreteIndices); currentState = updateMapping(currentState, request, concreteIndices); } } } else { currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } return currentState; }",Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here),Should we remove this setting on clone/split/shrink as well?,"These two lines look dangerous to me because we mutate an object which was set earlier. Consider the following code:  IndexConfig config = new IndexConfig(); BitmapIndexOptions options = config1.getBitmapIndexOptions(); // ... config.setBitmapIndexOptions(<new options>); // ""options"" object changed unexpectedly  I would rather overwrite an object in the setter and perform a lazy initialization in getter as we do in other config classes (e.g. IndexConfig.getAttributes() copies this approach).",use HttpClient.removeUserInfo,"WDYT about apply that look like that:  private void apply( Iterable<IndexEntryUpdate<LabelSchemaDescriptor>> updates, IndexUpdateMode updateMode ) throws IOException, IndexEntryConflictException { Map<LabelSchemaDescriptor, IndexUpdater> indexUpdaters = new HashMap<>(); for ( IndexEntryUpdate<LabelSchemaDescriptor> indexUpdate : updates ) { IndexUpdater indexUpdater = indexUpdaters.computeIfAbsent( indexUpdate.indexKey(), getMappingFunction( updateMode ) ); indexUpdater.process( indexUpdate ); } IOUtils.closeAll( indexUpdaters.values() ); } private Function<LabelSchemaDescriptor,IndexUpdater> getMappingFunction( IndexUpdateMode updateMode ) { return labelSchemaDescriptor -> { try { return indexMapRef.getIndexProxy( labelSchemaDescriptor ).newUpdater( updateMode ); } catch ( IndexNotFoundKernelException infe ) { throw new RuntimeException( infe ); } }; }  that saves a bit of cycles on iteration over updates",why is an empty settings as fallback needed here?,The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);,"@Blackbaud-EricSlater - why do we need an instance here ? Since this is a stateless service, creating instance here is redundant in my opinion, thoughts ? It will unnecessary create multiple instances of IndexPolicyCompareService, where in case of static method, all it needs is just the Class instance, which does not pose a risk of memory leak.","This catch block should never be reached in this case, so it's not so bad. What might be worse than the slowness is that if this happens it would be a symptom of something gone quite horribly wrong, so perhaps we shouldn't just silently ignore it like this...","I think breaking here is incorrect, in case of ""order by a, b"" and an index that only sorts by property a. Also, what if ""order by a desc"", and the index sorts ascending?",Can this be made protected?
"public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject fDiffProject : fDiffProjects) { IProject tempProject = Utilities.getProject(fDiffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }",not a field,Specific exceptions should be caught here.,s. Baseclass Kommentar,Isn't the path absolute already?,"There is not just C++ and Java, it's an extension point. Replace with generic message, i.e. could not create project for <language> ...",I would like to see all new code using lambdas where possible.,can you make the name more explicit? array doesn't indicate anything.,"in this case, return null as before. Then you can either use the same preference to have a 3rd value (like ""project"") else if (""project"".equsls(InstanceScope.INSTANCE.getNode(JavaCore.PLUGIN_ID).getString(PREF_NULL_SCHEDULING_RULE, null)) { return getProject(); } return super.getRule(kind, args); or introduce a new preference which can more explicitly take 3 possible values.","If you decide to keep the former preference name (for backward compatbility with early adopters), you may also want to keep checking the possible former value. if (""null"".equals(pref) || Boolean.parse(pref)) { return null; }",final,Reuse the same PermissionNameRenderer instance as the normalName.
"public static void fillReleasesTable(XWPFTable table, Collection<LicenseInfoParsingResult> projectLicenseInfoResults) { for (LicenseInfoParsingResult result : projectLicenseInfoResults) { String releaseName = nullToEmptyString(result.getName()); String version = nullToEmptyString(result.getVersion()); if (result.getStatus()== LicenseInfoRequestStatus.SUCCESS) { Set<String> copyrights = Collections.emptySet(); Set<LicenseNameWithText> licenseNamesWithTexts = Collections.emptySet(); Set<String> acknowledgements = Collections.emptySet(); if (result.isSetLicenseInfo()) { LicenseInfo licenseInfo = result.getLicenseInfo(); if (licenseInfo.isSetCopyrights()) { copyrights = licenseInfo.getCopyrights(); } if (licenseInfo.isSetLicenseNamesWithTexts()) { licenseNamesWithTexts = licenseInfo.getLicenseNamesWithTexts(); acknowledgements = licenseNamesWithTexts.stream() .map(LicenseNameWithText::getAcknowledgements) .filter(Objects::nonNull).collect(Collectors.toSet()); } } addReleaseTableRow(table, releaseName, version, licenseNamesWithTexts, acknowledgements, copyrights); } else { String filename = Optional.ofNullable(result.getLicenseInfo()) .map(LicenseInfo::getFilenames) .map(l -> l.stream().findFirst().orElse(null)) .orElse(""""); addReleaseTableErrorRow(table, releaseName, version, nullToEmptyString(result.getMessage()), filename); } } }",the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).,"I think a static import of Strings.nullToEmpty() is warranted to make this condition human-readable. Extracting the comparison into a method licenseNameWithTextEquals(license, excludedLicense) would also help readability, IMO.",I'd extract this into isLicenseNameWithTextEmpty(). Could then also be used in filterEmptyLicenses(),"I would expect the generator to fail if the parsing failed, instead of producing a valid looking result and expect the user to verify the content. I do not think that this will always happen and the red text might not even be on the titile page. In my opinion one should not even start generating if there were failures with the parsing.",I thougt we had a function to print that string,"This doesn't look like it fixes the issue. Moreover it looks like it will not fallback to UNKNOWN in case the issueType is not known... Also, this needs a test.",{} instead of string concat,why breaking backward compatibility? I'm -1 on breaking backward compatibility,I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...,remove this,Why not take all instead of only the first one?
"public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { throw new IllegalArgumentException( ""startTimeNanos should be greater than 0!"" ); } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = ""SlowQuery: "" + queryExecutionMillis + "" milliseconds. SQL: '"" + sql + ""'""; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }","I would suggest providing more clue about the exception like  throw new IllegalArgumentException( ""startTimeNanos ["" + startTimeNanos + ""] should be greater than 0!"" );  to help debugger a little bit.",wouldn't all start times be invalid then?,if (onlyverbose && !verbosemode),Maybe call the data indecipherable instead of weird?,"We should close the FileOutputStream, relying on finalizers is very finicky",This seems like duplicate code from a similar block I saw above. Should it be refactored?,pfft dropped the prefix for this but not the one above?,"we need the sleep even if there are more lots being generated. otherwise, this will consume lot of cpu.",How big is the overhead to do this check on every log?,"The output should be as before. That means you should print what the sysout was printing: String.format( ""%s %s %s"", GdbPlugin.getDebugTime(), TIMEOUT_TRACE_IDENTIFIER, message )","""... must have positive number of seconds..."""
"public void bucketLoaded(AbstractBucket<Object> bucket) { try { super.bucketLoaded(bucket); logger.debug(""Bucket {} loaded"", bucket.bucketKey); eventBucketExchanger.exchange(bucket.bucketKey, 1, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { logger.debug(""Timeout happened""); } catch (InterruptedException e) { e.printStackTrace(); } }",why swallowing?,IMPORTANT res = pipe.waitForCompletion(timeoutMillis) && res otherwise after the first fails to complete the boolean expression will short-circuit and the other waits won't get executed..,Can be replaced with lambda,This is a breaking change.,"This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.",Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,"I missed that PR, but isn't Notifier a lot like CompletedFuture?",Can be replaced with lambda,This is going to be wrong as it assumes it'll take a millisecond per pass.,No response under 100 ms results in timeout?,This should probably be removed
public ControllerFactory() { },Why public?,"I don't know much about how the serialization code works, but is this supposed to be a 1, instead of a unique serial? I'm guessing it doesn't matter because these factories will not be serialized.",Use tabs instead of spaces.,already passed in,"please make this private or protected,","Having short class name may be confusing. There can be cases of large applications that have the same name of things, but in different bounded contexts. E.g. consider ""Order"" for in two parts of a larger app that deal with different kinds of orders. Please pass FQN.","We are using the default ConfigurationCreator here, shouldn't we use our specialized one?",Why does it resolve controller home? is it better to name it with HomeDir? It's because this class not only called from controller but agent.,"suggestion this.converter = Objects.requireNonNull(converter, ""The converter cannot be null"");",personal style on my part - have only one constructor do super() - so have this one do this(true or false).,"Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter."
"public void inputReady(NHttpServerConnection conn, ContentDecoder decoder) { try { ProtocolState protocolState = SourceContext.getState(conn); if (protocolState != ProtocolState.REQUEST_HEAD && protocolState != ProtocolState.REQUEST_BODY) { handleInvalidState(conn, ""Request message body data received""); return; } log.info(""point 1""); SourceContext.updateState(conn, ProtocolState.REQUEST_BODY); SourceRequest request = SourceContext.getRequest(conn); int readBytes = request.read(conn, decoder); if (isMessageSizeValidationEnabled) { HttpContext httpContext = conn.getContext(); if (httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM) == null) { httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, 0); } int messageSizeSum = (int) httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM); messageSizeSum += readBytes; if (messageSizeSum > validMaxMessageSize) { log.warn(""Payload exceeds valid payload size range, hence discontinuing chunk stream at "" + messageSizeSum + "" bytes to prevent OOM.""); dropSourceConnection(conn); conn.getContext().setAttribute(PassThroughConstants.SOURCE_CONNECTION_DROPPED, true); request.getPipe().forceProducerComplete(decoder); } httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, messageSizeSum); } if (readBytes > 0) { metrics.incrementBytesReceived(readBytes); } } catch (IOException e) { logIOException(conn, e); informReaderError(conn); SourceContext.updateState(conn, ProtocolState.CLOSED); sourceConfiguration.getSourceConnections().shutDownConnection(conn, true); } }",remove this log,"nested switches make me queezy, would it be better to extract a function for each state?",Can you make these static constants (i.e. 0x1 and 0x2),we should use getAndSet(null) here to release the reference as well.,I wonder what this buys us... Is it ever be possible to recover ?,@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho,merge into one single boolean op,"Move this logic to a separate private function, such as ""isLastHTTPContent"". This same logic has been used in multiple places, and a single common place is useful to make sure it's consistent everywhere.",Use a logger instead of printStackTrace.,"TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?",StandardCharsets.UTF_8
"private ColumnChunk readStruct(GroupField field) throws IOException { List<TypeSignatureParameter> fields = field.getType().getTypeSignature().getParameters(); Block[] blocks = new Block[fields.size()]; ColumnChunk columnChunk = null; List<Optional<Field>> parameters = field.getChildren(); for (int i = 0; i < fields.size(); i++) { Optional<Field> parameter = parameters.get(i); if (parameter.isPresent()) { columnChunk = readColumnChunk(parameter.get()); blocks[i] = columnChunk.getBlock(); } } for (int i = 0; i < fields.size(); i++) { if (blocks[i] == null) { blocks[i] = RunLengthEncodedBlock.create(field.getType(), null, columnChunk.getBlock().getPositionCount()); } } BooleanList structIsNull = ParquetStructColumnReader.calculateStructOffsets(field, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); Block rowBlock = RowBlock.fromFieldBlocks(structIsNull.toBooleanArray(), blocks, structIsNull.toBooleanArray().length); return new ColumnChunk(rowBlock, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); }",is double call to structIsNull.toBooleanArray() intentional?,"IIRC there was some issue with case sensitivity when we added this feature to the Parquet reader. I think the issue was that Presto lower cases the field names in the type, so we may have to lower case when building the structFields map in the constructor. cc @nezihyigitbasi @zhenxiao for context on Parquet",Same question about optional above applies to here and to L159 below.,what does this change solve? how abut the cases where valueIsNull() == false (the else part)?,ditto regarding a final else block here.,Hmm.. why this needs to be in the inner loop. Can you just do: structColumnVector.noNulls = (i == 0) ? vectors[i].noNulls : structColumnVector.noNulls && vectors[i].noNulls;?,ditto regarding a final else here.,"field.getChildren().get(0) is an Optional and we just call get, is a value guaranteed to be present in this optional? On L176 we do a isPresent check, but not here (and below around L156)",Since typeParameters is only used in this branch move the declaration down to here.,ditto: return Optional.,else is redundant
"private void regenerateCertificatesImpl(Iterable<Entitlement> entitlements) { if (entitlements != null) { Set<String> deadCertIds = new HashSet<>(); for (Entitlement entitlement : entitlements) { Set<EntitlementCertificate> existing = entitlement.getCertificates(); try { entitlement.setCertificates(null); EntitlementCertificate generated = this.generateEntitlementCertificate( entitlement.getPool(), entitlement); entitlement.setDirty(false); this.eventSink.queueEvent(this.eventFactory.entitlementChanged(entitlement)); log.debug(""Generated entitlementCertificate: #{}"", generated.getId()); if (existing != null) { for (EntitlementCertificate cert : existing) { if (cert != null) { deadCertIds.add(cert.getId()); this.entitlementCertificateCurator.evict(cert); } } } } catch (CertificateSizeException cse) { entitlement.setCertificates(existing); log.warn(""The certificate cannot be regenerated at this time: {}"", cse.getMessage()); } } this.entitlementCurator.saveOrUpdateAll(entitlements, false, false); int count = this.entitlementCertificateCurator.deleteByIds(deadCertIds); log.debug(""{} old entitlement certificates deleted""); } }","suggestion log.debug(""{} old entitlement certificates deleted"", count);",Should this be public?,NACK. this undoes #1272,"We don't need to pass lazy through here, since we already know it's false at this point.","Just a thought... should this be returned as a ""error"" or should it in fact just return an empty list. If there aren't any events for a Certificate it isn't the user of this endpoint's fault...","Rather than nesting basically the entire method in a negated condition, why not  if (existingPools == null || existingPools.isEmpty()) { return; } // Actual logic here","By the way, if you see an opportunity to replace the com.google.common.eventbus handler by JavaFX observable listeners, please go ahead and migrate them!","Talked about this at stand-up today, and given the desire to get this out to PROD on Monday the decision was made to hold off on emailing stuff until that 2014 ticket","nit: unrelated in general it's better to make dedicated patches for cleanups, it's clearer when digging through the git history",Small formatting issue here. Can fit on line above.,"nextLong could return a negative, right?"
public boolean delete(final Identifier queryId) { if(queryStateMap.containsKey(queryId)) { queryStateMap.remove(queryId); return true; } else { return false; } },replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;,"@tumijacob It's not a biggie, but this method return can remain as the original primitive boolean. We do prefer primitives - it's only a concern when the original value is not a primitive and can be null.",emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet(),should return a boolean,"These begin events should probably follow argument validation, not precede - if an exception is thrown on the line below, your observer will be left in the begin state.","Same here not thread safe, use read write locks",Use meaningful names,any reason for making this sync only? We could return a Future<Storable> from here.,"Seems like you found a bug - you should not call both super.remove and super.getAndRemove. Could you fix that? Also, I think that stopTx should be called in finally block.",why synchronized?,These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
"public boolean onOptionsItemSelected(MenuItem item) { Intent intent = null; switch (item.getItemId()) { case R.id.menu_load: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, ""No connection found, please connect your device and try again"", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, ""Already fetching forms, ignored the request"", Toast.LENGTH_SHORT).show(); return true; } if (hasFormsWithData()) { Toast.makeText(this, ""There is existing form data for selected form(s). Finish Incomplete data and sync Complete data to Server first before downloading selected forms"", Toast.LENGTH_SHORT).show(); return true; } syncAllFormsInBackgroundService(); return true; case R.id.menu_upload: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, ""No connection found, please connect your device and try again"", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, ""Already uploading forms, ignored the request"", Toast.LENGTH_SHORT).show(); return true; } uploadAllFormsInBackgroundService(); return true; case R.id.menu_client_add: intent = new Intent(this, RegistrationFormsActivity.class); startActivity(intent); return true; case R.id.menu_tags: if (mainLayout.isDrawerOpen(GravityCompat.END)) { mainLayout.closeDrawer(GravityCompat.END); } else { mainLayout.openDrawer(GravityCompat.END); } return true; default: return super.onOptionsItemSelected(item); } }",Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?,You have multiple formatting and naming convention issues here.,"User-visible strings like that need to be in string resources, so they can be translated.","Thanks for explaining. However, I'm still having a hard time manually reproducing the flow. As I understand it now this pattern is a combination of the builder and chain pattern?","Fragment#getString(int resId, Object[] args) would be preferred here. You'll need to modify the strings to be multi-arg friendly. <string name=""diseaseMessage2"">%1$s has killed %2$s!</string>","There maybe no need for this variable here. And this may be more readable since it's a builder: java new AlertDialog.Builder(fragment.getContext()) .setTitle(R.string.unsynced_notes) .setMessage(R.string.unsynced_notes_message) .setPositiveButton(R.string.delete_notes, fragment.signOutClickListener) .setNeutralButton(R.string.visit_web_app, fragment.loadWebAppClickListener) .setNegativeButton(R.string.cancel, null) .show();  or java AlertDialog.Builder builder = new AlertDialog.Builder(fragment.getContext()) .setTitle(R.string.unsynced_notes) .setMessage(R.string.unsynced_notes_message) .setPositiveButton(R.string.delete_notes, fragment.signOutClickListener) .setNeutralButton(R.string.visit_web_app, fragment.loadWebAppClickListener) .setNegativeButton(R.string.cancel, null); builder.show();","Instead of checking for an intent extra here, you should be checking for an action: String action = intent.getAction();","Hmm, can isSocialLogin be false while in onSocialChanged(). I'm under the impression that this callback is only called when we are in the Social login mode, right?",Is it possible to have a null Intent here?,Like with dismissing you can use DialogUtils.showIfNotShowing. Sorry I should have pointed those out before leading you down the ProgressDialogFragment path!,"Ah I see, you were just pulling out the code for doing this that was previously in FormAndDataSyncer. So in that original implementation, the mistake there was actually that there is no reason to pass a numeric parameter in the case that you are using sync.success.sent.singular key. So you should just remove the parameter in that case, and change that key back to what it was before"
"public void handle(XFormParser p, Element e, Object parent) { String event = e.getAttributeValue(null, ""event""); FormDef form = (FormDef) parent; PollSensorAction action; String ref = e.getAttributeValue(null, ""ref""); if (ref != null) { IDataReference dataRef = new XPathReference(ref); if (dataRef != null) { dataRef = XFormParser.getAbsRef(dataRef, TreeReference.rootRef()); } TreeReference treeRef = FormInstance.unpackReference(dataRef); p.registerActionTarget(treeRef); action = new PollSensorAction(treeRef); } else { action = new PollSensorAction(); } form.registerEventListener(event, action); }",Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.,Looks from the conditional block above like ref can be null - should we be handling that here?,"""pollsensor"" -> PollSensorAction.ELEMENT_NAME",mark as @Nullable,Something weird has gone on in the history! I thought the idea of passing in the index was so that leading ignored Args could be skipped!,there is the util method again,there is no need for casting here,Only the REPO case does have help available. This now leaves us with non-functional help buttons in the REF and TAG cases.,"Oh, do we need one? If we have an empty fixture, I don't think we need to add a record to our DB. I think an empty <fixture/> tag should either delete an existing fixture or be ignored entirely. We can't really make a meaningful ""Base"" element like this","I've never seen us use this syntax in tests before; does it result in the same sort of test failure and error message as Assert.assertEquals(expected, actual)?",No need for this 'else' block - the clear() method was already called above.
"public void setQuotaMode(QuotaMode mode) { logger.info(""Setting Quota mode to "" + mode.name()); this.mode = mode; }","nit: try to avoid string concatenation in the log.  logger.info(""Setting Quota mode to {}"", mode.name());",warn seems too relaxing for this kind of exception. maybe error?,Why Object. Why not String?,@waymirec -- Can we look at splitting this into 2 methods -- for maxSpace & spaceUsed -- and perhaps using non-String return types?,Is it necessary to return the parameter?,"Are these supposed to be null if not set? If not, requireNonNull",Remove the call to this();,"Just define SEP as final string "","" instead of a character...","Consider using a more informative message in the log, something like ""The value \"""" + value + ""\"" isn't a valid quota mode."". Also, try to use the slf4j {} mechanism: log.error(""The value \""{}\"" isn't a valid quota mode."", value); log.error(""Exception"", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.",Should make a differentiation of the name and id.,Send this exception to the log.
"private static boolean isPreJava8() { final String version = System.getProperty(""java.version""); final String[] parts = version.split(""\\.""); try { int major = Integer.parseInt(parts[1]); final int token = Integer.parseInt(parts[0]); boolean isJEP223 = token != 1; if (isJEP223) { major = token; } return major < 8; } catch (final Exception ex) { return true; } }","Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.","Instead of returning null, could we throw an exception? We have to handle the case of finding an unknown Java version as well. Right now there will be an NPE when trying to do the comparison.","i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended",@m-g-sonar why compatible and not guaranteed?,Could we declare the matchers and patterns in the order they're used?,"Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged(""java.specification.version"", null); if (version != null) { Matcher matcher = Pattern.compile(""^(?:1\\.)?(\\d+)$"").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }","no, this can stay true. We don't support old stuff any more",Space after if?,"We don't need reflection here, I think. The Runtime is part of Java from its beginning. Runtime.class should do the job.","I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:",Gson doesn't run on these versions so I don't see any reason to include them.
"public PagingProvider<ReconnectableConnection, ReconnectableConnection> pagedOperation(Integer failOn) { return new PagingProvider<ReconnectableConnection, ReconnectableConnection>() { Integer counter = 0; @Override public List<ReconnectableConnection> getPage(ReconnectableConnection connection) { counter++; if (counter == failOn) { throw new ModuleException(MuleErrors.CONNECTIVITY, new ConnectionException(""Failed to retrieve Page"")); } return Collections.singletonList(connection); } @Override public Optional<Integer> getTotalResults(ReconnectableConnection connection) { return Optional.empty(); } @Override public void close(ReconnectableConnection connection) { } }; }",static import,"Should we check if the connectionId actually belongs to this <host, port> pair? There could be possibly error cases that connections to <host1, port1> are checked into <host2, port2>.",Is it necessary to have nested try-catch scopes? Can we make it simpler?,If no nulls accepted make the parameter int.,Remove this,"Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.",The value of shouldThrottleNumConnections should now be set based on this internal conn config and the max num conns from a client right?,Can't we use connection = super.createConnection() instead? That's way we do not have to pass null parameters?,implement equals and hashcode,I'm unsure about this and lower close() calls. So far as I know: database connection close() calls should not be needed in a connection pool managed environment as pool management handling connection to database.,"it isn't clear to me that the caller expects/handles a -1, please confirm"
"public boolean writeMutexCell(String tenantId, String schemaName, String tableName, String columnName, String familyName) throws SQLException { try { byte[] rowKey = columnName != null ? SchemaUtil.getColumnKey(tenantId, schemaName, tableName, columnName, familyName) : SchemaUtil.getTableKey(tenantId, schemaName, tableName); byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); try (Table sysMutexTable = getTable(sysMutexPhysicalTableNameBytes)) { byte[] family = PhoenixDatabaseMetaData.SYSTEM_MUTEX_FAMILY_NAME_BYTES; byte[] qualifier = PhoenixDatabaseMetaData.SYSTEM_MUTEX_COLUMN_NAME_BYTES; byte[] value = MUTEX_LOCKED; Put put = new Put(rowKey); put.addColumn(family, qualifier, value); boolean checkAndPut = sysMutexTable.checkAndPut(rowKey, family, qualifier, null, put); String processName = ManagementFactory.getRuntimeMXBean().getName(); String msg = "" tenantId : "" + tenantId + "" schemaName : "" + schemaName + "" tableName : "" + tableName + "" columnName : "" + columnName + "" familyName : "" + familyName; if (!checkAndPut) { LOGGER.error(processName + "" failed to acquire mutex for ""+ msg); } else { LOGGER.debug(processName + "" acquired mutex for ""+ msg); } return checkAndPut; } } catch (IOException e) { throw ServerUtil.parseServerException(e); } }","byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that.","Whenever getBytes is called on a String in Accumulo, UTF_8 should be passed to getBytes(). Otherwise the encoding is dependent on the system config which could possibly differ across time and nodes. Since this data is being persisted its important to always use the same encoding for strings. Value has a constructor that takes Strings and encodes with UTF8, so it would be best to use that.",would it be better to put checkMutationType() and checkRow() in doCheckAndRowMutate() method?,"use Optional#orElseThrow(), otherwise we get a non-descriptive error message when the optional is empty.",It would be great if we could have unit tests for all these new methods inside say PhoenixTTLRegionObserverTest.java,missed throwing IllegalStateException,You can just call setString directly on the table. No need to create an unchecked row for it.,Entity column name should not be empty or blank?,Ditto to this (obviously),update -> delete,"Any reason for the method rename? There might be usages of this API outside of the Phoenix jar (for example by the Platform teams), so I'd resist making this change unless it's absolutely necessary."
"public ReadableByteChannel get(PageId pageId, int pageOffset) throws IOException, PageNotFoundException { Path p = getFilePath(pageId); if (!Files.exists(p)) { throw new PageNotFoundException(p.toString()); } FileInputStream fis = new FileInputStream(p.toFile()); fis.skip(pageOffset); return fis.getChannel(); }","[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE",Should we check the result of status.isFolder and status.isCompleted here?,and for mister 24,"With all these exceptions, try extracting all of the exception construction to a separate method. For instance in this case you could extract a newSeekEofException( pos, newPageId, newOffset ). That would reduce the amount of bytecode in the method, and give the JIT inliner more material to work with.",How about passing an already positioned and limited input stream? (doing inputStream.seek(readStart); and ByteStreams#limit outside)? If you do that then most likely you won't even need this class.,The purpose of this line is not immediately clear to me. Care to elaborate?,We call it schema evolution. Let's change it to schema evolution is not supported for page file format,"Will this be a problem given we always force to use FSDataInputStream openFile(Path path, HiveFileContext hiveFileContext) to open files?","put(uri, stream) on a concurrentHashMap avoids the ""synchronized""",Wouldn't a ThreadPoolExecutor be more performant here instead of starting a new thread every time we page?,"suggestion Preconditions.notBlank(path, () -> ""File ["" + path + ""] must not be null or blank"");"
"String extractMetadataFromSlots(List<oasis.names.tc.ebxml_regrep.xsd.rim._3.SlotType1> documentSlots, String slotName, int valueIndex) { LOG.debug(""extractMetadataFromSlots slotname: {}; index: {}"", slotName, valueIndex); String slotValue = null; for (SlotType1 slot : documentSlots) { if (slotName.equals(slot.getName())) { LOG.debug(""Found {}: {}"", slotName, slot.getValueList().getValue()); if (valueIndex < 0) { slotValue = StringUtils.join(slot.getValueList().getValue(), VALUE_LIST_SEPERATOR); } else if (slot.getValueList() != null && slot.getValueList().getValue() != null && !slot.getValueList().getValue().isEmpty()) { slotValue = slot.getValueList().getValue().get(valueIndex); } else { slotValue = """"; } break; } } LOG.debug(""{}: {}"", slotName, slotValue); return slotValue; }",This statement slot.getValueList().getValue()) could cause an NPE,what if valuelist is empty? should you check for that?,"This line should be merged with the enhanced for, instead of a separate declaration. Also, can identifiableType.getSlot() ever be null? If so, append a check in the if statement above.","The problem is that the slots are sorted after newlines are prepended to some of the slots. The correct fix is to add the newlines after the slots have been sorted. (In the next for loop.) But the first slot still should not be prepended with a new line. Also, the serializeConstraints method has the same problem. Could you correct it as well?",I would vote for not using Array and introduce what's needed in CollectionHelper as we did for HV.,"Making these non-static to allow overriding seems fine to me. And move them up to be grouped with the other protected non-static methods. Note that after the suggestions I made on the corresponding issue, these methods will return @Role and @Accessibility integers respectively.",:ant: I'd use StringUtils.equals for clarity.,"missing space after ,","trimmedVal.startsWith(""${"") is imho redundant, it is already covered by trimmedVal.lastIndexOf(""${"") == 0.","I suspect the for loop above can be changed to be a for each loop over mixins, we don't need the i anymore, I think.",this.
"public PartitionStatistics getTableStatistics(String databaseName, String tableName) { try { Table table = getTable(databaseName, tableName).orElseThrow( () -> new PrestoException(HIVE_METASTORE_ERROR, String.format(""Could not retrieve table %s.%s"", databaseName, tableName))); HiveBasicStatistics basicStats = getHiveBasicStatistics(table.getParameters()); List<Column> columns = table.getPartitionColumns(); List<String> columnNames = columns.stream().map(Column::getName).collect(toImmutableList()); List<ColumnStatisticsInfo> colStatsList = client.getTableColumnStatistics(table.getDatabaseName(), table.getTableName(), columnNames); return new PartitionStatistics(basicStats, groupStatisticsByColumn(colStatsList, basicStats.getRowCount())); } catch (Exception e) { throw new PrestoException(HIVE_METASTORE_ERROR, e); } }",columnStatistics,"Why not return Optional.of(ImmutableMap.of()), like we do in FileHiveMetastore? It's expected that statistics might not be available for tables.",nit: put with the previous line,static import joining,"java Map<String, HiveColumnStatistics> columnStatistics = partitionColumnStatistics.getOrDefault(partitionName, ImmutableMap.of());",no need to move it above?,"Put each argument to toImmutableMap on separate lines, as they're a bit long and are important.",static import toList,statisticsObj -> statisticsInfo,"return columns.stream() .map(HiveColumnHandle::getName) .collect(Collectors.joining("",""));","This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error."
"private void lazyLoadModulesConfig() throws IOException, ConfigInvalidException { if (modulesConfig == null) { loadModulesConfig(); } }",curly braces aren't required,The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.,"this method can be static right ? , so you can do ConfigurationLoaderImpl.load(); , the name of the class can be better.",we should skip this if the config file doesn't exist otherwise this throws a NoSuchFIleException,Should this use FMLPaths.CONFIGDIR instead as the game directory may not be the same as the working directory?,"We prefer to cache the modification time before we read the file. That way if the file is modified while we are scanning it, our cached time should be older than the final edit time, and we'll scan it again the next time we are asked about the file. Caching the time after the read opens a race condition where we finish reading the old version, and someone else changes the file before we can get the modification time from it. In this case we would skip that update entirely and never notice it has occurred.",@NielsCharlier consider refactoring this to use Java 7 try-with-resources.,"this is just a setter, why we need to update it?","You should create new map. It will contains old configs, for example if it will contains key_1 and when you add new configs and remowe old(key_1) in the UI then this map will still contains key_1 config.",In this case it would be better to define modules variable after JsonArray modulesFromJson after this you will be able to create modules list instance with defined size new ArrayList<>(modulesFromJson.size);,Why is that necessary? Would it not be enough to simply catch the exception one level above this class? I am just asking because all the isInjector... getInjectorException... etc makes a lot of noise in different classes.
"public void run() { try { if (!makeResourceWritable(provider.getShell())) { return; } } catch (CoreException e) { MessageDialog.openWarning(provider.getShell(), ""Resource Not Accessible"", e.getMessage()); return; } if (LaunchUtils.hasLaunchedTestCases()) { MessageDialog.openWarning(provider.getShell(), Messages.RenameAction_ErrorDialogTitle, Messages.RenameAction_ErrorDialogMsg); return; } if (!RefactoringSaveHelper.checkDirtyEditors(provider.getShell())) { return; } if (containsSingleTag(getStructuredSelection())) { RenameTagWizard wizard = new RenameTagWizard(getSelectedTag()); run(wizard, provider.getShell()); } else { List<?> resources = getSelectedResources(); if (resources.size() == 1) { IResource resource = (IResource) resources.get(0); Q7RenameResourceWizard wizard = new Q7RenameResourceWizard( resource); run(wizard, provider.getShell()); } } }",Why do we handle error like this?,Why is this check now necessary if it wasn't previously?,perhaps it is better to check selection.isEmpty() first before continuing to other checks and also eliminating the need for null checks.,I think you'll have to lift this restriction. Note that the handler definition in plugin.xml also is restricted to single-element selections.,Could we test that collapsing works as well?,Could be suggestion return !selectedBaseResources.isEmpty();,"It would be safer if you used parentShell.bot(), although this will search in the active shell and you just gave it focus...",Use modern for loop.,isn't better to throw an IllegalStateException to notify that the test may leaked some resource?,rename 'resource',This also seems kinda pointless and a bit brittle. Just return resource.
"private void setValue(Type type, BlockBuilder blockBuilder, String value) { if (value == null) { blockBuilder.appendNull(); return; } if (!(type instanceof FixedWidthType) && !(type instanceof VarcharType)) { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), ""type '"" + type + ""' not supported""); } if (type instanceof FixedWidthType) { completedBytes += ((FixedWidthType) type).getFixedSize(); if (type instanceof BigintType) { type.writeLong(blockBuilder, parseDouble(value).longValue()); } else if (type instanceof IntegerType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else if (type instanceof TinyintType) { blockBuilder.writeByte(parseDouble(value).byteValue()); } else if (type instanceof SmallintType) { blockBuilder.writeShort(parseDouble(value).shortValue()); } else if (type instanceof BooleanType) { type.writeBoolean(blockBuilder, parseBoolean(value)); } else if (type instanceof DecimalType || type instanceof DoubleType) { type.writeDouble(blockBuilder, parseDouble(value)); } else if (type instanceof TimestampType) { type.writeLong(blockBuilder, parseLong(value)); } else if (type instanceof DateType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), ""type '"" + type + ""' not supported""); } } else { Slice slice = Slices.utf8Slice(value); blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry(); completedBytes += slice.length(); } }",Why parseDouble and then convert that to int instead of directly parsing to int ?,Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.,ditto regarding a final else here.,ditto regarding a final else block here.,what does this change solve? how abut the cases where valueIsNull() == false (the else part)?,We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); },"I think this is correct for the String case, but how do we know that the DataByteArray case will not be a reused object? You could always change bytes to a Binary and wrap the byte array inside the if blocks.",Unhandled,"the error handling here needs to either: - When atomicity == SKIP_ALL, throw CairoException. There is no need to rollback row, it hasn't been created - do the logging but exit method via return.",We need to keep the throw exception as we are not changing the existing behavior,not needed; same for other readers
"private void initialize() { this.setName(Constant.messages.getString(""proxies.options.title"")); this.add(getScrollPane()); this.setLayout(new GridBagLayout()); this.add(getMainProxyPanel(), LayoutHelper.getGBC(0, 0, 1, 0.0)); this.add(getSecurityProtocolsPanel(), LayoutHelper.getGBC(0, 1, 1, 0.0)); this.add(getScrollPane(), LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0)); }",This can be removed? (Being added later.),TableLayout,This could be removed (not needed for this UI component).,What if we are not running a dev version?,Although it requires some more changes I'd suggest adding to the whole panel instead of just the table (as it would be always scrollable no matter the size of the dialogue).,Can this be null? If not lets require it to be non-null here.,"Should be this.font(), and the same on the next line",What if the value is false? e.g. calling setNoScroll(true) and then setNoScroll(false) ?,this.protocols = new ArrayList<>(new ProtocolConfig(protocol)); seems better to me,This should be consistent with the default implementation in ContentDescriptor. Either null (if we think it's better to make explicit the content type is unknown) for both or String.class (if we feel String.class to be more consistent with parameters types logic) for both.,This font resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the label.
"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } ImageTransfer other = (ImageTransfer) obj; return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && type == other.type && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal); }","please move it to line 168, just to make it look cleaner :)",I think this does not work. You need to check equals on each element of the array. You can use Arrays#deepEquals(...),"same here, i bet noone needs all of them to be equal. don't make test code/reqeuirements leak into the main",do we really need all of them here? looks like messageId is unique..,please add brackets to all of these ifs,This is wrong. We still need to use the folder name for equality checks.,"suggestion return Objects.equals(messageId, other.toString());",you can use ==,"suggestion return Objects.equals(address, other.toString());","is it expected that we are ignoring requestExpiry, statusCode and timestamp when comparing? Same for other classes.",We decided to use Objects.isNull
"private static void printNetworkParameters(NetworkParams networkParams) { oshi.add(""Network parameters:"" + networkParams.toString()); }","To match the old format, do ""Network parameters:\n "" here.","We still need to start with the ""Network Interfaces:"" header here.","Please use braces, even for single line statements.","should be just ""display""",would be nice if the indent was configurable,What's the point of sorting keys here?,You can change + into append here.,populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>,"properties.get(obj).toString() would be safer in theory, because Properties can hold not only Strings","Change to ""Choose artifact types to exclude""",Why is it necessary / what's the benefit of adding code to also support a Long parallel width? Integer is certainly large enough.
"public static OzoneAcl convertOzoneAcl(OzoneAclInfo aclInfo) { ACLIdentityType aclType; switch(aclInfo.getType()) { case USER: aclType = ACLIdentityType.USER; break; case GROUP: aclType = ACLIdentityType.GROUP; break; case WORLD: aclType = ACLIdentityType.WORLD; break; default: throw new IllegalArgumentException(""ACL type is not recognized""); } List<IAccessAuthorizer.ACLType> aclRights = new ArrayList<>(); for(OzoneAclRights acl:aclInfo.getRightsList()) { try { aclRights.add(ACLType.valueOf(acl.name())); } catch(IllegalArgumentException iae) { LOG.error(""ACL:{} right is not recognized."", acl); } } return new OzoneAcl(aclType, aclInfo.getName(), aclRights); }",Do we missing some enums here?,This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?,why do we need to recreate a new UGI instead of using ugi.getGroups() here?,this can be simplified as this.aclBitSet= acls.clone();,You could use i++ instead of ++i here... What if the local ACL is the last one and so i++ is out of bound?,Can we move context.getClientUgi().getUserName() out of the for loop?,nit: space between if and (,QueryBuilder has a RR resource leak - it'd better to write this as:  query.getResult().getPaths().steam().forEach(path -> { Resource resource = resourceResolver.getResource(path); ... },is validationContext.getServerSecurityConfig() something that needs to be pulled out of the loop?,control flag,"I see above catch block for ClassNotFoundException doesn't also throw anything like this catch block, but isn't it bad practice?"
"public void shouldSubstituteHexValuesInReplacementString() { String replacement = ""abc\\x01\\xaadef""; ReplacerParamRule nonAsciiRegexRule = new ReplacerParamRule( """", REQ_HEADER_STR, ""anyMatchString"", true, replacement, null, true); assertThat( nonAsciiRegexRule.getEscapedReplacement(), equalTo(new String(new byte[] {'a', 'b', 'c', 1, (byte) 170, 'd', 'e', 'f'}))); }",These could be renamed to not use nonAscii.,"Let's raise this up to a public constant public static final MQL_RESERVED_CHARS = "" .,:(){}[]\""'*/+-"";",I suggest to use the expectedException rule everywhere inside this suite to also test for a user-friendly error message.,"all your test method has this resultString var = ""ABC"", better to have as a global variable?",why make this method final?,"suggestion for (char i = SPACE; i <= TILDE; i++) {  Can you do that? Can remove need for casting below, and can make SPACE and TILDE chars.","this will replace CRLF to 2 blanks, is this intended ?",can be private? or at least package protected access?,"why can't we do new String[]{""Aa"", ""Bb"" etc... instead of creating the string and then splitting it?","Please put @Test on the line above, not on the same line.",there is already some escape method/utility/lib so take a look if this can be reused here
"protected Object transform( Message in, String mimeType, String transformerId, MimeTypeToTransformerMapper mapper) throws MimeTypeParseException, CatalogTransformerException { MimeType derivedMimeType = null; try (InputStream message = in.getBody(InputStream.class); TemporaryFileBackedOutputStream tfbos = new TemporaryFileBackedOutputStream()) { if (message == null) { throw new CatalogTransformerException( ""Message body was null; unable to generate Metacard!""); } IOUtils.copy(message, tfbos); String fileExtensionHeader = getHeaderAsStringAndRemove(in, FILE_EXTENSION_HEADER); if (StringUtils.isNotEmpty(fileExtensionHeader)) { Optional<String> fileMimeType = getMimeTypeFor(tfbos.asByteSource().openBufferedStream(), fileExtensionHeader); if (fileMimeType.isPresent()) { LOGGER.trace( ""Setting mimetype to [{}] from Message header [{}]"", fileMimeType.get(), FILE_EXTENSION_HEADER); derivedMimeType = new MimeType(fileMimeType.get()); } } if (derivedMimeType == null) { if (StringUtils.isNotEmpty(mimeType)) { if (StringUtils.isNotEmpty(transformerId)) { derivedMimeType = new MimeType( mimeType + "";"" + MimeTypeToTransformerMapper.ID_KEY + ""="" + transformerId); LOGGER.trace(""Using mimeType to [{}]"", derivedMimeType); } else { LOGGER.trace(""Using CatalogEndpoint's configured mimeType [{}]"", mimeType); derivedMimeType = new MimeType(mimeType); } } else { LOGGER.debug(""Unable to determine mimeType. Defaulting to [{}]"", DEFAULT_MIME_TYPE); derivedMimeType = new MimeType(DEFAULT_MIME_TYPE); } } String metacardUpdateID = getHeaderAsStringAndRemove(in, METACARD_ID_HEADER); return generateMetacard(derivedMimeType, mapper, tfbos, metacardUpdateID) .orElseThrow( () -> new CatalogTransformerException( String.format( ""Did not find an InputTransformer for MIME Type [%s] and %s [%s]"", mimeType, MimeTypeToTransformerMapper.ID_KEY, transformerId))); } catch (IOException e) { LOGGER.debug(""Failed to get mimeType by reading input stream"", e); } throw new CatalogTransformerException(""Unable to transform incoming product""); }",The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again.,"We could declare message in the try-with-resources, then move the null check inside and delete the finally block.","This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.",Any reason we use the mime type in the header before the transformerId? Just curious because before the transformerId took precedence over the mimeType argument.,"If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting",I would move this inside a finally block in the same method,"Could be:  // failed to detect mimetype on extension: // fallback to the blob defined mimetype String mimeTypeName = blob.getMimeType(); if (isMimetypeEntry(mimeTypeName)) { return mimeTypeName; } // failed to detect mimetype on blob: // fallback to calculate mimetype from blob content return getMimetypeFromBlobWithDefault(blob, defaultMimetype);  with  protected boolean isMimetypeEntry(String name) { return mimetypeByNormalisedRegistry.containsKey(name); }",Should this be trace?,It may be a good idea to log this at a lesser level. I think I remember being told that not being able to close a stream isn't that big of a deal. Can anyone confirm this?,"If we return nothing, that has to be explicit on the type. The way we handle this in a clean way is using java Optional. You can then: - Modify the mimeType of this method to return Optional<String> - When returning something, return Optional.of(something) - When we encouter the error, we can then return Optional.empty() - Finally in **match** methods, we can handle the if resoluion in a functional manner using *filter* and *orElse* (that might replace the if block)","This is OK but given this is a public method don't you think it would be safer to throw an illegal argument exception if we don't have a file? After all, the MIME type of null is not null."
"public Map<String, Discrepancy> getDiscrepanciesList() { Map<String, Discrepancy> toReturn = new HashMap<String, Discrepancy>(); String discrepanciesJson = artifact.getSoleAttributeAsString(DispoConstants.DispoDiscrepanciesJson, ""{}""); try { JsonNode node = JsonUtil.getMapper().readTree(discrepanciesJson); Iterator<JsonNode> elements = node.getElements(); while (elements.hasNext()) { Discrepancy discrepancy = JsonUtil.getMapper().readValue(elements.next().toString(), Discrepancy.class); toReturn.put(discrepancy.getId(), discrepancy); } } catch (Exception ex) { throw new OseeCoreException(""Could not parse Discrepancies Json"", ex); } return toReturn; }",Suggest JSON related capabilities be isolated to the JsonUtil class.,"if you combine these calls into 1 line, the JVM JIT will be able to perform [return value optimization](<LINK_0>",use final keyword,"Could be more stream-ish with:  return issues.stream() .flatMap(issue -> issue.getFlatten().keySet().stream()) .collect(Collectors.toSet()); // or better readability with static import, then: .collect(toSet())  That would return a Set in interface and HashSet implementation, not SortedSet. But look like the we don't rely on the order of the result anyway?",What's the effect here? You store the value but then don't use it going forward.,Is it necessary to call this again?,update throw text? looks like copied from above,Maybe use a somewhat more descriptive variable name rather than 'x' :),name definedAttr,Do we want to return null or throw an exception here?,It would be **really** helpful to provide what type is actually expected. It looks like valueNode.getType().getPointer() can provide this info
"public void setup() throws IOException, InterruptedException { m_eventdIpcMgr.setEventWriter(m_database); OnmsMonitoringLocation location = new OnmsMonitoringLocation(); location.setLocationName(""Default""); m_locationDao.save(location); final OnmsNode node = new OnmsNode(location, ""node1""); node.setId(NODE_ID_ONE); m_nodeDao.save(node); Hashtable<String, Object> producerConfig = new Hashtable<String, Object>(); producerConfig.put(""group.id"", ""OpenNMS""); producerConfig.put(""bootstrap.servers"", kafkaServer.getKafkaConnectString()); ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class, RETURNS_DEEP_STUBS); when(configAdmin.getConfiguration(KAFKA_PRODUCER_CLIENT_PID).getProperties()).thenReturn(producerConfig); ExecutorService executor = Executors.newSingleThreadExecutor(); kafkaConsumer = new KafkaMessageConsumerRunner(kafkaServer.getKafkaConnectString()); executor.execute(kafkaConsumer); kafkaProducer = new OpennmsKafkaProducer(protobufMapper, nodeCache, configAdmin, m_eventdIpcMgr, alarmLifecycleListenerManager); kafkaProducer.setEventTopic(""events""); kafkaProducer.setEventFilter(""getUei().equals(\""uei.opennms.org/internal/discovery/newSuspect\"")""); kafkaProducer.setNodeTopic(""nodes""); kafkaProducer.init(); Thread.sleep(2000); }","What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?",Not needed?,"I'm curious why we need to initialize client here. Usually we need to do this in Cassandra instance itself, but not on the test class. Do we need it for JMX to work?","This test should use a non-default pipeline, like the integration tests in Core and the Mongo implementation.",HeapSizeManager heapSizeManager,Why do we need this?,Why not have an ExecutorPool rather than a specific list of Threads...,Change is unrelated to the PR (and in two places below in this class).,We can do this with GenericTestUtils.waitFor() right?,"what about assertEquals(""consumer record size is not zero"", 0, records.count());? It can also be applied in a few other places",Why do we need to set MAX_BLOCK_MS_CONFIG?
"public long updateHash( HashFunction hashFunction, long hash ) { class CodePointCursor { byte[] values; int i; @SuppressWarnings( ""WeakerAccess"" ) int codePointCount; @SuppressWarnings( ""WeakerAccess"" ) long next() { codePointCount++; byte b = values[i]; if ( b >= 0 ) { i++; return b; } int bytesNeeded = 0; while ( b < 0 ) { bytesNeeded++; b = (byte) (b << 1); } int codePoint = codePoint( values, b, i, bytesNeeded ); i += bytesNeeded; return codePoint; } } CodePointCursor cpc = new CodePointCursor(); cpc.values = bytes; cpc.i = offset; int len = offset + byteLength; while ( cpc.i < len ) { long codePointA = cpc.next() << 32; long codePointB = 0L; if ( cpc.i < len ) { codePointB = cpc.next(); } hash = hashFunction.update( hash, codePointA + codePointB ); } return hashFunction.update( hash, cpc.codePointCount ); }","The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?",Use parameterized logging instead of string concatenation.,0xD800 <= codePoint is unnecessary,What if values.length is longer than COEFFICIENTS.length?,Immediately return the value here,put all of this in a try {...} finally { buf.release(); } block,"No, this is not what you want. replace return getInt(length, signed); with long tmp = getInt(length, false); // false or true, no effect. if (!signed) tmp &= 0xFFFFFFFFL; return tmp;","redundant by spec: ""char: The char data type is a single 16-bit Unicode character. It has a minimum value of '\u0000' (or 0) and a maximum value of '\uffff' (or 65,535 inclusive)."" <LINK_0>","This function uses getByte for 1st and 2nd byte, and getByteUnchecked for 3rd byte and onwards. This inconsistency appears to be a bug. - If getByteUnchecked is used on 1st byte, this function should be named ""unchecked"". - Otherwise, this function need to do a bound check before reading 2nd-nth byte using getByteUnchecked. If such bound check is not done, this function need to be named ""unchecked"".","Performance-nit: Same nit as above, pull raw[ptr] into a local variable so its not evaluated twice.","Should we catch that exception here ? or pass it along ? I am sure there is a very thin chance this will happen. But in any case. Also, can we just do a default data.getBytes() if UTF-8 fails on UnsupportedEncodingException ?"
"public void triggerCompleted() { getProcessInstance().removeEventListener(getEventType(), getEventListener(), true); ((org.jbpm.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).setCurrentLevel(getLevel()); ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()).removeNodeInstance(this); NodeInstanceContainer container = ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()); NodeInstance instance = container.getNodeInstance(getNode()); triggerNodeInstance((org.jbpm.workflow.instance.NodeInstance) instance, NodeImpl.CONNECTION_DEFAULT_TYPE); }",what's the reason for this extra variable container?,"maybe an alternative approach would be to mark such nodes (entry node in foreach) as not async - like setting metadata on a node which would instruct to ignore asyncnode so it won't be wrapped. That would allow us to include that logic into the useAsync method, wdyt?","I think CancelNodeInstanceAction is used in multiple cases, boundary escalation and boundary error events, not sure I grasp the meaning of TIMED cancel type in this context?","Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow",Shouldn't it be true ? (legacy SQL used for old jobs),We will do updatePresentation(nodePresentation) twice when nodePresentation == null and update is true. Is it OK?,This if condition could be placed SubProcessPropertyWriter overriding this method. Since this is specific to subprocesses. Makes sense?,"if the exclude based on metadata will work, then I think all this code change won't be needed",shell should be disposed in teardown,The Exception is never thrown.,Why not logging it instead?
"void mapActionItemsToSelection(ISelection selection) { setMoveItemsEnabled(false); if (selection == null || selection.isEmpty()) return; if (selection instanceof IStructuredSelection) { IStructuredSelection structured = (IStructuredSelection) selection; Object obj = structured.getFirstElement(); if (!(obj instanceof PlanElement)) return; PlanElement firstSelectedEntry = (PlanElement) obj; PlanElement lastSelectedEntry = firstSelectedEntry; ElementAction type = firstSelectedEntry.getPlanElementAction(); unselectAllActionItemsExecpt(getItemFor(type)); if (structured.size() > 1) { for (Iterator iterator = structured.iterator(); iterator .hasNext();) { Object selectedObj = iterator.next(); if (!(selectedObj instanceof PlanElement)) continue; PlanElement entry = lastSelectedEntry = (PlanElement) selectedObj; if (type != entry.getPlanElementAction()) { unselectAllActionItemsExecpt(null); } } } enableMoveButtons(firstSelectedEntry, lastSelectedEntry); } }",We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.,"While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {","Are we sure that selection is not null? Otherwise, a null check before we call getFirstElement() is in order.",How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?,List<T> selected = null; will be enough here,perhaps it is better to check selection.isEmpty() first before continuing to other checks and also eliminating the need for null checks.,"Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is ""the EditPartViewer or null"") before calling deselectAll()","The last 4 lines of this method should be extracted as new method, because they are a duplication (see 10 lines above).","Check for null is not required here, because (element instance of IResource) returns false for null element.",I think you should use notifyItemRemoved(i) here.,This is not what I would expect. I would expect a comparison between index and HEAD.
"public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(""P60000000000000D""); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); assertThat(e.getMessage(), is(""Error during type conversion from type: java.time.Duration to the required type: "" + ""long with value PT1440000000000000H due java.lang.ArithmeticException: long overflow"")); } }","I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.",Can we remove the FQN?,eh ? What's this ?,"You may be able to simplify this test case through JUnit4 annotations, with the @Expected","""should throw an exception"" or Expected exception",should we swap method parametrr orders above?,Should be Assert.equals or Assert.<Object>equals so that the values actually get printed out in the failure mesasges,s/duration/size/,"Since inJapan is not a LocalDateTime, AbstractLocalDateTimeAssert.isEqualTo(LocalDateTime other) is not called but AbstractAssert.isEqualTo(Object other) is which makes the assertion to fail. But I think the assertion should pass as we want isEqualTo assertion to be consistent with LocalDateTime.isEqual, this is possible if AbstractLocalDateTimeAssert.isEqualTo overrides AbstractAssert.isEqualTo (that is taking an Object parameter). So at the end the test assertions could be: java assertThat(now.equals(inJapan)).isFalse(); assertThat(now.isEqual(inJapan)).isTrue(); assertThat(now).isEqualTo(inJapan); Object inJapanObject = inJapan; assertThat(now).isEqualTo(inJapanObject);","We generally prefer assertThat(..., is(..)) for better error messages.",I'm wondering whether we should actually not allow negative deltas. What do you think?
"private void publishChildren(IModule[] module, ArrayList<IStatus> results, IModule[] children, File parentModule, IProgressMonitor monitor) { if( children == null ) return; monitor.beginTask(""Assembling child modules"", children.length * 100); for( int i = 0; i < children.length; i++ ) { if( ServerModelUtilities.isBinaryModule(children[i])) results.addAll(Arrays.asList(fullBinaryPublish(module, children[i], ProgressMonitorUtil.submon(monitor, 100)))); else results.addAll(Arrays.asList(fullPublish(combine(module, children[i]), parentModule, ProgressMonitorUtil.submon(monitor, 100)))); } }",check if monitor is cancelled?,Collections.unmodifiableList(children)?,initial null seems not needed. Probably can be a for () loop :) for (ISourceModule module; (module = modules.poll()) != null;) { ... },shouldn't you check is monitor is cancelled?,"((Server)server).setModuleState(temp, state) is called twice in this loop",we should log this before throwing it.,Would be an IllegalArgumentException not a proper exception instead of including a exception from java.security package?,"wouldn't {{0L}} be okay for initial / default value of map/reduceTaskStartTime here? If {{reduceTaskReport}} is empty then {{reduceTaskStartTime}} will be {{Long.MAX_VALUE}}, which seems an odd default.","For this an all code like this: ReportListenerThreadHolder returns an IAsyncReportListener, so this check can be simplified by making the listener variable to be of type IAsyncReportListener .",This may consume a lot of memory. Use blocks like in the export,"raise an exception to say ""not implemented"""
public boolean isReady() { return false; },@Irenyak1 why return false here?,no qualifier?,Are these methods part of the upgrade?,"no, this.running must there anyway. Or we can rely on the this.contextStopped variable...",Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.,inline raw() ?,"Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.","I'd say if the entry is present, the command is not successful.",why is this unsuccessful ?,How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?,"This method doesn't need to return anything. When completed, the connection should be considered 'closed'."
"private void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) { synchronized (lock) { final long id = idGenerator.getAndIncrement(); final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter); final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work); EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get(); workProcessor.onNext(syncSubscriber); Disposable thisWorkSubscriber = workSubscriber.get(); if (thisWorkSubscriber != null) { logger.info(""[{}]: Receive request is placed in queue to process."", id); return; } EmitterProcessor<ServiceBusReceivedMessageContext> source = messageSource.get(); if (source == null) { source = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS) .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false)); messageSource.set(source); logger.info(""Created source for receiving messages.""); } EmitterProcessor<ServiceBusReceivedMessageContext> finalSource = source; thisWorkSubscriber = workProcessor .subscribe(currentWork -> finalSource.subscribe(currentWork), error -> { logger.error(""Error in processing messages [{}]"", error); }, () -> { logger.info(""Receiving messages completed.""); }); workSubscriber.set(thisWorkSubscriber); } }",These should be done through a sink.,final for both the variables?,"This seems to be an unexpected case... in fact, an error. We should at least raise the log level to WARNING, or maybe even throw an exception.","Not sure we want to do WARN logs, as Camels error handler et all ought to deal with this. If the Camel error handler did not handle that exception then the consumer has its own error handler that we tend to use which does a fallback and log a WARN: <LINK_0>","You don't need any logic to be in here. In the onNext() override, is where you would call emitter.next. And wherever the flux is attached to the Emitter could be the messageReceivedEmitter. MessageReceivedEmitter shouldn't have to exist.","I'm not sure what the consequence is of rolling back the session here and then attempting to commit it again in the finally block below. You may want to verify that this is OK, or move the commit back up to the 'success' case.","Can you please edit the message slightly so it would be more explaining? It is obvious, that when assert fails, something is not correct/expected...","Would you please tell me what exactly the difference between this test and pullNetworkExceptionAndResend test? In my compilation, they seem very similar to each other..",Can we obtain isAsync() as local variable only once in the begging of method? Kinda to avoid a race condition when it could be changed in between at runtime...,Assert.notNull(),Feels like something is missed here else...
"private static String truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName(String legalLastName, String legalFirstName) { int maxAllowedLengthOfFirstName = VendorConstants.MAX_VENDOR_NAME_LENGTH - VendorConstants.NAME_DELIM.length() - legalLastName.length(); if (legalFirstName.length() <= maxAllowedLengthOfFirstName) { return legalFirstName; } else { String truncatedLegalFirstName = legalFirstName.substring(0, maxAllowedLengthOfFirstName); LOG.info(""truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName: Received legalFirstName '"" + legalFirstName + ""' with length of "" + legalFirstName.length() + "" and it is being truncated to '"" + truncatedLegalFirstName + ""' with length of "" + truncatedLegalFirstName.length()); return truncatedLegalFirstName; } }","If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood.",Why not make this a constructor parameter?,There should not be a need to set this to public. Perhaps private would be better.,"This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace ""maxLength + 1"" with just ""maxLength"".","You should cover also the case, when passed value is null, since Candidate params titleBefore/titleAfter can be null or empty.","It should take ... into account in the max-length, so the string with ... should be max maxDetailLength long",It would a bit better if a private method is placed under that one who invokes it,missing this,"I would suggest instead:  java return """" + level;  Defaulting to WARN is too misleading.",str == null cannot be true here as this was already checked upfront by <LINK_0> (it also correctly results in null there). We could also move this empty string or 0 length up under that check as it would be same for both functions.,Could you use StringUtils.truncate instead?
"public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) { GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId)); GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity(); snapshot.setClusterId(volume.getClusterId()); snapshot.setVolumeId(new Guid(volumeId)); DateFormat df = new SimpleDateFormat(""yyyyMMddHHmmss""); String snapshotName = snapshotNamePrefix + ""-snap-"" + df.format(new Date()); snapshot.setSnapshotName(snapshotName); snapshot.setDescription(description); VDSReturnValue returnValue = getBackend().getResourceManager() .RunVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new GlusterVolumeCreateSnapshotVDSParameters(new Guid(serverId), volume.getName(), snapshotName, description, force)); if (returnValue.getSucceeded()) { snapshot.setSnapshotId((Guid) returnValue.getReturnValue()); snapshot.setCreatedAt(new Date()); snapshot.setStatus(GlusterSnapshotStatus.STARTED); getGlusterVolumeSnapshotDao().save(snapshot); } else { log.error(""Error while creating snapshot for volume '{}': {}"", volume.getName(), returnValue.getVdsError() .getMessage()); log.debug(returnValue.getVdsError().getMessage()); } }","How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed",check if volume is null and log and return.,What about this else case. Here also scheduling fails but we are not showing any error?.,Why not just do snapshot.setId() with return value (which should return the Guid) and save it,"looks like volume will be null here, no? only set below",you are passing 'true' to 'exitStatus' in case of FAILED as well.,Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?,Can we have: getParameters().<Guid>getParameter(UserRolesVdsParameters.RoleId) or even: getParameters().getParameter(UserRolesVdsParameters.RoleId) if the function gets object?,getGlusterVolume() from super class can be used,"Since Dates are mutable, startDate and endDate should be copied into the response to avoid downstream side-effects.",Please add null check for volume.getAsyncTask()
"public boolean removeFileEntry(String index, TransientStore ts) { BatchFileEntry fileEntry = getFileEntry(index, false); if (fileEntry != null) { if (fileEntry.isChunked()) { for (String chunkEntryKey : fileEntry.getChunkEntryKeys()) { List<Blob> chunkBlobs = ts.getBlobs(chunkEntryKey); if (chunkBlobs != null) { for (Blob blob : chunkBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(""Error while deleting chunk parent directory"", e); } } } ts.remove(chunkEntryKey); } fileEntry.beforeRemove(); } String fileEntryKey = fileEntry.getKey(); List<Blob> fileBlobs = ts.getBlobs(fileEntryKey); if (fileBlobs != null) { for (Blob blob : fileBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(""Error while deleting file parent directory"", e); } } } ts.remove(fileEntryKey); return true; } else { return false; } }",I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.,List<Blob> blobs = Collections.singletonList(new AsyncBlob(key)),Used to be fileSystem.deleteFileOrThrow underneath.,"The try-with-resources takes care of the closing, right?","I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?",Used to be fileSystem.deleteFileOrThrow underneath.,"Shouldn't this be deleted _after_ all the blobs in the directory are deleted, after the recursive call?",any reason to throw InterruptedException?,do any of these objects also need closing?,"same thing, while you are cleaning, other thread could store other key.",why resume hard delete before completing the compaction ?
