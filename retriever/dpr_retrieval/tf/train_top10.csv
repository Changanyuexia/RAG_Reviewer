code,review,top_1,top_2,top_3,top_4,top_5,top_6,top_7,top_8,top_9,top_10
"public void testMissingPrimaryKeyLookupQuery() throws Exception { indexType2TweeterDocuments(); final Table table = dataContext.getDefaultSchema().getTableByName(DEFAULT_TABLE_NAME); final Column[] pks = table.getPrimaryKeys().toArray(new Column[0]); try (DataSet ds = dataContext.query().from(table).selectAll().where(pks[0]).eq(""missing"").execute()) { assertFalse(ds.next()); } }","Please use a better name (primaryKeys, primaryKeyColumns).","Please use a better name (primaryKeys, primaryKeyColumns).","Please use a better name (primaryKeys, primaryKeyColumns).",Let's add another one check with different type of columns with the same name,"We could try a recovery here, and verify that the index starts to accepts writes after that recovery. Also, in ReadOnlyIndex, we could throw an exception in getInitializationTask, and provide a mock implementation getRecoveryTaskSupport that enables writes. Note that forcing an exception during initialization would make us to miss the call to markIndexBuilt, so the index won't be added to SIM#queryableIndexes and it won't accepts reads independently of its ReadOnlyIndex#supportsLoad implementation. That's why I think we need some new logic in SIM#markIndexFailed too.",What about dumping the missing indices into a file ? The purpose should be creating an upgrade script - that would ease the process for the developer.,"I'd rather use a better name for ""ds"", everywhere (dataSet).","assertThat(imd != null ? imd.getName() : null, is(equalTo(expected.getName())));",Use DDL for IT case.,Would it make sense to reduce this to the columns that are relevant?,"Name it ""schema""? There is no other literal schema for this test case."
"public void loadJavaRDD() throws Exception { doReturn(javaPairRDD).when(sparkContext).newAPIHadoopFile(any(), any(), any(), any(), any()); doReturn(javaRDD).when(javaPairRDD).map(any()); JavaRDD<Country> retJavaRDD = SparkAvroLoader.loadJavaRDD(sparkContext, ""/avro/datastore"", Country.class); assertTrue(javaRDD == retJavaRDD); verify(sparkContext).newAPIHadoopFile( eq(""/avro/datastore""), eq(AvroKeyInputFormat.class), eq(Country.class), eq(NullWritable.class), configurationCaptor.capture()); assertEquals(Country.SCHEMA$.toString(), configurationCaptor.getValue().get(""avro.schema.input.key"")); verify(javaPairRDD).map(mapFunctionCaptor.capture()); assertMapFunction(mapFunctionCaptor.getValue()); verifyNoMoreInteractions(sparkContext, javaPairRDD); verifyZeroInteractions(javaRDD); }",Wouln't it be better to use the expected type instead of any()?,"Same goes, shall we assert the state too?",Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));,tolerance?,This looks like testDataFormat(COMPONENT); Please see other tests for sample,I don't think setLenient(boolean) is needed. Based on the docs at <LINK_0> I think and have tested that the tests will work just fine without it. How about removing it ?,"NIT: Paths.get(""src"", ""hello.rs"")",why not use stripe-mock?,"I thought the correct behavior for Datasets was to reject a null type, not to default to Object.class. This will be required, right?",You could use try-with-resources to avoid explicit close here.,Shouldn't this fail?
"protected AuditMessageType getParticipantObjectIdentificationForRequest(PRPAIN201306UV02 request, AssertionType assertion, AuditMessageType auditMsg) { auditMsg = getPatientParticipantObjectIdentificationForResponse(request, auditMsg); try { auditMsg = getQueryParamsParticipantObjectIdentificationForResponse(request, auditMsg); } catch (JAXBException ex) { if (LOG.isDebugEnabled()) { LOG.error(""Error while creating ParticipantObjectIdentificationQueryByParameters segment : "" + ex.getLocalizedMessage(), ex); } } return auditMsg; }","Remove this ""if"" statement. That said, here are a few things for future reference: 1. You use ""is[Level]Enabled"" to check that specific level (e.g., if you're going to log trace, you'd check ""isTraceEnabled()"", not ""isDebugEnabled""). 2. There is no ""isErrorEnabled"" -- unless you disable logging altogether, it's always enabled. I suppose you could use ""isEnabledFor(Level.ERROR)"", but you'd only be checking if logging is on at all. 3. As a rule of thumb, unless the logging operation is extremely heavy (e.g., transforming a large object for the trace logs), you don't want to check if ""Info"" level or lower are enabled, only higher (debug, trace).","Since we're using an enhanced for loop, does checking .size() in advance gain us anything? Edit: Just kidding, I scrolled down and saw the ""else"".","You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?",Would it be simpler to write !HttpStatus.valueOf(responseCode).isError() ?,"Instead of assign and return, just return the last statement.",Do these need to be in separate if blocks?,"So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?","You use this exact log message in the AuditLogger class, do we need a statement both places? If we do, can you make the message here (or in AuditLogger) more specific?","@Shirly: what exactly do you want in the logs: ID of the event type (for example 27) or NAME of the event type (in this case 'VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE')? I'm asking because you've told me in the past that you cannot do any joins in Elastic Search, so if you want to allow filtering by event types, users wouldn't know what code is 27, but they probably may know what VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE means ...",(don't say i'm bothering you) could you just replace this line by this.sendAuditLog(auditLogContextBuilder.build())? It's IMHO more proper. And this what the method is intended to do.,Can we check for empty string rather than do a length check here?
"private synchronized void addNode(DiscoveryDruidNode druidNode) { DiscoveryDruidNode prev = nodes.put(druidNode.getDruidNode().getHostAndPortToUse(), druidNode); if (prev == null) { for (DruidNodeDiscovery.Listener l : nodeListeners) { listenerExecutor.submit(() -> { try { l.nodeAdded(druidNode); } catch (Exception ex) { log.error(ex, ""Exception occured in DiscoveryDruidNode.nodeAdded(node=[%s]) in listener [%s]."", druidNode, l); } }); } } else { log.warn(""Node[%s] discovered but existed already [%s]."", druidNode, prev); } }",is it possible that getDruidNode() or getHostAndPortToUse() are null?,I think it might be better to add to the list first and then register the added stuff.,Formatting,this is no longer thread safe - as the node may have been removed. an update to a removed node should fail. (return false),Should we throw UnrecoverableCorfuInterruptedError here?,"It's unclear why we removed uninitializedNodeTypeListeners.remove(this) && uninitializedNodeTypeListeners.isEmpty(), was it redundant? If it was, it's unclear why.","Before that we notified on removed nodes after all types of nodes were initialized, now we just ignore?",return a boolean esp. given the semantics of the update operation if there is an existing node of the same name that is not the provided node instance,> 0?,"I would have moved this line after this.killNodeImpl(node, host); to be sure that a node is deleted and forgotten only if the runtime on the remote node has been really killed, otherwise the information at the Scheduler level may be wrong. Same apply for other infrastructures.","Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow"
"public Step variantsLoadStep() throws Exception { return stepBuilderFactory.get(LOAD_VARIANTS).<Variant, Variant>chunk(10) .reader(reader) .writer(variantMongoWriter) .faultTolerant().skipLimit(50).skip(FlatFileParseException.class) .listener(new SkippedItemListener()) .build(); }","We talked about setting a chunk size. Shall we make it 1000 and set it in JobOptions? I'm not very happy about that location but other things like includeSrc, compressGenotypes, etc, are placed there too.","can we remove this then? I think the main reason for the fault tolerance was those NO_VARIANTS, right?",VariantLoaderStepStatisticsListener would make the relationship between both classes more clear.,this line is longer than 120,"Is there any way we can do this update outside a step initialization, maybe in a @PostConstruct method?",The first argument should be expected value.,"There is no point testing this if the method is marked @NonNull. It becomes a compiler check instead of a ""unit test check"". This means we can remove this test altogether.","Actually I think it would be good to have them split, even if the class internally used is the same. Passing an aggregation mode ""NONE"" is a very implementation-specific detail, and it doesn't make much sense for a higher level layer.",assertNotEquals?,Better to call it getMigrationToVersion0_9_6 as it indicates that it will upgrade from what ever version you on to 0.9.6 version,"Replacing 1L with variantSourceEntities.size() will ensure that even if the collection size changes, the mocked data will make sense."
public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + zScore.hashCode(); return result; },Please implement equals() method either. This will remove the potential problem when working with collections.,fullName should be enough here too.,Could use Objects.hash(),|We can replace the hashcode implementation here with *Objects.hash(...)*.,Ditto for java.util.Objects.hash(Object...),"It looks like SketchHolder overrides equals but not hashCode. This is a bug, although I'm not sure if it has a visible effect in production before this patch (I can't think of anything offhand that would depend on SketchHolder's hash code being consistent with equals). But it does affect the correctness of this new class's equals/hashCode methods. So please fix SketchHolder in this patch - I think something that just delegates to the underlying Sketch's hashCode method would be enough.","I'd suggest to consider conventional hashCode implementation that is consistent with equals method - taking both entity and title into account, both of which can be null: final int prime = 31; int result = super.hashCode(); result = prime * result + ((getEntity() == null) ? 0 : getEntity().hashCode()); result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode()); return result; (If two objects are equal according to the equals method, then calling the hashCode method on each of the two objects must produce the same integer result.)",Please check all your hashCode implementations. Please either return the hash code of a single referenced object or use HashCode.compute.,Doesn't Datanucleus advise against using id in hash?,"I think I saw this code in another PR this week, should it be standardized in a utility class or something?","This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant."
"public Object execute(final ExecutionEvent event) throws ExecutionException { final TaskData data = getTaskData(event); if (data == null) return null; Job job = new Job(MessageFormat.format( Messages.RebasePullRequestHandler_RebaseJob, data.getTaskId())) { @Override protected IStatus run(IProgressMonitor monitor) { PullRequestComposite prComp = PullRequestConnector .getPullRequest(data); if (prComp == null) return Status.CANCEL_STATUS; PullRequest request = prComp.getRequest(); Repository repo = PullRequestUtils.getRepository(request); if (repo == null) return Status.CANCEL_STATUS; String branchName = PullRequestUtils.getBranchName(request); try { String target = request.getBase().getRef(); Ref targetRef = repo.findRef(request.getBase().getRef()); if (targetRef != null) { SubMonitor progress = SubMonitor.convert(monitor, 2); if (!PullRequestUtils.isCurrentBranch(branchName, repo)) { monitor.setTaskName(MessageFormat .format(Messages.RebasePullRequestHandler_TaskCheckout, branchName)); BranchOperationUI.checkout(repo, branchName).run( progress.split(1)); } else { progress.setWorkRemaining(1); } monitor.setTaskName(MessageFormat.format( Messages.RebasePullRequestHandler_TaskRebase, branchName, target)); new RebaseOperation(repo, targetRef) .execute(progress.split(1)); executeCallback(event); } } catch (IOException e) { GitHubUi.logError(e); } catch (CoreException e) { GitHubUi.logError(e); } return Status.OK_STATUS; } }; schedule(job, event); return null; }",one more progress monitor change,one more unrelated progress monitor change,Could you extract the body of this into its own method? It's not very readable here.,better: can't start rebase in repository state ...,This isn't the intended use of the API. You shouldn't use RepositoryStatus unless the error has a corresponding task repository.,how about this: new HashSet<Repository>(Arrays.asList(repos));,"As you said in the commit message this may open multiple dialogs. I tried the change with three repositories: one having uncommited changes and two that either pull cleanly or abort due to other reasons. After starting to pull, the CleanupUncomittedChangesDialog and a pull result dialog for the other two repositories popped up. The result dialog appeared in the foreground, but clicking its OK button did not close it. Only after closing the CleanupUncomittedChangesDialog (which was behind the result dialog) I could click OK on the result dialog.","This surely works. but testing _the same_ variable for multiple different cases should be done using switch-case instead of multiple if-then to make it more clear that the same variable is tested. Also since this is an enum, a switch case (without default branch) would immediately have shown the issue by a compiler error.",style nit: no braces around single line blocks,I'd use an ErrorDialog.openError and pass the status in there. This way people are not confronted with the JGit error message at first (only if they want to see the details) and they're able to copy the error message,here we should also show the exception which is the root cause of the problem -> use multistatus as this was done in RebaseHelper
"public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { try { for (Element autoMountElement : roundEnv.getElementsAnnotatedWith(SecureAutoMount.class)) { final AutoMountContext context = getAutoMountContext(autoMountElement, SecureAutoMount.class); if (context == null) { continue; } for (Element elem : roundEnv.getElementsAnnotatedWith(AuthorizeInstantiation.class)) { final AuthorizeInstantiation mp = elem.getAnnotation(AuthorizeInstantiation.class); processMountPoint(context, elem, mp); } for (Element elem : roundEnv.getElementsAnnotatedWith(MountPath.class)) { final MountPath mp = elem.getAnnotation(MountPath.class); processMountPoint(context, elem, mp); } generateSource(context); } return true; } catch (IOException ex) { Logger.getLogger(SecureMountAnnotationProcessor.class.getName()).log(Level.SEVERE, null, ex); } return true; }",return false ?,"is there any way to figure out what annotatiotion processors are in the compilation cycle? If so, it we should list them. If not: it seems that the error message needs to point more clearly to the underlying cause in a more generic way. something along the lines what you have now, but a hint that another ap (not generating classes) might be the problem.",why did you change this to return true? I think in general it is best to return false so other processors can use the annotations too,Debug?,"Only at the User specified mountpoint we should try to mount. There may be fallback mounting strategy, but this should be only done by explicit user request.",We're gonna want to validate that !providerInterfaces.isEmpty(),typo: Safe to _cast_,I'm not super familiar with this code - are all of the items called in process from the same package? Are there possibly more than one package per process call?,"Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser",I don't see why this branch on instanceof ItemNotFoundException is needed... both logs are the same.,suggestion if ((m.getLocation() == Entity.LOC_NONE) && !m.isOneShotAmmo() && (m.getCriticals() > 0)) {
"public void testFrameworkProducerDelete() throws Exception { setupFrameworkProducer(false); Exchange mockExchangeCreate = mock(Exchange.class); Exchange mockExchangeDelete = mock(Exchange.class); Message message = mock(Message.class); Metacard metacard = mock(MetacardImpl.class); when(metacard.getId()).thenReturn(""metacard1""); when(mockExchangeCreate.getIn()).thenReturn(message); when(mockExchangeCreate.getOut()).thenReturn(message); when(mockExchangeCreate.getIn().getHeader(OPERATION_HEADER_KEY)).thenReturn(CREATE_OPERATION); when(mockExchangeCreate.getIn().getHeader(TIMEOUT_HEADER_KEY)).thenReturn(1000L); when(mockExchangeCreate.getIn().getBody()).thenReturn(metacard); when(mockExchangeCreate.getIn().getBody(any())).thenReturn(metacard); frameworkProducer.process(mockExchangeCreate); when(mockExchangeDelete.getIn()).thenReturn(message); when(mockExchangeDelete.getOut()).thenReturn(message); when(mockExchangeDelete.getIn().getHeader(OPERATION_HEADER_KEY)).thenReturn(DELETE_OPERATION); when(mockExchangeDelete.getIn().getHeader(TIMEOUT_HEADER_KEY)).thenReturn(1000L); }",This test needs a verification.,This test needs a verification.,This won't do anything since metacard is a mock.,Why do we need to set MAX_BLOCK_MS_CONFIG?,Could you name this values in some final local variables?,"Is this message correct? It seems like the IDConverter is expected to at least remove/add leading slashes. I guess this might not really be conversion, though.","Source ids are supposed to be unique. CachingFederationStrategy doesn't really care, but it's not accurate to how the system is supposed to behave. I'd prefer to mock normal behavior by making these ids unique within the scope of each unit test.","isNull is rarely the right matcher. If null is being passed around it is most likely an artefact of the tests, rather than part of any contract. Generally, stubs should be as general and accepting as possible (so any(Class) rather than restricting to null values). Verifications should be as precise as necessary (so rarely use any, unlikely to us isNull).",Refactor the dispatch logic in a method in order not to duplicate code.,nit: the exception is no longer thrown.,Shoud
"protected void onCreate(Bundle savedInstanceState) { Log.d(TAG, ""onCreate""); requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); requestWindowFeature(Window.FEATURE_ACTIVITY_TRANSITIONS); super.onCreate(savedInstanceState); PreferencesState.getInstance().onCreateActivityPreferences(getResources(), getTheme()); if (EyeSeeTeaApplication.permissions == null) { EyeSeeTeaApplication.permissions = Permissions.getInstance(this); } if (!EyeSeeTeaApplication.permissions.areAllPermissionsGranted()) { EyeSeeTeaApplication.permissions.requestNextPermission(); } initView(savedInstanceState); PreferencesState.getInstance().setPushInProgress(false); List<SurveyDB> surveyDBs = SurveyDB.getAllSendingSurveys(); Log.d(TAG, ""Surveys sending: "" + surveyDBs.size()); for (SurveyDB surveyDB : surveyDBs) { surveyDB.setStatus(Constants.SURVEY_QUARANTINE); surveyDB.save(); } AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); try { Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); Thread.sleep(100); AlarmPushReceiver.setPushAlarm(this); AlarmPushReceiver.setPushAlarm(this); } catch (InterruptedException e) { e.printStackTrace(); } mBaseActivityStrategy.onCreate(); }","this code is very strange, can you explain to me because is necessary?",Please make this translatable,"You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)","Did you think of moving the ""default"" for an option into the preferenceRepository? I see some benefit in case we use the preference in different locations, and also if it is not set, the SettingsActivity will need to show something. And I currently don't see a use case for having different defaults in those cases. Yes, the SharedPreferences stuff from Android is using the same approach, but there it is different, as that class is not under our control....",This URL is also defined in Const.java file. I think this and the below one should only be defined in Const.java.,"Was this extra just for the version where the whole maps preference screen was opened from widgets, by any chance? (and can it be removed?)",Please rename the xml file to preferences_notifications (plural). I think that reads a bit better. The Java class name is fine as-is,Please respect owner naming convention ^^,Please rename this layout file as well removing _new_api.,use getResources() directly,"listView.setHasFixedSize(true);  listView -> recyclerView? Also, you can take <LINK_0> and  RecyclerView.ItemDecoration itemDecoration = new DividerItemDecoration(getActivity(), null); listView.addItemDecoration(itemDecoration);"
"public void testProcessNonJavaFilesWithoutException() throws Exception { final TreeWalker treeWalker = new TreeWalker(); treeWalker.setTabWidth(1); treeWalker.configure(new DefaultConfiguration(""default config"")); final File file = new File(""src/main/resources/checkstyle_packages.xml""); final FileText fileText = new FileText(file, StandardCharsets.ISO_8859_1.name()); try { treeWalker.processFiltered(file, fileText); } catch (CheckstyleException ex) { fail(""Exception not expected""); } }","Like I mentioned to others, try-catch-fail is not a good option. JUnit automatically populates exception to user and fails the test. If exception occurs, user will now get a bland message and not the stack trace of the problem. There is nothing we can assert here?",Use StandardCharsets.ISO_8859_1.name(),Can we replace these 2 lines with createTreeWalkerConfig?,You have to assert that parse and walk methods are not invoked. Use Mockito to verify this fact.,The name of the check is NoLineWrap. Why did you lowercase check's name?,We said before catching an exception and just failing is bad practice. Exception should be populated to junit runner to display to user.,"You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure",Please make separate input file for each test.,InputWhitespaceAfterTypecast,"deleting test resources should happen in tearDown method annotated with @After, see RepositoryTestCase",Same code as in CompletionTest. Consider pulling that out into a static util method.
"protected void executeCommand() { final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance() .getProfile(getParameters().getProfileName()); sourceIp = getParameters().getSourceIp(); if (profile == null) { setSucceeded(false); } else { final boolean externalSsoEnabled = EngineLocalConfig.getInstance().getBoolean(""ENGINE_SSO_ENABLE_EXTERNAL_SSO""); final DbUser user = buildUser(externalSsoEnabled, getParameters(), profile.getAuthzName()); boolean isAdmin = !roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), "","")).isEmpty(); user.setAdmin(isAdmin); setCurrentUser(user); setUserName(String.format(""%s@%s"", getCurrentUser().getLoginName(), getCurrentUser().getDomain())); if (getParameters().isAdminRequired() && !isAdmin) { setSucceeded(false); } else if (permissionDao.getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), "",""), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) { setSucceeded(false); } else { String engineSessionId = sessionDataContainer.generateEngineSessionId(); sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp()); sessionDataContainer.setUser(engineSessionId, user); sessionDataContainer.refresh(engineSessionId); sessionDataContainer.setProfile(engineSessionId, profile); sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName()); sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken()); sessionDataContainer.setSsoOvirtAppApiScope(engineSessionId, getParameters().getAppScope()); getReturnValue().setActionReturnValue(engineSessionId); setSucceeded(true); sessionId = engineSessionId; } } }","Maybe having such method would be nicer: buildUser(T params, String authzName) { boolean externalSsoEnabled = EngineLocalConfig.getInstance().getBoolean(""ENGINE_SSO_ENABLE_EXTERNAL_SSO""); buildUser(externalSsoEnabled , params, authzName) { }","For failures this should be empty, because engineSessionId hasn't been created","This whole method could be replaced with return !Boolean.parseBoolean(env.get(""TWILIO_DISABLE_DB_SSL""));",you can simplify with Guid.isNullOrEmpty(profile.getSshPublicKeyId()),Please move conversion from List to comma separated string to DAO. IMHO it's better to make type conversion at the last moment and only at places where it's really needed.,I think this should be some kind of constant.,I don't think this will throw an NPE as much as it would return null to the caller of getExternalSSOProvider(),why is this primaryDomainName? Can be differ,suggestion: extract method to describe its purpose. I know you didn't write this code,"Same as above, why does USER need to have the same permissions as ADMIN?",Shouldn't this be != ? :-)
private void closeConfirmationWindow() { if(getConfirmWindow() == null) { return; } else { setConfirmWindow(null); } },you could just do setConfirmWindow(null); like above method,"There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.","Will this ever be called when the window is not yet created? Seems like that might be a bug if it happens. Would be it be possible to initialise the stage on construction, just not show it? Then we don't have to check for null everywhere. And sometimes the null checks may not communicate the right intent, if something cannot possibly be null at that point.",suggestion @Override public void clear() throws Exception {,missing braces,"We don't use braces ({}) for such simple one-line statements, please remove them.",It looks like user will see the 'ask user' message.,"Might be nice to move dialog.setOnCancelListener(cancelListener) to finalizeView, then you don't need to override setOnCancelListener in CustomViewAlertDialog. Shouldn't need a null check, looking at the implementation of setOnCancelListener.","I think can just be ""isCancellable""",This can be simplified as follows if(refresh != null) { refresh.cancel(); },simplify this with one statement: submitConfirm.setClickable(!visibility);
"public void queryFile1Contributors() { final IFileHistory history = historyProvider.getFileHistoryFor(iFile1, IFileHistoryProvider.NONE, new NullProgressMonitor()); assertNotNull(history); final IFileRevision[] revisions = history.getFileRevisions(); IFileRevision branchFileRevision1 = null; IFileRevision masterFileRevision3 = null; IFileRevision masterFileRevision1 = null; for (IFileRevision revision : revisions) { final String revisionId = revision.getContentIdentifier(); if (branchCommit1.getName().equals(revisionId)) { branchFileRevision1 = revision; } else if (masterCommit3.getName().equals(revisionId)) { masterFileRevision3 = revision; } else if (masterCommit1.getName().equals(revisionId)) { masterFileRevision1 = revision; } } assertNotNull(branchFileRevision1); assertNotNull(masterFileRevision3); assertNotNull(masterFileRevision1); final IFileRevision[] branchCommit1Parents = history.getContributors(branchFileRevision1); assertEquals(1, branchCommit1Parents.length); assertRevisionMatchCommit(branchCommit1Parents[0], masterCommit1); final IFileRevision[] masterCommit3Parents = history .getContributors(masterFileRevision3); assertEquals(1, masterCommit3Parents.length); assertRevisionMatchCommit(masterCommit3Parents[0], masterCommit1); final IFileRevision[] masterCommit1Parents = history .getContributors(masterFileRevision1); assertEquals(0, masterCommit1Parents.length); }","we don't use braces around single line blocks, many more occurrences in this patch",Remove this?,Usually we write this as if(!29) { return; },This is breaking the pre 2.9 tests. We could just check that the string matches up to the \n.,We should probably check this in the client.,"Or even simpler: java Iterables.transform(branches, from -> Util.fixNull(from.getName())));","Switch arguments, expected comes first for assertEquals.",assertThat(result).hasSize(1);,assertEquals,"Instead of duplicating the lines, can we abstract it to a method and call twice?","Use a shorter version of assertion to increase readability: assertNotEquals(branchAfterImport.baseTimestamp(), branchAfterImport.headTimestamp())."
"protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); finishIfNotRoot(); if (savedInstanceState != null) { wasExternal = savedInstanceState.getBoolean(""was_external""); } ACRAUtil.registerAppData(); uiController = new HomeActivityUIController(this); uiController.setupUI(); }","this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?",If you set wasExternal here then remove it from processFromExternalLaunch,"Would you mind actually leaving this logic the way it was? I know you don't like this pattern in general, but in scenarios like this where it's really important that no code be called after this line if it returns true, it feels like it will be much easier for someone in the future to accidentally add code after this if statement that messes that up.","Reusing the site picker layout here is likely to cause problems down the road. We could easily add something to the site picker layout that wouldn't make sense here. Likewise for reusing the site picker adapter since it was intended for use with the site picker. Perhaps a better approach would be to use the site picker activity itself, and have it hide features (like search) that aren't needed here?",call super,could you log some message here to indicate the restart cmd is not supported,Please rename the xml file to preferences_notifications (plural). I think that reads a bit better. The Java class name is fine as-is,"Please add spaces between if and (, as well as between ) and {. I want to get this style consistent throughout the project. Same with all other if statements.","implement a trackEvent(event)that calls into trackEvent(event, null, null) instead","The double 'startActivity' call isn't needed, right?",Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
"public void testCheckoutExistingBranch() throws Exception { Git git = new Git(db); writeTrashFile(""a"", ""Hello world a""); git.add().addFilepattern(""."").call(); git.commit().setMessage(""commit file a"").call(); git.branchCreate().setName(""branch_1"").call(); git.rm().addFilepattern(""a"").call(); FileUtils.mkdirs(new File(db.getWorkTree(), ""a"")); writeTrashFile(""a/b"", ""Hello world b""); git.add().addFilepattern(""a"").call(); git.commit().setMessage(""commit folder a"").call(); git.rm().addFilepattern(""a"").call(); writeTrashFile(""a"", ""New Hello world a""); git.add().addFilepattern(""."").call(); assertEquals( ""error: Your local changes to the following files would be overwritten by checkout:"", execute(""git checkout branch_1"")); }",don't you want to add a/b?,I would add a check that the resulting commit has one parent. That's an important fix.,initial commit is already created in setup() method,why is it called 'symlinkA' . This test doesn't create symlinks. I took over this test into a bugfix commit which is now a predecessor of this change. There I changed this variable name to fileA,wrong order of parameters,Why do you create this file? It's not added to the initial commit.,"I suggest to remove the setName(""master"") here and in nearly all the other tests. Whenever you want to checkout HEAD then git.checkout.setStartPoint(Constants.HEAD)... is sufficient and a further setName() is redundant and not needed. Only exception are tests where you want to checkout something different than HEAD.",use try-with-resource to avoid warning,You should check for entries: - exisiting in HEAD but missing in index (files where you already executed 'git rm' but have not comitted that) - symbolic links - submodules Even if we don't support all the bells and whistles of native git's ls-files we should not silently ignore links and submodules.,JUnit has expected the left and actual to the right. Please swap to avoid confusion when debugging,Assert the name of the conflicted file too. Here and elsewhere.
"private String formRevertMessage(RevertResult revertResult) { StringBuilder message = new StringBuilder(); if (revertResult.getNewHead() != null) { message.append(constant.revertedNewHead(revertResult.getNewHead())); } List<String> commits = revertResult.getRevertedCommits(); if (commits != null && commits.size() > 0) { StringBuilder revertedCommits = new StringBuilder(); for (String commit : commits) { revertedCommits.append("" ""); revertedCommits.append(commit); } message.append( revertedCommits.length() > 0 ? "" "" + constant.revertedCommits(revertedCommits.toString()) : ""\n""); } return message.toString(); }",To me it would be a bit clearer to use append chain here.,This is calculating the character count in each iteration. Would it be better to calculate the required size in advance?,e.g. those names instead of a and b :),style nit: no braces around single line block,"We could grab the SshInfo object and if its got no hosts, there is no SSH available and thus HTTP shoudl be used. The SshInfo object should be used anyway to format the port number correctly. The port isn't always 29418.",Strange... the JDT UI settings in our projects should remove trailing whitespace. Please remove.,Please change to !message.trim().isEmpty()) {,Could we extract this logic into a separate class? I'm worried that the BuildView is doing quite a few things already.,"Should this be ""Upstream Committers""? Also, it might be good to move this to a Messages.properties file so it can be translated.",Needs way better name. Static?,Cuddle catch with the closing curly on the prior line
"public static void init(Context context, String appDefinedUserAgent) { String appId = ""unknown""; try { PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0); appId = pi.packageName; } catch (Exception ignore) { } String userAgent = ""Unknown""; try { StringBuilder sb = new StringBuilder(); sb.append(""RealmJava/""); sb.append(BuildConfig.VERSION_NAME); sb.append("" (""); sb.append(Util.isEmptyString(Build.DEVICE) ? ""unknown-device"" : Build.DEVICE); sb.append("", ""); sb.append(Util.isEmptyString(Build.MODEL) ? ""unknown-model"" : Build.MODEL); sb.append("", v""); sb.append(Build.VERSION.SDK_INT); sb.append("")""); if (!appDefinedUserAgent.isEmpty()) { sb.append("" ""); sb.append(appDefinedUserAgent); } userAgent = sb.toString(); } catch (Exception e) { RealmLog.warn(""Constructing User-Agent description failed."", e); } if (SyncManager.Debug.separatedDirForSyncManager) { try { File dir = File.createTempFile(""remote_sync_"", ""_"" + android.os.Process.myPid(), context.getFilesDir()); if (!dir.delete()) { throw new IllegalStateException(String.format(Locale.US, ""Temp file '%s' cannot be deleted."", dir.getPath())); } if (!dir.mkdir()) { throw new IllegalStateException(String.format(Locale.US, ""Directory '%s' for SyncManager cannot be created. "", dir.getPath())); } SyncManager.nativeInitializeSyncManager(dir.getPath(), userAgent); } catch (IOException e) { throw new IllegalStateException(e); } } else { SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath(), userAgent); } UserStore userStore = new RealmFileUserStore(); SyncManager.init(appId, userAgent, userStore); }","use an overload or varargs to make this parameter optional, so: 1- you don't break current API 2- don't force the user to think about this parameter (especially in the context of non sync)",This should stay as a /. User agents are usually in the form software/version,Should log a warning here,Use Constants.TAG,This look similar to cleanUpStagedAndActiveSession method is there a reason to have different paths?,"If the app is opened for the first time, shouldn't there be a deterministic value for previousVersionCode?",final,"Pattern.compile() is normally meant to compile a pattern once, and then re-use it. If you don't do that you can just define a Matcher directly.",the variable name is still sdk16. It could be confusing,suggestion /* package */ ApplicationInfo getAppInfo() {,"> 0.0.0.0 [](start = 35, length = 7) can you put N/A? #Closed"
"private List<StoragePool> searchStoragePool() { Optional<Version> optionalVersion = Config.<HashSet<Version>> getValue(ConfigValues.SupportedClusterLevels).stream() .max(Comparator.naturalOrder()); List<StoragePool> dataCenters = genericSearch(storagePoolDao, true); optionalVersion.ifPresent( version -> dataCenters.forEach( dataCenter -> { dataCenter.setStoragePoolCompatibilityLevelUpgradeNeeded( version.compareTo(dataCenter.getCompatibilityVersion()) > 0); dataCenter.setMacPoolId(dcSingleMacPoolFinder.find(dataCenter.getId())); } )); return dataCenters; }","I believe it would be easier to do check !ifPresent and skip rest, instead of creating that first lambda. if you like 2 lambdas approach instead of one if and one lambda, then fine, but extract method to contain second lambda, because lambda in lambda ... that's like watching Inception again, and nobody should be forced to watch that...","from discussion below: can we use imperative statements here? I find this difficult to parse (I read the filter as a top-level thing that rejects versions that were unfriendly, when that's not the case).","I really want to see toString() within these classes, even for debug, calling all these functions each time is something that should be avoided.",Better to use List<Version> versions = ...,"I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon",This should be getDelegate().getLowestClusterHBaseVersion(),I still don't see why we need the 'if..else' here? both cases are the same,Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION),"I don't think that's not the right place for this. I see two options: 1. to validate the custom-compatibility version in CompatibilityVersionUtils#getEffective instead. 2. not to validate it at this point, set what could be an incorrect value, and rely on the validation in te 'validate' method. I would go with #2 - there's no point in validating something just to put another value (which is also incorrect - if I asked for a VM with CCV 5.7, I expect to get this compatibility or an error if that's invalid).",Should this return null if version is not a valid OSGI version?,Can we make this private?
"public boolean save(final Tuple<String, LogicalPlan> tuple){ final LogicalPlan plan = tuple.getValue(); final String queryId = tuple.getKey(); final File storedPlanFile= new File(planFolderPath + queryId + "".plan""); if (!storedPlanFile.exists()) { final DataFileWriter<LogicalPlan> dataFileWriter = new DataFileWriter<LogicalPlan>(datumWriter); try { dataFileWriter.create(plan.getSchema(), storedPlanFile); dataFileWriter.append(plan); dataFileWriter.close(); return true; } catch (final Exception e) { e.printStackTrace(); } } return false; }","File(planStorePath, queryId + "".plan"")",throws IOException,Maybe it would be good to create a utility class for the client messages.,Important. Deleting this runtime exception XStreamException will remove the actual filename from the stacktrace message when a user has a bug in his solver configuration. That will leave the user clueless (= not good).,Wired Path,It would be good to delete the stored files if the folder exists,Why do you create directory here?,"If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.",s/txSession/transactionSession conver lambda to { .. } form,"If you did this in the reverse order, you would prevent races... so blindly delete and then check if it still exists.",Why are we catching this and just logging it for now?
"public void onMessage(NodeRegistrationContainerReport nodeRegistrationContainerReport, EventPublisher publisher) { if (chillModeManager.getInChillMode()) { if (validate()) { chillModeManager.validateChillModeExitRules(publisher); return; } } else { return; } process(nodeRegistrationContainerReport); if(chillModeManager.getInChillMode()) { SCMChillModeManager.getLogger().info( ""SCM in chill mode. {} DataNodes registered, {} required."", registeredDns, requiredDns); } if (validate()) { chillModeManager.validateChillModeExitRules(publisher); return; } }",We should process data from this report before validating again.,"Please combine the 3 if statements to avoid nesting:  if (!typeToDMLOperationMapping.containsKey(typeCheck) && !isProperESAPICheckForDML(typeCheck, crudMethod) && !isWithSecurityEnforced(node)) { ...",Could you please use anyMatch() here and remove negation? I think it would improve readability :),"So, here I guess we could update a dropwizard Metrics instance for the event rate? That looks fairly simple.","This is a reason why I got 2 receivers.. The variant information is added to PushMessageInformation in the MetricCollector#updateExistingMetric: <LINK_0> Since it is already added in the NotificationDispatcher, it re-adds ""existing"" variant metric. By removing this line it starts to work correctly",maybe put this in else {} ? Not very important because the messages will be removed in exit() anyway,Do you want to consider the data stall of VPN?,why these null initializations required? the same for those in the other constructors,isn't this redundant?,You can use if (event.getDMContext() instanceof IContainerDMContext) to know if you are dealing with a container or a thread.,doc
"protected int doWork() { initializeAggregationState(); IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFilesAreReadable(INTERVALS); final int returnValue; if ( INTERVAL_ITERATOR ) { returnValue = processDataIntervalIteration(); } else { returnValue = processDataNormalIteration(); } if (returnValue != 0) { return returnValue; } log.info(""Iteration complete, generating metric files""); aggregatorList.forEach(this::writeMetricsFileForAggregator); log.info(String.format(""Examined %d loci, Processed %d loci, Skipped %d loci.\n"" + ""Computation took %d seconds."", nTotalLoci, nProcessedLoci, nSkippedLoci, progressLogger.getElapsedSeconds())); return returnValue; }","at this point returnValue==0, so why change?",format across lines  if (VCF != null) { ... },metricsA and metricsB are initialized but never used. It looks like they can be deleted.,"As before, using metrics.values() would be better here since the entry's key isn't used.","you should yield here (return). Operator shouldn't do a ton of work within single call, otherwise a query might be ""unkillable""",Long ... = null -> long ... = 0;,point data are held in interpolatedStates? That is confusing.,"This is common in the code base, and I dislike it. size() == 0 -> isEmpty() You cannot assume the way the List operator implements size() and may be a huge cost (linear and not constant time).",could be simply if (reAggregationFlag || (aggregationFlag && !rawService.getStatusAgg(...))),${result} and ${summary} need converted to Java,same here with being able to get rid of nesting of else
"private void setExecutionEnvironment(TargetPlatformConfiguration result, Xpp3Dom configuration) { String value = getStringValue(configuration.getChild(""executionEnvironment"")); if (value == null) { return; } if (value.startsWith(""?"")) { throw new RuntimeException( ""The target-platform-configuration parameter <executionEnvironment> must not start with a '?'. Use <defaultExecutionEnvironment> without a leading '?' instead.""); } try { ExecutionEnvironmentUtils.getExecutionEnvironment(value); } catch (UnknownEnvironmentException e) { throw new RuntimeException(""Invalid execution environment profile name "" + value); } result.setExecutionEnvironment(value); }","We don't need this check. Even if ""?"" is used somewhere, which I doubt, UnknownEnvironmentException be self-exlanatory enough for somebody to investigate and fix it.","Can be simplified as: return Strings.isNullOrEmpty(valueInEnvironment)? getPropertyValue(properties, defaultValue, property) : valueInEnvironment;","I think it would be better to not use a runtime exception, as this will kill the Bazel server. Prefer an AbruptExitException or similar to provide a user friendly error.",use the constants defined above,"Is it really safe to try to obtain a property from this container callback, which is really call earlier in the application lifecycle?",Minor: Should blank envName also use the default env? (This would be consistent with user.),"Braces are correct set as you double encode the expression. It is only moved code but can be fixed to java if (property.getValue() == null || property.getValue().equals("""")) { .... }","yes, this is what I mean. LGTM","what if my value is "" "" ? should use trim",Variable with constant like name.,Is this cast safe? Shouldn't it be (Boolean) and check for null?
"public void onBindEvent(BindButtonEvent event) { if (event.getState().equals(ButtonState.DOWN) && !SortOrderSystem.containsConsole()) { if (event.getId().equals(new SimpleUri(""engine:tabbingModifier""))) { shiftPressed = true; } if (event.getId().equals(new SimpleUri(""engine:tabbingUI""))) { TabbingManager.focusSetThrough = true; if (shiftPressed) { TabbingManager.changeCurrentNum(false); } else { TabbingManager.changeCurrentNum(true); } for (WidgetWithOrder widget : TabbingManager.getWidgetsList()) { if (widget.getOrder() == TabbingManager.getCurrentNum()) { if (!widget.isEnabled()) { TabbingManager.changeCurrentNum(true); } else { widget.onGainFocus(); TabbingManager.focusedWidget = widget; TabbingManager.getOpenScreen().getManager().setFocus(widget); } } else { widget.onLoseFocus(); if (widget instanceof UIRadialSection) { ((UIRadialSection) widget).setSelected(false); } } } event.prepare(new SimpleUri(""engine:tabbingUI""), ButtonState.UP, event.getDelta()); } else if (event.getId().equals(new SimpleUri(""engine:activate""))) { if (TabbingManager.focusedWidget instanceof UIDropdown) { ((UIDropdown) TabbingManager.focusedWidget).setOpenedReverse(); } else if (TabbingManager.focusedWidget instanceof ActivateableWidget) { ((ActivateableWidget) TabbingManager.focusedWidget).activateWidget(); } event.prepare(new SimpleUri(""engine:activate""), ButtonState.UP, event.getDelta()); } } if (event.getState().equals(ButtonState.UP) && !SortOrderSystem.containsConsole()) { if (event.getId().equals(new SimpleUri(""engine:tabbingModifier""))) { shiftPressed = false; } } }",You can replace this if with: java TabbingManager.changeCurrentNum(!shiftPressed);,please extract this magic number to a named constant,This is always true?,"Here we can replace, I think  if (tab == selectedTab) { if (tabsPanel.getWidgetCount() > 1) {  > if (tab == selectedTab && tabsPanel.getWidgetCount() > 1) {",Optional: use DIRECTDOMAINTAB.equalsIgnoreCase(selectedTab.getId()) to prevent NPE if second operator is null,I'm thinking about this more... I think we need to set focusedWidget to null before calling setKeyboardFocus otherwise the focusedWidget will have focusLost called twice.,It may be nicer to have an actual sentence here.,Nit: Use StringUtil.equal to compare strings,"""tristate"".equals",Same about this,"We don't use braces ({}) for such simple one-line statements, please remove them."
"protected boolean corsRequest() { if (!deployment.isCors()) return false; KeycloakSecurityContext securityContext = facade.getSecurityContext(); String origin = facade.getRequest().getHeader(CorsHeaders.ORIGIN); String exposeHeaders = deployment.getCorsExposedHeaders(); String requestOrigin = UriUtils.getOrigin(facade.getRequest().getURI()); log.debugv(""Origin: {0} uri: {1}"", origin, facade.getRequest().getURI()); if (securityContext != null && origin != null && !origin.equals(requestOrigin)) { AccessToken token = securityContext.getToken(); Set<String> allowedOrigins = token.getAllowedOrigins(); if (log.isDebugEnabled()) { for (String a : allowedOrigins) log.debug("" "" + a); } if (allowedOrigins == null || (!allowedOrigins.contains(""*"") && !allowedOrigins.contains(origin))) { if (allowedOrigins == null) { log.debugv(""allowedOrigins was null in token""); } else { log.debugv(""allowedOrigins did not contain origin""); } facade.getResponse().sendError(403); facade.getResponse().end(); return true; } log.debugv(""returning origin: {0}"", origin); facade.getResponse().setStatus(200); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, ""true""); facade.getResponse().setHeader(CorsHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, exposeHeaders); } else { log.debugv(""cors validation not needed as we're not a secure session or origin header was null: {0}"", facade.getRequest().getURI()); } return false; }","Only set header if ""deployment.getCorsExposedHeaders() != null""",something doesn't look right here; this chunk of code repeats the logic in the previous chunk.,"Yes, good option",can you make this final?,There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; },One cannot assume the request object in the context to be always of type of HttpUriRequest. It would be safer to use the generic HttpRequest type here. Otherwise everything looks good to me.,NIT: Typo in SecurityContext,Any potential performance problems using reflection here?,"I feel that this method should be done atomicly, but that was not the case before and so this is maybe out of topic.","What is the reason this block is needed? The previous implementation was not manually cloning the RoleGroup and the bug report seems to be in relation to popping the Principal. I have always considered role propagation in PicketBox across domains to be a bit of an undefined, does it make sense to be cloning the roles across if we both have the same or different domain?",let's move this consumeInputOnAxisFault call to handleException() method so that it will cover all the paths that this can happen.
"public void beforeSend( ServerSession session, Transaction tx, Message message, boolean direct, boolean noAutoCreateQueue) { try { if (brokerMessageInterceptor == null) { BundleContext bundleContext = getBundleContext(); brokerMessageInterceptor = bundleContext.getService( ((List<ServiceReference<BrokerMessageInterceptor>>) bundleContext.getServiceReferences( BrokerMessageInterceptor.class, ""(name=subjectInjectorPlugin)"")) .get(0)); } brokerMessageInterceptor.handleMessage(session, tx, message, direct, noAutoCreateQueue); } catch (InvalidSyntaxException e) { LOGGER.error( ""Could retrieve the Subject Injector Plugin, subject will not be correctly applied to the message."", e); } }",Is error the right log level here? Seems like warn or even info would be more appropriate.,Why is this not directly injected into the component? Is it not available at construction time?,"why ConfigurableApplicationContext, not ApplicationContext?",drop the comma,"While looking at this, I started wondering if it'd make sense to have this retry forever when Fedora is not available or throws an authentication/WebServiceIOException exception. The reason being that the failure isn't an issue with the job, but with the environment, so skipping over the job won't help. What do you think? Would it make sense to maybe increase the delay and make it retry forever in the two cases I mentioned? For startup of the work daemon i think its fine for it to have max retries before giving up since nothing from the queue would be lost. It'd be kind of nice to get notifications of some sort when these things are failing, but I don't really want to over engineer this since it's not going to be used for that long. So lets hold off on that until the need comes up.",local constant?,i think there's an extra {}: in the logging string,I would expect the system locale to be used here.,"Seems like after OSGI it should be a period instead of a comma, but a nit and may be just how I'm reading it.","This can be simplified java if (throwable instanceof AmqpException) { return new ServiceBusReceiverException((AmqpException) throwable, errorSource); } return throwable;","This can be condensed. java if ((throwable instanceof ServiceBusAmqpException) || !(throwable instanceof AmqpException)) { return throwable; } return new ServiceBusAmqpException((AmqpException) throwable, errorSource);"
"public void delete() throws IOException, InterruptedException { checkPermission(DELETE); FolderComputation<I> computation = getComputation(); Executor executor = Executor.of(computation); if (executor != null) { LOGGER.log(Level.INFO, ""Interrupting {0} in order to delete it"", this); executor.interrupt(Result.ABORTED, new CauseOfInterruption.UserInterruption(User.current())); long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15); while (executor.isAlive() && executor.getCurrentExecutable() == computation && expiration - System.nanoTime() > 0L) { Thread.sleep(50L); } if (executor.isAlive() && executor.getCurrentExecutable() == computation) { LOGGER.log(Level.WARNING, ""Interrupted {0} in order to delete it, but it has not stopped yet"", this); } } super.delete(); }",Superfluous check I think-it has been a long time since Executors were reused.,return getExpirationTimeStamp(0L),This should be infinite time,"perhaps add a ""done"" log message?","Let's do 50 until we're confident we need to go lower. I'm wary of the load increase from always being this fast. If we need to lower the pause this much, we may need to invest in smarter backoffs instead (continuing if the last iteration did work, otherwise pausing for longer).","two questions regarding this logic. 1. Why isn't this  synchronized(lock) { while(paused) { // not sure why this has to be a ""while"" and not an ""if"" wait(); } // hard delete code }  Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?",Suggest using parenthesis to clarify order of operator evaluation,"Then I would not have this method return null, but Duration.ZERO",Could we add a check on the OS actually being Windows before looping like this?,rename cancelAt to cancelAtNs,Why do you remove the annotation afterwards? Isn't that information also useful after the pod has finished?
"private void refreshLocalMessageFlags(final Account account, final Folder remoteFolder, final LocalFolder localFolder, ArrayList<Message> syncFlagMessages, final AtomicInteger progress, final int todo ) throws MessagingException { final String folder = remoteFolder.getName(); if (remoteFolder.supportsFetchingFlags()) { if (K9.DEBUG) Log.d(K9.LOG_TAG, ""SYNC: About to sync flags for "" + syncFlagMessages.size() + "" remote messages for folder "" + folder); FetchProfile fp = new FetchProfile(); fp.add(FetchProfile.Item.FLAGS); List<Message> undeletedMessages = new LinkedList<Message>(); for (Message message : syncFlagMessages) { if (!message.isSet(Flag.DELETED)) { undeletedMessages.add(message); } } remoteFolder.fetch(undeletedMessages.toArray(EMPTY_MESSAGE_ARRAY), fp, null); for (Message remoteMessage : syncFlagMessages) { Message localMessage = localFolder.getMessage(remoteMessage.getUid()); boolean messageChanged = syncFlags(localMessage, remoteMessage); if (messageChanged) { boolean shouldBeNotifiedOf = false; if (localMessage.isSet(Flag.DELETED) || isMessageSuppressed(account, folder, localMessage)) { for (MessagingListener l : getListeners()) { l.synchronizeMailboxRemovedMessage(account, folder, localMessage); } } else { for (MessagingListener l : getListeners()) { l.synchronizeMailboxAddOrUpdateMessage(account, folder, localMessage); } if (shouldNotifyForMessage(account, localFolder, localMessage)) { shouldBeNotifiedOf = true; } } if (!shouldBeNotifiedOf) { NotificationData data = getNotificationData(account, -1); if (data != null) { synchronized (data) { MessageReference ref = localMessage.makeMessageReference(); if (data.removeMatchingMessage(mApplication, ref)) { notifyAccountWithDataLocked(mApplication, account, null, data); } } } } } progress.incrementAndGet(); for (MessagingListener l : getListeners()) { l.synchronizeMailboxProgress(account, folder, progress.get(), todo); } } } }",Can you create a constant for the -1? I'm not sure what that represents here.,I'm not sure about this second condition.,Is this really more readable? (IMHO it's not),Can you not combine these if's to reduce the nesting a bit?,"If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.","Same, this should be expunge() without arguments.",This is throwing a StackOverflowException if invoked. Should probably be sendNow(event),This displays the sender name instead of the account name.,This is throwing a StackOverflowException if invoked. Should probably be sendNow(event),lets use loggers,anySet() is pretty weak. Can't we verify we pass in the right IDs?
"public InputStream getObject(String bucketName, String objectName, long offset, Long length) throws InvalidBucketNameException, NoSuchAlgorithmException, InsufficientDataException, IOException, InvalidKeyException, NoResponseException, XmlPullParserException, ErrorResponseException, InternalException, InvalidArgumentException { if (offset < 0) { throw new InvalidArgumentException(""offset should be zero or greater""); } if (length != null && length <= 0) { throw new InvalidArgumentException(""length should be greater than zero""); } if ((bucketName == null) || (bucketName.isEmpty())) { throw new InvalidArgumentException(""bucket name cannot be empty""); } if ((objectName == null) || (objectName.isEmpty())) { throw new InvalidArgumentException(""object name cannot be empty""); } Map<String,String> headerMap = new HashMap<>(); if (offset > 0) { if (length != null) { headerMap.put(""Range"", ""bytes="" + offset + ""-"" + (offset + length - 1)); } else { headerMap.put(""Range"", ""bytes="" + offset + ""-""); } } HttpResponse response = executeGet(bucketName, objectName, headerMap, null); return response.body().byteStream(); }",Do this validation first. See the order of method arguments.,Add this check at line #1849 and #1581,Use overloaded executePut()/executePost() accepting md5Required argument to avoid unnecessary diffs.,"you don't need to do statObject(), you can send the request to server and server will fail appropriately.","I don't think this check is useful. According to S3 specification, Content-Length must be returned else its server bug. statusCode is always available (else you get an exception) and contentTypecan be treated as optional.",Should this decompress the stream like it did before?,This should be InternalException(). This should not occur.,Please static import Preconditions thanks,Is it good idea to leave java runtime to throw NullPointerException ?,"Wouldn't it be clearer if ""(length + offset)"" is used instead of ""compose size""?","suggestion String range = null; if(offset != null) { range = ""bytes="" + offset + ""-""; if(length != null) { range = range + (offset + length - 1); } }  Couple of more lines, but I think this is more readable."
"public static FileUtils.FileCopyResult unzip( final ByteSource byteSource, final File outDir, boolean cacheLocally ) throws IOException { return unzip(byteSource, outDir, Predicates.<Throwable>alwaysTrue(), cacheLocally); }",I think that by default we should retry on Exceptions but not on other kinds of Throwables.,Putting this in an else block would be clearer.,"The RemoteCache interface has a getRemoteCacheManager(). However, this method currently returns a RemoteCacheManager (ugh...). I've opened <LINK_0> to rectify this. Once this is in place, we'll need the getCache() methods to return a ManagedRemoteCache decorator whose getRemoteCacheContainer() method returns this instance.",Is never used.,isUsedForBackup? And also why are you returning Boolean object when attribute is defined primitive boolean type?,"I don't really think we should support the null case here. Let's force the user to supply something, and if they want to call the NFSOwnerCacheProducer themselves, they can. We can leave the class in place but just not use it automatically.",isCacheable is now true? I guess this was supposed to be false for generic extractors. Or am I wrong?,Shouldn't this return Flux.error(e) ?,This value should be changed only under the write lock.,"Why can't we delegate here to the mentioned ontainerUtils.shouldRequeue() then? This seems for me as breaking change now... I think even if we need a reflection here, it still would be better to keep functionality unbroken. Although we are moving stuff around anyway to fix tangles... :smile:","should rather be  Java Objects.requireNonNull(throwableSupplier, ""throwableSupplier is null"");"
"public PrologEnvironment newPrologEnvironment() throws CompileException { PrologEnvironment env; if(urlLoader != null) { env = envFactory.create(urlLoader); return env; } else { env = envFactory.create(getClass().getClassLoader()); } String rules = getConfig().getPrologRules(); if (rules != null) { PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE); JavaObjectTerm streamObject = new JavaObjectTerm(in); if (!env.execute(Prolog.BUILTIN, ""consult_stream"", SymbolTerm.intern(""rules.pl""), streamObject)) { throw new CompileException(""Cannot consult rules.pl "" + getProject().getName() + "" "" + getConfig().getRevision()); } } return env; }",Style-nit: Unnecessary blank line.,"Instead of exporting IOException, lets wrap that inside of a CompileException so the caller doesn't have to handle a ton of exception types.","Move this declaration down, after the if. Its not needed if you have a ClassLoader.","Lets call this ""rules.pl"" here instead of ""submitrules"". That way it matches the name of the file the user creates, and the name we put into warning/error log statements.",Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?,"There's a corner case here: 1. --resource option is provided hence this method called. 2. yaml file has an include statement which sets resource as false. 3. parseFile is called which doesn't handle propertiesFile as resource. So it needs more fine-grained approach regarding dealing with propertiesFile. If my understanding is right, given that we only read and don't modify properties file after loading it, we could just create Properties instance from here and pass it instead of passing properties file name. Makes sense?",you're still not closing the input stream anywhere,not sure this should be static now,I wouldn't wrap the loadPropertiesFromClassLoader() in the try-catch as that try-catch will eat any exceptions that happen in there.,"Just try-with-resource, no need to close it manually :  try(FileInputStream fileistream = new FileInputStream(filename)) { .... }",what did you revert the Charset.forName()?
public void scheduleTask(TaskDefinition task) throws SchedulerException { if (!Context.getSchedulerService().getTaskByName(task.getName()).getStarted()) { Context.getSchedulerService().scheduleTask(task); } },"After taking a second look, i think we do not need this call at all. All those check of ensure that a service is not started before schedule, etc, belong to the service layer API. Your role is to simply call Context.getSchedulerService().scheduleTask(task) and that is all.","Same here as above. So let us get rid of this whole class. Because it is not adding value. And where it does, that is the business of the service layer API.",Why don't we just get rid of this class too?? Shouldn't this just call? Context.getSchedulerService().scheduleTask(task),I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.,Why do you fetch the task again?,afacit vvv is all noise,"I think that you've already handled isOneTimeExecution() properly in the CronJobSchedulerServiceImpl.scheduleJob, why are you skipping it here ?","suggestion log.debug(""get-task uuid:"" + uuid);",This inevitably is linear. What about key-ing tasks contexts by their ID (maybe as a separate structure in this class)? Or persisting returned value in UpdateSystemMemory?,"@tsr-thulio Improve this message. It should be ""Endorsement Resume schedule task executed""",Shouldn't this also just call Context.getSchedulerService(). shutDownTask(task) Same for the others.
"protected ImmutableList<PubsubMessage> sendBatch(final List<PubsubMessage> batch) throws InterruptedException { final int batchSize = batch.size(); final List<ApiFuture<String>> sendResults = batch.stream() .map(publisher::publish) .collect(Collectors.toCollection(() -> new ArrayList<>(batchSize))); final ImmutableList.Builder<PubsubMessage> remaining = ImmutableList.builder(); for (int i = 0; i < batchSize; ++i) { final ApiFuture<String> pendingResult = sendResults.get(i); try { final String messageId = pendingResult.get(); if (logger.isDebugEnabled()) { final PubsubMessage message = batch.get(i); logger.debug(""Finished sending event (partyId={}, eventId={}) to Pub/Sub: messageId = {}"", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), messageId); } } catch (final ExecutionException e) { final PubsubMessage message = batch.get(i); final Throwable cause = e.getCause(); if (cause instanceof ApiException) { final ApiException apiException = (ApiException) cause; if (apiException.isRetryable()) { logger.debug(""Transient error sending event (partyId={}, eventId={}) to Pub/Sub; retrying."", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); remaining.add(message); } else { logger.warn(""Permanent error sending event (partyId={}, eventId={}) to Pub/Sub; abandoning."", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); } } else { logger.error(""Unknown error sending event (partyId={}, eventId={}) to Pub/Sub; abandoning."", message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_PARTYID), message.getAttributesOrThrow(MESSAGE_ATTRIBUTE_EVENTID), cause); } } } return remaining.build(); }",debug logging should not change the applicationflow. getAttributesOrThrow would. getAttributesOrDefault is better I think,Is there a reason for choosing a LinkedList over an ArrayList ?,can't this lead to 0 due rounding errors -> wait() will treat it as indefinite timeout?,"Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP",suggestion CompletableFuture<IMessage> exceptionalFuture = new CompletableFuture<IMessage>();,"Unnecessary, can remove.","Maybe fail with RetryException(""Stopped retrying the operation because the error is not retriable."", throwable)",shouldnt these go into finally?,another log format? maybe make it compatible with existing? (or change existing),use simple thenApply(...) instead.,"Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));"
"public String validate(String parameterValue, ModelValidatorContext context) throws ValidationException { try { if (!isValidJSON(parameterValue)) { throw new ValidationException(""Expected value should match JSON format, received "" + parameterValue); } } catch (ValidationException er) { throw new ValidationException(""Validator error from JsonParser: Expected value should match JSON format, received "" + parameterValue); } return parameterValue; }","I think this part should be improved. isValidJSON returns a boolean and also throws a ValidationException. You should rather decide on a single strategy, either return true false or return void and throw an exception. I prefer the latter, as an exception contains more meaningful error messages than true/false. In that case the method should be renamed checkValidJson",true?,"This too sounds like ""why it validated"" instead of ""why it failed"".",Strange passing of calls between two methods. I'd rather add the default name specification here and then just pass null from non-parameterized getJsonSignatureValidator,Why are you returning the input parameter? the value seems to be never altered?,Class<?>,Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.,I only see tests referrencing this method. We should not loosen modifiers just for easier testing. Use reflection to grab method.,Please make the constructor private (see Invalid).,"White-spaces missing, please reformat.","The difference between java LOG.debug(""Something to say"", throwable); // and if (LOG.isDebugEnabled()) { LOG.debug(""Something to say"", throwable); }  should be so minimal in this case (we're talking about in the middle of a jersey exception handler!) that I would prefer more the concise approach. Thank you for making the changes."
public void getVersion() throws Exception { String version = gApi.config().server().getVersion(); Truth.assertThat(version).is(Version.getVersion()); },Can be inlined in the assertThat statement below.,Should this return null if version is not a valid OSGI version?,"I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.",I think get was more approriate here,ders more. pls find all and scrub,I remember some special handling was done for rc but I can't see any test cases for that.,"Here group.getSelectedVersionGroup() is not checked for null, though in other cases the check is used.","I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon",You should use method isNullOrEmpty,"why does this need to declare that it throws these exceptions, now?","Would prefer this to call getVersion(), rather than the deprecated getVersionFromStatic()."
"public HttpRequest filter(HttpRequest request) throws HttpException { Credentials currentCreds = checkNotNull(creds.get(), ""credential supplier returned null""); Signer signer = Signer.getSigner(); String signature; Multimap<String, String> decodedParams = queryParser().apply(request.getEndpoint().getRawQuery()); SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'""); df.setTimeZone(new SimpleTimeZone(0, ""GMT"")); String timestamp = df.format(new Date()); String signatureNonce = UUID.randomUUID().toString(); decodedParams.put(""AccessKeyId"", currentCreds.identity); decodedParams.put(""Timestamp"", timestamp); decodedParams.put(""SignatureNonce"", signatureNonce); String prefix; try { prefix = request.getMethod() + SEPARATOR + AcsURLEncoder.percentEncode(""/"") + SEPARATOR; } catch (UnsupportedEncodingException e) { throw Throwables.propagate(e); } String stringToSign = prefix; ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder(); for (Map.Entry<String, String> entry : decodedParams.entries()) builder.add(Strings2.urlEncode(entry.getKey()) + ""="" + Strings2.urlEncode(entry.getValue())); stringToSign += Strings2.urlEncode(Joiner.on(""&"").join(builder.build())); signature = signer.signString(stringToSign, currentCreds.credential + ""&""); decodedParams.put(""Signature"", signature); request = request.toBuilder().endpoint(uriBuilder(request.getEndpoint()).query(decodedParams).build()).build(); return request; }",If you use the jclouds Uris and UriBuilder classes I think you don't have to worry about manually encoding the parameters.,"Nit: Map on the LHS. It doesn't matter a huge amount, but I'm curious why you've used ImmutableMap elsewhere and not here.",Let's just make this @Nullable instead of using Optional,"Again, this could go in the constructor instead of resolving it every time?",Should the return type be Credential?,This could be set in the constructor instead of checking this on every request.,apache StringUtils.isNotBlank(hashPassword) is a shorter,Is it sufficient that getCredentials() was called? Suggestion - a stronger statement would be 'getCredentials() was called and succeeded' such as  java public AWSCredentials getCredentials() { AWSCredentials creds = credentialsFetcher.getCredentials(); getCredentialsCalled = true; return creds; },"Similar thought on adding clarity, move ""this::CallRequestAccessTokenEndpoint"" to a variable: Function<Client, Response> endpointCaller","Why this ':' check? If only alphanumeric characters are allowed, wouldn't a regexp make more sense to validate the identity?","Can you overload this method by providing signature PCKS10... getCsr(X500Name, PublicKey, PrivateKey) so clients don't have to explicitly pass null?"
"public void beforeDocumentChange(DocumentEvent event) { Document document = event.getDocument(); SPath path = editorManager.getEditorPool().getFile(document); if (path == null) { VirtualFile virtualFile = FileDocumentManager.getInstance() .getFile(document); if (virtualFile == null) { LOG.debug(""Ignoring event for document "" + document + "" - document is not known to the editor pool and a "" + ""VirtualFile for the document could not be found""); return; } path = virtualFileConverter.convertToPath(virtualFile); if (path == null) { LOG.debug(""Ignoring event for document "" + document + "" - document is not known to the editor pool and an "" + ""SPath for the document could not be found""); return; } else if (!editorManager.getSession() .isShared(path.getResource())) { LOG.debug(""Ignoring Event for document "" + document + "" - document is not shared""); return; } } String newText = event.getNewFragment().toString(); String replacedText = event.getOldFragment().toString(); editorManager .generateTextEdit(event.getOffset(), newText, replacedText, path); }","Are you tracking all files in the IDE ? If yes this could flood the log file a little bit depending on your sharing setup, e.g you do a partial sharing with only a few files.",Why not as assert?,That's because you're missing a ! here.,"Is OpenProfileEvent fired as a result of a user operation? If it is, we should give the user some feedback if this is where control flow ends.",You could maybe move that just before the if using it?,"Can event.getLength() or even more so, event.getText().length() become null here? Do we need to protect against this?","suggestion logger.warn(""Skipping [{}] as the event is already cancelled."", this.getName());",Could we you {} placeholders instead of concatenation,"I don't think it should be the helper's role to decide that the replacement content comes from a thumbnail. I'm convinced we'll have other use cases where we want replacements computed differently. Could you move this to the caller, in the operation?",This test is not needed since the event bundle is filtered regarding the events defined to trigger the listener in its descriptor.,"Ternary operator idOrPath.startsWith(""/"") ? new PathRef(idOrPath) : new IdRef(idOrPath)"
"private void initialize() { Assert.isNotNull(scope, ""Task scope should not be null.""); events.addAll(manager.getEvents(scope)); try { ReviewTaskProvider reviewTaskProvider = new ReviewTaskProvider(); reviewTaskProvider.open(manager); reviewTaskProvider.query(scope, null); } catch (CoreException e) { System.out.println(e); } events.addAll(manager.getEvents(scope)); }",the constructor already asserts that,"pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures",Should we create the connector and connectorUI like we do in AbstractRepositorySettingsPageTest?,Why not just queryRunner.close();?,can we use a logger instead of System out println?,showJVM,Method should be synchronized probably?,I would prefer that you use an explicit encoding rather than null which is the platform default. Even ASCII would be a better choice than null.,please remove the catch. it is not hit. and if something goes wrong here it is fine to throw that further.,@pynicolas i would avoid having the same value for moduleKey and relativePath,Can't we get the project from the task data? It might be mapped to TaskAttribute.PRODUCT.
"public void registerInterposedSynchronization(Synchronization sync) throws IllegalStateException { try { Transaction tx = transactionManager.getTransaction(); JCAOrderedLastSynchronizationList jcaOrderedLastSynchronization = interposedSyncs.get(tx); if (jcaOrderedLastSynchronization == null) { jcaOrderedLastSynchronization = new JCAOrderedLastSynchronizationList(tx, interposedSyncs); delegate.registerInterposedSynchronization(jcaOrderedLastSynchronization); } jcaOrderedLastSynchronization.add(sync); } catch (SystemException e) { throw new IllegalStateException(e); } }",putIfAbsent semantics is better,"Not a big deal at all, but I think at some point @dmlloyd was wanting all null checks to use org.wildfly.common.Assert.checkNotNullParam(). Sin this case it could just be:  transactionSynchronizationRegistry.registerInterposedSynchronization(Assert.checkNotNullParam(""synchronization"", synchronization);",Missing a reverse() too,Remove this,This method is never used. But I do agree with Jeff that this being static feels like an issue. This would be shared across all deployments which just doesn't seem correct.,I don't understand why this copy is necessary? Couldn't you just do an index (rather than iterator) based iteration of preJcaSync?,"Can this method be restored, implemented as:  TransactionSynchronizationRegistry curTsr = transactionSynchronizationRegistry; return curTsr != null ? curTsr : (TransactionSynchronizationRegistry) jndiService().locate(TSR_NAME);  That achieves the desired perf benefit without taking the risk of bypassing the current mechanism in favor of something else. The setTransactionSynchronizationRegistry method is only called from HibernatePersistenceProviderAdapater.injectJtaManager which looks to only be called from deep logic within some JPA related DUPs. If that logic isn't executed (which seems possible, e.g. if there are no JPA deployments) or if some small future change results in it not being set in some scenario, then this static field will not be set.",We should sort the observers as described in <LINK_0>,"Theoretically, it's possible that some registrations pass. So in the catch block we should only process the observers for which the registration failed. E.g. create a copy of observers outside the catch block, remove each observer for which the registration passed and then process the copy in the catch block.",Braces required by coding convention.,Won't this one override the one set if an exception is raised?
"void setUp() { mockApplicationContext = mock(ApplicationContext.class); mockEventStore = mock(EventStore.class); mockRepositoryProvider = mock(RepositoryProvider.class); executor = spy(new MockExecutor()); testSubject = new SpringAggregateSnapshotterFactoryBean(); testSubject.setApplicationContext(mockApplicationContext); testSubject.setExecutor(executor); when(mockApplicationContext.getBeansOfType(AggregateFactory.class)).thenReturn( Collections.singletonMap(""myFactory"", new AbstractAggregateFactory<StubAggregate>(StubAggregate.class) { @Override public StubAggregate doCreateAggregate(String aggregateIdentifier, DomainEventMessage firstEvent) { return new StubAggregate(aggregateIdentifier); } })); testSubject.setEventStore(mockEventStore); testSubject.setRepositoryProvider(mockRepositoryProvider); mockTransactionManager = mock(PlatformTransactionManager.class); aggregateIdentifier = UUID.randomUUID().toString(); String type = ""StubAggregate""; DomainEventMessage event1 = new GenericDomainEventMessage<>(type, aggregateIdentifier, 0L, ""Mock contents"", MetaData.emptyInstance()); DomainEventMessage event2 = new GenericDomainEventMessage<>(type, aggregateIdentifier, 1L, ""Mock contents"", MetaData.emptyInstance()); when(mockEventStore.readEvents(aggregateIdentifier)).thenReturn(DomainEventStream.of(event1, event2)); }","Would be nice for the test to pass without modifications, to show backwards compatibility.",Why have the JdbcSQLErrorCodesResolver and UnitOfWorkAwareConnectionProviderWrapper assertions been removed from the test?,Not needed?,"Class<? extends T>..., to be exact ;-)",Any reason you're using this over getClass().getClassLoader()?,"Code formating issue: need a space after ,",// needed.,"If you want to match on a specific value you can use ArgumentMatchers.eq(): suggestion eq(NotificationChannelUtils.ChannelType.MISCELLANEOUS)))  If any value will do, there's no need to call getClass() on an instance. You can write it as: suggestion any(NotificationChannelUtils.ChannelType.class)))",Java 8,"assertTrue is even better, I think. It's shorter and easier to read.",Use thenAnswer instead of a matcher to execute arbitrary logic.
"public void run() { try (OpenShiftClient client = clouldClientHelper.get()) { logger.info(""Watching ConfigMap in namespace {}"", client.getNamespace()); try (Watch watchable = client.configMaps().watch(new Watcher<ConfigMap>() { @Override public void eventReceived(Action action, ConfigMap kieServerState) { logger.info(""Event - Action: {}, {} on ConfigMap "", action, kieServerState.getMetadata().getName()); DeploymentConfig dc = client.deploymentConfigs().withName(kieServerId).get(); if (kieServerId.equals(kieServerState.getMetadata().getName()) && action.equals(Action.MODIFIED) && ""True"".equals(dc.getStatus().getConditions().get(0).getStatus()) && triggerRollout(client, kieServerId)) { ObjectMeta md = dc.getSpec().getTemplate().getMetadata(); Map<String, String> ann = md.getAnnotations() == null ? new HashMap<>() : md.getAnnotations(); md.setAnnotations(ann); ann.put(ROLLOUT_TRIGGER_TIMESTAMP, ZonedDateTime.now().format(DateTimeFormatter.ISO_INSTANT)); client.deploymentConfigs().createOrReplace(dc); logger.info(""Update DeploymentConfig: {}"", md.getName()); } else { logger.info(""Event - Ignored""); } } @Override public void onClose(KubernetesClientException cause) { logger.info(""Watcher closed.""); if (cause != null) { logger.info(cause.getMessage()); } } })) { logger.info(""Watcher created.""); Runtime.getRuntime().addShutdownHook(new Thread(() -> { synchronized (this) { isWatchRunning = false; notifyAll(); logger.info(""ShutdownHook sent notifyAll.""); } })); synchronized (this) { while (isWatchRunning && !Thread.currentThread().isInterrupted()) { logger.info(""WatchRunner thread starts.""); try { wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); logger.error(""WatchRunner thread being interrupted"", e); } logger.info(""WatchRunner thread being notified.""); } logger.info(""WatchRunner thread exits.""); } } } catch (KubernetesClientException e) { logger.error(""Failed"", e); } }",not sure how often this can be logged so maybe change the level to debug and also log the event that is being ignored?,"Probably going to want to watch the endpoints() rather than events(). Endpoints will give you ready + not ready hosts/ports with the metadata attached, which should be all we need for this case. Events will likely be way more data than we actually need",Critical service -> Critical component,Dangerous to call callbacks under the inner lock.,Is is reasonable to ask that this log line be written more readily (less restricted than FINE) and include a note/link to instructions for the required level of access needed to watch pod events?,return Optional<ConfigMap> ?,"Maybe: ""Cannot retry checkAndUpdateConfigMap with configMap "" + configMapName + "" because it does not exist.""",Should handler we registered when an exception occurs while watching start? Or mb it should be registered only when watcher successfully created? I prefer the second way,Maybe it makes sense to print Log.info instead. Then admin would understand better why namespace is not deleted after workspace creation.,Minor: we can deduplicate the codes by generating the singleton list before switch.,Looks like watchService cannot be null
"private static Integer getPlatFormOffset() { String currentOs = System.getProperty(""os.name"").toLowerCase(Locale.ROOT); String currentJdk = System.getProperty(""java.version"").toLowerCase(Locale.ROOT); for (int i = 0; i < PLATFORM_LIST.size(); i++) { if (currentOs.toLowerCase(Locale.ROOT).contains(PLATFORM_LIST.get(i).split("","")[0].toLowerCase(Locale.ROOT)) && currentJdk.toLowerCase(Locale.ROOT).contains( PLATFORM_LIST.get(i).split("","")[1].toLowerCase(Locale.ROOT))) { return i; } } return null; }","Throw an exception here and log an error including the currentOs and currentJdk. Returning null will cause a NPE upstream and we'll not know which OS, JDK name caused it.","Are we sure this alwyas _equals_ ""linux"" or would be using startsWith a safer option?","My inclination would be to make this regular expression a local variable, add a capture group for the integer, and then reuse that on lines 142 to get the version. Relying on a regular expression here and split below seems like it could create problems in the future if someone only updates this in one place.","Pattern.compile() is normally meant to compile a pattern once, and then re-use it. If you don't do that you can just define a Matcher directly.",In what cases this system property is null ? And why Windows (this developer unfriendly OS) should be the default ? :),This can / should probably be Locale.ROOT yeah?,please cache this map (as it is hard coded) and create an intial value so it would be compact new HashMap<>(2),"I see that similar methods in this class use IllegalStateException, shouldn't we do the same here?",please add a break statement after this to avoid fallthrough (ErrorProne complains about this).,Gson doesn't run on these versions so I don't see any reason to include them.,"Instead of returning null, could we throw an exception? We have to handle the case of finding an unknown Java version as well. Right now there will be an NPE when trying to do the comparison."
"public void subscribeUnsubscribe() throws Exception { final Postman postman = Mockito.mock(Postman.class); final DyBase base = new DyBase(); final Alias alias = new EmAlias(this.randomAlias(base), postman); final Bout bout = alias.inbox().bout(alias.inbox().start()); final Alias friend = this.randomAlias(base); bout.friends().invite(friend.name()); final ArgumentCaptor<Envelope> captor = ArgumentCaptor.forClass(Envelope.class); friend.inbox().bout(bout.number()).subscribe(false); bout.messages().post(DON_T_SEND_IT); friend.inbox().bout(bout.number()).subscribe(true); bout.messages().post(SEND_IT); bout.messages().post(SEND_IT); friend.inbox().bout(bout.number()).subscribe(false); bout.messages().post(DON_T_SEND_IT); Mockito.verify(postman, Mockito.times(2)).send(captor.capture()); final List<Envelope> messages = captor.getAllValues(); for (final Envelope envelope : messages) { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); MimeMultipart.class.cast(envelope.unwrap().getContent()) .writeTo(baos); MatcherAssert.assertThat( baos.toString(), Matchers.containsString( SEND_IT ) ); } }",@pecko let's also assert it does not contain the other string.,"@mbarbieri I think you can do one assertion, comparing the arguments list directly to a list of InternetAddresses containing only friend.email()...",@bdragan let's match attachment some.xml,@erimerturk shouldn't this be using the same bout as the other one? Do we really need to change this test?,@CarlosGines let's inline bout here as well,@amihaiemil can be move in the previous line to put the most we can in a 80 characters line,"topicCreator must be created here, not at the top.",Why do you log out? Users.signIn() should log out user implicitly.,Please use assertFalse,"avoid using one-time variables, just inline it if it's the only usage",Mock? You can use pretty simple Lambda:  channel.subscribe(m -> {});  :smile:
"private void testCopyQuestion() throws Exception { ______TS(""Success case: copy questions successfully""); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyTableToLoad(); assertFalse(""Unable to submit when there are no questions selected"", feedbackEditPage.isCopySubmitButtonEnabled()); feedbackEditPage.verifyHtmlPart(By.id(""copyModal""), ""/instructorFeedbackCopyQuestionModal.html""); feedbackEditPage.clickCopyTableAtRow(0); assertTrue(""Can click after selecting"", feedbackEditPage.isCopySubmitButtonEnabled()); feedbackEditPage.clickCopySubmitButton(); feedbackEditPage.verifyHtmlMainContent(""/instructorFeedbackCopyQuestionSuccess.html""); ______TS(""Success case: copy multiple questions successfully""); int numQuestionEditForms = feedbackEditPage.getNumberOfQuestionEditForms(); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyTableToLoad(); feedbackEditPage.clickCopyTableAtRow(0); feedbackEditPage.clickCopyTableAtRow(1); feedbackEditPage.clickCopySubmitButton(); assertEquals(numQuestionEditForms + 2, feedbackEditPage.getNumberOfQuestionEditForms()); ______TS(""No copiable questions""); feedbackEditPage = getFeedbackEditPageOfCourseWithoutQuestions(); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyErrorMessageToLoad(); assertEquals(""There are no questions to be copied."", feedbackEditPage.getCopyErrorMessageText()); assertFalse(""Should not be able to submit if there are no questions"", feedbackEditPage.isCopySubmitButtonEnabled()); ______TS(""Fails gracefully with an error message""); feedbackEditPage = getFeedbackEditPage(); feedbackEditPage.changeActionLinkOnCopyButton(""invalid URL""); feedbackEditPage.clickCopyButton(); feedbackEditPage.waitForCopyErrorMessageToLoad(); assertEquals(""Error retrieving questions. Please close the dialog window and try again."", feedbackEditPage.getCopyErrorMessageText()); assertFalse(""Should not be able to submit if loading failed"", feedbackEditPage.isCopySubmitButtonEnabled()); String questionId = getFeedbackQuestionWithRetry(courseId, feedbackSessionName, 4).getId(); BackDoor.deleteFeedbackQuestion(questionId); questionId = getFeedbackQuestionWithRetry(courseId, feedbackSessionName, 3).getId(); BackDoor.deleteFeedbackQuestion(questionId); }",Not related to gender type,Should not be able to submit when there is no question selected.,Added because?,Can be joined with the previous line?,Instead of doing this why not just assert if a certain class is present when the panel is expanded. Using verifyByHtml doesnt make sense here,"If possible, wait for element to appear instead of waiting for an absolute time as it will be more reliable.",please add space before {,log () here and after,"Just a question, why do we have to test whether the publish immediately button isn't selected? What does the 'original values' here refer to?","protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber(""2"")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());","similar here, should verify html content after the edition, so that you can know the edition indeed appears on the page"
"public Ban.Builder profile(org.spongepowered.api.profile.GameProfile profile) { checkNotNull(profile, ""Profile cannot be null!""); checkState(banType == BanTypes.PROFILE, ""Cannot set a GameProfile if the BanType is not BanType.USER_BAN!""); this.profile = profile; return this; }",Message needs updating,Doesn't this duplicate the nonNull check?,Interesting wrapping style :),Is this refactoring or new functionality?,This is illogically placed,Not sure this is the best place for these generic checks.,"The message should be ""definition is null"". Same for all other requireNonNulls","similarly:  if (!expression) { throw new BadRequestException(String.format(messageTemplate, messageArgs)); }","Can you remove private setters? It's not necessary we have private setters, so we reduce the size of the class",Use CharSequence instead of Object for actual's type.,It might be better to override toString rather than append ValidationError because now you will get org.voltdb.exception.ValidationError: ValidationError: MESSAGE when toString is called or the stack trace is printed
"public void removeListener() { View view = getView(); if (view != null) { getDiagramEventBroker().removeNotificationListener(view, this); if (hostSemanticElement != null) { for (EObject stereotypeApplication : hostSemanticElement.getStereotypeApplications()) { getDiagramEventBroker().removeNotificationListener(stereotypeApplication, this); } getDiagramEventBroker().removeNotificationListener(hostSemanticElement, this); hostSemanticElement = null; } } if (!stereotypeList.isEmpty()) { for (Stereotype stereotype : stereotypeList) { View label = helper.getStereotypeLabel(hostView, stereotype); if (null != label) { getDiagramEventBroker().removeNotificationListener(label, this); } BasicCompartment compartment = helper.getStereotypeBraceCompartment(hostView, stereotype); if (compartment != null) { getDiagramEventBroker().addNotificationListener(helper.getStereotypeBraceCompartment(hostView, stereotype), this); } if (compartment != null && stereotype != null) { EList<Property> properties = stereotype.allAttributes(); for (Property property : properties) { getDiagramEventBroker().removeNotificationListener(helper.getStereotypePropertyInBrace(hostView, stereotype, property), this); } } } } }",'null !=' is preferably used,Avoid multiple returns.,unsubscribe(),null or constant must be first for operations.,List#isEmpty(),List#isEmpty(),checkif you could remove that because there is already a notification service for stereotype,Can't assume ConnectableElement here either.,"Same as #addObserver, no one seems to call it.",unsubscribe(),This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
"protected void reinitAllDatabases() throws IOException { boolean acquired = false; try { semaphore.acquire(Integer.MAX_VALUE); acquired = true; try { db.close(); } catch (IOException e) { log.warnUnableToCloseDb(e); } try { expiredDb.close(); } catch (IOException e) { log.warnUnableToCloseExpiredDb(e); } } catch (InterruptedException e) { log.warnUnableToCloseDb(e); log.warnUnableToCloseExpiredDb(e); } db = reinitDatabase(getQualifiedLocation(), dataDbOptions()); expiredDb = reinitDatabase(getQualifiedExpiredLocation(), expiredDbOptions()); if (acquired) { semaphore.release(Integer.MAX_VALUE); } }",This should be done in a proper try finally block. If a reinitDatabase method threw an IOException the semaphore would be irreparably broken.,"@rvansa I think stop() should release all the semaphore permits. Threads trying to read from/write to the store after it was stopped should throw an exception immediately, they should not block forever.","Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.","I missed that PR, but isn't Notifier a lot like CompletedFuture?",one extra {},"Thank you, @dsyer , for the contribution! I'm afraid that this doesn't fit to the current 4.3 GA dead line this Friday. Just after that we will switch to 5.0 based on Java 8 already, so this issue may go away already :smile:  :spring-integration-jdbc:compileJava/home/travis/build/spring-projects/spring-integration/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java:158: error: unreported exception Exception; must be caught or declared to be thrown throw e;  Here is a JIRA to track: <LINK_0> Let us know if that works for you","A more detailed message like ""Sleep during DB update retry interrupted"" would be more useful.",I guess this mirrors the semaphore.acquire(Integer.MAX_VALUE) in the stop() method. Wouldn't it make sense then to initialize the semaphore in the init() method with new Semaphore(Integer.MAX_VALUE) ? @danberindei suggestion to use a reentrant lock is probably even better,"This does not reflect the tryLock(long time, TimeUnit unit) contract. We may obtain the local lock but should wait for the result from DB exactly during the desired time. Or even better for the time which is left after the local tryLock. Can transaction timeout help us here ?","Who else is using the lock? You could make a ""queueLock"" object to lock on for this purpose.",the second parameter can be removed
"public MatchClause append(Filter filter) { if (clause == null) { clause = new StringBuilder(""MATCH (n)""); if (filter.getRelationshipDirection().equals(Direction.INCOMING)) { clause.append(""<""); } clause.append(String.format(""-[%s:`%s`]-"", relationshipIdentifier(), this.relationshipType)); if (filter.getRelationshipDirection().equals(Direction.OUTGOING)) { clause.append("">""); } clause.append(String.format(""(%s) "", nodeIdentifier())); } clause.append(filter.toCypher(relationshipIdentifier(), clause.indexOf("" WHERE "") == -1)); return this; }",suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {,suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {,It hardcodes that the EntityUid must be a TrackedEntityType,There are lots of other places that build predicates. We should be consistent and use this new method everywhere we build a FilterPredicate.PathElement OR a new Path.,Introduce hasLabel() on Node?,This variable and the next seem unused.,Should we give more hints as to why this is Invalid Search Parameter?,"For the future, please send formatting changes in a preceding commit so that they don't interfere with spotting the actual changes..",Why it's not as below  final RelTraitSet inputTraitSet = sort.getInput().getTraitSet().replace(out);,"I just realized that the current way we do null check is incorrect in a lot of the matchers. If column is null, an NPE will have been thrown in the super call before reaching this statement. checkNotNull returns the object itself, so it is better to call it in the super:  super(..., prefix, Preconditions.checkNotNull(column).getSqlKeyword()), suffix));",clause?
"public static AdjustableSweepBatchConfigSource create( MetricsManager metricsManager, Supplier<SweepBatchConfig> rawSweepBatchConfig) { AdjustableSweepBatchConfigSource configSource = new AdjustableSweepBatchConfigSource(rawSweepBatchConfig); Gauge<Double> gauge = AdjustableSweepBatchConfigSource::getBatchSizeMultiplier; metricsManager.addMetricFilter(AdjustableSweepBatchConfigSource.class, ""batchSizeMultiplier"", ImmutableMap.of(), () -> gauge.getValue() != 1.0); metricsManager.registerMetric(AdjustableSweepBatchConfigSource.class, ""batchSizeMultiplier"", gauge); return configSource; }",I am confused b/w the description and implementation of filter here.,"Looks like this line is unnecessary? The ""values"" variable is never being used.",Should this be removed from here if this is already being updated in getValue?,code style,"Avoid two lookup, what about this?  final Double ratio = this.configuration.get(entity); return ratio == null ? DEFAULT_RATIO : ratio.doubleValue();","This shouldn't be synchronized, as nothing else in MetricRegistry uses this lock.",Might be better to just not set when empty,Should it be Locale.getDefault()?,"I thought you wanted to end this practice, Adrian?","I would rewrite this without streams, it's a bit difficult to read.",This constructor should call the more general one with a default value (3 in this case)
"public void configure(Binder binder) { JsonConfigProvider.bind(binder, ""druid.metadata.storage.tables"", MetadataStorageTablesConfig.class); JsonConfigProvider.bind(binder, ""druid.metadata.storage.connector"", MetadataStorageConnectorConfig.class); JsonConfigProvider.bind(binder, ""druid.manager.segments"", MetadataSegmentManagerConfig.class); JsonConfigProvider.bind(binder, ""druid.manager.rules"", MetadataRuleManagerConfig.class); binder.bind(PasswordProvider.class).toProvider( new Provider<PasswordProvider>() { @Inject MetadataStorageConnectorConfig metadataStorageConnectorConfig; @Inject Injector injector; @Override public PasswordProvider get() { final PasswordProvider passwordProvider; if (metadataStorageConnectorConfig == null || metadataStorageConnectorConfig.getPasswordProvider() == null) { JsonConfigProvider<PasswordProvider> provider = JsonConfigProvider.of(""druid.password"", PasswordProvider.class); provider.inject(injector.getInstance(Properties.class), injector.getInstance(JsonConfigurator.class)); passwordProvider = provider.get().get(); } else { passwordProvider = metadataStorageConnectorConfig.getPasswordProvider(); } injector.injectMembers(passwordProvider); return passwordProvider; } } ); }",Logging might be helpful to warn users that this should not happen.,This can be replaced with NoopAuthorizationManager.,Probably need this?  binder.bind( new TypeLiteral<SeekableStreamIndexTaskClientFactory<KinesisIndexTaskClient>>() { } ).to(KinesisIndexTaskClientFactory.class).in(LazySingleton.class);  Please fix KafkaIndexTaskModule properly too.,Nit: you could just turn the field into a ConfigOption.,Use CopyOnWriteArrayList for the injectorNames and remove synchronized() statements.,I would maybe prefer to call it Noop instead of Fake?,I don't think this is required. Given that it has a no-arg constructor. Guice should be able to inject this.,@mureinik We should ensure that the vararg-array is not null. You can use the class Checks here.,Do you need this? I think that binding it should be enough.,Please use Singleton annotation and remove this explicit binding. We plan to remove existing such usage pattern.,"Version.version would be better (like '2.4.1-SNAPSHOT', compare to '2.4' )"
"public void testMigrationTask() throws InterruptedException { MigrationTask migrationTask = new MigrationTask(project); migrationTask.start(); Assert.assertTrue(migrationTask.isAlive()); migrationTask.join(); Assert.assertFalse(migrationTask.isAlive()); Assert.assertEquals(100, migrationTask.getProgress()); }","test should test, if metadata is migrated ;-)",Could be merged to the next one with help of pollDelay.,why would validation have run just after construction?,"Slightly cleaner to verify that TaskInstance's commit is called/not called instead of interacting with the OffsetManager directly (since the contract AsyncRunLoop is with TaskInstance, not OffsetManager.)","This whole logic could be simplified as:  private void verifyExceptionalState(ThrowingRunnable action) { assertThrows(TaskMigratedException.class, action); // This task should be closed as a zombie with all the other tasks during onPartitionsLost assertThat(assignedTasks.runningTaskIds(), equalTo(singleTaskId)); EasyMock.verify(t1); }  so that new test just needs to put in the intended action. Here singleTaskId is a class level parameter I defined to replace the singleton list, which is not highly required.","Possibly unnecessary to start two new threads for this test when one sits around waiting for the InterruptTestRunner to complete. Most of InterruptTestRunner could be inlined here (if you wanted). There may be some purpose I'm missing - I initially thought it was to stop the test hanging, but we join() indefinitely here.","in theory it takes 2s, if it takes 3s it does not work because it means that work1 is executed twice. The timeout must be lower than 3s try something like ""getDurationMillis() * 3 - 200""",nit: remove final (here and elsewhere in this file),I _really_ dislike package-visible fields being used in tests.,We required braces for single-line if statements.,You need to mark the pipelining as final as the code needs to be JDK6 compatible.
"protected Object toNSCollection(ERXRestFormat.Delegate delegate, NSMutableDictionary<Object, Object> associatedObjects) { Object result = associatedObjects.get(_associatedObject); if (result == null) { if (delegate != null) { delegate.nodeWillWrite(this); } if (isArray()) { NSMutableArray<Object> array = new NSMutableArray<Object>(); for (ERXRestRequestNode child : _children) { array.add(child.toNSCollection(delegate, associatedObjects)); } result = array; } else if (isNull()) { result = NSKeyValueCoding.NullValue; } else if (_value != null) { result = _value; } else { NSMutableDictionary<Object, Object> dict = new NSMutableDictionary<Object, Object>(); for (Map.Entry<String, Object> attribute : _attributes.entrySet()) { String key = attribute.getKey(); Object value = attribute.getValue(); if (value == null) { value = NSKeyValueCoding.NullValue; } dict.put(key, value); } for (ERXRestRequestNode child : _children) { String name = child.name(); Object value = child.toNSCollection(delegate, associatedObjects); if (value != NSKeyValueCoding.NullValue || ERXProperties.booleanForKeyWithDefault(""ERXRest.includeNullValues"", true) == true) { dict.put(name, value); } } if (dict.isEmpty()) { result = NSKeyValueCoding.NullValue; } else { result = dict; } } if (_associatedObject != null) { associatedObjects.put(_associatedObject, result); } } return result; }",_== true_ part is not needed as booleanForKeyWithDefault already returns a boolean ;),"Giving new opportunity for Marco (or everyone else), eh? ;-P",Minor: why do you need the cast here?,"The logic of this method is duplicated from SaxonXPathRuleQuery::getRepresentation. In case the list is empty, this should be using EmptySequence.getInstance(), which the SaxonXPathRuleQuery already does",use final keyword,Would it be cleaner to just do this: <LINK_0>,"I think there are a few more types here that are relevant like XSBoolean, XSDateTime, XSInteger, and XSURI.",Maybe use a somewhat more descriptive variable name rather than 'x' :),else if,"jfyi we could also do:  headerMapper = simpleMapper .copy() .configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);  <LINK_0>",Why return as an object ? Wouldn't it be better to just return a String[] ? Saves the trouble of casting ?
"public User addUserToProject(final Project project, final Account account, final Role... userRoles) { notNull(project, ""project""); notNull(account, ""account""); notEmpty(account.getUri(), ""account.uri""); notNull(userRoles, ""userRoles""); validateRoleURIs(userRoles); noNullElements(Arrays.stream(userRoles).map(Role::getUri).collect(Collectors.toList()), ""userRoles.uri""); notEmpty(project.getId(), ""project.id""); final User user = new User(account, userRoles); doPostProjectUsersUpdate(project, user); return getUser(project, account); }",redundant check,This should only be indented one level,pls use querydsl instead (already in master),"This should call all  java return all(params, (RequestOptions) null);",Please remove diagnostic modifications before merging.,Probably smarter that way yes,"This should actually be APIException, the + should be a , and the other part should be wrapped in new Object[] { } so this gets properly localised.",Shoudn't use class attribute for the UserApi?,"You can use ArrayList constructor instead of going through stream. java new ArrayList<UserDTO>(users)  Second point. I know it was already there, but peek is intended mainly for debugging. Map would be much clearer. java .map(e -> e.users(new ArrayList<>(users)));","There should be a null check on the identityProvider, prior to calling its getRoles method. Maybe something like... List<String> roles = (identityProvider != null) ? identityProvider.getRoles():null;",do we really have to throw an exception in that case? wouldn't a warn be enough?
"public void testDeadlock() throws Exception { doTest(1000 * 30); boolean interrupted = Thread.interrupted(); if (interrupted) { fail(""Thread was interrupted at end of test""); } }",Why not inline this variable?,I don't think this is needed. This method already checks the return value of latch.await() and throws on failure. The client doesn't need to assert since returning from the method indicates success.,Bump all the numbers,"Possibly unnecessary to start two new threads for this test when one sits around waiting for the InterruptTestRunner to complete. Most of InterruptTestRunner could be inlined here (if you wanted). There may be some purpose I'm missing - I initially thought it was to stop the test hanging, but we join() indefinitely here.",Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.,Shouldn't you call cdl2. countDown() before you check the state again?,"My suggestion was to do assertFalse(await(tryLock)); first and await(lock.unlock()); later, without other delays.",Let's check exception message here?,"Hmmm, I think this JMX attribute became kind of useless the moment we stopped allowing the mix of tx and non-tx operations in the same cache, and now even more so because the number of deadlock checks isn't deterministic. I'd deprecate the attribute and remove this check.",:astonished:,This should probably be removed
"public void makeSortable() { final Map<ImageResource, Integer> imageWeightMap = new HashMap<ImageResource, Integer>(); imageWeightMap.put(statusCell.upImage, 0); imageWeightMap.put(statusCell.volumeSomeBricksDownImage, 1); imageWeightMap.put(statusCell.allBricksDownImage, 2); imageWeightMap.put(statusCell.downImage, 3); makeSortable(new Comparator<GlusterVolumeEntity>() { private final CustomStatusImageComaparator imageComparator = new CustomStatusImageComaparator(imageWeightMap); @Override public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) { return imageComparator.compare(statusCell.getStatusImage(statusCell.getVolumeStatus(o1)), statusCell.getStatusImage(statusCell.getVolumeStatus(o2))); } }); }",Are we recalculating the volume status here?,It's probable that the original intent was to avoid the overhead of Float.compare which will call floatToIntBits to do precise equality ? We could maybe switch to the following logic: if (o1.weight > o2.weight) { return -1; } else if (o1.weight < o2.weight) { return 1; } else { return 0; } To make it clearer for findbugs that we don't care about exact equality? This is only used for ordering and I think it's fine to treat 2 weights equal (for ordering purposes) if they change by just epsilon.,"Rather than a boolean for ssd, should this be a type? Maybe we want to favor non-ssd in another balancer impl?","why not >0 ? let say a volume has 6 bricks and first 2 are down. In this scenario, the above loop will executed 4 times but 3 is enough to get the expected result",please make it static,This doesn't seem aligned with the original implementation,Careful with float comparison. Although minor accuracy issues isn't a big deal here.,use foreach style loop,"May be I am missing something, but should ExecutableFlow be available to comparator (ranker) ? This will enable us to have more signals to chose an Executor A over Executor B in context of Executable flow C ? Just to make it more extensible and avoiding interfaces changes later on.",It's Comparator.reverseOrder(),"This means we are ordering the results by startTime, by default. But, the current behavior is to order by instanceTime in descending order and this change breaks that."
"public GoldenEgg(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.ARTIFACT}, ""{2}""); this.subtype.add(SubType.FOOD); this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1))); Ability ability = new AnyColorManaAbility(new GenericManaCost(1)); ability.addCost(new TapSourceCost()); ability.addCost(new SacrificeSourceCost()); this.addAbility(ability); Ability ability1 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(3), new ManaCostsImpl(""{1}"")); ability1.addCost(new TapSourceCost()); ability1.addCost(new SacrificeSourceCost()); this.addAbility(ability1); }",Costs 2.,This needs to trigger only the first time something cycles in a turn.,"Use Custom instead of EndOfGame, it doesn't add unnecessary text.","The string subtype is deprecated, use SubType.HUMAN and SubType.ROGUE instead.",You can just use new DamageTargetEffect(new SourcePermanentPowerCount()) here.,"This should be a triggered ability of the enchantment, not a trigger gained by the creature","This needs to not have the sunburst text, check out Skyrider Elf",This isn't important but you can leave out the zone since the default constructor already assumes it,"This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it.","This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.","You should use .setText(""and gains trample until end of turn""), otherwise the text is gonna be all wrong"
"public void unparse(SqlWriter writer, int leftPrec, int rightPrec) { writer.keyword(""CREATE""); if (isTemporary()) { writer.keyword(""TEMPORARY""); } if (getReplace()) { writer.keyword(""OR REPLACE""); } writer.keyword(""VIEW""); if (isIfNotExists()) { writer.keyword(""IF NOT EXISTS""); } viewName.unparse(writer, leftPrec, rightPrec); if (fieldList.size() > 0) { fieldList.unparse(writer, 1, rightPrec); } if (comment != null) { writer.newlineAndIndent(); writer.keyword(""COMMENT""); comment.unparse(writer, leftPrec, rightPrec); } writer.newlineAndIndent(); writer.keyword(""AS""); writer.newlineAndIndent(); query.unparse(writer, leftPrec, rightPrec); }",remove this ?,nit: Use a static constant representing CHANGE_DETECTION_ENABLED instead,if the views are inter-dependent you might need a loop to clean these up (which we already do in a couple of other places),"What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.","That seems like a very long way to check emptiness of a string. Perhaps add an isEmpty() fn in StringUtil class, if schemaName.isEmpty() is not sufficient for whatever reason.",why else?,"Looks like here we have to setNeverLazy(true) only for recursive CTE, no?","same here. If phoenix row ts is getting server-side ts, it's better to compare with server-side ts instead of client-side","seems like we don't need targetSession anymore, we can just use session?","this IF block is repeated multiple times, can you please extract it as method?","suggestion public AnalyzedDropView analyze(DropView dropView, CoordinatorTxnCtx txnCtx) {"
"public void testValidCRAMFileWithoutSeqDict() throws Exception { final SamReader samReader = SamReaderFactory. makeDefault(). validationStringency(ValidationStringency.SILENT). referenceSequence(new File(TEST_DATA_DIR, ""nm_tag_validation.fa"")). open(new File(TEST_DATA_DIR, ""nm_tag_validation.cram"")); final ReferenceSequenceFile reference = new FastaSequenceFile(new File(TEST_DATA_DIR, ""nm_tag_validation.fa""), true); final Histogram<String> results = executeValidation(samReader, reference, IndexValidationStringency.EXHAUSTIVE); Assert.assertTrue(!results.isEmpty()); }","just to be sure there is no index/dictionary involved: final ReferenceSequenceFile reference = new FastaSequenceFile(new File(TEST_DATA_DIR, ""nm_tag_validation.fa""), true); final SamReader samReader = SamReaderFactory. makeDefault(). validationStringency(ValidationStringency.SILENT). referenceSource(new ReferenceSource(reference)). ...","Ok, one more time: close the reader?","You also need to keep track of whether you got any exception at all, and assert that you did at the end of this test (since you can't use the built-in expectedExceptions here due to the wrapping).",These throws clauses and the corresponding imports are unused.,please test other types as well..,"I'd just pass e, so the stack trace also gets logged.",Arrays.fill would save a few lines here.,would be good to have a test that also checks the Ns and the masked regions,"Should probably take the assert out, since this throws before we get here",also include in the error message the build you found,"Instead of assertFalse() this should assert the number of results and the values for each expected result, if possible."
"public void cleanup() { if (model != null) { model.cleanup(); model = null; } if (modelItems != null) { for (T model: modelItems) { if (model instanceof HasCleanup) { ((HasCleanup)model).cleanup(); } } } for (Pair<T, V> item : items) { T value = item.getFirst(); if (!isGhost(value)) { if (item instanceof HasCleanup) { ((HasCleanup)value).cleanup(); } } } cleanContentPanel(); }","Yes had that on my to do list, but missed it.",items is a list - just call items.sort(getDefaultItemComparator()),Can replace with forEach.,"Out of curiosity, why is the return type of this setter not void?","OK, so I have a suggestion for improvement: instead of typecasting to the right kind of selection model, why not simply have a useful method on the ListModel itself, like: List<T> getSelectedList() so that callers who simply need the above list don't have to do the if/else magic? And if we do this, don't we simply need one selection model field in the ListModel itself? It basically comes down to the fact that complex code is sometimes due to not-useful-enough API on the objects we need to work with.",This should only be implemented once in the framework and shared by all places that check for anonymous access.,Should not be necessary as you remove it in deactivate already.,Useless statement.,looks like the super is a no-op -- do you want to leave it?,"I think we can just call clear() on mItemsSelected, and by doing so we can also make it final.",ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
public String get(String name) { return (isSet(name)) ? myRecord.get(name) : new String(); },"just return """" instead of new String()",This is another behavioral change that I don't want to see in an unrelated PR.,Will NPE if the key does not exist.,"You can just get it instead of doing two map accesses, doesn't work? Same with below. java return (String) dataMap.get(key);",Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature,why change this?,"Should this be return getRecord(tableName, null, key)?",Need to implement,The this. in getters are unnecessary too.,Maybe we want to keep something similar to what id was before,Why do we return the parents name instead of the name we store a few lines above?
private void updateMutePreviewOverlayVisibility() { mutePreviewOverlay.setVisibility( showMuteOverlayOnVideoCall() && muteButton.isChecked() && !isInGreenScreenMode ? View.VISIBLE : View.GONE); },"Just a tiny thing, I guess we can move the condition to an assign statement, it could be easier to read since the conditional expression is quite complex now. int mutePreviewOverlayVisibility = showMuteOverlayOnVideoCall() && muteButton.isChecked() && !isInGreenScreenMode ? View.VISIBLE : View.GONE; mutePreviewOverlay.setVisibility(mutePreviewOverlayVisibility);",Move it into onIncomingCall()?,"We should still warn that setVisible is not implemented, since setting the value doesn't actually have any effect (just like setFocus).","This defaults to false. Since the key is new it will be missing on older platforms. Use getBoolean(String, boolean) instead.","This seems to be risky. The availability of the hard keyboard may be changed when the display rotates (e.g. Droid), and in that case, the software keyboard should be hidden. The fix should be implemented just in InputMethodManagerSerivce.java.",Why only this update is ignored when mVideoCallScreen is null? How could it fix the crash?,"Remove this check? It will throw NullPointerException if it's null, which should never happen.",nit: don't need this return false; line,Lets not create a the local variable and just: sendScreenState(pm.isScreenOn());,"Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.",style nit: we don't use braces around single line blocks
"public void resetAllResponses() { for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) { questionResponseBundle.putIfAbsent(question, new ArrayList<>()); } }","emmmm i dont feel this replacement is necessary...and it might change what the code intends to do, as put will replace the value corresponding to the question even if the question is already associated with a value, but putIfAbsent only associate question with the new ArrayList<>() if the question is not associated to anything.","If init is only used here, can make it private.",So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.,Perhaps you could extract questions.get(response.feedbackQuestionId) into a variable to make more readable,Probably we can be consistent with the use of this. here?,Sanitize the text here instead? Can also consider using sanitizeForSaving() if you would like to keep the sanitation process in the build() method.,"@unyoungwax, oops missed this, but consider prefixing this boolean with <code>is...</code>","The things is that fqDB will fetch the question again and update the attribute. If we can just set the serialised JSON by question.setQuestionText(attr.questionMetaData);, why we need fqDB?",Consider extracting this for loop into a separate method.,"it seems to me that if I add some operations, and then clear, the end results is to clear the map and after that apply the same operations, which would not get me the expected results. I.e.: map.put() map.clear() should give me the same result as map.clear() Shouldn't this clear() method also need a ""currentState.clear(); "" ? This would affect also the isEmpty() calculation.","Should the signature for the buildQuestionTableAndResponseRows(question, responses, """") call here just eliminate the """" in the parameter and place it in the method body? It's only being called in one place (here) and it's already defaulting to null and true for the participantIdentifier and isShowingResponseRows. Likewise for buildQuestionTableWithoutResponseRows()."
"protected URLConnection getExternalGraphic(AjaxRequestTarget target, Form<?> form) { onlineResource.processInput(); if (onlineResource.getModelObject() != null) { URL url = null; try { String baseUrl = baseURL(form); String external = onlineResource.getModelObject().toString(); URI uri = new URI( external ); if( uri.isAbsolute() ){ url = uri.toURL(); if( !external.startsWith(baseUrl)){ form.warn( ""Recommend use of styles directory at ""+baseUrl); } } else { url = new URL( baseUrl + ""styles/""+external ); } URLConnection conn = url.openConnection(); if(""text/html"".equals(conn.getContentType())){ form.error(""Unable to access url""); return null; } return conn; } catch (FileNotFoundException notFound ){ form.error( ""Unable to access ""+url); } catch (Exception e) { e.printStackTrace(); form.error( ""Recommend use of styles directory at ""+e); } } return null; }",This logic changes a bit due to <LINK_0>,throw IllegalStateException() is a better way to handle this than return null. _IF_ UTF_8 disappears for some reason the stack trace and exception will be easier to find and debug than an NPE in the caller.,"Why throw Error instead of Exception or RuntimeException ? Error is generally discouraged unless you also own the catching the Error and then only for framework level code as a last resort to prevent crashing the JVM. Also, any specific reason to log AND throw, usually the thing catching has the responsibility to log as to avoid duplicated logs.",It seems to me like the removal of the slash has no effect because its dealt with here no?,What happens to relative links? Protocol-relative URLs? Tests don't cover those.,"Needs to be updated to Configuration.LIBRARIES_DOWNLOAD + ""/JPushBullet""","""notation"".equals(resource.getURI().fileExtension()) to avoid potential NPEs.","Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?","1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.",Could we have this as a shorthand in BootstrapContext as getReourceProvider(),Can we keep such code as static method?
private void loadButtonAction(ActionEvent e) { progressDialog = new ProgressDialog(list.getParent()); if (dbpath == SELECT_OPTION) { File dir = selectDirectory(); if (dir == null) { return; } } dbload.restart(); },"If dir is not to be used anywhere, you might as well do if (selectDirectory() == null)","Are we sure we want a double click, when everything else in the UI works with a single click?",should this be a constant as it is used below as well.,Where is this exception caught?,change to file.toPath(),Seems like this should be above the log statement,You can avoid showing the dialog by not calling the superclass implementation here. So no more checking in SettingsFragment ;),Is it really necessary to pass the AlertType to OpenDialog?,Should the user be notified that the database could not be deleted by means of an ExceptionDialog?,Can be declared later.,this looks like something that would belong in a finally block
"public Single<String> getP18ForItem(String entityId) { return depictsInterface.getLabelForEntity(entityId) .map(response -> { String name; try { JsonObject claims = response.getAsJsonObject(""claims"").getAsJsonObject(); JsonObject P18 = claims.get(""P18"").getAsJsonArray().get(0).getAsJsonObject(); JsonObject mainsnak = P18.get(""mainsnak"").getAsJsonObject(); JsonObject datavalue = mainsnak.get(""datavalue"").getAsJsonObject(); JsonPrimitive value = datavalue.get(""value"").getAsJsonPrimitive(); name = value.toString(); name = name.substring(1, name.length() - 1); } catch (Exception e) { name=""""; } if (!name.isEmpty()){ return getImageUrl(name); } else return ""No Image for Depiction""; }) .singleOrError(); }",Java convention for a variable says it should be p18 lowercase.,Please define concrete classes instead of using JsonObject. I guess I have already added some of these classes in my PR #3449. I will base my PR on structured-data branch and you could reuse it.,From what I see this call may happen when Jenkins instance is null and when the jobs are not fully loaded. It would be better to handle this cases explicitly,"You should never use the displayName to find i18n message, the message keys are always defined using the *name* and never the *displayName* that is supposed to be i18n already.",Please move this method just below getClaims(),I think this check if not necessary and next check device for null be enough .,"it would make sense to define a new variable for stack.getTagCompound() (let's say ""tag"") to shorten the code and make it more readable.",can be inlined into a single line by using Streams,"The value computation is a bit complex, so please set a variable (String value = ...) then use that value in put(""label"", value);. Also, please add an example of depictedItem.get(""label"") and the resulting value. This will make code much more understandable. Thanks!",label should be externalized,If this is ever true a NullPointerException has already been thrown
public String getServerState() { this.officeServer.refreshState(); return contextualLocalizationManager.getTranslationPlain( TRANSLATION_KEY_SERVER_STATE_PREFIX + this.officeServer.getState().name().toLowerCase()); },Small detail: missing this.. See the line you replaced for ex.,This can / should probably be Locale.ROOT yeah?,@dalifreire why we can't use Locale.ENGLISH right here?,Wrong way round.,suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);,This constant should be in a key,The one-argument constructor can just be called here instead: this(true),"You should use toLowerCase(Locale.ROOT) as using using ""toLowerCase"" by itself will use the default locale (which may lowercase incorrectly depending on the language)","Maybe specify the names in the constructor (SKIP(""skip"")) so that someone modifying toString() by accident won't break the parsing.",I don't think we require a this. here for method calling. Also not from our code style?!,why doesn't this simply call getTranslation
public void visitToken(DetailAST token) { switch (token.getType()) { case TokenTypes.INTERFACE_DEF: checkServiceInterface(token); break; default: break; } },There is just one case here. We can replace this switch statement with if.,Shouldn't this be a switch?,I suspect this can result in violation message duplication in a case like Foo<? extends Foo>. Please add this case as an input.,"java // Method name Map<String, Method> methods = Arrays.stream(serviceInterface.getMethods()) .filter(method -> method.isAnnotationPresent(ServiceMethod.class)) .collect(Collectors.toMap(method -> { ServiceMethod methodAnnotation = method.getAnnotation(ServiceMethod.class); return resolveMethodName(method, methodAnnotation); }, Function.identity()));",@pbludov @romani Any reasons why these shouldn't be default?,"All tokens with blocks should be here:  TokenTypes.ANNOTATION_ARRAY_INIT, TokenTypes.ANNOTATION_DEF, TokenTypes.ARRAY_INIT, TokenTypes.CASE_GROUP, TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF, TokenTypes.ENUM_CONSTANT_DEF, TokenTypes.ENUM_DEF, TokenTypes.INSTANCE_INIT, TokenTypes.INTERFACE_DEF, TokenTypes.LAMBDA, TokenTypes.LITERAL_CASE, TokenTypes.LITERAL_CATCH, TokenTypes.LITERAL_DEFAULT, TokenTypes.LITERAL_DO, TokenTypes.LITERAL_ELSE, TokenTypes.LITERAL_FINALLY, TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_IF, TokenTypes.LITERAL_NEW, TokenTypes.LITERAL_SWITCH, TokenTypes.LITERAL_SYNCHRONIZED, TokenTypes.LITERAL_TRY, TokenTypes.LITERAL_WHILE, TokenTypes.METHOD_DEF, TokenTypes.SLIST, TokenTypes.STATIC_INIT,","I would add pre-emptive checks on these constructor and method_def checks that: java if (hasServiceClientAnnotation) { // then do the check. Otherwise, you're doing the check on classes that aren't serviceclients. }","If we have TYPE_UPPER_BOUNDS, then don't we need TYPE_LOWER_BOUNDS here too?","might be a good look to have this line break remove, like ""Spec: %s."", methodName, JAVA_SPEC_LINK));",I think we have to add the token DO_WHILE. WHILE = while (true) { } DO_WHILE =  do { // this is DO while (true); // this is DO_WHILE  It could have been overlooked if external users though WHILE and DO_WHILE were the same token. @romani Do you agree?,why public?
public DeCoupleMBusDeviceCommandExecutor() { super(MbusChannelElementsDto.class); },The class passed on to the super constructor shouldn't be MbusChannelElementsDto. I think the cleanest would be to pass DecoupleMbusDto.class (and make DecoupleMbusDto implement ActionRequestDto).,define a local variable for ED,hope it will works here as well for this class,Why calling the super() constructor over here? Remove statement.,getSelectedPattern().getCommand() ?,"Nit: return ""newBranch""; is simpler, no need for ""break""s or ""String mc"" then.",return getParameters().isUseCinderCommandCallback() ? new ConcurrentChildCommandsExecutionCallback() : new SerialChildCommandsExecutionCallback();,remove this string,Is it ECDSA or EDCSA?,"This and other setters don't have to be public, could be private.",Please catch the MethodResultCode and check on MethodResultCode.SUCCESS. Log when the resultCode != MethodResultCode.SUCCESS Perhaps a nonsuccessful MethodResultCode should lead to a failed operation.
"public ServerWebSocketInitializer(final ServerInfo serverInfo) { LOG.info(""Currently time out time is not used "" + serverInfo.getTimeOut()); this.serverInfo = serverInfo; connectionServer = createServerSocket(); manager = createConnectionManager(getServerInfo()); }","Colon after ""used""",Setting the type to ConnectionInfo should eliminate this cast.,"Please change: - Capitalize beginning of sentence. - Remove jedis. This is a generic class (Pool<T>) and T may or may not be Jedis. suggestion logger.warn(""Could not initialize minimum number of idle resources"", e);","This won't log the error. We want to use the public void error(String msg, Throwable t); overload, so we need to change e.getMessage() -> e","We can also remove this.server.connectionList == null because it is not relevant anymore (also, it can never be null)","Do we need this? The java doc for ""yield"" says, its rarely appropriate and used for testing or debugging.",Was this inspired from kafka ?,Should also change this to isInfoEnabled.,implement equals and hashcode,space before {,Exception needs no placeholder in the message. Remove the ': {}'.
"public ArrayList<OncoTreeNode> getOncoTree(Version version) throws TopBraidException { ArrayList<OncoTreeNode> list = new ArrayList<OncoTreeNode>(super.query(String.format(query, version.getGraphURI()), new ParameterizedTypeReference<List<OncoTreeNode>>(){})); return list; }","I guess getOncoTree() returns List<OncoTreeNode> and we must return ArrayList<OncoTreeNode> ? Still, we don't really need to create a named variable here .. we could do: return new ArrayList<OncoTreeNode>(super.query ....",No need for super,"xPaths and xPath are so similar they're confusing, maybe rename the list to xpathsForNode",I think this decode method needs to be in the try / catch.,"The argument order should be assertEquals(expected, actual).","we have our own Assert class, please us that",ImmutableList,use Stream,"don't write to std out. use LOG.warn/error/info/debug, as appropriate. Also, do we want to return empty string in the case that there's a TransformerException? Or should the exception be propagated?",only this filter needs to be changed. No need to have the whole block inside if,![MAJOR](<LINK_1> Make this line start at column 9. [![rule](<LINK_2>](<LINK_0>
"public void doSample() { sendData(pm.isScreenOn()?""on"":""off""); }","@orhan89 while you're add it, could you do a API version check and use isInteractive() if available?<LINK_0>","Same for this line, the new MusicPlayer is not being stored. Singleton, or do something else in case you need multiple (for FX for example)",Lets not create a the local variable and just: sendScreenState(pm.isScreenOn());,why * 1000 ?,We need a return here - we don't want to call handleBackPressed() when the photo picker is showing.,"Removing this will break the functionality. Suppose a song was playing and you receive a call, now due to focus loss the song will be paused. But as soon as the call ends, the song must resume playing. This will not happen if we remove this line.",can you undo this?,camera should be released even if there is an Exception,Can those two code blocks not be simplified to one and then just passing streamType == AudioManager.STREAM_VOICE_CALL instead of true or false to play(...),Can these be split into separate tests?,Fails silently now
public Configuration setDefaults(Configuration defaults) { this.defaults = defaults; return this; },I suggest to check defaults != this before setting.,this.m_,Probably won't impact performance too much but we could technically use a single ConfigDef instance for the entire class instead of creating a new one every time this method is called.,"Hmmm... I think there might be some awkwardness here with trying to make PredicatedTransformer implement the Transformation interface. Could we replace every Transformation in the TransformationChain's [transformation list](<LINK_0> with a PredicatedTransformer and, if there are no predicates configured for a transform by the user, make the default behavior for the PredicatedTransformer class to blindly apply its transformation? This would solve a few problems: - No risk of users trying to actually use a PredicatedTransformer in a connector config, which they may try to do if we don't add logic to prevent it from being picked up during plugin path scanning on startup and logged as an SMT plugin - No need to implement methods that aren't used - One code path instead of two for application of transformations - More flexibility in instantiation and, possibly, the ability to encapsulate some of the ConfigDef generation logic in a separate class from ConnectorConfig (haven't looked into the specifics of this yet so may not actually be feasible or that elegant)",This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.,"Not sure, why not use @NotNull?",if this utils... I would have passed the calling class as parameter to get this defaults... so that you can have multiple... or better just pass InputStream...,Will this inject all instances of Task on the classpath?,"In general, not a good idea to pass a mutable map around. ImmutableMap.copOf()?",what Aaron said. This is not needed,one more method where it can take file location of properties would be good.
"public void refreshMetadata(String username) { if (mNosaraClient == null) { return; } if (!TextUtils.isEmpty(username)) { mUserName = username; if (getAnonID() != null) { mNosaraClient.trackAliasUser(mUserName, getAnonID()); clearAnonID(); } } else { mUserName = null; if (getAnonID() == null) { generateNewAnonID(); } } }",There is a problem here :cry: :disappointed: We need to change the library since trackaliasUser uses TracksClient.NosaraUserType.WPCOM (wpcom:user_id) internally. We should add another trackaliasUser method that takes the userType parameter....,Where does label is used here?,"Can we please remove  String[] uuidSplitted = uuid.split(""-""); StringBuilder builder = new StringBuilder(); for (String currentPart : uuidSplitted) { builder.append(currentPart); } uuid = builder.toString();  and use String uuid = UUID.randomUUID().toString(); as is (with the dashes inside the string) ? Just found out that an anonID can contain any character in it (limited to ASCII probably), so there is no need to replace all the dashes. This also make sure there will not be collision with the Android app. If you think that there is not enough entropy in UUID.randomUUID you can create your own version of it. @xyu for confirmation about anonID.",remove mRoles,"@jjl014 User id is optional, unlike client id and session id, which are required for user info",switch pls,"getDefaultTracker is called every time an event is reported. It is worth thinking about setting up the default tracker in a manner that doesn't require you to set the user id every time getDefaultTracker is called. Like if you setup that part of the tracker every time a new user logs in, you don't need to do it every time you call getDefaultTracker. That said, it might be a more complex implementation that isn't worth the effort. I'll leave it to you to decide.",remove finally {,"All these vars are used just once. Maybe just use the method call directly? i.e.  ""<LINK_0>"" + mUser.getAccountToken() + ....","As we discussed on the call, I think it'd be a good improvement to have this logic by itself in a helper method.  private void trackMagicLinkSignupIfNecessary() { if (AppPrefs.getShouldTrackMagicLinkSignup()) { AccountModel account = mAccountStore.getAccount(); if (!TextUtils.isEmpty(account.getUserName()) && !TextUtils.isEmpty(account.getEmail())) { mLoginAnalyticsListener.trackCreatedAccount(account.getUserName(), account.getEmail()); mLoginAnalyticsListener.trackSignupMagicLinkSucceeded(); AppPrefs.removeShouldTrackMagicLinkSignup(); } } }","I think we should use TextUtils.isEmpty() here, the @NonNull annotation doesn't prevent NPEs. Also we should AppLog it, just to make sure we won't miss it if this happen recurrently in the future due to bad input."
"private void removeHiddenInstructors(FeedbackQuestionAttributes question, List<FeedbackResponseAttributes> responses, Map<String, String> recipients, Set<String> hiddenInstructorEmails) { boolean noChangeRequired = hiddenInstructorEmails == null || hiddenInstructorEmails.isEmpty() || question.getRecipientType() != FeedbackParticipantType.INSTRUCTORS; if (noChangeRequired) { return; } for (String instructorEmail : hiddenInstructorEmails) { if (recipients.containsKey(instructorEmail)) { recipients.remove(instructorEmail); } Iterator<FeedbackResponseAttributes> iterResponse = responses.iterator(); while (iterResponse.hasNext()) { FeedbackResponseAttributes response = iterResponse.next(); if (response.recipientEmail.equals(instructorEmail)) { iterResponse.remove(); } } } }","@unyoungwax, oops missed this, but consider prefixing this boolean with <code>is...</code>",Can use new ArrayList<> here.,"For this condition, the block is too long. Try to reduce block length and nesting level by reversing the condition. e.g.  if (!hasResponseRateCheck) { return; }",Perhaps you could extract questions.get(response.feedbackQuestionId) into a variable to make more readable,Consider extracting explaining variable for this large condition,Introduce explaining variables?,Revert the changes here.,Not accurate. The last instructor who is visible and who is allowed to modify other instructors need not be the same person.,"If init is only used here, can make it private.",You can replace these clunky for loops with this:  //filter away current instructor instructors = instructors.stream().filter((instr) -> !instr.getEmail().equals(instructorToDeleteEmail)).collect (Collectors.toList()); //check for instructor with modify permission isAlternativeInstructorWithModifyInstructorPermissionPresent = instructors.stream().anyMatch(instr -> instr .isRegistered() && instr.isAllowedForPrivilege (Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR)); //check for instructor with visibility isAlternativeVisibleInstructorPresent = instructors.stream().anyMatch (InstructorAttributes::isDisplayedToStudents);,"emmmm i dont feel this replacement is necessary...and it might change what the code intends to do, as put will replace the value corresponding to the question even if the question is already associated with a value, but putIfAbsent only associate question with the new ArrayList<>() if the question is not associated to anything."
private void cancelUpload(int localMediaId) { if (mCurrentUpload != null && mCurrentUpload.getId() == localMediaId) { cancelCurrentUpload(); } for(Iterator<MediaModel> i = mQueue.iterator(); i.hasNext();) { MediaModel mediaModel = i.next(); if (mediaModel.getId() == localMediaId) { i.remove(); } } },nitpicking: would be nice to break from the loop here,"Isn't better to have a routine getMediaWithID that returns either the element or null. So we can just check for null, or check if the states are equals without 2 calls to get on mMediaList.",Please let's use getUploadQueue() here instead - as mQueue could be null and we're using it like this elsewhere in the Service code,We should return here like we do in the next == null check above - there's nothing for dispatchUploadAction to do (and it'll fix the 'site' might be null warning we're getting).,Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?,Creating a new empty Set and adding the correct media ids feels more natural to me than removing stuff from a copied array :). It's not a big deal we can keep this implementation.,"I know this isn't part of this PR, but we can drop the toLowerCase() here (and also the null check).",It's not necessary to box media.getLocalPostId() in a new Integer instance here.,Repository should be a dependency inject it in the constructor,contributionList can never be null,I think that returns previously medias is not necessary and init method either. We have to download simply all medias from drive folder and pass DriveRootFolderUid and ProgramUId in the download method of FileDownloader
"MergingUpdater(AbstractTripleStore database) { this.database = database; String property = System.getProperty(""outputDumps""); outputDumps = Boolean.TRUE.toString().equals(property); id = UUID.randomUUID().toString().replaceAll(""-"", """"); }","configuration should be injected, not read from system properties in the constructor.","This should be the resource uuid and not that of the parent, in this case the FulfillerDetails has no uuid property so this should possibly return null",Should this be additive instead of using one or the other? What happens if the user uses both dependencyExclusions and dependencyOverrides?,"I believe this isn't necessary. If the property wasn't set, an NPE would have been thrown already when the code attempts to call .toUpperCase(). This line and the next may be removed.","@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));",This should be done in a try-with-resources block to ensure the stream is closed.,"I saw the property names would be converted to lower cases, that means e.g. controller.upload.onlineToOfflineTimeout will become controller.upload.onlinetoofflinetimeout. Is that intentional?",":+1: This is a nice addition. However, I suggest an empty string if no value specified and it's not a boolean value, so the value isn't set to ""false"", and instead it catches the IllegalArgumentException below. suggestion value = Property.isValidBooleanPropertyKey(key) ? ""true"" : """";","Rather than adding this callback here, you could just override either of the propertyChanged methods and then update the PropertyWrapper class to not add this class to the SUBCLASSES_WITH_NO_CALLBACK map. This would be cleaner and probably result in less overall code.",Will this compile?,"Change the return type to String and use the following impl:  return System.setProperty(propertyName,propertyValue);"
protected org.spine3.server.storage.EventStorage createStorage(StorageFactory factory) { final RecordStorage<EventId> recordStorage = super.createStorage(factory); final org.spine3.server.storage.EventStorage storage = factory.createEventStorage(recordStorage); return storage; },Let's avoid FQNs as much as we can.,"I don't understand why you need this class. There is a builder, which provides the same features.",I think it's a bit cleaner to introduce a new test which verifies if filtering per Aggregate Type is performed instead of adjusting an existing one.,Can you extract a constant whilst we're at it?,Shall we rename the 2nd init? This is because both init are not doing the same thing.,Why you use InMemoryTopicRepository here?,Use the sagaType's class loader,How about just init()?,"Make a shortcut factory methods: createAdded() and createRemoved() , sort of. Not neccessarly with that names.",What do you think about Comparator.naturalOrder() instead of null ?,Not sure why we need this.. We don't refer to the instance methods anywhere else like this.
"public int getLength() { Widget widget = getWidget(); int childCount = 0; if (widget instanceof Composite) { childCount = ((Composite) widget).getChildren().length; if (widget instanceof CTabFolder) { for (CTabItem tabItem : ((CTabFolder) widget).getItems()) { if (tabItem.isDisposed()) { System.err.println(""CTabItem was disposed""); break; } else { childCount++; } } } } return childCount; }",The syserr should come out.,"Make private Disposable disposable = null and add a null check here, just to be sure.",These checks do not need to be performed.,and then move the invocation of CountNodes to here?,This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery,Looking at what debugInforForIndex (line 4966) does: shouldn't this be i? index is the number of items in the result.,I think you meant for (int j = i; j < widgetTable.length; j++) {,This is always true?,is it intended to be so?,"probably should be a syncExec, but I don't think it really matters (the runnable will surely execute before the postExpandNotify runnable, and notify() does a syncExec() at the end).","As above...again it would be better to just get the size off the model without creating another list. If you can go through the PR and apply this principle, that would be great. ""@"" me when you have made the changes and I will take another look. Thanks again for the PR as it will be a good API change for application developers."
"static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations( org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index) { expect(entity.getId()).andReturn(GUIDS[index]).anyTimes(); expect(entity.getvds_group_id()).andReturn(GUIDS[2]).anyTimes(); expect(entity.getvm_name()).andReturn(NAMES[index]).anyTimes(); expect(entity.getvm_description()).andReturn(DESCRIPTIONS[index]).anyTimes(); expect(entity.getnum_of_cpus()).andReturn(8).anyTimes(); expect(entity.getnum_of_sockets()).andReturn(2).anyTimes(); expect(entity.getusage_mem_percent()).andReturn(Integer.valueOf(20)).anyTimes(); expect(entity.getdisplay_type()).andReturn(DisplayType.vnc).anyTimes(); expect(entity.getdisplay_secure_port()).andReturn(5900).anyTimes(); expect(entity.getnum_of_monitors()).andReturn(2).anyTimes(); expect(entity.getvm_type()).andReturn(VmType.Server).anyTimes(); expect(entity.getrun_on_vds_name()).andReturn(NAMES[NAMES.length - 1]).anyTimes(); Map<String, DiskImage> diskImageMap = new HashMap<String, DiskImage>(); diskImageMap.put(""1"", new DiskImage()); expect(entity.getDiskMap()).andReturn(diskImageMap).anyTimes(); VmStatic vmStatic = new VmStatic(); vmStatic.setId(GUIDS[index]); vmStatic.setvm_name(NAMES[index]); expect(entity.getStaticData()).andReturn(vmStatic).anyTimes(); setUpStatisticalEntityExpectations(entity, statistics); return entity; }","this expectations relevant for your use-case only, no need for all tests to see them, please move them to your method which will extend expectations for setUpEntityExpectations()",use .value() instead of .name(),you already have setUriInfo() at line 202,can you replace with assertEquals?,s/any(Map.class)/anyMap()/,"Is there value in testing with more than one setting here? I agree this is the highest priority since it is the default, but the extremes of 0 and 9 are also worth checking.","why did you removed setUpGetCertuficateExpectations(1, 2); ?",You should use @Mock annotation for all these mocks and achieve cleaner code.,i'd create rpmversion in dedicated test rather than forcing all other tests defining it (!NULL check in mapper will do the trick for you),"I'd choose to stick code together that belongs together, so put the declaration of the Manufacturer object down to the place where it's actually needed.","this line should be replaced with: when(osRepository.getNetworkDevices(any(Integer.class), any(Version.class))).thenReturn(NETWORK_DEVICES);"
"public List<String> getDirectory() throws OwException { List<String> directory = new ArrayList<String>(); OwserverPacket requestPacket = new OwserverPacket(OwserverMessageType.DIR, ""/""); write(requestPacket); OwserverPacket returnPacket = null; do { try { returnPacket = read(false); } catch (OwException e) { logger.info(""getDirectory may have returned incomplete result: {}"", e.getMessage()); closeOnError(); return directory; } if (returnPacket.hasPayload()) { directory.add(returnPacket.getPayloadString()); } } while ((returnPacket.isPingPacket() || returnPacket.hasPayload())); if (!returnPacket.hasControlFlag(OwserverControlFlag.PERSISTENCE)) { logger.trace(""closing connection because persistence was denied""); close(); } connectionErrorCounter = 0; return directory; }",Is that a software issue? Then better do WARN and include the exception as a last param.,"Do you think adding some indentation in the message could visually help to understand the end of the list? suggestion String.join(""\n\t"", exceptions.stream().map(e -> e.getMessage()).collect(Collectors.toList()));",shouldn't this be retry < maxResent?,unnecessary return statement,Is calling verify() in After method a good practice? What if there's a test that doesn't need to verify all these mocks?,l10n,Should log properly and throw api exception?,nit: add braces around the modified one line block to follow formatting rules,we could use try-with-resource construct here,missing a failure assertion.,I'd rather throw here.
"public void start() throws Exception { synchronized (lock) { if (childrenCache != null) { return; } childrenCache = cacheFactory.make(curatorFramework, config.getContainerPath()); } ContainerCacheListener containerCacheListener = new ContainerCacheListener(); childrenCache.getListenable().addListener(containerCacheListener); try { childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT); } catch (Exception e) { synchronized (lock) { try { stop(); } catch (IOException e1) { log.error(e1, ""Exception when stopping InventoryManager that couldn't start.""); } } throw e; } while (!containerCacheListener.doneInitializing) { Thread.sleep(2000); log.info(""Waiting for PathChildrenCache to be completely loaded.""); } }",can we use a CountDownLatch.await(1 minute) here instead? that way not too many logs will be printed and also it wouldn't wait any more than necessary ?,"I think it might be nicer to register an anonymous inner class here instead of having this expose the PathChildrenCacheListener interface. Once someone gets one of these objects from the getter above, should they be able to register it with Curator?","there's a lot going on here, suggest guarding start/stop with a lock","Since unregister() already does the isPresent() check, I'd just unconditionally call it here.",log.error maybe,Can you elaborate on what behavior would be if RuntimeStartInterruptedException is caught here,"This change is not wrong. However, creating two synchronization blocks generally doesn't guarantee that the lock is yielded in between them. The JIT might even merge them together at run time. If something needs to happen in between the locks, then some other kind of mechanism has to be used to wait for it. So the change is not wrong, but it's not really right either. :)",:ant: Should use Throwable.addSuppressed on the others.,Won't this one override the one set if an exception is raised?,This call has the same try-catch-log inside. Can we apply the same approach to it?,This makes it possible for cacheManager to be null. References to cacheManager presume non-nullness.
"public void testDoubletonFlatbush() { List<Rectangle> items = new ArrayList<>(); Rectangle rect0 = new Rectangle(1, 1, 1, 1); items.add(rect0); Rectangle rect1 = new Rectangle(-1, -2, -1, -1); items.add(rect1); items.sort(RECTANGLE_COMPARATOR); Flatbush<Rectangle> rtree = new Flatbush<>(items.toArray(new Rectangle[] {})); List<Rectangle> allResults = findIntersections(rtree, EVERYTHING); allResults.sort(RECTANGLE_COMPARATOR); assertEquals(allResults, items); Rectangle hit0 = new Rectangle(1, 1, 2, 2); assertEquals(findIntersections(rtree, hit0), ImmutableList.of(rect0)); Rectangle hit1 = new Rectangle(-2, -2, -1, -2); assertEquals(findIntersections(rtree, hit1), ImmutableList.of(rect1)); Rectangle totalMiss = new Rectangle(10, 10, 12, 12); assertEquals(findIntersections(rtree, totalMiss), ImmutableList.of()); Rectangle marginalMiss = new Rectangle(0, 0, 0, 0); assertEquals(findIntersections(rtree, marginalMiss), ImmutableList.of()); }","use ImmutableList.of() and assertEqualsNoOrder  Rectangle rect0 = new Rectangle(1, 1, 1, 1); Rectangle rect1 = new Rectangle(-1, -2, -1, -1); List<Rectangle> items = ImmutableList.of(rect0, rect1); Flatbush<Rectangle> rtree = new Flatbush<>(items.toArray(new Rectangle[] {})); List<Rectangle> allResults = findIntersections(rtree, EVERYTHING); assertEqualsNoOrder(allResults.toArray(), items.toArray());  ditto testTwoLevelFlatbush","- use ImmutableList.of(...) - specify parameter for Flatbush: Flatbush<Rectangle> rtree = ... - inline hit and miss variables - ditto testSingletonFlatbushXY  List<Rectangle> items = ImmutableList.of(new Rectangle(0, 0, 1, 1)); Flatbush<Rectangle> rtree = new Flatbush<>(items.toArray(new Rectangle[] {})); assertEquals(findIntersections(rtree, EVERYTHING), items); // hit assertEquals(findIntersections(rtree, new Rectangle(1, 1, 2, 2)), items); // miss assertEquals(findIntersections(rtree, new Rectangle(-1, -1, -0.1, -0.1)).size(), 0);","use ImmutableList.of List<Rectangle> items = ImmutableList.of((new Rectangle(0, 10, 1, 11));","I'd inline these variables and compare a list with an empty list. This way, on failure, the error message will include the list and not just the size of it.  assertEquals(findIntersections(new Flatbush<>(new Rectangle[] {}), EVERYTHING), ImmutableList.of()); private static <T extends HasExtent> List<T> findIntersections(Flatbush<T> rtree, Rectangle rectangle) { List<T> results = new ArrayList<>(); rtree.findIntersections(rectangle, results::add); return results; }",numBuildRects -> numRectanges,"Comparators classes don't generally have to implement equals (i.e. is this comparator the same as this other comparator?), so this is effectively ""assertSame"" because it's probably relying on Object.equals(). I don't think it's particularly rigorous to test for equality by using the comparator so I can't think of something better and I'm happy enough if we just compare instances. So, I think we should probably assertSame where we're expecting the same instance returned to make it clear.",maybe shuffle and then sort,Use assertEquals,"In both this and the test above all changed values are expected to become 1, due to the highest diff being 100. Maybe we should test with some other value as well.","No need to assign, just getDifferanceMatrix(6, 6); [sic]. Then the supression isn't needed.",You can use assertTrue instead in all these assertions :)
public void onDeniedPendingLockNotification() { synchronized (ZKDistributedNonblockingLock.this) { _isLocked = false; _isPreempted = true; _isPending = false; ZKDistributedNonblockingLock.this.notify(); } },Looks like a lock can only be in one state at a time. I suggest merging these 2 booleans into an enum for the cleanness of the code and the logic.,"Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.",Is it ok to go from WAITING straight to RELEASED?,why don't u support reentrancy for local threads,"given we have only one thread locking reentrant lock, why we unlock only after nextFinish time ?","Should this also check for wakelock.isHeld(), since you are doing that before you call release() in acquireWakeLock?",This should probably be  previous.isRunning() || !previous.isCanceled(),Won't this change the state of the composite promise to AVAILABLE before all the sub-promises are AVAILABLE?,This doesn't seem like it wouldn't remove anything.,"The method implements synchronization via  lock API, the synchronized seems redundant.",Constructor can be package private.
"public void generateExperimentalCoordinates(Vector2d firstBondVector) throws CDKException { IMolecule original = molecule; IMolecule shallowCopy = molecule.getBuilder().newInstance(IMolecule.class,molecule); for (IAtom curAtom : shallowCopy.atoms()) { if (curAtom.getSymbol().equals(""H"")) { int bondsFromCurAtom=0; for (IBond bond : shallowCopy.bonds()) if(bond.contains (curAtom)) ++bondsFromCurAtom; if (bondsFromCurAtom < 2) { shallowCopy.removeAtomAndConnectedElectronContainers(curAtom); curAtom.setPoint2d(null); } } } molecule = shallowCopy; generateCoordinates(firstBondVector); double bondLength = GeometryTools.getBondLengthAverage(molecule); HydrogenPlacer hPlacer = new HydrogenPlacer(); molecule = original; hPlacer.placeHydrogens2D(molecule, bondLength); }",IAtomContainer.getConnectedBondsCount()? or IAtomContainer.getConnectedAtomsCount()? <LINK_0>,"I would suggest to just perceive the atom types, but not apply them to the molecule... then you do not have to clone() the IAtomContainer, making the whole calculation a lot faster.",I would tend to leave off the static class definition such that this would read IAtomContainer ac = makeAlphaPinene();. Thoughts?,"if performance is really that critical here, I would pull the call to size into the initializer so it isn't repeated.",Could you inverse the logic here? It's not good practice to leave empty if blocks... If I read that in 2 years time I would think someone forgot to add some code in the if block.,"Could you make this an assertEquals? Minor thing, but it makes the test reports nicer (on failures). Same below.","This is wrong, the test should now be **isotope.getMassNumber() == null**. It is valid to have an input like [12CH3]CO as different from CCO.",shouldn't this block (~ 1077-1100) be part of the getVariantAnnotation method above?,"If the general mutation is not specifically curated, it won't be returned to the relevant alteration list, which will cause the mismatch. For example: utils/match/variant?hugoSymbol=EGFR&variant=Gain-of-function Mutations&examples=Amplification It will return {""Amplification"": false}, which is wrong because Amplification is curated as Gain-of-function",Consider setting up the SMILES parser in the @BeforeClass ...,we don't need filter
"private String createBuildsStats(MemoryImprint memoryImprint, TaskListener listener, Map<String, String> parameters) { StringBuilder str = new StringBuilder(""""); final String rootUrl = hudson.getRootUrl(); String unsuccessfulMessage = null; Entry[] entries = memoryImprint.getEntries(); if (entries.length > 0) { str.append(""\n""); for (Entry entry : entries) { AbstractBuild build = entry.getBuild(); if (build != null) { GerritTrigger trigger = GerritTrigger.getTrigger(build.getProject()); Result res = build.getResult(); String customMessage = null; str.append(""\n\n""); if (trigger.getCustomUrl() == null || trigger.getCustomUrl().isEmpty()) { str.append(rootUrl).append(entry.getBuild().getUrl()); } else { str.append(expandParameters(trigger.getCustomUrl(), build, listener, parameters)); } str.append(MESSAGE_DELIMITER); if (res == Result.SUCCESS) { customMessage = trigger.getBuildSuccessfulMessage(); } else if (res == Result.FAILURE || res == Result.ABORTED) { customMessage = trigger.getBuildFailureMessage(); } else if (res == Result.UNSTABLE) { customMessage = trigger.getBuildUnstableMessage(); } else { customMessage = trigger.getBuildFailureMessage(); } if (customMessage == null || customMessage.equals("""")) { str.append(res.toString()); } else { str.append(customMessage); } if (res != Result.SUCCESS) { unsuccessfulMessage = entry.getUnsuccessfulMessage(); if (null != unsuccessfulMessage && !unsuccessfulMessage.isEmpty()) { logger.trace(""Using unsuccessful message from file.""); str.append("" <<<\n""); str.append(unsuccessfulMessage.trim()); str.append(""\n>>> ""); } } } } } else { logger.error(""I got a request to create build statistics, but no entries where found!""); } return str.toString(); }",you should use res.isWorseThan(Result.SUCCESS) instead. <LINK_0>,"Note that it will be returning it for Pipeline. ""In progress"" may help here","I know you moved this, but strange how the original author uses StringBuffer to make a String and still just uses + to put this all together. I might be wrong here, but this probably removes the benefits the StringBuffer gives.",nit: add braces around the modified one line block to follow formatting rules,Can we make an enum or consts for these result strings?,So is there still no way to solve this for a workflow? If so then the config page should reflect that.,"Declare in initializer outside the try block, and then the finally block need not check for null.",getBuild() can also be null if jobs have been triggered but not yet started. Even though you take care of potential null entries below it is safest if we can omit them all together in the source in case some other caller isn't that foreseeing.,lower this to debug or trace and you can fix around line 422 while you're at it ;),"I agree it is a bug fix. But since it is a bug fix that has nothing to do with what the commit message's rationale would explain, it needs to go into its own commit: <LINK_0>",![MAJOR](<LINK_1> Refactor this code to not nest more than 3 if/for/while/switch/try statements. [![rule](<LINK_2>](<LINK_0>
public void visitNode(Tree tree) { if (tree.is(Kind.METHOD) && isServletInit((MethodTree) tree)) { tree.accept(new AssignmentVisitor()); } else if (tree.is(Kind.VARIABLE)) { VariableTree variable = (VariableTree) tree; if (hasSemantic() && isOwnedByAServlet(variable) && !isStaticOrFinal(variable)) { issuableVariables.add(variable); } } },"checking for the semantic should be done before checking the type of the tree, as semantic is used to get the parameter type of the method.","Even if it would make sense that tree.parent() always return the same value, I believe it's safer to consider that it does not (to avoid tricky bugs).",extract identifier.symbol() into a dedicated variable in order to improve readability.,LOCK_METHODS.anyMatch((MethodInvocationTree) tree),"if the class has a constructor we ignore it, but non-static initializer aren't? I'm not sure with the criteria...",Please use a switch:  java switch (initializer.getNodeType()) { case CAST_EXPRESSION: initializer = ((CastExpression) initializer).getExpression(); break; case CLASS_INSTANCE_CREATION: ...,"JUnit4 also supports assertions with messages - unfortunately as first parameter, different to JUnit5 (e.g. <LINK_0> By relying on the exception type to be in position 0 and the executable in position 1, I'd argue it could come to FNs when a developer uses that JUnit4 assertion. Do we want to support that case as well?",TYPO !,Extract variableTree.symbol() instead of calling it 3 times.,I would make explicit tests for every kind (or switch) and have overloaded method for those. That will make classCast less likely to happen. Here there is a lot of implicit going on. Let's make thing explicit. checkIfUnknown(MethodInvocationTree ) checkIfUnknown(NewClasstree ),"By supporting only Tree.Kind.IDENTIFIER and not Tree.Kind.MEMBER_SELECT, you have the following FP:  class S3330 { play.mvc.Http.CookieBuilder xsfrToken10; Cookie xsfrToken() { this.xsfrToken10 = play.mvc.Http.Cookie.builder(""XSRF-TOKEN"", ""2""); this.xsfrToken10.withHttpOnly(false); // false-positive } }"
"public void shouldNotExpireChargesWhenAwaitingCaptureDelayIsLessThan48Hours() { String extChargeId1 = addCharge(CREATED, ""ref"", ZonedDateTime.now().minusMinutes(90), RandomIdGenerator.newId()); String extChargeId2 = addCharge(AWAITING_CAPTURE_REQUEST, ""ref"", ZonedDateTime.now().minusHours(48L).plusMinutes(1L), RandomIdGenerator.newId()); worldpayMockClient.mockCancelSuccess(); connectorRestApiClient .postChargeExpiryTask() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(""expiry-success"", is(1)) .body(""expiry-failed"", is(0)); connectorRestApiClient .withAccountId(accountId) .withChargeId(extChargeId1) .getCharge() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(JSON_CHARGE_KEY, is(extChargeId1)) .body(JSON_STATE_KEY, is(EXPIRED.toExternal().getStatus())); connectorRestApiClient .withAccountId(accountId) .withChargeId(extChargeId2) .getCharge() .statusCode(OK.getStatusCode()) .contentType(JSON) .body(JSON_CHARGE_KEY, is(extChargeId2)) .body(JSON_STATE_KEY, is(AWAITING_CAPTURE_REQUEST.toExternal().getStatus())); List<String> events1 = databaseTestHelper.getInternalEvents(extChargeId1); List<String> events2 = databaseTestHelper.getInternalEvents(extChargeId2); assertTrue(isEqualCollection(events1, asList(CREATED.getValue(), EXPIRED.getValue()))); assertTrue(isEqualCollection(events2, asList(AWAITING_CAPTURE_REQUEST.getValue()))); }",not sure what role this charge is playing in the test,this can be deleted as it is already asserted in the shouldBeAbleToRequestARefund_partialAmount test which is sufficient. no need to go overboard here.,Can we check that it also isn't an empty string?,can delete this as already asserted in shouldBeAbleToRefundTwoRequestsWhereAmountAvailableMatch.,don't think we need this assertion.,missing some assertions (verify()) here ?,these can be inlined,Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?,"Again, this should use an actual value and assert that the refund stores this value",Can we also add reverse_transfer ?,this can be deleted as it is already asserted in the shouldBeAbleToRequestARefund_partialAmount test which is sufficient. no need to go overboard here.
"public void updateSource(TaskSource sourceUpdate) { checkLockNotHeld(""Can not update sources while holding the driver lock""); checkArgument(sourceOperator.isPresent() && sourceOperator.get().getSourceId().equals(sourceUpdate.getPlanNodeId())); pendingTaskSourceUpdates.updateAndGet(current -> current == null ? sourceUpdate : current.update(sourceUpdate)); tryWithLock(() -> TRUE); }",Add a message to the checkArgument call.,"The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.",I think we need to commit before returning the execId as we are doing update before.,"from discussion below: can we use imperative statements here? I find this difficult to parse (I read the filter as a top-level thing that rejects versions that were unfriendly, when that's not the case).","I feel like there is a case here where there isn't an existing pipeline (via the save entrypoint), which should probably be legit from a stale checking perspective. I also suspect the submitted payload in that case would not have a last modified (unless that is magically set somewhere along the way with a default value).",nit: the same variable in processFor(Duration) is called blockedFuture.,:question: Am I missing something or the same result can be achieved with update -> existingMetacards.get(update.getId());?,"No need to use completeDriverBlockedFuture here, is there any? I think the intention is ""when sourceBlockedFuture completes, this particular new driverBlockedFuture should complete"", so you could just keep the new driverBlockedFuture on a variable and complete that, without taking any locks.","How about this instead? suggestion return (boolean) sourceStatusOptional .map(s -> s == Status.AVAILABLE) .orElseGet( () -> { LOGGER.debug(""Unknown source status for source id={}"", source.getId()); return false; });","Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!",I think this is a fix for the unbounded results map that you mentioned earlier. Can we split this fix into it its own review? Also s/cleanupTask/terminalState/
"protected int persistHydrant( FireHydrant indexToPersist, DataSchema schema, Interval interval, Map<String, Object> metadataElems ) { synchronized (indexToPersist) { if (indexToPersist.hasSwapped()) { log.info( ""DataSource[%s], Interval[%s], Hydrant[%s] already swapped. Ignoring request to persist."", schema.getDataSource(), interval, indexToPersist ); return 0; } log.info( ""DataSource[%s], Interval[%s], Metadata [%s] persisting Hydrant[%s]"", schema.getDataSource(), interval, metadataElems, indexToPersist ); try { int numRows = indexToPersist.getIndex().size(); final IndexSpec indexSpec = config.getIndexSpec(); indexToPersist.getIndex().getMetadata().putAll(metadataElems); final File persistedFile = indexMerger.persist( indexToPersist.getIndex(), interval, new File(computePersistDir(schema, interval), String.valueOf(indexToPersist.getCount())), indexSpec, config.getSegmentWriteOutMediumFactory() ); indexToPersist.swapSegment( new QueryableIndexSegment(indexIO.loadIndex(persistedFile), indexToPersist.getSegmentId()) ); return numRows; } catch (IOException e) { log.makeAlert(""dataSource[%s] -- incremental persist failed"", schema.getDataSource()) .addData(""interval"", interval) .addData(""count"", indexToPersist.getCount()) .emit(); throw new RuntimeException(e); } } }",Change doesn't belong to this PR,Change doesn't belong to this PR,Define at point of use.,"This will not be useful in the default configuration where maxPendingPersists = 0. It'll just print the warning every a persist is submitted, even if things are not actually being throttled. A better ""possibly throttled"" detection would need to check if a persist is running right before we submit a new one to the persistExecutor. That is racey but probably fine given that the check is only being used to emit a warning.","i think this condition moving us in the wrong direction and its a step that puts into the valley of assumptions based bugs even deeper then it was before. Just looking into what i can observe from this method signature and code around it its an accessor who should be able to create appropriate updater, based on correctly supplier accessor factory","IMO, return (int) Math.min(size, Integer.MAX_VALUE); looks better (as you did above)","Do double-check locking instead, to improve performance and reduce contention here.",Let's keep things reactive and functional and return either Observable<Void> or (preferably) Completable instead of void.,I don't understand why this copy is necessary? Couldn't you just do an index (rather than iterator) based iteration of preJcaSync?,I am not quite following the relation between updating 0 rows and concurrent update? Shouldn't the ConcurrentUpdateException be thrown in queryExecutor.update(storable) method instead?,suggestion int preLive = getMapOfLiveData().size();
"private void doBuildProject(File projectLocation, IProgressMonitor monitor) throws CoreException { if (monitor.isCanceled()) { return; } try { monitor.beginTask(Messages.MSBuild_BuildProjectTask, 10); String msBuild = getMSBuildPath(); if (msBuild != null) { File csprojFile = WPProjectUtils.getCsrojFile(projectLocation); Assert.isNotNull(csprojFile); StringBuilder cmdString = new StringBuilder(msBuild); cmdString.append("" ""); if (isRelease()) { cmdString.append(""/p:Configuration=Release ""); } cmdString.append(csprojFile.getAbsolutePath()); ExternalProcessUtility processUtility = new ExternalProcessUtility(); if (monitor.isCanceled()) { return; } monitor.worked(1); TextDetectingStreamListener listener = new TextDetectingStreamListener( ""Build succeeded.""); processUtility.execSync(cmdString.toString(), projectLocation, listener, listener, monitor, null, getLaunchConfiguration()); if (!listener.isTextDetected()) { throw new CoreException(new Status(IStatus.ERROR, WPCore.PLUGIN_ID, Messages.MSBuild_MSBuildError)); } } } finally { monitor.done(); } }",Needs quotes around the msbuild command,NIT: Overkill IMHO. Just add the <code>@Nonnull</code> annotation and forget about null params,Does the queue need to be locked here? I'm not sure what the protocol is around editing the queue. What happens if the queue item is cancelled after it is building?,May be you do not need another submonitor conversion here?,Why did we change this logic?,build.shouldSucceed();,"If you add another matcher with the same name failedWith, you could match against the CLIResultCode itself which might be more expressive.",Let's see if we can not hard code this,Breaks the behavior for <code> MatrixRun</code>s as far as I see,can be inserted to the if bellow (redundant if build is not captured),"The general pattern here is to just do workspace.runBuckBuild(""//com/example/backticks:example"").assertSuccess();"
"private void initializeServices() { logger().debug(""Initializing couchbase services on host: "" + enabledServices); final String services = enabledServices.stream().map(s -> { switch (s) { case KV: return ""kv""; case QUERY: return ""n1ql""; case INDEX: return ""index""; case SEARCH: return ""fts""; default: throw new IllegalStateException(""Unknown service!""); } }).collect(Collectors.joining("","")); Response response = doHttpRequest(MGMT_PORT, ""/node/controller/setupServices"", ""POST"", new FormBody.Builder() .add(""services"", services) .build(), false ); checkSuccessfulResponse(response, ""Could not enable couchbase services""); }","suggestion logger().debug(""Initializing couchbase services on host: {}"", enabledServices);",Maybe /druid/indexer/v1? (/mmx/ may look weird in open source),"for the sake of readability please refactor into it's own method ""fetchStateFromAutelis"" or alike",These two if blocks can be reduced to calls to a single method that takes the service name as argument.,log. warn,Can this happen ?,maybe more specific: serviceCannotOpen,Should that be a post or a put?,this isn't doing anything,"@kwart, me and @tezc reviewed these lines but we could not decide how we should configure it? You have removed cluster-name and cluster-pass from hazelcast client code base: <LINK_1> Application.java starts client with parameters from PCF service that are defined by member side via json file: <LINK_0> I think we should remove password from Application.java and above json file then configure client:  String clusterName = (String) credentials.get(""cluster_name""); List<String> members = (List<String>) credentials.get(""members""); clientConfig = new ClientConfig(); clientConfig.setClientName(clusterName);  Is this correct?","In the case of services being an empty list, the run command will be ""up -d "". _I know_ that for Docker Compose this is functionally identical and starts all services. However, just to be explicit in our code, could we perhaps do an if/else check around this, and only concatenate the services list onto ""up -d"" if necessary? I'm fine to have the up string duplicated in the code. You might also notice that I'm being a hypocrite about explicitness of code, when the original -d here is itself not very clear . If you wouldn't mind changing -d to --detach while you're editing the code, that would be another improvement."
"public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) { Optional<Object> customHttpHeadersObject = context.getData(AZURE_REQUEST_HTTP_HEADERS_KEY); if (customHttpHeadersObject.isPresent() && customHttpHeadersObject.get() instanceof HttpHeaders) { HttpHeaders customHttpHeaders = (HttpHeaders) customHttpHeadersObject.get(); for (HttpHeader httpHeader : customHttpHeaders) { if (!Objects.isNull(httpHeader.getName()) && !Objects.isNull(httpHeader.getValue())) { context.getHttpRequest().getHeaders().put(httpHeader.getName(), httpHeader.getValue()); } } } return next.process(); }",This could be replaced with java context.getData(AZURE_REQUEST_HTTP_HEADERS_KEY).ifPresent(headers -> { // for loop over headers });,Remove this.,"In camel there is ObjectHelper.notNull(type, name) that does pretty much the same thing.",will .toString() result in same as .getHeader(),headersBuilder ?,getBody()?,"if we do change this to store Headers directly, we can return Headers here too.",Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.,Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.,"minor, is it method scope for Visible For Testing? If not please change it to private.","This could just be .flatMap(response -> Mono.justOrEmpty(scrubETagHeader(response)). Also, do we need to have justOrEmpty as this shouldn't be able to be null."
"public ExpressionAnalysis( Map<NodeRef<Expression>, Type> expressionTypes, Map<NodeRef<Expression>, Type> expressionCoercions, Set<NodeRef<InPredicate>> subqueryInPredicates, Set<NodeRef<SubqueryExpression>> scalarSubqueries, Set<NodeRef<ExistsPredicate>> existsSubqueries, Map<NodeRef<Expression>, FieldId> columnReferences, Set<NodeRef<Expression>> typeOnlyCoercions, Set<NodeRef<QuantifiedComparisonExpression>> quantifiedComparisons, Map<NodeRef<Identifier>, LambdaArgumentDeclaration> lambdaArgumentReferences) { this.expressionTypes = new LinkedHashMap<>(requireNonNull(expressionTypes, ""expressionTypes is null"")); this.expressionCoercions = new LinkedHashMap<>(requireNonNull(expressionCoercions, ""expressionCoercions is null"")); this.typeOnlyCoercions = new LinkedHashSet<>(requireNonNull(typeOnlyCoercions, ""typeOnlyCoercions is null"")); this.columnReferences = new LinkedHashMap<>(requireNonNull(columnReferences, ""columnReferences is null"")); this.subqueryInPredicates = new LinkedHashSet<>(requireNonNull(subqueryInPredicates, ""subqueryInPredicates is null"")); this.scalarSubqueries = new LinkedHashSet<>(requireNonNull(scalarSubqueries, ""subqueryInPredicates is null"")); this.existsSubqueries = new LinkedHashSet<>(requireNonNull(existsSubqueries, ""existsSubqueries is null"")); this.quantifiedComparisons = new LinkedHashSet<>(requireNonNull(quantifiedComparisons, ""quantifiedComparisons is null"")); this.lambdaArgumentReferences = new LinkedHashMap<>(requireNonNull(lambdaArgumentReferences, ""lambdaArgumentReferences is null"")); }",wrap with unmodifiableSet in constructor and then just return field reference from get* methods.,new LinkedHashMap<>();,the formatting here is off a bit,now it became a checkArgument,is dropping the defensive copying here intentional? Why?,"Wait, why can't this just use SYMBOL_TYPES? I'm so confused...",nit: I still feel better to call it expressionTypes,Might be better to just extract this to a separate method,I don't think it makes sense to remove this until we've migrated all of the pruning cases -- the other pruning cases could cause this code to run.,"@wenleix may provide a better idea on this. In general, we may need to integrate this into ExpressionAnalyzer to avoid specialization before every getExpressionTypes",I think we should move this logic into [1] [1] <LINK_0>
"public FreeStyleProject newInstance(Branch branch) { FreeStyleProject job = new FreeStyleProject(getOwner(), branch.getEncodedName()); setBranch(job, branch); try { job.setQuietPeriod(0); } catch(IOException e) { e.printStackTrace(); } return job; }",For test stability we maintain the previous quiet period of 0. But live behavior will change.,Please delete the right project.,Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,Better to log instead of e.printStackTrace,you could use o.e.ease.Logger class to log error messages. Then we could get rid of the Activator which speeds up bundle loading. Only thing to keep is the bundle ID which you might put into an interface IBundleConstants or something similar,I wonder what we are saying with this error. Maybe this should be a fatal error - it's certainly pretty unlikely to happen. I think we should re-throw the exception (wrapped in some kind of RuntimeException) here so that rest-driver won't start.,should we add a more detailed log and set currentProductVersion to null,Should we create the connector and connectorUI like we do in AbstractRepositorySettingsPageTest?,"Should you check if there are some files you should still delete, in case this error happens?","pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures",Could do this without mocks by using a custom Project subclass that overrides scheduleBuild.
"public void init(final GlusterVolumeGeoRepCreateModel model) { super.init(model); model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() { @Override public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) { if(args.propertyName.equalsIgnoreCase(""RecommendationViolations"")) { getView().setSuggestedConfigViolations(model.getRecommendationViolations()); } else if (args.propertyName.equalsIgnoreCase(""QueryFailed"")) { getView().setFailureMessage(model.getQueryFailureMessage()); } } }); model.getSlaveUserName().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() { @Override public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) { String slaveUser = model.getSlaveUserName() .getEntity(); getView().setUserGroupVisibility(slaveUser != null && !slaveUser .equalsIgnoreCase(ConstantsManager.getInstance().getConstants().rootUser())); } }); }",You could do this in the model itself because userGroup is already represented in model. getSlaveUserGroupName().setIsChangeable() can be used to make the ui-editor to enable or disable.,ActionConfirmationText/ActionConfirmationMessage,use RoleNameComparer,You should rather directly go the way to Settings.getGcCredentials() (perhaps first checking with Settings.hasGcCredentials()) instead of this more complicated and harder to understand way through the preference.,This should be done in the model,Is this something that could actually happen?,Why not to use our ConfgirmationDialog class?,Why is this required? It should bind automatically,"I can't tell whether this preference is user-facing or not. If not, presumably it should be ""Internal.DefaultCloseAction""; if so, ""Default Close Action""?",the console user ID is *not* specific for VM. in case where you have RECONNECT on one VM but not on other you get a false answer. The check should be VM specific.,Is testing on a message instead of testing on instance a good idea?
"public Scheduler cleanupResponseUrlDataScheduler() throws SchedulerException { return this.constructScheduler(ResponseDataCleanupJob.class, KEY_CLEANUP_JOB_THREAD_COUNT, KEY_CLEANUP_JOB_CRON_EXPRESSION, this.getDatabaseUrl(), this.databaseUsername, this.databasePassword, this.databaseDriver); }",My guess is that ResponseUrlDataCleanupJob.class should be used here in stead of ResponseDataCleanupJob.class?,"Extract the building of the Scheduler to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the scheduler.",Variable please?,requireNonNull,Will this inject all instances of Task on the classpath?,access modifiers?,"We try to keep the list of registrations alphabetical here for readability, so it would be consistent to move this and the ActiveEntitlementJob above it to the start of the order.","This constructor can just invoke this(new JdbcTemplate(dataSource), lookupStrategy)","don't need this. None of them have it above, stay consistent.",Wouldn't be easier to write it with lambda syntax () -> ... ?,"Ah just one more (and sorry for nagging) but it may be better to call scheduleACronJob as the very last statement of initialize, to make sure that we do not register a not-yet-initialized object"
"public void generateType(final Ds3Type typeEntry) throws IOException { final Template typeTemplate = config.getTemplate(""TypeEnumConstant.tmplt""); final Type type = TypeConverter.toType(typeEntry); final Path outputPath = getTypeOutputPath(type); final OutputStream outStream = fileUtils.getOutputFile(outputPath); final Writer writer = new OutputStreamWriter(outStream); try { typeTemplate.process(type, writer); } catch (final NullPointerException e) { LOG.error(""Encountered NullPointerException while processing template "" + typeTemplate.getName(), e); e.printStackTrace(); } catch (final TemplateException e) { LOG.error(""Encountered TemplateException while processing template "" + typeTemplate.getName(), e); e.printStackTrace(); } }","Since you are appending the exception in the logging statement, you do not have to then print the stack trace. This will actually result in the stack being printing twice, depending on how the logger is configured.",It looks like these two exceptions can be combined into one. I don't believe that you need to call out the specific exception since it will print the stack trace for the exception.,This should not call log.error(t). It should return ExceptionUtil.getStrackTrace(t);,"Maybe we can phrase that a bit diffrent: ""expected OutputType, but found %s type"" ?",please create a more specific exception that extends this one.,"why is that better than the code of the standard PrintWriter class? Also, if there is a reason to circumvent the double checked locking in there, wouldn't you at least want to use this.lineSeparator instead of a hardcoded \n","Nitpick: ""filename:"" and ""type:"" rather than ""filename"" and ""type""",typo in DATAPAAKCAGE,Looks like you wanted to use append here.,There's FloatWritable and DoubleWritable. Make sure to cover both cases.,You should be using parameterized logging for everything here.
"private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if (!desiredColumns.isEmpty()) { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }",return before instantiating the map?,get a linkedHashMap (like for the event table),I presume this means we are out of pages..,"The field name list is a bit confusing now, since this isn't a List any more. I'm not massively concerned about this because the method is concise and so it is clear what is going on, but it might be better named existingAttachments or attachments.",Why is this needed here?,"Not super important: maybe iterate by only the ID set here, and retrieve both the RF2 row and the component with a {rowsToImport,existingComponents}.get(componentId) call for symmetry?",constraint can also have column_name right?,why a change here?,why synchronized?,hostsPerTable.get might be null if beginCreateTable but finishInsert didn't. There is a race condition here I think,topology id isn't needed.
"public String toString() { return ""KubernetesCloud '"" + name + ""' serverUrl :"" + serverUrl; }","more of a personal taste question, but why don't you like Guava MoreObjects ?",NIT: could have been replaced with String.format?,Add final keyword.,Does not match conventional toString implementation.,"I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?",I propose we have accessors getBaseUrl() getRelativeUrl getAbsoluteUrl(). The toString() should call getAbsoluteUrl because that is the most complete representation of the object.,It would be better to use java.net.URL class for constructing URLs.,"If you want to take the benefit of stringbuilder, you should write sbuilder.append(kmer.toString()).append(' ').append(et.toString()). Otherwise, it is the same as string cat.",Does not match conventional toString implementation.,nit: Intellij recommends using setProperty() instead of put(). I guess it's because the parameter type is more strict.,"I'm not sure if this makes any difference in terms of efficiency and temporary strings, but how about  java ret.append(s); ret.append("","");"
"public int getOptimalTileWidth() { FormatTools.assertId(currentId, true, 1); RandomAccessInputStream plane = getPlane(getSeries(), 0); if (plane == null) return super.getOptimalTileWidth(); try { TiffParser tp = new TiffParser(plane); IFD ifd = tp.getFirstIFD(); return (int) ifd.getTileWidth(); } catch (FormatException e) { LOGGER.debug(""Could not retrieve tile width"", e); } catch (IOException e) { LOGGER.debug(""Could not retrieve tile width"", e); } finally { try { plane.close(); } catch (IOException e2) { LOGGER.debug(""Could not close stream"", e2); } } return super.getOptimalTileWidth(); }","You can use RAIS plane2 = plane here, e.g.:  import java.io.Closeable; class C implements Closeable { public void close() { System.out.println(""closed""); } } public class M { public static void main(String[] args) { C c = new C(); try (C c2 = c) { System.out.println(""done""); } } }","Wow, nice WTF catch there. :+1:","It might be clearer to make a new method that accepts usePercentage e.g. median(Collection<Float> phaseValues, boolean usePercentage). That would avoid some duplicate code here too.",same about exception and doc Also resources might never be closed,"As reported by Travis, the method is now void so the boolean initializationSuccess = should be removed.","Any chance-even if remote-that rowsPerStrip could be zero? One of the reasons why 1.0-alpha1 took so long (couple years after the work started?) was largely due to CVE's created for sanselan. One of the CVE, if I am not mistaken, was about a division by zero (or another sort of arithmetic error?), that caused an exception and some infinite loop or large memory allocation (allowing users to perform DDOS). If it's never zero, then no need to worry. Otherwise, if there's any risk, better set a quick validation somewhere (here or constructor).",serialized.getInput(),Can replace with [Iterators#size](<LINK_0>,What's the significance of the .2 magic number? Could this be a symbolic constant?,This underscore should also be a dash,I think the underscore should be a dash
"public void createOrLoadKey() { String keyLocation = env.getProperty(""keyLocation""); if (rsaJsonWebKey == null) { try { loadSavedKey(keyLocation); } catch (ClassNotFoundException | IOException e1) { logger.error(""Key not found or error loading key. Creating new key. "", e1); try { RsaKeyUtil keyUtil = new RsaKeyUtil(); KeyPair keyPair; keyPair = keyUtil.generateKeyPair(2048); rsaJsonWebKey = (RsaJsonWebKey) PublicJsonWebKey.Factory.newPublicJwk(keyPair.getPublic()); rsaJsonWebKey.setPrivateKey(keyPair.getPrivate()); saveKey(keyLocation); } catch (JoseException e) { logger.error(""Error creating key: "", e1); throw new RuntimeException(e); } } } }",2048 looks like a magic number,"Very small suggestion: I believe this could be simplified to ""String keyUseString = keyUse == null ? DEFAULT_PUBLIC_KEY_USE : keyUse.toString();""",Should this not be String.valueOf(k) here?,Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));,IllegalArgumentException is possible here. I see it is not handled.,Use double try block to make logic simplier.  java try { InputStream is = new FileInputStream(keyStore); try { ... } finally { Closeables.closeQuietly(is); } } catch (...) { },"Can we declare global final variable for ""JKS"" and refer in code?",This line ^ seems to be repeated. This one says 'JKS' but a later one says 'PKCS12'. What is the correct one?,"suggestion assertKeyPair(file, null);",Should throw an exception and not fail silently.,once you have the other constructors for exceptions in pace you do not need to pass null parameters anymore
"public synchronized void onJobArrival(final JobEntity jobEntity) { final int numResourcesToUse = jobEntity.getNumWorkers() + jobEntity.getNumServers(); if (numAvailableResources >= numResourcesToUse) { LOG.log(Level.INFO, ""Start job {0} with {1} resources. Remaining free resources: {2}"", new Object[]{jobEntity.getJobId(), numAvailableResources, numAvailableResources - numResourcesToUse}); numAvailableResources -= numResourcesToUse; jobServerDriverFuture.get().executeJob(jobEntity); } else { LOG.log(Level.INFO, ""Put job {0} into queue"", jobEntity.getJobId()); jobWaitingQueue.add(jobEntity); } }","this code block (if in L54-L59) can be encapsulated into a method to avoid duplicate in onJobFinished(), something like boolean tryExecute() that returns whether the job execution was successful","It would be helpful to add a brief description, for example:  break// FIFO; jobs in the queue must wait until necessary resources become available","It's a bast practice to have unlock in ""finally"" block to ensure unlocking in case of exception in the preceding code.","The synchronization is probably not needed here unless member variable ""jobs"" is being modified concurrently. In that case you want to have synchronization everywhere ""jobs"" is accessed (both read and modified) (for ex - complete() ). It would be also good to add a @GuardedBy(""this"") annotation for ""jobs"".","We don't need to check the delayedRequestsQueue here, because a resource-request for anything in the delayedRequestsQueue will be sent out only when the requests are no-longer delayed. The implication of this is that if requestsQueue is empty and delayedRequestsQueue is not, the CPM will continue to hold onto allocated resources, in the worst case for a period of 5 mins (default). Aggregated over num_containers, could be significant especially in resource-crunch scenarios. Alternatively, we could release the resource only looking at the requestsQueue, and when a request in the delayedRequestsQueue ""expires"", we will send out the request to the YARN-RM and allocation flow shall resume.",Map#computeIfAbsent() could be used instead to make code a bit shorter,If the observer is null why bother doing anything? There doesn't appear to be any way to change it from being null as the constructor is the only modifier so why not short circuit all the other logic and just return.,![BLOCKER](<LINK_0> 'Severity: BLOCKER') Refactor this method to not always return the same value. [![rule](<LINK_2>](<LINK_1>,"This had nothing to do with this PR and it makes the code smaller, but unreadable. It takes a few minutes to understand whereas the previous code was straightforward to understand. Can you please revert this method? Also I am not 100% sure it does the same as before...",I feel the variable names are a bit confusing. I'd like to rename them: numWorkersToSync -> numWorkers (or numExistingWorkers/numRunningWorkers) numWorkersToRelease -> numWorkersPrev (may differ according to the previous one) How does it sound?,"nittier nit: blank line needed between the methods here (this would also break baseline checkstyle, but atlasdb-client isn't - yet - baseline-enabled)"
"AuthenticatingHttpConnector(final String user, final Optional<AgentProxy> agentProxyOpt, final Optional<Path> clientCertificatePath, final Optional<Path> clientKeyPath, final EndpointIterator endpointIterator, final DefaultHttpConnector delegate, final List<Identity> identities) { if (clientCertificatePath.isPresent() ^ clientKeyPath.isPresent()) { throw new IllegalArgumentException( ""both or neither of clientCertificatePath and clientKeyPath must be specified""); } this.user = user; this.agentProxy = agentProxyOpt; this.clientCertificatePath = clientCertificatePath; this.clientKeyPath = clientKeyPath; this.endpointIterator = endpointIterator; this.delegate = delegate; this.identities = identities; }",u fancy,It is better to catch the MalformedURLException and wrap it with IllegalArgumentException with a custom message and attach the MalformedURLException as a cause.,I would suggest to create a separate method in X509Util to create the CN part.,I found your code a bit complicated: isn't it this line only we should change to take the first supported authentication methods?,"Minor: have you considered introducing a simple copy method or perhaps implementing Cloneable? (But of course, the above code is a thing of beauty.)","Maybe I missed something but could we implement this like that ? java if (certificateTypes == null return setIdentity(privateKey, certificateChain, null) else return setIdentity(privateKey, certificateChain, Arrays.asList(certificateTypes))","Should this perhaps return null on error or something? Otherwise, the following resolver = ... line could be partially initialized which doesn't sound right to me. Or should it use the default configurator like in line 658?","wow, is this what the object actually looks like?","Chain length is not a safe way to determine if the certificate in the chain is self-signed. The chain could be incomplete (it might depend on certificates that are in the truststore, without including those certificates), and chains might contain certificates that are not part of the chain at all (and are unused). You should find a better way to identify ""self-signed""",This change isn't required either?,do else if because it all operations on certPath
"public Set<List<JavaFileScannerContext.Location>> flow(List<Integer> parameterIndices, List<Class<? extends Constraint>> domains) { Preconditions.checkArgument(!parameterIndices.isEmpty(), ""computing flow on empty symbolic value list should never happen""); if(node == null || behavior == null) { return Collections.emptySet(); } String key = parameterIndices.stream().sorted().map(Object::toString).reduce("""", String::concat); String domainKey = domains.stream().map(Class::getName).sorted().reduce("""", String::concat); Map<String, Set<List<JavaFileScannerContext.Location>>> flowByDomain = cachedFlows.computeIfAbsent(key, k -> new HashMap<>()); return flowByDomain.computeIfAbsent(domainKey, k -> FlowComputation.flow(node, getSymbolicValues(parameterIndices), c -> true, c -> false, domains, node.programState.getLastEvaluated())); }","I'm not sure about that generating the key like this will be unique: from how I see it, if we call the method with [1,2], we will end up with the same key (""12"") as asking for the 12th parameter with the list [12]. (I know this is pretty unlikely, but still...)",Don't change the declaration,This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.,why not directly constraints.domains().count() == 1 ?,I think we should close the **StringReader**s.,Why not simply returning a map here ? value->constraint ? this would avoid to create a new object (thus a new concept).,This one should also probably not have an extended visibility but rather be reimplemented.,what's the purpose of this filter?,"ConstraintStreamScoreDirectorFactory.getConstraints is non-public API. We avoid defensive copies in non-public API, unless it's a probably-one-day-public-API, to avoid performance surprises and to reduce the code size. Note that even though the array is defensively copied, the constraint instances are not. So it's not watertight. This method will never be part of a public API I'd argue.","Since you can do validation on the input record at the beginning, you could probably be able to avoid using try/catch, just by using somethinglike: if !valid() {<discard code>} else {<business code>}",The underlying value is not orderable in this case. One may still argue that a predictable order is beneficial. But this is likely not a good idea. You do not want to give user an expectation on things you may not be able to deliver. Sorting things by their string representation has this downside of appears to be working but breaks at surprising times.
"public synchronized void handleMessageLayoutPrepare( @NonNull CorfuPayloadMsg<LayoutPrepareRequest> msg, ChannelHandlerContext ctx, @NonNull IServerRouter r) { if (!isBootstrapped(msg, ctx, r)) { return; } final long msgEpoch = msg.getPayload().getEpoch(); final long serverEpoch = getServerEpoch(); final Rank prepareRank = new Rank(msg.getPayload().getRank(), msg.getClientID()); final Rank phase1Rank = getPhase1Rank(msgEpoch); if (msgEpoch != serverEpoch) { r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.WRONG_EPOCH, serverEpoch)); log.trace(""handleMessageLayoutPrepare: Incoming message with wrong epoch, got {}, "" + ""expected {}, message was: {}"", msg.getPayload().getEpoch(), serverEpoch, msg); return; } Layout proposedLayout = getProposedLayout(msgEpoch); if (phase1Rank != null && prepareRank.lessThanEqualTo(phase1Rank)) { log.debug(""handleMessageLayoutPrepare: Rejected phase 1 prepare of rank={}, "" + ""phase1Rank={}"", prepareRank, phase1Rank); r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_REJECT.payloadMsg(new LayoutPrepareResponse(phase1Rank.getRank(), proposedLayout))); } else { Rank highestProposedRank = proposedLayout == null ? new Rank(-1L, msg.getClientID()) : getPhase2Rank(msgEpoch); setPhase1Rank(prepareRank, msgEpoch); log.debug(""handleMessageLayoutPrepare: New phase 1 rank={}"", getPhase1Rank(msgEpoch)); r.sendResponse(ctx, msg, CorfuMsgType.LAYOUT_PREPARE_ACK.payloadMsg(new LayoutPrepareResponse(highestProposedRank.getRank(), proposedLayout))); } }","Are these checks really necessary ? Its possible that this condition is false, at the time of the check, but becomes true immediately after the evaluation.",can you please make -1 a constant and give it a name,"I think the original name commitLayout is more descriptive, could you change it back?",Consider a constant symbol for -1 to indicate an error value.,Why did you remove the final qualifier?,![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>,please add curly braces,"I think this hooks up the delagate as the transformer, bypassing RetransmissionRequesterImpl#reverseTransform()",DEBUG log for null ??,"Please invert the ""if"" condition","Is there a reason, the patch set 5's '<' got replaced by a '!='? I liked the '<' better, as it exposed the correspondence to the condition on line 84. Well ... although '<' is more robust, I actually do not care whether it's '<', or '!='. But I'd prefer to either use '<' in both cases or '!=' in both cases."
"public void setSpeed(Double degreesPerSecond) { if (maxSpeed != -1 && degreesPerSecond > maxSpeed) { speed = maxSpeed; log.info(""Trying to set speed to a value greater than max speed""); } this.speed = degreesPerSecond; for (String controller : controllers) { ServiceInterface si = Runtime.getService(controller); if (si.isLocal()) { ((ServoController) Runtime.getService(controller)).servoSetVelocity(this); } else { send(controller, ""servoSetVelocity"", this); } } broadcastState(); }",I think we need to maintain the backwards compatibility for the old skewl setSpeed . our new proper method is setVelocity which takes a double that specifies the angular velocity of the servo that we will try to achieve.,velocity not speed.,SpeedController not CustomSpeedController,what if this isn't true?,"are there any cases in which the motor doesn't set, but it doesn't error?",SpeedController not CustomSpeedController,out of scope,SpeedController not CustomSpeedController,You can simplify this by reordering the states.,Probably better to have this at DEBUG level for final release.,SpeedController not CustomSpeedController
"private String getMemberName(String topic) { String[] topicElements = getTopicElements(topic); if (topicElements.length != 5) throw new IllegalArgumentException(""Event creation failed, invalid topic: "" + topic); return topicElements[5]; }","Shouldn't a check for ""lower then"" not be sufficient?",Log and throw is considered to be anti-pattern: <LINK_0>,If it can be null please mark the getter @Nullable,"Do we still need to pass in the topicsMap, as we are no longer looping it?","We should not use Java assert statement but proper unit testing asserts, ie, assertThat(e.getMessage(), equalTo(""...""));",This is a debug statement I suppose - since it will always fail the test?,"this.name = Objects.requireNonNull(name, ""name can't be null""); ? Also, I believe topicConfig should not be null either -- can we add a check (also for the existing constructor above?",We should extend existing addInternalTopic instead of having two method.,"format(""%s [offset %d, kafka_topic %s, partition %d]"", message, offset, topic.name().asString(), partition); WDYT?","No exception should be caught, so its trown by the runtime","logger.info(""Skipping creation of topic {} on brokers, topic already exists"", topic.getQualifiedName())"
"private int countOccurrencesInTopology(final String topologyString, final String searchPattern) { final Matcher matcher = Pattern.compile(searchPattern).matcher(topologyString); final List<String> repartitionTopicsFound = new ArrayList<>(); while (matcher.find()) { repartitionTopicsFound.add(matcher.group()); } return repartitionTopicsFound.size(); }","likewise, this one can be static",Please make it matcher.end() > bestEnd. Looks more readable this way,this.,I would recommend dropping size var and just calling timeStamps.size() ... this way do not have to keep this thing correct... for example should set this to zero when calling clear,I believe this should be zero,Could you prepend ^ and append $ to pattern to achieve the same whole-string match?,do we want to make these abstract?,Why change the access of all list methods to private?,does not need to be public in non-public class,Delete and pass on m.,why array?
"public void run() { if (StringUtils.isNotBlank(id)) { boolean hasParent; if (vocabularyAndHasParent.get(name) == null) { String dirSchema = directoryService.getDirectorySchema(name); Schema schema = schemaManager.getSchema(dirSchema); hasParent = schema.hasField(""parent""); vocabularyAndHasParent.put(name, hasParent); } else { hasParent = vocabularyAndHasParent.get(name); } Session directorySession = directoryService.open(name); if (!directorySession.hasEntry(id)) { Map<String, Object> entry = new HashMap<>(); entry.put(""id"", id); if (StringUtils.isEmpty(label)) { label = id; } entry.put(""label"", label); if (hasParent) { entry.put(""parent"", parent); } entry.put(""obsolete"", obsolete); entry.put(""ordering"", ordering); directorySession.createEntry(entry); } directorySession.close(); } }",can just do if (StringUtils.isBlank(id)) { return; } to reduce nesting level,alreadyExist -> alreadyExists,just return this,"suggestion String.format(""Entry with id %s already exists in directory '%s'"", id, directory.getName()));","You can't directly compare refs, imagine one is an IdRef and the other a PathRef...","Could you rename (e, s) to (k, v) for clarity? Off the top of my head I cant see what e and s mean.","exists would be a more grammatically correct name. I don't have any problem understanding you, but the codebase should stay as readable as possible.","Ok now that I reread the final code I think we can keep the old name getChildrenIds, as the new method with the ""exclude"" args is distinct enough. Sorry about changing my mind several times. Also applies to other getAll* methods we renamed...",Why not call the constant (and value) REPOSITORY_NAME?,Maybe give a limit == 1 to doQuery as we just interested in the first element.,StringUtils.isNotBlank(parentDirectoryName)
"private EntitySpec<? extends Entity> build(Topology topology, String node, Set<String> visited) { final Map<String, NodeTemplate> nodeTemplates = topology.getNodeTemplates(); final NodeTemplate nodeTemplate = nodeTemplates.get(node); visited.add(node); EntitySpec<?> spec = createSpec(node, nodeTemplate, topology); LOG.info(""applying spec modifiers {}"", specModifiers); for (EntitySpecModifier builder : specModifiers) { builder.apply(spec, nodeTemplate, topology); } for (String child : children.get(node)) { if (!visited.contains(child)) { final EntitySpec<? extends Entity> childSpec = build(topology, child, visited); spec.child(childSpec) .configure(SoftwareProcess.CHILDREN_STARTABLE_MODE, SoftwareProcess.ChildStartableMode.BACKGROUND_LATE); } } return spec; }","This is debug at best, probably trace, and should include the spec/nodeTemplate in question. One to tweak subsequently.",Is mutability required?,"It might be best to extract this into a helper method and call directly when addProcessor() is called. That way the corresponding stack trace is easier to map to the actually call to addProcessor() that passed in incorrect supplier? Similarly, we should add this check to KStreamImpl#process() and others","Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow",Is it possible to use [equalsIgnoreCase](<LINK_0>,"Don't modify the spec object retrieved from the config. Instead copy it. Otherwise this can modify the default value of MEMBER_SPEC, or of inherited config that might be shared by multiple instances.","don't write to std out. use LOG.warn/error/info/debug, as appropriate. Also, do we want to return empty string in the case that there's a TransformerException? Or should the exception be propagated?",- what about the table? - move .build() to separate line,I'm curious about the design choice that requires a new object to be instantiated for every basic operation. This seems potentially inefficient if these operations have to be performed many times.,this can be made private,If Java 8 is allowed: nodes.forEach(n -> n.includeProperties(allProperties));
"public static ReviewCompareAnnotationSupport getAnnotationSupport(Viewer contentViewer) { ReviewCompareAnnotationSupport support = (ReviewCompareAnnotationSupport) contentViewer.getData(KEY_ANNOTAION_SUPPORT); if (support == null) { if (support == null) { support = new ReviewCompareAnnotationSupport(contentViewer); contentViewer.setData(KEY_ANNOTAION_SUPPORT, support); } } return support; }",Making *really* sure it's null? ;),Would it be better to use the view argument here instead? AS is complaining about a potential NPE here. suggestion setupContent((ViewGroup) view);,"You cannot presume this, as it is IMO fine that the user adds the size change listener via the data view before setting the data provider <LINK_0>",I have a silly question. What are these methods used for?,Shouldn't we exit here?,a null check should be added if this can be null,I get a warning here about the cast from Object.,"We can take benefit of the super call in this case to populate the event object instead of applying the properties other than contentDescription ourselves. Following code would be better as compared to the code above: java super.onInitializeAccessibilityEvent(event); if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) { final Map<String, CharSequence> map = new HashMap<>(); map.put(""rating"", String.valueOf((int) getRating())); map.put(""num_of_stars"", String.valueOf(getNumStars())); event.setContentDescription(ResourceUtil.getFormattedString(getResources(), R.string.rating_bar_selection, map)); }","Since this section is being shared between this method and the setAuthorAttributionText() method, it might make sense to create a local private utility method to do it, that would be invoked from both of these methods.",can you assert that is not null?,This should also be changed to unit instanceof DiscussionBlockModel. Ref <LINK_0>
"private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) { if (arrayOrListType.getClass().isArray()) { return arrayOrListType.getClass().getComponentType(); } if (isList(arrayOrListType)) { ParameterizedType pt = (ParameterizedType) arrayOrListType; return pt.getActualTypeArguments()[0]; } throw logger.logExceptionAsError(new RuntimeException(""Should not be there"")); }",Can we add an actual exception message if we ever run into this issue in production.,Can you leave this method as-is and create a new method to strip wildcards?,&& should be replaced with ||,"Should this check Collection as that is the super type for List and will capture Set, Queue, etc.","This is using the regular Java reflection API, you need to use the [Libgdx reflection API](<LINK_1>, otherwise you will break the GWT backend. I already did [this](<LINK_0> in the serialization branch, you can just copy it.",This is easier to read as: return type.getClass().isArray() || isList(type);,"You could use ReflectionUtils#getTypeClass(Type), I had forgotten about this method.",Shouldn't this be called isAssignableFrom? There is also Clazz.class.isInstance(obj),I think it should be: tType = ((ParameterizedType) tType).getActualTypeArguments()[cDept] BTW: In a separate branch I'm working on strategic solution to compare generic types. Will refactor this code to use the common feature.,Partition[].class ?,"How about ""Type is not supported""?"
"private ThriftType convertEnumTypeField(Class enumClass, String fieldName){ List<ThriftType.EnumValue> enumValues = new ArrayList<ThriftType.EnumValue>(); String enumName = enumClass.getName(); try { List enumCollection = getEnumList(enumName); for (Object enumObj : enumCollection) { ScroogeEnumDesc enumDesc = ScroogeEnumDesc.fromEnum(enumObj); enumValues.add(new ThriftType.EnumValue(enumDesc.id, enumDesc.originalName)); } return new ThriftType.EnumType(enumValues); } catch (Exception e) { throw new ScroogeSchemaConversionException(""Can not convert enum field "" + fieldName, e); } }",are there Exceptions other than RuntimeExceptions?,I can't see a difference between the 2 codes. But either is OK to me.,This could be final,This will throw a null pointer exception if targetType is null.,Why public?,"why simply not call BaseBackendResource.validateEnum(Class<E> clz, String name)? (instead of EnumValidator.validateEnum(reason, detail, clz, name), this why we will not have to maintain localization in two places)","try prefix is used to distinguish this method from public toMessageClass(). I find it better than innerToMessageClass() or something. I use try prefix for such methods as Bob Martin does in his great book, Clean Code.",lower case?,remove.,Why degrading to raw type here?,It is recommended to use LogicalTypeUtils.isLogicalTimestampMillis()
"public static Map<String, DbmsType> all() { Map<String, DbmsType> types = new HashMap<>(); types.put(""ARRAY"", ARRAY); types.put(""BIGINT"", BIGINT); types.put(""BINARY"", BINARY); types.put(""BOOLEAN"", BOOLEAN); types.put(""CHARACTER"", CHARACTER); types.put(""DATE"", DATE); types.put(""DATETIME"", DATETIME); types.put(""DECIMAL"", DECIMAL); types.put(""DOUBLE"", DOUBLE); types.put(""DOUBLE PRECISION"", DOUBLE_PRECISION); types.put(""FLOAT"", FLOAT); types.put(""FLOAT4"", FLOAT4); types.put(""FLOAT8"", FLOAT8); types.put(""INT"", INT); types.put(""INTEGER"", INTEGER); types.put(""NUMBER"", NUMBER); types.put(""NUMERIC"", NUMERIC); types.put(""OBJECT"", OBJECT); types.put(""REAL"", REAL); types.put(""SMALLINT"", SMALLINT); types.put(""STRING"", STRING); types.put(""TEXT"", TEXT); types.put(""TIME"", TIME); types.put(""TIMESTAMP"", TIMESTAMP); types.put(""TIMESTAMP_LTZ"", TIMESTAMP_LTZ); types.put(""TIMESTAMP_NTZ"", TIMESTAMP_NTZ); types.put(""TIMESTAMP_TZ"", TIMESTAMP_TZ); types.put(""VARBINARY"", VARBINARY); types.put(""VARCHAR"", VARCHAR); types.put(""VARIANT"", VARIANT); return types; }",It generates the map everytime you call all() method ? Why this map is not in a static{...} bloc code ?,"In alignment with valueOf, perhaps name this valueOfType or fromType?",Why is a Double treated at a uint64_t? Shouldn't this be treated as a float instead?,static,Perhaps nameToDataType.,return Arrays.asList(....),Should be super( NativeTypeEnum.STRING );,"I would pull all of this logic into a private static function, and then instead of catching the exception, throw a runtime exception. This should not happen, and if it does it is a very bad condition that we want to fail for. So after you moved all of this into it's own static function, the constructor would look like  java public TypeMapper() { this.typeMapper = initTypeMapper(); }",The type should be canonized. So that we can compare it with object references.,Could use .get instead of .getOrDefault,this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?
"private void restoreState(Bundle savedInstanceState) { if (savedInstanceState == null) return; boolean isInMultiSelectMode = savedInstanceState.getBoolean(BUNDLE_IN_MULTI_SELECT_MODE); if (isInMultiSelectMode) { mGridAdapter.setInMultiSelect(true); if (savedInstanceState.containsKey(BUNDLE_SELECTED_STATES)) { ArrayList<Integer> selectedItems = ListUtils.fromIntArray(savedInstanceState.getIntArray(BUNDLE_SELECTED_STATES)); mGridAdapter.setSelectedItems(selectedItems); setFilterSpinnerVisible(mGridAdapter.getSelectedItems().size() == 0); mSwipeToRefreshHelper.setEnabled(false); } } mHasRetrievedAllMedia = savedInstanceState.getBoolean(BUNDLE_HAS_RETRIEVED_ALL_MEDIA, false); mFilter = Filter.getFilter(savedInstanceState.getInt(BUNDLE_FILTER)); mEmptyViewMessageType = EmptyViewMessageType.getEnumFromString(savedInstanceState. getString(BUNDLE_EMPTY_VIEW_MESSAGE)); mIsDateFilterSet = savedInstanceState.getBoolean(BUNDLE_DATE_FILTER_SET, false); mStartDay = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_DAY); mStartMonth = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_MONTH); mStartYear = savedInstanceState.getInt(BUNDLE_DATE_FILTER_START_YEAR); mEndDay = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_DAY); mEndMonth = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_MONTH); mEndYear = savedInstanceState.getInt(BUNDLE_DATE_FILTER_END_YEAR); boolean datePickerShowing = savedInstanceState.getBoolean(BUNDLE_DATE_FILTER_VISIBLE); if (datePickerShowing) showDatePicker(); }",This leaves ActivityLauncher.newGalleryPost() unused - I think we should probably clean that up too.,I think you should use notifyItemRemoved(i) here.,"Since we're invalidating the entire dataset in the adapter (a few lines below), which will cause all the views to be redrawn, do we really need to do this here?","This correctly cycles back through the pager when the Back button is pressed. However, when the first position is reached, the Back button has no effect (i.e. the dialog should close when Back is pressed). To handle the final Back case, you could add an else here and say the following: else { super.onBackPressed(); }",Could we use Objects.equals to avoid eventual NPE?,"again equals for string is enough, no need to compare identity aferwards.",I think this should be isNavigationViewSavedStateMissing() without the 'not'.,The fact that I was lazy doesn't obligate you to cover the entire class. Just covering the new behavior would be fine.,@nmirasch do we still need to do this? should be set already right?,"==true is redundant, try to avoid comparing any boolean to true :)",just not sure if we always want to refresh the grid when deselectall is executed.
"public ClusterFeature get() { Cluster cluster = parent.getClusterEntity(); SupportedAdditionalClusterFeature feature = cluster.getAddtionalFeaturesSupported() .stream() .filter(f -> f.getFeature().getId().equals(asGuid(id))) .findFirst() .orElseThrow(() -> new WebApplicationException(Response.Status.NOT_FOUND)); return ClusterFeaturesMapper.map(feature.getFeature(), null); }",This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.,This may look better in functional form,What if the result is null? Should we check it?,"TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>","As you only iterate over addlFeatures, checking for emptiness is not required.","The idea of the ""template"" parameter is that you can pass an object that you have already populated, maybe partially, so if it is not null we should use it instead of creating a new one: AdditionalFeature entity = template != null? template: new AdditionalFeature();","Same, create a new instance only if ""template"" is null.",missing matches()?,"Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)",missing matches()?,missing matches()?
public Iterator getLocations() { return ORDERING.sortedCopy(this.storageLocations).iterator(); },Please Specify the type properly here like Iterator<StorageLocation>.,Please address <LINK_0>,"to iterate over forks we should not use hadrcoded value Please, see reference approach in MkIssues",Use constants for 1 and 2.,locations are effectively immutable. Don't need to make a copy of it.,do not throw RuntimeException,"@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.",static import?,"This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value lio essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call this.unsubscribe() on L101.","nit: baseline requires a space here: ...Function) mapper); We may not enforce baseline compliance for atlasdb-commons, but we might as well avoid introducing new issues.",Why not make the Locator's updated timestamp in the same granularity as Cassandra's timestamp? I.e: make it miliseconds?
"public JarSet process() { JarSet newJars = new JarSet(); for (String p: syncProcessedPaths()) { synchronized (removedPaths) { removedPaths.add(new Path(p)); } project.getExtensionManager().pathRemoved(p); } boolean newRuntimeDetected = false; Set<String> processed = new HashSet<String>(); synchronized(this) { processed.addAll(processedPaths); } for (int i = 0; i < paths.size(); i++) { String p = paths.get(i); if(!requestForLoad(p)) continue; removedPaths.add(new Path(p)); String fileName = new File(p).getName(); if(EclipseResourceUtil.SYSTEM_JAR_SET.contains(fileName)) continue; XModelObject o = FileSystemsHelper.getLibs(model).getLibrary(p); if(o == null) continue; boolean nrd = project.getExtensionManager().setRuntimes(p, readRuntimes(o)); if(nrd) newRuntimeDetected = true; detectBeanModule(p, o, newJars); } for (FileAnyImpl s: servicesInSrc.keySet()) { IResource r = (IResource)s.getAdapter(IResource.class); if(r != null && r.exists()) { boolean nrd = project.getExtensionManager().setRuntimes(r.getFullPath().toString(), readRuntimesInService(s)); if(nrd) newRuntimeDetected = true; } } IJavaProject javaProject = EclipseResourceUtil.getJavaProject(project.getProject()); Set<String> recognizedRuntimes = CDIExtensionFactory.getInstance().getRecognizedRuntimes(javaProject); boolean nrd = project.getExtensionManager().setRuntimes(""_recognized_"", recognizedRuntimes); if(nrd) newRuntimeDetected = true; if(newRuntimeDetected) { for (String p: processed) { String fileName = new File(p).getName(); if(EclipseResourceUtil.SYSTEM_JAR_SET.contains(fileName)) continue; XModelObject o = FileSystemsHelper.getLibs(model).getLibrary(p); if(o != null) { detectBeanModule(p, o, newJars); } } } validateProjectDependencies(); return newJars; }","Let's move ""_recognized_"" to final static variable","Don't do this in the loop, but just once before the loop. Otherwise the monitor might ignore some work done.",Can we have a race condition here? I see we set the state to loaded but I don't see any other locks. Could we have multiple threads loading at the same time?,"This sould be retrieved from the plugin, not instantiated here. Only the plugin should instantiate this class (which should be called ModelDependencyProviderRegistry)","If running in a NLJ, union operation or other contexts they could be running in a different thread, we need a different way to identify RS vs Olap/Spark",If you want this iteration to be thread safe you need to hold the lock on updateJobs.,this 'instanceof' looks like a 'code smell' what about adding a isLocalSessionsEnabled method to the base class (SessionTracker) with a default return value of 'false' ?,"Are you sure this will prevent reordering, markLoaded is always called when the lock is already taken. I also believe that if it does prevent it, doing nothing on reader side will still be a problem since it is not synchronized in any way.",Could use a ConcurrentHashMap instead of synchronized map.,"So the issue here is with metrics. A call to reloadIfOutdated generates both cached_job_conditional_reload and cached_job_reload and the causality of failures (if you log 0s and 1s) in cached_job_reload is unknown because of this. Essentially, there are three flows: 1) Reload success/failure 2) Cached reload is necessary/unnecessary 3) Cached reload success/failure (via reload) Maybe a common uninstrumented helper method will disambiguate these with some improved metric names?",asList()?
public CoprocessorRpcChannel coprocessorService(ServerName serverName) { return null; },Should these throw UnsupportedExceptions?,Intentional?,Could this be private or at least package private?,"You can remove the last space. In addition, probably enough to show ioe.getMessage()",this feels like a brittle contract... having to call createChannels prior to calling getInputs or getOutputs,Returns Class<? extends ServerSocketChannel> instead.,why did you remove this ?,this.,make function synchronized. Res: done with syncronized block,May be nice to keep also the service factory as in spring boot we can pre-load the registry but on osgi/spring/xml custom stuffs you may just want put a jar and let camel resolve it as for other stuffs.,What if cancelOepration throws an exception?
public static String getGatewayAliasDefaultTo(String overrideAlias) { if (StringUtils.isNotBlank(overrideAlias)) { return overrideAlias; } String alias = System.getProperty(NhincConstants.CLIENT_KEY_ALIAS); return StringUtils.isBlank(alias) ? NhincConstants.DEFAULT_CLIENT_KEY_ALIAS : alias; },duplicate logic in getPrivateKeyAlias method().,@bgeVam please use isBlank,size can be provided as we iterate on registryPrefixes length,"what if my value is "" "" ? should use trim",Is there a config parameter to check as opposed to a null check? I think the former is a better design as the user will have to explicitly state whether he/she wants to enable SSL authentication and we'll perform checks based upon that as opposed to checking for null,"Can be simplified as: return Strings.isNullOrEmpty(valueInEnvironment)? getPropertyValue(properties, defaultValue, property) : valueInEnvironment;",I did not check what is the last argument we pass as null but It would be good to create overloaded methods if it is easy for easy readability...,Better not use e.getMessage(). Instead use a contextual message.,"Please use LOG.warn(""Unable to access property: {}"", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage) to reduce stack trace",Throw it; we want to fail fast rather than wait for auth failures talking to the far end.,"If some but not all of these are null, that would suggest an unintentional error condition. Perhaps it's worth failing loudly."
"public String toString() { return ""exceededCount="" + m_exceededCount + ""\nm_armed="" + m_armed; }","suggestion ""\narmed="" + m_armed;",So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?,Space before {,"Again, very minor, PAREN*",suggestion private void addMismatchReasonInternal(String reason) {,"why is this (and others) """"?","Why not String.format(""%s -> %s"", argument, result)?",return a single String,"You should probably spit out at least the class name otherwise ot won't be really helpful. As far as I remember, other classes to the same.","Code style: Even though the compiler would optimize this anyway, I'd prefer to have the pattern as a constant here.","""WindowED"" VS. ""WindowING"" . I have no preference except to pick one and use it consistently."
"private void updateFileCacheSizeLimit() { boolean isAvailableSpaceLowerThanHighLimit; if(mDiskCacheIsExternal){ isAvailableSpaceLowerThanHighLimit = mStatFsHelper.testLowDiskSpace( StatFsHelper.StorageType.EXTERNAL, mDefaultCacheSizeLimit - mCacheStats.getSize()); } else{ isAvailableSpaceLowerThanHighLimit = mStatFsHelper.testLowDiskSpace( StatFsHelper.StorageType.INTERNAL, mDefaultCacheSizeLimit - mCacheStats.getSize()); } if (isAvailableSpaceLowerThanHighLimit) { mCacheSizeLimit = mLowDiskSpaceCacheSizeLimit; } else { mCacheSizeLimit = mDefaultCacheSizeLimit; } }",No need for code duplication. We can do something like:  StorageType storageType = mStorage.isExternal() ? StatFsHelper.StorageType.EXTERNAL : StatFsHelper.StorageType.INTERNAL;,casting to int here is redundant now..,"How come this method is the same for calculating the storage capacity for both internal and external? Like, if I have a device with 16GB internal storage with a 64GB with an SD card, those are the different numbers that this method should return right?",might look a bit better if you extract it to a method (e.g. 'updateTitle'..),This should imho be implemented with an equals since you are comparing Strings and to make it null safe I would suggest: return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());,StorageType is an enum - it should be compared with ==,I'm ok with either capitalization. But it needs to be consistent. The overutilized 2 lines above is capitalized differently.,"This calc gets redone in many places. Can we create utility methods for padding in PackingUtils? Something like this maybe?  public static long increaseBy(long value, long percent);",Lets use kernal.rebalanceEnabled(rebalanceEnabled);,"I have some spider-sense that tingles here. If a user of this table claims twice without checking timeToResize, it will never resize. Putting in a >= or some assert might provide better safety for future devs.","This will override the properties of the disk we're adding. If you want to to override just for the sake of validation, you should clone the disk."
"BufferAndBacklog pollBuffer() { synchronized (buffers) { if (isBlocked) { return null; } Buffer buffer = null; if (buffers.isEmpty()) { flushRequested = false; } while (!buffers.isEmpty()) { BufferConsumer bufferConsumer = buffers.peek().getBufferConsumer(); buffer = bufferConsumer.build(); checkState(bufferConsumer.isFinished() || buffers.size() == 1 || (buffers.size() == 2 && buffers.peekLast().getBufferConsumer().getDataType() == Buffer.DataType.RECOVERY_COMPLETION), ""When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.""); if (buffers.size() == 1) { flushRequested = false; } if (bufferConsumer.isFinished()) { buffers.poll().getBufferConsumer().close(); decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer()); } if (buffer.readableBytes() > 0) { break; } buffer.recycleBuffer(); buffer = null; if (!bufferConsumer.isFinished()) { break; } } if (buffer == null) { return null; } if (buffer.getDataType().isBlockingUpstream()) { isBlocked = true; } updateStatistics(buffer); return new BufferAndBacklog( buffer, getBuffersInBacklog(), isDataAvailableUnsafe() ? getNextBufferTypeUnsafe() : Buffer.DataType.NONE, sequenceNumber++); } }",Why do we need that change here and not for aligned barriers?,"I guess the path of buffer == null was caused by duplicated notification for LocalInputChannel. If we already fixed the duplicated notification in this PR, can we remove this path for simple?","it would change the behavior of flushRequested here. The flushRequested is mainly used for judging the availability of partition called by upper component, so it should not be coupled with the condition of dataAvailableNotified. E.g. if flushRequested = false and buffers.size() == 1 and buffers.peek().isDataAvailable(), no matter with dataAvailableNotified is false or true, the new flushRequested should alway be true.",I think there is no point in adding explicit requireNonNull just before dereferencing it.,the above two lines can be replaced with: parent.notifyDecreaseBacklog(++buffersInBacklog);,the above two lines can be replaced with: parent.notifyDecreaseBacklog(--buffersInBacklog);,Why add synchornized section?,Lets change the default to GRACEFULLY,Should not call drain while in the synchronized block. It should look like this:  java if (done) { return; } boolean callOnOverflow = false; boolean callError = false; Deque<T> dq = deque; synchronized (dq) { if (dq.size() == bufferSize) { switch (strategy) { case DROP_LATEST: dq.pollLast(); dq.offer(t); callOnOverflow = true; break; case DROP_OLDEST: dq.poll(); dq.offer(t); callOnOverflow = true; break; default: // signal error callError = true; break; } } else { dq.offer(t); return; } } if (callOnOverflow) { if (onOverflow != null) { try { onOverflow.run(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); s.cancel(); onError(ex); } } } else if (callError) { s.cancel(); onError(new MissingBackpressureException()); } else { drain(); },"In case we pool a buffer, and say you wrote 300 bytes, on a place that previously had 4K filled you will fill it with 300 bytes... the buffer will be flipped, but when the libaio write takes place.. I'm afraid this could not cleanup the rest of the 4K. I did not run any tests on this.. just from what I remember on the pool mechanism. just make sure the previously pooled buffer wouldn't make to the journal.",I think it is unnecessary to use synchronized here
"public InMemoryMessageExchangeStore(final NetworkConfig config, TokenProvider tokenProvider) { if (config == null) { throw new NullPointerException(""Configuration must not be null""); } if (tokenProvider == null) { throw new NullPointerException(""TokenProvider must not be null""); } this.tokenProvider = tokenProvider; this.config = config; this.tokenLength = config.getInt(NetworkConfig.Keys.TOKEN_SIZE_LIMIT, MAX_TOKEN_LENGTH); LOGGER.log(Level.CONFIG, ""using tokens of {0} bytes in length"", tokenLength); }","Do we still need the token length here? It seems that the TokenProvider retrieves it from the config itself, doesn't it?","simply do a this(config, null) and handle the null case appropriately in the other constructor?",default token provider is maybe not used here.,else if maxBytesInMemory < 0?,queueLength should be >= 0 or change the createExecutor(ThreadFactory threadFactory) to create a SynchronousQueue if queueLength <= 0,"key.getBytes() will use some platform default charset. It's not good to rely on that, better to specify charset explicitly.","What do you think about using a telescoping constructor since one is a prefix of the other?  @Inject public LocalMemoryManager(NodeMemoryConfig config) { this(config, Runtime.getRuntime().maxMemory()); }","""...but was: %d:""?",This message appears to be a duplication of line 258 and doesn't match the range on line 275.,"This can be simplified with maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, ZOOKEEPER_MAX_CONNECTION_DEFAULT).",Try running in the gcstress mode?
"public ChangeInfo format(RevisionResource rsrc) throws OrmException { ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl()); Optional<PatchSet.Id> ps = Optional.of(rsrc.getPatchSet().getId()); return format(cd, ps); }","Why should format(RevisionResource) return a ChangeInfo and not (at the very least) a RevisionInfo? Though ideally it would return a Map<String, ActionInfo>","Optional: ""patch set""",NoSuchChangeException should be converted into ResourceNotFoundException so that the caller gets 404 Not Found instead of 500 Internal Server Error.,new OrmException(e),never thrown?,"Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open(); try { } finally { db.close(); } As then the Java compiler can promise us the value cannot be null at use sites, and its clear what the scope of the value is.",Index will build with stale data.,Unnecessary delta.,"Unneeded change. This only used in RegexPathPredicateTest, that is in the same package.",Don't throw.,This also should be doing the prefetch.
"private String putBlob(Router router, BlobProperties blobProperties, byte[] usermetadata, byte[] content, RouterOperationCallback<String> putBlobCallback) throws Exception { byte[] buf = new byte[content.length]; Utils.readBytesFromStream(new ByteArrayInputStream(content), buf, 0, content.length); ReadableStreamChannel blobDataChannel = new ByteBufferReadableStreamChannel(ByteBuffer.wrap(buf)); Future<String> putBlobFuture; if (putBlobCallback == null) { putBlobFuture = router.putBlob(blobProperties, usermetadata, blobDataChannel); } else { putBlobFuture = router.putBlob(blobProperties, usermetadata, blobDataChannel, putBlobCallback); if (!putBlobCallback.awaitCallback(1, TimeUnit.SECONDS)) { throw new IllegalStateException(""putBlob() timed out""); } else if (putBlobCallback.getException() != null) { verifyExceptionMatch(putBlobCallback, putBlobFuture); throw putBlobCallback.getException(); } assertTrue(""PutBlob: Future is not done but callback has been received"", putBlobFuture.isDone()); assertEquals(""PutBlob: Future BlobId and callback BlobId do not match"", putBlobFuture.get(), putBlobCallback.getResult()); } return putBlobFuture.get(); }","verifyExceptionMatch() blocks on future.get(), so isDone() will always be true when you're here, no? Also, if the callback was received, then we should ensure that future.get() returns immediately as well, so shouldn't it be a timed get within verifyExceptionMatch()?",why callback is null,incorrect.,"could you add routerMetrics as the second parameter, right after routerConfig? It makes sense to have the config and metrics together, and it is also consistent with pattern used elsewhere.",??? Looks like the implementation is also for GET?,incorrect.,"I would prefer passing a valid GetBlobOptions mandatory. The caller must know what type of operation it wants to make via the getBlob() call. Unlike the range (which is a bit fancy), it does not feel right for the router to assume the type.",this count may be unreliable because chunks of blobs that are deleted are also triggered with attemptChunkDeletes == false,"blobProperties != null could be removed, because it has been checked in all callers.",replace PutBlobOptionsBuilder().build() with PutBlobOptions.DEFAULT?,Should this channel instantiation be outside of the reactive stream? This is creating a new channel each time another item is emitted from the stream.
"public Patient createFHIRPatient(Patient patient) { List<String> errors = new ArrayList<String>(); org.openmrs.Patient omrsPatient = FHIRPatientUtil.generateOmrsPatient(patient, errors); if (!errors.isEmpty()) { StringBuilder errorMessage = new StringBuilder(""The request cannot be processed due to the following issues \n""); for (int i = 0; i < errors.size(); i++) { errorMessage.append((i + 1) + "" : "" + errors.get(i) + ""\n""); } throw new UnprocessableEntityException(errorMessage.toString()); } org.openmrs.api.PatientService patientService = Context.getPatientService(); omrsPatient = patientService.savePatient(omrsPatient); return FHIRPatientUtil.generatePatient(omrsPatient); }",This string should go into the messages.properties file.,We should use StaticUtils.collectionToString for this.,"java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?",shall we move these messages to constants?,"This is not semantically correct, the Location header should point to the location of the created resource, not to a different resource. Since multiple resources are created, it would be better to use null for the header, and instead put the list of locations in the response body.",This should be done once in the constructor instead of doing it every time getMessage() is called.,correct the commnet,"Hmm.... not too convinced by the error message - surely patient update fails for reasons other than there being no patient associated with a given UUID? this may be misleading... I suggest replacing it with something like ""Failed to update patient. The actual error message was "" + e.getMessage();","""The request cannot be processed due to the following issues""",StringBuilder or <LINK_0>,"I hope you do not kill me, but as this is infra component it is good to know the practices... you should not allow caller to modify collection. return Collections.unmodifiableList(errors);"
"private static void enforceTaskCountLimit(int size) { if (size > Limits.maxWorkflowTasks()) { throw new ConfigException(""Too many for_range subtasks. Limit: "" + Limits.maxWorkflowTasks()); } }",Showing size here would help users to understand what's wrong since it's likely users don't know an actual number of tasks with step.,"nit: drop ""this.""","this should be a ServiceException, since it'll be serialized as such.","We're abstracting accesses to _parallel property by moving related implementations to ParallelControl. Why don't you move this direct access to _parallel property to the class by adding like ParallelControl#copyIfNeeded(Config src, Config dst)?","prop: Since we assert that active and stand-by tasks are disjunct, we could avoid to compute the union here and just sum up the sizes of activeTasks and standbyTasks.",Should this logic be simplified? Can we just say something like:  if (enqueueQueryWhenTaskLimitExceeded) { resourceGroupManager.setTaskLimitExceeded(totalRunningTaskCount <= maxTotalRunningTaskCount); },"nittier nit: blank line needed between the methods here (this would also break baseline checkstyle, but atlasdb-client isn't - yet - baseline-enabled)",we should be able to use the time since the task entered the running state here,Should we also verify that the new values are >= zero?,"I found only one case (test) where metrics could be passed in a null. So, I would wonder if it would make sense to mock metrics in that test and to always assume/verify that we have metrics being passed in?",@gkatzioura can you please run benchmarks and compare latency and throughput of AtomicRateLimiter before and after your changes with various contention parameters?
"public void testAllCases() throws IOException { boolean crNewline = true; test("""", new String[]{}, 5); test(""1234\n"", new String[]{""1234"", ""\n""}, 10); test(""1234"", new String[]{""1234"", """"}, 10); test(""123\r\n123\r\nabc\n"", new String[]{""123"", ""\r\n"", ""123"", ""\r\n"", ""abc"", ""\n""}, 20); test(""123\r123\r\nabc\n"", new String[]{""123"", ""\r"", ""123"", ""\r\n"", ""abc"", ""\n""}, 20); test(""1234\r"", new String[]{""1234"", ""\r""}, 5); test(""1234\r\nabc\r\n"", new String[]{""1234"", ""\r\n"", ""abc"", ""\r\n""}, 5); test( ""123456"", new String[]{""123456"", """"}, 5); test( ""12345"", new String[]{""12345"", """"}, 5); test( ""1234\rA"", new String[]{""1234"", ""\r"", ""A"", """"}, 5); }","Can you repeat this same case with sizes 4 and 6 (buffer ending just before the carriage return, and just after the line feed)?",> /var/tmp $ xxd foo.properties 00000000: 0a The test case between the issue and here is different. InputNewlineAtEndOfFileNewlineAtEnd will have \n or \r\n depending on the OS. Does the issue still happen with this file even though the file is longer than 1 byte? We usually try to mimic the same file that is being reported to us to show the issue is fixed. Do we want to use a file that is the same line encoding on all OSes that is controlled through the .gitattributes file like InputNewlineAtEndOfFileLf?,"I don't think it adds real value to put these constants into the xxxColumnType variables, especially since they're only used once. It doesn't make the code more understandable or more elegant.","Add asserts for empty string, string of only ""\n"", and string of only ""\r\n""","if changed to: String testFirstCharWhitespace = "" ThisIsAReallyLongishWord toTest TheWordWrapperFunc""; String[] expectedResult = {""ThisIsAReallyLon"", ""gishWord toTest"", ""TheWordWrapperFu"", ""nc""}; it becomes clear how this function is supposed to work at one glance","It seems enough as follows.  java CodePoints cp2 = new CodePoints(""ABCD""); cp2 = null;  ->  java CodePoints cp2 = null;","It is wrong to return WRITE in this case since ""a"" itself doesn't change. Returning WRITE would affect Extract Function refactoring by forcing ""a"" to become an output parameter or a return value. Treating array expressions differently only makes sense for variable declared as arrays not as pointers, but the problem is that for most uses int x[4]; is almost the same as int* const x;","I think it's better to test that it fails if one of the columns names defined in the CsvInputFormat has a comma (i.e., error message: Column[%s] has a comma, it cannot). Otherwise, it's testing the same behavior as testColumnMissing().",You don't need to call both.,Feed Name -> Feed,We don't expect a ConfigCompileException here
"public void stop() { log.info(""Stopping task""); try { writer.closeQuietly(); } finally { try { dialect.close(); } finally { dialect = null; } } }",Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?,"Ditto here, if we have swallowed all possible exception inside close, then it is unnecessary to have another swallow here.",I think it would be better to remove the catch block just let the exception propagate (the method already declares to throw Exception) and put the dataSource.stop() call into the finally block of the try-finally statement.,shouldnt the delegate be closed or at least flushed?,How about a deleteQuietly function if this is frequently needed?,throw UncheckedIOException(e)?,:question: do you need to do line 187 (final SolrClient c = client;)?,the null check isn't needed when having the taskScheduler final an being set in the constructor.,this should be catch (Throwable t),"Same as above, do we want to invoke postTaskDestroy if there was an exception?",Why not static? (This can probably move to MySqlUtils anyway.)
"public void run() { SmppSession smppSession = smppClient.getSession(); if (smppSession != null && smppSession.isBound()) { try { smppSession.enquireLink(new EnquireLink(), enquireLinkTimeout); } catch (SmppTimeoutException | SmppChannelException | RecoverablePduException | UnrecoverablePduException error) { Log.warning(""Enquire link failed, executing reconnect: "" + error); smppClient.reconnect(); } catch (InterruptedException error) { Log.info(""Enquire link interrupted, probably killed by reconnecting""); } } else { Log.error(""Enquire link running while session is not connected""); } }",Exception can be included as a separate parameter.,"Message may be null, add a guard check",exception being null seems to be a legit case. Its way too hard to throw errors here. We do not use assert in ESH at all: Assertions need to be switched on during compilation what we don't do. Thus they will be removed from the resulting class files. And in this particular case it is hiding a NPE when exception actually _is_ null. Please review other occurrences and replace them by throwing IllegalArgumentException or IllegalStateException.,"change message to ""Socket threw an error, Socket: {} Error: {}""",even in logger.error String.format should be called implicitly,Why do you call interrupt() on a already interrupted thread here?,This should probably use Spring's TaskExecutor [1] support. [1] - <LINK_0>,"This should be a WARN or lower. spelling fix: ""occurred""","right now, the checkSessionExpiration is only called if sessionExpirationPercent > 0, we should also change that?",Exception needs no placeholder in the message. Remove the ': {}'.,"This is not ""error"" level. It should be at debug."
"protected void postProcessing(boolean closeEarly) { if (sortGraph) { if (ghStorage.isCHPossible() && isCHPrepared()) throw new IllegalArgumentException(""Sorting a prepared CHGraph is not possible yet. See #12""); GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage); GHUtility.sortDFS(ghStorage, newGraph); logger.info(""graph sorted ("" + getMemInfo() + "")""); ghStorage = newGraph; } if (!hasInterpolated() && hasElevation()) { interpolateBridgesAndOrTunnels(); } initLocationIndex(); importPublicTransit(); if (lmPreparationHandler.isEnabled()) lmPreparationHandler.createPreparations(ghStorage, locationIndex); loadOrPrepareLM(closeEarly); if (chPreparationHandler.isEnabled()) chPreparationHandler.createPreparations(ghStorage); if (isCHPrepared()) { for (CHProfile profile : chPreparationHandler.getCHProfiles()) { if (!getProfileHash(profile.getProfile()).isEmpty() && !getProfileHash(profile.getProfile()).equals("""" + profilesByName.get(profile.getProfile()).getVersion())) throw new IllegalArgumentException(""CH preparation of "" + profile.getProfile() + "" already exists in storage and doesn't match configuration""); } } else { prepareCH(closeEarly); } }",Why is isEmpty() treated special here? Why is it possible for the hash to be empty?,In both exceptions I would link to this issue #1922 to give more context.,I know this is a bit of taste: but I prefer to avoid nested if-else and here one could avoid the else as the if stops in every case.,You should never synchornized against a Long value - this is because JDK would cache the instance for value -127 to 128 when you call Long.valueOf.,How about using Platform.getPreferencesService().getBoolean() when it's just to read the preference?,Why not 10?,"In very early version we gave a hint how large the graph can get, but this is no longer really necessary. Can be removed in another issue ;)",nit: Please consider filing an issue. -> Please file an issue.,"upgrades are, dunno about the plural there. Perhaps upgrading is... just taking extra care since it's public surface. WDYT?","Sorry, already removed this :flushed:",@vilchik-elena do we need that line?
"private Long getFirstValidPrivateId(List<InstanceGroup> instanceGroups) { LOGGER.debug(""Get first valid PrivateId of instanceGroups""); long highest = instanceGroups.stream() .flatMap(ig -> ig.getAllInstanceMetaData().stream()) .filter(im -> im.getPrivateId() != null) .map(InstanceMetaData::getPrivateId) .max(Long::compare) .orElse(0L); LOGGER.debug(""Highest privateId: {}"", highest); return highest == 0 ? 0 : highest + 1; }",so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:  return highest.isPresent() ? highest.get() + 1 : 0;  also we might have a test for this method to be sure we don't break it in the future,Could use <= here,"value could be 0, as the default one. So other requirement could choose from positive range (to be executed sooner) or negative range (to be executed later) in comparison to default implementation.",Shouldn't we return the actual estimate?,checkOne can be used or is unused?,"if the column is not null in database, why we need this null check?","Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)",Same here. Does it need to be synchronized?,"Could there be value in adding a warning statement if we detect current being 1000ms less than last? That could indicate a clock drift, which might be worth logging (although we wouldn't want to spam it(.",I'm not convinced Optional will add value here.,Should this maybe return RecordStore.DEFAULT_TTL (-1 --> use MapConfig's default) instead of 0 (--> infinite max idle)?
"private void applyChanges(Sample target, Sample source) throws IOException { target.setDescription(source.getDescription()); target.setSampleType(source.getSampleType()); target.setReceivedDate(source.getReceivedDate()); target.setQcPassed(source.getQcPassed()); target.setScientificName(source.getScientificName()); target.setTaxonIdentifier(source.getTaxonIdentifier()); if (!target.getAlias().equals(source.getAlias()) && (!isDetailedSample(target) || (isDetailedSample(target) && !((SampleAdditionalInfo) target).hasNonStandardAlias()))) { validateAliasUniqueness(source.getAlias()); } target.setAlias(source.getAlias()); target.setDescription(source.getDescription()); target.setEmpty(source.isEmpty()); target.setVolume(source.getVolume()); if (!isStringBlankOrNull(source.getIdentificationBarcode())) { target.setIdentificationBarcode(source.getIdentificationBarcode()); } if (isDetailedSample(target)) { sampleAdditionalInfoService.applyChanges((SampleAdditionalInfo) target, (SampleAdditionalInfo) source); if (isIdentitySample(target)) { Identity iTarget = (Identity) target; Identity iSource = (Identity) source; iTarget.setInternalName(iSource.getInternalName()); iTarget.setExternalName(iSource.getExternalName()); } if (isTissueSample(target)) { sampleTissueService.applyChanges((SampleTissue) target, (SampleTissue) source); } if (isTissueProcessingSample(target)) { applyChanges((SampleTissueProcessing) target, (SampleTissueProcessing) source); } if (isAliquotSample(target)) { SampleAliquot saTarget = (SampleAliquot) target; SampleAliquot saSource = (SampleAliquot) source; saTarget.setSamplePurpose(saSource.getSamplePurpose()); } if (isStockSample(target)) { SampleStock ssTarget = (SampleStock) target; SampleStock ssSource = (SampleStock) source; ssTarget.setStrStatus(ssSource.getStrStatus()); ssTarget.setConcentration(ssSource.getConcentration()); ssTarget.setDNAseTreated(ssSource.getDNAseTreated()); } } }","This will prevent changing to null, which should be allowed",Use RS_MAINTAINER instead of ALLOC_MAINTAINER ?,![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception.ConstraintViolationException' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>,This whole block can probably be replaced with a call to allelesToConsider.contains() instead which would be just as fast but less gross.,this method should call projectDao.setReferenceGenomeDao as well,"DefaultStainCategoryService calculates whether to add the 's' or not, could this one too?",you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...,"Have a look at how it's done in ListReviewers: for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) { Account.Id accountId = patchSetApproval.getAccountId(); if (!reviewers.containsKey(accountId)) { reviewers.put(accountId, resourceFactory.create(rsrc, accountId)); } } Obviously you'll need to change variable names to fit in here, but generally that should work as expected.","I don't think this behaviour is correct. From my understanding, it is fine for a sample to have no group ID if its parent has one. I think the ""inherited but changeable"" idea here is that the parent's group ID should be default in the UI when creating a sample, but clearing it is valid","![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_3> ![MAJOR](<LINK_0> 'Severity: MAJOR') No need to call ""toString()"" method as formatting and string conversion is done by the Formatter. [![rule](<LINK_1>](<LINK_2>","How about creating in AuthenticationInfo a new method called isAnonymous(AuthenticationInfo subject) and move the check inside? something like  // In AuthenticationInfo.java private static final String ANONYMOUS = ""anonymous""; public static boolean isAnonymous(AuthenticationInfo subject) { if (subject != null ) { LOG.info(""Subject is null assuming anonymous""); return true; } return ANONYMOUS.equals(subject.getUser(); } //for the fun public boolean isAnonymous() { return ANONYMOUS.equals(user); } //then here you can do something like this in makePrivate if (AuthenticationInfo.isAnonymous(subject)) { // Add maybe meaningful log :) return; } NotebookAuthorization notebookAuthorization = NotebookAuthorization.getInstance(); Set<String> users = notebookAuthorization.getOwners(noteId); users.add(subject.getUser()); notebookAuthorization.setOwners(noteId, users); users = notebookAuthorization.getReaders(noteId); users.add(subject.getUser()); notebookAuthorization.setReaders(noteId, users); users = notebookAuthorization.getWriters(noteId); users.add(subject.getUser()); notebookAuthorization.setWriters(noteId, users);"
"public Node(String name, Id id) throws NodeException { Objects.requireNonNull(name); Objects.requireNonNull(id); this.mName = name; this.mId = id; }","Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.",StringUtils.isBlank(nodeId),UnsupportedOperationException might be more appropriate here.,redundant with below?,nodeID could be null,I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.,what Aaron said. This is not needed,what else? any warning or exception should be there?,It might be better to override toString rather than append ValidationError because now you will get org.voltdb.exception.ValidationError: ValidationError: MESSAGE when toString is called or the stack trace is printed,"This line could merge with the next line, making the next line return new UID(requireNonNull(v));",Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
"public boolean Validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = configurator.getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().AsConvertible().Integer(); getModel().getNumOfDesktops().ValidateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().ValidateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid()); getModel().setIsPoolTabValid(true); return super.Validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid(); }",Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.,"after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().ValidateEntity( } remove union (like you did in name validation)",getInstance().getInstance() ?,"Sorry I didn't notice it before, this could be the same as in NetworkModel, using the trinary comparison operator.",If possible import the model type and use the fully qualified name of the backend type.,"This is a bit strange, I would prefer something like:  if (isRequired()) { setValidationState(ValidationState.INVALID_BY_REQUIRED_WITHOUT_VALUE); return false; } else { setValidationState(ValidationState.VALID); return true; }  What do you think?",I think also the description needs validation: getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });,the linebreak place is not the best choice,"but now you can make a username like ' % @#$!@%& '. Is that correct? Would it not be better to subclass the AsciiNameValidation and add a support for '@' character? Something like ""NameWithDomainValidation""?",Please use interface List in the left side,Single pass is needed here.
"synchronized void flush() { if (_kafkaProducer != null) { try { CompletableFutureUtils.within(CompletableFuture.runAsync(() -> _kafkaProducer.flush()), Duration.ofMillis(_flushTimeout)).join(); } catch (CompletionException e) { Throwable cause = e.getCause(); if (cause instanceof InterruptException) { _log.warn(""Kafka producer flush interrupted, closing producer {}."", _kafkaProducer); shutdownProducer(); throw (InterruptException) cause; } else if (cause instanceof java.util.concurrent.TimeoutException) { _log.warn(""Kafka producer flush timed out after {}ms. Destination topic may be unavailable."", _flushTimeout); } throw e; } } }","CompletableFuture.runAsync() uses the common pool which isn't the best option for a potentially long blocking call like Producer.flush(). Even if we provide our own thread pool to runAsync(), the CompletableFuture we'll get won't give us a way to interrupt a Producer.flush() call that exceeds the allowed timeout, which is necessary to free up the thread-pool thread in question. This is because calling cancel(true) on a CompletableFuture returned by runAsync() only causes a cancellation exception to be propagated without interrupting the blocked thread pool. I'm afraid our only option here seems to be using an ExecutorService directly java // It's okay to use a single thread executor since flush() is synchronized ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> future = executor.submit(() -> super.flush()); try { // Block until timeout elapses future.get(_flushTimeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { ... // Interrupt the Producer.flush() call to free up the blocked thread future.cancel(true); ... }",It is definitely stale since what Sonam is now catching is IllegalStateException which is not even on that list.,"we're checking _kafkaProducer outside the lock. _kafkaProducer may change by the time shutdownProducer() is called. Can we instead have a shutdownProducer(producer) that does this comparison under the lock and calls shutdownProducer(), or something along those lines?",Shouldn't you reset the interrupt flag after catching this?,"If it may be come in handy during debugging and isn't produced too frequently, it may not be such a bad idea to turn the two debug logs within this block to info instead. I don't have as much experience as you do with these logs though.",RuntimeException will be sufficient,"Maybe try to wakeup the consumer before you try to interrupt it's thread? I would imagine that that would tend to deal with stopping more elegantly (in terms of the kafka client side, not your code). In fact, I think you could probably do without the shutdownNow altogether. Edit: well, okay, the shutdownNow is clearly necessary in case we're waiting for topics or something like that",Minor nit: there are a lot of redundant this references lying around.,re interrupt the thread,"exception can be improved a bit - ""failed to flush within X ms, successfully completed Y/Z batches"". wuold help distinguish between slow connection and no connection.","This function is only used in unit test, we should not expose."
"public void testPropertyNameOnMethodName() throws NoSuchMethodException { class Hotel { String hotelName; public String getHotelName() { return hotelName; } } Method m = Hotel.class.getDeclaredMethod(""getHotelName""); assertMemberValue(m, ""getHotelName""); }",Does GSON maintain full method names or does it drop Java bean notation? I know in Jackson's case this would serialize as hotelName (possibly HotelName as I'm not completely certain about how it handles casing).,Why not use JUnit assert* methods here?,We should use assertNull(simpleObject.getName()) here.,Can be static,Can you include a check for setName with none null values?,please move as close to usage as possible.,nit: Can be simplified to assertSame,Maybe we should fix this then,Class<?>,How about a test for an override in a nested class?,@dskalenko yes - test confirming that only one suppression is enough to suppress - previously we needed two
"void oneParameterAndStatementUtilityConstructor() { LambdaExpr expr = new LambdaExpr(new Parameter(new UnknownType(), ""a""), parseStatement(""return 5;"")); assertEquals(""a -> return 5;"", expr.toString()); }",I don't think this is valid Java code...,We should probably also assert isTypeInferred here,AppVeyor does its job: this test fails on Windows. Try assertEqualsNoEol or whatever it is called.,This could also be java.lang.String.,The constructors should be package private,@vilchik-elena Hoiw about adding,"Hmmm, three messages are a little overkill?","For this kind of test, I'm not sure that mocking is better than parsing python code.",Could we add a check on the node being replaced having a null parent?,Both good ideas :+1:,"Please extend why you need this test. We try to avoid such tests as much as possible, please make such case in non compilable sources if you need. All test coverage should be on real Java files , not a fake trees."
"public void useDefaultKeyPair() throws KeyStoreException { String alias = Config.<String>GetValue(ConfigValues.CertAlias); String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl); char[] password = Config.<String>GetValue(ConfigValues.keystorePass).toCharArray(); KeyStore.PrivateKeyEntry entry; InputStream in = null; try { in = new FileInputStream(p12); KeyStore ks = KeyStore.getInstance(""PKCS12""); ks.load(in, password); entry = (KeyStore.PrivateKeyEntry)ks.getEntry( alias, new KeyStore.PasswordProtection(password) ); } catch (Exception e) { throw new KeyStoreException( String.format( ""Failed to get certificate entry from key store: %1$s/%2$s"", p12, alias ), e ); } finally { Arrays.fill(password, '*'); if (in != null) { try { in.close(); } catch(IOException e) { log.error(""Cannot close key store"", e); } } } if (entry == null) { throw new KeyStoreException( String.format( ""Bad key store: %1$s/%2$s"", p12, alias ) ); } setKeyPair( new KeyPair( entry.getCertificate().getPublicKey(), entry.getPrivateKey() ) ); }",These ^ could be final.,Having the clear password in memory once is bad ...,"suggestion assertKeyPair(file, password);",Use double try block to make logic simplier.  java try { InputStream is = new FileInputStream(keyStore); try { ... } finally { Closeables.closeQuietly(is); } } catch (...) { },You may use builder.setConnectionThreadCount(2);,"Can we declare global final variable for ""JKS"" and refer in code?",This will break on Windows for sure. Please use the classloader.,Needs a try-with-resources block to ensure no resource leak occurs if an exception is thrown.,"While setting up the server & client not a part of this library or PR, it would nice to set the integration test server and client up to only use TLS 1.2.",IllegalArgumentException is possible here. I see it is not handled.,"suggestion assertKeyPair(file, password);"
"protected void endVmCommand() { Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED); boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess(); boolean liveSnapshotRequired = isLiveSnapshotApplicable(); boolean liveSnapshotSucceeded = false; if (taskGroupSucceeded) { getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK); if (liveSnapshotRequired) { liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot); } else { if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) { logMemorySavingFailed(); getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId()); removeMemoryVolumesOfSnapshot(createdSnapshot); } } } else { if (createdSnapshot != null) { revertToActiveSnapshot(createdSnapshot.getId()); if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) { removeMemoryVolumesOfSnapshot(createdSnapshot); } } else { log.warnFormat(""No snapshot was created for VM {0} which is in LOCKED status"", getVmId()); } } boolean archSupportSnapshot = isSnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion()); if (getParameters().isSaveMemory() && (archSupportSnapshot || !FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()))) { log.warnFormat(""A memory snapshot was required but not created, since VM architecture does not support it."", getVmId()); } incrementVmGeneration(); endActionOnDisks(); setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded)); getReturnValue().setEndActionTryAgain(false); }",same here (!archSupportSnapshot) ? how about extract this check to separate method like 'isMemorySnapshotSupported' that checks the cluster compatibility version and the architecture (because I see that is appears multiple times here) ?,"This line will never be executed - the first if statement in the method will evaluate to true, and a NullableMemoryImageBuilder will be returned. Moreover, in such a situation I don't think we should just log the discrepancy, but fail canDoAction() - the use has obviously requested an impossible command to be run.","1. Ravi, IMO this should be outside of the transaction, there's no need to open a new transaction if we already know that we won't do anything.. 2. we could just return at this point","Allon, another question here - upon engine restart , as Ravi described in the commit msg, if the snapshot entry was compensated, don't we want to end with failure somehow?",RemoveSnapshot may fail on the validate() methoid - so perhaps we should iterate over the disks and free only those who are in LOCKED status.,I would change this to warn or error. perhaps warn is more suitable,"Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.",shouldn't be 2 deletes here?,this is being called on a different flow now. is this intentional?,Why do we need a switch statement only for one option? If is much more elegant in that case IMO,seems to be like this should be before the vm is unlocked in super.endVmCommand();
"public static void main(String[] args) throws Exception { Optional.ofNullable(System.getProperty(""logback.configurationFile"")) .stream() .forEach(file -> System.err.println(""Load logging config from "" + file)); Configuration configuration = Configuration.builder() .useWorkingDirectoryEnvProperty() .build(); LOGGER.info(""Loading configuration {}"", configuration); GuiceJamesServer server = createServer(configuration) .combineWith(new JMXServerModule()); JamesServerMain.main(server); }",Can't we rely on System.out here because as far as I know we are not printing an error but an expected behavior.,nit: s/passwordAuthenticator/passwordAuthenticatorManager/,Should be done via a logger,There should be a space after if,this looks like a switch(config.transport) { ... } or config.getTransport() ?,This can be replaced with NoopAuthorizationManager.,"In hindsight, we shouldn't be passing the number of players into a randomly generated grid. I'll push some changes to this branch to fix that.","The JMSServerManager is deprecated so it's probably best not to use it in new tests. Check out the ""embedded-simple"" example for how to programmatically instantiate a broker with a configuration file.",Can be replaced with NoopAuthorizationManager.,please avoid return at middle of function. maybe it suggest you have your own exception for normal termination? :) or... condtional.,"Again, maybe join the paths the idiomatic way. I think you can do new File(path1, path2) in Java."
"public String createNewProcess() { try { createProcessHierarchy(); if (Objects.nonNull(PrimeFaces.current())) { PrimeFaces.current().executeScript(""PF('sticky-notifications').renderMessage({'summary':'"" + Helper.getTranslation(""processSaving"") + ""','detail':'"" + Helper.getTranslation( ""youWillBeRedirected"") + ""','severity':'info'});""); } return processListPath; } catch (DataException e) { Helper.setErrorMessage(""errorSaving"", new Object[] {ObjectType.PROCESS.getTranslationSingular() }, logger, e); } catch (IOException | ProcessGenerationException e) { logger.error(e.getLocalizedMessage()); } return this.stayOnCurrentPage; }",suggestion if (Objects.nonNull(PrimeFaces.current()) && Objects.nonNull(FacesContext.getCurrentInstance()) {,"suggestion message += ""\n WARNING: There are uncommitted changes to the script definitions. These will be lost if you update."";",I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?,This test case should not be changed.,I wonder whose job it is to do the decoding? is it the SDK job to decode scriptLog or the user?,Could the content of this method be moved to MigrationService to keep MigrationForm free of program logic?,Phonenumber cannot be save: patient does not exist --> Phonenumber cannot be saved: patient does not exist,would be better to have a copy constructor here: new Script(script);,unrelated change,"I think this logic is correct, but the code/jump-branch complexity is high (mostly due to legacy problems). If possible I would like to try to simplify it.",Use an else for this (or throw an IllegalStateException maybe?)
"private static void appendLib(StringBuilder classpath, String libDirName, boolean useLibJarsFormat) { File libDir = new File(libDirName); if (!libDir.exists()) { System.err.println(""ERROR - Directory needed for classpath does not exist: "" + libDirName); System.exit(-1); } if (useLibJarsFormat) { File[] files = libDir.listFiles(); Arrays.sort(files); for (File f : files) { if (f.isFile() && f.getName().endsWith("".jar"")) { if (classpath.length() != 0) { classpath.append("",""); } classpath.append(f.getAbsolutePath()); } } } else { if (classpath.length() != 0) { classpath.append("":""); } classpath.append(libDir + ""/*""); } }",Should this be libDir.getAbsolutePath() like f..getAbsolutePath() above?,"Cannot have a system.out.println in code, if you want the list to be visible for debugging purposes, create a logger using Logging.getLogger(class) and then write log statements at debug level","Since we're changing the exposed contract anyways as we rename the file, could we fix the visibility of this function as well? I know the visibility is copied over from the old location, so we can leave it as public as well. I'll provide a separate patch set for that then.",Probably want to use the newer equivalent mapreduce.map.speculative,File.pathSeparator,Please add a check not null validation,it would be nice to include the throwable stack (maybe at DEBUG only though?) So it's easier to understand why it couldn't be loaded. In one case I had a classloader issue which wasn't obvious so it would be good to have a way to expose the exception.,A try-with-resources would be the thing to do here.,"Same thing here, you should clean copied jars and libStore jars",i'd be consistent with the use of cache/preload. You still use interchange them quite a bit.,We should ensure that this works also for Hadoop. Placing the library in the Hadoop lib dir might be useful to be able to install Hadoop without root permissions.
"public boolean close() { synchronized (startStopLock) { if (!started.get() || executorService.isShutdown()) { LOG.info(""Already shutdown, ignoring""); return false; } started.set(false); executorService.shutdownNow(); final ListenableFuture<?> future = this.future; if (future != null) { if (!future.isDone() && !future.cancel(true) && !future.isDone()) { LOG.error(""Error cancelling future for topic [%s]"", getKafkaTopic()); return false; } } if (!cacheManager.delete(factoryId)) { LOG.error(""Error removing [%s] for topic [%s] from cache"", factoryId, getKafkaTopic()); return false; } if (consumerConnector != null) { consumerConnector.shutdown(); } return true; } }",calling stop multiple times should return true thought,"Maybe try to wakeup the consumer before you try to interrupt it's thread? I would imagine that that would tend to deal with stopping more elegantly (in terms of the kafka client side, not your code). In fact, I think you could probably do without the shutdownNow altogether. Edit: well, okay, the shutdownNow is clearly necessary in case we're waiting for topics or something like that",Do we need to wait to avoid the leader election?,"Not sure if we need this? If the shutdown is not clean, we logged an ERROR before in StreamThread#run()",RuntimeException would be sufficient,"If it may be come in handy during debugging and isn't produced too frequently, it may not be such a bad idea to turn the two debug logs within this block to info instead. I don't have as much experience as you do with these logs though.","CompletableFuture.runAsync() uses the common pool which isn't the best option for a potentially long blocking call like Producer.flush(). Even if we provide our own thread pool to runAsync(), the CompletableFuture we'll get won't give us a way to interrupt a Producer.flush() call that exceeds the allowed timeout, which is necessary to free up the thread-pool thread in question. This is because calling cancel(true) on a CompletableFuture returned by runAsync() only causes a cancellation exception to be propagated without interrupting the blocked thread pool. I'm afraid our only option here seems to be using an ExecutorService directly java // It's okay to use a single thread executor since flush() is synchronized ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> future = executor.submit(() -> super.flush()); try { // Block until timeout elapses future.get(_flushTimeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { ... // Interrupt the Producer.flush() call to free up the blocked thread future.cancel(true); ... }","we're checking _kafkaProducer outside the lock. _kafkaProducer may change by the time shutdownProducer() is called. Can we instead have a shutdownProducer(producer) that does this comparison under the lock and calls shutdownProducer(), or something along those lines?",use camel context -> executor service manager -> has api to shutdown thread pool more safely,"It might be worth mentioning that if there is a partition-level failure, then the first one is returned.",RuntimeException will be sufficient
"public Metadata(Map<String, String[]> metadata) { md = metadata; }",I would check for null and make a copy of the map,Aren't there cases where people might be changing/removing breadcrumb metadata in a callback? The case which comes to mind is intent extras from the EventReceiver.,If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...,"<LINK_0> handled the case when metadata was null, does that check need to go here also?",The constructor already does this logic. Could this just be this.metadata = metadata?,SHould we check that values is neither null nor empty?,create an Immutable copy of the clientMetadata and assign it. java this.clientMetadata = Collections.unmodifiableMap(mutableClientMetadataMap);,As above the getter should deal with wrapping in an Optional.,what does passing a null type in mean?,unneeded,"Why do you need to return the metadata? You are updating the own object, it should be part of the method getMetadata if you want to obtain this data after an update on it."
"private void evaluateXPath() { Document document = getWebSourceCode().getDocument(expression.contains("":"")); try { NodeList nodes = (NodeList) getXPathExpressionForDocument(document).evaluate(document, XPathConstants.NODESET); for (int i = 0; i < nodes.getLength(); i++) { int lineNumber = getWebSourceCode().getLineForNode(nodes.item(i)); createViolation(lineNumber); } } catch (XPathExpressionException exceptionNodeSet) { try { Boolean result = (Boolean) getXPathExpressionForDocument(document).evaluate(document, XPathConstants.BOOLEAN); if (result) { createViolation(0); } } catch (XPathExpressionException exceptionBoolean) { throw new IllegalStateException(String.format(""Can't evaluate expression \""%s\"""", expression), exceptionBoolean); } } }",![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>,Catch clause is too general.,"Could just return directly here: return (NodeList) expr.evaluate(contextNode, XPathConstants.NODESET);","""enable"" not ""ebable"". Same mistake below.",The whole file prints the error messages. Is that the best practice? Should these go to a logger? Or let the exception through?,Provide messages in ParseResult if missing required fields,Should the %s be replaced with something (the xmlString for instance)?,"Why does this just return null? If there is anything in matches, shouldn't the test fail at this point?",Is this like if (!StringHelper.isBlank(responseValue.faultMessage)),"I hope, you are right.",the brackets :)
"protected PageableResult doGetAll(RequestContext context) throws ResponseException { return new AlreadyPaged<AutoGenerationOption>(Context.getService(IdentifierSourceService.class).getAutoGenerationOption(3), context); }",What does the 3 parameter mean?,"This shouldn't be changed, instead you need to change getAllCount() to return VisitService.getAllVisits().size()",Validate that inputs are positive: <LINK_0>,"Instead of patient.getActiveIdentifiers(), use patient.getIdentifiers() if context.getIncludeAll() is true, then just return this list. Else build and return a new list that does not have voided ones. Does this make sense?","Can we use enums or constants instead of hardcoded numbers here? Also, making RAMP_STAGE_MAX protected should be good enough and avoids having this function.",I know this was a requested change but I am against this given the service treats this as an optional parameter. @JonathanGiles thoughts?,Declare Context.getService(IdentifierSourceService.class) at the top of the class.,+1 for SystemClock.elapsedRealTime().,response.status().code(),Remove these two lines.,why not just if(200 <= responseCode && responseCode < 300) ?
"protected BinaryLogicalFilterPredicate(FilterPredicate left, FilterPredicate right) { Preconditions.checkNotNull(left, ""left""); Preconditions.checkNotNull(right, ""right""); this.left = left; this.right = right; String name = getClass().getSimpleName().toLowerCase(); this.toString = name + ""("" + left + "", "" + right + "")""; }","same here:  this.left = checkNotNull(left, ""left"");",The one-argument constructor can just be called here instead: this(true),suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);,"Maybe specify the names in the constructor (SKIP(""skip"")) so that someone modifying toString() by accident won't break the parsing.","We don't have MoreObjects on 1.8, use Objects.toStringHelper instead",Wrong way round.,"You should use toLowerCase(Locale.ROOT) as using using ""toLowerCase"" by itself will use the default locale (which may lowercase incorrectly depending on the language)",Maybe we want to keep something similar to what id was before,"config key could be ""foo-----bar"" for example ... throws IndexOutOfBounds I believe. Could also start or end with hyphen.",The this. in getters are unnecessary too.,"isn't this the same as if I would have imported the method from Either? @danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?"
"public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown) { enforceConnectivityInternalPermission(); enforceCrossUserPermission(userId); if (LockdownVpnTracker.isEnabled()) { return false; } synchronized (mVpns) { Vpn vpn = mVpns.get(userId); if (vpn == null) { Slog.w(TAG, ""User "" + userId + "" has no Vpn configuration""); return false; } if (!vpn.setAlwaysOnPackage(packageName, lockdown)) { return false; } if (!startAlwaysOnVpn(userId)) { vpn.setAlwaysOnPackage(null, false); return false; } } return true; }","Shouldn't this be inside the synchronized{} block ? Also, can't this be simplified to if (!mLockdownEnabled) ?",Here too it looks like whether the tracker is enabled or not might change between the check and the call. Also LockdownVpnTracker.isEnabled() here might be replaced with mLockdownEnabled I thik,// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off,Shouldn't this API call be guarded by a check for Android version M?,Space before {,"Instead of iterating over packages, what do you think about PackageManager#getPermissionInfo(). packageName ? Then use PackageManager.getPackageInfo(packageName, MATCH_SYSTEM_ONLY). I'm thinking it might be possible or the package to define the permission but not hold it ? Right now the package has it because it shares the same UID and signature with NetworkStack.apk, but OEMs could use InProcessNetworkStack.apk instead.",Nit: this could (should?) be == instead of <=.,you can use here LockingGroup.VM.name() and not worry of some unexpected LockingGroup.toString() future implementation,How about restricting only RuntimeException?,"those are hidden APIs, can we try use below mechanism to figure out firstboot? return Settings.Global.getInt(context.getContentResolver(), Settings.Global.BOOT_COUNT) == 1;","Nit: while you're at it, this ""this."" is not necessary, I think."
"private FilterExpression parseQualifierContent(QualifierType type) { if (type == QualifierType.SORT) { return parseSortKeys(); } else if (isCompoundId(type, lookAhead())) { return parseCompoundId(); } else if (isRangeOperatorToken(lookAhead())) { return parseRangeOperator(type, lookAhead()); } else if (isDateToken(lookAhead())) { return parseDateOrDateRange(type); } else if (isNumberToken(lookAhead())) { return parseNumberOrNumberRange(type); } else if (isQuotedContentToken(lookAhead())) { Token quotedContent = consume(); return parseQuotedContent(type, quotedContent); } else if (isKeywordToken(lookAhead())) { return new Qualifier(type, consume().getValue()); } else { throw new ParseException(String.format(""Invalid content for qualifier %s: %s"", type, lookAhead())); } }","Checking for failure here leads to a non-id qualifier being used with a compound id being a parse error. Could we follow the other parse* functions and let it fail later, as a semantic error? If for some reason we want to use compound ids with other qualifiers, it would be easier.","Instead of this (which doesn't always remove the correct characters), we can use Utility.stripQuotes and trim.",I think _input is not appropriate variable name. It is actually trimmedInput what from my point of view facilitate code reading. What do you think?,nitpick: I'd throw IllegalArgumentException directly from there. note that IAExc will be catched by the toplevel parse function (fromXContent) and the token location will be added from there.,Why add the = null?,"You probably a want a * after the \\s for a more flexible syntax. Looking at the legacy open Cypher specification, space is also allowed between the : and the label identifier when creating indexes, though not when doing index lookups via the START clause.","Please avoid to reformat automatically our files. It makes it very difficult to find the real changes in there. To fix it, use your IDE to compare both versions then bring back all the changes that are purely reformatting. Thanks!",I'm thinking that instead of splitting this text twice (here and in parseAllJoinItems) then wouldn't it be better to not have this if-block and just always apply parseAllJoinItems(...)?,"A question: Is it correct that ""RANK DISTINCT"" is not supported by the standard and so is correctly going to be treated as a syntax error?",I think we have to add the token DO_WHILE. WHILE = while (true) { } DO_WHILE =  do { // this is DO while (true); // this is DO_WHILE  It could have been overlooked if external users though WHILE and DO_WHILE were the same token. @romani Do you agree?,"![MAJOR](<LINK_1> Make ""isOpenParenthesis"" a ""static"" method. [![rule](<LINK_2>](<LINK_0>"
protected Optional<DominantHandProperty> getForEntity(Entity entity) { if(!(entity instanceof EntityPlayer)) return Optional.empty(); EnumHandSide hand = ((EntityPlayer) entity).getPrimaryHand(); HandType type = (HandType) (Object) hand; return Optional.of(new DominantHandProperty(type)); },"if (, and if statements require braces.",I would argue there is no point punishing modders for this. Just put in the method doc that changing this value has no affect for pick blocks.,tabs,what is the idea behind this?,Please use EntityType.getEnum(type) instead of using string literals,OptBool.of(dataHolder.isGlowing()),"Since you are returning inside the if-blocks, the elses are redundant and can be omitted.",We should probably also add a message saying that you cannot barter with piglins using Slimefun items.,Braces,Please add a space after (Class<E>).,false == what missing == ?
"private boolean isUnregisteredDisk() { DiskImage unregisteredDisk; storagePoolId = BackendDataCenterHelper.lookupByStorageDomainId(this, storageDomainId); try { GetUnregisteredDiskQueryParameters getDiskParams = new GetUnregisteredDiskQueryParameters(guid, storageDomainId, storagePoolId); unregisteredDisk = getEntity(DiskImage.class, QueryType.GetUnregisteredDisk, getDiskParams, guid.toString()); } catch (WebApplicationException e) { if (e.getResponse().getStatus() == Response.Status.NOT_FOUND.getStatusCode()) { return false; } throw e; } return unregisteredDisk != null; }","BTW: if ""getEntity()"" either returns the result or throws a WebApplicationException exception with ""NOT_FOUND"" status, the code can be simplified to always ""return true"" at the end and no need in ""unregisteredDisk"" local variable at all.",Can you mark this @Nullable please?,"i'd move this to the inheriting classes (making this method abstract) where you have map of <guid, disk>, so you can fetch disk in more efficient way - like in ~O(1) (even if amount of disks is not that big) instead of 1. fetch all disks 2. map each to api object 3. loop over and find the current or throw notFound()",I hope you realize the two lines are not atomic. Just want to make sure - if you're fine with that - cool.,"We agreed to preserve the message, but it was lost, maybe during a rebase?","I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.","please keep old way of search for admins (this is more efficient) and only if isFiltered() use this code, e.g if (!isFiltered()) { return getEntity(storage_domains.class, SearchType.StorageDomain, ""Storage: name="" + name).g etId(); } else { ... VdcQueryType.GetAllStorageDomains ... }",declare throws please,You don't need to use getStorageDomain().getstatus() != null condition,I think this can be deleted,"Please don't remove the Network, just add another ""else if"" for the NetworkView. This procedure can be useful to get the id of a Network entity in a generic way."
public long getFileSize(String ext) { Long size = sizeMap.get(ext); return (size == null) ? 0 : size.longValue(); },No parens on condition.,etc. for the rest,Why Long instead of long?,We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.,The parseSize method below only supports int. Should do a long method with a range check for if the int value is allowed.,"For Max + Min Size, I think synchronized should be removed from the setter methods and just make the variables volatile instead.","Hmm, this could be tricky since we use both warm up and cool down checks with this?",why do we ignore this?,would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?,Should this maybe return RecordStore.DEFAULT_TTL (-1 --> use MapConfig's default) instead of 0 (--> infinite max idle)?,"so, would this be the suggested change?  NumberFormat f = NumberFormat.getInstance(); if (f instanceof DecimalFormat) { ((DecimalFormat) f).applyPattern(""#,##0.#""); } return String.format(unitStrings[digitGroups], f.format(size / Math.pow(1024, digitGroups)));"
public boolean tryAdvance(Consumer<? super BytesHandle> action) { try { FormatEntry nextEntry = getNextEntry(); if (nextEntry == null) { return false; } BytesHandle nextBytesHandle = readEntry(nextEntry); action.accept(nextBytesHandle); splitter.count++; } catch (IOException e) { e.printStackTrace(); } return true; },"The IDEs tend to generate boilerplate code that suppresses exceptions. Unless we know it is safe to suppress an exception, the best practice is to throw the exception. In this case, if we encounter an IOException, something must be wrong with the zipfile. Where the exception is a checked exception (like IOException) that's not allowed by the signature (as with the tryAdvance() method), we can rethrow it with something like throw new RuntimeException(""Could not read ZipEntry"", e); To be clear, the same issue affects the other tryAdvance() method.",should we add a more detailed log and set currentProductVersion to null,I wonder what we are saying with this error. Maybe this should be a fatal error - it's certainly pretty unlikely to happen. I think we should re-throw the exception (wrapped in some kind of RuntimeException) here so that rest-driver won't start.,Better to log instead of e.printStackTrace,"For greater clarity, this could probably be an else if so execution skips this branch if getUriMaker() is not null",I'm not 100% sure if we should log here as well. In many places the exception is already logged. So every exception is logged twice. Maybe just log that an exception is logged without logging the exception itself? Or remove it entirely,if (onlyverbose && !verbosemode),"new BoundedPrintWriter(~stackTraceResult~ **printWriter** Currently, the counter in printWriter is not used properly",You can use the Closeables class to implement this.,Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,This is printed out once on class loading? We can prettify later.
public static ViewGroup.OnHierarchyChangeListener tryGetOnHierarchyChangeListenerHack( ViewGroup viewGroup) { if (sOnHierarchyChangeListenerField == null) { return null; } try { return (ViewGroup.OnHierarchyChangeListener)sOnHierarchyChangeListenerField.get(viewGroup); } catch (IllegalAccessException e) { throw new RuntimeException(e); } },"This too, possibly","This should probably be refacotred to use ReflectionUtil, no?",Add the original exception as cause.,wouldn't it be easier (and also more performant) to simply make the field accessible in the constructor of the comparator? Going through all methods for every field access is not very beautiful.,"This test should be verifying that you _can_ use this event, not that it throws an exception.","Any reason for using IllegalArgumentException? I think the following may be more appropriate: java throw new GroovyRuntimeException(""Illegal access to field "" + field.getName() + ""."", ex);",public isn't needed,"I see above catch block for ClassNotFoundException doesn't also throw anything like this catch block, but isn't it bad practice?",Add final keyword.,The catch block needs to be moved to one line below.,Same as previous PR review: Sonar Lint should complain if you don't at least log the exception
"private HullConfig read(String shipName) { final HullConfig.Data configData = new HullConfig.Data(); configData.internalName = shipName; Json json = Assets.getJson(shipName); try { readProperties(json.getJsonValue(), configData); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(""The JSON of ship "" + shipName + "" is missing, or has malformed, a required parameter"" + e.getMessage().split("":"")[1]); } catch (SerializationException e) { throw new SerializationException(""The JSON of ship "" + shipName + "" has invalid syntax"" + e.getMessage().split("":"")[1]); } configData.tex = Assets.getAtlasRegion(shipName); configData.icon = Assets.getAtlasRegion(shipName + ""Icon""); validateEngineConfig(configData); json.dispose(); return new HullConfig(configData); }",Take a look at what the error message you're splitting is :wink: (hint: it's the entire JSON file),"I don't understand this. The rootNode.has(""guard"") can *never* be false, since you just verified that it is true in line 119.","suggestion console.warn(""Usage: \""changeShip module:shipName\"""");","this is test and it doesn't matter much. but in general you should not create a ObjectMapper per method invocation, This is costly timewise.",We should use JsonParseException here if you want to declare the exception.,please use try with resources as in ConfigurationHolder,I'm not entirely sure how safe it is to change the event message. It's possible users have queries on it,May be use string builders here,Why setLenient(true)?,shipName) {,Now when we change handleException method in commcare controller we should also change getting message value from response in javascript handlers as you did below for other ones. Please find all handlers that can be affected by your changes and fix it
"public ImmutableValue<Entity> leashHolder() { return new ImmutableSpongeEntityValue<>(Keys.LEASH_HOLDER, getValue()); }",This should be stored in a field.,"You can use this.key (or this.usedKey, one of those fields - name always escapes me :P)",this.key can be used here.,Default value should be false.,Pretty sure I created [ImmutableSpongeEntityValue](<LINK_0> for this specifically.,"~~Use SpongeEntityValue here.~~ ~~Hmm, I need to make some changes to that class.~~ Nevermind.",The default value should be true.,The default value should be true.,Use the immutable value cache,This should never have a null value. I need to work out how LeashData is going to work.,return ?
"public int onStartCommand(@Nullable Intent intent, int flags, int startId) { if (intent != null) { if (intent.getAction() != null) { restoreQueuesAndPositionIfNecessary(); String action = intent.getAction(); switch (action) { case ACTION_TOGGLE_PAUSE: if (isPlaying()) { pause(); } else { play(); } break; case ACTION_PAUSE: pause(); break; case ACTION_PLAY: play(); break; case ACTION_PLAY_PLAYLIST: Playlist playlist = intent.getParcelableExtra(INTENT_EXTRA_PLAYLIST); int shuffleMode = intent.getIntExtra(INTENT_EXTRA_SHUFFLE_MODE, getShuffleMode()); if (playlist != null) { List<Song> playlistSongs; if (playlist instanceof AbsCustomPlaylist) { playlistSongs = ((AbsCustomPlaylist) playlist).getSongs(getApplicationContext()); } else { playlistSongs = (List<Song>) (List) PlaylistSongLoader.getPlaylistSongList(getApplicationContext(), playlist.id); } if (!playlistSongs.isEmpty()) { if (shuffleMode == SHUFFLE_MODE_SHUFFLE) { int startPosition = 0; if (!playlistSongs.isEmpty()) { startPosition = new Random().nextInt(playlistSongs.size()); } openQueue(playlistSongs, startPosition, true); setShuffleMode(shuffleMode); } else { openQueue(playlistSongs, 0, true); } } else { Toast.makeText(getApplicationContext(), R.string.playlist_is_empty, Toast.LENGTH_LONG).show(); } } else { Toast.makeText(getApplicationContext(), R.string.playlist_is_empty, Toast.LENGTH_LONG).show(); } break; case ACTION_REWIND: back(true); break; case ACTION_SKIP: playNextSong(true); break; case ACTION_STOP: case ACTION_QUIT: pendingQuit = false; quit(); break; case ACTION_PENDING_QUIT: pendingQuit = true; break; } } } return START_NOT_STICKY; }",This seems redundant.,"Might be a good idea to also add fast forward and rewind, since some media buttons support those when long-pressed.","Removing this should not cause something like #2356, right?",Why do you want to unconditionally enable it here? It's definitely wrong.,[nits] intent.getAction() can be null,"We try to use the ""guard style"" pattern in c:geo. Basically that is to avoid all nested if conditions and instead to have multiple return statements in the beginning: if (intent.getExtras()==null) { return default; } if (intent.getExtras().getString(EXTRA_GEOCODE)== null) { return default; } ...",Define at first usage.,"Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time",Will you be able to put methods that send broadcasts into your RecentListActionModeUtil?,"nice catch, I just recently wondered about our handling of singleTop","new ComponentName(mServiceInstance, mServiceInstance.getClass()) would be easier"
"public void configurePipeline(PipelineConfigurer configurer) throws IllegalArgumentException { super.configurePipeline(configurer); if (this.config.format == null || this.config.format.isEmpty()) { throw new IllegalArgumentException(""Format is not specified. Allowed values are DEFAULT, EXCEL, MYSQL,"" + "" RFC4180, PDL & TDF""); } if (!this.config.format.equalsIgnoreCase(""DEFAULT"") && !this.config.format.equalsIgnoreCase(""EXCEL"") && !this.config.format.equalsIgnoreCase(""MYSQL"") && !this.config.format.equalsIgnoreCase(""RFC4180"") && !this.config.format.equalsIgnoreCase(""TDF"") && !this.config.format.equalsIgnoreCase(""PDL"")) { throw new IllegalArgumentException(""Format specified is not one of the allowed values. Allowed values are "" + ""DEFAULT, EXCEL, MYSQL, RFC4180, PDL & TDF""); } if (configurer.getStageConfigurer().getInputSchema() != null) { Schema.Field inputSchemaField = configurer.getStageConfigurer().getInputSchema().getField(config.field); if (inputSchemaField == null) { throw new IllegalArgumentException( ""Field "" + config.field + "" is not present in the input schema, it is expected""); } else { if (!inputSchemaField.getSchema().getType().equals(Schema.Type.STRING)) { throw new IllegalArgumentException( ""Field Type "" + config.field + "" should be String""); } } } try { Schema outputSchema = Schema.parseJson(this.config.schema); configurer.getStageConfigurer().setOutputSchema(outputSchema); } catch (IOException e) { throw new IllegalArgumentException(""Format of schema specified is invalid. Please check the format.""); } }",Type for Field + config.field + must be String,you can use Schema's isNullable and getNonNullable methods to help out here.,Put this exception in the default branch of swith.,this would be an ABI change so restrict the patch to a major version bump It's unclear we'd want to break API in any case... maybe better to add a getFormat() and keep getSyntax working as long as the current format is a syntax. Could also put a deprecated annotation on get/setSyntax perhaps,I don't think we should use anywhere any tabs. Let's use spaces instead :),"The default value of fail-on-missing-field is false, should set it to true.",ARRAY_ELEMENT_DELIMITER is also a single character in CsvValidator.,must be of type bytes or string,Better use the CodecFactory class from the avro library to parse and pickup the codec to simplify the logic. java try { CodecFactory.fromString(conf.compressionCodec); } catch (Exception e) { throw new IllegalArgumentException(.....); },So EncodeType eType = EncodeType.valueOf(type) will not work?,';' can be replaced by SEMI_COLON
"private void applyProperties(AssociationKey associationKey, RowKey rowKey, Relationship relationship) { String[] rowKeyIndexColumnNames = associationKey.getRowKeyIndexColumnNames(); for ( int i = 0; i < rowKeyIndexColumnNames.length; i++ ) { for ( int j = 0; j < rowKey.getColumnNames().length; j++ ) { if ( rowKeyIndexColumnNames[i].equals( rowKey.getColumnNames()[j] ) ) { relationship.setProperty( rowKeyIndexColumnNames[i], rowKey.getColumnValues()[j] ); break; } } } }",Should there be RowKey#getColumnValue(String name)? This would make this code here a bit easier to grasp.,We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.,"Same as above: don't hardcode the owl prefix, resolve to an IRI.",We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.,Should return ReadOnlyArray.,"return false? BTW, ValueStringIgnoreCase.equals() unlike other value types may return true for different strings. But this ugly data type can be addressed in a separate issue, it may have more unrelated problems due to its equals() implementation.",assert findLast ^ row != null,"Now that the ColumnTypeResolver resolves JSONArray objects to List objects, we should add some logic here that the values which are actually returned are of the type List.",Why add this here?,I don't think this is correct. We need a separate implementation for non-zero elements here.,You can just call setString directly on the table. No need to create an unchecked row for it.
"private Diagnostic handleMigrationOptions() { Diagnostic migrationMismatchDiagnostic = null; VSMVersionSAXParser parser = new VSMVersionSAXParser(uri); String loadedVersion = parser.getVersion(new NullProgressMonitor()); boolean migrationIsNeeded = true; if (loadedVersion != null) { Version parsedLoadedVersion = Version.parseVersion(loadedVersion); Version lastMigrationVersion = VSMMigrationService.getInstance().getLastMigrationVersion(); boolean attemptToLoadMoreRecentVSM = lastMigrationVersion.compareTo(parsedLoadedVersion) < 0; if (attemptToLoadMoreRecentVSM) { migrationMismatchDiagnostic = new XMIException(MessageFormat.format(Messages.DescriptionResourceImpl_versionMismatchMessage, uri, parsedLoadedVersion, lastMigrationVersion)); } migrationIsNeeded = VSMMigrationService.getInstance().isMigrationNeeded(parsedLoadedVersion); } Object versionOption = this.getDefaultLoadOptions().get(AbstractSiriusMigrationService.OPTION_RESOURCE_MIGRATION_LOADEDVERSION); if (!migrationIsNeeded && versionOption != null) { removeMigrationMechanism(); } else if (migrationIsNeeded && (versionOption == null || !versionOption.equals(loadedVersion))) { DescriptionResourceImpl.addMigrationOptions(loadedVersion, this.getDefaultLoadOptions(), this.getDefaultSaveOptions()); } return migrationMismatchDiagnostic; }","Strange to use an XMIException here, which would imply something is corrupted at the XMI level, which is not the case. Especially since there is a AirdResourceVersionMismatchException defined in the same patch which implements Resource.Diagnostic.",Trivial lambda,Trivial lambda,"I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:","Why is this being collected as a set and then streamed again? I could only think it was to de-dupe the collection. If so, consider using .distinct() to save collecting and streaming twice",Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION),Sonar complains with case without break but I don't like to add it only for 1.5 (Sonar is analyzing only new code). I would like to refactor the whole switch (to if/else probably) or keep last case without and we will do in another ticket. Wdyt?,Set too.,"This is a bug in the build system, not the code.",Just realizing now: if it is a Set we don't need to check if it is contained inside first,The upgrade method should run all changesets from liquibase-master.xml...
"public <T> T get(String key, String field) { RedisConnection<byte[], byte[]> redisCommands = null; try { redisCommands = getRedisConnection(); byte[] serializedData = redisCommands.hget(key.getBytes(), field.getBytes()); T deserializeObject = new JavaSerializer().deserializeObject(serializedData); return deserializeObject; } catch (Exception e) { logger.error(""Exception Occurred while getting a value from redis"", e); } finally { closeConnection(redisCommands); } return null; }",Catching the exception hides network- and classpath/structural problems and returns null to the caller.,it would be a good habit to validate value instanceof Serializable so you can throw an IllegalArgumentException as early as possible,There's no need for a try/catch here.,"maybe one more log: logger.error(""Get Redis pool failure more than 3 times."")",Can't we use connection = super.createConnection() instead? That's way we do not have to pass null parameters?,"won't this span a new serializee? I guess the callers of this method want the same instance as this class is using... So probably you want to inject just Serializee, and not Instance<Serializee>",There's way too much try/catch in here. Check out try-with-resources (Java 1.7+) or Google Guava's [Closer](<LINK_0> A cleaner approach is having a try/catch with an inner try/finally (closing the resources) block. The try/catch could then wrap any checked exception within a RedisException.,"if you provide better ""serialize"" message then please improve this one too.",This appears to be duplicated with above new code. Is it possible to consolidate?,is there a specific reason for returning null? can you return an empty Email object instead?,"Code has blank lines, please remove them and format."
"public void testScaffoldSetup() throws Exception { Project project = projectHelper.createWebProject(); try (CommandController c = testHarness.createWizardController(ScaffoldSetupWizard.class, project.getRoot())) { c.initialize(); c.setValueFor(""provider"", ""Mock Scaffold Provider""); c.setValueFor(""webRoot"", """"); Assert.assertTrue(c.isValid()); Result result = c.execute(); Assert.assertNotNull(result); } }",Is this test really testing much? It doesn't assert that the result is not a failure: !(result instanceof Failed) for instance.,"please add: GoAssumptions.assumeGoVersionAtLeast(""1.10.0"");","This use TreeMaps internally, so you can just assert an exact form for the toString and it should be stable.",Do the tests need to change?,Shouldn't the two lines above resolve to true?,This test doesn't need to be changed,"We talked about using docker-fixtures for tests in this PR, though it is more work to set up.",I have a different opinion on this. I would like to see mockito fail here. It indicates that the dev made something unintended and it is easy to fix.,- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7,It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.,Minor: consider replacing equalTo with is from Hamcrest here and below.
"private Set<Integer> getTimeseriesLayerIds(int layerId) throws ActionException { Set<Integer> timeseriesLayerIds = new HashSet<>(); for (OskariLayer layer : mapLayerService.findAll()) { JSONObject options = layer.getOptions(); try { if (options != null && options.has(""timeseries"")) { JSONObject timeseriesOptions = options.getJSONObject(""timeseries""); Integer metadataLayerId = timeseriesOptions.getJSONObject(""metadata"").getInt(""layer""); if (metadataLayerId == layerId) { timeseriesLayerIds.add(layer.getId()); } } } catch (JSONException e) { throw new ActionException(""Cannot parse layer metadata options for layer: "" + layer.getName() + "", id: "" + layer.getId()); } } return timeseriesLayerIds; }",This could throw a NPE if options has timeseries but not metadata under it.,You could do try-with-resources and get rid of the finally statement:  try (SqlSession session = factory.openSession()) { ... },suggestion final int layerId = params.getRequiredParamInt(PARAM_LAYER_ID),"If you throw an exception for metadataoptions not being there, you should put MetaDataOptions in the default for the attribute. I can show you.",Admin check can be done with params.requireAdminUser();,The queryables endpoint is used for describing for example attributes that can be used to search items. It isn't a comprehensive list of attributes that the items in the collection have. The best we can do here instead is querying the /items endpoint for the first 10 or so features and gather the set of attribute names detected from those features. That should be reasonably accurate.,"Don't log and throw as it leads to excessive logging. So you can remove the log.error here and add the ""cause exception"" to ActionException as second parameter.",Integer.parseInt,The same username/password combination is used for all layers. Is this intentional?,"You could just do ResponseHelper.writeResponse(params, userLayer)?","Update rate isn't checked here, but I guess if last update is null we should always update. Maybe change the message a bit?"
"public void testSignInSucceeded() { Activity mockActivty = mock(Activity.class); ActivityHelper mockActivityHelper = mock(ActivityHelper.class); FirebaseUser mockFirebaseUser = TestHelper.makeMockFirebaseUser(); IDPResponse mockIdpResponse = mock(IDPResponse.class); CredentialSignInHandler credentialSignInHandler = new CredentialSignInHandler( mockActivty, mockActivityHelper, RC_ACCOUNT_LINK, RC_SAVE_CREDENTIALS, mockIdpResponse); Context mockContext = mock(Context.class); FlowParameters mockFlowParams = mock(FlowParameters.class); Task mockTask = mock(Task.class); when(mockTask.isSuccessful()).thenReturn(true); when(mockTask.getResult()).thenReturn(new FakeAuthResult(mockFirebaseUser)); when(mockActivityHelper.getApplicationContext()).thenReturn(mockContext); when(mockActivityHelper.getFlowParams()).thenReturn(mockFlowParams); credentialSignInHandler.onComplete(mockTask); ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class); ArgumentCaptor<Integer> intCaptor = ArgumentCaptor.forClass(Integer.class); verify(mockActivty).startActivityForResult(intentCaptor.capture(), intCaptor.capture()); Intent capturedIntent = intentCaptor.getValue(); assertEquals(RC_SAVE_CREDENTIALS, (int) intCaptor.getValue()); assertEquals( SaveCredentialsActivity.class.getName(), capturedIntent.getComponent().getClassName()); assertEquals( TestConstants.EMAIL, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_EMAIL)); assertEquals( TestConstants.NAME, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_NAME)); assertEquals( TestConstants.PHOTO_URL, capturedIntent.getExtras().getString(ExtraConstants.EXTRA_PROFILE_PICTURE_URI)); }","I think you should be able to use Tasks.forResult(new FakeAuthResult(mockFirebaseUser)) instead of a mock object without consequence here, it should be more readable.","Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.","To be consistent, we shouldn't statically import this and instead use AuthUI.EXTRA_DEFAULT_PHONE.","These tests verify the intent when the intent is only created for the purposes of the test. It would be nice to update the tests to reflect the changes in SmartLock, ideally checking that the SmartLock API is called with the correct credential.",@CTI777 this test will be more clear if we split the operations and the assertions in half.. 1) Start and the assertions 1.1) We can check that the last event here is the BPMN element that is going to catch the signal. collectedEvents.clear(); 2) Signal and the assertions,This createIntent call uses ExtraConstants.EXTRA_PHONE. We should unify the values between this and AuthUI.PHONE_VERIFICATION_DEFAULT_PHONE_EXTRA. I'd suggest: java class AuthUI { // ... public static final String EXTRA_DEFAULT_PHONE = ExtraConstants.EXTRA_PHONE; // ... },The Exception is never thrown.,"I was able to get past the error I mentioned below with this change: suggestion ""Eeflowtestingmobile"",",nit: let's call this variable matchesFakeOnTap,The Exception is never thrown.,Should we move this call out of the constructor and into the static setup method as well?
"public void testRecover() throws Exception { CountDownLatch countDownLatch = new CountDownLatch(2); final AtomicReference<Boolean> notified = new AtomicReference<Boolean>(false); NotifyListener listner = new NotifyListener() { @Override public void notify(List<URL> urls) { notified.set(Boolean.TRUE); } }; MockRegistry mockRegistry = new MockRegistry(registryUrl, countDownLatch); mockRegistry.register(serviceUrl); mockRegistry.subscribe(serviceUrl, listner); Assert.assertEquals(mockRegistry.getRegistered().size(), 1); Assert.assertEquals(mockRegistry.getSubscribed().size(), 1); mockRegistry.recover(); Assert.assertEquals(mockRegistry.getFailedSubscribed().size(), 1); Assert.assertEquals(countDownLatch.getCount(), 0); }","please fix typo listner, should be listener ?",I'd put the magic port number of 9999 into a class-level constant.,"suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.","pls. consider to enhance registerTest, unregisterTest, subscribeTest, unsubsribeTest, etc, instead of introducing new test methods. But your method naming is more recommended, pls. stick to it.",We are calling close even though it doesn't do anything just to avoid warnings? Where are the warnings coming from?,This assertion method is obscure. You shouldn't have to read the methods implementation to see what is being asserted.,Residue from debugging?,How about using snaeService.wait(500); instead and calling notify(); in the event handler?,It's not good to have two methods failing for the same reasons. Could we assert fewer things here?,This test doesn't assert anything.,Shouldn't numbers be assertEquals?
"public int compare(final Account account1, final Account account2) { if (account1.getPreferredEmail() != null && account2.getPreferredEmail() != null) { return account1.getPreferredEmail().compareTo( account2.getPreferredEmail()); } if (account1.getFullName() != null && account2.getFullName() != null) { return account1.getFullName().compareTo(account2.getFullName()); } return Integer.valueOf(account1.getId().get()).compareTo( Integer.valueOf(account2.getId().get())); }","This isn't stable, is it? We should compare email to """" , and the same with full name.","One way I like to simplify these null/empty checks for strings is to just do ! """".equals(...email). If you like the pattern...","Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?","Same as above, get the caller user/account from current context.",I thin It is better to return int instead of Integer.,"Please don't initialize a local variable to null. Instead leave it uninitialized so the compiler can prove we have correctly populated it before use. Right now this is hiding a bug here where the diffPref can be null if the database threw an exception. That would probably crash the JSON encoder in HostPageServlet. If the database fails, we should return a default preference after logging the warning here.",what is expected to be part of metadata ?,It's Comparator.naturalOrder(),Hi @hijklmno. This looks good overall. What was your reason for not setting this.accountNumber to stringOrNull(accountNumber)?,"I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.",Shall we log if it is other error?
"public void onNext(final AggregationMessage aggregationMessage) { final String workerId = aggregationMessage.getSourceId().toString(); final String localState = codec.decode(aggregationMessage.getData().array()); final String globalState = globalStateMachine.getCurrentState(); switch (globalState) { case STATE_INIT: break; case STATE_RUN: if (localState.equals(STATE_INIT)) { sendResponseMessage(workerId, new byte[0]); return; } break; case STATE_CLEANUP: default: throw new RuntimeException(""Invalid state""); } blockedWorkerIds.add(workerId); LOG.log(Level.FINE, ""Receive a synchronization message from {0}. {1} messages have been received out of {2}."", new Object[]{workerId, blockedWorkerIds.size(), numWorkersToSync}); tryReleaseWorkers(); }","It'd be helpful to remind what's going on here, especially mentioning that _In case when a worker's local state is behind the globally synchronized state, this implies the worker is added by EM. If so, the worker is replied to continue until it reaches the global state_.",What does rcvMsg stand for?,"This seems to be an unexpected case... in fact, an error. We should at least raise the log level to WARNING, or maybe even throw an exception.",Consider throwing instead of returning UNKNOWN. That encourages this list to be kept correct at all times. :-),This log looks irrelevant to its location. You should move this line after L242 or remove this. Same for L272.,"If we plan to throw RuntimeException, why do we have to wait until at least one Exception occurs and throw it in validate()? Is there specific reason not to throw here directly? Also, what happens if more than one failure take place?",throw RuntimeException?,Why don't we define a static variable instead of creating all the time?,"The same argument as for GlobalStateStore should apply here -- StandbyTask don't write but only read, hence, no ProducerFencedException could ever happen here.",Does this line have any effect? Since in the very next line it will be reinitialized with a new latch.. Or I guess you just want to release all waiting threads bound to the latch before assigning a new latch,"Could we unify both code paths by always using  for (InputGate inputGate : getEnvironment().getAllInputGates()) { inputGate .getStateConsumedFuture() .thenRun(() -> mainMailboxExecutor.execute(inputGate::requestPartitions, ""Input gate request partitions"")); }  and set getStateConsumedFuture to done if no data is available?"
"public HttpMessage setProtocolVersion(HttpVersion version) { ObjectUtil.checkNotNull(version, ""version""); this.version = version; return this; }",nit: you can merge both lines above as checkNotNull will return the given argument,Small nit: I would prefer version.compareTo(ProtocolVersion.NEWEST_SUPPORTED) > 0,This can be java return valueOf(value.toUpperCase(ENGLISH));,Let's not change this signature. Maybe add a separate method,"You are still programming in Javascript here. :-P What about replacing """" with null here and remove """" from the variable declaration?",Please use the form given before,redundant with below?,"should be more specified, what kind of exception can even be thrown here. The only one I did add, was an AssertionError","I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.","Can you remove private setters? It's not necessary we have private setters, so we reduce the size of the class",Remove the public modifier from the constructor and remove the null check.
"private void validate() { assertThat(localSegment, Objects::nonNull, () -> new AxonConfigurationException(""The localSegment may not be null"")); assertThat(channel, Objects::nonNull, () -> new AxonConfigurationException(""JChannel may not be null"")); assertThat(clusterName, Objects::nonNull, () -> new AxonConfigurationException(""The clusterName may not be null"")); assertThat(serializer, Objects::nonNull, () -> new AxonConfigurationException(""Serializer may not be null"")); assertThat(routingStrategy, Objects::nonNull, () -> new AxonConfigurationException(""RoutingStrategy may not be null"")); assertThat(consistentHashChangeListener, Objects::nonNull, () -> new AxonConfigurationException(""ConsistentHashChangeListener may not be null"")); }","Null values at this point should not be really reported as a property being null, but as a mandatory property for which no value was provided",Extraction to a separate method.,Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... },what Aaron said. This is not needed,@xiaolong-sn nit: Collections.emptyList() is more expressive,more clear to put in this way: !containsMacro(Cassandra.USERNAME) && !containsMacro(Cassandra.PASSWORD) && (Strings.isNullOrEmpty(username) ^ Strings.isNullOrEmpty(password)),extra semicolon?,The message in the assertStrictPositive seems incorrect to me. Shouldn't it state something along the lines of The maxRetryCount is a strictly positive number?,Static import the assertion methods,Even better would probably to compare File object. I wonder if AssertJ has some support to do this more cleanly...,can we remove the this. references? since this is scoped in the class anyway
"private Object unwrapBinary(Object obj, BinaryReaderHandles hnds) { if (obj instanceof BinaryObjectImpl) { BinaryObjectImpl obj0 = (BinaryObjectImpl)obj; return marsh.deserialize(BinaryHeapInputStream.create(obj0.array(), obj0.start()), hnds); } else if (obj instanceof BinaryObject ) return ((BinaryObject)obj).deserialize(); else if (BinaryUtils.knownCollection(obj)) return unwrapCollection((Collection<Objects>)obj, hnds); else if (BinaryUtils.knownMap(obj)) return unwrapMap((Map<Object, Object>)obj, hnds); else if (obj instanceof Object[]) return unwrapArray((Object[])obj, hnds); else return obj; }",Cosmetic. Extra space between BinaryObject and ).,"may be write the assert message here.For instance, ""Bad comp mode""","Maybe a quick check for the ""magic"" value at the beginning before attempting to read it via OIS ?",I think data is never null at this location.,do we need negative mark here?,can we make byte[] be the firs if check in both places ?,This appears to be duplicated with above new code. Is it possible to consolidate?,"Do you know if it would be better to phrase the exception in the ""why this happened"" instead of ""what happened""? Attempted to decode with non-Avro schema object in AvroByteDecoder. vs object must be an Avro Schema.","The buffer's mainly purpose is for performance with caching. Here is created everytime. The following is a good sample.  // Re-use (manage) this buffer to avoid allocating on every serialization LinkedBuffer buffer = LinkedBuffer.allocate(512); // ser final byte[] protostuff; try { protostuff = ProtostuffIOUtil.toByteArray(foo, schema, buffer); } finally { buffer.clear(); }","I'm not crazy about catching an exception, mutating it and then recatching it. It makes the code more complex due to nesting. I would move the catching to the main catchblock of the method and deal with it there.",Same here - throws SerializationException is not required.
"public void put(String handle, LocalDateTime lastUsed) { storageLock.lock(); try { if (_storage == null) { throw new RuntimeException(EXCEPTION_STORAGE); } if (lastUsed == null) { _storage.put(LAST_USED.getKey(handle), (String) null); } else { String gsonStr = gson.toJson(lastUsed); _storage.put(LAST_USED.getKey(handle), gsonStr); } } finally { storageLock.unlock(); } }",do not throw RuntimeException,outside of the try block,this method looks really nice but I think it won't be suitable for every case and the method itself doesn't specify which exception exactly it will throw and in some cases we throw different exceptions. I think we should keep the current usage as it is for the validations.,"The message should be ""List< T> may not be empty""",Let's keep it as it is for the being.,Maybe its an idea to distinguish more precisely between whats an exception because value is a filename string and when its possibly a malformed JSON string?,"@cweitkamp If someone wants to put a value ""now"", shouldn't it be used without any further check and the expiresAt be updated? If expire is one minute and I call putValue(somemmutableObj) every 30 seconds, I would expect that the cached value never expires.",I guess you actually mean storage == null. And I would also suggest to return in this case so we don't get a NPE later.,Instead of importing the method I would write TrayLog.logv(  makes it more obvious that the method isn't part of AbstractTrayPreference class,"It would be good to use Double.isNan() here for better readability. Also, what about Inf and -Inf? The ticket doesn't mention them, but we should be able to handle them as well.",Also take a look at - <LINK_0>
public ArrayList<LinkInfo> getRemoteGoToLinks() throws IOException { if (remoteGoToLinks == null) { loadAndPreflightPdf(); remoteGoToLinks = parseForLinks(PDActionRemoteGoTo.SUB_TYPE); } return remoteGoToLinks; },List<LinkInfo> (check below for other method signatures),Ternary?,Let's avoid null and rework to empty string,"Same thing as in previous file. I believe we need to avoid multiple get(nnn, TimeUnit) in the same method. Just chaining and calling get(...) on the last future should be enough.",this.links = List.copyOf(links) would give me the warm reassurance of knowing that this list can't be mutated after it's set by something outside this class,"This line wrapping seems a bit odd to me, although maybe I'm just not familiar with this project's conventions.","I am not sure that splitting the value is enough. URI itself can contain , which means that this code would produce invalid result.",Is this worth making configurable?,"This if-else is redundand. Please replace it with just return deps; If no deps are added in the for loop, the deps will be empty ;) The same in the method below.","While this is correct, I think it's confusing to mix StateMachine, which has its own set of guarantees (e.g., ""nothing happens except if it's in enter, exit, or processmessage""; ""every state is very explicit on the things that an happen in it"") with arbitrary lambdas that run on the handler thread. I think it would be less confusing to define separate CMD_UPDATE_LINKPROPERTIES and CMD_UPDATE_CAPABILITIES messages, and have notifyNetworkConnected send those two before it sends CMD_NETWORK_CONNECTED. Or just have the caller (CS) call the two functions before it notifies NM that the network connected. Yes, it's a little more verbose, but it has the advantage that it maintains the invariants of StateMachine. The new commands only need to be handled in the default state I think.",nit: define a constant instead
"private void breakModifies(ProgressMonitor pm) throws IOException { if (breakScore <= 0) return; ArrayList<DiffEntry> newEntries = new ArrayList<DiffEntry>(entries.size()); pm.beginTask(JGitText.get().renamesBreakingModifies, entries.size()); for (int i = 0; i < entries.size(); i++) { DiffEntry e = entries.get(i); if (e.getChangeType() == ChangeType.MODIFY) { final int score = calculateModifyScore(e); if (score < breakScore) { List<DiffEntry> tmp = DiffEntry.breakModify(e); DiffEntry del = tmp.get(0); del.score = score; deleted.add(del); added.add(tmp.get(1)); } else { newEntries.add(e); } } pm.update(1); } entries = newEntries; }",Non-modify entries should be added back onto newEntries.,"This is horribly slow when entries is an ArrayList, because you have to shift every later cell down on each split. Worse you are splitting everything in this particular case. Make a newEntries that you add items you aren't going to break into, and that way you don't have to modify and shift down the existing entries array.",throw? Seems to me a method private void advanceOrCancel(ProgressMonitor pm) throws CanceledException { if (pm.isCancelled()) { throw new CanceledException(JGitText.get().renameCancelled); } pm.update(1); } and using that instead of pm.update(1) might help.,Just use remove here. Its faster to remove-and-get in one step than it is to get and later do a remove of the same key.,Style-nit: This can be a static method.,Do you want to clear tmp here too?,Better to break after the equal sign.,"bad formatting, you have tabs in this file and we use only spaces",Clear exit conditions should be at the beginning of methods. if (candidates.isEmpty()) { return Collections.emptySet(); },"This is just a nitpicky little detail, but it looks a bit strange to updateDiffStateAdapter just for the first diff. We might want to introduce the method updateDiffStateAdapter(List<Diff>) in the super class, to avoid that. Eventually we'll update the adapter on the comparison anyway, but this might change in the future and then we'd had more control if we'd have dedicated methods for one diff, several diffs, and the comparison.",Should subclasses be allowed to override this method?
"public void sendJsonMessage(String json) throws OperationFailedException { try { assertConnected(); org.jivesoftware.smack.packet.Message msg = new org.jivesoftware.smack.packet.Message(); msg.setType(org.jivesoftware.smack.packet.Message.Type.groupchat); msg.addExtension(new JsonMessageExtension(json)); MessageEventManager. addNotificationsRequests(msg, true, false, false, true); multiUserChat.sendMessage(msg); } catch (NotConnectedException | InterruptedException ex){ throw new OperationFailedException( ""Failed to send JSON message "" + json , OperationFailedException.GENERAL_ERROR , ex); } }",brackets don't match coding style,you could use IOUtils.closeXXX methods instead. This should clean up the code a bit,If this is the expected behaviour you can just ignore the exception or we risk to read the test logs and think that there is some error!,do we still want to reset this if it's a rejoin?,Why isn't this part of the multi-catch above?,I think ServiceDiscoveryManager should be a field of this class.,Please do not swallow exceptions silently.,Mock this also.,Do you think 500 is enough for an average environment?,"""disconnecting""",add message to log
"public static void placeSteamOven(World world, BlockPos pos, List<ItemStack> input, List<ItemStack> output) { MultiBlockPattern pattern = TileSteamOven.patterns.get(0); Map<Character, IBlockState> blockMapping = new HashMap<Character, IBlockState>(); IBlockState base = RailcraftBlocks.getBlockMachineAlpha().getDefaultState(); IBlockState steamOven = base.withProperty(MachineProxyAlpha.VARIANT, EnumMachineAlpha.STEAM_OVEN); blockMapping.put('B', steamOven); TileEntity tile = pattern.placeStructure(world, pos, blockMapping); if (tile instanceof TileSteamOven) { TileSteamOven master = (TileSteamOven) tile; for (int slot = 0; slot < 9; slot++) { if (input != null && slot < input.size()) master.inv.setInventorySlotContents(TileSteamOven.SLOT_INPUT + slot, input.get(slot)); if (output != null && slot < output.size()) master.inv.setInventorySlotContents(TileSteamOven.SLOT_OUTPUT + slot, output.get(slot)); } } }",EnumMachineAlpha.STEAM_OVEN.getState()?,Make the tick delay 0.,Add java player.addStat(StatList.getBlockStats(this)); player.addExhaustion(0.005F);  As those are the lines in the parent classes method that we still want.,split this line into multiple lines pesant,whole switch can be collapsed into pos = pos.offset(EnumFacing),Should definitely check the entity is an instance of Projectile. (example: Modded entities may not be)  java TileEntity tileEntity = source.getBlockTileEntity(); if (entity instanceof Projectile && tileEntity instanceof ProjectileSource) { ((Projectile) entity).setShooter((ProjectileSource) tileEntity); } return world.spawnEntityInWorld(entity);,I suspect they just ask the master,"Flip the if statement, please.",This block of code is repeated three times - maybe move it to a method that can be called from all places?,Irrelevant change I'll do this myself.,"This does not work like you think. setFireInfo sets the fire info for all forestry hives because all forestry hives have the same block instance. You have to implement the methodsgetFlammability, getFireSpreadSpeed and isFlammable in the class of the hive block."
"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (obj instanceof ErrorPage) { ErrorPage other = (ErrorPage) obj; boolean rtn = true; rtn = ObjectUtils.nullSafeEquals(getExceptionName(), other.getExceptionName()); rtn = rtn && ObjectUtils.nullSafeEquals(this.path, other.path); rtn = rtn && this.status == other.status; return rtn; } return false; }","Thanks for the suggestion. Rather than assigning rtn on 117 and then again on line 118, the two could be combined:  boolean rtn = ObjectUtils.nullSafeEquals(getExceptionName(), other.getExceptionName());",Can't we just assume that content and other fields are equal when the nodeId is equal?,"Unless a good reason for this, the following is considered more correct:  java if (getClass() != obj.getClass()) { return false; }",... two non-equal objects can have the same hashCode! :(,why are we setting the hashtag here? Shouldn't equals be read-only?,Can you add the curly brackets to the if calls.,"what about the more readable: return Objects.equal(leftTraversal, other.leftTraversal) && Objects.equal(rightTraversal, other.rightTraversal) && Objects.equal(originTraversal, other.originTraversal)",Why U don't want to consider id in equals and hashCode ?,It's a common patteen in equals method. Use == here (.equals) is used later,"I don't think we can change the behaviour of equals() like this. This class is part of the public API and changing equals() to no longer consider fields that were already in the object is a breaking change. Instead, I to handle this case where the route objects are ""the same but with different properties"", I think we should add another method such as isSameDestinationAs(). This is consistent with what we have done in other classes such as LinkAddress, where everything is checked in equals(), but there is another method that checks whether an object is ""the same as but with different properties"". (In the case of LinkAddress that is called isSameAddressAs.) Also, this should check the MTU.","Is there a reason why the equals method is not fully implemented? It's returning false for separate object instances that contain the same description and value, but it should return true. Your IDE should be able to generate it for you."
"protected boolean shouldNotFilter(HttpServletRequest request) { final HttpSession session = request.getSession(false); if (session != null && !session.isNew()) { log.debug(""User {} has a session: {}"", request.getRemoteUser(), session.getId()); log.debug(""Max inactive interval: {}"", session.getMaxInactiveInterval()); final Instant ctime = Instant.ofEpochMilli(session.getCreationTime()); final Instant atime = Instant.ofEpochMilli(session.getLastAccessedTime()); log.debug(""Session creation time: {}, last access time: {}"", ctime, atime); return true; } else { log.debug(""User {} does not have a session"", request.getRemoteUser()); } return REST_API_SERVLET_PATH.equalsIgnoreCase(request.getServletPath()); }",Consider wrapping lines 47 - 49 in a log.isDebugEnabled() conditional.,"Extract the ""USER_ID"" to a constant and make it more unique. The HttpSession can be accessed ""everywhere"" in a servlet container. For example: ""org.everit.jira.timetracker.plugin.user.id.hash"".",Use parameterized log statements. See the one right below this.,Instead of doing this can you just not setup/run maintenanceTimer if it is a consumer app?,You should always generate message after the process is done. You can prevent unexpected issues.,you don't need this here^,add principal name to message?,you must begin all in if already authenticated so you do nothing....,"While it's more verbose (and we didn't do it in the code where it used to live), it might be more clear/correct to do this is session.setMaxInactiveInterval(TimeUnit.MINUTES.toSeconds(expirationTime));","Does this cope with the case ""The previous session ended in a crash. In other words, one session can only have 1 crash at most."" in the project definition? Should we also check if there have been unhandled errors?",null credentials and demo credentials is not the same case
private VolumeType getType() { if (!getStorageDomain().getStorageType().isOpenStackDomain() && getParameters().getVolumeFormat() == VolumeFormat.RAW) { return VolumeType.Preallocated; } return VolumeType.Sparse; },"This is very fragile, and will break when we add new storage type. Better check for the storage types (block or file?). Also, this change is possible only when creating volumes with vdsm supporting deferred preallocation, or it may cause very bad performance regression when creating big raw images. This is probably not the place to do these checks, we probably need to modify the code creating new volumes, or the code creating and copying volumes.","Surround with (): (volumeFormat == VolumeFormat.RAW && diskBackup == DiskBackup.Incremental) similar to 1 line below. Although not required due to the operators' precedence, will help in readability and might save from bugs in the future.",I'd add an isLocal() method to the StorageType enum and have this return getStorageType.isLocal(),storageType can be initialized inside the if command since it is only used for storage type V2,"1. i don't think this should be based on the ""potential"" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.","The call to ""getState().toUpperCase()"" here may generate a NPE. You need to check that it has a value befor using it.",Let's future proof the code: if (storageFormat.compareTo(StorageFormatType.V3) >= 0),"What if instead, you throw a cloud runtime with a message describing the problem/error here?","Reverse the order, isFileDomain first then Preallocated then FeatureSupported",return SUPPORTED_INPUT_FORMATS.contains(inputFormat);,you can use Schema's isNullable and getNonNullable methods to help out here.
"private void addVersionAndBranchTags(String remotePath, CVSTag[] tags) { TagCacheEntry entry = getTagCacheEntryFor(remotePath, true); entry.accessed(); for (int i = 0; i < tags.length; i++) { if (tags[i].getType() != CVSTag.DATE) { if (!getAllKnownTagsForParents(entry).contains(tags[i])) { removeTagFromChildrenCacheEntries(entry, tags[i], false); entry.tags.add(tags[i]); } } } }","It's not safe, because if this was the last tag for this entry, this entry will be removed, but I understand you don't like the boolean in the signature of the method. I changed the method that it always removes tags only from children and where it's necessary I added removing the tag from current entry. Should be more clear now.",Use #isEmpty.,Use #isEmpty(),"Yes, even if we add empty set of tags the entry is treated as accessed. I don't think it's correct.","Shouldn't the second condition be ""entry.parent.children.isEmpty()""?",We have to have a submonitor in case we need to pass it to #getTopLevelFoldersForChildren. I can avoid it by if'ing larger amount of code and create a submonitor only if we are dealing with Branch.,Change to unmodifiableSet if we switch to a set. suggestion return Collections.unmodifiableList(tags);,"builder.append("","").append(tag.GetTagNameAndChildrenNames());",I would retain the existing indexOf body to to avoid indirection in the most common case.,"I think this would be better off being @Intrinsic and calling through to the original method so it doesn't interfere with other vanilla calls.  @Intrinsic public boolean entity$addTag(final String tag) { Objects.requireNonNull(tag, ""tag""); return this.shadow$addTag(tag); }  The difference between this method and that one is that you return the result of Set#add, vanilla just returns true - is it a problem if addTag just reports whether the entry is in the set, which it will be if it reports true, regardless?","Please use Verbs.gather instead of ""Gather"" here"
"public QueryResponse getSpecies() throws IOException { Properties properties = new Properties(); properties.load(DBAdaptorConnector.class.getResourceAsStream(""/eva.properties"")); return setQueryResponse(archiveEvaproDbAdaptor.getSpecies(properties.getProperty(""eva.version""), true)); }",Is there a need to read the prop file for every request?,"This is a bug in the build system, not the code.",getOrDefault is not available in Java 7.,"We can insert "" ""s for the above statement, though super minor.","I see you do not use this anywhere, so remove?",The VXQueryApplication shouldn't have to be instantiated explicitly. The ClusterController should start it.,Just leaving a note. So far we haven't discussed anything about host-level quotas. But this is something that we need to configure after running a redliner test on Ambry frontends.,Do we need any printStackTrace() here?,This could probably be simplified with try-with-resources,"what about moving this logic:  return JAXB.unmarshal(QuickModelInfoProvider.class.getResourceAsStream(""/gov/healthit/qdm/qdm-modelinfo-5.0.xml""), ModelInfo.class);  under case ""5.0"": and then making the logic under default: be an error. This way, if you get an unsupported version, you can fail gracefully.",Add check that non-null
"void messageConsumptionCycle() { while (!killed) { long incrementedClock = 0; UpdateMessage message = null; if (!internalMessageQueue.isEmpty()) message = internalMessageQueue.removeFirst(); else synchronized (externalMessageLock) { if (!externalMessageQueue.isEmpty()) { message = takeExternalMessage(); } else { incrementedClock = ++clock; } } if (message == null) { localUpdateTermination(incrementedClock); while (message == null) { synchronized (externalMessageLock) { while (externalMessageQueue.isEmpty()) { try { externalMessageLock.wait(); } catch (InterruptedException e) { if (killed) return; } } message = takeExternalMessage(); } } } message.receiver.update(message.direction, message.updateElement, null); } }",Marking this as a high-priority functional correctness issue.,if(numToAdd <= 0)?,getTracker could be saved into a field so that we do not have to fetch it for each tuple going through the mailbox...,"given we have only one thread locking reentrant lock, why we unlock only after nextFinish time ?",This will suck up an entire CPU (with PersistentQueue) until a message is available or the timeout occurs.,"Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.","Odd spacing. Also maybe it might be more terse as ""exceeded Configuration messageLimit of {0}""?","wouldn't these two lines be cleaner and also slightly faster if, in absence of a separate Adapter node, the field adapter would simply default to this (declared as protected Mailbox adapter = this)?",if 'this' thread already owns the lock and attempts to acquire it again we'll get wrong logging here. the log is correct only if the lock is acquired by other thread (use !isHeldByCurrentThread()).,"Should this also check for wakelock.isHeld(), since you are doing that before you call release() in acquireWakeLock?",Can you be stuck here forever if someone keeps adding things to the pool?
"public boolean equals(Object o) { if (this == o) { return true; } if (o == null || o.getClass() != getClass()) { return false; } PeriodBroadcastDistributionRule that = (PeriodBroadcastDistributionRule) o; if (!Objects.equals(period, that.period)) { return false; } if (!Objects.equals(includeFuture, that.includeFuture)) { return false; } return Objects.equals(colocatedDataSources, that.colocatedDataSources); }",includeFuture can't be null. if (includeFuture != that.includeFuture)?,Should have hashCode overridden too so it is consistent with equals.,Override hashCode too,same problem with when !has*,The use of Equal.equal would really help here to take advantage of type inference.,Extra blank line,"Two TimeAndDims might have dims of different length so I think this could cause an out of bounds array access on that.dims[i]. This also doesn't check types at all but the Comparator for sorted facts does check types. The equals impl could do return dimsComparator.compare(this, that) == 0 although this does some needless name lookups.",Use another example of expression than a return statement... That example is hard to follow.,suggestion if (o instanceof PredicateEvaluator) {,partitionKey?,Need to update equals and hashcode?
"protected HttpClient createHttpClient() throws Error { int port = getPort(); Lookup<AuthSchemeProvider> authSchemeProvider = null; CredentialsProvider credsProvider = new BasicCredentialsProvider(); AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME); if (user != null && user.length() > 0) { credsProvider.setCredentials( authScope, new UsernamePasswordCredentials(user, password) ); } else if (kerberos) { authSchemeProvider = RegistryBuilder.<AuthSchemeProvider>create() .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory(true)) .build(); credsProvider.setCredentials( authScope, new Credentials() { @Override public Principal getUserPrincipal() { return null; } @Override public String getPassword() { return null; } } ); } RequestConfig globalConfig = RequestConfig.custom() .setCookieSpec(CookieSpecs.IGNORE_COOKIES) .setConnectTimeout(timeout) .build(); HttpClientBuilder clientBuilder = HttpClientBuilder.create() .setConnectionManager(new BasicHttpClientConnectionManager(createConnectionSocketFactoryRegistry())) .setDefaultRequestConfig(globalConfig) .setDefaultCredentialsProvider(credsProvider) .setDefaultAuthSchemeRegistry(authSchemeProvider); if (!compress) { clientBuilder.disableContentCompression(); } return new HttpClient45(clientBuilder.build()); }",Why is this needed?,"Is null/empty password valid? If not, should we check both for username and password not to be null (or empty)? If only username or password is null/empty, should it be logged (WARN)?",Why is this needed?,I think that timeout should be its own setting,I would inline initializeConfigs (if it is used in single place) and getConfiguration here,"could you please move it to the constructor? configure is for dynamic things like the admin password, everything else should be configured in the constructor, so that it can be overridden externally without extending the class",It is being calles inside the UserGroupInformation.setConfiguration. Please remove that. <LINK_0>,nit: Maybe Connecting to kudu with kerberos authentication?,Please retain the ability to clear the credentials by calling with null username and password,if we implement this it should be optional and retry number/time between retry configurable.,"We are already in an instance of this object and yet the method you are calling creates a new one just to call a method that is already defined here. This leads to un-necessary object creation, plus the cache used is different then this one which means that the property are reloaded multiple times. This applies to all your static methods you use like this. May I suggest that you provide and internal non-static method for those and that your static version (if still used outside of this class uses that one after creating a dummy instance)."
"public void bindPubSubProducer(String name, MessageChannel moduleOutputChannel, Properties properties) { validateProducerProperties(name, properties, SUPPORTED_PUBSUB_PRODUCER_PROPERTIES); RabbitPropertiesAccessor accessor = new RabbitPropertiesAccessor(properties); String exchangeName = applyPrefix(accessor.getPrefix(this.defaultPrefix), name); declareExchangeIfNotPresent(new FanoutExchange(exchangeName)); AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(determineRabbitTemplate(accessor)); endpoint.setExchangeName(exchangeName); endpoint.setRoutingKey(name); configureOutboundHandler(endpoint, accessor); doRegisterProducer(name, moduleOutputChannel, endpoint, accessor); }","Wouldn't you want this to be a TopicExchange as well, instead of a FanoutExchange?","FYI, I [just fixed a bug in XD](<LINK_0> - over there, we only have one DLQ for all partitions, not a DLQ for each partition. Having a DLQ for each partition might be a bit of overkill, given that we can get the originating partition from a header, especially with a large number of partitions. Not necessarily something for this PR, but something to think about, perhaps.",not sure why we need this to be asynch (QueueChannel),these properties should really be mutually exclusive (validated within the props?): - partitionKeyExpression OR partitionKeyExtractorClass - partitionSelectorExpression OR partitionSelectorClass,"enableStatus aims to ""start logging once we add the first 'element' in the store ?",M-m-m. How this exception can be possible here if we have done provisioning already a bit before via  this.provisioningProvider.provisionProducerDestination()? Maybe the idea was to include that call to the try...catch as well? Thanks,"rethrow these as runtime errors, I think. If we can't connect to the channel we should crash here rather than in a separate thread. Note that the producer error handling probably needs some tender loving care.","Please check if we have a method to get the default value if it is null, so that we can avoid the null check at L160","Let's add this later in ActiveTaskCreator class instead of here, also I'd suggest we use the clientId + thread-id-suffix (the thread-name should be in the form of clientId + ""-StreamThread-"" + threadIdx so it's easy to parse out the middle -StreamThread- part) instead of UUID. In practice if client-Id is not set it would default to UUID-suffixIndex. But by comparing the log we have the clear clue which transaction id belongs to which thread, while just another random UUID did not reveal us anything.",can be final field of this class,No this. on method calls.
"private List<KeyRange> getRegionRowKeyRanges() throws SQLException { List<HRegionLocation> regionLocations = getRegionBoundaries(scanGrouper); List<KeyRange> regionKeyRanges = Lists.newArrayListWithExpectedSize(regionLocations.size()); for(HRegionLocation regionLocation : regionLocations){ HRegionInfo regionInfo = regionLocation.getRegionInfo(); KeyRange range = KeyRange.getKeyRange(regionInfo.getStartKey(), true, regionInfo.getEndKey(), false); regionKeyRanges.add(range); } return regionKeyRanges; }","Could you change ""for("" to ""for (""? Other places too.",Add some keys with strings in key ranges?,"What if there's already a Filter on that scan (such as if we're rebuilding a view index). I _think_ that's OK, because we generated our key list for the SkipScanFilter using the pre-existing view filter on incrScan which we got from the original rebuild Scan, but let's make sure we test and are really sure about that.",Why not return the collection itself instead of converting it to array?,Can we make this a list since it should be sorted.,Should the scanner be closed after the call ?,"Since the scan we use for this scanner is not a raw scan, we should not get any delete cell. We should trow an exception if the type of the cell is not put.",getMembersForEachRegion can be private until you need to make it @VisibleForTesting. Currently there's no test using the method though.,This will probably be permanently unsupported.,!regions.isEmpty()?,I think we can have an ExecutionPipelinedRegion interface which inherits the PipelinedRegion interface. Similar to Topology -> SchedulingTopology. The SchedulingStrategy should operate on ExecutionPipelinedRegion instead. Note that we already have a LogicalPipelinedRegion and I think we should also rework it. Then this method does not need to be default since LogicalTopology can also return logical regions (we already have this method implementation).
"public void handleDelete(ActionParameters params) throws ActionException { final User user = params.getUser(); final long id = ConversionHelper.getLong(params.getRequiredParam(PARAM_ID), -1); if (!service.canModifyCategory(user, id)) { throw new ActionDeniedException(""Tried to delete category: "" + id); } try { layerService.delete(new long [] {id}); } catch (ServiceException e) { LOG.warn(e); throw new ActionException(""Failed to delete layers""); } AuditLog.user(params.getClientIp(), params.getUser()) .withParam(""id"", id) .deleted(AuditLog.ResourceType.MYPLACES_LAYER); JSONObject response = new JSONObject(); JSONHelper.putValue(response, KEY_SUCCESS, true); ResponseHelper.writeResponse(params, response); }",Prefer ActionParameters.getRequiredParamLong(PARAM_ID) instead. If the id is not a long we don't want to fail with ActionDeniedException but with a ActionParamsExcepton instead.,Should check if the Counterparty that should be deleted belongs to the logged AppUser,"If a user has ROLE_ACB and ROLE_ATL I think this won't work as desired? I know that's super unlikely. But if they do, I think the if/else if's need to be changed around a bit.","Again, I'd prefer more descriptive errors here as to why the group cannot be deleted.",Maybe it would be good to be consistent with MigrationResource and return the deleted entity in a response here as well.,"If these parameters are not set in the request do we want to replace current values? If not could call userLayer.setLayer_name(params.getHttpParam(PARAM_NAME, userLayer.getLayer_name());","This should be Integer, not int to match the type on line 57. If this tries to return null an error will occur because int can't be null (but deleteByUserId can)",It would be easier to instantly see whats going on if there was a method deleteLayersForProvider() and removeProviderFromLayers() which would be called based on the boolean. After the conditional statements you could call deleteDataProvider() that would return the removed provider. Then you could write the response based on that in handleDelete.,"If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt(""id"") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.","By right, soft deletion should not result in InvalidParametersException","- Here you are using Integer.parseInt to get the numeric ID value. In method addToClient you are using Integer.valueOf. Maybe you can change one to the other? - Both methods are throwing a NumberFormatException  and this code is in frontend classes, you should handle this."
"private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) { Set<LoadBalancer> loadBalancers = new HashSet<>(); Set<TargetGroup> targetGroups = new HashSet<>(); if (StackType.DATALAKE.equals(source.getType())) { LOGGER.info(""Setting up load balancers for stack {}"", source.getName()); Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack); Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream() .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName())) .collect(Collectors.toSet()); if (!knoxGatewayGroups.isEmpty()) { LOGGER.info(""Knox gateway instance found; enabling Knox load balancer configuration.""); TargetGroup targetGroup = new TargetGroup(); targetGroup.setType(TargetGroupType.KNOX.name()); targetGroup.setInstanceGroups(knoxGatewayGroups); targetGroups.add(targetGroup); knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup)); } } if (!targetGroups.isEmpty()) { LoadBalancer loadBalancer = new LoadBalancer(); loadBalancer.setStack(stack); loadBalancer.setType(LoadBalancerType.PRIVATE.name()); loadBalancer.setTargetGroups(targetGroups); targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer)); loadBalancers.add(loadBalancer); } return loadBalancers; }",Should this be in an entitlement?,"I think it would be useful to add some extra log lines, as there are a several if and it would help us investigate later","Just checking, will the aws API ever return a null for this, or is it just an empty string when there are no more pages? If it's possible there might be a null, I'd opt for !Strings.isNullOrEmpty() here",Using if-else instead of if-continue?,"To be safe, we should make sure this logic isn't triggered if the DNS for the load balancer couldn't be registered. (See the else statement directly above this).","we've had problems in the past with hitting aws' api rate limits. Rather than making an individual call for each (even though it is filtered down), it might be wise to move this outside of the loop. We can describe all ALBs in one call, then grab what we need from the object. It's likely faster to loop through the object in memory than to make a new call for new data.",Please remove the if here and use the composite pattern to determine the specific cloud-api that is needed to delete the prerequisites. Move every azure specific implementation to the cloud-azure module.,I would use FlowLogDBService#findAllByResourceIdAndFinalizedIsFalseOrderByCreatedDesc here as it would spare some resources: - won't fetch db again for the environment - you could loose the finalized check in the next if - you could loose try-catch and use isEmpty instead,"nit : which -> with ""We can not read the host project with id""","same here, code shouldn't reach this part if flow is running",log would be nice here
"public static void sendGeoIntent(@NonNull Activity activity, @NonNull Location location, String placeName) { String geoStr = ""geo:0,0?q="" + location.getLatitude() + "","" + location.getLongitude(); if (!TextUtils.isEmpty(placeName)) { geoStr += ""("" + placeName +"")""; } try { activity.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(geoStr))); } catch (ActivityNotFoundException e) { FeedbackUtil.showMessage(activity, R.string.error_no_maps_app); } }","If we end up going with this solution, please call Uri.encode on this appended label string (as directed in <LINK_0> Also, please add a space after the second '+' to resolve the checkstyle failure in CI.",I think this can just be removed.,This is fine as a Log.e as it's indicating an error.,"This is going to be removed anyway, but it'd have been better if we did this after if (place == null) since we are nullifying the mPostLocation in that if anyway.",catch more specific exception and it is good idea to log the exception,"Missing the -... ex: pt-BR Now that i look into it, is it a - or a _? I believe it's a -. One more reason to use the default functions",suggestion mLikelyPlaceAttributions[i] = placeLikelihood.getPlace(),"I don't like accessing these values inside a try catch. These values _should_ always be set, and if they're not its a failure of our build tooling. Because this is a tricky bug to spot, I'd rather it fail in a noticeable way if we have an incorrect configuration, not fail in a silent way.",Typo - should be Received.,What if location is null?,"This still needs to be here, in case PAPI loads before EssentialsX - in that instance, Essentials won't receive PAPI's PluginEnableEvent."
"protected void delete(Context context, Integer id) throws AuthorizeException { try { MetadataSchema metadataSchema = metadataSchemaService.find(context, id); if (metadataSchema == null) { throw new ResourceNotFoundException(""metadata schema with id: "" + id + "" not found""); } metadataSchemaService.delete(context, metadataSchema); } catch (SQLException e) { throw new RuntimeException(e.getMessage(), e); } }","Again, getMessage() should be replaced with a more informative error","Again, getMessage() can return null. Please replace with a more informative error message.",More useful error message please,"Change to something like: throw new RuntimeException(""Unable to find Community with id="" + id, e);","I'd prefer to log a more descriptive error (again e.getMessage() can be null). Maybe this should be: log.error(""Error deleting Relationship specified by ID:"" + id, e);",We should turn the auth system back on after creating the test data.,"same here, should be thrown from within the service in my opinion",We should turn the auth system back on after creating the test data.,"Again, I'd prefer more descriptive errors here as to why the group cannot be deleted.",Is there a need for a separate delete function here? The configurable workflow handles this as the result of an action,I don't think we need this catch - this is handled by the boolean return value.
"public ScoredCandidates<T> generate( T content, ResultDescription desc, EquivToTelescopeResults equivToTelescopeResults ) { DefaultScoredCandidates.Builder<T> candidates = DefaultScoredCandidates.fromSource(""Alias""); desc.startStage(""Resolving aliases:""); EquivToTelescopeComponent generatorComponent = EquivToTelescopeComponent.create(); generatorComponent.setComponentName(""Alias Equivalence Generator""); for (Alias alias : content.getAliases()) { desc.appendText(alias.toString()); } desc.finishStage(); Set<T> resolvedContentForAliases = content.getAliases().parallelStream() .filter(alias -> namespaceToMatch == null || alias.getNamespace().equals(namespaceToMatch)) .map(this::getLookupEntries) .flatMap(MoreStreams::stream) .map(this::getResolvedContent) .map(ResolvedContent::getAllResolvedResults) .flatMap(MoreStreams::stream) .filter(cls::isInstance) .map(cls::cast) .collect(MoreCollectors.toImmutableSet()); for (T identified : resolvedContentForAliases) { if (java.util.Objects.equals(content.getId(), identified.getId())) { continue; } if (identified.isActivelyPublished()) { candidates.addEquivalent(identified, Score.nullScore()); desc.appendText(""Resolved %s"", identified.getCanonicalUri()); } } equivToTelescopeResults.addGeneratorResult(generatorComponent); return candidates.build(); }","Shouldn't the description be a bit more specific, e.g. which alias matched, and the stage finished at the end of the process?",suggestion List<String> lookupUris = MoreStreams.stream(lookupEntries) .map(LookupEntry::uri) .collect(MoreCollectors.toImmutableList);,you can just do a straight return rather than assigning to an intermediate variable (and then you don't need the curlys),isn't there a risk of losing an alias through this? wouldn't just removing alias be safer?,Is it worth defineing this as a separate NullResultDescription class that can be used by other tests?,Just pass in the name variable to this,"you can use  return CollectionUtils.map(""inode"",contentlet.getInode(),""languageId"",contentlet.getLanguageId()+"""");","Let's not merge aliases, let's overwrite them. Otherwise we'll not remove if they change.","If Deer just call it ""Deer Title Search Generator"" in all cases in my opinion",This function always returns null? That doesn't seem right.,"The ResolutionExceptions thrown here are lacking the information from definition.getOrigin(). The type TargetDefinitionResolutionException is not (any more) referenced outside this class, so it can in fact be replaced by a different type, or made class private. But the message should not get less useful."
"private void updateQcowCompat() { if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) { getImage().setQcowCompat(QcowCompat.QCOW2_V2); if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) { QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), false); if (qemuImageInfo != null) { getImage().setQcowCompat(qemuImageInfo.getQcowCompat()); } imageDao.update(getImage().getImage()); } } }",consider extracting to a method as this code is similar to BaseImagesCommand. have a nice day :),"IIUC, this will return the compat version from the export domain, that by definition will be 0.10. Wouldn't we want to force the proper compat version based on the target domain?","the update is unneeded, the method is called before the disk is saved in the db in line 131.","shouldn't this be ""!="" ?",1.can we have those two conditions in setQcowCompat() to avoid repeating them? 2. if not - let's have them in one in condition with &&.,It is a matter of personal preference so take it or leave it :) I would use a method isQuotaStausChangedToDisable() and write the if condition inside just makes the code easier to read.,"Very unreadable, please extract to a boolean with a meaningful name",Please consider to extract to a different method (like isInternalManagedDisk),Is it necessary to return the parameter?,what about support for upgrade from v2 to v3? v1 to v3?,"Consider using ""final"" for local variables."
"public void testNotEnoughForMultipleDiskAndDomainsFirstDomainFails() { ArrayList<DiskImage> imagesDisks = mockMultipleSourceImagesForDomain(4, STORAGE_DOMAIN_ID, 4); imagesDisks.addAll(mockMultipleSourceImagesForDomain(4, STORAGE_DOMAIN_ID2, 4)); doReturn(imagesDisks).when(cmd).getSourceImages(); mockStorageDomainDAOGetForStoragePool(15, STORAGE_DOMAIN_ID); mockStorageDomainDAOGetForStoragePool(22, STORAGE_DOMAIN_ID2); assertFalse(""Validation should fail. First domain should not have enough free space for request."", cmd.isEnoughSpaceToMergeSnapshots()); }",can't this be defined as a List<DiskImage> ?,any difference between this test and the previous one?,No.,Please use Collections.singletonList(),Perhaps consider to change the message so it will indicate that domain2 has not enough available disk size to pass the threshold check.,Please replace this assert with a CanDoActionTestUtils call.,Please use Collections.singletonList(),"This is redundant AFAIK - it should be Mockito's default behavior. If it isn't, use Collections.emptyList(), not the raw EMPTY_LIST.",please extract the expect result (12) to a constant. +2 for the rest.,"Since the project already introduced the ValidationResultMatchers class for validity assertion, wouldn't the following will be preferred ? assertThat(result, isValid());",Why not Collections.emptyList() ?
"private boolean executeOnce(final int thisTryNumber, final int totalTriesIntended) { final Connection sshConnection = new Connection(parent.host, parent.port); try { sshConnection.connect(null, sshTimeoutMillis, 0, sshTimeoutMillis); LOGGER.info(""SSH port is open on {}:{}"", parent.host, parent.port); return true; } catch (IOException e) { LOGGER.error(""Failed to connect to {}:{} (try {}/{}) - {}"", parent.host, parent.port, thisTryNumber, totalTriesIntended, e.getMessage()); return false; } finally { sshConnection.close(); } }","While I agree that passing a non-zero value as the connectTimeout argument is a good idea, I don't believe that passing 0 as the readTimeout argument is a good idea. I think that passing zero anywhere will _either_ result in ""no timeout"" or ""a timeout of zero"" and both outcomes are bad (one results in non-robust code, the other results in the situation you reported & are trying to fix).",Move the logic to the [ExecResponse constructor](<LINK_0> This way the approach would be ssh driver agnostic.,maybe it makes sense to suppress other exceptions (runtime&Co),shall we add a debug log here for the expiry time set,why removed these two lines,GerritDefaultValues.DEFAULT_GERRIT_SSH_CONNECTION_TIMEOUT I guess?,I would prefer for (int count = 0; count <= retryCount; count++),if interrupted and not rethrown as a good practice the flag should be set up back to the thread Thread.currentThread().interrupt(); _I'm not going to write this request on other places where it should be included_,"when upgrading slaveConnectTimeout won't be in the object, so it will get set to 0 IIRC You need to handle it in readResolve to set it to the default, or here to return the default if it is 0",I think these extra try catch blocks are unnecessary,"Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?"
"private OnHeapValueHolder<V> invalidateInGetorComputeIfAbsent(MapWrapper<K, V> map, final K key, final ValueHolder<V> value, final Fault<V> fault, final long now) { final AtomicReference<OnHeapValueHolder<V>> toInvalidate = new AtomicReference<OnHeapValueHolder<V>>(); map.computeIfPresent(key, new BiFunction<K, OnHeapValueHolder<V>, OnHeapValueHolder<V>>() { @Override public OnHeapValueHolder<V> apply(K mappedKey, final OnHeapValueHolder<V> mappedValue) { if(mappedValue.equals(fault)) { try { toInvalidate.set(cloneValueHolder(key, value, now, Duration.ZERO, true)); } catch (LimitExceededException ex) { throw new AssertionError(""Should have already been thrown.""); } invalidationListener.onInvalidation(key, toInvalidate.get()); return null; } return mappedValue; } }); return toInvalidate.get(); }",That message is confusing. Just say that it should not be thrown here as sizing is not happening.,"Here, not sure about the now... given it's in a conditional compute, which way would be best?","These few lines are repeated all over the place and in the AbstractOffHeapStore as well. So they should be extracted. What is also interesting is that none of this requires the context of this class, so it would be a valid candidate for a method on CachePassThroughException.",I don't think the size should be recalculated when the mapping gets evicted/removed/expired. This should be stored somewhere like in the ValueHolder.,"Code style preference ... but I'd rather stick with the explicit else. If someone was to screw up the if branch to no longer return, this would compile fine. The previous version would fail saying that there is a missing return statement.","Still believe this whole block can be hidden inside a method. Also your first version had many more locations where equivalent code was called, but you changed to a version that no longer notifies. I believe the initial version was more _correct_ just needed some refactoring to extract duplication.",Quite a number of the changes here are the same. Refactor into a new method like setAccessTimeAndExpiryThenReturnMapping which clarifies intent and includes expiration notification when needed. Then you can have the few places where it happens differently still invoke a refactored setAccessTimeAndExpiry.,"I might be wrong but vValueHoder may itself be a null, if there was no mapping for the key.",I think it'd be a bit cleaner to move the value type check into nullSafeValueHolder.,Couldn't the soft reference be freed between the twice calls to get()? Shouldn't we use a safe programming style and safe the current reference? Java final V valueCur = value.get(); if (valueCur == null || isExpired()) { return refreshValue(); } else { retturn valueCur; },"This method seems a little weird. I think this new wrap() method that takes (K, OnHeapValueHolder) should return the anonymous implementation of Cache.Entry. The existing wrap() method that takes Map.Entry should call this one pass the entry key and value."
"public String toResponse() { if (selectionSet instanceof String) { return String.format( ""\""%s\"":%s"", getName(), getSelectionSet().toString().equals("""") ? ""{\""edges\"":[]}"" : getSelectionSet().toString() ); } else if (selectionSet instanceof Number) { return String.format( ""\""%s\"":%s"", getName(), getSelectionSet().toString().equals("""") ? ""{\""edges\"":[]}"" : getSelectionSet().toString() ); } else { return String.format(""\""%s\"":%s"", getName(), ((SelectionSet) getSelectionSet()).toResponse()); } }",Can we combine this case with the one above? if (selectionSet instanceof String || selectionSet instanceOf Number),"How about ""array("" + elementAdapter + "")""",I still recommend to put here human friendly text.,"@yesamer I think it would be clearer to and an ""else"" statement, or to create two different methods. Wdyt?",classExample.equals(Boolean.class),Isn't the current default quotes_and_brackets? If so should we preserve this?,We shouldn't be building the JSON manually -- look into the other toJson methods and construct JsonArrays and JsonObjects before going toString on them,Any reason not to use the simpler JSONUtils.serializeAsString(Map)?,suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better,Typed iterator,orElseGet should be used here.
"public <A extends Annotation> ConstraintValidator<A, ?> getInitializedValidator(Type validatedValueType, ConstraintDescriptorImpl<A> descriptor, ConstraintValidatorFactory constraintFactory) { Contracts.assertNotNull( validatedValueType ); Contracts.assertNotNull( descriptor ); Contracts.assertNotNull( constraintFactory ); final CacheKey key = new CacheKey( descriptor.getAnnotation(), validatedValueType, constraintFactory ); if ( constraintValidatorCache.containsKey( key ) ) { @SuppressWarnings(""unchecked"") ConstraintValidator<A, ?> constraintValidator = (ConstraintValidator<A, ?>) constraintValidatorCache.get( key ); if ( DUMMY_CONSTRAINT_VALIDATOR.equals( constraintValidator ) ) { return null; } else { log.tracef( ""Constraint validator %s found in cache."", constraintValidator ); return constraintValidator; } } ConstraintValidatorDescriptor<A> validatorTypeDescriptor = findMatchingValidatorClass( descriptor, validatedValueType ); ConstraintValidator<A, ?> constraintValidator = createAndInitializeValidator( constraintFactory, validatorTypeDescriptor, descriptor ); if ( constraintValidator == null ) { putInitializedValidator( validatedValueType, descriptor.getAnnotation(), constraintFactory, DUMMY_CONSTRAINT_VALIDATOR ); return null; } else { putInitializedValidator( validatedValueType, descriptor.getAnnotation(), constraintFactory, constraintValidator ); return constraintValidator; } }",validatorDescriptor would be nice to be consistent with the naming a few lines below.,Maybe we should pass the ValidationContext to the ConstraintValidatorManager thus allowing to delay the context creation to where we need it. That would help avoiding creating the context if not strictly required (i.e. only create the context if we use the new initialize() method).,@marko-bekhta I just noticed this change. What does it have to do with this patch?,"Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?",Maybe remove the OrConstrained here too?,"Shouldn't it be just type here? Or perhaps extractedType. After all, it can be the constraint type _or_ the validator type.","I used to do this a lot, but now i don't think it is right to unwrap. <LINK_0>",Why not just getValueExtractor()? It's used for type parameter constraints and cascaded validation.,Should you also check for isBeanConstrained and cache that?,"Please add a check Objects.requireNonNull(supplier, ""supplier is null"");",Please put spaces around :
private static JAXBContext initOnmsEventParameterContext() { try { return JAXBContext.newInstance(EventParms.class); } catch (JAXBException e) { e.printStackTrace(); } return null; },Lets re-throw this as a RuntimeException instead.,This is printed out once on class loading? We can prettify later.,Better to log instead of e.printStackTrace,Can we use the logger here and/or rethrow the exception instead of printing the stack trace?,"I am wondering if we could avoid using e.printStackTrace() here: - If I understand correctly, the schema should always be available, so we might be able to just throw a (runtime) exception here to avoid a NPE later. - If it is expected that the schema creation may fail (and we do not want to fail the static initializer by throwing an exception), the exception e could be just logged. What do you think?","Sorry, how changing visibility makes caching?",Should this be System.err instead?,"This would put a hard dependency on woodstox in the logging module. I believe the better option would be to catch RuntimeException and check the cause to see if the cause is a XMLStreamException. If not, rethrow the RuntimeException, otherwise treat it like the XMLStreamException.",kill the default (provider) method and inline here,technically if you're PrintWriter throws the exception your StringWriter will never be closed :-),should we add a more detailed log and set currentProductVersion to null
"public RemoteCounterManagerTest() { testImpl = new CounterManagerImplTest(this::allTestCounterManagers, this::log, this::cacheManager); }","fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)",Do we really need a snapshot manager here? I think it's not necessary. Please remove TODO,"this test is failing in JpaStoreFunctionalTest. I believe you have to use String in the keys and wrap the value using wrap(""k1"", ""v1"")","While I am not denying the setter is confusing, this is not the scope of this PR to change that.",do you have any trouble with array initializers?,That can't compile anymore.,"You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).",we need to specify this all the time to make it work now ?,"Do we really need to specify near, backups, and atomicity mode here?","A good opportunity to not hardcode the port here, but rather use findFreePort()","This method should return RemoteCache<K, V>."
"private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) { if (!s1.getReadName().equals(s2.getReadName())) { throw new PicardException(""Read names do not match: "" + s1.getReadName() + "" : "" + s2.getReadName()); } catalogDuplicateDifferences(s1, s2); final AlignmentComparison comp = compareAlignmentRecords(s1, s2); switch (comp) { case UNMAPPED_BOTH: ++comparisonMetric.unmappedBoth; break; case UNMAPPED_LEFT: ++comparisonMetric.unmappedLeft; break; case UNMAPPED_RIGHT: ++comparisonMetric.unmappedRight; break; case MAPPINGS_DIFFER: ++comparisonMetric.mappingsDiffer; break; case MAPPINGS_MATCH: ++comparisonMetric.mappingsMatch; break; default: throw new PicardException(""Unhandled comparison type: "" + comp); } }","It would be nice to move this switch into SamComparisonMetric. Or, move it into AlignmentComparison so the switch is no longer necessary, e.g. AlignmentComparison.updateMetric(SamComparisonMetric), where updateMetric() is overridden per enum member to increment the correct field.",I am having a hard time understanding why this is comparing bases that are over the same genomic position....,if(qual >= 30) { metrics.Q20_BASES++; metrics.Q30_BASES++; } else if (qual >=20) { metrics.Q20_BASES++; }  slightly faster for qualities above 30 not sure if it makes it less readable though,"This duplicates the code in isAdapter() above, and has the same side effecting issue. Is there a way to refactor the code and avoid the duplication?",It looks like this can be static,please use { } around the if body,is clippingOperator used elsewhere?,"Since @nh13 just did something very similar in CollectAlignmentSummaryMetrics it would probably be good to extract this into a re-usable spot so that there's a reasonable fixed definition of Chimeras somewhere. I could imagine:  java public class ChimeraUtil { public static int DEFAULT_INSERT_SIZE_LIMIT = 100000; public static int DEFAULT_MAPQ_LIMIT = 20; public Set<PairOrientation> DEFAULT_EXPECTED_ORIENTATIONS = EnumSet.of(PairOrientation.FR); public void isChimeric(final SAMRecord rec); public void isChimeric(final SAMRecord r1, final SAMRecord r2);  }","Refactor to remove empty if clause, and add curly braces",refactor casting,why not call equal() here for refNucleotide and count.refNucleotide?
"private Message.Builder getMessageBuilder(Class<?> clazz) { try { assert supports(clazz); Method method = methodCache.get(clazz); if (method == null) { method = clazz.getMethod(""newBuilder""); methodCache.put(clazz, method); } return (Message.Builder) method.invoke(clazz); } catch (Exception ex) { throw new MessageConversionException( ""Invalid Protobuf Message type: no invocable newBuilder() method on "" + clazz, ex); } }",Please check [our guidelines](<LINK_0> on source code style.,"Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException(""Illegal access to method"" + cachedMethod.getName(), ex) )",Shouldn't that be Class<?>,"I used to do this a lot, but now i don't think it is right to unwrap. <LINK_0>",It should be faster if the assertNoLock() were grouped.,No arguments to this method so IllegalArgumentException doesn't seem right. Think it might be good to either just remove the try/catch or wrap in a GroovyRuntimeException (to capture cachedMethod.getName).,I'd almost rather move the if (async) outside the lock-unlock so that we don't have to pay the synchronization penalty if we know we don't need to.,"we could add an element supplier ""function"" to VRaptorCache. what do you think? Something like:  java MethodHandle methodHandle = cache.getOrPut(method, new Supplier<>() { public MethodHandle get() { return methodHandleFactory.create(instance.getClass(), method); } });","This is not a safe operation. It's accessing a non-thread-safe mutable object (the map) without proper synchronization. It can cause a variety of issue ranging from getting an incorrect result to looping forever walking the map internal structures. In general, the double-checked locking idiom is broken due to Java memory model semantics.",Is this change related to updating apache velocity?,Better way to do this using slf4j: <LINK_0>
"static String base64(byte[] data) { byte[] encodedData = Base64.getEncoder().encode(data); return new String(encodedData, StandardCharsets.UTF_8); }",@doom369 just wondering if we should call encodeToString  directly. WDYT ?,minor nit: spaces between ( and {,"There seems to be an output change here: original: Base32.encode(""a"".getBytes()) => ""ME"" new: Base32.encode(""a"".getBytes()) => ""ME======"" We might need omitPadding() to ensure this is an exact drop in replacement.",Should we use UTF-8 instead of default character setting?,"Please, inline everything into this method, three additional classes for a such small function aren't needed.",These two methods are identical except for where the ByteBuffer comes from. Think about using a strategy pattern (a bit like guava's Supplier) to factor out the commonality.,I would have replace ArrayList with List.  if (dataToEncode instanceof List) { List arrayToDecode = (List)dataToEncode; List returnValueArray = new ArrayList(arrayToDecode.size()); for (Object arrayEntry : arrayToDecode) { returnValueArray.add(encodeObject(arrayEntry)); },"This approach to implement this method is wrong. The primary logic should be in this method, while the former one (that which takes charset name) should delegate to this method.",you can also use if (this != Base64) and then you do not need the isBase64 field,can this use the MMX StringUtils functions?,It results in a list with not encoded elements
"public void onAdd(SolApplication solApplication) { IniReader reader = new IniReader(Const.SAVE_FILE_NAME, null); String saveMajorVersion = reader.getString(""version"", """").split(""\\."")[0]; String gameMajorVersion = Const.VERSION.split(""\\."")[0]; continueControl.setEnabled(SaveManager.hasPrevShip(""prevShip.ini"") && saveMajorVersion.equals(gameMajorVersion)); }","""prevShip.ini"" shouldn't be used here, now that you have the constant defined. In fact, I don't think the file should be passed to the save manager, as that's more of a save manager concern. I would consider moving all of this logic into the hasPrevShip function.","I think that this is also dead code: at line 250 we know that firstMajor == secondMajor and firstMinor != secondMinor, so there is no possibility of reaching this line.","java } else if (versionInString.contains(""."")) { ... } else { // throw some Exception/log.severe/Assumption.fail/... }",Please bring back switch statement. This could throw array index out of bounds exception,"I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:","I would request that you bring back the ""hasPrevShip"" method, even if it's just a wrrapper for resourceExists. NewGameScreen should never need to know the name of the save file.","That's a hyphen, not a dash",Aren't the if and else blocks inverted?,"i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended","Please add back the if() statement. In case the adapter version changes, this can crash.",don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
"public boolean execute(int retries, MapOperation mapOperation, ILogger logger) { RecordStore recordStore = mapOperation.recordStore; if (recordStore == null) { return false; } if (recordStore.getInMemoryFormat() != NATIVE || recordStore.getEvictionPolicy() == NONE) { return false; } MapContainer mapContainer = recordStore.getMapContainer(); Evictor evictor = mapContainer.getEvictor(); for (int i = 0; i < retries; i++) { if (logger.isFineEnabled()) { logger.fine(format( ""Applying forced eviction on current RecordStore (map %s, partitionId: %d)!"", mapOperation.getName(), mapOperation.getPartitionId() )); } try { evictor.forceEvict(recordStore); mapOperation.runInternal(); return true; } catch (NativeOutOfMemoryError e) { ignore(e); } } return false; }",Minor: you can extract this null check and the in-memory format/eviction policy check into a static method and invoke it from here and other implementations of ForcedEviction,Shouldn't TaskProcessor initiate it's own logger ?,could you log some message here to indicate the restart cmd is not supported,Do Entities.destroyAllCatching(...) to prevent errors here causing the whole test to be skipped,should the second arg be true here?,is this is a typo? (checking for origApp != null and then calling method on newApp),"If customers send retention value that is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days. For cases where they deliberately send test metrics and then want to delete them from discovery after a week. The check we should have is , to cap the retention period to the max_retention",Would it be better to check AbstractLogger.getRecursionDepth() > 1? The class name check is fragile,"can't we get this config from recordstore? If we can, we eliminate concurrent hashmap lookup cost.",Make the method static,Isn't the rest of this function just doing appList.toArray(new ApplicationRecord[0])?
"public void onFailure(Throwable caught) { if (hasResponse()) { GWT.log(""HTTP "" + getResponse().getStatusCode() + "": "" + getResponse().getStatusText()); } Message message = new Message(translateCauses(caught), MessageStyle.ERROR); DisplayMessageEvent.fire(hasHandlers, message); }",you should remove this log.,This is wrong. You can not write D d3 = () -> {}. D is not a SAM.,You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...,"You could move the construction of msg and response under the if clause as you don't use it in the else case. Just curious though, since the check and the write aren't atomic, what happens if writeAndFlush() is called when the channel isn't active?","I think, it's better to transfer a method parameters and keep a name at a previous position.",Maybe better to create a constructor that only takes an InboundMessageDispatcher and uses null inside ResetResponseHandler. Just to not pass null explicitly as the second parameter.,Debug has to be detected first otherwise we'll always take the INFO branch.,why is required?,is this debug code that made it in,Still this line can through nullapointer exception. Need to check all scenarios before sending pull request,"This would put a hard dependency on woodstox in the logging module. I believe the better option would be to catch RuntimeException and check the cause to see if the cause is a XMLStreamException. If not, rethrow the RuntimeException, otherwise treat it like the XMLStreamException."
"public void stop() { coapServer.stop(); if (clientRegistry instanceof Stoppable) { ((Stoppable) clientRegistry).stop(); } if (securityRegistry instanceof Stoppable) { ((Stoppable) securityRegistry).stop(); } if (observationRegistry instanceof Stoppable) { ((Stoppable) observationRegistry).stop(); } LOG.info(""LW-M2M server stopped""); }",we should stop the queueRequestSender ?,"And btw we tend to write Camel instead of Apache Camel in these log messages, maybe we should just do that. Yeah its friday and its 'bike shed' day ;)",Extra synchronized,Use {} placeholders in the log message instead of '+',Please add log line. Having the thread name here will help debug issues.,Why change this to purge?,Why is this throwing Exception? Should usually not throw anything.,why are the throws on the next line?,Shouldn't this say _cluster based job coordinator_?,if accountservice is non-null this check isn't needed,Would it make sense to add something this.caches.clear() to the stop ?
"public void setLogFilePermission(String fileName) throws IOException { File file = new File(logRootDir, fileName).getCanonicalFile(); boolean runAsUser = ObjectReader.getBoolean(stormConf.get(SUPERVISOR_RUN_WORKER_AS_USER), false); File parent = new File(logRootDir, fileName).getParentFile(); Optional<File> mdFile = (parent == null) ? Optional.empty() : getMetadataFileForWorkerLogDir(parent); Optional<String> topoOwner = mdFile.isPresent() ? Optional.of(getTopologyOwnerFromMetadataFile(mdFile.get().getCanonicalPath())) : Optional.empty(); if (runAsUser && topoOwner.isPresent() && file.exists() && !Files.isReadable(file.toPath())) { LOG.debug(""Setting permissions on file {} with topo-owner {}"", fileName, topoOwner); try { ClientSupervisorUtils.processLauncherAndWait(stormConf, topoOwner.get(), Lists.newArrayList(""blob"", file.getCanonicalPath()), null, ""setup group read permissions for file: "" + fileName); } catch (IOException e) { ExceptionMeters.NUM_PERMISSION_EXCEPTIONS.mark(); throw e; } } }",The exception name is not clear,Is this the right error message here?,"This should instead be this.setJobMetadata(LoggingFilter.OWNER_KEY, owner.getKey()), since the owner is never actually used as an argument in the execute method, and is only used as part of the metadata.","Instead of partitioning the argument string, have you considered passing an array or something that is easier to parse? Python subprocess module uses that approach.","I think new File(""target/jboss-as"") will work exactly the same.",Compare userId instead of relying on equals method,"This is an unintended grant of permissions to all users. If the owner doesn't exist, this should instead call throwIfNonAdmin","If you decide not to use java.nio here, this FileInputStream should be closed after this regardless",good point here. I forgot to encrypt the password.,"The owner key is not an argument of this job's execution, so we don't need to validate its existence here.",Collections.emptyList/Set?
"private void estimateCommandsMachineName( Devfile devfile, Tool tool, KubernetesList recipeObjects) { List<Command> toolsCommands = devfile .getCommands() .stream() .filter(c -> c.getActions().get(0).getTool().equals(tool.getName())) .collect(toList()); if (toolsCommands.isEmpty()) { return; } List<Pod> pods = recipeObjects .getItems() .stream() .filter(hasMetadata -> hasMetadata instanceof Pod) .map(hasMetadata -> (Pod) hasMetadata) .collect(toList()); if (pods.size() != 1) { return; } Pod pod = pods.get(0); List<Container> containers = pod.getSpec().getContainers(); if (containers.size() != 1) { return; } Container container = containers.get(0); String machineName = Names.machineName(pod, container); toolsCommands.forEach(c -> c.getAttributes().put(MACHINE_NAME_ATTRIBUTE, machineName)); }","Could you describe why, not what?","IMHO, the inlined assignment makes the otherwise simple decision logic unnecessarily hard to parse with one's eyes. What about just simply: java if (podsData.size() != 1) { // many or no pods - can't estimate the name because of ambiguity or lack of information return; } PodData pod = podsData.get(0); if (pod.getSpec().getContainers().isEmpty()) { // no containers to base the name on return; }  The code is read many more times than it is written.","you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....",Please check that yaml inlined in error message looks good enough.,Why do we lose the cause here?,Is it important if machine names conflict with each other?,WDYT if we change two checks to just one? Something like: Plugin brokering supports one pod only. Workspace 'ID' contains 'N' pods,"suggestion checkArgument(!env.getPodsData().isEmpty(), ""Environment should contain at least 1 pod or deployment"");",suggestion return podStatus.getContainerStatuses();,"nonexisting are two words. So, nonexisting -> nonExisting",suggestion return pod.getSpec().getContainers().size() == pod.getStatus().getContainerStatuses().size() && PodUtils.getContainerStatus(pod).stream().allMatch(ContainerStatus::getReady);  ?
"private String encrypt(String value) { try { return getStorageHelper().encrypt(mContext, value); } catch (GeneralSecurityException | IOException e) { Logger.e(TAG, ""Encryption failure"", """", ADALError.ENCRYPTION_FAILED, e); } return null; }",nit: space,"Can we return raw string if encryption fail, as being done in previous logic?",Just return StudioEncryption.getStudioEncryption(StudioEncryption.EncryptionKeyName.SYSTEM).decrypt(encodedPassword); like method of encryptPasswordAES,"if it is debug, you can drop the {} and feed the e","probably better to write ""Exception"" instead of empty in these cases.",If you'd like to get telemetry how frequently this error occurs use ClientAnalytics to log this event and information that might help you to investigate what happened,"Why the above change? By the way, was changing this file part of the ticket?",There is already logging for that in the EncryptionUtils.encrypt catch block,"suggestion final IvParameterSpec iv = IV.readIv(bytes); cipher.init(Cipher.DECRYPT_MODE, key, iv);  In order to not have to make the handler interface generic. I realise that this will make the implementation deviate a bit from the other CipherStorage classes, but probably best to keep this workaround as contained as possible.",Why not use name as the key in CACHED_ENCRYPTION_KEYS?,So...no way to test encryption when running tests?
public String getBackupIdentifier() { return Const.SystemParams.ACCOUNT_ATTRIBUTES_BACKUP_LOG_MSG + this.googleId; },"Beside AccountAttributes.java, there are more *Atrributes.java need to be changed.",Is storing it in the class required? account.googleId should work fine as well. (or ${data.account.googleId}),I did not check what is the last argument we pass as null but It would be good to create overloaded methods if it is easy for easy readability...,Why do we need this? I don't understand,Throw it; we want to fail fast rather than wait for auth failures talking to the far end.,"I am aware that this was not handled before, but any chance that the passed in parameter can be null and lead to unexpected behavior? (applies to all the other fields as well)",Nit: extra space at the end should be removed.,"To me, this line seems redundant. Why not pass withStudentProfileAttributes(this.studentProfile.getCopy()) in the building process","Fuck, sorry, I said this in a confusing way. We still need to Md5 the value, since otherwise it can still be read. What we want is to MD5 -> Base64, to get a consistent string version of the MD5 hashed value.","nit: If we are going to log this as a warning, I think we should include the exception to help diagnose the problem: suggestion ""Keeping cached GitHub App Installation Token for app ID "" + appID + "": token is stale but has not expired"", e);",Any reason for this change? I think this is not relevant to the issue.
protected static WebDriver getCurrentBrowser() { return b.getCurrentWebDriver(); },"Are you sure that ""protected static"" is ok? To me it doesn't make sense as you can't override static methods.","It seems like we need to do return here at least. Also, could we log the exception with some logger? Because in the case with stdout we won't be able to turn the logging off. What do you think?",combine maybe and re-throw?,This setting should be in the initiateDriver method.,if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver),We should also handle/catch the Exception here.,should it be protected. In most cases no one extends from controllers,"or @MobileTest.. If the user is running session sharing, the annotation will be on the class vs. the method.",Please use relative time units as in <LINK_1>,please add final keyword,Probably need this?  binder.bind( new TypeLiteral<SeekableStreamIndexTaskClientFactory<KinesisIndexTaskClient>>() { } ).to(KinesisIndexTaskClientFactory.class).in(LazySingleton.class);  Please fix KafkaIndexTaskModule properly too.
"public void onlineUseCase() { Assume.assumeTrue(mCameraId != null); mCamera.open(); mCamera.addOnlineUseCase(Collections.<UseCase>singletonList(mFakeUseCase)); verify(mMockOnImageAvailableListener, never()).onImageAvailable(any(ImageReader.class)); mCamera.release(); }","Rather than put this in every test, you can just put it once in the setup() method.",We can use the @SdkSuppress(minSdkVersion = Build.VERSION_CODES.M) at the top of the ExtensionTest.,put it in teardown?,"What does guaranteed size means ? is it always 640x480 ? or you just want to test default resolution ? I think if your purpose is to test 640x480 is always supported, then you should not rely on the fact that default resolution happens to be 640x480 at this moment because default resolution could changes in the future. Instead you should just set target resolution to 640x480.",No need to wrap line,"This assert is not necessary, other tests already verify that the closer starts in state OPEN. And I don't think the final is needed either.",No need to wrap line,right ... will change it,hard to find a device without cameras what happen when you throw? can an user get this error using an ErrorBoundary? 0 is always the first camera? won't break the current behavior?,I use isA() to check the different Exceptions thrown by the client. This lets me validate all the different error scenario paths as they often have different Exception types.,"Since the CameraX instance is being replaced by init(). Do we have any reason to allow resetting this to false? We should probably check that it is set to ""true"" before trying to deinit() or we might run into a NullPointerException."
"protected String buildPOFipsCountryCode(PaymentWorksVendor pmwVendor, Map<String, List<PaymentWorksIsoFipsCountryItem>> paymentWorksIsoToFipsCountryMap) { String fipsCountryCode = StringUtils.EMPTY; if (paymentWorksFormModeService.shouldUseLegacyFormProcessingMode()) { String paymentWorksVendorCountryCode = findPoCountryToUse(pmwVendor); fipsCountryCode = convertFipsPoCountryOptionToFipsCountryCode(paymentWorksVendorCountryCode); if (StringUtils.isBlank(fipsCountryCode)) { LOG.error(""buildPOFipsCountryCode, unable to find LEGACY FIPS country code for "" + paymentWorksVendorCountryCode); } } else if (paymentWorksFormModeService.shouldUseForeignFormProcessingMode()) { PaymentWorksPurchaseOrderCountryFipsOption option = PaymentWorksPurchaseOrderCountryFipsOption.findPaymentWorksPurchaseOrderCountryFipsOption(pmwVendor.getPoCountryUsCanadaAustraliaOther()); if (LOG.isDebugEnabled()) { LOG.debug(""buildPOFipsCountryCode, new foreign form FIPS country code option: "" + option.toString()); } if (StringUtils.isNotBlank(option.fipsCountryCode)) { fipsCountryCode = option.fipsCountryCode; } else { try { fipsCountryCode = convertIsoCountryCodeToFipsCountryCode(pmwVendor.getPoCountry(), paymentWorksIsoToFipsCountryMap); } catch (NullPointerException npe) { LOG.error(""buildPOFipsCountryCode, had and error converting '"" + pmwVendor.getPoCountry() + ""' to a FIPS code."", npe); fipsCountryCode = StringUtils.EMPTY; } } if (StringUtils.isBlank(fipsCountryCode)) { LOG.error(""buildPOFipsCountryCode, unable to find new foreign form FIPS country code for country code "" + pmwVendor.getPoCountry()); } } return fipsCountryCode; }","Minor typo in error message, should change from ""...had and error..."" to ""...had an error...""","The same StringUtils.isNotBlank() check is getting duplicated in each ""if"" and ""else if"" condition. I would recommend adding some short-circuit logic in the event of a blank country option. Also, StringUtils.equalsIgnoreCase() should already be null-safe, which can help with simplifying this.","It looks like the PaymentWorksVendor class has some pre-existing typos in its diversity classification property names (as well as in the supplier diversity service). If fixing the names is beyond the scope of this PR, then please create a separate user story to get them fixed.","StringUtils.equalsIgnoreCase() should already be null-safe, so you shouldn't need a non-blank check here.",Another spot that can be simplified due to null-safe equalsIgnoreCase method.,"Missing the -... ex: pt-BR Now that i look into it, is it a - or a _? I believe it's a -. One more reason to use the default functions",would this be better called just taxRule? foundRule denotes a boolean and this is not the case here.,This operator should be changed from a bitwise OR to a logical OR.,"Nothing is being appended to this StringBuilder after constructing it with the initial text, so this could be replaced with a plain String instead.","Another method that could be simplified by having it call the two-arg method that takes a list as the second arg, so that the constructor doesn't need to be called directly here.",This method has a typo. FIelds should be Fields.
public Boolean isWakeupEvent(ITmfEvent event) { String eventName = event.getName(); ITmfTrace trace = event.getTrace(); LttngEventLayout eventLayout = getProvider().getEventLayout(); String wakeupEventName = NonNullUtils.nullToEmptyString(fWakeupEventMap.get(trace)); if (wakeupEventName.equals(eventLayout.eventSchedProcessWaking()) && (eventName.equals(eventLayout.eventSchedProcessWaking()) || eventName.equals(eventLayout.eventSchedProcessWakeupNew()))) { return NonNullUtils.checkNotNull(Boolean.TRUE); } else if (wakeupEventName.equals(eventLayout.eventSchedProcessTTWU()) && eventName.equals(eventLayout.eventSchedProcessTTWU())) { return NonNullUtils.checkNotNull(Boolean.TRUE); } return NonNullUtils.checkNotNull(Boolean.FALSE); },why not boolean? (lowercase?),"Just to be sure, here you are ||'ing on eventSchedProcessWak*ing*() and eventSchedProcessWake*up*New(). Is this correct? And you don't need eventSchedProcessWakeup() at all?",no! I'm guessing this is a debugging check?,"Why do we use iterators? I know the base class does, but why in the first place?",Throw an exception if the event is not found?,how about only events with a phase?,"getTrace() being a UfTrace you are painting yourself in a corner here. Like for the TraceEventEvent thing, this provider works only on UfTrace trace, not uftrace-like events implementing the same semantic. But it does not need to be fixed right now. But it should be kept in mind for later.",should it use the trace's cache size?,string equals,just null,"Iterables.any(trace.getEventAspects(), aspect -> aspect instanceof ITmfCounterAspect); ?"
"private void triggerDeveloperBan(final CertifiedProductSearchDetails updatedListing) { Scheduler scheduler; try { scheduler = getScheduler(); TriggerKey triggerId = triggerKey(""triggerBanNow_"" + new Date().getTime(), ""triggerDeveloperBanTrigger""); JobKey jobId = jobKey(""Trigger Developer Ban Notification"", ""chplJobs""); Trigger qzTrigger = newTrigger() .withIdentity(triggerId) .startNow() .forJob(jobId) .usingJobData(""status"", updatedListing.getCurrentStatus().getStatus().getName()) .usingJobData(""dbId"", updatedListing.getId()) .usingJobData(""chplId"", updatedListing.getChplProductNumber()) .usingJobData(""developer"", updatedListing.getDeveloper().getName()) .usingJobData(""acb"", updatedListing.getCertifyingBody().get(""name"").toString()) .usingJobData(""changeDate"", new Date().getTime()) .usingJobData(""firstName"", Util.getCurrentUser().getFullName()) .usingJobData(""lastName"", Util.getCurrentUser().getFriendlyName()) .usingJobData(""effectiveDate"", updatedListing.getCurrentStatus().getEventDate()) .usingJobData(""openNcs"", updatedListing.getCountOpenNonconformities()) .usingJobData(""closedNcs"", updatedListing.getCountClosedNonconformities()) .build(); scheduler.scheduleJob(qzTrigger); } catch (SchedulerException e) { LOGGER.error(""Could not start Trigger Developer Ban"", e); } }","Does it matter that ""firstName"" and ""lastName"" are still the keys here? Probably should be full and friendly anyway?",Not sure if we really need it. Half of the engine commands would probably not working correctly when you invoke commands before the backend initialization is done. Further I don't think that the REST api and the GWT frontend are even accessible until everything is properly initialized in the backend since they depend on it. @mperina is that correct?,"add "",""",it looks like you've copied reschedule() and just replaced the Trigger creation. For the sake of Don't-Repeat-Yourself (DRY) could you please extract the Trigger-Creation from the methods and use just one resulting method which reschedules the Job properly,Is there a reason for having these two variables be public and yet have getters?,"Quartz best practices state that all listener methods contain a try-catch and should handle ALL exceptions [1]. If something happens when committing the JobStatus, we violate this best practice and could potentially introduce issues. [1] <LINK_0>","Validations that startAt < endBy, startAt > now etc?",should be non-nullable primitive long,I would make the name of this file a constant probably in JobConstants that way we can at least change it and it will change all over the code where we reference it and we don't have to track down strings.,push to the top you only need the builder is the scheduler is not null,is there a way to delete a scheduled job once a cron trigger is set
protected boolean updateSelection(IStructuredSelection selection) { if (!super.updateSelection(selection)) { return false; } final IResource[][] clipboardData = new IResource[1][]; shell.getDisplay().syncExec(new Runnable() { @Override public void run() { ResourceTransfer resTransfer = ResourceTransfer.getInstance(); clipboardData[0] = (IResource[]) clipboard.getContents(resTransfer); } }); IResource[] resourceData = clipboardData[0]; boolean isProjectRes = resourceData != null && resourceData.length > 0 && resourceData[0].getType() == IResource.PROJECT; if (isProjectRes) { for (IResource element : resourceData) { if (element.getType() != IResource.PROJECT || ((IProject) element).isOpen() == false) { return false; } } return true; } if (getSelectedNonResources().size() > 0) { return false; } IResource targetResource = getTarget(); if (targetResource == null) { return false; } List<? extends IResource> selectedResources = getSelectedResources(); if (selectedResources.size() > 1) { for (IResource resource : selectedResources) { if (resource.getType() != IResource.FILE) { return false; } if (!targetResource.equals(resource.getParent())) { return false; } } } if (resourceData != null) { if (isLinked(resourceData) && targetResource.getType() != IResource.PROJECT && targetResource.getType() != IResource.FOLDER) { return false; } if (targetResource.getType() == IResource.FOLDER) { for (IResource element : resourceData) { if (targetResource.equals(element)) { return false; } } } return true; } TransferData[] transfers = clipboard.getAvailableTypes(); FileTransfer fileTransfer = FileTransfer.getInstance(); for (TransferData transfer : transfers) { if (fileTransfer.isSupportedType(transfer)) { return true; } } return false; },rename 'resource',perhaps it is better to check selection.isEmpty() first before continuing to other checks and also eliminating the need for null checks.,Could be suggestion return !selectedBaseResources.isEmpty();,I'd rather prefer you changed the getOpenShiftServer signature to take a IResource parameter instead of a IResourceUIModel,I think you'll have to lift this restriction. Note that the handler definition in plugin.xml also is restricted to single-element selections.,we don't use curly brackets around one single line block's,"Check for null is not required here, because (element instance of IResource) returns false for null element.",just a niggle : what's the point of using full class name (including package)?,I would like to see all new code using lambdas where possible.,"I suggest to create and schedule one job for the bunch of resources, if there are more than 1 of them. The job, for instance, may iterate the stream and (1) check if monitor is cancelled, (2) report to monitor begin of task, (3) set 'deleting' to true, (4) explicitly call job.doRun(monitor) (let's make it public), (5) without a job listener, check status and set 'deleting' to false if ok.",This should be removed
public void destroyTelephonyConference() { for (Connection c : getConnections()) { notifyConferenceMembershipChanged(c); } destroy(); },It doesn;t look like the membership of these connections have been changed yet.. Should removeTelephonyConnection be called for all of the connections first?,"This should be able to remove a membership that matches the patient, if there is multiple for the same patient then you can ignore it",I think this should also be able to lookup the membership with the matching patient and remove it so that a call like the one below works too: Cohort.removeMembership(new CohortMembership(Context.getPatientService().getPatient(patientId))),We should make removeConnectionCallbacks(...) and getServiceConnectionManager() package private since they are only used internally.,Instead of nodeID shouldn't it be whatever was returned from the earlier call to setMembershipListener?,why?,It may be faster to save all the Futures here and iterate through them to get the final results in another loop below. That way you submit the work to all network threads without waiting.,"Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.","Better to do an ""if / else if / else if"" style",Why not return directly the List<IConnector>?,return if already destroyed
"private long getWatermarkMs(String realtimeTableName, List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata, long bucketMs) { RealtimeToOfflineSegmentsTaskMetadata realtimeToOfflineSegmentsTaskMetadata = _clusterInfoAccessor.getMinionRealtimeToOfflineSegmentsTaskMetadata(realtimeTableName); if (realtimeToOfflineSegmentsTaskMetadata == null) { long watermarkMs; long minStartTimeMs = Long.MAX_VALUE; for (LLCRealtimeSegmentZKMetadata realtimeSegmentZKMetadata : completedSegmentsMetadata) { minStartTimeMs = Math.min(minStartTimeMs, realtimeSegmentZKMetadata.getStartTimeMs()); } watermarkMs = (minStartTimeMs / bucketMs) * bucketMs; realtimeToOfflineSegmentsTaskMetadata = new RealtimeToOfflineSegmentsTaskMetadata(realtimeTableName, watermarkMs); _clusterInfoAccessor.setRealtimeToOfflineSegmentsTaskMetadata(realtimeToOfflineSegmentsTaskMetadata); } return realtimeToOfflineSegmentsTaskMetadata.getWatermarkMs(); }",Do we want to add  Preconditions.checkState(minStartTimeMs != Long.MAX_VALUE);  to throw the exception at the same condition?,nit: static import currentTimeMillis,Why is it changed?,"Instead of the try/catch, how about replacing rejectionPolicy.getCurrMaxTime().minus(windowMillis) with new DateTime(Math.max(windowMillis, rejectionPolicy.getCurrMaxTime().getMillis()) - windowMillis)? Or if you're not convinced that is cleaner, this looks cool as is so I am ok with merging it.","If we are not using java 8 Optional here, maybe we can consider doing this: String taskShutDownVal = get(TASK_SHUTDOWN_MS); if (null == taskShutDownVal) { ... } else { ...} It is a minor thing (so optional for change :)), but the pattern in the old way will call get() function twice in most of the cases. I believe this get() is light, but it may be heavy in other cases. So I would suggest to consider to always make only one call as a best practice.","Its probably a matter of preference, but you can just do return getDelayTime(ingestTime) > TRACKER_DELAYED_METRICS_MILLIS",Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } },doesn't this line and the number of {} need to have an equivalent change?,Why is this line outside the iif block? Shouldn't it be inside it following the highestContiguousMsgId is reset?,Is that (much) faster than the following? I'm curious if you have the answer (i.e. I don't want you to research it or change your source code).  java int nextTsDeltaHistIdx = tsDeltaHistIdx + 1; tsDeltaHistIdx = (nextTsDeltaHistIdx < tsDeltaHist.length) ? nextTsDeltaHistIdx : 0;,We should not take the max here as we would like to know if it somehow ends up going down
"private static void printTumorTypeSummary(Set<Evidence> evidences, SpreadsheetService service, WorksheetEntry entry) throws IOException, ServiceException { URL feedUrl = entry.getListFeedUrl(); if (evidences != null && service != null && entry != null) { for (Evidence evidence : evidences) { ListEntry row = new ListEntry(); setValue(row, ""Gene"", evidence.getGene().getHugoSymbol()); List<String> alterationNames = new ArrayList<>(); for (Alteration alteration : evidence.getAlterations()) { if (StringUtils.isNullOrEmpty(alteration.getName())) { alterationNames.add(alteration.getAlteration()); } else { alterationNames.add(alteration.getName()); } } setValue(row, ""Variants"", MainUtils.listToString(alterationNames, "", "")); setValue(row, ""CancerType"", getCancerType(evidence.getOncoTreeType())); setValue(row, ""Summary"", evidence.getDescription()); service.insert(feedUrl, row); } } }",Put this snippet of getting alterationNames into a function. Since the same code is used in printEvidences(),"The variable name ""hasjointed"" is opposite to its assigned meaning.","Since we set this on startup, do we need to fetch it again instead of just using Allergen. getOtherNonCodedConceptUuid()?",Is the activity.getCurrentStatus().getStatusChangedDate() the date of the most recent status change? That's how I read it but maybe it's not. I would have thought you wanted to use the creation date of the change request here.,"As long as we're messing with this code, I'd like to yank out this hard-coded 8.","In Evidence, there is no attribute called shortDescription, and neither its corresponding get method. This cased an error when I tried to build, need to add it.","if performance is really that critical here, I would pull the call to size into the initializer so it isn't repeated.",Let's also do a null check on evidence as well,missing { and } in if - else statement. The NPE occurs when dereferencing getCountry I think.,should this be made into a doubly indexed array? wouldn't that be faster?,I think this could be rewritten more cleanly by using the [String formatter](<LINK_0>
"public static void createProjects( final Set<ProjectRecord> projectsToCreate, final boolean open, final IWorkingSet[] selectedWorkingSets, IProgressMonitor monitor) throws InvocationTargetException, InterruptedException { IWorkspaceRunnable wsr = new IWorkspaceRunnable() { @Override public void run(IProgressMonitor actMonitor) throws CoreException { IWorkingSetManager workingSetManager = PlatformUI .getWorkbench().getWorkingSetManager(); try { actMonitor.beginTask("""", projectsToCreate.size() * 2 + 1); if (actMonitor.isCanceled()) throw new OperationCanceledException(); Map<IProject, File> projectsToConnect = new HashMap<>(); for (ProjectRecord projectRecord : projectsToCreate) { if (actMonitor.isCanceled()) throw new OperationCanceledException(); actMonitor.subTask(projectRecord.getProjectLabel()); IProject project = createExistingProject(projectRecord, open, SubMonitor.convert(actMonitor, 1)); if (project == null) continue; RepositoryFinder finder = new RepositoryFinder(project); finder.setFindInChildren(false); Collection<RepositoryMapping> mappings = finder .find(SubMonitor.convert(actMonitor, 1)); if (!mappings.isEmpty()) { RepositoryMapping mapping = mappings.iterator() .next(); IPath absolutePath = mapping .getGitDirAbsolutePath(); if (absolutePath != null) { projectsToConnect.put(project, absolutePath.toFile()); } } if (selectedWorkingSets != null && selectedWorkingSets.length > 0) workingSetManager.addToWorkingSets(project, selectedWorkingSets); } if (!projectsToConnect.isEmpty()) { ConnectProviderOperation connect = new ConnectProviderOperation( projectsToConnect); connect.execute(SubMonitor.convert(actMonitor, 1)); } } finally { actMonitor.done(); } } }; try { ResourcesPlugin.getWorkspace().run(wsr, monitor); } catch (OperationCanceledException e) { throw new InterruptedException(); } catch (CoreException e) { throw new InvocationTargetException(e); } }","I don't think one should convert the same monitor multiple times. Use SubMonitor progress = SubMonitor.convert(actMonitor, projectsToCreate.size() * 2 + 1); at the top and then use only progress, not actMonitor, and use progress.newChild(1) here and below.",Delete this line.,style nit: no braces here,Use the workspace direcltly.,Can you elaborate explain why the AVOID_WORKSPACE is necessary here?,"isAccessible() should be used here, it covers also deleted projects.",Why did we change this logic?,"There is not just C++ and Java, it's an extension point. Replace with generic message, i.e. could not create project for <language> ...",obsolete; rename loop var to project,LibraryFilter would probably be a more expressive name.,"These checks can be removed now (this is the actual advantage of introducing fUpdateUIJob, right?)"
"private void runTearDown(Throwable exception) throws DeviceNotAvailableException { List<IMultiTargetPreparer> cleanerList = new ArrayList<>(mMultiPreparers); Collections.reverse(cleanerList); for (IMultiTargetPreparer multiCleaner : cleanerList) { if (multiCleaner.isDisabled() || multiCleaner.isTearDownDisabled()) { continue; } CLog.d(""Running teardown Multi cleaner: %s"", multiCleaner.getClass().getSimpleName()); multiCleaner.tearDown(mModuleInvocationContext, exception); } for (int i = 0; i < mModuleInvocationContext.getDeviceConfigNames().size(); i++) { String deviceName = mModuleInvocationContext.getDeviceConfigNames().get(i); ITestDevice device = mModuleInvocationContext.getDevice(deviceName); if (i >= mPreparersPerDevice.size()) { CLog.d( ""Main configuration has more devices than the module configuration. '%s' "" + ""will not run any tear down."", deviceName); continue; } List<ITargetPreparer> preparers = mPreparersPerDevice.get(deviceName); if (preparers == null) { CLog.w( ""Module configuration devices mismatch the main configuration "" + ""(Missing device '%s'), resolving preparers by index."", deviceName); String key = new ArrayList<>(mPreparersPerDevice.keySet()).get(i); preparers = mPreparersPerDevice.get(key); } ListIterator<ITargetPreparer> itr = preparers.listIterator(preparers.size()); while (itr.hasPrevious()) { ITargetPreparer preparer = itr.previous(); if (preparer instanceof ITargetCleaner) { ITargetCleaner cleaner = (ITargetCleaner) preparer; if (cleaner.isDisabled() || cleaner.isTearDownDisabled()) { CLog.d(""%s has been disabled. skipping."", cleaner); continue; } RecoveryMode origMode = null; try { if (exception != null && exception instanceof DeviceNotAvailableException) { origMode = device.getRecoveryMode(); device.setRecoveryMode(RecoveryMode.NONE); } cleaner.tearDown( device, mModuleInvocationContext.getBuildInfo(deviceName), exception); } finally { if (origMode != null) { device.setRecoveryMode(origMode); } } } } } }",m,Why throw a runtime exception instead of module exception?,"Is this to avoid the method being called more than once? If it is not an expected behavior, shouldn't we raise an exception?","Shouldn't we include just the SSLDs? Otherwise, if there are Kaifa smart meters in a system, we would be contacting those for their events as well.","I always have trouble explaining dependencies in error messages because it can get confusing easily :-) Suggestion: ""Ignoring dependency of module '%1$s' on module '%2$s'. %3$s""","The current approach results in a query per Kaifa device. It's much more efficient to let the DB do the filtering. Regardless of the solution: add an index on (device, date_time) to make the search more efficient.",nit: you probably also want to check mLaunchListener.getCurrentRunREsults().isRunFailure() in case of crash that would let you know.,There are gerrits that prefer a different variant recently.,"why this block is not before ""if (!mCoverage)""? The logic has nothing to do with line 996 If mCoverage is true, does that mean we will still need to use InstrumentationTest rerun?",Restore visibility of methods in this class to package level when unit tests are moved to jaggr-core,What would happen when the same module is being loaded multiple times because of multiple SPI references in the CLASSPATH ?
"public static String md5(String str) { MessageDigest m = null; try { m = MessageDigest.getInstance(""MD5""); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } m.update(str.getBytes(),0,str.length()); return new BigInteger(1,m.digest()).toString(16); }","It it better to throw unchecked exception than simply print error because if error occurs then variable 'm' will be null and NullPointerException will be thrown later (line 16). try { m = MessageDigest.getInstance(""MD5""); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); //use logger instead throw new RuntimeException(""No Such Algorithm: MD5""); }",Usually its not a good practice to change the access modifiers of a method just for writing tests for it.,Do we need this instance whenever the method is called? Can't we reuse it?,"Can you call the other version of hash() from here instead?  java public static byte[] hash(byte[] data) throws NoSuchAlgorithmException { return hash(data, 0, data.length); }",A standard converter like DataTypeConverter.printHexBinary() could be a possibility.,Magic Number,Remove the catch block for IOException.,"Use logging, don't print to standard out.","Unknown data source to calculate sha256 hash. This should not happen, please report this issue at <LINK_0> - is better i think.",how did you decide between throwing vs. silently ignoring (which is what you do in ReadableStreamChannelInputStreamTest)?,We should log here why the generation fails. Taking an input stream is a bit dubious? It could be: - not at position zero when we start reading - another thread could be reading concurrently - caller might not realise we're reading through it Is there a way to make sure we have a new stream that only this method is using?
"public Map<K, V> removeAll(BiPredicate<? super K, ? super V> predicate) { Objects.requireNonNull(predicate, ""predicate is null""); return filter(predicate.negate()); }",the return type should be M,I don't think this should be memoized... the Store should be able to call into this multiple times with different sets of keys.,formatting weird,The implementation is missing and should be protected by doWithWriteLock,Why not Repartitioned.as(null) ? This way we can remove empty() -- it would align with the pattern we apply in existing code.,nit: UnsupportedOperationException (java.lang) is more descriptive.,"Seems quite similar to what the default method already offers? But maybe best to keep it, but throw an exception stating that native filters are not encodable in XML (this is what the visitor seem to be doing, prepare filters for XML encoding).",".collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?",emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet(),remove(Object),minor: access can be package-private (in support of the method name's Internal suffix :-) ). same for addInternal below.
"static Path getCMPath(Configuration conf, String checkSum) throws IOException, MetaException { String newFileName = checkSum; int maxLength = conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY, DFSConfigKeys.DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT); if (newFileName.length() > maxLength) { newFileName = newFileName.substring(0, maxLength-1); } return new Path(cmroot, newFileName); }",Looks like getCMPath never throw IOException or MetaException. Shall check and remove it.,is this line redundant? we want to log an error when both file system are different. Doesn't matter if src is hdfs or not.,IseException is a REST exception. We should throw something like a ConfigurationException here instead.,this constructor can directly call the below one,"suggestion Long multiplier = Double.valueOf(Math.pow(1024,pow)).longValue();",you can just do return at this point,Wouldn't it be simpler to just use base 10?,"Seems like a lot of regex magic for what could be a simple StringUtils.left(safeName,maxMnemonic) + ""-"" + uniqueSuffix(name) Obfuscates exactly what is being done","This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...","Result of replaceAll is ignored. Please, assign it to a variable. suggestion maxUploadSizeString = maxUploadSizeString.replaceAll(""\\s+"", """");","nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>"
"public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { ApplicationEnvironmentPreparedEvent castEvent = (ApplicationEnvironmentPreparedEvent) event; String componentName = castEvent.getEnvironment().getProperty(""info.component""); LOG.info(""Setting service name to {}"", componentName); CommonLogHolder.setServiceType(componentName); } if (event instanceof ApplicationFailedEvent) { LOG.info(""Terminating default logging context""); ((LoggerContext) LoggerFactory.getILoggerFactory()).reset(); BasicConfigurator.configureDefaultContext(); } }",Can this be overloaded to avoid the casts?,Where does it get set?,"You should also log the getName() if it's not null, this can help debugging as it's different from the class name.",Need to check that the event is for this context.,Shouldn't we confirm that the event context is this bean's declaring context?,"Strictly speaking, you should make this ApplicationContextAware and check the context in the event matches. We don't want to react to events from other contexts in the hierarchy - maybe not relevant here, but best practice.",shouldn't it be better off with a bit detailed log message?,why did you remove the code here? it is still needed. You should not remove code so you can make a variable a constant. If you make a variable a constant and you get a compile error it just means that we are not able to make it a constant. The task of this ticket is simply to make things constants which are never reassigned.,"Maybe better to revert the condition? If logging is bootstrapped, we can return early. Advantage is a reduction of a big _if_ block with identation.","To use better the features of log4j, it's better to change this as: logger.info(""Bundle {} has started with config!"", APP_ID);","How about to replace calls to root.getLoggerContext() to loggerContext, if we already have the context as a field?"
"private String getBundleVersion() { ClassLoader cl = getClass().getClassLoader(); if (cl instanceof URLClassLoader) { URL url = ((URLClassLoader) cl).findResource(JarFile.MANIFEST_NAME); try { Manifest manifest = new Manifest(url.openStream()); return manifest.getMainAttributes().getValue(""Bundle-Version""); } catch (IOException e) { } } return null; }",url should be checked for null.,"Suggest:  version = value.replaceAll(""BUILD-SNAPSHOT"", ""SNAP"").replaceAll(""-RELEASE"", """");","If we decide to keep this, then I'm wondering why you'd attempt URL loading. Never seen that being needed?",unused,We should probably parametrize this dt-git.properties also.,loadClass(type) will throw ClassNotFoundException if not found. Better to just catch that rather than generic Exception? e.g. if bundle name was invalid then fine to throw exception rather than just returning Maybe.absent().,"if this is the default fallback, probably should return ""dev"" instead.","please try to line wrap lines longer than 80 columns why not the more direct: ClassLoader parent = PluginLoader.class.getClassLoader(); new URLClassLoader(getPluginURLs(jarFile), parent)?",I don't think you need to print stack trace here. It'll wind up polluting the test output.,"This is a bug in the build system, not the code.",Optional<String> ?
"public Response ackAlert( @ApiParam(required = true, value = ""The alertId to Ack."", allowableValues = ""An existing alertId."") @PathParam(""alertId"") final String alertId, @ApiParam(required = false, value = ""User acknowledging the alerts."") @QueryParam(""ackBy"") final String ackBy, @ApiParam(required = false, value = ""Additional notes associated with the acknowledgement."") @QueryParam(""ackNotes"") final String ackNotes) { try { if (!isEmpty(alertId)) { alertsService.ackAlerts(tenantId, Arrays.asList(alertId), ackBy, ackNotes); if (log.isDebugEnabled()) { log.debug(""AlertId: "" + alertId); } return ResponseUtil.ok(); } else { return ResponseUtil.badRequest(""AlertId required for ack""); } } catch (Exception e) { log.debug(e.getMessage(), e); if (e.getCause() != null && e.getCause() instanceof IllegalArgumentException) { return ResponseUtil.badRequest(""Bad arguments: "" + e.getMessage()); } return ResponseUtil.internalError(e); } }",Let's not break/change the format here. I think each annotation should go in a different line for consistency and readability. Perhaps some automatic formatting from the IDE here.,"If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt(""id"") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.",Could we name this userId instead of nedId for consistency?,Maybe have one of them be the wrong length and the other one be the right length but with non-digits in it to cover a broader swathe of the validation,"I see what you're going for with the early return to avoid response being null. I'd probably refactor a little bit like this so the error case is always handled in the else block.  java protected void onSuccess(String response) { if (response != null) { try { JSONArray jsonArray = new JSONArray(response); if (jsonArray.length() > 0) { JSONObject jsonObject = jsonArray.getJSONObject(0); long endUserId = jsonObject.getLong(""id""); wootricApiCallback.onGetEndUserIdSuccess(endUserId); } else { wootricApiCallback.onEndUserNotFound(); } } catch (JSONException e) { wootricApiCallback.onApiError(e); } } else { wootricApiCallback.onApiError( new IllegalArgumentException(""End user params are missing"")); } }",can we have this as a function,It's newer a good idea to have a variable name the same as the class name. suggestion Announcement announcement = new Announcement();,final,No need to LOG.error() here. Since you are throwing an ActionException it will be logged anyway by the controller. Logging it twice only adds spam to the log files.,getUserIdFromAuthId never returns null.,I think this is probably the last item. Add organization to all the relevant log statements.
"public static String humanReadable(float bytes) { if (bytes > GB) { return String.format(""%.03f GB"", bytes / GB); } else if (bytes > MB) { return String.format(""%.03f MB"", bytes / MB); } else if (bytes > KB) { return String.format(""%.03f kB"", bytes / KB); } else { return String.format(""%.02f B"", bytes); } }",TB too?,Did you take a look at our convention for constants? <LINK_0>,These should be constants rather than calculated each time the method runs.,"Cosmetic: Please, always use braces around conditions and loops. Thanks! :)","I'd like to see better rounding with a consistent number of significant digits. E.g. 345,3 MB is displayed as 345 MB (that's fine) but 3,456MB is displayed as 3MB which is unnecessarily reducing the accuracy, instead this should be displayed as 3,45MB. Maybe it would make sense to also show the precise numbers in brackets like what file system explorers typically display.",java return bytes >> 20;,create a constant so it make's sense? I have no idea what is 18 atm same for above an below,maybe this could be 'static' ?,public method does not need VisibleForTesting annotation.,would be nicer if this was a fluent API - could overload setters with things like ByteSizeStrings bytesPerMetricUnit(int val)? And deprecate setters?,This should be in BIG ENDIAN byte order
"private void reset() { if (chunk != null) { chunkedInput = new HttpChunkedInput(new RepeatedBytesInput()); request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, path); HttpUtil.setContentLength(request, totalSize); request.headers().add(RestUtils.Headers.BLOB_SIZE, totalSize); request.headers().add(RestUtils.Headers.SERVICE_ID, serviceId); request.headers().add(RestUtils.Headers.AMBRY_CONTENT_TYPE, ""application/octet-stream""); if (targetAccountName != null) { request.headers().add(RestUtils.Headers.TARGET_ACCOUNT_NAME, targetAccountName); } if (targetContainerName != null) { request.headers().add(RestUtils.Headers.TARGET_CONTAINER_NAME, targetContainerName); } } else { if (pathList == null) { request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path); } else { request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, pathList.get(counter.getAndIncrement() % pathList.size())); } } for (Pair<String, String> headerNameValue : customHeaders) { request.headers().add(headerNameValue.getFirst(), headerNameValue.getSecond()); } chunksReceived = 0; sizeReceived = 0; lastChunkReceiveTime = 0; requestStartTime = System.currentTimeMillis(); response = null; }",Do you think it's worthwhile to check !targetAccountName.isEmpty() as well? Same for container's check.,Should the blobName be an empty string?,why is this case allowed ?,"Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?","I *think* we only call writeTarget() when we have a success status...in other words, that we've already checked for 200 status before we get here. If that's true, then we shouldn't need to check it again, right?",This method is called from ExplorerActivityTest in the RestExplorerTest project. I don't see that file modified in your checkin.,Hi @hijklmno. This looks good overall. What was your reason for not setting this.accountNumber to stringOrNull(accountNumber)?,"Why are put requests injected differently than post requests? Put requests contain the blobId, but that doesn't appear to be used here.","Correct me if I am wrong. If updateAccounts throws exception, where it would be handled? And the exception parameter is still null in onCompletion ? Same question in GetAccountsHandler.",ensure number of calls to append is correct,"This is users recursion for retries, can we use iteration instead - it should be much easier to follow iterative code."
"private void load() { List<OnmsNode> nodes = nodeDao.findAll(); this.sparseGraph = new DirectedSparseGraph(); int counter = 0; for (OnmsNode node : nodes) { CustomVertex vertexChild = new CustomVertex(NAMESPACE, node); if (node.getParent() == null) { this.sparseGraph.addVertex(vertexChild); } else { CustomVertex vertexParent = new CustomVertex(NAMESPACE, node.getParent()); vertexChild.setParent(vertexParent); this.sparseGraph.addVertex(vertexChild); this.sparseGraph.addVertex(vertexParent); this.sparseGraph.addEdge(new AbstractEdge(NAMESPACE, String.valueOf(counter), vertexParent, vertexChild), vertexParent, vertexChild, EdgeType.DIRECTED); counter++; } } List<CustomVertex> tempVertices = new ArrayList<>(); for (CustomVertex vertex : this.sparseGraph.getVertices()) { Collection<CustomVertex> predecessors = this.sparseGraph.getPredecessors(vertex); if (predecessors.isEmpty()) { vertex.setLevel(0); tempVertices.add(vertex); tempVertices.addAll(setLevel(this.sparseGraph, vertex, 1)); } } for (CustomVertex customVertex : tempVertices) { this.addVertices(customVertex); } for (AbstractEdge abstractEdge : this.sparseGraph.getEdges()) { this.addEdges(abstractEdge); } }",Please rename to edgeId.,Is there a particular reason to use Objects.isNull() instead of just verifiing if vertex == null?,Fry asks that you keep the Objects.equal for the unlikely case of NPE.,"hmm, shouldn't this be at most 1 vertex? Since the quicksearch vs Id functions aren't the same signature anyway we might return just an Optional<vertex> instead of a GraphTraversal.",i just started to merge this and i think that change might have been an artifact from your rebase at some point as i see that style in tp34. sorry about making you change that. i will probably go back and add that change to tp33 after this merge is done.,"Looks like addEdge(), removeEdge() has the same logics as the base class. Why do we need to override here?","all of these sample graphs need a ""name"" property of some sort. that's why the build is currently failing for me. please ""final"" the two Vertex variables.","We could use just one if: java if (Objects.equals(parent, element)) { // ...",Missing encoding StandardCharsets.UTF_8,@dskalenko move null to right hand side,This code creates a HashSet object even though v exists.
"public ResponseDefinition execute(Admin admin, Request request, PathParams pathParams) { BrowserProxySettings browserProxySettings = admin.getOptions().browserProxySettings(); KeyStoreSettings caKeyStore = browserProxySettings.caKeyStore(); try { X509KeyStore x509KeyStore = new X509KeyStore(caKeyStore.loadStore(), caKeyStore.password().toCharArray()); X509Certificate certificate = x509KeyStore.getCertificateAuthority().certificateChain()[0]; return new ResponseDefinitionBuilder() .withStatus(HTTP_OK) .withHeader(""Content-Type"", ""application/x-pem-file"") .withBody( ""-----BEGIN CERTIFICATE-----\r\n"" + BASE64_ENCODER.encodeToString(certificate.getEncoded()) + ""\r\n"" + ""-----END CERTIFICATE-----"" ) .build(); } catch (Exception e) { StringWriter stacktrace = new StringWriter(); e.printStackTrace(new PrintWriter(stacktrace)); return new ResponseDefinition( HTTP_INTERNAL_ERROR, ""Failed to export certificate authority cert from "" + caKeyStore.path() + ""\r\n"" + stacktrace ); } }","Could we just log the stacktrace, rather than sending it on the response?",This will not be closed if CertificateException is thrown?,logErrorAndThrow() will throw RuntimeError internally. A ClientLogger can't be static and the naming of ClientLogger variable has to be 'logger'. It applies to other changes as well.,"We can try-with-resources this: java try (InputStream stream = new ByteArrayInputStream(publicCertificate)) { CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509""); return certificateFactory.generateCertificate(stream); }",Does this contain the file name?,we will need to keep the old method signature as well as this method is protected and so changing its signature is a API breaking change,"I am still tempted to think this should be shorter rather than longer, i.e. it is an out of the box solution not a long term solution.",Unclosed ByteArrayInputStream.,Having the clear password in memory once is bad ...,These ^ could be final.,getBytes(CharsetUtil.US_ASCII)
"public Function<Element, LeaseElement> parser() { return (element -> { NodeList childElements = element.getElementsByTagNameNS(NAMESPACE_STRING, LEASE_LENGTH_ELEMENT_NAME); if (childElements.getLength() != 1) { LOGGER.error(""Found "" + childElements.getLength() + "" lease-length elements. The XSD should have prevented this.""); throw new AssertionError(""The schema for connection-leasing element requires one and only one lease-length element""); } Element leaseLengthElement = (Element)childElements.item(0); String leaseLengthString = leaseLengthElement.getTextContent(); LOGGER.info(""Found lease length XML text: "" + leaseLengthString); String timeUnitString = leaseLengthElement.getAttribute(TIME_UNIT_ATTRIBUTE_NAME); LOGGER.info(""Found lease length time unit: "" + timeUnitString); LeaseElement leaseElement = new LeaseElement(); leaseElement.setLeaseValue(leaseLengthString); leaseElement.setTimeUnit(timeUnitString); return leaseElement; }); }",can't we set these values in the constructor?,getPrefix returns null if there is no prefix so this will throw an NPE.,"I hope, you are right.","Instead of invoking both, wouldn't it be better to have the eviction stuff merely act as a facade to the memory configuration",@tmjee same here shutdown awaitTermination shutdownNow,meant one element with 2 minutes and another element with 120 seconds for e.g.,"Use the new ModelNode op:  if (resourceMode.hasDefined(attribute.getName(), valueType.getName())) {  That call has no chance of mutating a ModelNode where doing so isn't wanted, so I want us to start using it.","Put elem.attribute(""readonly"") in a local variable. Same below.",Error occurred while creating a new XMLEventReader from StringReader.,can't you write this with a stream? java return children.stream() .filter(child -> child.getNodeType() == Node.ELEMENT_NODE) .map(Element.class::cast) .filter(element -> element.getTagName().equals(name)) .findFirst();,Error occurred while using SAXParserFactory to create a SAXParser.
"XAResourceRegistryFile(Xid xid) throws SystemException { final String xidString = SimpleXid.of(xid).toHexString('_'); this.filePath = xaRecoveryPath.resolve(xidString); try { fileChannel = doPrivileged((PrivilegedExceptionAction<FileChannel>) () -> { final SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new FilePermission(xaRecoveryPath.toString() + File.separatorChar + '*', ""read,write"")); } xaRecoveryPath.toFile().mkdir(); return FileChannel.open(filePath, StandardOpenOption.APPEND, StandardOpenOption.CREATE_NEW); }); openFilePaths.add(xidString); fileChannel.lock(); Log.log.xaResourceRecoveryFileCreated(filePath); } catch (PrivilegedActionException e) { throw Log.log.createXAResourceRecoveryFileFailed(filePath, (IOException)e.getCause()); } catch (IOException e) { throw Log.log.createXAResourceRecoveryFileFailed(filePath, e); } }",@tadamski If you cache this FilePermission in the containing FileSystemXAResourceRecoveryRegistry object you will save a per-transaction objection creation/gc.,"I see above catch block for ClassNotFoundException doesn't also throw anything like this catch block, but isn't it bad practice?","I am curious couldn't we just test this by default given that all schemas need to be present in ""schema/"" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.",Which file descriptor did we open here? This statement seems to be at the wrong place.,tracef,Looks like we should check for null for both of these and set to the default value if null.,Is this the right error message here?,assertTrue avoids the double negative,can be info,Shouldn't be the schema named wildfly-wise-... ?,do we need to worry about null here? (this is retrieving a thread local that is initially set within the instance of CommandLinePropertySourceOverridingListener upon receiving the ApplicationEnvironmentPreparedEvent)
public void fromRunnable() { Completable.fromRunnable(new Runnable() { @Override public void run() { } }) .test() .assertResult(); },I'd increment a counter and assert its 1.,I have a different opinion on this. I would like to see mockito fail here. It indicates that the dev made something unintended and it is easy to fix.,Assert with counter. You could return it's value and assert you only get 1 and that a subsequent call gets 2,Please use TestException so we don't mistake them with any other RuntimeException failures.,nit: remove final (here and elsewhere in this file),"It would have been better to use DisabledCondition.class.getName() to avoid relying on a String value but DisabledCondition is not public, is making it public something that can be considered ? This is not a blocker for this PR ;-)",should not all of those be cs instead of ms for MaybeSubject ?,static import,test name does not correspond to the test class name - unsure what are testing here?,"No need to talk to a mocked observer, TestObserver.assertEmpty() already verifies these.",Please verify that the correct inner exceptions are received. Example: <LINK_0>
"public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { HttpRequest request = (HttpRequest) e.getMessage(); ChannelBuffer content = request.getContent(); if (content.readable()) { sendMessage(MessageBuilder.withPayload(content.toString(Charset.forName(""UTF-8""))).build()); } writeResponse(request, e.getChannel()); }","I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??",why charset == null? if charset is not available it should use default charset.,null initialization is redundant.,"actually, MessageContent could have this as a static method.",Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.,"Never compare to true, this is useless.","It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?",@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho,"no, the case is different for websocket because there is no payload, so no need to receive specific data, in general the application is not interested to receive ping (as it would anyway response with a pong). However it is interested to send ping to check if the connection is still alive.",nit: you can merge lines above as checkNotNull will return the given argument,Something has been missed here... I don't see the MailHeaders.CONTENT_TYPE in the DefaultMailHeaderMapper. Just a simple omission? Let me know and I'll fix on merge!
public BaseResourceReferenceDt setResource(IBaseResource theResource) { myResource = theResource; return null; },null?,This also seems kinda pointless and a bit brittle. Just return resource.,Should we return an explicit IStatus.ERROR instead? * It would avoid potential NPEs on the client side. * It would make it clear that this method should not have been called on an ResourceStrategy which explicity says it does not handle this method.,"This should be private, as we don't want the resource attribute to be set externally.",why null?,style nit: we don't use curly braces around single line blocks,"Declare this abstract or with a default implementation, then override in subclasses. VarDeclaration always contains a resource; ValDeclaration contains one depending on it's type; TypeDeclaration never contains a resource.",This should also have an java if (theResource instanceof IResource) { ..... }  ..to cover the DSTU2 structures.,"Well, @jglick-style violates the recommended code style",This creates a copy that is then wrapped by another copy and then made unmodifiable. The ResourceBuilder is in the same package with ResourceImpl so we should be able to not have to copy so much? I.e. the setX method is package private.,yep figured out i need to rectify the configuration [here](<LINK_0> but i opted for the easier way c7e02e7 as not to run them in the osgi container.
"@Override public Frame fetch(StatementHandle h, long offset, int fetchMaxRowCount) throws NoSuchStatementException { final CalciteConnectionImpl calciteConnection = getConnection(); CalciteServerStatement stmt = calciteConnection.server.getStatement(h); final Signature signature = stmt.getSignature(); final Iterator<Object> iterator; if (stmt.getResultSet() == null) { final Iterable<Object> iterable = _createIterable(h, signature, null, null); iterator = iterable.iterator(); stmt.setResultSet(iterator); } else { iterator = stmt.getResultSet(); } final List rows = MetaImpl.collect(signature.cursorFactory, LimitIterator.of(iterator, fetchMaxRowCount), new ArrayList<List<Object>>()); boolean done = fetchMaxRowCount == 0 || rows.size() < fetchMaxRowCount; @SuppressWarnings(""unchecked"") List<Object> rows1 = (List<Object>) rows; stmt.setResultSet(null); return new Meta.Frame(offset, done, rows1); }","This is too aggressive :( The iterator is not released after a call ended because it might not be fully read. If I'm not wrong, setting it to null would cause infinite loop when result row count is large enough.","This should be rs, I guess",this code seems to be for reverse/prior and belongs to another JIRA. can we remove this if it can affect the functionality?,Move this to the finally block?,"Minor, but how about Collections.<SQLCloseable>emptyList() instead here so we don't have to worry about null?",Unnecessary braces for single statement block (there are bunch of these in this file).,"I suggest to add methods for retrieving property value in Source (or in RowProperties) class:  Schema getRuntimeSchema(RuntimeContainer container) { Schema schema = rowProperties.schemaFlow.schema.getValue(); if (AvroUtils.isIncludeAllFields(schema)) { schema = getEndpointSchema(container, rowProperties.table.tableName.getValue()); } }   String getPreparedStatementQuery() { return rowProperties.query.getValue(); }  etc","The first iterator method in AbstractDatabaseEngine had this signature:  public synchronized ResultIterator iterator(String query)  Then people added more iterator methods, some of them synchronized, some of them not. I think all methods that use the connection should be synchronized; this means this one would need to be synchronized, but all other iterator methods call this one and don't need to be.",Should it be an error to call this method if you can't actually get the result set? Feels like it strongly indicates misuse / coding error.,should use {}-placeholders instead of string concat,shouldn't we check for if (_closed) before we check for if(_next)?.
"public String getDeviceName() { String manufacturer = Build.MANUFACTURER; String model = Build.MODEL; String deviceName; if (model.startsWith(manufacturer)) { deviceName = StringUtils.capitalize(model); } else { deviceName = StringUtils.capitalize(manufacturer) + "" "" + model; } return deviceName == null ? ""Unknown Device"" : deviceName; }",final,"String.valueOf is only needed when the parameter isn't already a string, both Build.Manufacturer/Model are already strings.",Worth pushing this (and getLong) into MapUtils?,"Shouldn't we include just the SSLDs? Otherwise, if there are Kaifa smart meters in a system, we would be contacting those for their events as well.","The current approach results in a query per Kaifa device. It's much more efficient to let the DB do the filtering. Regardless of the solution: add an index on (device, date_time) to make the search more efficient.",Exists => Exist,"Why does Device have cpuAbis? (I realise this is pre-existing, but seems odd to be in DeviceBuildInfo too.)",The two logger.error above both seem to be more appropriately logger.warn unless system stability is affected.,"To reduce code duplication, create a function which gets the string and replaces empty values.","ExistingEntityException is thrown, isn't an UnknownEntityException a more valid choice?",Why this change?
"public BsmAdminPageEditWindow editAttribute(String key, String value) throws InterruptedException { getSelectWebElement(""attributeList"").selectByVisibleText(key); editAttributeWindow() .value(value) .confirm(); wait.until(ExpectedConditions.elementToBeClickable(By.id(""addAttributeButton""))); return this; }","This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?","This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?","confirmDialog should wait for presence or visibility of ""#ok"" instead of explicit wait here",Are we really need to wait 2 seconds if we are waiting on web element anyway later?,"""//div[text()='%s']"" looks too simple to reliably prevent confusing with wrong element.","It would be useful to have such operation in seleniumWebDriverHelper class: waitAttributeEqualsTo(By element, attributeName, expectedValue)",It should be checked before the call of the method.,Looks not nice),typo in attribuetContainer,it's better to user SeleniumWebDriverHelper#waitAndClick() method instead,I would prefer constant there.
@Test @Config(reportSdk=9) public void useOkHttpByDefault() throws Exception { Downloader downloader = Utils.createDefaultDownloader(Robolectric.application); assertThat(downloader instanceof OkHttpDownloader).isTrue(); },Maybe change this to assertThat(downloader).isInstanceOf(OkHttpDownloader.class) ?,Revert. Add // or something to prevent this.,"This catch statement isn't needed, no?",prefer to have // given // when // then sections,No need to change. I feel that it's from the refactoring action,"Please test it against full expected string, doesNotContain can be not sufficient.",It's better to match message exactly to expected string.,test name does not correspond to the test class name - unsure what are testing here?,this assert is redundant,The expected result should be added to the front.,Should we assert that it contains project?
"public void load(@NonNull Picasso picasso, @NonNull Request request, @NonNull Callback callback) { initializeIfFirstTime(); boolean signaledCallback = false; try { BufferedSource source = Okio.buffer(Okio.source(assetManager.open(getFilePath(request)))); try { Bitmap bitmap = decodeStream(source, request); signaledCallback = true; callback.onSuccess(new Result(bitmap, DISK)); } finally { try { source.close(); } catch (IOException ignored) { } } } catch (Exception e) { if (!signaledCallback) { callback.onError(e); } } }",You have a few more of these to update,"This creates a dependency from PreviewImageFragment - responsible for rendering and handling input events for the fragment showing images in the preview gallery - to the ThumbnailsCacheManager - responsible for handling thumbnais, that do not appear in PreviewImageFragment. Better move the static method rotataImage(...) to .utils.BitmapUtils.",same. Could be called back 2x,You should have moved it here.,Cache the call here and above.,Same as above. The return statement on line 55 is enough to fix the problem.,We don't really need the if/else condition here. We can just always create the bitmap with the fixed width and proportional height. It's ok if the original bitmap is smaller than our fixed width; it'll just be scaled up (a very uncommon case anyway).,You either need a hasDrawable() method or to delete hasBitmap() on Result,"This should be package scoped, not public.",suggestion this.cause = requireNonNull(cause);,"I don't think you want to give every callback every failure. I think you want to give a callback only its own failure and just stop processing. Most callbacks will show an error message to the user, and that's that."
"public void onLiveInstanceChange(List<LiveInstance> liveInstances, NotificationContext changeContext) { try { logger.trace(""Live instance change triggered from {} with: {}"", dcName, liveInstances); updateInstanceLiveness(liveInstances); if (!liveStateInitialized.get()) { logger.info(""Received initial notification for live instance change from {}"", dcName); liveStateInitialized.set(true); } helixClusterManagerMetrics.liveInstanceChangeTriggerCount.inc(); } catch (Throwable t) { errorCount.incrementAndGet(); throw t; } }","trace seems too low, how often will this happen?","minor: since this one is not under a lock, could you use AtomicBoolean and compareAndSet()?",nit: just do instanceConfigInitalized.set(true) in an finally block.,shall we have a lock for onLiveInstanceChange and getLiveInstances,Do you think incrementing the appropriate error based on the eventType makes sense here?,your other PR made a change to this function (to account for stopped replicas too) - does this change in the if still hold? (I think it should),I'm not sure that we need this one. I can't find any other unhandled failure events.,Why remove the timeouts?,Can you log the exception too?,"This change is not wrong. However, creating two synchronization blocks generally doesn't guarantee that the lock is yielded in between them. The JIT might even merge them together at run time. If something needs to happen in between the locks, then some other kind of mechanism has to be used to wait for it. So the change is not wrong, but it's not really right either. :)",blank line
"public EncryptionServiceImpl() { String passwordDirectory = System.getProperty(""ddf.etc"").concat(""/certs""); String keysetLocation = Paths.get(passwordDirectory, KEYSET_FILE_NAME).toString(); synchronized (EncryptionServiceImpl.class) { File keysetFile = new File(keysetLocation); InputStream keysetFileInputStream = null; OutputStream keysetFileOutputStream = null; try { AeadConfig.register(); if (!keysetFile.exists()) { keysetHandle = KeysetHandle.generateNew(AeadKeyTemplates.AES128_GCM); keysetFileOutputStream = Files.newOutputStream(Paths.get(keysetLocation)); CleartextKeysetHandle.write( keysetHandle, JsonKeysetWriter.withOutputStream(keysetFileOutputStream)); } else { keysetFileInputStream = Files.newInputStream(Paths.get(keysetLocation)); keysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withInputStream(keysetFileInputStream)); } aead = AeadFactory.getPrimitive(keysetHandle); } catch (GeneralSecurityException | IOException e) { LOGGER.warn(""Problem initializing Tink. Enable debug logging for more information.""); LOGGER.debug("""", e); } finally { try { keysetFileInputStream.close(); } catch (IOException | NullPointerException ignore) { } try { keysetFileOutputStream.close(); } catch (IOException | NullPointerException ignore) { } } } }",Do a null check instead of catching the NPE. Can a try with resources be used?,Having the clear password in memory once is bad ...,These ^ could be final.,"Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class",There is already logging for that in the EncryptionUtils.encrypt catch block,IllegalArgumentException is possible here. I see it is not handled.,Use double try block to make logic simplier.  java try { InputStream is = new FileInputStream(keyStore); try { ... } finally { Closeables.closeQuietly(is); } } catch (...) { },Should this not be String.valueOf(k) here?,"Return value should not be discarded: if the server starts with an invalid certificate, it should not start at all. Here, it will still be used, allowing insecure connections to be possible.",Is there any way to recover from this? Maybe we could also give some kind of action to take.,This will break on Windows for sure. Please use the classloader.
"public static String updateOldDescription(String description) { String newDescription = """"; newDescription = updatePrisonerDescription(description); if (!newDescription.isEmpty()) { return newDescription; } newDescription = updateBondsmanDescription(description); if (!newDescription.isEmpty()) { return newDescription; } return """"; }",We can also move this up to the declaration and remove the meaningless initialization.,set your feature as transient,nit: how about we just use the class name of input strategy by default,Can we reuse the existing converter?,Please restore the original formatting.,+ desc,"Parsing html should be done outside of Feed.java. Feed is the model that represents the actual feed. How we display the feed afterwards does not belong to the feed itself, in my opinion.","Bug, you're setting description instead of summary.",unnecessary else after return,"I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.",Can we adhere to the coding style of this file and not have multiple return statements?
public void testCacheBehaviour(){ IgniteUtils.setCurrentIgniteName(ignite.configuration().getIgniteInstanceName()); int size = rows; cacheBehaviorLogic(size); },We dont need size variable here.,We should perform get with some timeout to prevent test hanging.,Indentation looks a little off here.,should not be message looked like: Schema 'rename' not found?,"Let's use setNearEvictionPolicyFactory here. I think we need 4 cases here: setEvictionPolicyFactory, setNearEvictionPolicyFactory, setEvictionPolicy and setNearEvictionPolicy. You can use factories in cache1 and plain policies in cache2.",this needs to be called for all configs,Added.,"since it is static, you should use class name (LRUCache.MAX_ENTRIES) or just omit this",Why lessThan(2)? How is 0 a valid state in this test?,"Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.",Apache license header is absent.
"private void runOneIteration() { try { LockWatchTestRuntimeConfig config = runtime.get(); if (config.namespaceToWatch().isPresent()) { LockWatchingResource lockWatcher = resource.apply(config.namespaceToWatch().get()); LockWatchRequest request = LockWatchRequest.of(config.tablesToWatch().stream() .map(TableReference::getQualifiedName) .map(LockWatchReferences::entireTable) .collect(Collectors.toSet())); LockWatchStateUpdate versionBefore = lockWatcher.getWatchState( OptionalLong.empty()); long startRegistering = System.currentTimeMillis(); lockWatcher.startWatching(request); log.info(""Registered lock watches for keyspace {} and tables {} in {} seconds."", SafeArg.of(""keyspace"", config.namespaceToWatch().get()), SafeArg.of(""tables"", config.tablesToWatch()), SafeArg.of(""seconds"", System.currentTimeMillis() - startRegistering)); long startUpdate = System.currentTimeMillis(); LockWatchStateUpdate versionAfter = lockWatcher.getWatchState(versionBefore.lastKnownVersion()); long duration = System.currentTimeMillis() - startUpdate; if (versionAfter.success()) { Optional<LockWatchEvent> result = versionAfter.events().stream() .map(event -> event.accept(filter)) .filter(Optional::isPresent) .map(Optional::get) .findFirst(); if (!result.isPresent()) { log.info(""Registered lock watches, but did not find any open locks. Took {} seconds"", SafeArg.of(""duration"", duration)); } else { log.info(""Registered lock watches, found {} open locks. Took {} seconds."", SafeArg.of(""numberOfWatches"", ((LockWatchOpenLocksEvent) result.get()).lockDescriptors().size()), SafeArg.of(""duration"", duration)); } } else { log.info(""Registered lock watches, but was unable to get an update. Last known version is {}"", SafeArg.of(""lastKnownVersion"", versionAfter.lastKnownVersion())); } } } catch (Throwable th) { log.info(""Failed to run a test iteration of registering lock watches"", th); } }","nit: The metric is millis, not seconds",nit: just call lastVersion() here?,"Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!","This feels like it's in the wrong place? You should be cleaning up when transactions are removed from the cache, not when they're added right? Otherwise, this will not be prompt.","from discussion below: can we use imperative statements here? I find this difficult to parse (I read the filter as a top-level thing that rejects versions that were unfriendly, when that's not the case).","nit: standard in other tests is to replace with _, not X. suggestion String tableName = UUID.randomUUID().toString().substring(0, 16).replace(""-"", ""_"");",I think this might be a bit simpler if we just use ifPresent(...)?,Not thread safe? I think you want synchronized on all methods in this class.,"Can you explain the dependency loop? This is weird and there should be a different solution. i.e. it feels to me like all the cache code should live alongside this class, or at least in this sub-project?","For completeness, can you also remove the ""Preconditions.checkArgument(!startTimestamps.isEmpty(), ""Cannot get events for empty set of transactions"");"" here; it's checked in the TimestampMapping","Looks a little iffy, but is correct"
"void preInit( FMLPreInitializationEvent event ) { if ( !Loader.isModLoaded( ""appliedenergistics2-core"" ) ) { CommonHelper.proxy.missingCoreMod(); } Stopwatch star = Stopwatch.createStarted(); this.configPath = event.getModConfigurationDirectory().getPath() + File.separator + ""AppliedEnergistics2"" + File.separator; AEConfig.instance = new AEConfig( this.configPath ); FacadeConfig.instance = new FacadeConfig( this.configPath ); AELog.info( ""Starting Pre Initialization"" ); CreativeTab.init(); if ( AEConfig.instance.isFeatureEnabled( AEFeature.Facades ) ) CreativeTabFacade.init(); if ( Platform.isClient() ) CommonHelper.proxy.init(); Registration.instance.PreInit( event ); if ( AEConfig.instance.isFeatureEnabled( AEFeature.VersionChecker ) ) { AELog.info( ""Starting VersionChecker"" ); this.startService( ""AE2 VersionChecker"", new Thread( new VersionChecker() ) ); } AELog.info( ""Pre Initialization ( ended after "" + star.elapsed( TimeUnit.MILLISECONDS ) + ""ms )"" ); }",you removed the ones on top but kept the brackets here?,What does this change do?,"If you agree, would you mind using null as a value for slaveConfig argument on those three configurations? Really we don't need to start a slave for this test, doing so we can save some seconds","You have to also remove the car and see whether they have get removed correctly, Also another usecase add a car that have some wrong configs (execution plan referring to stream 'foo' but stream 'foo' is not in car), and also check the deployment whether its correctly done and also remove that car and check whether its getting cleaned.",rename to automationContext,"lib folder should be already on the plugin classpath, is it now working? this will not work on all OS because you use file.separator and then you hardcode the file separator in the next piece of string ""/"". Pass a File instance used to build the path",minor thing: no need to concatenate strings here.,"please display ex.getMessage(), please dump debug stack trace","Why not delegate this to MagicalGoConfigXmlLoader itself? At least the finding, if not the init.","also remove the capp, after every test case CEP should come back to its initial state then only we can guarantee the next test will not fail!",This could (of course) also be done in the pom.xml (where I already add 2 listeners by default). Why does this need to happen in code (triggered by a system property)?
"public static void checkValidPath(String path) throws InvalidPathException { ObjectChecker chk = new ObjectChecker() .setSafeForWindows(SystemReader.getInstance().isWindows()); byte[] bytes = Constants.encode(path); int segmentStart = 0; try { for (int i = 0; i < bytes.length; i++) { if (bytes[i] == '/') { chk.checkPathSegment(bytes, segmentStart, i); segmentStart = i + 1; } } chk.checkPathSegment(bytes, segmentStart, bytes.length); } catch (CorruptObjectException e) { throw new InvalidPathException(e.getMessage()); } }",Likewise.,"setSafeForMacOs, too?",How about also throwing an InvalidPathException in this case?,Maybe use System.lineSeparator() instead of \n for better Windows support (since Windows uses \r\n)?,"@yufeldman In the first case, you merge absolute and relative path, in the second case, there is an attempt to merge two absolute path, should they be handled differently if merging two absolute path should be allowed at all?",We never list runtime exceptions in throws,"should this be wrapped in some sort of a loop, which breaks when path == objectName? I'm thinking of the ../../somethingSomething case",style-nit: avoid braces for simple constructs,Functions.isWindows perhaps?,NIT: can use Functions.isWindows(),This can be made more compact.
public static float convertLightCountsToLux(final int rawCount) { final float maxLux = 125.0f; final float maxCount = 65536.0f; final float whiteMultiplier = 2.0f; final float internalIntensity = ((float) rawCount / maxCount) * maxLux; return (whiteMultiplier * internalIntensity); },this is possibly a breaking change for timelines. Was it tested?,create a constant so it make's sense? I have no idea what is 18 atm,braces please! {^_^},"I would make this and the above private for now, if there's no other code using it.","Might as well use your provided constants, Weights.BUILT_IN_CONVENTION.",should this be in some MathUtils class?,Please indicate possible values in Exception message,let's explain this constant,create a constant so it make's sense? I have no idea what is 18 atm same for above an below,this.,It took me a few minutes to understand where the +0.5 was coming from. Basically its just to round the decimal number right ? So if we want 8 decimals and want to truncate number 3.123456786:  3.123456786 * 10E8 + 05 = 312345678.6 + 0.5 = 312345679.1  Then we use Math.floor() to get the largest integer that is less than or equal to the argument.
"private boolean getNodeMemberships(Element subscriptions) throws NodeStoreException, InterruptedException { ResultSet<NodeMembership> cur = channelManager.getNodeMemberships(node); if (channelManager.isLocalNode(node)) { subscriptions.addAttribute(XMLConstants.NODE_ATTR, node); for (NodeMembership ns : cur) { if (actorJid.toBareJID().equals(ns.getUser().toBareJID())) { Element subscription = subscriptions.addElement(XMLConstants.SUBSCRIPTION_ELEM); subscription.addAttribute(XMLConstants.NODE_ATTR, ns.getNodeId()) .addAttribute(XMLConstants.SUBSCRIPTION_ELEM, ns.getSubscription().toString()) .addAttribute(XMLConstants.JID_ATTR, ns.getUser().toBareJID()); if (null != ns.getInvitedBy() && isOwnerModerator()) { subscription.addAttribute(XMLConstants.INVITED_BY_ELEM, ns.getInvitedBy().toBareJID()); } } } } else { if (!channelManager.isCachedNode(node) || (null != requestIq.getElement().element(XMLConstants.PUBSUB_ELEM).element(XMLConstants.SET_ELEM)) && !cur.isEmpty()) { makeRemoteRequest(new JID(node.split(""/"")[2]).getDomain()); } return false; } return true; }","This should be a not comparison, original line:  java if (false == actorJid.toBareJID().equals(ns.getUser())) {  Basically we don't want to show a subscription != 'subscribed' to anyone but the owner/admin or the user themselves.","can we just return true? If it is true, no need to loop remaining objects right?","Below way is good for performance I guess.  java for (int i = 0, size = first.size(); i < size; i++) {",Braces?,Extra spaces,Never swallow exceptions without at least logging them. In this case: Why not throw them?,What happens if/when e1.getNodeid() is null?,"You need to re-set the interrupted status of the thread here by calling Thread.currentThread().interrupt(). Also, wrapping InterruptedException is generally not a good idea; better to just have a message that says ""operation was interrupted"" or something.","no need to check for testName != null. I think it can't be null and if it is, the getTestResources(testName) will throw a NPE when accessing the map.",You could use functional style expression like: suggestion return node.orElse(null);,Do we need the service-service unavailable check here? I'd expect prosody and most servers to either create the node or throw a conflict error.
"public void testRestart() throws RunScriptOnNodesException { final String groupName = String.format(NAME_PREFIX, System.getProperty(""user.name"").substring(0, 3)); Set<? extends NodeMetadata> nodes = view.getComputeService().rebootNodesMatching(inGroup(groupName)); assertTrue(nodes.size() > 0); boolean allRestarted = false; while (!allRestarted) { nodes = view.getComputeService().listNodesDetailsMatching(nameStartsWith(groupName)); for (NodeMetadata node : nodes) { if (node.getStatus() != NodeMetadata.Status.RUNNING) { allRestarted = false; try { Thread.sleep(30 * 1000); } catch (InterruptedException e) { } continue; } else { allRestarted = true; } } } assertTrue(allRestarted); view.getComputeService().destroyNodesMatching(inGroup(groupName)); }",All the above tests are already covered by the BaseComputeServiceLiveTest. You should subclass that one and try to make all tests pass without overriding its methods (as that is our compute service implementation contract). Take the [DigitalOcean](<LINK_0> one as an example.,Please fix indents and use assertNotNull,Replace Assert.assertFalse by assertThat so you'll keep using the same library in all the class,Replace Assert.assertFalse by assertThat so you'll keep using the same library in all the class,"[minor] replay(node, computeService);?",Remove this :),Add an assertion to check the hardwre id.,You should put all the inits inside the try.,can you explain why did you change the null to N/A?,"These asserts are not testing anything related to the webservices.rest module, they're just calling Obs.getGroupMembers(). You should be doing resource.getGroupMembers(resource.getByUniqueId(""...""))",waitFor()?
"private void registerExternalProvidersTrustStore(DefaultHttpClient httpClient) { try { KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream inputStream = new FileInputStream( new File(EngineLocalConfig.getInstance().getExternalProvidersTrustStore().getAbsolutePath())); try { trustStore.load(inputStream, EngineLocalConfig.getInstance().getExternalProvidersTrustStorePassword().toCharArray()); } finally { inputStream.close(); } SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore); Scheme sch = new Scheme(""https"", 443, socketFactory); httpClient.getConnectionManager().getSchemeRegistry().register(sch); } catch (Exception ex) { log.warn(""Cannot register external providers trust store: {}"", ex.getMessage()); } }",instead you could use the try-with-resource paradigm,truststoreUrl / trustStoreUrl,"While setting up the server & client not a part of this library or PR, it would nice to set the integration test server and client up to only use TLS 1.2.","What's 80? Let's avoid using 'magic numbers' within any implementation. Instead, read these values from a configuration file. Also use appropriate constants upon the same.",We don't want stack trace prints as part of tha code flow. I suggest throw new RuntimeException(e) instead.,"Why can't we use here something like this?  TrustManagerFactory tmf = TrustManagerFactory.getInstance(""SunX509""); tmf.init(null); c.init(null, tmf.getTrustManagers(), null);",Having the clear password in memory once is bad ...,"if sslVerify is false we want to enter this block hence this should read: if (!repo.getConfig().getBoolean(""http"", ""sslVerify"", true))",These ^ could be final.,guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?,why this algorithm specifically?
"public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); TextView filesText = (TextView) view.findViewById(R.id.files_text); view.findViewById(R.id.finish_button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (activity != null) { activity.finish(); } } }); filesText.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (parent != null) { Intent intent = new Intent(Intent.ACTION_GET_CONTENT); Uri uri = Uri.parse(parent); intent.setDataAndType(uri, ""resource/folder""); startActivity(Intent.createChooser(intent, ""Open folder"")); } } }); int numFiles = 0; Bundle args = getArguments(); if (args != null) { ArrayList<File> files = (ArrayList<File>) args.getSerializable(GeoTagImagesService.EXTRA_GEOTAGGED_FILES); numFiles = files.size(); if (files != null && numFiles > 0) { parent = files.get(0).getParent(); } } if (parent != null) { filesText.setText(String.format(getString(R.string.photos_geotagged), String.valueOf(numFiles), parent)); } else { filesText.setText(getString(R.string.no_files_geotagged)); } }",@chaviw no point checking for files being null here since you already call files.size() above.,can you change this to protected static? This order is really unconventional,This change is unrelated.,You can remove this to simplify it to getActivity().finish();,"This HashMap seems unnecessary to me because you can call intent.putExtra() directly for each value. The Bundle that stores these ""extras"" in the Intent is essentially a map.",Don't log errors as debug. Please use error log instead.,Should we call the function below instead?,"Check for debug enabled if (Constants.DEBUG_MODE_ENABLED) { Log.d(TAG, ""Starting File upload service""); }",Indentation problem (again tabs vs spaces),These empty implementations can be removed I guess,"Maybe we should have an enum for notification tags? Also, in Java isn't 001 the same as 1?"
public Boolean attachStdin() { return (attachStdin != null) ? attachStdin : Boolean.FALSE; },if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?,this is self assignment - please modify to: this.attached = attached,My bad. Tridiums Niagara does that with their version of Boolean and I just had to fix that for Distech.,return Boolean.parseBoolean(getFieldValue(field).toString());,I find these could be useful outside of the package.,Qualify field access,The error message doesn't match the actual behaviour.,I would recommend an else if here to avoid comparing against a string unnecessarily.,"You probably also want to support ""boolean.class""",This could just be Boolean.parseBoolean(string);,sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
"public NonTerminal(String name) { this.name = name; this.entryState = new EntryState(name + ""-entry"", this); this.exitState = new ExitState(name + ""-exit"", this); }",I still think you should throw an exception if name is null,"oh, this comes form apache. Maybe jsut ust """" even if it is not that readable.","Use Optional.getOrElse() here. E.g. String fromState = this.fromState.getOrElse(""_"")",Modifier 'private' is redundant for Enum constructor - needs to be removed.,"why is this needed? You said you want to remove it, but why was it added in the first place? What's stopping it from being trivially removed?",Formatting,Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.,Please assert what the nullable state is.,Please assert what the nullable nonterminal is.,Please assert what the nullable nonterminal is.,The this. in getters are unnecessary too.
public void determineNextResync(ZonedDateTime now) { this.nextResync = now.plusNanos(this.resyncPeriodInMillis * 1000000); },"Can't really understand what's going on here. We multiply by 1,000,000 a millisecond unit and add it as a nanosecond? (it would _probably_ make sense if we divided instead of multiply, but then why not just do now.plus(resyncPeriodInMillis, ChronoUnit.MILLIS))",Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;,Shouldn't this be Calendar.getInstance() instead ? That way it's truly a no-op.,currentTimeMillis() instead of creating a new DateTime() object,"This lets you chain the tickers, though I don't think we used this functionality",getNextTimeAdjustedByDay -> DateTimeUtils.getNextTimeAdjustedByDay,"nit: can we make a constant called HOUR_IN_SECONDS, that contains 3600?",Could you change it to 10000 (and the MapperRenderingProcessor to 9999). That's the interval specified in the docs of getPriority().,Refactor to increase readability: - create private method to determine the next notification time for the response data and compare this with the current time in order to determine if a notification should be sent,"Why is this setter public, we have a builder which is responsible to do the object creation ?",Where do these numbers come from?
"@Test public void testArrayGetCloneRefCouples() throws Exception { Run(""@a = array('Meow'); @b = array(@a, @a, array(@a)); @c = @b[]; msg((ref_equals(@b[0], @b[1]) && ref_equals(@b[0], @b[2][0])));"", fakePlayer); verify(fakePlayer).sendMessage(""true""); }","@c is not used here, I think you meant for it to be.","The fail is hard to interpret, I think we can improve on using String arrays instead. Also indentation is weird in the entire file.","Calling fail() throws an AssertionError, so you'll get a confusing error message if we ever get here. When testing code that should throw an AssertionError it's best to use this pattern:  try { callThatShouldThrowAssertionError(); } catch (AssertionError expected) { // optional: make assertions on expected here return; } fail(""Expected AssertionError to be thrown"");","I think it would be more explicit to ""hard-code"" [] in this case, wouldn't it? java assertMessageEquals(ex, ""array contents differ at index [3][0][1][0], expected: <5> but was: <[]>"");",@ivandalbosco I'm not sure of the value of this test.,Would prefer this as Hamcrest assertThat for consistency.,I think we can do away with this condition because its already been taken care of by the other two edit checks above it.,"These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.","There is a function called dyn() which is meant for use in these cases, as eventually, once more static analysis is complete, this will also cause the same warning. <LINK_0> This forces the compiler to treat the value as dynamic, even if it's hardcoded, and is the preferred solution in this case, and in the eval case as well.",I think it is enough for the test to assign and check only once.,"A few more cases discussed during review: * can we have a test for getRefsByPrefix()? * what about ordering of the result? It seems like it's well defined, so should this use something like assertArrayEquals? * what happens with overlapping prefixes?"
"void resizeArray(int newArraySize) { long[] newArray = new long[newArraySize]; System.arraycopy(this.array, 0, newArray, 0, this.array.length); this.array = newArray; }",I think this will fail if the new size is smaller than the current one. Could be checked with an assert (private methods).,we can define a constant MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;,s/leased/borrowed,"@fchauveau there is no null handling of source, is this intended ?",I think it should return Array here.,I think it should return Array here.,A bit shift would be faster ? Also we don't check for integer overflow issues.,"is there an implicit assumption that you will always move ""forward""? i.e. that locusPosition is always greater than offset? if so, please assert this in the top of the method.","I think this is a simpler test to cover the cases in this loop:  assertEquals(BlockUtil.calculateNewArraySize(200), 300); assertEquals(BlockUtil.calculateNewArraySize(Integer.MAX_VALUE), MAX_ARRAY_SIZE); try { BlockUtil.calculateNewArraySize(MAX_ARRAY_SIZE); } catch (IllegalArgumentException e) { assertEquals(e.getMessage(), format(""Can not grow array beyond '%s'"", MAX_ARRAY_SIZE)); }",I think it should return Array here.,nit: remove brackets to be consistent with 2 lines below.
"public void onResume() { super.onResume(); if (mSelectRoleShareVM.isRemoveSeleted()) { showSpinner(); mCollaborationsShareVM.deleteCollaboration(mSelectRoleShareVM.getCollaboration()); mSelectRoleShareVM.setRemoveSelected(false); } else { if (mSelectRoleShareVM.getSelectedRole().getValue() != null && mSelectRoleShareVM.getCollaboration() != null) { if (mSelectRoleShareVM.getSelectedRole().getValue() != mSelectRoleShareVM.getCollaboration().getRole()) { if (mSelectRoleShareVM.getSelectedRole().getValue() == BoxCollaboration.Role.OWNER) { AlertDialog dialog = new AlertDialog.Builder(getActivity()).setTitle(R.string.box_sharesdk_change_owner_alert_title) .setMessage(R.string.box_sharesdk_change_owner_alert_message) .setPositiveButton(android.R.string.yes, (d, which) -> { showSpinner(R.string.box_sharesdk_fetching_collaborators, R.string.boxsdk_Please_wait); mCollaborationsShareVM.updateOwner(mSelectRoleShareVM.getCollaboration()); }).setNegativeButton(android.R.string.no, (d, which) -> {}).setIcon(android.R.drawable.ic_dialog_alert).create(); dialog.show(); } else { showSpinner(); mCollaborationsShareVM.updateCollaboration(mSelectRoleShareVM.getCollaboration(), mSelectRoleShareVM.getSelectedRole().getValue()); } mSelectRoleShareVM.setSelectedRole(null); } } } if (mCollaborationsShareVM.getCollaborations().getValue() == null) { mCollaborationsShareVM.fetchItemInfo(mCollaborationsShareVM.getShareItem()); } }",removeSelected?,No need to check this.,is that possible this is null?,null check,Remove?,This can be simplified as follows if(refresh != null) { refresh.cancel(); },Please use constants defined here: <LINK_4>,rename 'resource',Too bad theres no natural place to put this blurb :( Kind of irks me that we have this repeated thrice but I also am not a fan of multiple base classes.,Removing....,"Thanks for the investigation! > If we can confirm that the stored display name will never be empty, I think it would be possible to simplify the logic of changedDisplayName() so that it simply compares the value of the text field with the stored one. What do you think? Sounds good to me, I haven't checked yet how the AccountModel is initialized, but I guess it's done during user creation POST call (after the email confirmation)."
"void stop() { allocatorExecutor.shutdown(); try { if (!allocatorExecutor.awaitTermination(3, TimeUnit.SECONDS)) { log.warn(""Timedout while awaiting for allocatorExecutor's termination, so force shuttingdown""); } } catch (InterruptedException e) { log.warn(""Got InterruptedException while awaiting termination of allocatorExecutor, so force shuttingdown""); } allocatorExecutor.shutdownNow(); log.info(""Stopped entry logger preallocator.""); }","We can give some more time, like 30 seconds.","Maybe rewrite to avoid another concatenation?  logger.log(Level.INFO, ""{0} (took {1})"", new Object[] {logMessageOnSuccess, DurationFormatUtils...)",This should probably be removed,I think shutdown should be invoked first before awaitTermination.,Bump all the numbers,use client.shutdown(),"Would you need the similar thread join pattern for the container placement handler thread , similar to the container allocator thread?",This is a breaking change.,"FYI, TimeUnit.SECONDS.sleep(seconds.longValue())","Nit could we use the slf4j logging format like  LOG.info(""Halting after {} second"", numSeconds);",- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
"public AbstractLunAvailableSizeColumn() { super(new AbstractToggleButtonCell<LunModel>() { @Override public void onClickEvent(LunModel lunModel) { if (lunModel !=null) { lunModel.setAdditionalAvailableSizeSelected(!lunModel.isAdditionalAvailableSizeSelected()); } } @Override public void render(Context context, LunModel value, SafeHtmlBuilder sb, String id) { boolean isGrayedOut = value.getIsGrayedOut(); String inputId = id + ""_input""; SafeHtml input = null; int additionalAvailableSizeSize = value.getAdditionalAvailableSize(); String additionalAvailableSizeSizeString = ""+ "" + additionalAvailableSizeSize + "" GB""; if (additionalAvailableSizeSize == 0 || !value.getIsIncluded()) { input = templates.disabled("""", ""color:gray"", inputId); } else if (!isGrayedOut) { input = templates.disabled("""", ""color:black"", inputId); } else if (value.isAdditionalAvailableSizeSelected()) { input = templates.toggledDown(inputId, additionalAvailableSizeSizeString); } else { input = templates.toggledUp(inputId, additionalAvailableSizeSizeString); } sb.append(templates.span(id, input)); } }); }",redundant black line,"try removing this if out to line 53, and remove 'value.isRemoveLunSelected()' from line 54..","Appears twice:""vertical-align:middle;"". Is it intentional?",Instead of adding inline styles like this could you pass in a class name that we apply to the element instead? This makes maintenance a lot easier as well as making branding applying different styles.,Why would you have a tooltip if the cell doesn't display anything?,Let's have a blank line between the methods,I'd move these to line 35 (before the if).,"value.toString() vs. factory.convert(..) a bit lower, line 63, again",What about &gt; and a bunch of other encoded string elements? wouldn't it make more sense to use a generic encoder/decoder?,please replace with TextUtils.isEmpty (i.e. instead of the static import that's there now),"nit: you don't need this line, and you can then inline the casting."
"public String getPendingViewAsString() { CacheTopology cacheTopology = stateTransferManager.getCacheTopology(); return (!(cacheTopology != null && cacheTopology.getPendingCH() != null)) ? ""N/A"" : cacheTopology.getPendingCH().getMembers().toString(); }",Reverse the operands to avoid negation maybe? Would look nicer.,It is good to have a method to convert config.get(Config.TOPOLOGY_RELIABILITY_MODE) to enum and then compare two enum values. Comparing two Strings is error prone.,"TopologyData may be a better name, since this is just a wrapper for holding the topology entities, not really building the topology.",AuthorizationException can be removed,protected constructor was added with purpose not as a mistake.,"This is the topology at the time of submission, not the latest one, which is what you want right?. The latest one can be gotten from the current physicalPlan.getTopology(), but even that one doesn't contain updates to the config (e.g. parallelism) since creation. If that's needed see UpdateTopologyMaster.",I think the cache topology is never null. what case do you have in mind?,please move the isEmpty methods to the scimSchema,unnecessary cast,@weijjia I think this new commit needs your CR/approval.,invert contains and null condition please. It's not necessary to call contains if proto == null
"public void scrutinize(ItemUpdate update) { Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>(); for (Statement statement : update.getAddedStatements()){ PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId(); Value value = statement.getClaim().getMainSnak().getValue(); propertyIdValueValueMap.put(pid, value); } for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){ List<PropertyIdValue> conflictingProperties = _fetcher.getConflictsWithProperties(propertyId); if (conflictingProperties != null){ for (PropertyIdValue conflictingPid : conflictingProperties) { if (propertyIdValueValueMap.containsKey(conflictingPid) && raiseWarning(propertyId, propertyIdValueValueMap, conflictingPid)) { QAWarning issue = new QAWarning(type, propertyId.getId(), QAWarning.Severity.WARNING, 1); issue.setProperty(""property_entity"", propertyId); issue.setProperty(""added_property_entity"", conflictingPid); issue.setProperty(""example_entity"", update.getItemId()); addIssue(issue); } } } } }",We need to check to check what happens with no value and some value snaks.,Should we use a lower severity level for warnings on existing items?,"A little sanitization here would make a lot of sense, if nothing else make sure no ' ?",Log string concatenation,Is this plotted in grafana?,please add curly braces here (even though it's a One-liner),you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...,Please add braces surrounding the for loop block. Otherwise this is confusing to read.,"It's better to put the value at the end rather than delimiting it: java ""Duplicate property: %s""","Style-nit: Our public API should return Map, Set, List and not a concrete implementation type. Sorry I missed this during earlier review iterations.",space
"public SSLContext get() { Credentials currentCreds = checkNotNull(creds.get(), ""credential supplier returned null""); String keyStorePassword = checkNotNull(currentCreds.credential, ""credential supplier returned null credential (should be keyStorePassword)""); KeyManagerFactory kmf; try { kmf = KeyManagerFactory.getInstance(""SunX509""); kmf.init(keyStore.get(), keyStorePassword.toCharArray()); SSLContext sc = SSLContext.getInstance(""TLS""); sc.init(kmf.getKeyManagers(), trustManager, new SecureRandom()); System.setProperty(""https.protocols"", ""TLSv1""); return sc; } catch (NoSuchAlgorithmException e) { throw propagate(e); } catch (UnrecoverableKeyException e) { throw propagate(e); } catch (KeyStoreException e) { throw propagate(e); } catch (KeyManagementException e) { throw propagate(e); } }","find a better way, this is super dodgy",Potential NullPointerException if the property is not defined,"While setting up the server & client not a part of this library or PR, it would nice to set the integration test server and client up to only use TLS 1.2.",guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?,IllegalArgumentException is possible here. I see it is not handled.,This will break on Windows for sure. Please use the classloader.,propagate a proper exception here.,Having the clear password in memory once is bad ...,This 2 lines probably ought to be in the try block as technically sslContext could be null outside of it.,Why is it no longer private?,@SplotyCode can you make this package-private and remove the @deprecated  tag ?
"public void fromStream_user_providesToken() throws IOException { MockTokenServerTransportFactory transportFactory = new MockTokenServerTransportFactory(); transportFactory.transport.addClient(CLIENT_ID, CLIENT_SECRET); transportFactory.transport.addRefreshToken(REFRESH_TOKEN, ACCESS_TOKEN); InputStream userStream = UserCredentialsTest.writeUserStream(CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN); UserCredentials credentials = UserCredentials.fromStream(userStream, transportFactory); assertNotNull(credentials); Map<String, List<String>> metadata = credentials.getRequestMetadata(CALL_URI); TestUtils.assertContainsBearerToken(metadata, ACCESS_TOKEN); }",Fully-qualified class name not needed.,let's rename these variables too,SA == SERVICE_ACCOUNT? avoid abbreviations,"no final on local variables unless required, per Google style",expected value first,why not using assertUsernamePassword here?,Static import the assertion methods,"This isn't going to return null, so it would be better not to wrap it with assertNull.",Should be making use of StepVerifier instead of .block() on these tests.,"add a space after '+'. Also, you might want to avoid referring to coincidental details of the implementation, such as the fact that currently, the only path to providing the refresh token is the constructor; maybe we might add other paths to setting it later.",google style is to not use final on local variables unless it's required
"public void scan(HttpMessage msg, String param, String value) { if (this.inScope(Tech.Linux) || this.inScope(Tech.MacOS)) { if (matchBodyPattern(getBaseMsg(), patternSSIUnix, new StringBuilder())) { return; } if (testServerSideInclude(param, SSI_UNIX, patternSSIUnix)) { return; } if (testServerSideInclude(param, SSI_UNIX2, patternSSIUnix)) { return; } } if (this.inScope(Tech.Windows)) { if (matchBodyPattern(getBaseMsg(), patternSSIWin, new StringBuilder())) { return; } if (testServerSideInclude(param, SSI_WIN, patternSSIWin)) { return; } if (testServerSideInclude(param, SSI_WIN2, patternSSIWin)) { return; } } }","- This should be done in the previous if statement (after tech checks), to not return earlier (Windows test could still be done). Also, worth extracting a method to reduce code duplication (boolean isEvidencePresent(Pattern)?). - Since the result is not required the StringBuilder can be null.",Ensure that streams are closed. Use try-with-resources.,Is there a reason you chose _system_name environment variable instead of the os.name system property as described in the [Java properties](<LINK_0> tutorial?,I don't like catching all exceptions here. Can we narrow this to the actual exception thrown? And log a message other than just returning?,"Pattern.compile() is normally meant to compile a pattern once, and then re-use it. If you don't do that you can just define a Matcher directly.","Are we sure this alwyas _equals_ ""linux"" or would be using startsWith a safer option?","suggestion if (osArch.equals(""i686_64"") || osArch.equals(""x86_64"") || osArch.equals(""amd64"") || osArch.equals(""ppc64le"") || osArch.equals(""aarch64""))  Might as well solve two problems at once :) This also occurs with AArch64 Java.","suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);",Stray .build(),"I see that the other test does this, did you try without? If it's needed I'm curious why.","The JUnit rule ExpectedException could be used to have simply:  thrown.expect(IllegalStateException.class); thrown.expectMessage(""Version of ScannerForMSBuild should be higher than or equals to 4.1.0.1148 to be able to use .Net Core.""); build.setUseDotNetCore(true);"
"public void installServices(OperationContext context, ModelNode model) throws OperationFailedException { if (!context.isBooting()) return; ModelNode subsystemModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS)); if (subsystemModel.hasDefined(ProxyConfigurationResourceDefinition.WILDCARD_PATH.getKey())) { Set<String> adapterNames = new HashSet<>(); Set<LoadMetric> enabledMetrics = new HashSet<>(); for (Property property : subsystemModel.get(ProxyConfigurationResourceDefinition.WILDCARD_PATH.getKey()).asPropertyList()) { String proxyName = property.getName(); adapterNames.add(proxyName); ModelNode proxyModel = property.getValue(); ServiceTarget target = context.getServiceTarget(); ProxyConfigurationServiceConfigurator configurationBuilder = new ProxyConfigurationServiceConfigurator(proxyName); configurationBuilder.configure(context, proxyModel).build(target).install(); Set<LoadMetric> metrics = new HashSet<>(); LoadBalanceFactorProvider loadProvider = this.getLoadProvider(proxyName, metrics, context, proxyModel); enabledMetrics.addAll(metrics); String connector = CONNECTOR.resolveModelAttribute(context, proxyModel).asString(); int statusInterval = STATUS_INTERVAL.resolveModelAttribute(context, proxyModel).asInt(); new ContainerEventHandlerServiceConfigurator(proxyName, loadProvider).build(target).install(); for (ContainerEventHandlerAdapterServiceConfiguratorProvider provider : ServiceLoader.load(ContainerEventHandlerAdapterServiceConfiguratorProvider.class, ContainerEventHandlerAdapterServiceConfiguratorProvider.class.getClassLoader())) { provider.getServiceConfigurator(proxyName, connector, Duration.ofSeconds(statusInterval)).configure(context).build(target).setInitialMode(Mode.PASSIVE).install(); } } for (BoottimeHandlerProvider handler : ServiceLoader.load(BoottimeHandlerProvider.class, BoottimeHandlerProvider.class.getClassLoader())) { handler.performBoottime(context, adapterNames, enabledMetrics); } } }","Rather than iterate over the whole model twice, just use the Resource interface to nagivate through child resources once.","Once I fix <LINK_0> in a minute you can use PROPERTIES.unwrap(context, model) to replace L109-119.",Subsystems should no longer use the ModelController directly. They should create an in-vm client using a factory provided by the associated capability: <LINK_0>,context.getServiceTarget() should be replaced by context.getCapabilityServiceTarget(),WFLY-4294 says this op will fail in runtime on a server. But it looks like this one is still adding services.,"Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.","USERNAME.resolveModelAttribute(context, fullModel) not operation.","Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.","I don't think this is equivalent. There are other variants of DOWN than WONT_START and if those are true the existing code drops into a call to AbstractDeploymentUnitService.getStatus. And that checks a StabilityMonitor for both failed and problems and if either are found the result is DeploymentStatus.FAILED, not DeploymentStatus.STOPPED. In other words, DOWN due to missing dependencies -> DeploymentStatus.FAILED.",Use context.getCapabilityServiceTarget().addCapability(...) if possible.,What happened to MappingProviderResourceDefinition? From what I see this is the only place it is used but unless github is not showing correctly it has not been removed.
"public void onHelpClick() { UriUtil.visitInExternalBrowser(getContext(), Uri.parse(requireContext().getString(R.string.android_app_edit_help_url))); }","Hint: FeedbackUtil.java contains numerous convenience functions for visiting specific external pages, e.g. the FAQ page, the privacy policy, etc. We can simply add another function there that goes to this page.","You may also use this to access real primaryColor of the theme. I am not really sure which is the best. We are using different colorPrimary for DevFest, StudyJams etc.  ThemeUtils.getThemeAttrColor(context, R.attr.colorPrimary);",Do you really need this check?,suggestion /* package */ Intent buildIntentForUri(Uri uri) {,"Since it's present in all configurations, consider moving this object creation to the top of the method to occur unconditionally.",Niptick: Should we re-set the AppLock extended timeout here? AppLockManager.getInstance().setExtendedTimeout();,These empty implementations can be removed I guess,Indentation problem (again tabs vs spaces),"It might make sense to use try...finally here, putting enableDeepLinking in the finally block. Otherwise deep linking won't be re-enabled if something goes wrong.",Just call ActionUtil.share?,"FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET is deprecated, and why is needed?"
"public static Block read(final int major, InputStream inputStream) { final boolean v3OrHigher = major >= CramVersions.CRAM_v3.major; if (v3OrHigher) { inputStream = new CRC32InputStream(inputStream); } try { final BlockCompressionMethod method = BlockCompressionMethod.byId(inputStream.read()); final BlockContentType type = BlockContentType.byId(inputStream.read()); final int contentId = ITF8.readUnsignedITF8(inputStream); final int compressedSize = ITF8.readUnsignedITF8(inputStream); final int rawSize = ITF8.readUnsignedITF8(inputStream); final byte[] compressedContent = new byte[compressedSize]; InputStreamUtils.readFully(inputStream, compressedContent, 0, compressedSize); if (v3OrHigher) { final int actualChecksum = ((CRC32InputStream) inputStream).getCRC32(); final int checksum = CramInt.readInt32(inputStream); if (checksum != actualChecksum) { throw new RuntimeException(String.format(""Block CRC32 mismatch: %04x vs %04x"", checksum, actualChecksum)); } } final byte[] uncompressedContent = ExternalCompression.uncompress(method, compressedContent); if (uncompressedContent.length != rawSize) { throw new CRAMException(String.format(""Block uncompressed size did not match expected size: %04x vs %04x"", rawSize, uncompressedContent.length)); } switch (type) { case FILE_HEADER: return new FileHeaderBlock(method, compressedContent); case COMPRESSION_HEADER: return new CompressionHeaderBlock(method, compressedContent); case MAPPED_SLICE: return new SliceHeaderBlock(method, compressedContent); case EXTERNAL: return new ExternalDataBlock(method, compressedContent, contentId); case CORE: return new CoreDataBlock(method, compressedContent); default: throw new CRAMException(""Unknown BlockContentType "" + type.name()); } } catch (final IOException e) { throw new RuntimeIOException(e); } }","The validation seems like a good idea, but it does seem like it would be expensive to do speculatively. Maybe we should do it lazily on ""un-compression"" instead. We'd have to retain the original size from the stream, but thats cheap.","Can this be renamed so it and readFromInputStream have symmetric names to indicate they're companions ? Although, see my question above about if these are 'block-type' preserving.","In tests we can just declare that these methods and the test methods ""throw IOException"" rather than catching and wrapping them, and just get rid of the catch clause.","When doing the construction, inBuffer and outBuffer are newly allocated. The same goes for other variables. Is that better and possible if we keep the original initCipher method and invoke the initCipher in the method resetStreamOffset?","Is the comma at the end of this string there for a reason, or is it a typo?","Since this is not overridable, what about moving it to VCFTextTransformer and make it a factory method, e.g. VCFTextTransformer.fromVersion(). Another possible place for this is VCFHeaderVersion, e.g. VCFHeaderVersion.createTextTransformer().","Sorry, how do we assert the row is reset?",Maybe ContainerHeader should have a toBlock ?,Can this be streamlined by having version or CramVersions return the correct EOF_MARKER directly?,"If these didn't work, then you might need to call that layoutElements(), on ""content""'s parent.",lastReadInputCheckpoint is never used anymore. Could you remove?
"protected boolean validateSourceDomainsSpaceRequirements() { Map<Guid, List<DiskImage>> storageDomainsActiveImagesMap = new HashMap<>(); for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) { DiskImage diskImage = getDiskImageByImageId(parameters.getImageId()); if (diskImage.getActive()) { diskImage.getSnapshots().add(diskImage); MultiValueMapUtils.addToMap(parameters.getSourceStorageDomainId(), diskImage, storageDomainsActiveImagesMap); } } for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsActiveImagesMap.entrySet()) { Guid sourceDomainId = entry.getKey(); List<DiskImage> disksList = entry.getValue(); Guid storagePoolId = disksList.get(0).getStoragePoolId(); StorageDomain sourceDomain = getStorageDomainById(sourceDomainId, storagePoolId); if (!doesStorageDomainHasSpaceForRequest(sourceDomain, disksList)) { return false; } } return true; }","Maybe I'm being daft, but where are the CDA message being added?","I'd use ceil instead of round, just to be on the super-safe side.",I think this isn't necessary,does it justify keep iterating the list after finding one that exists or can we break after #246 (considering that we interact with the database here)?,"As noted above, this should be a local variable.",At this point I would just return allDomainsHaveSpaceForDisksWithSnapshots.,diskImages.stream().anyMatch(img -> img.getImageStatus() == ImageStatus.ILLEGAL),I would call them 'duplicate' rather than 'invalid'.,please put the correct status.,'memory disks' maybe?,"is this fixing anything? the constructor already sets the vm to getParameters().getVm() and getVm either gets the one set in the constructor or goes to the parameters as is done here (which seems redundant, but anyway). So i don't understand why we need to go to the params here."
"int binarySearch(K key) { int res = map.getKeyType().binarySearch(key, keys, getKeyCount(), cachedCompare); cachedCompare = (res < 0 ? -res : res) - 1; return res; }","Both old an new logic expect cachedCompare to be within the range [1, size] for cached path. The previous logic generated the cachedCompare like Java cachedCompare = res < 0 ? ~res : res + 1;  Here the Java cachedCompare = res < 0 ? ~res : res - 1;  is used. When entry isn't found ~res produces values within the range [0, size], this range is wider than the expected range, so the fallback to default may be unexpectedly used by both old and new code. When an entry is found, old res + 1 produced values within the range [1, size], it was correct. This range is expected and cachedCompare - 1 is actually used, so res + 1 - 1 = res (previous entry) was used as the starting point. When an entry is found, new res - 1 produces the values within the range [-1, size - 2], it looks like off-by-two error. So one of two paths was buggy and now both paths are buggy (suboptimal). Maybe I'm missing something, please re-check. (~something == -something - 1)","have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.",This needs to be changed to return the long value.,It's Comparator.reverseOrder(),please make it static,Get rid of the not needed parenthesis,This method should be implemented.,This method can be implemented as return a - b;,It's Comparator.naturalOrder(),"May be I am missing something, but should ExecutableFlow be available to comparator (ranker) ? This will enable us to have more signals to chose an Executor A over Executor B in context of Executable flow C ? Just to make it more extensible and avoiding interfaces changes later on.","@jomarko I do not know if in your test mapping ""M"" to an action (contextual menu) gave issues, but I think it is much safer to use another key, something not frequently used for text insertion/editing, better if a key combination"
"public FluidStack drain(ForgeDirection from, FluidStack resource, boolean doDrain) { if (resource != null) { Fluid f = resource.getFluid(); if (f != null) { Fluid fluid = tank.getFluidType(); if (fluid != null && f.getID() == fluid.getID()) return tank.drain(resource.amount, doDrain); } } return null; }",wouldn't it be easier if you do this in the tank? also you can just return null here as nobody uses this as far as i know,Why have a result if the only one you care about is allow? Cancelable exists for boolean things.,Why are these no longer part of IFluidHandler? Do you plan to replace them with the improved TankInfo stuff?,We actually need to be able to set the tank contents to null.,Perhaps compare with the previous comparator level rather than the previous amount of fluid?,Densty is set twice in this line,You don't need to change the type here.,can they be null?,hasParent,"This is unnecessary, its called via canFillFluidType() in super.fill().",No need
"public static <K, V> List<ConsumerRecord<K, V>> waitUntilMinRecordsReceived(final Properties consumerConfig, final String topic, final int expectedNumRecords, final long waitTime) throws InterruptedException { final List<ConsumerRecord<K, V>> accumData = new ArrayList<>(); final String reason = String.format(""Did not receive all %d records from topic %s within %d ms"", expectedNumRecords, topic, waitTime); try (final Consumer<K, V> consumer = createConsumer(consumerConfig)) { TestUtils.retryOnExceptionWithTimeout(waitTime, () -> { final List<ConsumerRecord<K, V>> readData = readRecords(topic, consumer, waitTime, expectedNumRecords); accumData.addAll(readData); assertThat(reason, accumData.size(), is(greaterThanOrEqualTo(expectedNumRecords))); }); } return accumData; }",nit: add static import? (similar elsewhere),"just checking... was this for your debugging, or do we really want to print to stdout during the tests?","Do you think refactoring createKafkaBasedConnectorTaskMetrics with additional boolean which decides the creation of histogram for poll duration will make more sense? Then in the future, if we decide to enable it for other tasks, we can just set the boolean to true?",nit: would it be even nicer if try/catch is placed within sendPollInfoToPositionTracker?,"The cynic in my mind reads this and wonders: Kafka position tracker has a dedicated consumer and ScheduledExecutorService. Why is it making an RPC call on the task's consumer (even if we're optimizing by invoking it right after poll()), especially that positions() isn't invoked anywhere else. I understand we cannot share a single consumer across multiple threads, but then why can't the tracker use its dedicated consumer to fetch broker offsets _and_ assigned partition offsets? Is it because it doesn't use its consumer to poll?",We don't use the trace level elsewhere. Not sure if it is supported by all logging implementations.,"The logic looks fragile when the partitionRecords is empty. For all -1 cases, we add one more dummy record to the array being checked, or just remove the last element from the derived array so that we could maintain the same verification.",nit: we could put topic2 initialization before L196,You could replace all this with commons-lang3 SerializationUtils.deserialize,"If you use commitSync() api, you should set enable.auto.commit to false before create KafkaConsumer instance.","What does """" +  mean?"
"public void setImage (Image image) { checkWidget (); if ((style & SWT.SEPARATOR) != 0) return; if (image != null && image.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT); this.image = image; updateStyleBits(false); OS.InvalidateRect (handle, null, true); }",With the proposed change: updateStyleBits(image == null),"With the proposed change: updateStyleBits(true), unconditional, because text can't be null.","Again, there is some code here that is duplicate in both cases of the if-statment.","paranoia: can we first set it to false, and *after* that call GTK.gtk_widget_queue_draw(widget);",Please version guard this check with < 3.16.0. Playing too much with css esp. when every theme from 3.16.0 is just css is dangerous.,SWT requires 3.4 already so the guard can be removed.,"Even if it's a bit longer, I think checkImage would be clearer as a variable name. It's immediately clear that checkImage.width is the width of the image, not of the check box or anything.",Is this 3.10.10 a typo? I can't find such gtk version.,if you exchange left and right it would be faster for non overlay case (us) :),Try to see if you can merge the if gtk3.0 - gtk3.10+ into a single block and check if it works on pre gtk 3.10.,"It's a good habbit to preserve alpha when possible and it is here as both Color.getAlpha() and rgba(r, g, b, a) will work here."
"public static void setupEnvironment() throws Exception { IWorkspace workspace = ResourcesPlugin.getWorkspace(); IWorkspaceDescription description = workspace.getDescription(); description.setAutoBuilding(false); workspace.setDescription(description); GitImportRepoWizard importWizard = new GitImportRepoWizard(); importWizard.openWizard(); String repoName = ""egit""; String repoUrl = ""git://egit.eclipse.org/egit.git""; if (!importWizard.containsRepo(repoName)) { addRepository(importWizard, repoUrl); } importWizard.selectAndCloneRepository(repoName); importWizard.waitForCreate(); waitForWorkspaceRefresh(); }",style nit: no braces around single line,"Breaking the initialize workspace out into a method so it can be ""reset"" wont really work well since Workspace.getWorkspace uses a static cache. I think you will need to change this line to  ws = new Workspace(getWorkspaceDirectory());  to ensure a new Workspace object is returned.","I am not sure this will work. I still think you need to add the plugin to the Run's workspace. But given the other changes above, the workspace should be a standalone workspace.","Maybe it's just confused me, but did you eventually mean to have this and the next static method named exactly the other way around? Right now static run() calls instance execute, and static execute() calls instance run. And to avoid that confusion, would it eventually be possible to name the 2 methods identically? Or does that confuse the compiler? BTW: The class looks even better than I had thought when describing the lambda idea.",Should this not do something like ErrorPopup.showMessage( ProjectEditorResources.CONSTANTS.NoRepositorySelectedPleaseSelectARepository() )?,"It's hard to understand test scenario here. Please, divide separate steps by empty rows.",as far as I can see this method is not present on RRP,use FileRepositoryBuilder.create,"The first param of this constructor represents project name. Using String ""repository"" as a value for it is confusing to say the least :) Please change to ""projectName"" or similar. The same applies to all usages in this test class.","I think, should replace the importWidget.waitAndTypeImporterAsGitInfo() to the git.importJavaApp()",Wait over 40 minutes? Is it needed to wait for so long? It looks suspicious.
protected void configure() { bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName); bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()) .toInstance(new JavaScriptPlugin(fileName)); },"DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(...)",Maybe this should also be protected?,"This should be declared in another location, e.g. WebModule. We always need this set declared but not every server binds PluginModule. In particular the server that powers gerit-review doesn't bind PluginModule. :-)",could use matcher.matches here I believe,Remove all of the unnecessary final modifier from the local variables from all of the modified classes.,should rather be named currentContextClassloader,s/and/or,Plugin annotation -> Dependency annotation for all exceptions in this file.,Let's declare it as private static final String?,"This condition is always false now: originalName = ""foo.jar"" And the name of plugin can be ""foo"" or ""bar"" if plugin defines its own name, but it is never ""foo.jar"".","Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with."
public List<QuickFilter> getQuickFilters() { return this.quickFilters; },return quickFilters,"Concern: These changes to the filters-related methods are definitely breaking changes, and seem like they're actually pretty likely to break existing code. (Unless I'm missing something, which is very possible.)",whitespace suggestion if (!filtersCanBeModified) {,Something is wrong here. Let's discuss.,How about putting this filter into the optionsBuilder immediately (just like we do it for all other enum-based filters)?,ImmutableList,this is not backwards compatible,"Not sure how it was implemented previously, but we check for null in public and package-private static API. Please review the methods of the class on this matter.",this (also below),"Should add non null check, if equals() is implemented without null precautions",@pinaf could you explain purpose of these asserts?
"public void startContainerWithVolumes() throws DockerException { Volume volume1 = new Volume(""/opt/webapp1""); Volume volume2 = new Volume(""/opt/webapp2""); CreateContainerResponse container = dockerClient.createContainerCmd(""busybox"").withVolumes(volume1, volume2) .withCmd(""true"").withBinds(new Bind(""/src/webapp1"", volume1, ro), new Bind(""/src/webapp2"", volume2)) .exec(); LOG.info(""Created container {}"", container.toString()); assertThat(container.getId(), not(isEmptyString())); InspectContainerResponse inspectContainerResponse = dockerClient.inspectContainerCmd(container.getId()).exec(); assertThat(inspectContainerResponse.getConfig().getVolumes().keySet(), contains(""/opt/webapp1"", ""/opt/webapp2"")); dockerClient.startContainerCmd(container.getId()).exec(); dockerClient.waitContainerCmd(container.getId()).exec(new WaitContainerResultCallback()).awaitStatusCode(); inspectContainerResponse = dockerClient.inspectContainerCmd(container.getId()).exec(); assertContainerHasVolumes(inspectContainerResponse, volume1, volume2); assertEquals(inspectContainerResponse.getMounts().size(), 2); assertEquals(inspectContainerResponse.getMounts().get(0).getDestination(), volume1); assertEquals(inspectContainerResponse.getMounts().get(0).getMode(), ""ro""); assertEquals(inspectContainerResponse.getMounts().get(0).getRW(), Boolean.FALSE); assertEquals(inspectContainerResponse.getMounts().get(1).getDestination(), volume2); assertEquals(inspectContainerResponse.getMounts().get(1).getMode(), ""rw""); assertEquals(inspectContainerResponse.getMounts().get(1).getRW(), Boolean.TRUE); }","you've change order of expected and actual (error string will be wrong in case of fail) to not repeat this mistake simply use assertThat(actual, matcherForIt()) - thats more friendly to any reviewer or maintaineer",Sounds like it should be RW and RO (upper case),"Please let the exception be thrown from the test method, as it could be important.","nit1: please extract the image definition nit2: could you please add a line break after try ( and also before ) {? I know that we're a bit inconsistent, but usually it helps, especially with long fluent-style chains","Bad example was before... assertThat(response.getLogPath(), is(""/mnt/sda1/var/lib/docker/containers/469e5edd8d5b33e3c905a7ffc97360ec6ee211d6782815fbcd144568045819e1/469e5edd8d5b33e3c905a7ffc97360ec6ee211d6782815fbcd144568045819e1-json.log"")",Maybe try using message.status() instead? I'm running docker 1.7.1 and that's where it was for me.,please duplicate to netty test class,"Seems like IDE added this full class name after move. If you revert this change (add static import back), diff will be easily to review",nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :),"please see other tests on how to format it, something like: java try ( GenericContainer container = new GenericContainer() .withCommand(""top"") .withTmpFs(singletonMap(""/testtmpfs"", ""rw"")) ) {","Not really testing anything interesting here; maybe better to just delete this, especially if the user argument is deleted. What I would like to see in a test (if it is possible) is verification in WithContainerStepTest that you are fixing some bug: a script which fails before the switch of the user ID from run to exec but which passes afterwards."
public ListenableFuture<?> isBlocked() { if (!finishing || !joinPagesNotNeeded.isPresent()) { return NOT_BLOCKED; } return joinPagesNotNeeded.get(); },isn't finishing tied to joinPagesNotNeeded not being empty? Maybe just get rid of it and then then becomes return joinPagesNotNeeded.orElse(NOT_BLOCKED),Something like return joinPagesNotNeeded.map(Future::isDone).orElse(true),nit: reverse (as it was originally): state == State.FINISHED && .. -- do the cheaper thing first,"This function is only used in unit test, we should not expose.","Unnecessary, can remove.","I wonder if you should lock the handlers also with toCompletableFuture(), but given it's unsafe to assume toCompletableFuture().isDone() => this.isDone(), it's probably not necessary.",Are these methods part of the upgrade?,that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.,Use P.lazy.,"Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.",nit: also verify( this.pagesSpatialIndex == null)
"public ConsumerTestRuntimeEnvironment(Supplier<CuratorFramework> curatorSupplier) { this.paths = new ZookeeperPaths(""/hermes""); this.curatorSupplier = curatorSupplier; this.curator = curatorSupplier.get(); this.groupRepository = new ZookeeperGroupRepository(curator, objectMapper, paths); this.topicRepository = new ZookeeperTopicRepository(curator, objectMapper, paths, groupRepository); this.subscriptionRepository = new ZookeeperSubscriptionRepository(curator, objectMapper, paths, topicRepository); this.configFactory = new MutableConfigFactory().overrideProperty(CONSUMER_WORKLOAD_REBALANCE_INTERVAL, 1); this.consumersRegistry = new ConsumerNodesRegistry(curator, executorService, paths.consumersRegistryPath(), ""id""); this.metrics = mock(HermesMetrics.class); when(metrics.timer(anyString())).thenReturn(new Timer()); try { curator.create().creatingParentsIfNeeded().forPath(""/hermes/groups""); consumersRegistry.start(); } catch (Exception e) { e.printStackTrace(); } }","There's a lot going on in this class, it creates subscriptions, spawns SelectiveSupervisorControllers, makes assertions. Maybe we could separate this work to different classes.","Here and below, since there are no bodies, you can just use {} instead of {\n\n}",Could be simplified to use getExecutionEnvironment(Configuration),duplicated code. Maybe this assertion should be unified. Verify if this can be done in all the tests.,"We should use better variable names (path, entries). It would make the assertions and verifications clearer.",this entire class should be immutable. Make all the fields final. You'll need to refactor load() to return RemoteConfig and then set the fields.,why do we need to avoid singleton list? Also could we format the assertion call more consistently like in L285-286,"We should use better variable names (filter, path, entries). It would make the assertions and verifications clearer.",Mock? You can use pretty simple Lambda:  channel.subscribe(m -> {});  :smile:,bindSingletonFactory() can be used,you have this statically imported
public void testDefaults() { ConfigAssertions.assertRecordedDefaults(ConfigAssertions.recordDefaults(JsonWebTokenConfig.class) .setKey(null) .setRequiredAudience(null) .setRequiredIssuer(null)); },Static import the assertion methods,"You should not need to call Arrays.asList at all. If the varargs were used instead of a String, it would be an instance of Array which can already be considered a ""list"". Similarly, if you could go ahead and fix the withAudience method which shouldn't be calling Arrays.asList as well. (same reason). Feel free to do it here or in a separate PR if desired.",This was probably throwing an unhandled exception. Please rollback this test's changes. Create new tests if required but don't change the existing ones :),Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));,let's apply the format template to the new code,Nit: static import recordDefaults,This seems like a bit of a workaround - why not use mockito's verify?,This property should be restored at the end of the test.,I thought we should do:  assertRecordedDefaults( recordDefaults(CompilerConfig.class) .setInterpreterEnabled(false) .setExpressionCacheEnabled(true));,I think we can remove this line.,@xiaolong-sn nit: Collections.emptyList() is more expressive
"public Message[] getErrors() { Message[] messages = new Message[fErrors.size()]; int i = 0; for (String string : fErrors) { messages[i++] = new Message(string, -1); } return messages; }",rename to message,Should we return immutable list?,"would this not be dangerous? either we have code relying on this, and need to support it, or we should remove it from the interface/api so people dont code against it.",Maybe catch ClassCastException and rethrow as ArrayStoreException?,"errors can keep final, and instead of attribute emptyList here, you can call List.clear() method.",s/leased/borrowed,It seems to me you would still be able to implement this method. You are just going to have 'eventType' as the first element in the partition list.,"I think only the for loop should be good enough - there's no allocation, and it will do the same 0 < size, 1 < size comparisons.","Record dropped message count? Message count may be inaccurate if the message is corrupted, so recording count of dropped message sets may be helpful too.",Good,We need to check offset + length <= arr.length?
"public void publishJobModelVersion(String oldVersion, String newVersion) { Stat stat = new Stat(); String currentVersion = zkClient.<String>readData(keyBuilder.getJobModelVersionPath(), stat); LOG.info(""publishing new version: "" + newVersion + ""; oldVersion = "" + oldVersion + ""("" + stat .getVersion() + "")""); if (currentVersion != null && !currentVersion.equals(oldVersion)) { throw new SamzaException( ""Someone changed JobModelVersion while the leader was generating one: expected"" + oldVersion + "", got "" + currentVersion); } int dataVersion = stat.getVersion(); try { stat = zkClient.writeDataReturnStat(keyBuilder.getJobModelVersionPath(), newVersion, dataVersion); } catch (Exception e) { String msg = ""publish job model version failed for new version = "" + newVersion + ""; old version = "" + oldVersion; LOG.error(msg, e); throw new SamzaException(e); } LOG.info(""published new version: "" + newVersion + ""; expected data version = "" + (dataVersion + 1) + ""(actual data version after update = "" + stat.getVersion() + "")""); }",Please leave msg.,Shouldn't we re-throw the exception here?,"I made this change because the GlobalStorageStatus.getServerVersion() method is annotated with @CheckForNull and I got an issue, that's why I added the check. So we can just ignore the issue ?","Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!",We could have something like LeaderInformation.isEmpty(),why %5?,s/jm path/barrier path,nit: can we log the stacktrace here? IMHO it's better for debugging.,I think this is a behavior change,if isDebugEnabled is missing here,Are you trying to print the set of ids or just the size of the set? (The header doesn't match.)
"private String generateExcludes(final Iterable<String> excludes) { final StringBuilder xml = new StringBuilder(75); xml.append(""<FindBugsFilter><Match><Or>""); for (final String exclude : excludes) { xml.append(""<Class name=\"""").append(exclude).append(""\""/>""); } xml.append(""</Or></Match></FindBugsFilter>""); return xml.toString(); }","yeah, this is definitely a bad idea, since exclude may be equal to, say, ""hey"" and the entire code will crash. Let's find a way to use Xembly","This else seems like a problem (and maybe it was the reason for not doing this earlier). I think this makes it impossible to do:  java class Foo { @InjectView(1) View foo; } class Bar extends Foo { @InjectView(2) View bar; }  We can work around this by using composition rather than inheritance. The generated code keeps an instance of the superclass injector:  java class Bar$$ViewInjector implements Injector<Bar> { private final Injector<Foo> parent = new Injector<Foo>(); @Override public void inject(Foo foo, ...) { parent.inject(foo, ...); // ... } // same for reset... }",What about StringJoiner and for (boolean value : values) joiner.add(String.valueOf(value)); (Shorthand on phone),use Class object to get class name,@ilyakharlamov Please indent it so we don't need the LineLengthCheck here,toString() formatting.,This needs to allocate five times (for each replace) and does the full search five times. Is there any better way to do this in Java?,"maybe, it would be better to inline that actual following way:  java Matchers.containsString( new StringBuilder() .append(""<a>"") .append(System.lineSeparator()) .append(""<b/>"") .append(System.lineSeparator()) .append(""</a>"") .toString() );  what do you think?",@brettchabot doesn't this return a Filter object which is ignored? i.e. missing filter = ... <LINK_0>,"@ilyakharlamov Here too, let's try to use cactoos classes instead of making this iterator() thing","Instead of putting this large block inside the if statement, it would be cleaner to reverse it, and have: if (numConstants <= 0) { return """": }"
"public Registration deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonNode node = p.readValueAsTree(); Registration.Builder builder = Registration.builder(); if (node.hasNonNull(""name"")) { builder.name(node.get(""name"").asText()); } if (node.hasNonNull(""url"")) { String url = node.get(""url"").asText(); builder.healthUrl(url.replaceFirst(""/+$"", """") + ""/health"").managementUrl(url); } else { if (node.hasNonNull(""healthUrl"")) { builder.healthUrl(node.get(""healthUrl"").asText()); } if (node.hasNonNull(""managementUrl"")) { builder.managementUrl(node.get(""managementUrl"").asText()); } if (node.hasNonNull(""serviceUrl"")) { builder.serviceUrl(node.get(""serviceUrl"").asText()); } } if (node.hasNonNull(""metadata"")) { Iterator<Map.Entry<String, JsonNode>> it = node.get(""metadata"").fields(); while (it.hasNext()) { Map.Entry<String, JsonNode> entry = it.next(); builder.metadata(entry.getKey(), entry.getValue().asText()); } } return builder.build(); }",iirc the source is added later in the controller and not part of the request.,"Remove, and use StandardCharsets.UTF_8",Delete blank lines,psf,Add minimal feedback when failure,why do you do the substring if you are using contains?,"don't assume ""http"" use url.getProtocol()","For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)","You can create a constant to include the ""http://"" string and named as **HTTP_SCHEME** for instance.","May I suggest this?  int i = url.indexOf(""/#/""); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.",Will * <LINK_0> * <LINK_1> work as well?
"private Map<Long, Pair<String, Long>> recoverPendingLargeMessages() throws Exception { Map<Long, Pair<String, Long>> largeMessages = new HashMap<>(); List<String> filenames = largeMessagesFactory.listFiles(""msg""); List<Long> idList = new ArrayList<>(); for (String filename : filenames) { Long id = getLargeMessageIdFromFilename(filename); if (!largeMessagesToDelete.containsKey(id)) { idList.add(id); SequentialFile seqFile = largeMessagesFactory.createSequentialFile(filename); long size = seqFile.size(); largeMessages.put(id, new Pair<>(filename, size)); } } return largeMessages; }",you can just use a primitive long here,"Calling values() creates a new List, if you're iterating the objects, simply call using forEach method on the collection.",If it's now using CHM there is no need to sync on it,"With the Folder abstraction UIDs are opaque strings. UIDs being numbers is an implementation detail of ImapFolder. So until we can replace this interface with something more flexible let's keep this interface clean. Also, sometimes (e.g. when emptying the Trash folder) an unconstrained EXPUNGE makes sense. So I'd keep the original method and add a new one that better describes what it is about. My suggestion: java public void expungeUids(List<String> uids) throws MessagingException",Do we need to close underlying file of new large message after copy?,Revert this and keep explicit,wonder is there's a way in mongo to do bulk deletes?,why not simply add tcall the error.. we don't need a special logger here.,"This block appears in 3 methods, could be pulled out for less duplication and to make these methods simpler.",if(deleteMsg == messageInfo.isDeleted())?,"Let's use an AtomicLong and accumulateAndGet: not _wrong_ because of how it's used, but there could be unwanted race conditions"
public void setComponent(T component) { this.component = component; },"I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.","remove() returns the removed value, so no need for both get() and remove()","This is using the regular Java reflection API, you need to use the [Libgdx reflection API](<LINK_1>, otherwise you will break the GWT backend. I already did [this](<LINK_0> in the serialization branch, you can just copy it.",![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>,what about the rest of the fields?,![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>,More final listener,![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>,use && rather than nested ifs (I know this isn't code that you added but we should clean it up as we're modifying it anyway),Space before {,Space before {
"private void activeDetailModelChanging(HasEntity<D> newValue, boolean stopRefresh) { for (HasEntity<D> oldValue : activeDetailModels) { if (oldValue != null && stopRefresh) { oldValue.setEntity(null); if (oldValue instanceof SearchableListModel) { ((SearchableListModel) oldValue).stopRefresh(); } } } if (newValue != null) { newValue.setEntity(provideDetailModelEntity(getSelectedItem())); } }","Wouldn't a top-level if (stopRefresh) guard condition be better, instead of checking it within the loop?",this is quite risky - it can lead to NPEs all over the frontend. Are you sure you need it?,"Update: I added the LinkPropertiesUtil.CompareOrUpdateResult generic class to do this. The idea is that you'd have two lists of RouteInfo objects, and then would do: CompareOrUpdateResult<IpPrefix, RouteInfo> result = new CompareOrUpdateResult<>( oldRoutes, newRoutes, (route) -> route.getDestination()); for (RouteInfo route : result.added) { // Add route. } for (RouteInfo route: result.removed) { // Remove route. } for (RouteInfo route: result.updated) { // Replace route. }","Do these have to be deproxy'ed here? Callers of rebindPartialActive(CompoundTransformer, Iterator<BrooklynObject>) probably wouldn't realise that they can't just pass proxy objects. Therefore I'd be inclined to have the deproxy'ing happen somehwere in that other rebindPartialActive method.","See my suggestion above, I think this method isn't really necessary.",I think all three skins require both mappedElements.size() > oldValueIndex && oldValueIndex != -1. I think container.getSelectionModel().clearSelection(oldValueIndex) will throw a NullPointerException if the index is larger than the number of shown elements.,"I'm not sure about that. According to the specification, the keySet isn't a copy, it's backed by the original map, so changes to the map during iteration result in undefined behavior: <LINK_0>","We have the class FieldNames with field names. You can't link it from exporter because is in editor, but maybe you can move it to schema (as GameStructure) and add components and children fields.","I think we should continue to use the previous way to detect all detached objects. But if we want to decrease the number of Remove notifcation (after checkings the effects on manuel refresh, red cross decorators, ...) we could here call either eDelete or eRemoveCrossReferences regarding the value of the eContainer() at the execution time.","I have run ContainsOnlyPerfTest with and without the changes, it is indeed much faster, I still fail to see where is the O(n2), enlighten me please ;-)",The isValid boolean isn't needed: if you move these two adds into the body of the e.isValidField(i) conditional and then break afterwards it should be the same behavior without an intermediate boolean.
"public void findAllPaginationTest() throws Exception { context.turnOffAuthorisationSystem(); EPerson ePerson = EPersonBuilder.createEPerson(context) .withNameInMetadata(""John"", ""Doe"") .withEmail(""Johndoe@gmail.com"") .build(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get(""/api/eperson/epersons"") .param(""size"", ""1"")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath(""$._embedded.epersons"", Matchers.contains(Matchers.anyOf( EPersonMatcher.matchEPersonOnEmail(eperson.getEmail()), EPersonMatcher.matchEPersonOnEmail(admin.getEmail()), EPersonMatcher.matchEPersonOnEmail(ePerson.getEmail()) )))) .andExpect(jsonPath(""$._embedded.epersons"", Matchers.hasSize(1))) .andExpect(jsonPath(""$.page.size"", is(1))) .andExpect(jsonPath(""$.page.totalElements"", is(3))) ; getClient(token).perform(get(""/api/eperson/epersons"") .param(""size"", ""1"") .param(""page"", ""1"")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath(""$._embedded.epersons"", Matchers.contains(Matchers.anyOf( EPersonMatcher.matchEPersonOnEmail(eperson.getEmail()), EPersonMatcher.matchEPersonOnEmail(admin.getEmail()), EPersonMatcher.matchEPersonOnEmail(ePerson.getEmail()) )))) .andExpect(jsonPath(""$._embedded.epersons"", Matchers.hasSize(1))) .andExpect(jsonPath(""$.page.size"", is(1))) .andExpect(jsonPath(""$.page.totalElements"", is(3))) ; getClient().perform(get(""/api/eperson/epersons"")) .andExpect(status().isForbidden()) ; }",The variables eperson and ePerson are confusing in the same block. Could more specific names be used?,"If you apply the above suggested changes, I think you can also restore the original behavior here.",is this dead code?,it will be better to check that no changes have been applied,"same as above, we need to support real boolean and be friendly with textual boolean",it should be isUnauthorized 403 as the client is not yet authenticated,This method is missing a context.restoreAuthSystemState(); after creating the EPerson,"better to use the official way here true instead than ""true""",please use an additional get to check that changes are persisted,It looks like there's accidentally two context.restoreAuthSystemState() calls in this method now. This second one can be removed.,Why doesn't this request return the correct content type anymore?
"public void testAccessControl_studentNotExistInCourse_shouldFail() { InstructorAttributes instructor1OfCourse1 = typicalBundle.instructors.get(""instructor1OfCourse1""); StudentAttributes student1InCourse2 = typicalBundle.students.get(""student1InCourse2""); CourseAttributes typicalCourse1 = typicalBundle.courses.get(""typicalCourse1""); loginAsInstructor(instructor1OfCourse1.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, typicalCourse1.getId(), Const.ParamsNames.STUDENT_EMAIL, student1InCourse2.getEmail(), }; verifyCannotAccess(submissionParams); }",You should test for both instructor and student?,Why are you accessing courseId from instructor?,This is the same as // no parameters?,"You should verify that there are 6 feedback sessions associated with the course. Ideally, maybe also verify that the feedback sessions actually match?",testDifferentPrivileges should be moved here.,You should have one for invalid course id?,What's the point of testing student?,Suggest to change courseAttributes to be expectedCourse,So it should be change to verifyAccessibleForAdmin?,and the emails are sent? (e.g. verify the email-sending task is added),courseName does not need to be loaded from CoursesLogic.
"public @Nullable String resolveDeviceType(int quark, long timestamp) { return TmfStrings.cpu(); }",Should this be using TmfCpuAspect?,"In the events table the columns ""Tid"" will display the HostThread.toSting() which includes a long Host ID. This is not what I expected for that column. Shouldn't we see the TID value instead? It's confusing for me (at least for me).","With <LINK_0> could we remove this method, avoid the loop and use trace.getAnalysisModule(id) instead?","bikeshedding, but return null and then put the tid under.",this would be clearer when the map is based on the enum,"I see that similar methods in this class use IllegalStateException, shouldn't we do the same here?",I don't think you need the condition here.,Does this not ever fail?,inline?,I get a TimeRangeException here,"If you don't specify any constructor, you automatically get one like this by default (public, no parameter). Here we want a *private* constructor, to make sure nobody instantiates this class."
"public void run() { logger.info(""System Resource: {}"", SystemResourceMonitor.create(SystemResourceMonitor.allResources).getFormattedSystemResourceUsage()); }",The create method call should be separate from the logger call.,"Even if this was copied, we should fix the this.m_ references here :)",Should we return an explicit IStatus.ERROR instead? * It would avoid potential NPEs on the client side. * It would make it clear that this method should not have been called on an ResourceStrategy which explicity says it does not handle this method.,This method doesn't advance the monitor.,getOrCreateResourceMonitor(),"This should be private, as we don't want the resource attribute to be set externally.",Not using curly on the else branch? :),Why?,should be  java throw Throwables.propagate(e);  so that both IDE and the compiler know the execution flow stops here,We don't really use final on variables anywhere as the Java compiler will automatically infer it now.,Same here with Throwable.
public RangeResourceEntry remove(ResourceEntry<Long> resourceEntry) { RangeResourceEntry rangeResourceEntry = (RangeResourceEntry) resourceEntry; if (this.begin > rangeResourceEntry.getBegin()) { this.begin = rangeResourceEntry.getBegin(); } if (this.end < rangeResourceEntry.getEnd()) { this.end = rangeResourceEntry.getEnd(); } return this; },"This seems like the opposite of remove to me, since the range goes from beginning to end, if we remove from resourceEntry.begin to resourceEntry.end, then if the original begin is larger than the resourceEntry.begin and we set begin to the resourceEntry.begin, we'd be adding those ports between resourceEntry.begin and begin to the range. Similarly for end.","For this method, if we have a range say, [u,v] and we want to add [w,x], the only cases we can actually do this are when the result is [u,x] (when v+1 = w) or [w,v] (when x+1 = u). Unless I'm misunderstanding those are the only options because we can't have two separate ranges, just one range. If this is the case, we need to have the following logic instead of what is there:  if (end+1 != rangeResource.getBegin() && begin != rangeResource.end()+1) { //incompatible addition, throw an exception? } if (end < rangeResourceEntry.getBegin()) { end = rangeResourceEntry.getEnd(); } else if (begin > rangeResourceEntry.getEnd()) { begin = rangeResourceEntry.getBegin(); }  If that's not the case, can you explain how this is supposed to work? (Either way, I think the logic below is flawed because both have to do with using only the beginning of the rangeResourceEntry).",Should'n it be range == null,This should set the flags argument to FL_COMMITTED | FL_CONFIRMED.,"what if rowCountEstimateIncrease < pageSize? in that case assumedSize would be still less than requestedRange.getEnd() + pageSize, is it fine?",We could avoid making setParent() public if we use rEntry instead here?,is this endless recursion?,workspace root or deleted resource will return null,"Hmm, for my eyes is nicer Pair.newPair(rowIndex, columnIndex), but if you prefer this variant, just let me know, does not prevent from merging.",Did we determine that it was safe to remove entries after prepare? Does the TM log the resource at this point?,"Should these have some kind of validation, e.g., non-negative, from less than to?"
"public void secondary_no_location() throws Exception { thrown.expectMessage(""Precise secondary location should contain at least one '^'""); check( ""foo(); ""x = bar();\n"" + "" TestIssue.create(""msg1"", 1).secondary(""Secondary message"", 3, 5, 8)); }",@vilchik-elena The message should give the line number.,@vilchik-elena The message should give the line number.,"supernit: HashMap is [dead](<LINK_0> to me, and it should be dead to you too. LinkedHashMap is the only way to live.",@vilchik-elena Eclipse tells me that there is an unnecessary cast to PreciseIssue here and on lines 89 and 92.,It could do getJsonTextArea().setText(messageLocation.getValue()); to use the original payload by default.,Will these tests pass if the users locale is non-English? I think all of our non-instrumented test runs are still in English.,NON_NLS is not required in tests.,can you make those no-arg constructor private?,"If you pass a Schema.Builder to the failureOf() then it will call both buildWithLocation() and also set an expected pointer. You also don't have to explicitly pass the expectedViolatedSchema if it is the same as the root schema (it matters only when we check sub-schema failures). So this test can be written as  ConditionalSchema.Builder subject = ConditionalSchema.builder().ifSchema(MAX_LENGTH_STRING_SCHEMA).thenSchema(PATTERN_STRING_SCHEMA); TestSupport.failureOf(subject) .expectedKeyword(""then"") .input(""bar"") .expect();  But if you prefer being more explicit then you can leave it as-is.","I think this message is a bit much. Can we make them match? > ""Expected 1, got 0"" > ""Expected 0, got 1""","What's -2? It should have a psf variable to define it. Is -1 also used somewhere? If so, that should be fixed too. If I did it, I apologise..."
public ASN1DataFormat() { super(); this.usingIterator = false; },Those 3 implicit super() calls could be removed.,"Please use Method m = helper.getClass().getMethod(""setBadASM"", Boolean.TYPE);",forEach?,"not needed. Is there a way to decouple even more so that we don't need to pass the o.e.swtchart class? Adapter, resolver, consumer, not sure exactly how.",Why did you not use a Objects.nonNull(record) here like on other places and changes?,This means now that the conversion service can never be null. That means that all the checks for hasConversionService are no longer necessary. Would you mind creating a ticket to improve that (remove the hasConversionService checks) so that we remember for the future?,"I suppose I would want to understand why this check was here in the first place, given no where else do we consider the group order, and this only is an issue when writing. I suppose it is because we would pass the alignment to the alignmentSorter if we request a sort order (SO) but do nothing in the case of group order (GO). In your case, you are adding support SO=unsorted and GO=query, so shouldn't the alignment be passed to an alignmentSorter based on your new comparator if SO=unsorted and GO=query?",remove excess nls,"1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of ""alias is null"" -> alias is null. 5. Do the same for the other methods.",forEach?,generics is missing
public Long getUuid() { return new Long(artId); },use Long.valueOf() instead of new Long() - always for performance reasons,use Long.valueOf() instead of new Long() - always for performance reasons,use Long.valueOf() instead of new Long() - always for performance reasons,use Long.valueOf() instead of new Long() - always for performance reasons,use Long.valueOf() instead of new Long() - always for performance reasons,456L,use 'L',This can be simplified to Optional.ofNullable(id).,put the uuid of any identifier source associated with a log entry,"Same as above, get the caller user/account from current context.","Add ""this"" qualifier"
"public void testCreateProcessWithLogonW() { String winDir = Kernel32Util.getEnvironmentVariable(""WINDIR""); if (winDir == null || !(new File(winDir).exists())) { throw new IllegalStateException(""WINDIR environment variable did not properly resolve to a directory.""); } STARTUPINFO si = new STARTUPINFO(); si.lpDesktop = null; PROCESS_INFORMATION results = new PROCESS_INFORMATION(); boolean result = Advapi32.INSTANCE.CreateProcessWithLogonW(""A"" + System.currentTimeMillis(), ""localhost"", ""12345"", Advapi32.LOGON_WITH_PROFILE, new File(winDir, ""notepad.exe"").getAbsolutePath(), """", 0, null, """", si, results); assertFalse(result); assertEquals(Native.getLastError(), W32Errors.ERROR_LOGON_FAILURE); }","assertNotNull(""No WINDIR value returned"", winDir); assertTrue(""Specified WINDIR does not exist: "" + winDir, new File(winDir).exists());","This could be simplified to  hResult = shellFolder.ParseDisplayName(null, null, directory, pchEaten, ppidl,",Functions.isWindows perhaps?,Maybe use the constants from <LINK_0>,@prahladyeri false should be on the next line,"This code should be in a _finally_ clause:  java HANDLE h = ...obtain handle... ...ensure OK handle... try { char[] path = new char[WinDef.MAX_PATH]; IntByReference lpdwSize = new IntByReference(path.length); boolean b = Kernel32.INSTANCE.QueryFullProcessImageName(h, 0, path, lpdwSize); assert... assert... } finally { . ..close handle... }",Probably should factor this out.,"You can use ConditionalIgnoreRule.IgnoreWindows on the class, I don't check if you can depend on nuxeo-runtime-test. Otherwise, you can use SystemUtils.IS_OS_WINDOWS from commons-lang3.","Should be a space after ,.",this error message is kind of ambitious. What should I do? :-),Looks like a debug line or something? suggestion
public void compileSuccessForBundleSparseArray() { CompileResult result = compileFiles(BundleSparseArrayCompileSuccessActivity.class); assertCompilationSuccessful(result); },"Sorry, i think i was not clear. Please add assertGeneratedClassContains() here to actually check the correct method call was generated.",Maybe you could mention what those parameters should represent - path to the content & value of the content as string. Just a nitpick to make the message more helpful.,Minor: consider replacing equalTo with is from Hamcrest here and below.,"It would have been better to use DisabledCondition.class.getName() to avoid relying on a String value but DisabledCondition is not public, is making it public something that can be considered ? This is not a blocker for this PR ;-)",Shouldn't the two lines above resolve to true?,It would be great to have tests for 1. Multiple @BeforeParam methods 1. Multiple @AfterParam methods 1. @AfterParam methods with parameters 1. @BeforeParam methods without parameters 1. Parameterized tests with more than one parameter,You can move this line to setUp from both test methods.,nit: remove final (here and elsewhere in this file),"Since you're checking for null, can you mark this field @nullable?",I have a different opinion on this. I would like to see mockito fail here. It indicates that the dev made something unintended and it is easy to fix.,"This expectation seems not right. I think it should rather be raised at the declaration of message(), i.e. on line 56."
"public ExecutionError filter(ExecutionErrorContext errorContext) { Builder errorBuilder = ExecutionError.builder().type(""DB"").initActivityId(getInitActivityId(errorContext)); String stacktrace = getStackTrace(errorContext.getCause()); Task task = errorContext.getLastExecutedTask(); NodeInstance nodeInstance = errorContext.getLastExecutedNode(); logger.debug(""Last executed node instance {}, last executed task {}"", nodeInstance, task); if (nodeInstance != null) { logger.debug(""Last executed node instance {} will be used to populate error details"", nodeInstance); errorBuilder .deploymentId(((ProcessInstanceImpl)nodeInstance.getProcessInstance()).getDeploymentId()) .processInstanceId(nodeInstance.getProcessInstance().getId()) .processId(nodeInstance.getProcessInstance().getProcessId()) .activityId(nodeInstance.getId()) .activityName(nodeName(nodeInstance)); } else if (task != null) { logger.debug(""Last executed task {} will be used to populate error details"", task); errorBuilder .deploymentId(task.getTaskData().getDeploymentId()) .processInstanceId(task.getTaskData().getProcessInstanceId()) .processId(task.getTaskData().getProcessId()) .activityId(task.getId()) .activityName(task.getName()); } return errorBuilder .message(errorContext.getCause().getMessage()) .error(stacktrace) .errorDate(new Date()) .build(); }","Would be good to have constants for the builder types, right now they are hard-coded strings like ""DB"", ""Task"". WDYT?","suggestion errorsToAck = em.createQuery(findTaskErrorsQuery, ExecutionErrorInfo.class)","Could we replace the 2, 3 with ProcessInstance.STATE_COMPLETED, ProcessInstance.STATE_ABORTED?","omit using return in void methods, it is less readable and it is hard to debugging",1 ? Is it always 1 ?,"An int type can or should never be null, maybe you want to use an Integer type which can be null. On other places you are comparing this with value 0, so maybe only a wrong written condition?","I think CancelNodeInstanceAction is used in multiple cases, boundary escalation and boundary error events, not sure I grasp the meaning of TIMED cancel type in this context?","Probably missing parentheses? What happens if NodeInstance is not a dynamic one and its nodeName is the one I am looking for? I guess there will be a ClassCastException. Shouldn't there be (ni instanceof DynamicNodeInstance) && (stage.equals(ni.getNode().getMetaData().get(""UniqueId"")) || stage.equals(ni.getNodeName()))",Wouldn't it be better to read ORIGINAL_INSTANCE_TIME here as Optional as well and throw explicitly in case of absent?,"As we discussed, this could have problems in a multi-threaded environment. It would make more sense to have a service-like thing that you tell - service.startUsing(IdSet) - service.stopUsing(IdSet)",empty conditional block? Consider inverting the condition
