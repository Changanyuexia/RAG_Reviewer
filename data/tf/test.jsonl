{"function": "private ByteArrayInputStream uploadPackV2(String... inputLines) throws Exception { ByteArrayOutputStream send = new ByteArrayOutputStream(); PacketLineOut pckOut = new PacketLineOut(send); for (String line : inputLines) { if (line == PacketLineIn.END) { pckOut.end(); } else if (line == PacketLineIn.DELIM) { pckOut.writeDelim(); } else { pckOut.writeString(line); } } UploadPack up = new UploadPack(server); up.setUseProtocolV2(true); ByteArrayOutputStream recv = new ByteArrayOutputStream(); up.upload(new ByteArrayInputStream(send.toByteArray()), recv, null); ByteArrayInputStream recvStream = new ByteArrayInputStream(recv.toByteArray()); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(\"version 2\")); assertThat(pckIn.readString(), is(\"ls-refs\")); assertThat(pckIn.readString(), is(\"fetch=shallow\")); assertTrue(pckIn.readString() == PacketLineIn.END); return recvStream; }", "text": "Let's add a constant for \"version 2\"", "function_tokens": ["private", "\u0120Byte", "Array", "Input", "Stream", "\u0120upload", "Pack", "V", "2", "(", "String", "...", "\u0120input", "L", "ines", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Byte", "Array", "Output", "Stream", "\u0120send", "\u0120=", "\u0120new", "\u0120Byte", "Array", "Output", "Stream", "();", "\u0120Pack", "et", "Line", "Out", "\u0120p", "ck", "Out", "\u0120=", "\u0120new", "\u0120Pack", "et", "Line", "Out", "(", "send", ");", "\u0120for", "\u0120(", "String", "\u0120line", "\u0120:", "\u0120input", "L", "ines", ")", "\u0120{", "\u0120if", "\u0120(", "line", "\u0120==", "\u0120Pack", "et", "Line", "In", ".", "END", ")", "\u0120{", "\u0120p", "ck", "Out", ".", "end", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "line", "\u0120==", "\u0120Pack", "et", "Line", "In", ".", "D", "EL", "IM", ")", "\u0120{", "\u0120p", "ck", "Out", ".", "write", "Del", "im", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120p", "ck", "Out", ".", "write", "String", "(", "line", ");", "\u0120}", "\u0120}", "\u0120Upload", "Pack", "\u0120up", "\u0120=", "\u0120new", "\u0120Upload", "Pack", "(", "server", ");", "\u0120up", ".", "set", "Use", "Prot", "ocol", "V", "2", "(", "true", ");", "\u0120Byte", "Array", "Output", "Stream", "\u0120rec", "v", "\u0120=", "\u0120new", "\u0120Byte", "Array", "Output", "Stream", "();", "\u0120up", ".", "upload", "(", "new", "\u0120Byte", "Array", "Input", "Stream", "(", "send", ".", "to", "Byte", "Array", "()", "),", "\u0120rec", "v", ",", "\u0120null", ");", "\u0120Byte", "Array", "Input", "Stream", "\u0120rec", "v", "Stream", "\u0120=", "\u0120new", "\u0120Byte", "Array", "Input", "Stream", "(", "rec", "v", ".", "to", "Byte", "Array", "());", "\u0120Pack", "et", "Line", "In", "\u0120p", "ck", "In", "\u0120=", "\u0120new", "\u0120Pack", "et", "Line", "In", "(", "rec", "v", "Stream", ");", "\u0120assert", "That", "(", "p", "ck", "In", ".", "read", "String", "(),", "\u0120is", "(\"", "version", "\u01202", "\")", ");", "\u0120assert", "That", "(", "p", "ck", "In", ".", "read", "String", "(),", "\u0120is", "(\"", "ls", "-", "ref", "s", "\")", ");", "\u0120assert", "That", "(", "p", "ck", "In", ".", "read", "String", "(),", "\u0120is", "(\"", "f", "etch", "=", "sh", "allow", "\")", ");", "\u0120assert", "True", "(", "p", "ck", "In", ".", "read", "String", "()", "\u0120==", "\u0120Pack", "et", "Line", "In", ".", "END", ");", "\u0120return", "\u0120rec", "v", "Stream", ";", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120add", "\u0120a", "\u0120constant", "\u0120for", "\u0120\"", "version", "\u01202", "\""]}
{"function": "private void repaint() { if (graph != null) { System.out.println(\"repainting graph...\"); Tile model = new Tile(graph); TileView view = new TileView(); TileController tc = new TileController(view, model); Group root = new Group(); wrapper.hvalueProperty().addListener( (ChangeListener<Number>) (ov, oldVal, newVal) -> { repaintPosition(tc, root, newVal.doubleValue()); }); Rectangle clip = new Rectangle(getMaxUnifiedEnd(graph) * VertexView.HORIZONTALSCALE, 0); root.getChildren().add(clip); repaintPosition(tc, root, wrapper.hvalueProperty().doubleValue()); } }", "text": "Iffy formatting", "function_tokens": ["private", "\u0120void", "\u0120rep", "aint", "()", "\u0120{", "\u0120if", "\u0120(", "graph", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "rep", "ain", "ting", "\u0120graph", "...\"", ");", "\u0120Tile", "\u0120model", "\u0120=", "\u0120new", "\u0120Tile", "(", "graph", ");", "\u0120Tile", "View", "\u0120view", "\u0120=", "\u0120new", "\u0120Tile", "View", "();", "\u0120Tile", "Controller", "\u0120tc", "\u0120=", "\u0120new", "\u0120Tile", "Controller", "(", "view", ",", "\u0120model", ");", "\u0120Group", "\u0120root", "\u0120=", "\u0120new", "\u0120Group", "();", "\u0120wrapper", ".", "h", "value", "Property", "().", "add", "Listener", "(", "\u0120(", "Change", "Listener", "<", "Number", ">)", "\u0120(", "ov", ",", "\u0120old", "Val", ",", "\u0120new", "Val", ")", "\u0120->", "\u0120{", "\u0120rep", "aint", "Position", "(", "tc", ",", "\u0120root", ",", "\u0120new", "Val", ".", "double", "Value", "());", "\u0120});", "\u0120Rect", "angle", "\u0120clip", "\u0120=", "\u0120new", "\u0120Rect", "angle", "(", "get", "Max", "Un", "ified", "End", "(", "graph", ")", "\u0120*", "\u0120Ver", "tex", "View", ".", "H", "OR", "IZ", "ONT", "AL", "SC", "ALE", ",", "\u01200", ");", "\u0120root", ".", "get", "Children", "().", "add", "(", "clip", ");", "\u0120rep", "aint", "Position", "(", "tc", ",", "\u0120root", ",", "\u0120wrapper", ".", "h", "value", "Property", "().", "double", "Value", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "ff", "y", "\u0120formatting"]}
{"function": "public Request iterate(final Request req, final Coordinates cords) { return null; }", "text": "don't return NULL, throw UnsupportedOperatedException instead", "function_tokens": ["public", "\u0120Request", "\u0120iter", "ate", "(", "final", "\u0120Request", "\u0120req", ",", "\u0120final", "\u0120Coord", "inates", "\u0120cords", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["don", "'t", "\u0120return", "\u0120NULL", ",", "\u0120throw", "\u0120Un", "supported", "Oper", "ated", "Exception", "\u0120instead"]}
{"function": "public MamQueryIQ parse(XmlPullParser parser, int initialDepth) throws Exception { String queryId = null; String node = null; DataForm dataForm = null; if (parser.getName().equals(MamQueryIQ.ELEMENT)) { queryId = parser.getAttributeValue(\"\", \"queryid\"); node = parser.getAttributeValue(\"\", \"node\"); boolean done = false; while (!done) { int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) { if (parser.getName().equals(DataForm.ELEMENT)) { dataForm = new DataFormProvider().parse(parser); } } else if (eventType == XmlPullParser.END_TAG) { if (parser.getName().equals(MamQueryIQ.ELEMENT)) { done = true; } } } } return new MamQueryIQ(queryId, node, dataForm); }", "text": "That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?", "function_tokens": ["public", "\u0120Mam", "Query", "IQ", "\u0120parse", "(", "X", "ml", "Pull", "Parser", "\u0120parser", ",", "\u0120int", "\u0120initial", "Depth", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120String", "\u0120query", "Id", "\u0120=", "\u0120null", ";", "\u0120String", "\u0120node", "\u0120=", "\u0120null", ";", "\u0120Data", "Form", "\u0120data", "Form", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "parser", ".", "get", "Name", "().", "equ", "als", "(", "M", "am", "Query", "IQ", ".", "E", "LE", "MENT", "))", "\u0120{", "\u0120query", "Id", "\u0120=", "\u0120parser", ".", "get", "Attribute", "Value", "(\"", "\",", "\u0120\"", "query", "id", "\");", "\u0120node", "\u0120=", "\u0120parser", ".", "get", "Attribute", "Value", "(\"", "\",", "\u0120\"", "node", "\");", "\u0120boolean", "\u0120done", "\u0120=", "\u0120false", ";", "\u0120while", "\u0120(!", "done", ")", "\u0120{", "\u0120int", "\u0120event", "Type", "\u0120=", "\u0120parser", ".", "next", "();", "\u0120if", "\u0120(", "event", "Type", "\u0120==", "\u0120X", "ml", "Pull", "Parser", ".", "ST", "ART", "_", "TAG", ")", "\u0120{", "\u0120if", "\u0120(", "parser", ".", "get", "Name", "().", "equ", "als", "(", "Data", "Form", ".", "E", "LE", "MENT", "))", "\u0120{", "\u0120data", "Form", "\u0120=", "\u0120new", "\u0120Data", "Form", "Provider", "().", "parse", "(", "parser", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "event", "Type", "\u0120==", "\u0120X", "ml", "Pull", "Parser", ".", "END", "_", "TAG", ")", "\u0120{", "\u0120if", "\u0120(", "parser", ".", "get", "Name", "().", "equ", "als", "(", "M", "am", "Query", "IQ", ".", "E", "LE", "MENT", "))", "\u0120{", "\u0120done", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120new", "\u0120Mam", "Query", "IQ", "(", "query", "Id", ",", "\u0120node", ",", "\u0120data", "Form", ");", "\u0120}"], "docstring_tokens": ["That", "\u0120is", "\u0120unusual", ",", "\u0120as", "\u0120the", "\u0120parser", "\u0120should", "\u0120be", "\u0120on", "\u0120START", "_", "TAG", "\u0120of", "\u0120the", "\u0120element", ".", "\u0120Why", "\u0120do", "\u0120you", "\u0120feel", "\u0120it", "\u0120is", "\u0120necessary", "\u0120to", "\u0120check", "\u0120for", "\u0120this", "\u0120condition", "?"]}
{"function": "public static <T> TypeToken<T> getTypeToken(TypeToken<T> token, Class<? super T> raw) { if (raw!=null) return TypeToken.of((Class<T>)raw); if (token!=null) return token; throw new IllegalStateException(\"Both indicators of type are null\"); }", "text": "Should this not prefer the token over the raw?", "function_tokens": ["public", "\u0120static", "\u0120<", "T", ">", "\u0120Type", "Token", "<", "T", ">", "\u0120get", "Type", "Token", "(", "Type", "Token", "<", "T", ">", "\u0120token", ",", "\u0120Class", "<?", "\u0120super", "\u0120T", ">", "\u0120raw", ")", "\u0120{", "\u0120if", "\u0120(", "raw", "!", "=", "null", ")", "\u0120return", "\u0120Type", "Token", ".", "of", "((", "Class", "<", "T", ">)", "raw", ");", "\u0120if", "\u0120(", "token", "!", "=", "null", ")", "\u0120return", "\u0120token", ";", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "Both", "\u0120indicators", "\u0120of", "\u0120type", "\u0120are", "\u0120null", "\");", "\u0120}"], "docstring_tokens": ["Should", "\u0120this", "\u0120not", "\u0120prefer", "\u0120the", "\u0120token", "\u0120over", "\u0120the", "\u0120raw", "?"]}
{"function": "private void initPlugins() throws Exception { Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps(); for (InitStep initStep : pluginsInitSteps) { initStep.run(); } }", "text": "It would have been shorter to inline this variable and not have it in scope. :-)", "function_tokens": ["private", "\u0120void", "\u0120init", "Plug", "ins", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Collection", "<?", "\u0120extends", "\u0120Init", "Step", ">", "\u0120plugins", "Init", "Step", "s", "\u0120=", "\u0120plugin", "Loader", ".", "get", "Init", "Step", "s", "();", "\u0120for", "\u0120(", "Init", "Step", "\u0120init", "Step", "\u0120:", "\u0120plugins", "Init", "Step", "s", ")", "\u0120{", "\u0120init", "Step", ".", "run", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["It", "\u0120would", "\u0120have", "\u0120been", "\u0120shorter", "\u0120to", "\u0120inline", "\u0120this", "\u0120variable", "\u0120and", "\u0120not", "\u0120have", "\u0120it", "\u0120in", "\u0120scope", ".", "\u0120:-)"]}
{"function": "public <T> T cast(FormField<?> formField) { if (getDefaultOrNull(formField)) { return null; } if (this == formField.getValueType()) { return (T) formField.getValue(); } else if (STRING == formField.getValueType()) { return (T) formField.getValue().toString(); } else { throw LOGGER.logExceptionAsError(new UnsupportedOperationException(String.format(\"Cannot cast from \" + \"field value of type %s to type %s\", formField.getValueType(), PHONE_NUMBER))); } }", "text": "Is toString() required? It's already of STRING type.", "function_tokens": ["public", "\u0120<", "T", ">", "\u0120T", "\u0120cast", "(", "Form", "Field", "<?", ">", "\u0120form", "Field", ")", "\u0120{", "\u0120if", "\u0120(", "get", "Default", "Or", "Null", "(", "form", "Field", "))", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120if", "\u0120(", "this", "\u0120==", "\u0120form", "Field", ".", "get", "Value", "Type", "())", "\u0120{", "\u0120return", "\u0120(", "T", ")", "\u0120form", "Field", ".", "get", "Value", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "STR", "ING", "\u0120==", "\u0120form", "Field", ".", "get", "Value", "Type", "())", "\u0120{", "\u0120return", "\u0120(", "T", ")", "\u0120form", "Field", ".", "get", "Value", "().", "to", "String", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120LOG", "GER", ".", "log", "Exception", "As", "Error", "(", "new", "\u0120Un", "supported", "Operation", "Exception", "(", "String", ".", "format", "(\"", "C", "annot", "\u0120cast", "\u0120from", "\u0120\"", "\u0120+", "\u0120\"", "field", "\u0120value", "\u0120of", "\u0120type", "\u0120%", "s", "\u0120to", "\u0120type", "\u0120%", "s", "\",", "\u0120form", "Field", ".", "get", "Value", "Type", "(),", "\u0120PH", "ONE", "_", "NUM", "BER", "))", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Is", "\u0120to", "String", "()", "\u0120required", "?", "\u0120It", "'s", "\u0120already", "\u0120of", "\u0120STR", "ING", "\u0120type", "."]}
{"function": "public LengthFieldBasedFrameDecoder( ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, boolean failFast) { checkPositive(maxFrameLength, \"maxFrameLength\"); checkPositiveOrZero(lengthFieldOffset, \"lengthFieldOffset\"); checkPositiveOrZero(initialBytesToStrip, \"initialBytesToStrip\"); if (lengthFieldOffset > maxFrameLength - lengthFieldLength) { throw new IllegalArgumentException( \"maxFrameLength (\" + maxFrameLength + \") \" + \"must be equal to or greater than \" + \"lengthFieldOffset (\" + lengthFieldOffset + \") + \" + \"lengthFieldLength (\" + lengthFieldLength + \").\"); } this.byteOrder = checkNotNull(byteOrder, \"byteOrder\"); this.maxFrameLength = maxFrameLength; this.lengthFieldOffset = lengthFieldOffset; this.lengthFieldLength = lengthFieldLength; this.lengthAdjustment = lengthAdjustment; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength; this.initialBytesToStrip = initialBytesToStrip; this.failFast = failFast; }", "text": "move the check and assignment before the other checks to ensure the behaviour is not changed.", "function_tokens": ["public", "\u0120Length", "Field", "Based", "Frame", "Dec", "oder", "(", "\u0120Byte", "Order", "\u0120byte", "Order", ",", "\u0120int", "\u0120max", "Frame", "Length", ",", "\u0120int", "\u0120length", "Field", "Offset", ",", "\u0120int", "\u0120length", "Field", "Length", ",", "\u0120int", "\u0120length", "Adjust", "ment", ",", "\u0120int", "\u0120initial", "Bytes", "To", "St", "rip", ",", "\u0120boolean", "\u0120fail", "Fast", ")", "\u0120{", "\u0120check", "Pos", "itive", "(", "max", "Frame", "Length", ",", "\u0120\"", "max", "Frame", "Length", "\");", "\u0120check", "Pos", "itive", "Or", "Zero", "(", "length", "Field", "Offset", ",", "\u0120\"", "length", "Field", "Offset", "\");", "\u0120check", "Pos", "itive", "Or", "Zero", "(", "initial", "Bytes", "To", "St", "rip", ",", "\u0120\"", "initial", "Bytes", "To", "St", "rip", "\");", "\u0120if", "\u0120(", "length", "Field", "Offset", "\u0120>", "\u0120max", "Frame", "Length", "\u0120-", "\u0120length", "Field", "Length", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "max", "Frame", "Length", "\u0120(\"", "\u0120+", "\u0120max", "Frame", "Length", "\u0120+", "\u0120\"", ")", "\u0120\"", "\u0120+", "\u0120\"", "must", "\u0120be", "\u0120equal", "\u0120to", "\u0120or", "\u0120greater", "\u0120than", "\u0120\"", "\u0120+", "\u0120\"", "length", "Field", "Offset", "\u0120(\"", "\u0120+", "\u0120length", "Field", "Offset", "\u0120+", "\u0120\"", ")", "\u0120+", "\u0120\"", "\u0120+", "\u0120\"", "length", "Field", "Length", "\u0120(\"", "\u0120+", "\u0120length", "Field", "Length", "\u0120+", "\u0120\"", ").\"", ");", "\u0120}", "\u0120this", ".", "byte", "Order", "\u0120=", "\u0120check", "Not", "Null", "(", "byte", "Order", ",", "\u0120\"", "byte", "Order", "\");", "\u0120this", ".", "max", "Frame", "Length", "\u0120=", "\u0120max", "Frame", "Length", ";", "\u0120this", ".", "length", "Field", "Offset", "\u0120=", "\u0120length", "Field", "Offset", ";", "\u0120this", ".", "length", "Field", "Length", "\u0120=", "\u0120length", "Field", "Length", ";", "\u0120this", ".", "length", "Adjust", "ment", "\u0120=", "\u0120length", "Adjust", "ment", ";", "\u0120length", "Field", "End", "Offset", "\u0120=", "\u0120length", "Field", "Offset", "\u0120+", "\u0120length", "Field", "Length", ";", "\u0120this", ".", "initial", "Bytes", "To", "St", "rip", "\u0120=", "\u0120initial", "Bytes", "To", "St", "rip", ";", "\u0120this", ".", "fail", "Fast", "\u0120=", "\u0120fail", "Fast", ";", "\u0120}"], "docstring_tokens": ["move", "\u0120the", "\u0120check", "\u0120and", "\u0120assignment", "\u0120before", "\u0120the", "\u0120other", "\u0120checks", "\u0120to", "\u0120ensure", "\u0120the", "\u0120behaviour", "\u0120is", "\u0120not", "\u0120changed", "."]}
{"function": "public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - 1 - endOfTableName); return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }", "text": "might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here", "function_tokens": ["public", "\u0120static", "\u0120Optional", "<", "Table", "Ref", "And", "Rem", "ain", "der", ">", "\u0120try", "Par", "se", "Table", "Ref", "(", "Lock", "Desc", "ript", "or", "\u0120lock", "Desc", "ript", "or", ")", "\u0120{", "\u0120byte", "[]", "\u0120raw", "Bytes", "\u0120=", "\u0120lock", "Desc", "ript", "or", ".", "get", "Bytes", "();", "\u0120int", "\u0120end", "Of", "Table", "Name", "\u0120=", "\u0120By", "tes", ".", "index", "Of", "(", "raw", "Bytes", ",", "\u0120(", "byte", ")", "\u01200", ");", "\u0120if", "\u0120(", "end", "Of", "Table", "Name", "\u0120==", "\u0120-", "1", ")", "\u0120{", "\u0120return", "\u0120Optional", ".", "empty", "();", "\u0120}", "\u0120String", "\u0120fully", "Qual", "ified", "Name", "\u0120=", "\u0120new", "\u0120String", "(", "raw", "Bytes", ",", "\u01200", ",", "\u0120end", "Of", "Table", "Name", ");", "\u0120Table", "Reference", "\u0120table", "Ref", "\u0120=", "\u0120Table", "Reference", ".", "create", "From", "F", "ully", "Qual", "ified", "Name", "(", "fully", "Qual", "ified", "Name", ");", "\u0120Byte", "String", "\u0120remaining", "Bytes", "\u0120=", "\u0120Byte", "String", ".", "of", "(", "raw", "Bytes", ",", "\u0120end", "Of", "Table", "Name", "\u0120+", "\u01201", ",", "\u0120raw", "Bytes", ".", "length", "\u0120-", "\u01201", "\u0120-", "\u0120end", "Of", "Table", "Name", ");", "\u0120return", "\u0120Optional", ".", "of", "(", "Imm", "utable", "Table", "Ref", "And", "Rem", "ain", "der", ".", "of", "(", "table", "Ref", ",", "\u0120remaining", "Bytes", "));", "\u0120}"], "docstring_tokens": ["might", "\u0120it", "\u0120be", "\u0120clearer", "\u0120if", "\u0120you", "\u0120said", "\u0120raw", "Bytes", ".", "length", "\u0120-", "\u0120(", "end", "Of", "Table", "Name", "\u0120+", "\u01201", ")?", "\u0120not", "\u0120particularly", "\u0120f", "ussed", "\u0120here"]}
{"function": "public void ThrottleForNormalizeTestWithinIdeal() throws Exception { List<RateLimit> scenarios = new ArrayList<>(); int limit = 5000; int buffer = ApiRateLimitChecker.calculateBuffer(limit); int approximateIdeal = 4000; scenarios.add(new RateLimit(limit, approximateIdeal + buffer - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 101, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 100, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, approximateIdeal - 99, soon)); scenarios.add(new RateLimit(limit, limit, soon)); setupStubs(scenarios); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(1, countOfOutputLinesContaining(\"under budget\")); assertFalse(handler.getView().stream().anyMatch(m -> m.getMessage().contains(\"Sleeping\"))); ApiRateLimitChecker.ThrottleForNormalize.checkApiRateLimit(listener, github); assertEquals(2, countOfOutputLinesContaining(\"rechecking\")); assertEquals(3, countOfOutputLinesContaining(\"Still sleeping\")); assertEquals(2, countOfOutputLinesContaining(\"Sleeping for\")); assertEquals(1, countOfOutputLinesContaining(\"under budget\")); assertEquals(10, handler.getView().size()); }", "text": "EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>", "function_tokens": ["public", "\u0120void", "\u0120Thro", "ttle", "For", "Normal", "ize", "Test", "Within", "Id", "eal", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120List", "<", "Rate", "Limit", ">", "\u0120scenarios", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120int", "\u0120limit", "\u0120=", "\u01205000", ";", "\u0120int", "\u0120buffer", "\u0120=", "\u0120Ap", "i", "Rate", "Limit", "Check", "er", ".", "cal", "cul", "ate", "Buffer", "(", "limit", ");", "\u0120int", "\u0120approximate", "Id", "eal", "\u0120=", "\u01204000", ";", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120+", "\u0120buffer", "\u0120-", "\u0120100", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u0120100", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u0120100", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u0120101", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u0120100", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u012099", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120approximate", "Id", "eal", "\u0120-", "\u012099", ",", "\u0120soon", "));", "\u0120scenarios", ".", "add", "(", "new", "\u0120Rate", "Limit", "(", "limit", ",", "\u0120limit", ",", "\u0120soon", "));", "\u0120setup", "St", "ubs", "(", "sc", "en", "arios", ");", "\u0120Ap", "i", "Rate", "Limit", "Check", "er", ".", "Th", "ro", "ttle", "For", "Normal", "ize", ".", "check", "A", "pi", "Rate", "Limit", "(", "list", "ener", ",", "\u0120github", ");", "\u0120assert", "Equ", "als", "(", "1", ",", "\u0120count", "Of", "Output", "L", "ines", "Cont", "aining", "(\"", "under", "\u0120budget", "\")", ");", "\u0120assert", "False", "(", "handler", ".", "get", "View", "().", "stream", "().", "any", "Match", "(", "m", "\u0120->", "\u0120m", ".", "get", "Message", "().", "cont", "ains", "(\"", "S", "le", "eping", "\"))", ");", "\u0120Ap", "i", "Rate", "Limit", "Check", "er", ".", "Th", "ro", "ttle", "For", "Normal", "ize", ".", "check", "A", "pi", "Rate", "Limit", "(", "list", "ener", ",", "\u0120github", ");", "\u0120assert", "Equ", "als", "(", "2", ",", "\u0120count", "Of", "Output", "L", "ines", "Cont", "aining", "(\"", "re", "checking", "\")", ");", "\u0120assert", "Equ", "als", "(", "3", ",", "\u0120count", "Of", "Output", "L", "ines", "Cont", "aining", "(\"", "Still", "\u0120sleeping", "\")", ");", "\u0120assert", "Equ", "als", "(", "2", ",", "\u0120count", "Of", "Output", "L", "ines", "Cont", "aining", "(\"", "S", "le", "eping", "\u0120for", "\")", ");", "\u0120assert", "Equ", "als", "(", "1", ",", "\u0120count", "Of", "Output", "L", "ines", "Cont", "aining", "(\"", "under", "\u0120budget", "\")", ");", "\u0120assert", "Equ", "als", "(", "10", ",", "\u0120handler", ".", "get", "View", "().", "size", "());", "\u0120}"], "docstring_tokens": ["EDIT", ":", "\u0120this", "\u0120is", "\u0120identical", "\u0120to", "\u0120what", "\u0120Liam", "\u0120just", "\u0120said", ".", "\u0120Just", "\u0120making", "\u0120sure", "\u0120I", "'m", "\u0120following", "\u0120along", "\u0120-", "\u0120this", "\u0120bump", "\u0120from", "\u01208", "\u0120to", "\u012010", "\u0120is", "\u0120to", "\u0120allow", "\u0120for", "\u0120these", "\u0120two", "\u0120new", "\u0120log", "\u0120lines", ",", "\u0120right", "?", "\u0120([", "75", "](", "<", "L", "INK", "_", "0", ">,", "\u0120[", "106", "](", "<", "L", "INK", "_", "1", ">"]}
{"function": "public boolean cleanupNode(final String id) { RegionAndId regionAndId = RegionAndId.fromSlashEncoded(id); ResourceGroup resourceGroup = resourceGroupMap.getUnchecked(regionAndId.region()); String group = resourceGroup.name(); VirtualMachine virtualMachine = api.getVirtualMachineApi(group).get(regionAndId.id()); if (virtualMachine == null) { return true; } logger.debug(\">> destroying %s ...\", regionAndId.slashEncode()); boolean vmDeleted = deleteVirtualMachine(group, virtualMachine); cleanupVirtualMachineNICs(group, virtualMachine); cleanupVirtualMachineStorage(group, virtualMachine); return vmDeleted; }", "text": "[minor] could you name it resourceGroupName", "function_tokens": ["public", "\u0120boolean", "\u0120cleanup", "Node", "(", "final", "\u0120String", "\u0120id", ")", "\u0120{", "\u0120Region", "And", "Id", "\u0120region", "And", "Id", "\u0120=", "\u0120Region", "And", "Id", ".", "from", "Sl", "ash", "Enc", "oded", "(", "id", ");", "\u0120Resource", "Group", "\u0120resource", "Group", "\u0120=", "\u0120resource", "Group", "Map", ".", "get", "Un", "checked", "(", "region", "And", "Id", ".", "region", "());", "\u0120String", "\u0120group", "\u0120=", "\u0120resource", "Group", ".", "name", "();", "\u0120Virtual", "Machine", "\u0120virtual", "Machine", "\u0120=", "\u0120api", ".", "get", "Virtual", "Machine", "A", "pi", "(", "group", ").", "get", "(", "region", "And", "Id", ".", "id", "());", "\u0120if", "\u0120(", "virtual", "Machine", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120logger", ".", "debug", "(\"", ">>", "\u0120destroying", "\u0120%", "s", "\u0120...\"", ",", "\u0120region", "And", "Id", ".", "sl", "ash", "En", "code", "());", "\u0120boolean", "\u0120vm", "De", "leted", "\u0120=", "\u0120delete", "Virtual", "Machine", "(", "group", ",", "\u0120virtual", "Machine", ");", "\u0120cleanup", "Virtual", "Machine", "N", "IC", "s", "(", "group", ",", "\u0120virtual", "Machine", ");", "\u0120cleanup", "Virtual", "Machine", "Storage", "(", "group", ",", "\u0120virtual", "Machine", ");", "\u0120return", "\u0120vm", "De", "leted", ";", "\u0120}"], "docstring_tokens": ["[", "min", "or", "]", "\u0120could", "\u0120you", "\u0120name", "\u0120it", "\u0120resource", "Group", "Name"]}
{"function": "public Factory(long nowMillis, Request request, Response cacheResponse) { this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; if (cacheResponse != null) { this.sentRequestMillis = cacheResponse.sentRequestAtMillis(); this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis(); Headers headers = cacheResponse.headers(); for (int i = 0, size = headers.size(); i < size; i++) { String fieldName = headers.name(i); String value = headers.value(i); if (\"Date\".equalsIgnoreCase(fieldName)) { servedDate = HttpDate.parse(value); servedDateString = value; } else if (\"Expires\".equalsIgnoreCase(fieldName)) { expires = HttpDate.parse(value); } else if (\"Last-Modified\".equalsIgnoreCase(fieldName)) { lastModified = HttpDate.parse(value); lastModifiedString = value; } else if (\"ETag\".equalsIgnoreCase(fieldName)) { etag = value; } else if (\"Age\".equalsIgnoreCase(fieldName)) { ageSeconds = UtilKtKt.toNonNegativeInt(value, -1); } } } }", "text": "UtilKtKt isn't a great name.", "function_tokens": ["public", "\u0120Factory", "(", "long", "\u0120now", "Mill", "is", ",", "\u0120Request", "\u0120request", ",", "\u0120Response", "\u0120cache", "Response", ")", "\u0120{", "\u0120this", ".", "now", "Mill", "is", "\u0120=", "\u0120now", "Mill", "is", ";", "\u0120this", ".", "request", "\u0120=", "\u0120request", ";", "\u0120this", ".", "cache", "Response", "\u0120=", "\u0120cache", "Response", ";", "\u0120if", "\u0120(", "cache", "Response", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120this", ".", "sent", "Request", "Mill", "is", "\u0120=", "\u0120cache", "Response", ".", "sent", "Request", "At", "Mill", "is", "();", "\u0120this", ".", "received", "Response", "Mill", "is", "\u0120=", "\u0120cache", "Response", ".", "received", "Response", "At", "Mill", "is", "();", "\u0120Head", "ers", "\u0120headers", "\u0120=", "\u0120cache", "Response", ".", "headers", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ",", "\u0120size", "\u0120=", "\u0120headers", ".", "size", "();", "\u0120i", "\u0120<", "\u0120size", ";", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120field", "Name", "\u0120=", "\u0120headers", ".", "name", "(", "i", ");", "\u0120String", "\u0120value", "\u0120=", "\u0120headers", ".", "value", "(", "i", ");", "\u0120if", "\u0120(\"", "Date", "\".", "equ", "als", "Ign", "ore", "Case", "(", "field", "Name", "))", "\u0120{", "\u0120served", "Date", "\u0120=", "\u0120H", "ttp", "Date", ".", "parse", "(", "value", ");", "\u0120served", "Date", "String", "\u0120=", "\u0120value", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(\"", "Exp", "ires", "\".", "equ", "als", "Ign", "ore", "Case", "(", "field", "Name", "))", "\u0120{", "\u0120expires", "\u0120=", "\u0120H", "ttp", "Date", ".", "parse", "(", "value", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(\"", "Last", "-", "Mod", "ified", "\".", "equ", "als", "Ign", "ore", "Case", "(", "field", "Name", "))", "\u0120{", "\u0120last", "Mod", "ified", "\u0120=", "\u0120H", "ttp", "Date", ".", "parse", "(", "value", ");", "\u0120last", "Mod", "ified", "String", "\u0120=", "\u0120value", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(\"", "ET", "ag", "\".", "equ", "als", "Ign", "ore", "Case", "(", "field", "Name", "))", "\u0120{", "\u0120et", "ag", "\u0120=", "\u0120value", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(\"", "Age", "\".", "equ", "als", "Ign", "ore", "Case", "(", "field", "Name", "))", "\u0120{", "\u0120age", "Second", "s", "\u0120=", "\u0120Ut", "il", "K", "t", "K", "t", ".", "to", "Non", "Neg", "ative", "Int", "(", "value", ",", "\u0120-", "1", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Ut", "il", "K", "t", "K", "t", "\u0120isn", "'t", "\u0120a", "\u0120great", "\u0120name", "."]}
{"function": "protected void doResolveAll(String inetHost, DnsRecord[] additionals, Promise<List<InetAddress>> promise, DnsCache resolveCache) throws Exception { if (inetHost == null || inetHost.isEmpty()) { promise.setSuccess(Collections.singletonList(loopbackAddress())); return; } final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost); if (bytes != null) { promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes))); return; } final String hostname = hostname(inetHost); InetAddress hostsFileEntry = resolveHostsFileEntry(hostname); if (hostsFileEntry != null) { promise.setSuccess(Collections.singletonList(hostsFileEntry)); return; } CacheResult res = doResolveAllCached(hostname, additionals, promise, resolveCache, resolvedInternetProtocolFamilies); if (res == CacheResult.CACHED) { return; } if (res == CacheResult.CACHED_EXPIRED) { promise = executor().newPromise(); } doResolveAllUncached(hostname, additionals, promise, promise, resolveCache, completeOncePreferredResolved); }", "text": "consider using a switch(res) {...}", "function_tokens": ["protected", "\u0120void", "\u0120do", "Res", "olve", "All", "(", "String", "\u0120in", "et", "Host", ",", "\u0120D", "ns", "Record", "[]", "\u0120addition", "als", ",", "\u0120Promise", "<", "List", "<", "In", "et", "Address", ">>", "\u0120promise", ",", "\u0120D", "ns", "Cache", "\u0120resolve", "Cache", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120if", "\u0120(", "inet", "Host", "\u0120==", "\u0120null", "\u0120||", "\u0120in", "et", "Host", ".", "is", "Empty", "())", "\u0120{", "\u0120promise", ".", "set", "Success", "(", "Col", "lections", ".", "sing", "leton", "List", "(", "loop", "back", "Address", "()", "));", "\u0120return", ";", "\u0120}", "\u0120final", "\u0120byte", "[]", "\u0120bytes", "\u0120=", "\u0120Net", "Ut", "il", ".", "create", "Byte", "Array", "From", "I", "p", "Address", "String", "(", "inet", "Host", ");", "\u0120if", "\u0120(", "bytes", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120promise", ".", "set", "Success", "(", "Col", "lections", ".", "sing", "leton", "List", "(", "In", "et", "Address", ".", "get", "By", "Address", "(", "bytes", "))", ");", "\u0120return", ";", "\u0120}", "\u0120final", "\u0120String", "\u0120host", "name", "\u0120=", "\u0120host", "name", "(", "inet", "Host", ");", "\u0120In", "et", "Address", "\u0120hosts", "File", "Entry", "\u0120=", "\u0120resolve", "Host", "s", "File", "Entry", "(", "host", "name", ");", "\u0120if", "\u0120(", "host", "s", "File", "Entry", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120promise", ".", "set", "Success", "(", "Col", "lections", ".", "sing", "leton", "List", "(", "host", "s", "File", "Entry", "));", "\u0120return", ";", "\u0120}", "\u0120Cache", "Result", "\u0120res", "\u0120=", "\u0120do", "Res", "olve", "All", "C", "ached", "(", "host", "name", ",", "\u0120addition", "als", ",", "\u0120promise", ",", "\u0120resolve", "Cache", ",", "\u0120resolved", "Internet", "Prot", "ocol", "F", "am", "ilies", ");", "\u0120if", "\u0120(", "res", "\u0120==", "\u0120Cache", "Result", ".", "C", "ACH", "ED", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "res", "\u0120==", "\u0120Cache", "Result", ".", "C", "ACH", "ED", "_", "EXP", "IRED", ")", "\u0120{", "\u0120promise", "\u0120=", "\u0120execut", "or", "().", "new", "Prom", "ise", "();", "\u0120}", "\u0120do", "Res", "olve", "All", "Un", "c", "ached", "(", "host", "name", ",", "\u0120addition", "als", ",", "\u0120promise", ",", "\u0120promise", ",", "\u0120resolve", "Cache", ",", "\u0120complete", "Once", "Pre", "ferred", "Res", "olved", ");", "\u0120}"], "docstring_tokens": ["consider", "\u0120using", "\u0120a", "\u0120switch", "(", "res", ")", "\u0120{", "...", "}"]}
{"function": "private List<Resource> filterNotAuthorizedResource(PerunSession sess, List<Resource> resources) throws InternalErrorException { Iterator<Resource> resIterator = resources.iterator(); while(resIterator.hasNext()) { Resource resource = resIterator.next(); if(!AuthzResolver.isAuthorized(sess, Role.RESOURCEADMIN, resource) && !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) resIterator.remove(); } return resources; }", "text": "For PerunObserver you can return all resources immediately.", "function_tokens": ["private", "\u0120List", "<", "Resource", ">", "\u0120filter", "Not", "Author", "ized", "Resource", "(", "Per", "un", "Session", "\u0120s", "ess", ",", "\u0120List", "<", "Resource", ">", "\u0120resources", ")", "\u0120throws", "\u0120Internal", "Error", "Exception", "\u0120{", "\u0120Iter", "ator", "<", "Resource", ">", "\u0120res", "Iterator", "\u0120=", "\u0120resources", ".", "iterator", "();", "\u0120while", "(", "res", "Iterator", ".", "has", "Next", "())", "\u0120{", "\u0120Resource", "\u0120resource", "\u0120=", "\u0120res", "Iterator", ".", "next", "();", "\u0120if", "(", "!", "Auth", "z", "Res", "olver", ".", "is", "Author", "ized", "(", "s", "ess", ",", "\u0120Role", ".", "RES", "OURCE", "AD", "MIN", ",", "\u0120resource", ")", "\u0120&&", "\u0120!", "Auth", "z", "Res", "olver", ".", "is", "Author", "ized", "(", "s", "ess", ",", "\u0120Role", ".", "PER", "UN", "O", "BS", "ER", "VER", "))", "\u0120res", "Iterator", ".", "remove", "();", "\u0120}", "\u0120return", "\u0120resources", ";", "\u0120}"], "docstring_tokens": ["For", "\u0120Per", "un", "Obs", "erver", "\u0120you", "\u0120can", "\u0120return", "\u0120all", "\u0120resources", "\u0120immediately", "."]}
{"function": "public void initTrackerServers(List<TrackerServer> serverList) { serverList.add(new TrackerServer(new ServerBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(\"objectDecoder\", new AstraProtocolDecoder(AstraProtocol.this)); } }); serverList.add(new TrackerServer(new ConnectionlessBootstrap(), this.getName()) { @Override protected void addSpecificHandlers(ChannelPipeline pipeline) { pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024, 1, 2, -3, 0)); pipeline.addLast(\"objectDecoder\", new AstraProtocolDecoder(AstraProtocol.this)); } }); }", "text": "UDP is a datagram protocol, so it doesn't require frame decoder.", "function_tokens": ["public", "\u0120void", "\u0120init", "Tracker", "Ser", "vers", "(", "List", "<", "Tracker", "Server", ">", "\u0120server", "List", ")", "\u0120{", "\u0120server", "List", ".", "add", "(", "new", "\u0120Tracker", "Server", "(", "new", "\u0120Server", "Boot", "strap", "(),", "\u0120this", ".", "get", "Name", "())", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120void", "\u0120add", "Specific", "Hand", "lers", "(", "Channel", "P", "ip", "eline", "\u0120pipeline", ")", "\u0120{", "\u0120pipeline", ".", "add", "Last", "(\"", "frame", "Dec", "oder", "\",", "\u0120new", "\u0120Length", "Field", "Based", "Frame", "Dec", "oder", "(", "1024", ",", "\u01201", ",", "\u01202", ",", "\u0120-", "3", ",", "\u01200", "));", "\u0120pipeline", ".", "add", "Last", "(\"", "object", "Dec", "oder", "\",", "\u0120new", "\u0120Ast", "ra", "Prot", "ocol", "Dec", "oder", "(", "A", "stra", "Prot", "ocol", ".", "this", "));", "\u0120}", "\u0120});", "\u0120server", "List", ".", "add", "(", "new", "\u0120Tracker", "Server", "(", "new", "\u0120Connection", "less", "Boot", "strap", "(),", "\u0120this", ".", "get", "Name", "())", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120void", "\u0120add", "Specific", "Hand", "lers", "(", "Channel", "P", "ip", "eline", "\u0120pipeline", ")", "\u0120{", "\u0120pipeline", ".", "add", "Last", "(\"", "frame", "Dec", "oder", "\",", "\u0120new", "\u0120Length", "Field", "Based", "Frame", "Dec", "oder", "(", "1024", ",", "\u01201", ",", "\u01202", ",", "\u0120-", "3", ",", "\u01200", "));", "\u0120pipeline", ".", "add", "Last", "(\"", "object", "Dec", "oder", "\",", "\u0120new", "\u0120Ast", "ra", "Prot", "ocol", "Dec", "oder", "(", "A", "stra", "Prot", "ocol", ".", "this", "));", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["U", "DP", "\u0120is", "\u0120a", "\u0120dat", "agram", "\u0120protocol", ",", "\u0120so", "\u0120it", "\u0120doesn", "'t", "\u0120require", "\u0120frame", "\u0120dec", "oder", "."]}
{"function": "protected Properties getIntegrationProperties() { if (this.beanFactory != null) { return IntegrationContextUtils.getIntegrationProperties(this.beanFactory); } else { return null; } }", "text": "Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.", "function_tokens": ["protected", "\u0120Properties", "\u0120get", "Integ", "ration", "Pro", "perties", "()", "\u0120{", "\u0120if", "\u0120(", "this", ".", "bean", "Factory", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120Integration", "Context", "Ut", "ils", ".", "get", "Integ", "ration", "Pro", "perties", "(", "this", ".", "bean", "Factory", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["Maybe", "\u0120we", "\u0120can", "\u0120return", "\u0120an", "\u0120empty", "\u0120Properties", "\u0120here", "\u0120(", "perhaps", "\u0120a", "\u0120static", "\u0120constant", "\u0120empty", "\u0120props", "\u0120so", "\u0120we", "\u0120don", "'t", "\u0120create", "\u0120a", "\u0120new", "\u0120one", "\u0120for", "\u0120each", "\u0120instance", ").", "\u0120It", "\u0120would", "\u0120save", "\u0120a", "\u0120null", "\u0120check", "\u0120everywhere", "\u0120that", "\u0120uses", "\u0120it", "."]}
{"function": "public void testShowStatsSelectNonStarFails() { assertQueryFails(\"SHOW STATS FOR (SELECT nationkey FROM nation_partitioned)\", \".*Only SELECT \\\\* is supported in SHOW STATS SELECT clause\"); }", "text": "Why this change?", "function_tokens": ["public", "\u0120void", "\u0120test", "Show", "Stats", "Select", "Non", "Star", "F", "ails", "()", "\u0120{", "\u0120assert", "Query", "F", "ails", "(\"", "SH", "OW", "\u0120STATS", "\u0120FOR", "\u0120(", "SELECT", "\u0120nation", "key", "\u0120FROM", "\u0120nation", "_", "part", "ition", "ed", ")\",", "\u0120\"", ".*", "Only", "\u0120SELECT", "\u0120\\\\", "*", "\u0120is", "\u0120supported", "\u0120in", "\u0120SHOW", "\u0120STATS", "\u0120SELECT", "\u0120clause", "\");", "\u0120}"], "docstring_tokens": ["Why", "\u0120this", "\u0120change", "?"]}
{"function": "protected static ConnectionFactory getConnectionFactory( IDatabaseConnection databaseConnection, String url ) { ConnectionFactory factory = null; if ( url.startsWith( \"jdbc:mysql:\" ) || ( url.startsWith( \"jdbc:mariadb:\" ) ) ) { Properties props = new Properties(); props.put( \"user\", StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ) ); props.put( \"password\", StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); props.put( \"socketTimeout\", \"0\" ); props.put( \"connectTimeout\", \"5000\" ); factory = new DriverManagerConnectionFactory( url, props ); } else { factory = new DriverManagerConnectionFactory( url, StringEscapeUtils.unescapeHtml( databaseConnection.getUsername() ), StringEscapeUtils.unescapeHtml( databaseConnection.getPassword() ) ); } return factory; }", "text": "We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.", "function_tokens": ["protected", "\u0120static", "\u0120Connection", "Factory", "\u0120get", "Connection", "Factory", "(", "\u0120ID", "at", "abase", "Connection", "\u0120database", "Connection", ",", "\u0120String", "\u0120url", "\u0120)", "\u0120{", "\u0120Connection", "Factory", "\u0120factory", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "\u0120url", ".", "st", "arts", "With", "(", "\u0120\"", "j", "db", "c", ":", "mys", "ql", ":\"", "\u0120)", "\u0120||", "\u0120(", "\u0120url", ".", "st", "arts", "With", "(", "\u0120\"", "j", "db", "c", ":", "m", "ari", "ad", "b", ":\"", "\u0120)", "\u0120)", "\u0120)", "\u0120{", "\u0120Properties", "\u0120props", "\u0120=", "\u0120new", "\u0120Properties", "();", "\u0120props", ".", "put", "(", "\u0120\"", "user", "\",", "\u0120String", "E", "scape", "Ut", "ils", ".", "un", "escape", "H", "tml", "(", "\u0120database", "Connection", ".", "get", "Us", "ername", "()", "\u0120)", "\u0120);", "\u0120props", ".", "put", "(", "\u0120\"", "password", "\",", "\u0120String", "E", "scape", "Ut", "ils", ".", "un", "escape", "H", "tml", "(", "\u0120database", "Connection", ".", "get", "Password", "()", "\u0120)", "\u0120);", "\u0120props", ".", "put", "(", "\u0120\"", "socket", "Timeout", "\",", "\u0120\"", "0", "\"", "\u0120);", "\u0120props", ".", "put", "(", "\u0120\"", "connect", "Timeout", "\",", "\u0120\"", "5000", "\"", "\u0120);", "\u0120factory", "\u0120=", "\u0120new", "\u0120Driver", "Manager", "Connection", "Factory", "(", "\u0120url", ",", "\u0120props", "\u0120);", "\u0120}", "\u0120else", "\u0120{", "\u0120factory", "\u0120=", "\u0120new", "\u0120Driver", "Manager", "Connection", "Factory", "(", "\u0120url", ",", "\u0120String", "E", "scape", "Ut", "ils", ".", "un", "escape", "H", "tml", "(", "\u0120database", "Connection", ".", "get", "Us", "ername", "()", "\u0120),", "\u0120String", "E", "scape", "Ut", "ils", ".", "un", "escape", "H", "tml", "(", "\u0120database", "Connection", ".", "get", "Password", "()", "\u0120)", "\u0120);", "\u0120}", "\u0120return", "\u0120factory", ";", "\u0120}"], "docstring_tokens": ["We", "\u0120cannot", "\u0120do", "\u0120this", "\u0120-", "\u0120this", "\u0120is", "\u0120a", "\u0120really", "\u0120bad", "\u0120practice", ".", "\u0120Please", "\u0120don", "'t", "\u0120write", "\u0120code", "\u0120that", "\u0120resembles", "\u0120this", "\u0120either", ".", "\u0120We", "\u0120need", "\u0120symm", "etric", "\u0120encoding", "/", "dec", "oding", "\u0120that", "'s", "\u0120done", "\u0120for", "\u0120all", "\u0120databases", ",", "\u0120not", "\u0120targeted", "\u0120at", "\u0120MySQL", "/", "Maria", "DB", "."]}
{"function": "public void testDisableIncrementalAnalysis() { executeTarget(\"testDisableIncrementalAnalysis\"); assertOutputContaining(\"Avoid really long methods\"); }", "text": "you should check the cache doesn't exist, plus that no suggestion to use the cache is logged", "function_tokens": ["public", "\u0120void", "\u0120test", "Disable", "Incre", "mental", "Analysis", "()", "\u0120{", "\u0120execute", "Target", "(\"", "test", "Disable", "Incre", "mental", "Analysis", "\");", "\u0120assert", "Output", "Cont", "aining", "(\"", "Avoid", "\u0120really", "\u0120long", "\u0120methods", "\");", "\u0120}"], "docstring_tokens": ["you", "\u0120should", "\u0120check", "\u0120the", "\u0120cache", "\u0120doesn", "'t", "\u0120exist", ",", "\u0120plus", "\u0120that", "\u0120no", "\u0120suggestion", "\u0120to", "\u0120use", "\u0120the", "\u0120cache", "\u0120is", "\u0120logged"]}
{"function": "public void preInstall() { resolver = Entities.newDownloader(this); String subpath = entity.getConfig(BrooklynNode.SUBPATH_IN_ARCHIVE); if (subpath==null) { String uploadUrl = entity.getConfig(BrooklynNode.DISTRO_UPLOAD_URL); String origDownloadName = uploadUrl; if (origDownloadName==null) { String downloadUrlTemplate = entity.getAttribute(BrooklynNode.DOWNLOAD_URL); if (downloadUrlTemplate!=null) { origDownloadName = DownloadSubstituters.substitute(downloadUrlTemplate, DownloadSubstituters.getBasicEntitySubstitutions(this)); } } if (origDownloadName!=null) { origDownloadName = Urls.getBasename(origDownloadName); String downloadName = origDownloadName; downloadName = Strings.removeFromEnd(downloadName, \".tar.gz\"); downloadName = Strings.removeFromEnd(downloadName, \".tgz\"); downloadName = Strings.removeFromEnd(downloadName, \".zip\"); if (!downloadName.equals(origDownloadName)) { downloadName = Strings.removeFromEnd(downloadName, \"-dist\"); subpath = downloadName; } } } if (subpath==null) subpath = format(\"brooklyn-%s\", getVersion()); setExpandedInstallDir(Os.mergePaths(getInstallDir(), resolver.getUnpackedDirectoryName(subpath))); }", "text": "Make sure to unescape the url path before using it. I've hit this in actual usage.", "function_tokens": ["public", "\u0120void", "\u0120pre", "Install", "()", "\u0120{", "\u0120res", "olver", "\u0120=", "\u0120Ent", "ities", ".", "new", "Download", "er", "(", "this", ");", "\u0120String", "\u0120sub", "path", "\u0120=", "\u0120entity", ".", "get", "Config", "(", "Brook", "lyn", "Node", ".", "S", "UB", "PATH", "_", "IN", "_", "ARCH", "IVE", ");", "\u0120if", "\u0120(", "sub", "path", "==", "null", ")", "\u0120{", "\u0120String", "\u0120upload", "Url", "\u0120=", "\u0120entity", ".", "get", "Config", "(", "Brook", "lyn", "Node", ".", "DIS", "TR", "O", "_", "U", "PL", "OAD", "_", "URL", ");", "\u0120String", "\u0120orig", "Download", "Name", "\u0120=", "\u0120upload", "Url", ";", "\u0120if", "\u0120(", "orig", "Download", "Name", "==", "null", ")", "\u0120{", "\u0120String", "\u0120download", "Url", "Template", "\u0120=", "\u0120entity", ".", "get", "Attribute", "(", "Brook", "lyn", "Node", ".", "DOWN", "LOAD", "_", "URL", ");", "\u0120if", "\u0120(", "download", "Url", "Template", "!", "=", "null", ")", "\u0120{", "\u0120orig", "Download", "Name", "\u0120=", "\u0120Download", "Sub", "st", "it", "uters", ".", "sub", "st", "itute", "(", "download", "Url", "Template", ",", "\u0120Download", "Sub", "st", "it", "uters", ".", "get", "Basic", "Entity", "Sub", "st", "it", "utions", "(", "this", "));", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "orig", "Download", "Name", "!", "=", "null", ")", "\u0120{", "\u0120orig", "Download", "Name", "\u0120=", "\u0120Ur", "ls", ".", "get", "Bas", "ename", "(", "orig", "Download", "Name", ");", "\u0120String", "\u0120download", "Name", "\u0120=", "\u0120orig", "Download", "Name", ";", "\u0120download", "Name", "\u0120=", "\u0120Str", "ings", ".", "remove", "From", "End", "(", "download", "Name", ",", "\u0120\".", "tar", ".", "gz", "\");", "\u0120download", "Name", "\u0120=", "\u0120Str", "ings", ".", "remove", "From", "End", "(", "download", "Name", ",", "\u0120\".", "tg", "z", "\");", "\u0120download", "Name", "\u0120=", "\u0120Str", "ings", ".", "remove", "From", "End", "(", "download", "Name", ",", "\u0120\".", "zip", "\");", "\u0120if", "\u0120(!", "download", "Name", ".", "equ", "als", "(", "orig", "Download", "Name", "))", "\u0120{", "\u0120download", "Name", "\u0120=", "\u0120Str", "ings", ".", "remove", "From", "End", "(", "download", "Name", ",", "\u0120\"-", "dist", "\");", "\u0120sub", "path", "\u0120=", "\u0120download", "Name", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "sub", "path", "==", "null", ")", "\u0120sub", "path", "\u0120=", "\u0120format", "(\"", "brook", "lyn", "-", "%", "s", "\",", "\u0120get", "Version", "());", "\u0120set", "Exp", "anded", "Install", "Dir", "(", "Os", ".", "mer", "ge", "Path", "s", "(", "get", "Install", "Dir", "(),", "\u0120res", "olver", ".", "get", "Un", "packed", "Directory", "Name", "(", "sub", "path", "))", ");", "\u0120}"], "docstring_tokens": ["Make", "\u0120sure", "\u0120to", "\u0120un", "escape", "\u0120the", "\u0120url", "\u0120path", "\u0120before", "\u0120using", "\u0120it", ".", "\u0120I", "'ve", "\u0120hit", "\u0120this", "\u0120in", "\u0120actual", "\u0120usage", "."]}
{"function": "public boolean isLaunchedFromIntent() { return invokeSource.equals(InvokeSource.WIDGET) || invokeSource.equals(InvokeSource.INTENT_SHARE) || invokeSource.equals(InvokeSource.INTENT_PROCESS_TEXT); }", "text": "A future refactor might place this method in the enum directly.", "function_tokens": ["public", "\u0120boolean", "\u0120is", "Laun", "ched", "From", "Int", "ent", "()", "\u0120{", "\u0120return", "\u0120invoke", "Source", ".", "equ", "als", "(", "Inv", "oke", "Source", ".", "W", "ID", "GET", ")", "\u0120||", "\u0120invoke", "Source", ".", "equ", "als", "(", "Inv", "oke", "Source", ".", "INT", "ENT", "_", "SHARE", ")", "\u0120||", "\u0120invoke", "Source", ".", "equ", "als", "(", "Inv", "oke", "Source", ".", "INT", "ENT", "_", "PR", "OC", "ESS", "_", "TEXT", ");", "\u0120}"], "docstring_tokens": ["A", "\u0120future", "\u0120ref", "actor", "\u0120might", "\u0120place", "\u0120this", "\u0120method", "\u0120in", "\u0120the", "\u0120enum", "\u0120directly", "."]}
{"function": "private void initializeAsyncCancelAndVerifyCancelled(AlwaysFailingInitializer initializer, Runnable cleanupTask) throws InterruptedException { initializer.initialize(true); initializer.cancelInitialization(cleanupTask); int numberOfAttemptsWhenCancelled = initializer.initializationAttempts; initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY * 5 + 1, TimeUnit.MILLISECONDS); assertThat(initializer.initializationAttempts).isEqualTo(numberOfAttemptsWhenCancelled); }", "text": "We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?", "function_tokens": ["private", "\u0120void", "\u0120initialize", "Async", "C", "ancel", "And", "Ver", "ify", "C", "ance", "lled", "(", "Always", "F", "ailing", "Initial", "izer", "\u0120initial", "izer", ",", "\u0120Run", "n", "able", "\u0120cleanup", "Task", ")", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120initial", "izer", ".", "initial", "ize", "(", "true", ");", "\u0120initial", "izer", ".", "c", "ancel", "Initial", "ization", "(", "clean", "up", "Task", ");", "\u0120int", "\u0120number", "Of", "Attempts", "When", "C", "ance", "lled", "\u0120=", "\u0120initial", "izer", ".", "initial", "ization", "Attempts", ";", "\u0120initial", "izer", ".", "d", "eter", "ministic", "S", "ched", "uler", ".", "tick", "(", "ASY", "NC", "_", "IN", "IT", "_", "D", "EL", "AY", "\u0120*", "\u01205", "\u0120+", "\u01201", ",", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", ");", "\u0120assert", "That", "(", "initial", "izer", ".", "initial", "ization", "Attempts", ").", "is", "E", "qual", "To", "(", "number", "Of", "Attempts", "When", "C", "ance", "lled", ");", "\u0120}"], "docstring_tokens": ["We", "\u0120have", "\u0120AS", "Y", "NC", "_", "IN", "IT", "_", "D", "EL", "AY", "\u0120*", "\u01205", "\u0120+", "\u01201", "\u0120twice", "\u0120here", "\u0120(", "well", ",", "\u0120the", "\u0120other", "\u0120time", ",", "\u0120it", "'s", "\u01205", "*", "A", "ID", "+", "1", "\u0120).", "\u0120Is", "\u0120it", "\u0120worth", "\u0120extracting", "\u0120a", "\u0120constant", "\u0120here", ",", "\u0120like", "\u0120SE", "VER", "AL", "_", "IN", "IT", "_", "D", "EL", "AY", "S", "?"]}
{"function": "public ExecutorService getExecutor(Properties p) { TypedProperties tp = TypedProperties.toTypedProperties(p); int maxThreads = tp.getIntProperty(\"maxThreads\", 1); int queueSize = tp.getIntProperty(\"queueSize\", 100000); long keepAliveTime = tp.getLongProperty(\"keepAlive\", 10000); final int threadPrio = tp.getIntProperty(\"threadPriority\", Thread.MIN_PRIORITY); final String threadNamePrefix = tp.getProperty(\"threadNamePrefix\", tp.getProperty(\"componentName\", \"Thread\")); final String threadNameSuffix = tp.getProperty(\"threadNameSuffix\", \"\"); ThreadFactory tf = new ThreadFactory() { @Override public Thread newThread(Runnable r) { String threadName = threadNamePrefix + \"-\" + counter.getAndIncrement() + threadNameSuffix; Thread th = new Thread(r, threadName); th.setDaemon(true); th.setPriority(threadPrio); return th; } }; ThreadPoolExecutor tpe = new ThreadPoolExecutor(maxThreads, maxThreads, keepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(queueSize), tf, new ThreadPoolExecutor.CallerRunsPolicy()); tpe.allowCoreThreadTimeOut(true); return tpe; }", "text": "I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.", "function_tokens": ["public", "\u0120Exec", "utor", "Service", "\u0120get", "Exec", "utor", "(", "Pro", "perties", "\u0120p", ")", "\u0120{", "\u0120Typ", "ed", "Pro", "perties", "\u0120t", "p", "\u0120=", "\u0120Typ", "ed", "Pro", "perties", ".", "to", "Typ", "ed", "Pro", "perties", "(", "p", ");", "\u0120int", "\u0120max", "Thread", "s", "\u0120=", "\u0120t", "p", ".", "get", "Int", "Property", "(\"", "max", "Thread", "s", "\",", "\u01201", ");", "\u0120int", "\u0120queue", "Size", "\u0120=", "\u0120t", "p", ".", "get", "Int", "Property", "(\"", "queue", "Size", "\",", "\u0120100", "000", ");", "\u0120long", "\u0120keep", "Al", "ive", "Time", "\u0120=", "\u0120t", "p", ".", "get", "Long", "Property", "(\"", "keep", "Al", "ive", "\",", "\u012010000", ");", "\u0120final", "\u0120int", "\u0120thread", "P", "rio", "\u0120=", "\u0120t", "p", ".", "get", "Int", "Property", "(\"", "thread", "Prior", "ity", "\",", "\u0120Thread", ".", "MIN", "_", "PR", "IOR", "ITY", ");", "\u0120final", "\u0120String", "\u0120thread", "Name", "Pref", "ix", "\u0120=", "\u0120t", "p", ".", "get", "Property", "(\"", "thread", "Name", "Pref", "ix", "\",", "\u0120t", "p", ".", "get", "Property", "(\"", "component", "Name", "\",", "\u0120\"", "Thread", "\")", ");", "\u0120final", "\u0120String", "\u0120thread", "Name", "S", "uff", "ix", "\u0120=", "\u0120t", "p", ".", "get", "Property", "(\"", "thread", "Name", "S", "uff", "ix", "\",", "\u0120\"\"", ");", "\u0120Thread", "Factory", "\u0120tf", "\u0120=", "\u0120new", "\u0120Thread", "Factory", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Thread", "\u0120new", "Thread", "(", "Run", "n", "able", "\u0120r", ")", "\u0120{", "\u0120String", "\u0120thread", "Name", "\u0120=", "\u0120thread", "Name", "Pref", "ix", "\u0120+", "\u0120\"", "-\"", "\u0120+", "\u0120counter", ".", "get", "And", "Incre", "ment", "()", "\u0120+", "\u0120thread", "Name", "S", "uff", "ix", ";", "\u0120Thread", "\u0120th", "\u0120=", "\u0120new", "\u0120Thread", "(", "r", ",", "\u0120thread", "Name", ");", "\u0120th", ".", "set", "Da", "emon", "(", "true", ");", "\u0120th", ".", "set", "Prior", "ity", "(", "thread", "P", "rio", ");", "\u0120return", "\u0120th", ";", "\u0120}", "\u0120};", "\u0120Thread", "Pool", "Exec", "utor", "\u0120t", "pe", "\u0120=", "\u0120new", "\u0120Thread", "Pool", "Exec", "utor", "(", "max", "Thread", "s", ",", "\u0120max", "Thread", "s", ",", "\u0120keep", "Al", "ive", "Time", ",", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", ",", "\u0120new", "\u0120Link", "ed", "Bl", "ocking", "Queue", "<", "Run", "n", "able", ">(", "queue", "Size", "),", "\u0120tf", ",", "\u0120new", "\u0120Thread", "Pool", "Exec", "utor", ".", "Call", "er", "Run", "s", "Policy", "());", "\u0120t", "pe", ".", "allow", "Core", "Thread", "Time", "Out", "(", "true", ");", "\u0120return", "\u0120t", "pe", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120this", "\u0120helps", ",", "\u0120because", "\u0120as", "\u0120long", "\u0120as", "\u0120the", "\u0120number", "\u0120of", "\u0120available", "\u0120threads", "\u0120is", "\u0120smaller", "\u0120the", "\u0120number", "\u0120of", "\u0120core", "\u0120threads", ",", "\u0120the", "\u0120execut", "or", "\u0120will", "\u0120create", "\u0120new", "\u0120threads", "\u0120for", "\u0120each", "\u0120submitted", "\u0120task", "."]}
{"function": "public GWCConfig getConfig() { if (gsEnvironment != null && gsEnvironment.isStale()) { syncEnvironment(); } return gwcConfigPersister.getConfig(); }", "text": "This bloc of code is repeated many times, should be centralized in a single method.", "function_tokens": ["public", "\u0120GW", "C", "Config", "\u0120get", "Config", "()", "\u0120{", "\u0120if", "\u0120(", "gs", "Environment", "\u0120!=", "\u0120null", "\u0120&&", "\u0120g", "s", "Environment", ".", "is", "St", "ale", "())", "\u0120{", "\u0120sync", "Environment", "();", "\u0120}", "\u0120return", "\u0120g", "w", "c", "Config", "Pers", "ister", ".", "get", "Config", "();", "\u0120}"], "docstring_tokens": ["This", "\u0120bloc", "\u0120of", "\u0120code", "\u0120is", "\u0120repeated", "\u0120many", "\u0120times", ",", "\u0120should", "\u0120be", "\u0120centralized", "\u0120in", "\u0120a", "\u0120single", "\u0120method", "."]}
{"function": "private void captureScreenshot(String comment, WebDriver driver, WebElement element, boolean errorMessage) { if (getMessage(errorMessage) != null) { comment = getMessage(errorMessage); } LOGGER.debug(\"DriverListener->captureScreenshot starting...\"); try { if (errorMessage) { LOGGER.error(comment); Screenshot.captureFailure(driver, comment); } else { LOGGER.info(comment); if (MobileContextHelper.isInWebViewContext()) { MobileContextHelper.backUpContext(driver); Screenshot.capture(driver, comment); MobileContextHelper.restoreContext(driver); } else { Screenshot.capture(driver, comment); } } } catch (Exception e) { LOGGER.debug(\"Unrecognized failure detected in DriverListener->captureScreenshot: \" + e.getMessage(), e); } finally { resetMessages(); } LOGGER.debug(\"DriverListener->captureScreenshot finished...\"); }", "text": "I don't see sense from this if (MobileContextHelper.isInWebViewContext())", "function_tokens": ["private", "\u0120void", "\u0120capture", "Screenshot", "(", "String", "\u0120comment", ",", "\u0120Web", "Driver", "\u0120driver", ",", "\u0120Web", "Element", "\u0120element", ",", "\u0120boolean", "\u0120error", "Message", ")", "\u0120{", "\u0120if", "\u0120(", "get", "Message", "(", "error", "Message", ")", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120comment", "\u0120=", "\u0120get", "Message", "(", "error", "Message", ");", "\u0120}", "\u0120LOG", "GER", ".", "debug", "(\"", "Driver", "Listener", "->", "capt", "ure", "Screenshot", "\u0120starting", "...\"", ");", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "error", "Message", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(", "comment", ");", "\u0120Sc", "reenshot", ".", "capt", "ure", "Failure", "(", "driver", ",", "\u0120comment", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", "GER", ".", "info", "(", "comment", ");", "\u0120if", "\u0120(", "Mobile", "Context", "Helper", ".", "is", "In", "Web", "View", "Context", "())", "\u0120{", "\u0120Mobile", "Context", "Helper", ".", "back", "Up", "Context", "(", "driver", ");", "\u0120Sc", "reenshot", ".", "capt", "ure", "(", "driver", ",", "\u0120comment", ");", "\u0120Mobile", "Context", "Helper", ".", "rest", "ore", "Context", "(", "driver", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Sc", "reenshot", ".", "capt", "ure", "(", "driver", ",", "\u0120comment", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Un", "recogn", "ized", "\u0120failure", "\u0120detected", "\u0120in", "\u0120Driver", "Listener", "->", "capt", "ure", "Screenshot", ":", "\u0120\"", "\u0120+", "\u0120e", ".", "get", "Message", "(),", "\u0120e", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120reset", "Mess", "ages", "();", "\u0120}", "\u0120LOG", "GER", ".", "debug", "(\"", "Driver", "Listener", "->", "capt", "ure", "Screenshot", "\u0120finished", "...\"", ");", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120see", "\u0120sense", "\u0120from", "\u0120this", "\u0120if", "\u0120(", "Mobile", "Context", "Helper", ".", "is", "In", "Web", "View", "Context", "())"]}
{"function": "public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) { super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.my_courses, menu); final Config config = environment.getConfig(); if (config.isTabsLayoutEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(false); menu.findItem(R.id.menu_item_account).setVisible(true); menu.findItem(R.id.menu_item_account).setIcon( new IconDrawable(getContext(), FontAwesomeIcons.fa_gear) .colorRes(getContext(), R.color.white) .actionBarSize(getContext())); } else { menu.findItem(R.id.menu_item_account).setVisible(false); if (config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled()) { menu.findItem(R.id.menu_item_search).setVisible(true); } else { menu.findItem(R.id.menu_item_search).setVisible(false); } } }", "text": "This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled())", "function_tokens": ["public", "\u0120void", "\u0120on", "Create", "Options", "Menu", "(", "Menu", "\u0120menu", ",", "\u0120Menu", "In", "fl", "ater", "\u0120infl", "ater", ")", "\u0120{", "\u0120super", ".", "on", "Create", "Options", "Menu", "(", "menu", ",", "\u0120infl", "ater", ");", "\u0120infl", "ater", ".", "in", "fl", "ate", "(", "R", ".", "menu", ".", "my", "_", "c", "ourses", ",", "\u0120menu", ");", "\u0120final", "\u0120Config", "\u0120config", "\u0120=", "\u0120environment", ".", "get", "Config", "();", "\u0120if", "\u0120(", "config", ".", "is", "T", "abs", "Layout", "Enabled", "())", "\u0120{", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "search", ").", "set", "V", "isible", "(", "false", ");", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "account", ").", "set", "V", "isible", "(", "true", ");", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "account", ").", "set", "Icon", "(", "\u0120new", "\u0120Icon", "Draw", "able", "(", "get", "Context", "(),", "\u0120Font", "Awesome", "I", "cons", ".", "fa", "_", "gear", ")", "\u0120.", "color", "Res", "(", "get", "Context", "(),", "\u0120R", ".", "color", ".", "white", ")", "\u0120.", "action", "Bar", "Size", "(", "get", "Context", "()", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "account", ").", "set", "V", "isible", "(", "false", ");", "\u0120if", "\u0120(", "config", ".", "get", "Course", "D", "iscovery", "Config", "().", "is", "Course", "D", "iscovery", "Enabled", "())", "\u0120{", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "search", ").", "set", "V", "isible", "(", "true", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "search", ").", "set", "V", "isible", "(", "false", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120if", "-", "else", "\u0120block", "\u0120can", "\u0120be", "\u0120simplified", "\u0120to", ":", "\u0120menu", ".", "find", "Item", "(", "R", ".", "id", ".", "menu", "_", "item", "_", "search", ").", "set", "V", "isible", "(", "config", ".", "get", "Course", "D", "iscovery", "Config", "().", "is", "Course", "D", "iscovery", "Enabled", "())"]}
{"function": "protected List<AttributeStatement> createSubjectRoleStatement(final CallbackProperties properties) throws SAMLAssertionBuilderException { final String userCode = properties.getUserCode(); final String userSystem = properties.getUserSystem(); final String userSystemName = properties.getUserSystemName(); final String userDisplay = properties.getUserDisplay(); if (Arrays.asList(userCode, userSystem, userSystemName, userDisplay).contains(null)) { LOG.error(\"No information provided to fill in user role attribute..\"); throw new SAMLAssertionBuilderException(\"No information provided to fill in user role attribute.\"); } final List<AttributeStatement> statements = new ArrayList<>(); final List<Attribute> attributes = new ArrayList<>(); attributes.add(componentBuilder.createUserRoleAttribute(userCode, userSystem, userSystemName, userDisplay)); if (!attributes.isEmpty()) { statements.addAll(componentBuilder.createAttributeStatement(attributes)); } return statements; }", "text": "Can this be changed to createSubjectRoleAttribute?", "function_tokens": ["protected", "\u0120List", "<", "Attribute", "Statement", ">", "\u0120create", "Subject", "Role", "Statement", "(", "final", "\u0120Call", "back", "Pro", "perties", "\u0120properties", ")", "\u0120throws", "\u0120SAM", "L", "Ass", "ert", "ion", "Builder", "Exception", "\u0120{", "\u0120final", "\u0120String", "\u0120user", "Code", "\u0120=", "\u0120properties", ".", "get", "User", "Code", "();", "\u0120final", "\u0120String", "\u0120user", "System", "\u0120=", "\u0120properties", ".", "get", "User", "System", "();", "\u0120final", "\u0120String", "\u0120user", "System", "Name", "\u0120=", "\u0120properties", ".", "get", "User", "System", "Name", "();", "\u0120final", "\u0120String", "\u0120user", "Display", "\u0120=", "\u0120properties", ".", "get", "User", "Display", "();", "\u0120if", "\u0120(", "Ar", "rays", ".", "as", "List", "(", "user", "Code", ",", "\u0120user", "System", ",", "\u0120user", "System", "Name", ",", "\u0120user", "Display", ").", "cont", "ains", "(", "null", "))", "\u0120{", "\u0120LOG", ".", "error", "(\"", "No", "\u0120information", "\u0120provided", "\u0120to", "\u0120fill", "\u0120in", "\u0120user", "\u0120role", "\u0120attribute", "..", "\");", "\u0120throw", "\u0120new", "\u0120SAM", "L", "Ass", "ert", "ion", "Builder", "Exception", "(\"", "No", "\u0120information", "\u0120provided", "\u0120to", "\u0120fill", "\u0120in", "\u0120user", "\u0120role", "\u0120attribute", ".\"", ");", "\u0120}", "\u0120final", "\u0120List", "<", "Attribute", "Statement", ">", "\u0120statements", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120final", "\u0120List", "<", "Attribute", ">", "\u0120attributes", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120attributes", ".", "add", "(", "component", "Builder", ".", "create", "User", "Role", "Attribute", "(", "user", "Code", ",", "\u0120user", "System", ",", "\u0120user", "System", "Name", ",", "\u0120user", "Display", "));", "\u0120if", "\u0120(!", "att", "ributes", ".", "is", "Empty", "())", "\u0120{", "\u0120statements", ".", "add", "All", "(", "component", "Builder", ".", "create", "Attribute", "Statement", "(", "att", "ributes", "));", "\u0120}", "\u0120return", "\u0120statements", ";", "\u0120}"], "docstring_tokens": ["Can", "\u0120this", "\u0120be", "\u0120changed", "\u0120to", "\u0120create", "Subject", "Role", "Attribute", "?"]}
{"function": "public LineRanges within(final LineRanges ranges) { final LineRanges result = new LineRanges(); final Iterator<LineRange> iterator = ranges.iterate(); while (iterator.hasNext()) { final LineRange next = iterator.next(); for (final LineRange line : this.lines.collection()) { if (next.within(line)) { result.add(line); } } } return result; }", "text": "@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?", "function_tokens": ["public", "\u0120Line", "R", "anges", "\u0120within", "(", "final", "\u0120Line", "R", "anges", "\u0120ranges", ")", "\u0120{", "\u0120final", "\u0120Line", "R", "anges", "\u0120result", "\u0120=", "\u0120new", "\u0120Line", "R", "anges", "();", "\u0120final", "\u0120Iter", "ator", "<", "Line", "Range", ">", "\u0120iterator", "\u0120=", "\u0120ranges", ".", "iter", "ate", "();", "\u0120while", "\u0120(", "iterator", ".", "has", "Next", "())", "\u0120{", "\u0120final", "\u0120Line", "Range", "\u0120next", "\u0120=", "\u0120iterator", ".", "next", "();", "\u0120for", "\u0120(", "final", "\u0120Line", "Range", "\u0120line", "\u0120:", "\u0120this", ".", "lines", ".", "collection", "())", "\u0120{", "\u0120if", "\u0120(", "next", ".", "within", "(", "line", "))", "\u0120{", "\u0120result", ".", "add", "(", "line", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120result", ";", "\u0120}"], "docstring_tokens": ["@", "Jim", "Dean", "Sp", "ive", "y", "\u0120can", "\u0120we", "\u0120go", "\u0120with", "\u0120a", "\u0120fore", "ach", "?", "\u0120for", "\u0120(", "final", "\u0120Line", "Range", "\u0120range", "\u0120:", "\u0120ranges", ")?"]}
{"function": "public GlusterServersListReturnForXmlRpc(Map<String, Object> innerMap) { super(innerMap); List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>(); Object[] serversArr = (Object[]) innerMap.get(GLUSTER_HOSTS); if (serversArr != null) { for (int i = 0; i < serversArr.length; i++) { glusterServers.add(prepareServerInfo((Map<String, Object>) serversArr[i])); } } setServer(glusterServers); }", "text": "Do not try to parse the sever list if the command has failed (mStatus.code != 0)", "function_tokens": ["public", "\u0120Gl", "uster", "Ser", "vers", "List", "Return", "For", "X", "ml", "R", "pc", "(", "Map", "<", "String", ",", "\u0120Object", ">", "\u0120inner", "Map", ")", "\u0120{", "\u0120super", "(", "inner", "Map", ");", "\u0120List", "<", "Gl", "uster", "Server", "Info", ">", "\u0120gl", "uster", "Ser", "vers", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Gl", "uster", "Server", "Info", ">", "();", "\u0120Object", "[]", "\u0120servers", "Ar", "r", "\u0120=", "\u0120(", "Object", "[", "])", "\u0120inner", "Map", ".", "get", "(", "GL", "UST", "ER", "_", "H", "OST", "S", ");", "\u0120if", "\u0120(", "ser", "vers", "Ar", "r", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120servers", "Ar", "r", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120gl", "uster", "Ser", "vers", ".", "add", "(", "prep", "are", "Server", "Info", "((", "Map", "<", "String", ",", "\u0120Object", ">)", "\u0120servers", "Ar", "r", "[", "i", "])", ");", "\u0120}", "\u0120}", "\u0120set", "Server", "(", "gl", "uster", "Ser", "vers", ");", "\u0120}"], "docstring_tokens": ["Do", "\u0120not", "\u0120try", "\u0120to", "\u0120parse", "\u0120the", "\u0120sever", "\u0120list", "\u0120if", "\u0120the", "\u0120command", "\u0120has", "\u0120failed", "\u0120(", "m", "Status", ".", "code", "\u0120!=", "\u01200", ")"]}
{"function": "private void buildTestedInstance() { ; this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }", "text": "Floating semicolon", "function_tokens": ["private", "\u0120void", "\u0120build", "T", "ested", "Instance", "()", "\u0120{", "\u0120;", "\u0120this", ".", "tested", "\u0120=", "\u0120new", "\u0120Client", "Full", "Session", "Impl", "(", "f", "actory", ",", "\u0120canvas", "Command", "Manager", ",", "\u0120session", "Command", "Manager", ",", "\u0120request", "Command", "Manager", ",", "\u0120registry", "Factory", ");", "\u0120}"], "docstring_tokens": ["Flo", "ating", "\u0120sem", "icol", "on"]}
{"function": "public void parentIsNotCalledIfAccountStatusExceptionIsThrown() { AuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(new AccountStatusException( \"\", new Throwable()) { }); AuthenticationManager parent = mock(AuthenticationManager.class); ProviderManager mgr = new ProviderManager( Collections.singletonList(iThrowAccountStatusException), parent); try { mgr.authenticate(mock(Authentication.class)); fail(\"Expected exception\"); } catch (AccountStatusException expected) { } verifyZeroInteractions(parent); }", "text": "Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.", "function_tokens": ["public", "\u0120void", "\u0120parent", "Is", "Not", "C", "alled", "If", "Account", "Status", "Exception", "Is", "Th", "rown", "()", "\u0120{", "\u0120Authentication", "Provider", "\u0120i", "Throw", "Account", "Status", "Exception", "\u0120=", "\u0120create", "Provider", "Which", "Th", "rows", "(", "new", "\u0120Account", "Status", "Exception", "(", "\u0120\"", "\",", "\u0120new", "\u0120Throw", "able", "())", "\u0120{", "\u0120});", "\u0120Authentication", "Manager", "\u0120parent", "\u0120=", "\u0120mock", "(", "Authent", "ication", "Manager", ".", "class", ");", "\u0120Provider", "Manager", "\u0120m", "gr", "\u0120=", "\u0120new", "\u0120Provider", "Manager", "(", "\u0120Collections", ".", "sing", "leton", "List", "(", "i", "Throw", "Account", "Status", "Exception", "),", "\u0120parent", ");", "\u0120try", "\u0120{", "\u0120m", "gr", ".", "authent", "icate", "(", "m", "ock", "(", "Authent", "ication", ".", "class", "));", "\u0120fail", "(\"", "Ex", "pected", "\u0120exception", "\");", "\u0120}", "\u0120catch", "\u0120(", "Account", "Status", "Exception", "\u0120expected", ")", "\u0120{", "\u0120}", "\u0120verify", "Zero", "Inter", "actions", "(", "parent", ");", "\u0120}"], "docstring_tokens": ["Thanks", "\u0120for", "\u0120these", "\u0120cleanup", "\u0120items", ",", "\u0120too", ".", "\u0120Will", "\u0120you", "\u0120please", "\u0120put", "\u0120them", "\u0120in", "\u0120a", "\u0120separate", "\u0120commit", "\u0120(", "same", "\u0120PR", ")?", "\u0120That", "\u0120is", ",", "\u0120any", "\u0120code", "\u0120changes", "\u0120that", "\u0120aren", "'t", "\u0120directly", "\u0120related", "\u0120to", "\u0120the", "\u0120new", "\u0120constructor", ",", "\u0120let", "'s", "\u0120separate", "\u0120them", "\u0120into", "\u0120their", "\u0120own", "\u0120commit", ".", "\u0120This", "\u0120simpl", "ifies", "\u0120maintenance", "."]}
{"function": "private void initScanner(Schema projected) throws IOException { this.projector = new Projector(inSchema, outSchema, plan.getTargets()); System.out.println(\"=======================>\" + plan.getTableDesc().getName()); for (FragmentProto f: fragments) { FileFragment ff = (FileFragment)FragmentConvertor.convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), f); System.out.println(\">>>>>>>>>>>>>>>>>>>\" + ff.getPath()); } if (fragments != null) { if (fragments.length > 1) { this.scanner = new MergeScanner(context.getConf(), plan.getPhysicalSchema(), plan.getTableDesc().getMeta(), FragmentConvertor.<FileFragment>convert(context.getConf(), plan.getTableDesc().getMeta().getStoreType(), fragments), projected ); } else { this.scanner = StorageManagerFactory.getStorageManager( context.getConf()).getScanner(plan.getTableDesc().getMeta(), plan.getPhysicalSchema(), fragments[0], projected); } scanner.init(); } }", "text": "Please remove debug codes.", "function_tokens": ["private", "\u0120void", "\u0120init", "Scan", "ner", "(", "Sche", "ma", "\u0120projected", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120this", ".", "project", "or", "\u0120=", "\u0120new", "\u0120Project", "or", "(", "in", "Sche", "ma", ",", "\u0120out", "Sche", "ma", ",", "\u0120plan", ".", "get", "T", "arg", "ets", "());", "\u0120System", ".", "out", ".", "println", "(\"", "================", "======", "=>", "\"", "\u0120+", "\u0120plan", ".", "get", "Table", "Desc", "().", "get", "Name", "());", "\u0120for", "\u0120(", "Frag", "ment", "Pro", "to", "\u0120f", ":", "\u0120fragments", ")", "\u0120{", "\u0120File", "Frag", "ment", "\u0120ff", "\u0120=", "\u0120(", "File", "Frag", "ment", ")", "Frag", "ment", "Con", "vert", "or", ".", "con", "vert", "(", "context", ".", "get", "Conf", "(),", "\u0120plan", ".", "get", "Table", "Desc", "().", "get", "Meta", "().", "get", "Store", "Type", "(),", "\u0120f", ");", "\u0120System", ".", "out", ".", "println", "(\"", ">>>>>>>>", ">>>>>>>>", ">>", ">\"", "\u0120+", "\u0120ff", ".", "get", "Path", "());", "\u0120}", "\u0120if", "\u0120(", "fr", "ag", "ments", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "fr", "ag", "ments", ".", "length", "\u0120>", "\u01201", ")", "\u0120{", "\u0120this", ".", "scan", "ner", "\u0120=", "\u0120new", "\u0120Merge", "Scan", "ner", "(", "context", ".", "get", "Conf", "(),", "\u0120plan", ".", "get", "Physical", "Sche", "ma", "(),", "\u0120plan", ".", "get", "Table", "Desc", "().", "get", "Meta", "(),", "\u0120Frag", "ment", "Con", "vert", "or", ".<", "File", "Frag", "ment", ">", "con", "vert", "(", "context", ".", "get", "Conf", "(),", "\u0120plan", ".", "get", "Table", "Desc", "().", "get", "Meta", "().", "get", "Store", "Type", "(),", "\u0120fragments", "),", "\u0120projected", "\u0120);", "\u0120}", "\u0120else", "\u0120{", "\u0120this", ".", "scan", "ner", "\u0120=", "\u0120Storage", "Manager", "Factory", ".", "get", "Storage", "Manager", "(", "\u0120context", ".", "get", "Conf", "()", ").", "get", "Scan", "ner", "(", "plan", ".", "get", "Table", "Desc", "().", "get", "Meta", "(),", "\u0120plan", ".", "get", "Physical", "Sche", "ma", "(),", "\u0120fragments", "[", "0", "],", "\u0120projected", ");", "\u0120}", "\u0120scanner", ".", "init", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120remove", "\u0120debug", "\u0120codes", "."]}
{"function": "public boolean put(ConflictTxStream conflictStream) { Long val = cacheConflictKeys.get(conflictStream); if (val != null && val >= conflictStream.txVersion) { log.error(\"For key {}, the value {} is not smaller than the expected value {} or maxWildCard\", conflictStream, cacheConflictKeys.get(conflictStream), conflictStream.txVersion, maxConflictWildcard); return false; } if (cacheConflictKeys.size() == cacheSize) { invalidateFirst(); } cacheEntries.add(conflictStream); cacheConflictKeys.put(conflictStream, conflictStream.txVersion); cacheEntriesBytes += conflictStream.size(); return true; }", "text": "please use long", "function_tokens": ["public", "\u0120boolean", "\u0120put", "(", "Conf", "lict", "Tx", "Stream", "\u0120conflict", "Stream", ")", "\u0120{", "\u0120Long", "\u0120val", "\u0120=", "\u0120cache", "Conf", "lict", "Keys", ".", "get", "(", "conf", "lict", "Stream", ");", "\u0120if", "\u0120(", "val", "\u0120!=", "\u0120null", "\u0120&&", "\u0120val", "\u0120>=", "\u0120conflict", "Stream", ".", "tx", "Version", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "For", "\u0120key", "\u0120{", "},", "\u0120the", "\u0120value", "\u0120{}", "\u0120is", "\u0120not", "\u0120smaller", "\u0120than", "\u0120the", "\u0120expected", "\u0120value", "\u0120{}", "\u0120or", "\u0120max", "Wild", "Card", "\",", "\u0120conflict", "Stream", ",", "\u0120cache", "Conf", "lict", "Keys", ".", "get", "(", "conf", "lict", "Stream", "),", "\u0120conflict", "Stream", ".", "tx", "Version", ",", "\u0120max", "Conf", "lict", "Wild", "card", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "cache", "Conf", "lict", "Keys", ".", "size", "()", "\u0120==", "\u0120cache", "Size", ")", "\u0120{", "\u0120invalid", "ate", "First", "();", "\u0120}", "\u0120cache", "Ent", "ries", ".", "add", "(", "conf", "lict", "Stream", ");", "\u0120cache", "Conf", "lict", "Keys", ".", "put", "(", "conf", "lict", "Stream", ",", "\u0120conflict", "Stream", ".", "tx", "Version", ");", "\u0120cache", "Ent", "ries", "Bytes", "\u0120+=", "\u0120conflict", "Stream", ".", "size", "();", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["please", "\u0120use", "\u0120long"]}
{"function": "public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(final Collection<BindingSet> bindingSets) throws QueryEvaluationException { return null; }", "text": "Is there a reason this isn't implemented?", "function_tokens": ["public", "\u0120Close", "able", "Iter", "ation", "<", "B", "inding", "Set", ",", "\u0120Query", "E", "val", "uation", "Exception", ">", "\u0120evaluate", "(", "final", "\u0120Collection", "<", "B", "inding", "Set", ">", "\u0120binding", "S", "ets", ")", "\u0120throws", "\u0120Query", "E", "val", "uation", "Exception", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Is", "\u0120there", "\u0120a", "\u0120reason", "\u0120this", "\u0120isn", "'t", "\u0120implemented", "?"]}
{"function": "public static <T> void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }", "text": "nit: unnecessary generic type declaration", "function_tokens": ["public", "\u0120static", "\u0120<", "T", ">", "\u0120void", "\u0120handle", "B", "ulk", "Write", "Error", "(", "List", "<", "B", "ulk", "Write", "Error", ">", "\u0120errors", ",", "String", "\u0120op", ",", "Get", "CB", "\u0120c", "b", ")", "\u0120{", "\u0120for", "\u0120(", "B", "ulk", "Write", "Error", "\u0120e", "\u0120:", "\u0120errors", ")", "\u0120{", "\u0120c", "b", ".", "get", "C", "tx", "(", "e", ".", "get", "Index", "()", ").", "add", "Error", "(", "get", "Error", "(", "e", ",", "op", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120unnecessary", "\u0120generic", "\u0120type", "\u0120declaration"]}
{"function": "public Integer getPartition() { String changelogPartition = getMessageValue(CHANGELOG_VALUE_KEY); return (changelogPartition != null) ? Integer.parseInt(changelogPartition) : null; }", "text": "Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition)", "function_tokens": ["public", "\u0120Integer", "\u0120get", "Part", "ition", "()", "\u0120{", "\u0120String", "\u0120chang", "el", "og", "Part", "ition", "\u0120=", "\u0120get", "Message", "Value", "(", "CH", "ANG", "EL", "OG", "_", "VALUE", "_", "KEY", ");", "\u0120return", "\u0120(", "ch", "angel", "og", "Part", "ition", "\u0120!=", "\u0120null", ")", "\u0120?", "\u0120Integer", ".", "parse", "Int", "(", "ch", "angel", "og", "Part", "ition", ")", "\u0120:", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Probably", "\u0120safer", "\u0120to", "\u0120replace", "\u0120the", "\u0120null", "\u0120check", "\u0120with", "\u0120String", "Ut", "ils", ".", "is", "Not", "Bl", "ank", "(", "ch", "angel", "og", "Part", "ition", ")"]}
{"function": "public void testInitAggregator() throws Exception { final List<BuiltinAggregator> aggregators = Arrays.asList(BuiltinAggregator.COUNT, BuiltinAggregator.MAX, BuiltinAggregator.MIN, BuiltinAggregator.SUM); testedView.initBuiltinAggregators(aggregators); aggregators.stream().forEach(agg -> verify(lstBuiltinAggregator).addOption(agg.value())); }", "text": "Out of interest why can you not do BuiltinAggregator.values()?", "function_tokens": ["public", "\u0120void", "\u0120test", "Init", "Agg", "reg", "ator", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120List", "<", "Built", "in", "Agg", "reg", "ator", ">", "\u0120aggreg", "ators", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(", "Built", "in", "Agg", "reg", "ator", ".", "C", "OUNT", ",", "\u0120Built", "in", "Agg", "reg", "ator", ".", "MAX", ",", "\u0120Built", "in", "Agg", "reg", "ator", ".", "MIN", ",", "\u0120Built", "in", "Agg", "reg", "ator", ".", "S", "UM", ");", "\u0120tested", "View", ".", "init", "Built", "in", "Agg", "reg", "ators", "(", "agg", "reg", "ators", ");", "\u0120aggreg", "ators", ".", "stream", "().", "for", "Each", "(", "agg", "\u0120->", "\u0120verify", "(", "l", "st", "Built", "in", "Agg", "reg", "ator", ").", "add", "Option", "(", "agg", ".", "value", "()", "));", "\u0120}"], "docstring_tokens": ["Out", "\u0120of", "\u0120interest", "\u0120why", "\u0120can", "\u0120you", "\u0120not", "\u0120do", "\u0120Built", "in", "Agg", "reg", "ator", ".", "values", "()", "?"]}
{"function": "private void doCopyRetry(FileSystem sourceFs, List<ReplChangeManager.FileInfo> srcFileList, FileSystem destinationFs, Path destination, boolean useRegularCopy) throws IOException, LoginException { int repeat = 0; boolean isCopyError; List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath); while (!pathList.isEmpty() && (repeat < MAX_COPY_RETRY)) { LOG.info(\"Attempt: \" + (repeat+1) + \". Copying files: \" + pathList); try { isCopyError = false; doCopyOnce(sourceFs, pathList, destinationFs, destination, useRegularCopy); } catch (IOException e) { if (!(e instanceof FileNotFoundException)) { LOG.info(\" File operation failed with error : \" + e.getMessage()); sourceFs = pathList.get(0).getFileSystem(hiveConf); destinationFs = destination.getFileSystem(hiveConf); } isCopyError = true; } pathList = getFilesToRetry(sourceFs, srcFileList, destinationFs, destination, isCopyError); repeat++; } if (!pathList.isEmpty()) { LOG.error(\"File copy failed even after several attempts. Files list: \" + srcFileList); throw new IOException(\"File copy failed even after several attempts.\"); } }", "text": "Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.", "function_tokens": ["private", "\u0120void", "\u0120do", "Copy", "Ret", "ry", "(", "File", "System", "\u0120source", "Fs", ",", "\u0120List", "<", "Repl", "Change", "Manager", ".", "File", "Info", ">", "\u0120src", "File", "List", ",", "\u0120File", "System", "\u0120destination", "Fs", ",", "\u0120Path", "\u0120destination", ",", "\u0120boolean", "\u0120use", "Regular", "Copy", ")", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Login", "Exception", "\u0120{", "\u0120int", "\u0120repeat", "\u0120=", "\u01200", ";", "\u0120boolean", "\u0120is", "Copy", "Error", ";", "\u0120List", "<", "Path", ">", "\u0120path", "List", "\u0120=", "\u0120Lists", ".", "transform", "(", "src", "File", "List", ",", "\u0120Repl", "Change", "Manager", ".", "File", "Info", "::", "get", "Effective", "Path", ");", "\u0120while", "\u0120(!", "path", "List", ".", "is", "Empty", "()", "\u0120&&", "\u0120(", "repeat", "\u0120<", "\u0120MAX", "_", "C", "OP", "Y", "_", "RE", "TRY", "))", "\u0120{", "\u0120LOG", ".", "info", "(\"", "Attempt", ":", "\u0120\"", "\u0120+", "\u0120(", "repeat", "+", "1", ")", "\u0120+", "\u0120\".", "\u0120Cop", "ying", "\u0120files", ":", "\u0120\"", "\u0120+", "\u0120path", "List", ");", "\u0120try", "\u0120{", "\u0120is", "Copy", "Error", "\u0120=", "\u0120false", ";", "\u0120do", "Copy", "Once", "(", "source", "Fs", ",", "\u0120path", "List", ",", "\u0120destination", "Fs", ",", "\u0120destination", ",", "\u0120use", "Regular", "Copy", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(!", "(", "e", "\u0120instance", "of", "\u0120File", "Not", "Found", "Exception", "))", "\u0120{", "\u0120LOG", ".", "info", "(\"", "\u0120File", "\u0120operation", "\u0120failed", "\u0120with", "\u0120error", "\u0120:", "\u0120\"", "\u0120+", "\u0120e", ".", "get", "Message", "());", "\u0120source", "Fs", "\u0120=", "\u0120path", "List", ".", "get", "(", "0", ").", "get", "File", "System", "(", "h", "ive", "Conf", ");", "\u0120destination", "Fs", "\u0120=", "\u0120destination", ".", "get", "File", "System", "(", "h", "ive", "Conf", ");", "\u0120}", "\u0120is", "Copy", "Error", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120path", "List", "\u0120=", "\u0120get", "Files", "To", "Ret", "ry", "(", "source", "Fs", ",", "\u0120src", "File", "List", ",", "\u0120destination", "Fs", ",", "\u0120destination", ",", "\u0120is", "Copy", "Error", ");", "\u0120repeat", "++;", "\u0120}", "\u0120if", "\u0120(!", "path", "List", ".", "is", "Empty", "())", "\u0120{", "\u0120LOG", ".", "error", "(\"", "File", "\u0120copy", "\u0120failed", "\u0120even", "\u0120after", "\u0120several", "\u0120attempts", ".", "\u0120Files", "\u0120list", ":", "\u0120\"", "\u0120+", "\u0120src", "File", "List", ");", "\u0120throw", "\u0120new", "\u0120IO", "Exception", "(\"", "File", "\u0120copy", "\u0120failed", "\u0120even", "\u0120after", "\u0120several", "\u0120attempts", ".\"", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Need", "\u0120to", "\u0120catch", "\u0120IO", "Exception", "\u0120from", "\u0120get", "Files", "To", "Ret", "ry", "\u0120as", "\u0120well", "\u0120as", "\u0120it", "\u0120may", "\u0120throw", "\u0120this", "\u0120exception", "\u0120for", "\u0120N", "N", "\u0120failures", "\u0120and", "\u0120need", "\u0120ret", "ry", "."]}
{"function": "public long forceNext() { long l = longs.incrementAndGet(INDEX_HEAD); if (((l >> 3) << 3) == l && concurrentInvocations() > 10) { concurrencyDetection.onDetected(); } return l; }", "text": "minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.", "function_tokens": ["public", "\u0120long", "\u0120force", "Next", "()", "\u0120{", "\u0120long", "\u0120l", "\u0120=", "\u0120long", "s", ".", "incre", "ment", "And", "Get", "(", "IND", "EX", "_", "HEAD", ");", "\u0120if", "\u0120((", "(", "l", "\u0120>>", "\u01203", ")", "\u0120<<", "\u01203", ")", "\u0120==", "\u0120l", "\u0120&&", "\u0120concurrent", "In", "voc", "ations", "()", "\u0120>", "\u012010", ")", "\u0120{", "\u0120conc", "urrency", "Det", "ection", ".", "on", "Det", "ected", "();", "\u0120}", "\u0120return", "\u0120l", ";", "\u0120}"], "docstring_tokens": ["min", "or", ":", "\u0120you", "\u0120can", "\u0120use", "\u0120Quick", "Math", ".", "mod", "Power", "Of", "Two", "(", "l", ",", "\u01208", ")", "\u0120==", "\u01200", "\u0120instead", "\u0120of", "\u0120((", "l", "\u0120>>", "\u01203", ")", "\u0120<<", "\u01203", ")", "\u0120==", "\u0120l", ",", "\u0120to", "\u0120make", "\u0120it", "\u0120more", "\u0120readable", ".", "\u0120I", "\u0120mis", "read", "\u0120this", "\u0120like", "\u0120((", "l", "\u0120>>", "\u01203", ")", "\u0120<<", "\u01203", ")", "\u0120==", "\u01201", "\u0120initially", "\u0120(", "so", "\u01201", "\u0120instead", "\u0120of", "\u0120small", "\u0120L", ")", "\u0120and", "\u0120didn", "'t", "\u0120get", "\u0120what", "\u0120it", "\u0120means", "."]}
{"function": "public boolean needsSequentialWriting() { return !vfsList.get(0).getCapabilities().contains(Capabilities.PARALLEL_WRITE); }", "text": "Why not use capabilities directly here?", "function_tokens": ["public", "\u0120boolean", "\u0120needs", "Sequ", "ential", "Writing", "()", "\u0120{", "\u0120return", "\u0120!", "v", "fs", "List", ".", "get", "(", "0", ").", "get", "Cap", "abilities", "().", "cont", "ains", "(", "Cap", "abilities", ".", "PAR", "AL", "LE", "L", "_", "WR", "ITE", ");", "\u0120}"], "docstring_tokens": ["Why", "\u0120not", "\u0120use", "\u0120capabilities", "\u0120directly", "\u0120here", "?"]}
{"function": "private static NewIssueLocation locationForIssue(InputFile inputFile, HtmlIssue issue, NewIssue newIssue) { NewIssueLocation location = newIssue.newLocation() .on(inputFile) .message(issue.message()); Integer line = issue.line(); if (issue.startColumn() != null) { location.at(inputFile.newRange(issue.line(), issue.startColumn(), issue.endLine(), issue.endColumn())); } else if (line != null) { location.at(inputFile.selectLine(line)); } return location; }", "text": "Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!", "function_tokens": ["private", "\u0120static", "\u0120New", "Issue", "Location", "\u0120location", "For", "Issue", "(", "Input", "File", "\u0120input", "File", ",", "\u0120H", "tml", "Issue", "\u0120issue", ",", "\u0120New", "Issue", "\u0120new", "Issue", ")", "\u0120{", "\u0120New", "Issue", "Location", "\u0120location", "\u0120=", "\u0120new", "Issue", ".", "new", "Location", "()", "\u0120.", "on", "(", "input", "File", ")", "\u0120.", "message", "(", "issue", ".", "message", "());", "\u0120Integer", "\u0120line", "\u0120=", "\u0120issue", ".", "line", "();", "\u0120if", "\u0120(", "issue", ".", "start", "Column", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120location", ".", "at", "(", "input", "File", ".", "new", "Range", "(", "issue", ".", "line", "(),", "\u0120issue", ".", "start", "Column", "(),", "\u0120issue", ".", "end", "Line", "(),", "\u0120issue", ".", "end", "Column", "()", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "line", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120location", ".", "at", "(", "input", "File", ".", "select", "Line", "(", "line", "));", "\u0120}", "\u0120return", "\u0120location", ";", "\u0120}"], "docstring_tokens": ["Do", "\u0120you", "\u0120assume", "\u0120that", "\u0120if", "\u0120start", "Column", "\u0120is", "\u0120not", "\u0120null", ",", "\u0120end", "Line", "\u0120and", "\u0120end", "Column", "\u0120will", "\u0120not", "\u0120be", "\u0120either", "?", "\u0120Or", "\u0120is", "\u0120it", "\u0120fine", "\u0120to", "\u0120have", "\u0120two", "\u0120last", "\u0120as", "\u0120null", "?", "\u0120If", "\u0120it", "'s", "\u0120the", "\u0120first", "\u0120case", "\u0120I", "\u0120think", "\u0120we", "\u0120should", "\u0120also", "\u0120check", "\u0120them", "!"]}
{"function": "public FbChain(final Iterable<Fallback> fallbacks) { super( new Fallback() { @Override public Opt<Response> route(final RqFallback req) throws IOException { Opt<Response> rsp = new Opt.Empty<Response>(); for (final Fallback fbk : fallbacks) { final Opt<Response> opt = fbk.route(req); if (opt.has()) { rsp = new Opt.Single<Response>(opt.get()); break; } } return rsp; } } ); }", "text": "@ekondrashev why not just rsp = opt?", "function_tokens": ["public", "\u0120F", "b", "Chain", "(", "final", "\u0120Iter", "able", "<", "Fall", "back", ">", "\u0120fall", "backs", ")", "\u0120{", "\u0120super", "(", "\u0120new", "\u0120Fall", "back", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Opt", "<", "Response", ">", "\u0120route", "(", "final", "\u0120R", "q", "Fall", "back", "\u0120req", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120Opt", "<", "Response", ">", "\u0120r", "sp", "\u0120=", "\u0120new", "\u0120Opt", ".", "Empty", "<", "Response", ">", "();", "\u0120for", "\u0120(", "final", "\u0120Fall", "back", "\u0120f", "b", "k", "\u0120:", "\u0120fall", "backs", ")", "\u0120{", "\u0120final", "\u0120Opt", "<", "Response", ">", "\u0120opt", "\u0120=", "\u0120f", "b", "k", ".", "route", "(", "req", ");", "\u0120if", "\u0120(", "opt", ".", "has", "())", "\u0120{", "\u0120r", "sp", "\u0120=", "\u0120new", "\u0120Opt", ".", "Single", "<", "Response", ">(", "opt", ".", "get", "());", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120return", "\u0120r", "sp", ";", "\u0120}", "\u0120}", "\u0120);", "\u0120}"], "docstring_tokens": ["@", "ek", "ond", "ras", "he", "v", "\u0120why", "\u0120not", "\u0120just", "\u0120r", "sp", "\u0120=", "\u0120opt", "?"]}
{"function": "protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); Boolean dbShouldBeUpdated = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }", "text": "Why use a java.lang.Boolean and not a primitive boolean?", "function_tokens": ["protected", "\u0120void", "\u0120execute", "Command", "()", "\u0120{", "\u0120final", "\u0120List", "<", "L", "UN", "s", ">", "\u0120l", "uns", "From", "V", "g", "Info", "\u0120=", "\u0120(", "List", "<", "L", "UN", "s", ">)", "\u0120run", "V", "ds", "Command", "(", "V", "DS", "Command", "Type", ".", "Get", "VG", "Info", ",", "\u0120new", "\u0120Get", "VG", "Info", "V", "DS", "Command", "Parameters", "(", "get", "V", "ds", "().", "get", "Id", "(),", "\u0120get", "Storage", "Domain", "().", "get", "Storage", "())", ").", "get", "Return", "Value", "();", "\u0120final", "\u0120List", "<", "L", "UN", "s", ">", "\u0120l", "uns", "From", "Db", "\u0120=", "\u0120get", "L", "un", "D", "ao", "().", "get", "All", "For", "Volume", "Group", "(", "get", "Storage", "Domain", "().", "get", "Storage", "());", "\u0120Map", "<", "Consumer", "<", "List", "<", "L", "UN", "s", ">>", ",", "\u0120List", "<", "L", "UN", "s", ">>", "\u0120l", "uns", "To", "Update", "In", "Db", "\u0120=", "\u0120get", "L", "uns", "To", "Update", "In", "Db", "(", "l", "uns", "From", "V", "g", "Info", ",", "\u0120l", "uns", "From", "Db", ");", "\u0120Boolean", "\u0120db", "Should", "Be", "Updated", "\u0120=", "\u0120l", "uns", "To", "Update", "In", "Db", ".", "cont", "ains", "Key", "(", "update", "Ex", "isting", "L", "uns", ")", "\u0120||", "\u0120l", "uns", "To", "Update", "In", "Db", ".", "cont", "ains", "Key", "(", "save", "New", "L", "uns", ");", "\u0120if", "\u0120(", "db", "Should", "Be", "Updated", ")", "\u0120{", "\u0120Transaction", "Support", ".", "execute", "In", "New", "Transaction", "(", "()", "\u0120->", "\u0120{", "\u0120update", "L", "uns", "In", "Db", "(", "l", "uns", "To", "Update", "In", "Db", ");", "\u0120refresh", "L", "uns", "Connect", "ions", "(", "l", "uns", "From", "V", "g", "Info", ");", "\u0120cleanup", "L", "uns", "From", "Db", "(", "l", "uns", "From", "V", "g", "Info", ",", "\u0120l", "uns", "From", "Db", ");", "\u0120return", "\u0120null", ";", "\u0120});", "\u0120}", "\u0120set", "S", "uc", "ceed", "ed", "(", "true", ");", "\u0120}"], "docstring_tokens": ["Why", "\u0120use", "\u0120a", "\u0120java", ".", "lang", ".", "Boo", "lean", "\u0120and", "\u0120not", "\u0120a", "\u0120primitive", "\u0120boolean", "?"]}
{"function": "public void modifyAST(IIndex index, IMarker marker) { IASTTranslationUnit ast; try { ITranslationUnit tu = getTranslationUnitViaEditor(marker); ast = tu.getAST(index, ITranslationUnit.AST_SKIP_INDEXED_HEADERS); } catch (CoreException e) { CheckersUiActivator.log(e); return; } IASTNode astNode = null; if (isCodanProblem(marker)) { astNode = getASTNodeFromMarker(marker, ast); } if (astNode == null || !(astNode instanceof IASTCastExpression)) { return; } ASTRewrite r = ASTRewrite.create(ast); INodeFactory factory = ast.getASTNodeFactory(); IASTCastExpression oldcast = (IASTCastExpression) astNode; IASTCastExpression newcast = factory.newCastExpression(getCastType(), oldcast.getTypeId().copy(CopyStyle.withLocations), oldcast.getOperand().copy(CopyStyle.withLocations)); r.replace(oldcast, newcast, null); Change c = r.rewriteAST(); try { c.perform(new NullProgressMonitor()); } catch (CoreException e) { CheckersUiActivator.log(e); return; } try { marker.delete(); } catch (CoreException e) { CheckersUiActivator.log(e); } }", "text": "merge the try/catch with the one below?", "function_tokens": ["public", "\u0120void", "\u0120modify", "AST", "(", "II", "nd", "ex", "\u0120index", ",", "\u0120IM", "ark", "er", "\u0120marker", ")", "\u0120{", "\u0120I", "AST", "Translation", "Unit", "\u0120ast", ";", "\u0120try", "\u0120{", "\u0120I", "Translation", "Unit", "\u0120tu", "\u0120=", "\u0120get", "Translation", "Unit", "Via", "Editor", "(", "mark", "er", ");", "\u0120ast", "\u0120=", "\u0120tu", ".", "get", "AST", "(", "index", ",", "\u0120I", "Translation", "Unit", ".", "AST", "_", "SK", "IP", "_", "IND", "EX", "ED", "_", "HEAD", "ERS", ");", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120Check", "ers", "U", "i", "Activ", "ator", ".", "log", "(", "e", ");", "\u0120return", ";", "\u0120}", "\u0120I", "AST", "Node", "\u0120ast", "Node", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "is", "Cod", "an", "Problem", "(", "mark", "er", "))", "\u0120{", "\u0120ast", "Node", "\u0120=", "\u0120get", "AST", "Node", "From", "Mark", "er", "(", "mark", "er", ",", "\u0120ast", ");", "\u0120}", "\u0120if", "\u0120(", "ast", "Node", "\u0120==", "\u0120null", "\u0120||", "\u0120!", "(", "ast", "Node", "\u0120instance", "of", "\u0120I", "AS", "TC", "ast", "Exp", "ression", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120A", "STR", "ew", "rite", "\u0120r", "\u0120=", "\u0120A", "STR", "ew", "rite", ".", "create", "(", "ast", ");", "\u0120IN", "ode", "Factory", "\u0120factory", "\u0120=", "\u0120ast", ".", "get", "AST", "Node", "Factory", "();", "\u0120I", "AS", "TC", "ast", "Exp", "ression", "\u0120old", "cast", "\u0120=", "\u0120(", "IAS", "TC", "ast", "Exp", "ression", ")", "\u0120ast", "Node", ";", "\u0120I", "AS", "TC", "ast", "Exp", "ression", "\u0120new", "cast", "\u0120=", "\u0120factory", ".", "new", "Cast", "Exp", "ression", "(", "get", "Cast", "Type", "(),", "\u0120old", "cast", ".", "get", "Type", "Id", "().", "copy", "(", "Copy", "Style", ".", "with", "L", "ocations", "),", "\u0120old", "cast", ".", "get", "Oper", "and", "().", "copy", "(", "Copy", "Style", ".", "with", "L", "ocations", "));", "\u0120r", ".", "replace", "(", "old", "cast", ",", "\u0120new", "cast", ",", "\u0120null", ");", "\u0120Change", "\u0120c", "\u0120=", "\u0120r", ".", "rew", "rite", "AST", "();", "\u0120try", "\u0120{", "\u0120c", ".", "per", "form", "(", "new", "\u0120Null", "Progress", "Monitor", "());", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120Check", "ers", "U", "i", "Activ", "ator", ".", "log", "(", "e", ");", "\u0120return", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120marker", ".", "delete", "();", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120Check", "ers", "U", "i", "Activ", "ator", ".", "log", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["mer", "ge", "\u0120the", "\u0120try", "/", "catch", "\u0120with", "\u0120the", "\u0120one", "\u0120below", "?"]}
{"function": "synchronized public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) { List<String> newSegments = new ArrayList<>(); for (String onlineSegment : onlineSegments) { if (!_segmentToTimeRangeMSCache.containsKey(onlineSegment)) { newSegments.add(onlineSegment); } } List<String> newSegmentZKMetadataPaths = new ArrayList<>(); for (String segment: newSegments) { newSegmentZKMetadataPaths.add(_segmentZKMetadataPathPrefix + segment); } List<ZNRecord> znRecords = _propertyStore.get(newSegmentZKMetadataPaths, null, AccessOption.PERSISTENT, true); for (int i = 0; i < newSegments.size(); i++) { String segment = newSegments.get(i); Interval range = extractTimeRangeMSFromSegmentZKMetaZNRecord(segment, znRecords.get(i)); _segmentToTimeRangeMSCache.put(segment, range); } _segmentToTimeRangeMSCache.keySet().retainAll(onlineSegments); _timeRangeMSToSegmentSearchTree = new IntervalST<String>(_segmentToTimeRangeMSCache); }", "text": "@snleee This is handled with the API refreshSegment()", "function_tokens": ["syn", "chron", "ized", "\u0120public", "\u0120void", "\u0120on", "External", "View", "Change", "(", "External", "View", "\u0120external", "View", ",", "\u0120Ideal", "State", "\u0120ideal", "State", ",", "\u0120Set", "<", "String", ">", "\u0120online", "Seg", "ments", ")", "\u0120{", "\u0120List", "<", "String", ">", "\u0120new", "Seg", "ments", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "\u0120(", "String", "\u0120online", "Seg", "ment", "\u0120:", "\u0120online", "Seg", "ments", ")", "\u0120{", "\u0120if", "\u0120(!", "_", "se", "gment", "To", "Time", "Range", "MS", "Cache", ".", "cont", "ains", "Key", "(", "online", "Seg", "ment", "))", "\u0120{", "\u0120new", "Seg", "ments", ".", "add", "(", "online", "Seg", "ment", ");", "\u0120}", "\u0120}", "\u0120List", "<", "String", ">", "\u0120new", "Seg", "ment", "Z", "K", "Met", "adata", "Path", "s", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "\u0120(", "String", "\u0120segment", ":", "\u0120new", "Seg", "ments", ")", "\u0120{", "\u0120new", "Seg", "ment", "Z", "K", "Met", "adata", "Path", "s", ".", "add", "(_", "se", "gment", "Z", "K", "Met", "adata", "Path", "Pref", "ix", "\u0120+", "\u0120segment", ");", "\u0120}", "\u0120List", "<", "Z", "N", "Record", ">", "\u0120z", "n", "Rec", "ords", "\u0120=", "\u0120_", "property", "Store", ".", "get", "(", "new", "Seg", "ment", "Z", "K", "Met", "adata", "Path", "s", ",", "\u0120null", ",", "\u0120Access", "Option", ".", "P", "ERS", "IST", "ENT", ",", "\u0120true", ");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120new", "Seg", "ments", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120segment", "\u0120=", "\u0120new", "Seg", "ments", ".", "get", "(", "i", ");", "\u0120Inter", "val", "\u0120range", "\u0120=", "\u0120extract", "Time", "Range", "MS", "From", "Seg", "ment", "Z", "K", "Meta", "Z", "N", "Record", "(", "se", "gment", ",", "\u0120z", "n", "Rec", "ords", ".", "get", "(", "i", "));", "\u0120_", "se", "gment", "To", "Time", "Range", "MS", "Cache", ".", "put", "(", "se", "gment", ",", "\u0120range", ");", "\u0120}", "\u0120_", "se", "gment", "To", "Time", "Range", "MS", "Cache", ".", "key", "Set", "().", "ret", "ain", "All", "(", "online", "Seg", "ments", ");", "\u0120_", "time", "Range", "M", "ST", "oS", "eg", "ment", "Search", "Tree", "\u0120=", "\u0120new", "\u0120Inter", "val", "ST", "<", "String", ">", "(_", "se", "gment", "To", "Time", "Range", "MS", "Cache", ");", "\u0120}"], "docstring_tokens": ["@", "sn", "le", "ee", "\u0120This", "\u0120is", "\u0120handled", "\u0120with", "\u0120the", "\u0120API", "\u0120refresh", "Seg", "ment", "()"]}
{"function": "private TracingContext traceToMap(Map<String, Object> map) { long startParse = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - startParse; long startOffset = now - startRequestNanos; map.put(\"startOffset\", startOffset); map.put(\"duration\", duration); }; }", "text": "Probably just wants to be start or startPhase or something if now generic.", "function_tokens": ["private", "\u0120Tr", "acing", "Context", "\u0120trace", "To", "Map", "(", "Map", "<", "String", ",", "\u0120Object", ">", "\u0120map", ")", "\u0120{", "\u0120long", "\u0120start", "Par", "se", "\u0120=", "\u0120System", ".", "n", "ano", "Time", "();", "\u0120return", "\u0120()", "\u0120->", "\u0120{", "\u0120long", "\u0120now", "\u0120=", "\u0120System", ".", "n", "ano", "Time", "();", "\u0120long", "\u0120duration", "\u0120=", "\u0120now", "\u0120-", "\u0120start", "Par", "se", ";", "\u0120long", "\u0120start", "Offset", "\u0120=", "\u0120now", "\u0120-", "\u0120start", "Request", "N", "anos", ";", "\u0120map", ".", "put", "(\"", "start", "Offset", "\",", "\u0120start", "Offset", ");", "\u0120map", ".", "put", "(\"", "duration", "\",", "\u0120duration", ");", "\u0120};", "\u0120}"], "docstring_tokens": ["Probably", "\u0120just", "\u0120wants", "\u0120to", "\u0120be", "\u0120start", "\u0120or", "\u0120start", "Phase", "\u0120or", "\u0120something", "\u0120if", "\u0120now", "\u0120generic", "."]}
{"function": "public void testIllegalMinMax() { try { new FixedDoubleHistogram(-200, 3.0, 3.0); fail(\"exception expected\"); } catch (IllegalArgumentException e) { assertTrue(e.getMessage().contains(\"bucketCount\")); } }", "text": "nit: any chance to make the message assertion more specific? :)", "function_tokens": ["public", "\u0120void", "\u0120test", "Il", "legal", "Min", "Max", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120new", "\u0120Fixed", "Double", "Hist", "ogram", "(-", "200", ",", "\u01203", ".", "0", ",", "\u01203", ".", "0", ");", "\u0120fail", "(\"", "ex", "ception", "\u0120expected", "\");", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "Arg", "ument", "Exception", "\u0120e", ")", "\u0120{", "\u0120assert", "True", "(", "e", ".", "get", "Message", "().", "cont", "ains", "(\"", "buck", "et", "Count", "\")", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120any", "\u0120chance", "\u0120to", "\u0120make", "\u0120the", "\u0120message", "\u0120assertion", "\u0120more", "\u0120specific", "?", "\u0120:)"]}
{"function": "public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(baseDir, false); return p4.latestChange(); }", "text": "We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }", "function_tokens": ["public", "\u0120List", "<", "Mod", "ification", ">", "\u0120latest", "Mod", "ification", "(", "File", "\u0120base", "Dir", ",", "\u0120final", "\u0120Sub", "process", "Exec", "ution", "Context", "\u0120exec", "C", "tx", ")", "\u0120{", "\u0120P", "4", "Client", "\u0120p", "4", "\u0120=", "\u0120get", "P", "4", "(", "base", "Dir", ",", "\u0120false", ");", "\u0120return", "\u0120p", "4", ".", "latest", "Change", "();", "\u0120}"], "docstring_tokens": ["We", "\u0120can", "\u0120do", "\u0120the", "\u0120same", "\u0120thing", "\u0120here", "\u0120too", "\u0120right", "?", "\u0120", "\u0120public", "\u0120List", "<", "Mod", "ification", ">", "\u0120latest", "Mod", "ification", "(", "File", "\u0120base", "Dir", ",", "\u0120final", "\u0120Sub", "process", "Exec", "ution", "Context", "\u0120exec", "C", "tx", ")", "\u0120{", "\u0120P", "4", "Client", "\u0120p", "4", "\u0120=", "\u0120get", "P", "4", "(", "exec", "C", "tx", ".", "is", "Server", "()", "\u0120?", "\u0120base", "Dir", ":", "\u0120working", "dir", "(", "base", "Dir", "));", "\u0120return", "\u0120p", "4", ".", "latest", "Change", "();", "\u0120}"]}
{"function": "public void putJobCompletedNotification() throws IOException, SignatureException { UUID notificationUUID = null; try { final PutJobCompletedNotificationRegistrationSpectraS3Response response = client .putJobCompletedNotificationRegistrationSpectraS3( new PutJobCompletedNotificationRegistrationSpectraS3Request(\"test@test.test\")); notificationUUID = response.getJobCompletedNotificationRegistrationResult().getId(); assertThat(response.getStatusCode(), is(201)); } finally { client.deleteJobCompletedNotificationRegistrationSpectraS3( new DeleteJobCompletedNotificationRegistrationSpectraS3Request(notificationUUID)); } }", "text": "check to make sure notificationUUID is not null", "function_tokens": ["public", "\u0120void", "\u0120put", "Job", "Completed", "Not", "ification", "()", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Signature", "Exception", "\u0120{", "\u0120U", "UID", "\u0120notification", "U", "UID", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120final", "\u0120Put", "Job", "Completed", "Not", "ification", "Registration", "Spect", "ra", "S", "3", "Response", "\u0120response", "\u0120=", "\u0120client", "\u0120.", "put", "Job", "Completed", "Not", "ification", "Registration", "Spect", "ra", "S", "3", "(", "\u0120new", "\u0120Put", "Job", "Completed", "Not", "ification", "Registration", "Spect", "ra", "S", "3", "Request", "(\"", "test", "@", "test", ".", "test", "\")", ");", "\u0120notification", "U", "UID", "\u0120=", "\u0120response", ".", "get", "Job", "Completed", "Not", "ification", "Registration", "Result", "().", "get", "Id", "();", "\u0120assert", "That", "(", "response", ".", "get", "Status", "Code", "(),", "\u0120is", "(", "201", "));", "\u0120}", "\u0120finally", "\u0120{", "\u0120client", ".", "delete", "Job", "Completed", "Not", "ification", "Registration", "Spect", "ra", "S", "3", "(", "\u0120new", "\u0120Delete", "Job", "Completed", "Not", "ification", "Registration", "Spect", "ra", "S", "3", "Request", "(", "not", "ification", "U", "UID", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["check", "\u0120to", "\u0120make", "\u0120sure", "\u0120notification", "U", "UID", "\u0120is", "\u0120not", "\u0120null"]}
{"function": "public static Pair<Boolean, String> checkFingerPrint(String expected, PublicKey key) throws Exception { if (key == null) { return null; } if (expected == null) { return new Pair<>(false, getFingerPrint(key)); } String comps[] = expected.split(\":\", 2); DigestFactory factory; if (comps[0].length() > 2) { factory = BuiltinDigests.fromString(comps[0]); if (factory == null) { return new Pair<>(false, getFingerPrint(key)); } } else { factory = BuiltinDigests.md5; expected = \"MD5:\" + expected; } String fingerprint = getFingerPrint(factory, key); return new Pair<>(expected.equals(fingerprint), fingerprint); }", "text": "java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }", "function_tokens": ["public", "\u0120static", "\u0120Pair", "<", "Boo", "lean", ",", "\u0120String", ">", "\u0120check", "F", "inger", "Print", "(", "String", "\u0120expected", ",", "\u0120Public", "Key", "\u0120key", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120if", "\u0120(", "key", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120if", "\u0120(", "expected", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120new", "\u0120Pair", "<", ">(", "false", ",", "\u0120get", "F", "inger", "Print", "(", "key", "));", "\u0120}", "\u0120String", "\u0120comp", "s", "[]", "\u0120=", "\u0120expected", ".", "split", "(", "\":", "\",", "\u01202", ");", "\u0120Digest", "Factory", "\u0120factory", ";", "\u0120if", "\u0120(", "com", "ps", "[", "0", "].", "length", "()", "\u0120>", "\u01202", ")", "\u0120{", "\u0120factory", "\u0120=", "\u0120Built", "in", "Dig", "ests", ".", "from", "String", "(", "com", "ps", "[", "0", "]);", "\u0120if", "\u0120(", "f", "actory", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120new", "\u0120Pair", "<", ">(", "false", ",", "\u0120get", "F", "inger", "Print", "(", "key", "));", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120factory", "\u0120=", "\u0120Built", "in", "Dig", "ests", ".", "md", "5", ";", "\u0120expected", "\u0120=", "\u0120\"", "MD", "5", ":\"", "\u0120+", "\u0120expected", ";", "\u0120}", "\u0120String", "\u0120fingerprint", "\u0120=", "\u0120get", "F", "inger", "Print", "(", "f", "actory", ",", "\u0120key", ");", "\u0120return", "\u0120new", "\u0120Pair", "<", ">(", "expected", ".", "equ", "als", "(", "finger", "print", "),", "\u0120fingerprint", ");", "\u0120}"], "docstring_tokens": ["java", "\u0120if", "\u0120(", "Generic", "Ut", "ils", ".", "is", "Empty", "(", "expected", "))", "\u0120{", "\u0120return", "\u0120new", "\u0120Pair", "<", ">(", "false", ",", "\u0120get", "F", "inger", "Print", "(", "key", "));", "\u0120}"]}
{"function": "private boolean isValidationNecessaryOnReads(TableReference tableRef) { return isValidationNecessary(tableRef) && validateLocksOnReads; }", "text": "probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.", "function_tokens": ["private", "\u0120boolean", "\u0120is", "Val", "idation", "N", "ec", "ess", "ary", "On", "Read", "s", "(", "Table", "Reference", "\u0120table", "Ref", ")", "\u0120{", "\u0120return", "\u0120is", "Val", "idation", "N", "ec", "ess", "ary", "(", "table", "Ref", ")", "\u0120&&", "\u0120validate", "L", "ocks", "On", "Read", "s", ";", "\u0120}"], "docstring_tokens": ["probably", "\u0120premature", ",", "\u0120but", "\u0120if", "\u0120in", "\u0120most", "\u0120usage", "\u0120validate", "L", "ocks", "On", "Read", "s", "\u0120is", "\u0120going", "\u0120to", "\u0120be", "\u0120false", ",", "\u0120then", "\u0120flipping", "\u0120the", "\u0120arguments", "\u0120makes", "\u0120sense", "."]}
{"function": "public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }", "text": "We don't need super here", "function_tokens": ["public", "\u0120Trader", "(", "String", "\u0120name", ",", "\u0120double", "\u0120cash", "In", "Hand", ")", "\u0120{", "\u0120super", "();", "\u0120this", ".", "name", "\u0120=", "\u0120name", ";", "\u0120this", ".", "cash", "In", "Hand", "\u0120=", "\u0120cash", "In", "Hand", ";", "\u0120this", ".", "stocks", "Own", "ed", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Order", ">", "();", "\u0120this", ".", "orders", "Pl", "aced", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Order", ">", "();", "\u0120}"], "docstring_tokens": ["We", "\u0120don", "'t", "\u0120need", "\u0120super", "\u0120here"]}
{"function": "public boolean isEnabled() { GitHistoryPage page = getPage(); if (page == null) return false; String head; try { head = page.getInputInternal().getRepository().getFullBranch(); } catch (IOException e) { head = null; } IStructuredSelection sel = getSelection(page); if (sel.size() != 1) return false; Object o = sel.getFirstElement(); if (!(o instanceof PlotCommit)) return false; PlotCommit commit = (PlotCommit) o; int refCount = commit.getRefCount(); for (int i = 0; i < refCount; i++) { String refName = commit.getRef(i).getName(); if (refName.equals(head)) continue; if (refName.startsWith(Constants.R_HEADS) || refName.startsWith(Constants.R_REMOTES)) return true; } return false; }", "text": "Does it make sense to continue here? Or just return false.", "function_tokens": ["public", "\u0120boolean", "\u0120isEnabled", "()", "\u0120{", "\u0120Git", "History", "Page", "\u0120page", "\u0120=", "\u0120get", "Page", "();", "\u0120if", "\u0120(", "page", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120false", ";", "\u0120String", "\u0120head", ";", "\u0120try", "\u0120{", "\u0120head", "\u0120=", "\u0120page", ".", "get", "Input", "Internal", "().", "get", "Rep", "ository", "().", "get", "Full", "B", "ranch", "();", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120head", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120I", "Struct", "ured", "Se", "lection", "\u0120se", "l", "\u0120=", "\u0120get", "Se", "lection", "(", "page", ");", "\u0120if", "\u0120(", "sel", ".", "size", "()", "\u0120!=", "\u01201", ")", "\u0120return", "\u0120false", ";", "\u0120Object", "\u0120o", "\u0120=", "\u0120se", "l", ".", "get", "First", "Element", "();", "\u0120if", "\u0120(!", "(", "o", "\u0120instance", "of", "\u0120Plot", "Comm", "it", "))", "\u0120return", "\u0120false", ";", "\u0120Plot", "Comm", "it", "\u0120commit", "\u0120=", "\u0120(", "Plot", "Comm", "it", ")", "\u0120o", ";", "\u0120int", "\u0120ref", "Count", "\u0120=", "\u0120commit", ".", "get", "Ref", "Count", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120ref", "Count", ";", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120ref", "Name", "\u0120=", "\u0120commit", ".", "get", "Ref", "(", "i", ").", "get", "Name", "();", "\u0120if", "\u0120(", "ref", "Name", ".", "equ", "als", "(", "head", "))", "\u0120continue", ";", "\u0120if", "\u0120(", "ref", "Name", ".", "st", "arts", "With", "(", "Const", "ants", ".", "R", "_", "HEAD", "S", ")", "\u0120||", "\u0120ref", "Name", ".", "st", "arts", "With", "(", "Const", "ants", ".", "R", "_", "REM", "OT", "ES", "))", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Does", "\u0120it", "\u0120make", "\u0120sense", "\u0120to", "\u0120continue", "\u0120here", "?", "\u0120Or", "\u0120just", "\u0120return", "\u0120false", "."]}
{"function": "public void testStartProcessFromNodeIdsWithTimer() throws Exception { final String processId = \"simple.restartWithTimer\"; assertNotNull(deploymentService); KModuleDeploymentUnit deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION); deploymentService.deploy(deploymentUnit); units.add(deploymentUnit); assertNotNull(processService); Long processInstanceId = processService.startProcess(deploymentUnit.getIdentifier(), processId, singletonMap(\"var_a\", 3)); assertNotNull(processInstanceId); Thread.sleep(3000); processService.abortProcessInstance(processInstanceId); Collection<NodeInstanceDesc> timed = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.SKIPPED, new QueryContext(0, 0)); assertThat(timed.size(), is(1)); Collection<NodeInstanceDesc> aborted = runtimeDataService.getProcessInstanceFullHistoryByType(processInstanceId, EntryType.ABORTED, new QueryContext(0, 0)); assertThat(aborted.size(), is(1)); String[] nodeIds = aborted.stream().map(e -> e.getNodeId()).toArray(String[]::new); processInstanceId = processService.startProcessFromNodeIds(deploymentUnit.getIdentifier(), processId, singletonMap(\"var_a\", 3), nodeIds); runtimeDataService.getTasksByProcessInstanceId(processInstanceId).forEach(e -> { Task task = this.userTaskService.getTask(e); assertThat(task.getName(), is(\"Third Task\")); this.userTaskService.start(e, \"katy\"); this.userTaskService.complete(e, \"katy\", emptyMap()); }); ProcessInstance pi = processService.getProcessInstance(processInstanceId); assertNull(pi); }", "text": "Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {", "function_tokens": ["public", "\u0120void", "\u0120test", "Start", "Process", "From", "Node", "Id", "s", "With", "Timer", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120String", "\u0120process", "Id", "\u0120=", "\u0120\"", "simple", ".", "rest", "art", "With", "Timer", "\";", "\u0120assert", "Not", "Null", "(", "de", "ploy", "ment", "Service", ");", "\u0120K", "Module", "Deploy", "ment", "Unit", "\u0120deployment", "Unit", "\u0120=", "\u0120new", "\u0120K", "Module", "Deploy", "ment", "Unit", "(", "GROUP", "_", "ID", ",", "\u0120ART", "IF", "ACT", "_", "ID", ",", "\u0120VERS", "ION", ");", "\u0120deployment", "Service", ".", "de", "ploy", "(", "de", "ploy", "ment", "Unit", ");", "\u0120units", ".", "add", "(", "de", "ploy", "ment", "Unit", ");", "\u0120assert", "Not", "Null", "(", "process", "Service", ");", "\u0120Long", "\u0120process", "Instance", "Id", "\u0120=", "\u0120process", "Service", ".", "start", "Process", "(", "de", "ploy", "ment", "Unit", ".", "get", "Ident", "ifier", "(),", "\u0120process", "Id", ",", "\u0120single", "ton", "Map", "(\"", "var", "_", "a", "\",", "\u01203", "));", "\u0120assert", "Not", "Null", "(", "process", "Instance", "Id", ");", "\u0120Thread", ".", "sleep", "(", "3000", ");", "\u0120process", "Service", ".", "ab", "ort", "Process", "Instance", "(", "process", "Instance", "Id", ");", "\u0120Collection", "<", "Node", "Instance", "Desc", ">", "\u0120timed", "\u0120=", "\u0120runtime", "Data", "Service", ".", "get", "Process", "Instance", "Full", "History", "By", "Type", "(", "process", "Instance", "Id", ",", "\u0120Entry", "Type", ".", "SK", "IPP", "ED", ",", "\u0120new", "\u0120Query", "Context", "(", "0", ",", "\u01200", "));", "\u0120assert", "That", "(", "tim", "ed", ".", "size", "(),", "\u0120is", "(", "1", "));", "\u0120Collection", "<", "Node", "Instance", "Desc", ">", "\u0120aborted", "\u0120=", "\u0120runtime", "Data", "Service", ".", "get", "Process", "Instance", "Full", "History", "By", "Type", "(", "process", "Instance", "Id", ",", "\u0120Entry", "Type", ".", "AB", "ORT", "ED", ",", "\u0120new", "\u0120Query", "Context", "(", "0", ",", "\u01200", "));", "\u0120assert", "That", "(", "ab", "orted", ".", "size", "(),", "\u0120is", "(", "1", "));", "\u0120String", "[]", "\u0120node", "Id", "s", "\u0120=", "\u0120aborted", ".", "stream", "().", "map", "(", "e", "\u0120->", "\u0120e", ".", "get", "Node", "Id", "()", ").", "to", "Array", "(", "String", "[]", "::", "new", ");", "\u0120process", "Instance", "Id", "\u0120=", "\u0120process", "Service", ".", "start", "Process", "From", "Node", "Id", "s", "(", "de", "ploy", "ment", "Unit", ".", "get", "Ident", "ifier", "(),", "\u0120process", "Id", ",", "\u0120single", "ton", "Map", "(\"", "var", "_", "a", "\",", "\u01203", "),", "\u0120node", "Id", "s", ");", "\u0120runtime", "Data", "Service", ".", "get", "T", "asks", "By", "Process", "Instance", "Id", "(", "process", "Instance", "Id", ").", "for", "Each", "(", "e", "\u0120->", "\u0120{", "\u0120Task", "\u0120task", "\u0120=", "\u0120this", ".", "user", "Task", "Service", ".", "get", "Task", "(", "e", ");", "\u0120assert", "That", "(", "task", ".", "get", "Name", "(),", "\u0120is", "(\"", "Third", "\u0120Task", "\")", ");", "\u0120this", ".", "user", "Task", "Service", ".", "start", "(", "e", ",", "\u0120\"", "kat", "y", "\");", "\u0120this", ".", "user", "Task", "Service", ".", "complete", "(", "e", ",", "\u0120\"", "kat", "y", "\",", "\u0120empty", "Map", "());", "\u0120});", "\u0120Process", "Instance", "\u0120pi", "\u0120=", "\u0120process", "Service", ".", "get", "Process", "Instance", "(", "process", "Instance", "Id", ");", "\u0120assert", "Null", "(", "pi", ");", "\u0120}"], "docstring_tokens": ["Exception", "\u0120is", "\u0120never", "\u0120thrown", "\u0120within", "\u0120this", "\u0120method", ".", "\u0120suggestion", "\u0120public", "\u0120void", "\u0120test", "Start", "Process", "From", "Node", "Id", "s", "With", "Timer", "()", "\u0120{"]}
{"function": "protected boolean isAnyAppConfiguredInSourceServerXml() { boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(\"Application configuration is found in server.xml.\"); bConfigured = true; } return bConfigured; }", "text": "Here I would just say return true. Then fall through return false, instead of creating a variable.", "function_tokens": ["protected", "\u0120boolean", "\u0120is", "Any", "App", "Config", "ured", "In", "Source", "Server", "X", "ml", "()", "\u0120{", "\u0120boolean", "\u0120b", "Config", "ured", "\u0120=", "\u0120false", ";", "\u0120Set", "<", "String", ">", "\u0120locations", "\u0120=", "\u0120get", "App", "Config", "L", "ocations", "From", "Source", "Server", "X", "ml", "();", "\u0120if", "\u0120(", "loc", "ations", ".", "size", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120log", ".", "debug", "(\"", "Application", "\u0120configuration", "\u0120is", "\u0120found", "\u0120in", "\u0120server", ".", "xml", ".\"", ");", "\u0120b", "Config", "ured", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120return", "\u0120b", "Config", "ured", ";", "\u0120}"], "docstring_tokens": ["Here", "\u0120I", "\u0120would", "\u0120just", "\u0120say", "\u0120return", "\u0120true", ".", "\u0120Then", "\u0120fall", "\u0120through", "\u0120return", "\u0120false", ",", "\u0120instead", "\u0120of", "\u0120creating", "\u0120a", "\u0120variable", "."]}
{"function": "protected void exportAsContext() { if (EDatabaseConnTemplate.isSchemaNeeded(getConnection().getDatabaseType()) && schemaText != null && StringUtils.isEmpty(schemaText.getText())) { MessageDialog.openWarning(getShell(), Messages.getString(\"AbstractForm.ExportAsContext\"), Messages.getString(\"DatabaseForm.checkSchema\")); } collectContextParams(); super.exportAsContext(); }", "text": "It's better to use **isBlank** here", "function_tokens": ["protected", "\u0120void", "\u0120export", "As", "Context", "()", "\u0120{", "\u0120if", "\u0120(", "ED", "at", "abase", "Conn", "Template", ".", "is", "Sche", "ma", "Need", "ed", "(", "get", "Connection", "().", "get", "Database", "Type", "())", "\u0120&&", "\u0120schema", "Text", "\u0120!=", "\u0120null", "\u0120&&", "\u0120String", "Ut", "ils", ".", "is", "Empty", "(", "sche", "ma", "Text", ".", "get", "Text", "()", "))", "\u0120{", "\u0120Message", "Dialog", ".", "open", "Warning", "(", "get", "Shell", "(),", "\u0120Messages", ".", "get", "String", "(\"", "Abstract", "Form", ".", "Export", "As", "Context", "\"),", "\u0120Messages", ".", "get", "String", "(\"", "Database", "Form", ".", "check", "Sche", "ma", "\")", ");", "\u0120}", "\u0120collect", "Context", "Par", "ams", "();", "\u0120super", ".", "export", "As", "Context", "();", "\u0120}"], "docstring_tokens": ["It", "'s", "\u0120better", "\u0120to", "\u0120use", "\u0120**", "is", "Bl", "ank", "**", "\u0120here"]}
{"function": "public boolean validate() { boolean isNew = getModel().getIsNew(); int maxAllowedVms = getMaxVmsInPool(); int assignedVms = getModel().getAssignedVms().asConvertible().integer(); getModel().getNumOfDesktops().validateEntity( new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) }); getModel().getPrestartedVms().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) }); getModel().getMaxAssignedVmsPerUser().validateEntity( new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 1000000) }); getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid()); getModel().setIsPoolTabValid(true); return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid(); }", "text": "also here please use Short.MAX_VALUE", "function_tokens": ["public", "\u0120boolean", "\u0120validate", "()", "\u0120{", "\u0120boolean", "\u0120is", "New", "\u0120=", "\u0120get", "Model", "().", "get", "Is", "New", "();", "\u0120int", "\u0120max", "All", "owed", "V", "ms", "\u0120=", "\u0120get", "Max", "V", "ms", "In", "Pool", "();", "\u0120int", "\u0120assigned", "V", "ms", "\u0120=", "\u0120get", "Model", "().", "get", "Ass", "igned", "V", "ms", "().", "as", "Con", "vert", "ible", "().", "integer", "();", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "valid", "ate", "Entity", "(", "\u0120new", "\u0120I", "Val", "idation", "[]", "\u0120{", "\u0120new", "\u0120Not", "Empty", "Val", "idation", "(),", "\u0120new", "\u0120Length", "Val", "idation", "(", "4", "),", "\u0120new", "\u0120Integer", "Val", "idation", "(", "is", "New", "\u0120?", "\u01201", "\u0120:", "\u01200", ",", "\u0120is", "New", "\u0120?", "\u0120max", "All", "owed", "V", "ms", "\u0120:", "\u0120max", "All", "owed", "V", "ms", "\u0120-", "\u0120assigned", "V", "ms", ")", "\u0120});", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "valid", "ate", "Entity", "(", "\u0120new", "\u0120I", "Val", "idation", "[]", "\u0120{", "\u0120new", "\u0120Not", "Empty", "Val", "idation", "(),", "\u0120new", "\u0120Integer", "Val", "idation", "(", "0", ",", "\u0120assigned", "V", "ms", ")", "\u0120});", "\u0120get", "Model", "().", "get", "Max", "Ass", "igned", "V", "ms", "Per", "User", "().", "valid", "ate", "Entity", "(", "\u0120new", "\u0120I", "Val", "idation", "[]", "\u0120{", "\u0120new", "\u0120Not", "Empty", "Val", "idation", "(),", "\u0120new", "\u0120Integer", "Val", "idation", "(", "1", ",", "\u0120100", "0000", ")", "\u0120});", "\u0120get", "Model", "().", "set", "Is", "General", "Tab", "Valid", "(", "get", "Model", "().", "get", "Is", "General", "Tab", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Name", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Max", "Ass", "igned", "V", "ms", "Per", "User", "().", "get", "Is", "Valid", "());", "\u0120get", "Model", "().", "set", "Is", "Pool", "Tab", "Valid", "(", "true", ");", "\u0120return", "\u0120super", ".", "valid", "ate", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Name", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Num", "Of", "Des", "kt", "ops", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "P", "rest", "arted", "V", "ms", "().", "get", "Is", "Valid", "()", "\u0120&&", "\u0120get", "Model", "().", "get", "Max", "Ass", "igned", "V", "ms", "Per", "User", "().", "get", "Is", "Valid", "();", "\u0120}"], "docstring_tokens": ["also", "\u0120here", "\u0120please", "\u0120use", "\u0120Short", ".", "MAX", "_", "VALUE"]}
{"function": "private void doConcurrentPutInTx(String s) throws Exception { for (int i = 0; i < totalNumberOfBuckets; i++) { synchronized (list) { list.add(i); } } Thread[] threads = new Thread[totalNumberOfBuckets]; for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i] = new Thread(() -> doPutOpInTx(s)); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].start(); } for (int i = 0; i < totalNumberOfBuckets; i++) { threads[i].join(); } }", "text": "This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()", "function_tokens": ["private", "\u0120void", "\u0120do", "Con", "current", "Put", "In", "Tx", "(", "String", "\u0120s", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120total", "Number", "Of", "B", "uck", "ets", ";", "\u0120i", "++)", "\u0120{", "\u0120synchronized", "\u0120(", "list", ")", "\u0120{", "\u0120list", ".", "add", "(", "i", ");", "\u0120}", "\u0120}", "\u0120Thread", "[]", "\u0120threads", "\u0120=", "\u0120new", "\u0120Thread", "[", "total", "Number", "Of", "B", "uck", "ets", "];", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120total", "Number", "Of", "B", "uck", "ets", ";", "\u0120i", "++)", "\u0120{", "\u0120threads", "[", "i", "]", "\u0120=", "\u0120new", "\u0120Thread", "(", "()", "\u0120->", "\u0120do", "Put", "Op", "In", "Tx", "(", "s", "));", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120total", "Number", "Of", "B", "uck", "ets", ";", "\u0120i", "++)", "\u0120{", "\u0120threads", "[", "i", "].", "start", "();", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120total", "Number", "Of", "B", "uck", "ets", ";", "\u0120i", "++)", "\u0120{", "\u0120threads", "[", "i", "].", "join", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120synchronization", "\u0120block", "\u0120should", "\u0120be", "\u0120replaced", "\u0120with", "\u0120a", "\u0120collection", "\u0120that", "\u0120handles", "\u0120conc", "urrency", ",", "\u0120like", "\u0120Conc", "urrency", "Link", "ed", "Queue", "\u0120or", "\u0120Collections", ".", "syn", "chron", "ized", "List", "()"]}
{"function": "private void addEditLink(WebMvcLinkBuilder selfLinkBuilder, GoalDto goalResource) { goalResource.add(selfLinkBuilder.withRel(JsonRootLinkRelationProvider.EDIT_REL)); }", "text": "Here too we may use IanaLinkRelation.EDIT?", "function_tokens": ["private", "\u0120void", "\u0120add", "Edit", "Link", "(", "Web", "M", "vc", "Link", "Builder", "\u0120self", "Link", "Builder", ",", "\u0120Goal", "D", "to", "\u0120goal", "Resource", ")", "\u0120{", "\u0120goal", "Resource", ".", "add", "(", "self", "Link", "Builder", ".", "with", "Rel", "(", "J", "son", "Root", "Link", "Rel", "ation", "Provider", ".", "EDIT", "_", "REL", "));", "\u0120}"], "docstring_tokens": ["Here", "\u0120too", "\u0120we", "\u0120may", "\u0120use", "\u0120I", "ana", "Link", "Rel", "ation", ".", "EDIT", "?"]}
{"function": "public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = \"\"; mFloppyPath = \"\"; mRunAndPause = false; _diskSize = 0; }", "text": "coudl be just ArrayList since now it is imported ^^ vv", "function_tokens": ["public", "\u0120VM", "()", "\u0120{", "\u0120m", "V", "m", "Static", "\u0120=", "\u0120new", "\u0120V", "m", "Static", "();", "\u0120m", "V", "m", "Dynamic", "\u0120=", "\u0120new", "\u0120V", "m", "Dynamic", "();", "\u0120m", "V", "m", "Statistics", "\u0120=", "\u0120new", "\u0120V", "m", "Statistics", "();", "\u0120m", "V", "m", "Static", ".", "set", "Images", "(", "new", "\u0120java", ".", "util", ".", "Array", "List", "<", "Disk", "Image", ">", "());", "\u0120m", "V", "m", "Static", ".", "set", "Inter", "faces", "(", "new", "\u0120java", ".", "util", ".", "Array", "List", "<", "V", "m", "Network", "Interface", ">", "());", "\u0120m", "Disk", "Map", "\u0120=", "\u0120new", "\u0120java", ".", "util", ".", "Hash", "Map", "<", "String", ",", "\u0120Disk", "Image", ">", "();", "\u0120m", "C", "d", "Path", "\u0120=", "\u0120\"", "\";", "\u0120m", "Flo", "ppy", "Path", "\u0120=", "\u0120\"", "\";", "\u0120m", "Run", "And", "Pause", "\u0120=", "\u0120false", ";", "\u0120_", "disk", "Size", "\u0120=", "\u01200", ";", "\u0120}"], "docstring_tokens": ["c", "oud", "l", "\u0120be", "\u0120just", "\u0120Array", "List", "\u0120since", "\u0120now", "\u0120it", "\u0120is", "\u0120imported", "\u0120^", "^", "\u0120v", "v"]}
{"function": "private void setCurentCommitInfo(String revision) { fCommitInfo.reset(); Iterator<Map.Entry<String, RevisionInfo>> itr1 = fRevisions.entrySet().iterator(); while (itr1.hasNext()) { Entry<String, RevisionInfo> entry = itr1.next(); if (entry.getKey().equals(revision)) { System.out.println(\"Looking at the Current patchset : \" + entry.getValue().getNumber()); fCommitInfo.setCommit(revision); fCommitInfo.setMessage(entry.getValue().getCommit().getMessage()); fCommitInfo.setParents(entry.getValue().getCommit().getParents()); fCommitInfo.setAuthor(entry.getValue().getCommit().getAuthor()); fCommitInfo.setCommitter(entry.getValue().getCommit().getCommitter()); } else { System.out.println(\"Looking at the other patchset : \" + entry.getValue().getNumber()); } } }", "text": "log", "function_tokens": ["private", "\u0120void", "\u0120set", "C", "ure", "nt", "Comm", "it", "Info", "(", "String", "\u0120revision", ")", "\u0120{", "\u0120f", "Comm", "it", "Info", ".", "reset", "();", "\u0120Iter", "ator", "<", "Map", ".", "Entry", "<", "String", ",", "\u0120Revision", "Info", ">>", "\u0120it", "r", "1", "\u0120=", "\u0120f", "Rev", "isions", ".", "entry", "Set", "().", "iterator", "();", "\u0120while", "\u0120(", "it", "r", "1", ".", "has", "Next", "())", "\u0120{", "\u0120Entry", "<", "String", ",", "\u0120Revision", "Info", ">", "\u0120entry", "\u0120=", "\u0120it", "r", "1", ".", "next", "();", "\u0120if", "\u0120(", "entry", ".", "get", "Key", "().", "equ", "als", "(", "re", "vision", "))", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "Looking", "\u0120at", "\u0120the", "\u0120Current", "\u0120patch", "set", "\u0120:", "\u0120\"", "\u0120+", "\u0120entry", ".", "get", "Value", "().", "get", "Number", "());", "\u0120f", "Comm", "it", "Info", ".", "set", "Comm", "it", "(", "re", "vision", ");", "\u0120f", "Comm", "it", "Info", ".", "set", "Message", "(", "entry", ".", "get", "Value", "().", "get", "Comm", "it", "().", "get", "Message", "());", "\u0120f", "Comm", "it", "Info", ".", "set", "Parents", "(", "entry", ".", "get", "Value", "().", "get", "Comm", "it", "().", "get", "Parents", "());", "\u0120f", "Comm", "it", "Info", ".", "set", "Author", "(", "entry", ".", "get", "Value", "().", "get", "Comm", "it", "().", "get", "Author", "());", "\u0120f", "Comm", "it", "Info", ".", "set", "Comm", "itter", "(", "entry", ".", "get", "Value", "().", "get", "Comm", "it", "().", "get", "Comm", "itter", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "Looking", "\u0120at", "\u0120the", "\u0120other", "\u0120patch", "set", "\u0120:", "\u0120\"", "\u0120+", "\u0120entry", ".", "get", "Value", "().", "get", "Number", "());", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["log"]}
{"function": "public void testQueryProcessByVariables() { Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\"); Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\"); List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext()); Assert.assertEquals(3, data.size()); for (ProcessInstanceWithVarsDesc p : data) { Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\")); Assert.assertEquals(\"test.test_A\", p.getProcessId()); } }", "text": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "function_tokens": ["public", "\u0120void", "\u0120test", "Query", "Process", "By", "Vari", "ables", "()", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120variables", "\u0120=", "\u0120Collections", ".<", "String", ",", "\u0120Object", ">", "\u0120single", "ton", "Map", "(\"", "var", "_", "a", "\",", "\u0120\"", "a", "1", "\");", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120attributes", "\u0120=", "\u0120Collections", ".<", "String", ",", "\u0120Object", ">", "\u0120single", "ton", "Map", "(\"", "process", "Id", "\",", "\u0120\"", "test", ".", "test", "_", "A", "\");", "\u0120List", "<", "Process", "Instance", "With", "V", "ars", "Desc", ">", "\u0120data", "\u0120=", "\u0120advance", "Variable", "Data", "Service", ".", "query", "Process", "By", "Vari", "ables", "(", "att", "ributes", ",", "\u0120variables", ",", "\u0120new", "\u0120Query", "Context", "());", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(", "3", ",", "\u0120data", ".", "size", "());", "\u0120for", "\u0120(", "Process", "Instance", "With", "V", "ars", "Desc", "\u0120p", "\u0120:", "\u0120data", ")", "\u0120{", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(\"", "a", "1", "\",", "\u0120p", ".", "get", "Vari", "ables", "().", "get", "(\"", "var", "_", "a", "\")", ");", "\u0120Ass", "ert", ".", "assert", "Equ", "als", "(\"", "test", ".", "test", "_", "A", "\",", "\u0120p", ".", "get", "Process", "Id", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Col", "lections", ".<", "String", ",", "\u0120Object", ">", "\u0120single", "ton", "Map", "\u0120can", "\u0120be", "\u0120replaced", "\u0120with", "\u0120just", "\u0120Collections", ".", "sing", "leton", "Map"]}
{"function": "void updateThreadPoolSize(int numThreads) { m_scheduler.setCorePoolSize(numThreads); LOG.info(\"Updated PBD to use \" + numThreads + \" threads to enforce retention policy\"); }", "text": "Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling", "function_tokens": ["void", "\u0120update", "Thread", "Pool", "Size", "(", "int", "\u0120num", "Thread", "s", ")", "\u0120{", "\u0120m", "_", "sc", "hed", "uler", ".", "set", "Core", "Pool", "Size", "(", "num", "Thread", "s", ");", "\u0120LOG", ".", "info", "(\"", "Updated", "\u0120P", "BD", "\u0120to", "\u0120use", "\u0120\"", "\u0120+", "\u0120num", "Thread", "s", "\u0120+", "\u0120\"", "\u0120threads", "\u0120to", "\u0120enforce", "\u0120retention", "\u0120policy", "\");", "\u0120}"], "docstring_tokens": ["Do", "\u0120you", "\u0120want", "\u0120to", "\u0120check", "\u0120if", "\u0120the", "\u0120thread", "\u0120count", "\u0120changed", "\u0120because", "\u0120right", "\u0120now", "\u0120this", "\u0120log", "\u0120message", "\u0120will", "\u0120be", "\u0120logged", "\u0120on", "\u0120every", "\u0120catalog", "\u0120update", "\u0120which", "\u0120affects", "\u0120ki", "pling"]}
{"function": "protected void postProcessHeaderLines() { final List<String> headerLines = getHeaderLines(); final Pattern blankLine = Pattern.compile(EMPTY_LINE_PATTERN); for (final String line : headerLines) { try { if (line.isEmpty()) { headerRegexps.add(blankLine); } else { headerRegexps.add(Pattern.compile(line)); } } catch (final PatternSyntaxException ex) { throw new IllegalArgumentException(\"line \" + (headerRegexps.size() + 1) + \" in header specification\" + \" is not a regular expression\", ex); } } }", "text": "please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.", "function_tokens": ["protected", "\u0120void", "\u0120post", "Process", "Header", "L", "ines", "()", "\u0120{", "\u0120final", "\u0120List", "<", "String", ">", "\u0120header", "L", "ines", "\u0120=", "\u0120get", "Header", "L", "ines", "();", "\u0120final", "\u0120Pattern", "\u0120blank", "Line", "\u0120=", "\u0120Pattern", ".", "comp", "ile", "(", "EMP", "TY", "_", "LINE", "_", "P", "AT", "TERN", ");", "\u0120for", "\u0120(", "final", "\u0120String", "\u0120line", "\u0120:", "\u0120header", "L", "ines", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "line", ".", "is", "Empty", "())", "\u0120{", "\u0120header", "Re", "gex", "ps", ".", "add", "(", "blank", "Line", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120header", "Re", "gex", "ps", ".", "add", "(", "Pattern", ".", "comp", "ile", "(", "line", "));", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Pattern", "Sy", "ntax", "Exception", "\u0120ex", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "line", "\u0120\"", "\u0120+", "\u0120(", "header", "Re", "gex", "ps", ".", "size", "()", "\u0120+", "\u01201", ")", "\u0120+", "\u0120\"", "\u0120in", "\u0120header", "\u0120specification", "\"", "\u0120+", "\u0120\"", "\u0120is", "\u0120not", "\u0120a", "\u0120regular", "\u0120expression", "\",", "\u0120ex", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["please", "\u0120move", "\u0120compilation", "\u0120of", "\u0120pattern", "\u0120to", "\u0120class", "\u0120field", ",", "\u0120to", "\u0120be", "\u0120done", "\u0120ones", ",", "\u0120for", "\u0120whole", "\u0120execution", "\u0120of", "\u0120check", "style", "."]}
{"function": "public void setActivePart(IAction action, IWorkbenchPart targetPart) { if(targetPart instanceof IMavenProjectHolder) { this.projectHolder = (IMavenProjectHolder) targetPart; } else { this.projectHolder = null; } }", "text": "I don't like IMavenProjectHolder. I think targetPart.getAdapter(MavenProject.class) is more appropriate here.", "function_tokens": ["public", "\u0120void", "\u0120set", "Active", "Part", "(", "IA", "ction", "\u0120action", ",", "\u0120I", "Work", "bench", "Part", "\u0120target", "Part", ")", "\u0120{", "\u0120if", "(", "target", "Part", "\u0120instance", "of", "\u0120IM", "aven", "Project", "H", "older", ")", "\u0120{", "\u0120this", ".", "project", "H", "older", "\u0120=", "\u0120(", "IM", "aven", "Project", "H", "older", ")", "\u0120target", "Part", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120this", ".", "project", "H", "older", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120like", "\u0120IM", "aven", "Project", "H", "older", ".", "\u0120I", "\u0120think", "\u0120target", "Part", ".", "get", "Adapter", "(", "M", "aven", "Project", ".", "class", ")", "\u0120is", "\u0120more", "\u0120appropriate", "\u0120here", "."]}
{"function": "private void parseConfiguration(Config config, FailureCollector collector) { if (!config.defaults.isEmpty()) { String[] defaultsList = config.defaults.split(\",\"); for (String defaultValue : defaultsList) { String[] defaultsArray = defaultValue.split(\":\"); if (defaultsArray.length != 2) { collector.addFailure( String.format(\"Invalid default: %s.\", defaultValue), \"Defaults should contain source field and its corresponding default \" + \"value in the format: <source-field>:<default-value>[,<source-field>:<default-value>]* \" + \"For example: lang_code:English,country_code:Britain\").withConfigElement(DEFAULTS, defaultValue); } else { defaultsMapping.put(defaultsArray[0], defaultsArray[1]); } } } String[] mappingArray = config.mapping.split(\",\"); for (String mapping : mappingArray) { String[] mappingValueArray = mapping.split(\":\"); if (mappingValueArray.length != 3) { collector.addFailure(String.format(\"Invalid mapping: %s.\", mapping), \"Mapping should contain source field, lookup table name, \" + \"and target field in the format: \" + \"<source-field>:<lookup-table-name>:<target-field>\" + \"[,<source-field>:<lookup-table-name>:<target-field>]* \" + \"For example: lang_code:language_code_lookup:lang_desc,\" + \"country_code:country_lookup:country_name\").withConfigElement(MAPPING, mapping); } else { String defaultValue = null; if (defaultsMapping.containsKey(mappingValueArray[0])) { defaultValue = defaultsMapping.get(mappingValueArray[0]); } ValueMapping valueMapping = new ValueMapping(mappingValueArray[2], mappingValueArray[1], defaultValue); mappingValues.put(mappingValueArray[0], valueMapping); } } collector.getOrThrowException(); }", "text": "indentation, here and rest of PR", "function_tokens": ["private", "\u0120void", "\u0120parse", "Configuration", "(", "Config", "\u0120config", ",", "\u0120Failure", "Collect", "or", "\u0120collector", ")", "\u0120{", "\u0120if", "\u0120(!", "config", ".", "default", "s", ".", "is", "Empty", "())", "\u0120{", "\u0120String", "[]", "\u0120defaults", "List", "\u0120=", "\u0120config", ".", "default", "s", ".", "split", "(", "\",\"", ");", "\u0120for", "\u0120(", "String", "\u0120default", "Value", "\u0120:", "\u0120defaults", "List", ")", "\u0120{", "\u0120String", "[]", "\u0120defaults", "Array", "\u0120=", "\u0120default", "Value", ".", "split", "(", "\":\"", ");", "\u0120if", "\u0120(", "default", "s", "Array", ".", "length", "\u0120!=", "\u01202", ")", "\u0120{", "\u0120collector", ".", "add", "Failure", "(", "\u0120String", ".", "format", "(\"", "Invalid", "\u0120default", ":", "\u0120%", "s", ".\",", "\u0120default", "Value", "),", "\u0120\"", "Def", "aults", "\u0120should", "\u0120contain", "\u0120source", "\u0120field", "\u0120and", "\u0120its", "\u0120corresponding", "\u0120default", "\u0120\"", "\u0120+", "\u0120\"", "value", "\u0120in", "\u0120the", "\u0120format", ":", "\u0120<", "source", "-", "field", ">:", "<", "default", "-", "value", ">[", ",", "<", "source", "-", "field", ">:", "<", "default", "-", "value", ">]", "*", "\u0120\"", "\u0120+", "\u0120\"", "For", "\u0120example", ":", "\u0120lang", "_", "code", ":", "English", ",", "country", "_", "code", ":", "Britain", "\").", "with", "Config", "Element", "(", "DE", "FA", "ULTS", ",", "\u0120default", "Value", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120defaults", "M", "apping", ".", "put", "(", "default", "s", "Array", "[", "0", "],", "\u0120defaults", "Array", "[", "1", "]);", "\u0120}", "\u0120}", "\u0120}", "\u0120String", "[]", "\u0120mapping", "Array", "\u0120=", "\u0120config", ".", "m", "apping", ".", "split", "(", "\",\"", ");", "\u0120for", "\u0120(", "String", "\u0120mapping", "\u0120:", "\u0120mapping", "Array", ")", "\u0120{", "\u0120String", "[]", "\u0120mapping", "Value", "Array", "\u0120=", "\u0120mapping", ".", "split", "(", "\":\"", ");", "\u0120if", "\u0120(", "m", "apping", "Value", "Array", ".", "length", "\u0120!=", "\u01203", ")", "\u0120{", "\u0120collector", ".", "add", "Failure", "(", "String", ".", "format", "(\"", "Invalid", "\u0120mapping", ":", "\u0120%", "s", ".\",", "\u0120mapping", "),", "\u0120\"", "M", "apping", "\u0120should", "\u0120contain", "\u0120source", "\u0120field", ",", "\u0120lookup", "\u0120table", "\u0120name", ",", "\u0120\"", "\u0120+", "\u0120\"", "and", "\u0120target", "\u0120field", "\u0120in", "\u0120the", "\u0120format", ":", "\u0120\"", "\u0120+", "\u0120\"<", "source", "-", "field", ">:", "<", "look", "up", "-", "table", "-", "name", ">:", "<", "target", "-", "field", ">\"", "\u0120+", "\u0120\"[", ",", "<", "source", "-", "field", ">:", "<", "look", "up", "-", "table", "-", "name", ">:", "<", "target", "-", "field", ">]", "*", "\u0120\"", "\u0120+", "\u0120\"", "For", "\u0120example", ":", "\u0120lang", "_", "code", ":", "language", "_", "code", "_", "look", "up", ":", "lang", "_", "desc", ",\"", "\u0120+", "\u0120\"", "country", "_", "code", ":", "country", "_", "look", "up", ":", "country", "_", "name", "\").", "with", "Config", "Element", "(", "M", "APP", "ING", ",", "\u0120mapping", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120default", "Value", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "default", "s", "M", "apping", ".", "cont", "ains", "Key", "(", "m", "apping", "Value", "Array", "[", "0", "]", "))", "\u0120{", "\u0120default", "Value", "\u0120=", "\u0120defaults", "M", "apping", ".", "get", "(", "m", "apping", "Value", "Array", "[", "0", "]);", "\u0120}", "\u0120Value", "M", "apping", "\u0120value", "M", "apping", "\u0120=", "\u0120new", "\u0120Value", "M", "apping", "(", "m", "apping", "Value", "Array", "[", "2", "],", "\u0120mapping", "Value", "Array", "[", "1", "],", "\u0120default", "Value", ");", "\u0120mapping", "Values", ".", "put", "(", "m", "apping", "Value", "Array", "[", "0", "],", "\u0120value", "M", "apping", ");", "\u0120}", "\u0120}", "\u0120collector", ".", "get", "Or", "Throw", "Exception", "();", "\u0120}"], "docstring_tokens": ["ind", "ent", "ation", ",", "\u0120here", "\u0120and", "\u0120rest", "\u0120of", "\u0120PR"]}
{"function": "public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(\"eventData cannot be null.\"); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, \"Size of the payload exceeded Maximum message size: %s kb\", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }", "text": "Replace with Objects.requireNotNull.", "function_tokens": ["public", "\u0120boolean", "\u0120try", "Add", "(", "final", "\u0120Event", "Data", "\u0120event", "Data", ")", "\u0120throws", "\u0120Pay", "load", "Size", "Ex", "ceed", "ed", "Exception", "\u0120{", "\u0120if", "\u0120(", "event", "Data", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "event", "Data", "\u0120cannot", "\u0120be", "\u0120null", ".\"", ");", "\u0120}", "\u0120final", "\u0120Event", "Data", "Impl", "\u0120event", "Data", "Impl", "\u0120=", "\u0120(", "Event", "Data", "Impl", ")", "\u0120event", "Data", ";", "\u0120final", "\u0120int", "\u0120size", ";", "\u0120try", "\u0120{", "\u0120size", "\u0120=", "\u0120get", "Size", "(", "event", "Data", "Impl", ",", "\u0120events", ".", "is", "Empty", "());", "\u0120}", "\u0120catch", "\u0120(", "java", ".", "n", "io", ".", "Buffer", "Over", "flow", "Exception", "\u0120exception", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Pay", "load", "Size", "Ex", "ceed", "ed", "Exception", "(", "String", ".", "format", "(", "Loc", "ale", ".", "US", ",", "\u0120\"", "Size", "\u0120of", "\u0120the", "\u0120payload", "\u0120exceeded", "\u0120Maximum", "\u0120message", "\u0120size", ":", "\u0120%", "s", "\u0120kb", "\",", "\u0120this", ".", "max", "Message", "Size", "\u0120/", "\u01201024", "));", "\u0120}", "\u0120if", "\u0120(", "this", ".", "current", "Size", "\u0120+", "\u0120size", "\u0120>", "\u0120this", ".", "max", "Message", "Size", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120this", ".", "events", ".", "add", "(", "event", "Data", "Impl", ");", "\u0120this", ".", "current", "Size", "\u0120+=", "\u0120size", ";", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["Re", "place", "\u0120with", "\u0120Objects", ".", "require", "Not", "Null", "."]}
{"function": "private static void doAppendEscapedIdentifier(Appendable sbuf, String value) throws SQLException { try { sbuf.append('\"'); for (char ch : value.toCharArray()) { if (ch == '\\0') { throw new PSQLException(GT.tr(\"Zero bytes may not occur in identifiers.\"), PSQLState.INVALID_PARAMETER_VALUE); } if (ch == '\"') { sbuf.append(ch); } sbuf.append(ch); } sbuf.append('\"'); } catch (IOException e) { throw new PSQLException(GT.tr(\"No IOException expected from StringBuffer or StringBuilder\"), PSQLState.UNEXPECTED_ERROR, e); } }", "text": "I wonder if this change would result array allocation and extra cpu/memory consumption issues", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120do", "App", "end", "Esc", "aped", "Ident", "ifier", "(", "App", "end", "able", "\u0120s", "buf", ",", "\u0120String", "\u0120value", ")", "\u0120throws", "\u0120SQ", "LE", "x", "ception", "\u0120{", "\u0120try", "\u0120{", "\u0120s", "buf", ".", "append", "('", "\"", "');", "\u0120for", "\u0120(", "char", "\u0120ch", "\u0120:", "\u0120value", ".", "to", "Char", "Array", "())", "\u0120{", "\u0120if", "\u0120(", "ch", "\u0120==", "\u0120'", "\\", "0", "')", "\u0120{", "\u0120throw", "\u0120new", "\u0120PS", "Q", "LE", "x", "ception", "(", "GT", ".", "tr", "(\"", "Zero", "\u0120bytes", "\u0120may", "\u0120not", "\u0120occur", "\u0120in", "\u0120identifiers", ".\"", "),", "\u0120PS", "QL", "State", ".", "IN", "VAL", "ID", "_", "PAR", "AM", "ET", "ER", "_", "VALUE", ");", "\u0120}", "\u0120if", "\u0120(", "ch", "\u0120==", "\u0120'", "\"", "')", "\u0120{", "\u0120s", "buf", ".", "append", "(", "ch", ");", "\u0120}", "\u0120s", "buf", ".", "append", "(", "ch", ");", "\u0120}", "\u0120s", "buf", ".", "append", "('", "\"", "');", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120PS", "Q", "LE", "x", "ception", "(", "GT", ".", "tr", "(\"", "No", "\u0120IO", "Exception", "\u0120expected", "\u0120from", "\u0120String", "Buffer", "\u0120or", "\u0120String", "Builder", "\"),", "\u0120PS", "QL", "State", ".", "UN", "EXP", "ECT", "ED", "_", "ERROR", ",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120wonder", "\u0120if", "\u0120this", "\u0120change", "\u0120would", "\u0120result", "\u0120array", "\u0120allocation", "\u0120and", "\u0120extra", "\u0120cpu", "/", "memory", "\u0120consumption", "\u0120issues"]}
{"function": "public void shouldScheduleDelayedActionOnHandlerThread() { Handler handler = mock(Handler.class); @SuppressWarnings(\"unchecked\") Action0 action = mock(Action0.class); Scheduler scheduler = HandlerScheduler.create(handler); Worker inner = scheduler.createWorker(); inner.schedule(action, 1L, TimeUnit.SECONDS); ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class); verify(handler).postDelayed(runnable.capture(), eq(1000L)); runnable.getValue().run(); verify(action).call(); }", "text": "May be static imports for TimeUnit values here and below?", "function_tokens": ["public", "\u0120void", "\u0120should", "Sche", "dule", "Del", "ayed", "Action", "On", "Handler", "Thread", "()", "\u0120{", "\u0120Handler", "\u0120handler", "\u0120=", "\u0120mock", "(", "Handler", ".", "class", ");", "\u0120@", "Supp", "ress", "W", "arn", "ings", "(\"", "un", "checked", "\")", "\u0120Action", "0", "\u0120action", "\u0120=", "\u0120mock", "(", "Action", "0", ".", "class", ");", "\u0120Sched", "uler", "\u0120sched", "uler", "\u0120=", "\u0120Handler", "S", "ched", "uler", ".", "create", "(", "handler", ");", "\u0120Worker", "\u0120inner", "\u0120=", "\u0120sched", "uler", ".", "create", "Work", "er", "();", "\u0120inner", ".", "sche", "dule", "(", "action", ",", "\u01201", "L", ",", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", ");", "\u0120Argument", "Capt", "or", "<", "Run", "n", "able", ">", "\u0120run", "n", "able", "\u0120=", "\u0120Argument", "Capt", "or", ".", "for", "Class", "(", "Run", "n", "able", ".", "class", ");", "\u0120verify", "(", "handler", ").", "post", "Del", "ayed", "(", "run", "n", "able", ".", "capt", "ure", "(),", "\u0120eq", "(", "1000", "L", "));", "\u0120run", "n", "able", ".", "get", "Value", "().", "run", "();", "\u0120verify", "(", "action", ").", "call", "();", "\u0120}"], "docstring_tokens": ["May", "\u0120be", "\u0120static", "\u0120imports", "\u0120for", "\u0120Time", "Unit", "\u0120values", "\u0120here", "\u0120and", "\u0120below", "?"]}
{"function": "public void aggregate(ByteBuffer buf, int position) { boolean countNulls = !selector.nameLookupPossibleInAdvance() || NullHandlingHelper.useDefaultValuesForNull(); MutableBitmap mutableBitmap = getMutableBitmap(position); IndexedInts row = selector.getRow(); for (int i = 0; i < row.size(); i++) { int index = row.get(i); if (countNulls || selector.lookupName(index) != null) { mutableBitmap.add(index); } } buf.putLong(position, mutableBitmap.size()); }", "text": "Similar to DistinctCountAggregator", "function_tokens": ["public", "\u0120void", "\u0120aggregate", "(", "Byte", "Buffer", "\u0120buf", ",", "\u0120int", "\u0120position", ")", "\u0120{", "\u0120boolean", "\u0120count", "Null", "s", "\u0120=", "\u0120!", "select", "or", ".", "name", "Look", "up", "P", "ossible", "In", "Ad", "vance", "()", "\u0120||", "\u0120Null", "Hand", "ling", "Helper", ".", "use", "Default", "Values", "For", "Null", "();", "\u0120Mut", "able", "Bit", "map", "\u0120mut", "able", "Bit", "map", "\u0120=", "\u0120get", "M", "utable", "Bit", "map", "(", "position", ");", "\u0120Index", "ed", "Int", "s", "\u0120row", "\u0120=", "\u0120selector", ".", "get", "Row", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120row", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120int", "\u0120index", "\u0120=", "\u0120row", ".", "get", "(", "i", ");", "\u0120if", "\u0120(", "count", "Null", "s", "\u0120||", "\u0120selector", ".", "look", "up", "Name", "(", "index", ")", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120mut", "able", "Bit", "map", ".", "add", "(", "index", ");", "\u0120}", "\u0120}", "\u0120buf", ".", "put", "Long", "(", "position", ",", "\u0120mut", "able", "Bit", "map", ".", "size", "());", "\u0120}"], "docstring_tokens": ["Similar", "\u0120to", "\u0120Dist", "inct", "Count", "Agg", "reg", "ator"]}
{"function": "private List<ModelNode> adjustInfinispan(final PathAddress subsystem) throws Exception { final List<ModelNode> list = new ArrayList<>(); list.add(getWriteAttributeOperation(subsystem.append(\"cache-container\", \"server\").append(\"transport\", \"jgroups\"), \"stack\", new ModelNode(\"udp\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"server\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"server\").append(\"replicated-cache\", \"default\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"web\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"web\").append(\"distributed-cache\", \"dist\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"ejb\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"ejb\").append(\"distributed-cache\", \"dist\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"invalidation-cache\", \"entity\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"local-cache\", \"local-query\"))); list.add(setStatisticsEnabledTrue( subsystem.append(\"cache-container\", \"hibernate\").append(\"replicated-cache\", \"timestamps\"))); return list; }", "text": "Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0", "function_tokens": ["private", "\u0120List", "<", "Model", "Node", ">", "\u0120adjust", "In", "fin", "is", "pan", "(", "final", "\u0120Path", "Address", "\u0120subsystem", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120List", "<", "Model", "Node", ">", "\u0120list", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120list", ".", "add", "(", "get", "Write", "Attribute", "Operation", "(", "sub", "system", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "server", "\").", "append", "(\"", "trans", "port", "\",", "\u0120\"", "j", "groups", "\"),", "\u0120\"", "stack", "\",", "\u0120new", "\u0120Model", "Node", "(\"", "ud", "p", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "server", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "server", "\").", "append", "(\"", "repl", "icated", "-", "cache", "\",", "\u0120\"", "default", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "web", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "web", "\").", "append", "(\"", "dist", "ributed", "-", "cache", "\",", "\u0120\"", "dist", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "e", "j", "b", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "e", "j", "b", "\").", "append", "(\"", "dist", "ributed", "-", "cache", "\",", "\u0120\"", "dist", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "h", "iber", "n", "ate", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "h", "iber", "n", "ate", "\").", "append", "(\"", "in", "valid", "ation", "-", "cache", "\",", "\u0120\"", "entity", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "h", "iber", "n", "ate", "\").", "append", "(\"", "local", "-", "cache", "\",", "\u0120\"", "local", "-", "query", "\"))", ");", "\u0120list", ".", "add", "(", "set", "Statistics", "Enabled", "True", "(", "\u0120subsystem", ".", "append", "(\"", "cache", "-", "container", "\",", "\u0120\"", "h", "iber", "n", "ate", "\").", "append", "(\"", "repl", "icated", "-", "cache", "\",", "\u0120\"", "tim", "est", "amps", "\"))", ");", "\u0120return", "\u0120list", ";", "\u0120}"], "docstring_tokens": ["Statistics", "-", "enabled", "\u0120were", "\u0120introduced", "\u0120in", "\u01206", ".", "3", ".", "0", ",", "\u0120so", "\u0120there", "\u0120is", "\u0120no", "\u0120need", "\u0120to", "\u0120set", "\u0120them", "\u0120to", "\u0120true", "\u0120for", "\u01206", ".", "3", ".", "0", ",", "\u0120only", "\u0120for", "\u01206", ".", "2", ".", "0"]}
{"function": "EventBus eventBus() { EventBus bus = new EventBus((exception, context) -> exception.printStackTrace()); bus.register(new DeadEventHandler()); return bus; }", "text": "printStackTrace() must not be used. Use a logger instead.", "function_tokens": ["Event", "Bus", "\u0120event", "Bus", "()", "\u0120{", "\u0120Event", "Bus", "\u0120bus", "\u0120=", "\u0120new", "\u0120Event", "Bus", "((", "ex", "ception", ",", "\u0120context", ")", "\u0120->", "\u0120exception", ".", "print", "Stack", "Tr", "ace", "());", "\u0120bus", ".", "register", "(", "new", "\u0120Dead", "Event", "Handler", "());", "\u0120return", "\u0120bus", ";", "\u0120}"], "docstring_tokens": ["print", "Stack", "Tr", "ace", "()", "\u0120must", "\u0120not", "\u0120be", "\u0120used", ".", "\u0120Use", "\u0120a", "\u0120logger", "\u0120instead", "."]}
{"function": "ObjectLoader openPackedObject(WindowCursor curs, AnyObjectId objectId) { PackList pList; do { pList = packList.get(); SEARCH: for (;;) { for (PackFile p : pList.packs) { try { ObjectLoader ldr = p.get(curs, objectId); if (ldr != null) return ldr; } catch (PackMismatchException e) { PackList nList = scanPacks(pList); if (pList != nList) { pList = nList; continue SEARCH; } } catch (IOException e) { removePack(p); } } break SEARCH; } } while (searchPacksAgain(pList)); return null; }", "text": "I think this could just be: if (searchPacksAgain(pList)) continue SEARCH;", "function_tokens": ["Object", "Loader", "\u0120open", "P", "acked", "Object", "(", "Window", "C", "ursor", "\u0120curs", ",", "\u0120Any", "Object", "Id", "\u0120object", "Id", ")", "\u0120{", "\u0120Pack", "List", "\u0120p", "List", ";", "\u0120do", "\u0120{", "\u0120p", "List", "\u0120=", "\u0120pack", "List", ".", "get", "();", "\u0120SE", "ARCH", ":", "\u0120for", "\u0120(", ";;", ")", "\u0120{", "\u0120for", "\u0120(", "Pack", "File", "\u0120p", "\u0120:", "\u0120p", "List", ".", "packs", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Object", "Loader", "\u0120l", "dr", "\u0120=", "\u0120p", ".", "get", "(", "c", "urs", ",", "\u0120object", "Id", ");", "\u0120if", "\u0120(", "ld", "r", "\u0120!=", "\u0120null", ")", "\u0120return", "\u0120l", "dr", ";", "\u0120}", "\u0120catch", "\u0120(", "Pack", "M", "ism", "atch", "Exception", "\u0120e", ")", "\u0120{", "\u0120Pack", "List", "\u0120n", "List", "\u0120=", "\u0120scan", "P", "acks", "(", "p", "List", ");", "\u0120if", "\u0120(", "p", "List", "\u0120!=", "\u0120n", "List", ")", "\u0120{", "\u0120p", "List", "\u0120=", "\u0120n", "List", ";", "\u0120continue", "\u0120SE", "ARCH", ";", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120remove", "Pack", "(", "p", ");", "\u0120}", "\u0120}", "\u0120break", "\u0120SE", "ARCH", ";", "\u0120}", "\u0120}", "\u0120while", "\u0120(", "search", "P", "acks", "Again", "(", "p", "List", "));", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120this", "\u0120could", "\u0120just", "\u0120be", ":", "\u0120if", "\u0120(", "search", "P", "acks", "Again", "(", "p", "List", "))", "\u0120continue", "\u0120SE", "ARCH", ";"]}
{"function": "public void bufferExactFailingSupplier() { Scheduler.Worker w = new TestScheduler().createWorker(); TestSubscriber<List<Integer>> observer = new TestSubscriber<List<Integer>>(); FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>> buf = new FlowableBufferTimed.BufferExactBoundedSubscriber<Integer, List<Integer>>(observer, ArrayListSupplier.<Integer>asCallable(), 100, TimeUnit.MILLISECONDS, 10, false, w); buf.onError(new Throwable()); buf.onComplete(); }", "text": "The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;", "function_tokens": ["public", "\u0120void", "\u0120buffer", "Ex", "act", "F", "ailing", "Supp", "lier", "()", "\u0120{", "\u0120Sched", "uler", ".", "Work", "er", "\u0120w", "\u0120=", "\u0120new", "\u0120Test", "S", "ched", "uler", "().", "create", "Work", "er", "();", "\u0120Test", "Sub", "sc", "riber", "<", "List", "<", "Integer", ">>", "\u0120observer", "\u0120=", "\u0120new", "\u0120Test", "Sub", "sc", "riber", "<", "List", "<", "Integer", ">>", "();", "\u0120Flow", "able", "Buffer", "Tim", "ed", ".", "Buffer", "Ex", "act", "B", "ounded", "Sub", "sc", "riber", "<", "Integer", ",", "\u0120List", "<", "Integer", ">>", "\u0120buf", "\u0120=", "\u0120new", "\u0120Flow", "able", "Buffer", "Tim", "ed", ".", "Buffer", "Ex", "act", "B", "ounded", "Sub", "sc", "riber", "<", "Integer", ",", "\u0120List", "<", "Integer", ">>", "(", "ob", "server", ",", "\u0120Array", "List", "Supp", "lier", ".<", "Integer", ">", "as", "Call", "able", "(),", "\u0120100", ",", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", ",", "\u012010", ",", "\u0120false", ",", "\u0120w", ");", "\u0120buf", ".", "on", "Error", "(", "new", "\u0120Throw", "able", "());", "\u0120buf", ".", "on", "Complete", "();", "\u0120}"], "docstring_tokens": ["The", "\u0120list", "\u0120supplier", "\u0120should", "\u0120fail", ",", "\u0120calling", "\u0120on", "Error", "\u0120and", "\u0120on", "Completed", "\u0120this", "\u0120way", "\u0120is", "\u0120just", "\u0120a", "\u0120plain", "\u0120protocol", "\u0120violation", ".", "\u0120Do", "\u0120something", "\u0120this", "\u0120instead", ":", "\u0120java", "\u0120Flow", "able", ".", "empty", "()", "\u0120.", "buffer", "(", "10", ",", "\u012010", ",", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", ",", "\u0120Sched", "ul", "ers", ".", "com", "put", "ation", "(),", "\u0120new", "\u0120Call", "able", "<", "List", "<", "Object", ">>", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120call", "()", "\u0120{", "\u0120throw", "\u0120new", "\u0120Test", "Exception", "();", "\u0120}", "\u0120})", "\u0120.", "test", "()", "\u0120.", "aw", "ait", "Done", "(", "5", ",", "\u0120Time", "Unit", ".", "SEC", "ON", "DS", ")", "\u0120.", "assert", "Failure", "(", "Test", "Exception", ".", "class", ")", "\u0120;"]}
{"function": "private Image getImageForDraw() { if (sprite.look.getLookData() != null) { if (sprite.look.getLookData().getCollisionInformation().getLeftBubblePos() == null || sprite.look.getLookData().getCollisionInformation().getRightBubblePos() == null) { sprite.look.getLookData().getCollisionInformation().loadOrCreateCollisionPolygon(); } CollisionInformation collisionInformation = sprite.look.getLookData().getCollisionInformation(); Pair<Integer, Integer> bubblePosRight = collisionInformation.getRightBubblePos(); Pair<Integer, Integer> bubblePosLeft = collisionInformation.getLeftBubblePos(); imageLeft.setX(calculateLeftImageX(bubblePosLeft.first)); imageLeft.setY(calculateImageY(bubblePosLeft.second)); imageRight.setX(calculateRightImageX(bubblePosRight.first)); imageRight.setY(calculateImageY(bubblePosRight.second)); } else { if (drawRight) { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() + (sprite.look .getWidthInUserInterfaceDimensionUnit() / 2)); } else { image.setX(sprite.look.getXInUserInterfaceDimensionUnit() - sprite.look .getWidthInUserInterfaceDimensionUnit() / 2 - image.getWidth()); } image.setY(sprite.look.getYInUserInterfaceDimensionUnit() + (sprite.look .getHeightInUserInterfaceDimensionUnit() / 2)); } return image; }", "text": "I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction()", "function_tokens": ["private", "\u0120Image", "\u0120get", "Image", "For", "Draw", "()", "\u0120{", "\u0120if", "\u0120(", "spr", "ite", ".", "look", ".", "get", "Look", "Data", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "spr", "ite", ".", "look", ".", "get", "Look", "Data", "().", "get", "Coll", "ision", "Information", "().", "get", "Left", "B", "ub", "ble", "Pos", "()", "\u0120==", "\u0120null", "\u0120||", "\u0120sprite", ".", "look", ".", "get", "Look", "Data", "().", "get", "Coll", "ision", "Information", "().", "get", "Right", "B", "ub", "ble", "Pos", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120sprite", ".", "look", ".", "get", "Look", "Data", "().", "get", "Coll", "ision", "Information", "().", "load", "Or", "Create", "Coll", "ision", "Poly", "gon", "();", "\u0120}", "\u0120Coll", "ision", "Information", "\u0120collision", "Information", "\u0120=", "\u0120sprite", ".", "look", ".", "get", "Look", "Data", "().", "get", "Coll", "ision", "Information", "();", "\u0120Pair", "<", "Integer", ",", "\u0120Integer", ">", "\u0120bubble", "Pos", "Right", "\u0120=", "\u0120collision", "Information", ".", "get", "Right", "B", "ub", "ble", "Pos", "();", "\u0120Pair", "<", "Integer", ",", "\u0120Integer", ">", "\u0120bubble", "Pos", "Left", "\u0120=", "\u0120collision", "Information", ".", "get", "Left", "B", "ub", "ble", "Pos", "();", "\u0120image", "Left", ".", "set", "X", "(", "cal", "cul", "ate", "Left", "Image", "X", "(", "bub", "ble", "Pos", "Left", ".", "first", "));", "\u0120image", "Left", ".", "set", "Y", "(", "cal", "cul", "ate", "Image", "Y", "(", "bub", "ble", "Pos", "Left", ".", "second", "));", "\u0120image", "Right", ".", "set", "X", "(", "cal", "cul", "ate", "Right", "Image", "X", "(", "bub", "ble", "Pos", "Right", ".", "first", "));", "\u0120image", "Right", ".", "set", "Y", "(", "cal", "cul", "ate", "Image", "Y", "(", "bub", "ble", "Pos", "Right", ".", "second", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "draw", "Right", ")", "\u0120{", "\u0120image", ".", "set", "X", "(", "spr", "ite", ".", "look", ".", "get", "X", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120+", "\u0120(", "spr", "ite", ".", "look", "\u0120.", "get", "Width", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120/", "\u01202", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120image", ".", "set", "X", "(", "spr", "ite", ".", "look", ".", "get", "X", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120-", "\u0120sprite", ".", "look", "\u0120.", "get", "Width", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120/", "\u01202", "\u0120-", "\u0120image", ".", "get", "Width", "());", "\u0120}", "\u0120image", ".", "set", "Y", "(", "spr", "ite", ".", "look", ".", "get", "Y", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120+", "\u0120(", "spr", "ite", ".", "look", "\u0120.", "get", "Height", "In", "User", "Interface", "Dim", "ension", "Unit", "()", "\u0120/", "\u01202", "));", "\u0120}", "\u0120return", "\u0120image", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120would", "\u0120prefer", "\u0120the", "\u0120use", "\u0120of", "\u0120local", "\u0120variables", "\u0120to", "\u0120resolve", "\u0120calls", "\u0120to", "\u0120something", ".", "something", "else", ".", "some", "function", "()"]}
{"function": "public static User toUser(DecodedJWT jwt) { final String subject = jwt.getSubject(); final List<Role> roles = jwt.getClaims().entrySet().stream() .filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) .map(entry -> { final String roleName = entry.getKey(); final Claim claim = entry.getValue(); final List<Permission> permissions = claim.asList(String.class).stream().map(Permission::valueOf).collect(Collectors.toList()); return new Role(roleName.substring(roleName.indexOf(\"_\") + 1, roleName.length()), permissions); }).collect(Collectors.toList()); return new User(subject, roles); }", "text": "You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,", "function_tokens": ["public", "\u0120static", "\u0120User", "\u0120to", "User", "(", "Dec", "oded", "J", "WT", "\u0120j", "wt", ")", "\u0120{", "\u0120final", "\u0120String", "\u0120subject", "\u0120=", "\u0120j", "wt", ".", "get", "Subject", "();", "\u0120final", "\u0120List", "<", "Role", ">", "\u0120roles", "\u0120=", "\u0120j", "wt", ".", "get", "Claim", "s", "().", "entry", "Set", "().", "stream", "()", "\u0120.", "filter", "(", "entry", "\u0120->", "\u0120entry", ".", "get", "Key", "().", "st", "arts", "With", "(", "RO", "LE", "_", "P", "REF", "IX", "))", "\u0120.", "map", "(", "entry", "\u0120->", "\u0120{", "\u0120final", "\u0120String", "\u0120role", "Name", "\u0120=", "\u0120entry", ".", "get", "Key", "();", "\u0120final", "\u0120Claim", "\u0120claim", "\u0120=", "\u0120entry", ".", "get", "Value", "();", "\u0120final", "\u0120List", "<", "Per", "mission", ">", "\u0120permissions", "\u0120=", "\u0120claim", ".", "as", "List", "(", "String", ".", "class", ").", "stream", "().", "map", "(", "Per", "mission", "::", "value", "Of", ").", "collect", "(", "Collect", "ors", ".", "to", "List", "());", "\u0120return", "\u0120new", "\u0120Role", "(", "role", "Name", ".", "sub", "string", "(", "role", "Name", ".", "index", "Of", "(\"", "_", "\")", "\u0120+", "\u01201", ",", "\u0120role", "Name", ".", "length", "()", "),", "\u0120permissions", ");", "\u0120}", ").", "collect", "(", "Collect", "ors", ".", "to", "List", "());", "\u0120return", "\u0120new", "\u0120User", "(", "subject", ",", "\u0120roles", ");", "\u0120}"], "docstring_tokens": ["You", "\u0120could", "\u0120just", "\u0120use", "\u0120String", ".", "replace", "()", "\u0120to", "\u0120replace", "\u0120the", "\u0120RO", "LE", "_", "P", "REF", "IX", "\u0120with", "\u0120an", "\u0120empty", "\u0120String", "\u0120and", "\u0120use", "\u0120the", "\u0120resulting", "\u0120value", "\u0120as", "\u0120the", "\u0120role", "\u0120name", ","]}
{"function": "public void readInfo() { this.mvnInfo = null; this.mvnName = null; if (!infofile.exists()) { return; } try { final String content = FileUtils.readFileToString(infofile, Charsets.UTF_8); final int i = content.indexOf(','); LOGGER.log(Level.FINE, \"The \" + name + \" artifact info cached is: \" + content); if (i != -1) { this.mvnInfo = content.substring(0, i); this.mvnName = content.substring(i + 1); } else { LOGGER.log(Level.WARNING, \"The \" + name + \" artifact info is invalid\"); } } catch (IOException e) { LOGGER.log(Level.WARNING, \"The \" + name + \" artifact info failed to be loaded\", e); } }", "text": "you can use parameterized logging here", "function_tokens": ["public", "\u0120void", "\u0120read", "Info", "()", "\u0120{", "\u0120this", ".", "m", "v", "n", "Info", "\u0120=", "\u0120null", ";", "\u0120this", ".", "m", "v", "n", "Name", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(!", "inf", "of", "ile", ".", "ex", "ists", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120final", "\u0120String", "\u0120content", "\u0120=", "\u0120File", "Ut", "ils", ".", "read", "File", "To", "String", "(", "inf", "of", "ile", ",", "\u0120Ch", "ars", "ets", ".", "UTF", "_", "8", ");", "\u0120final", "\u0120int", "\u0120i", "\u0120=", "\u0120content", ".", "index", "Of", "(", "',", "');", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "FINE", ",", "\u0120\"", "The", "\u0120\"", "\u0120+", "\u0120name", "\u0120+", "\u0120\"", "\u0120artifact", "\u0120info", "\u0120cached", "\u0120is", ":", "\u0120\"", "\u0120+", "\u0120content", ");", "\u0120if", "\u0120(", "i", "\u0120!=", "\u0120-", "1", ")", "\u0120{", "\u0120this", ".", "m", "v", "n", "Info", "\u0120=", "\u0120content", ".", "sub", "string", "(", "0", ",", "\u0120i", ");", "\u0120this", ".", "m", "v", "n", "Name", "\u0120=", "\u0120content", ".", "sub", "string", "(", "i", "\u0120+", "\u01201", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "WARNING", ",", "\u0120\"", "The", "\u0120\"", "\u0120+", "\u0120name", "\u0120+", "\u0120\"", "\u0120artifact", "\u0120info", "\u0120is", "\u0120invalid", "\");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "log", "(", "Level", ".", "WARNING", ",", "\u0120\"", "The", "\u0120\"", "\u0120+", "\u0120name", "\u0120+", "\u0120\"", "\u0120artifact", "\u0120info", "\u0120failed", "\u0120to", "\u0120be", "\u0120loaded", "\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["you", "\u0120can", "\u0120use", "\u0120parameter", "ized", "\u0120logging", "\u0120here"]}
{"function": "private void refreshSignedOffBy() { String curText = commitText.getText(); if (signedOff) { commitText.setText(signOff(curText)); } else { String s = getSignedOff(); if (s != null) { curText = replaceSignOff(curText, s, EMPTY_STRING); if (curText.endsWith(Text.DELIMITER + Text.DELIMITER)) curText = curText.substring(0, curText.length() - Text.DELIMITER.length()); commitText.setText(curText); } } }", "text": "Style nit: unneeded curlies", "function_tokens": ["private", "\u0120void", "\u0120refresh", "S", "igned", "Off", "By", "()", "\u0120{", "\u0120String", "\u0120cur", "Text", "\u0120=", "\u0120commit", "Text", ".", "get", "Text", "();", "\u0120if", "\u0120(", "signed", "Off", ")", "\u0120{", "\u0120commit", "Text", ".", "set", "Text", "(", "sign", "Off", "(", "cur", "Text", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120s", "\u0120=", "\u0120get", "S", "igned", "Off", "();", "\u0120if", "\u0120(", "s", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120cur", "Text", "\u0120=", "\u0120replace", "Sign", "Off", "(", "cur", "Text", ",", "\u0120s", ",", "\u0120EMP", "TY", "_", "STR", "ING", ");", "\u0120if", "\u0120(", "cur", "Text", ".", "ends", "With", "(", "Text", ".", "D", "EL", "IM", "IT", "ER", "\u0120+", "\u0120Text", ".", "D", "EL", "IM", "IT", "ER", "))", "\u0120cur", "Text", "\u0120=", "\u0120cur", "Text", ".", "sub", "string", "(", "0", ",", "\u0120cur", "Text", ".", "length", "()", "\u0120-", "\u0120Text", ".", "D", "EL", "IM", "IT", "ER", ".", "length", "());", "\u0120commit", "Text", ".", "set", "Text", "(", "cur", "Text", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Style", "\u0120nit", ":", "\u0120un", "needed", "\u0120cur", "lies"]}
{"function": "public void put(String key, String value) { Assert.notNull(key, \"'key' must not be null.\"); Assert.notNull(value, \"'value' must not be null.\"); BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); ops.set(value); }", "text": "this.redisTemplate", "function_tokens": ["public", "\u0120void", "\u0120put", "(", "String", "\u0120key", ",", "\u0120String", "\u0120value", ")", "\u0120{", "\u0120Ass", "ert", ".", "not", "Null", "(", "key", ",", "\u0120\"'", "key", "'", "\u0120must", "\u0120not", "\u0120be", "\u0120null", ".\"", ");", "\u0120Ass", "ert", ".", "not", "Null", "(", "value", ",", "\u0120\"'", "value", "'", "\u0120must", "\u0120not", "\u0120be", "\u0120null", ".\"", ");", "\u0120Bound", "Value", "Oper", "ations", "<", "String", ",", "\u0120String", ">", "\u0120ops", "\u0120=", "\u0120red", "is", "Template", ".", "bound", "Value", "Ops", "(", "key", ");", "\u0120ops", ".", "set", "(", "value", ");", "\u0120}"], "docstring_tokens": ["this", ".", "red", "is", "Template"]}
{"function": "public ResponseEntity<?> createDilution(@RequestBody DilutionDto dilutionDto, UriComponentsBuilder b) throws IOException { if (dilutionDto == null) { log.error( \"Received null dilutionDto from front end; cannot convert to Dilution. Something likely went wrong in the JS DTO conversion.\"); throw new RestException(\"Cannot convert null to Dilution\", Status.BAD_REQUEST); } Long id = null; LibraryDilution dilution; try { dilution = Dtos.to(dilutionDto); dilution.setLibrary(libraryService.get(dilutionDto.getLibrary().getId())); id = populateAndSaveDilutionFromDto(dilutionDto, dilution, true); } catch (ConstraintViolationException e) { log.error(\"Error while creating dilution\", e); RestException restException = new RestException(e.getMessage(), Status.BAD_REQUEST); restException.addData(\"constraintName\", e.getConstraintName()); throw restException; } UriComponents uriComponents = b.path(\"/library/{id}\").buildAndExpand(dilution.getLibrary().getId()); HttpHeaders headers = new HttpHeaders(); headers.setLocation(uriComponents.toUri()); headers.set(\"Id\", id.toString()); return new ResponseEntity<>(headers, HttpStatus.CREATED); }", "text": "fetch should already happen in Service", "function_tokens": ["public", "\u0120Response", "Entity", "<?", ">", "\u0120create", "D", "il", "ution", "(", "@", "Request", "Body", "\u0120Dil", "ution", "D", "to", "\u0120dil", "ution", "D", "to", ",", "\u0120Uri", "Comp", "onents", "Builder", "\u0120b", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "d", "il", "ution", "D", "to", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120log", ".", "error", "(", "\u0120\"", "Re", "ceived", "\u0120null", "\u0120dil", "ution", "D", "to", "\u0120from", "\u0120front", "\u0120end", ";", "\u0120cannot", "\u0120convert", "\u0120to", "\u0120Dil", "ution", ".", "\u0120Something", "\u0120likely", "\u0120went", "\u0120wrong", "\u0120in", "\u0120the", "\u0120JS", "\u0120D", "TO", "\u0120conversion", ".\"", ");", "\u0120throw", "\u0120new", "\u0120Rest", "Exception", "(\"", "C", "annot", "\u0120convert", "\u0120null", "\u0120to", "\u0120Dil", "ution", "\",", "\u0120Status", ".", "B", "AD", "_", "RE", "QUEST", ");", "\u0120}", "\u0120Long", "\u0120id", "\u0120=", "\u0120null", ";", "\u0120Library", "D", "il", "ution", "\u0120dil", "ution", ";", "\u0120try", "\u0120{", "\u0120dil", "ution", "\u0120=", "\u0120D", "t", "os", ".", "to", "(", "d", "il", "ution", "D", "to", ");", "\u0120dil", "ution", ".", "set", "Library", "(", "library", "Service", ".", "get", "(", "d", "il", "ution", "D", "to", ".", "get", "Library", "().", "get", "Id", "()", "));", "\u0120id", "\u0120=", "\u0120populate", "And", "Save", "D", "il", "ution", "From", "D", "to", "(", "d", "il", "ution", "D", "to", ",", "\u0120dil", "ution", ",", "\u0120true", ");", "\u0120}", "\u0120catch", "\u0120(", "Con", "str", "aint", "Viol", "ation", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "Error", "\u0120while", "\u0120creating", "\u0120dil", "ution", "\",", "\u0120e", ");", "\u0120Rest", "Exception", "\u0120rest", "Exception", "\u0120=", "\u0120new", "\u0120Rest", "Exception", "(", "e", ".", "get", "Message", "(),", "\u0120Status", ".", "B", "AD", "_", "RE", "QUEST", ");", "\u0120rest", "Exception", ".", "add", "Data", "(\"", "con", "str", "aint", "Name", "\",", "\u0120e", ".", "get", "Con", "str", "aint", "Name", "());", "\u0120throw", "\u0120rest", "Exception", ";", "\u0120}", "\u0120Uri", "Comp", "onents", "\u0120ur", "i", "Comp", "onents", "\u0120=", "\u0120b", ".", "path", "(\"", "/", "library", "/", "{", "id", "}", "\").", "build", "And", "Exp", "and", "(", "d", "il", "ution", ".", "get", "Library", "().", "get", "Id", "());", "\u0120H", "ttp", "Head", "ers", "\u0120headers", "\u0120=", "\u0120new", "\u0120H", "ttp", "Head", "ers", "();", "\u0120headers", ".", "set", "Location", "(", "uri", "Comp", "onents", ".", "to", "U", "ri", "());", "\u0120headers", ".", "set", "(\"", "Id", "\",", "\u0120id", ".", "to", "String", "());", "\u0120return", "\u0120new", "\u0120Response", "Entity", "<", ">(", "headers", ",", "\u0120H", "ttp", "Status", ".", "CRE", "ATED", ");", "\u0120}"], "docstring_tokens": ["f", "etch", "\u0120should", "\u0120already", "\u0120happen", "\u0120in", "\u0120Service"]}
{"function": "public void start(SocketAddress endpoint) throws IOException { if (isListening()) { throw new IllegalStateException(\"Cannot start when already listening for messages\"); } bindToAddress(endpoint); new Thread(() -> { while (!configServerSocket.isClosed()) { acceptConnection(); } }, \"configurationListener\").start(); }", "text": "thread.isUnterupted not necessary?", "function_tokens": ["public", "\u0120void", "\u0120start", "(", "Socket", "Address", "\u0120endpoint", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "is", "List", "ening", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "C", "annot", "\u0120start", "\u0120when", "\u0120already", "\u0120listening", "\u0120for", "\u0120messages", "\");", "\u0120}", "\u0120bind", "To", "Address", "(", "end", "point", ");", "\u0120new", "\u0120Thread", "(", "()", "\u0120->", "\u0120{", "\u0120while", "\u0120(!", "config", "Server", "Socket", ".", "is", "Cl", "osed", "())", "\u0120{", "\u0120accept", "Connection", "();", "\u0120}", "\u0120},", "\u0120\"", "config", "uration", "Listener", "\").", "start", "();", "\u0120}"], "docstring_tokens": ["thread", ".", "is", "Un", "ter", "upt", "ed", "\u0120not", "\u0120necessary", "?"]}
{"function": "public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(\"Launch batch job (makeUnique=false) twice\"); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\"); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(\"job launch --name \" + MY_JOB); System.out.println(\"*************************\" + result.getException().getMessage()); assertThat( result.getException().getMessage(), containsString(\"A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters.\")); }", "text": "I assume this was meant to be removed?", "function_tokens": ["public", "\u0120void", "\u0120test", "Launch", "Job", "Tw", "ice", "Where", "Make", "Unique", "Is", "False", "()", "\u0120{", "\u0120logger", ".", "info", "(\"", "Launch", "\u0120batch", "\u0120job", "\u0120(", "make", "Unique", "=", "false", ")", "\u0120twice", "\");", "\u0120execute", "Job", "Create", "(", "MY", "_", "J", "OB", ",", "\u0120J", "OB", "_", "W", "ITH", "_", "PAR", "AM", "ET", "ERS", "_", "DES", "CRIP", "TOR", "\u0120+", "\u0120\"", "\u0120--", "make", "Unique", "=", "false", "\");", "\u0120check", "For", "Job", "In", "List", "(", "MY", "_", "J", "OB", ",", "\u0120J", "OB", "_", "W", "ITH", "_", "PAR", "AM", "ET", "ERS", "_", "DES", "CRIP", "TOR", "\u0120+", "\u0120\"", "\u0120--", "make", "Unique", "=", "false", "\",", "\u0120true", ");", "\u0120execute", "Job", "Launch", "(", "MY", "_", "J", "OB", ");", "\u0120Command", "Result", "\u0120result", "\u0120=", "\u0120execute", "Command", "Ex", "pecting", "Failure", "(\"", "job", "\u0120launch", "\u0120--", "name", "\u0120\"", "\u0120+", "\u0120MY", "_", "J", "OB", ");", "\u0120System", ".", "out", ".", "println", "(\"", "****************", "********", "*", "\"", "\u0120+", "\u0120result", ".", "get", "Exception", "().", "get", "Message", "());", "\u0120assert", "That", "(", "\u0120result", ".", "get", "Exception", "().", "get", "Message", "(),", "\u0120contains", "String", "(\"", "A", "\u0120job", "\u0120instance", "\u0120already", "\u0120exists", "\u0120and", "\u0120is", "\u0120complete", "\u0120for", "\u0120parameters", "={", "}.", "\u0120If", "\u0120you", "\u0120want", "\u0120to", "\u0120run", "\u0120this", "\u0120job", "\u0120again", ",", "\u0120change", "\u0120the", "\u0120parameters", ".\"", "));", "\u0120}"], "docstring_tokens": ["I", "\u0120assume", "\u0120this", "\u0120was", "\u0120meant", "\u0120to", "\u0120be", "\u0120removed", "?"]}
{"function": "public List<GenericVertex> resolve(GraphService graphService, SearchCriteria searchCriteria) { GenericGraph graph = graphService.getGraph(searchCriteria.getNamespace()); return graph.getVertices() .stream() .map(ApplicationVertex::new) .filter(v -> filter(v, searchCriteria.getCriteria())) .map(ApplicationVertex::asGenericVertex) .collect(Collectors.toList()); }", "text": "What do we do, if the result is null?", "function_tokens": ["public", "\u0120List", "<", "Generic", "Ver", "tex", ">", "\u0120resolve", "(", "Graph", "Service", "\u0120graph", "Service", ",", "\u0120Search", "Crit", "eria", "\u0120search", "Crit", "eria", ")", "\u0120{", "\u0120Generic", "Graph", "\u0120graph", "\u0120=", "\u0120graph", "Service", ".", "get", "Graph", "(", "search", "Crit", "eria", ".", "get", "Names", "pace", "());", "\u0120return", "\u0120graph", ".", "get", "Vert", "ices", "()", "\u0120.", "stream", "()", "\u0120.", "map", "(", "Application", "Ver", "tex", "::", "new", ")", "\u0120.", "filter", "(", "v", "\u0120->", "\u0120filter", "(", "v", ",", "\u0120search", "Crit", "eria", ".", "get", "Crit", "eria", "()", "))", "\u0120.", "map", "(", "Application", "Ver", "tex", "::", "as", "Generic", "Ver", "tex", ")", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "List", "());", "\u0120}"], "docstring_tokens": ["What", "\u0120do", "\u0120we", "\u0120do", ",", "\u0120if", "\u0120the", "\u0120result", "\u0120is", "\u0120null", "?"]}
{"function": "protected Location manageRecursive(Location loc, final ManagementTransitionMode initialMode) { AccessController.Response access = managementContext.getAccessController().canManageLocation(loc); if (!access.isAllowed()) { throw new IllegalStateException(\"Access controller forbids management of \"+loc+\": \"+access.getMsg()); } if (log.isDebugEnabled()) { String msg = \"Managing location \" + loc + \" (\"+initialMode+\"), from \" + Tasks.current()+\" / \"+Entitlements.getEntitlementContext(); long count = LOCATION_CNT.incrementAndGet(); if (count % 100 == 0) { log.debug(msg, new Exception(\"Informational stack trace of call to manage location \"+loc+\" (\"+count+\" calls; \"+getLocations().size()+\" currently managed)\")); } else { log.debug(msg); } } recursively(loc, new Predicate<AbstractLocation>() { public boolean apply(AbstractLocation it) { ManagementTransitionMode mode = getLastManagementTransitionMode(it.getId()); if (mode==null) { setManagementTransitionMode(it, mode = initialMode); } if (it.isManaged()) { if (mode==ManagementTransitionMode.CREATING) { return false; } else { } } boolean result = manageNonRecursive(it, null); if (result) { it.setManagementContext(managementContext); if (!mode.isReadOnly()) { it.onManagementStarted(); recordLocationEvent(it, Lifecycle.CREATED); } managementContext.getRebindManager().getChangeListener().onManaged(it); } return result; } }); return loc; }", "text": "I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.", "function_tokens": ["protected", "\u0120Location", "\u0120manage", "Rec", "ursive", "(", "Location", "\u0120loc", ",", "\u0120final", "\u0120Management", "Trans", "ition", "Mode", "\u0120initial", "Mode", ")", "\u0120{", "\u0120Access", "Controller", ".", "Response", "\u0120access", "\u0120=", "\u0120management", "Context", ".", "get", "Access", "Controller", "().", "can", "Man", "age", "Location", "(", "loc", ");", "\u0120if", "\u0120(!", "access", ".", "is", "All", "owed", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "Access", "\u0120controller", "\u0120forbids", "\u0120management", "\u0120of", "\u0120\"+", "loc", "+", "\":", "\u0120\"+", "access", ".", "get", "Msg", "());", "\u0120}", "\u0120if", "\u0120(", "log", ".", "is", "Debug", "Enabled", "())", "\u0120{", "\u0120String", "\u0120msg", "\u0120=", "\u0120\"", "Man", "aging", "\u0120location", "\u0120\"", "\u0120+", "\u0120loc", "\u0120+", "\u0120\"", "\u0120(\"", "+", "initial", "Mode", "+", "\"),", "\u0120from", "\u0120\"", "\u0120+", "\u0120T", "asks", ".", "current", "()", "+", "\"", "\u0120/", "\u0120\"+", "Ent", "itle", "ments", ".", "get", "Ent", "it", "lement", "Context", "();", "\u0120long", "\u0120count", "\u0120=", "\u0120LOC", "ATION", "_", "C", "NT", ".", "incre", "ment", "And", "Get", "();", "\u0120if", "\u0120(", "count", "\u0120%", "\u0120100", "\u0120==", "\u01200", ")", "\u0120{", "\u0120log", ".", "debug", "(", "msg", ",", "\u0120new", "\u0120Exception", "(\"", "In", "form", "ational", "\u0120stack", "\u0120trace", "\u0120of", "\u0120call", "\u0120to", "\u0120manage", "\u0120location", "\u0120\"+", "loc", "+", "\"", "\u0120(\"", "+", "count", "+", "\"", "\u0120calls", ";", "\u0120\"+", "get", "L", "ocations", "().", "size", "()", "+", "\"", "\u0120currently", "\u0120managed", ")", "\")", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "debug", "(", "msg", ");", "\u0120}", "\u0120}", "\u0120rec", "urs", "ively", "(", "loc", ",", "\u0120new", "\u0120Pred", "icate", "<", "Abstract", "Location", ">", "()", "\u0120{", "\u0120public", "\u0120boolean", "\u0120apply", "(", "Abstract", "Location", "\u0120it", ")", "\u0120{", "\u0120Management", "Trans", "ition", "Mode", "\u0120mode", "\u0120=", "\u0120get", "Last", "Management", "Trans", "ition", "Mode", "(", "it", ".", "get", "Id", "());", "\u0120if", "\u0120(", "mode", "==", "null", ")", "\u0120{", "\u0120set", "Management", "Trans", "ition", "Mode", "(", "it", ",", "\u0120mode", "\u0120=", "\u0120initial", "Mode", ");", "\u0120}", "\u0120if", "\u0120(", "it", ".", "is", "Man", "aged", "())", "\u0120{", "\u0120if", "\u0120(", "mode", "==", "Management", "Trans", "ition", "Mode", ".", "CRE", "ATING", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120}", "\u0120}", "\u0120boolean", "\u0120result", "\u0120=", "\u0120manage", "Non", "Rec", "ursive", "(", "it", ",", "\u0120null", ");", "\u0120if", "\u0120(", "result", ")", "\u0120{", "\u0120it", ".", "set", "Management", "Context", "(", "management", "Context", ");", "\u0120if", "\u0120(!", "mode", ".", "is", "Read", "Only", "())", "\u0120{", "\u0120it", ".", "on", "Management", "Start", "ed", "();", "\u0120record", "Location", "Event", "(", "it", ",", "\u0120Lif", "ecycle", ".", "CRE", "ATED", ");", "\u0120}", "\u0120management", "Context", ".", "get", "Reb", "ind", "Manager", "().", "get", "Change", "Listener", "().", "on", "Man", "aged", "(", "it", ");", "\u0120}", "\u0120return", "\u0120result", ";", "\u0120}", "\u0120});", "\u0120return", "\u0120loc", ";", "\u0120}"], "docstring_tokens": ["I", "'d", "\u0120do", "\u0120the", "\u0120increment", "\u0120outside", "\u0120of", "\u0120the", "\u0120if", "\u0120(", "log", ".", "is", "Debug", "Enabled", ").", "\u0120The", "\u0120call", "\u0120is", "\u0120cheap", ",", "\u0120and", "\u0120if", "\u0120the", "\u0120log", "\u0120level", "\u0120gets", "\u0120changed", "\u0120on", "-", "the", "-", "fly", "\u0120to", "\u0120debug", "\u0120then", "\u0120we", "\u0120want", "\u0120the", "\u0120message", "\u0120to", "\u0120have", "\u0120an", "\u0120accurate", "\u0120call", "\u0120count", "."]}
{"function": "void start(int slot) { mSlot = slot; int error = isValid(); if (error == SUCCESS) { Log.d(TAG, \"Starting keepalive \" + mSlot + \" on \" + mNai.name()); switch (mType) { case TYPE_NATT: mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; case TYPE_TCP: mTcpController.startSocketMonitor(mFd, this, mSlot); mNai.asyncChannel .sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0 , mPacket); mNai.asyncChannel .sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket); break; default: Log.wtf(TAG, \"Starting keepalive with unknown type: \" + mType); } mStartedState = STARTING; } else { handleStopKeepalive(mNai, mSlot, error); return; } }", "text": "Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?", "function_tokens": ["void", "\u0120start", "(", "int", "\u0120slot", ")", "\u0120{", "\u0120m", "Slot", "\u0120=", "\u0120slot", ";", "\u0120int", "\u0120error", "\u0120=", "\u0120is", "Valid", "();", "\u0120if", "\u0120(", "error", "\u0120==", "\u0120SU", "CC", "ESS", ")", "\u0120{", "\u0120Log", ".", "d", "(", "TAG", ",", "\u0120\"", "Starting", "\u0120keep", "al", "ive", "\u0120\"", "\u0120+", "\u0120m", "Slot", "\u0120+", "\u0120\"", "\u0120on", "\u0120\"", "\u0120+", "\u0120m", "N", "ai", ".", "name", "());", "\u0120switch", "\u0120(", "m", "Type", ")", "\u0120{", "\u0120case", "\u0120TYPE", "_", "N", "ATT", ":", "\u0120m", "N", "ai", ".", "as", "ync", "Channel", "\u0120.", "send", "Message", "(", "C", "MD", "_", "ST", "ART", "_", "S", "OCK", "ET", "_", "K", "EEP", "AL", "IVE", ",", "\u0120slot", ",", "\u0120m", "Inter", "val", ",", "\u0120m", "P", "acket", ");", "\u0120break", ";", "\u0120case", "\u0120TYPE", "_", "TC", "P", ":", "\u0120m", "T", "cp", "Controller", ".", "start", "Socket", "Monitor", "(", "m", "F", "d", ",", "\u0120this", ",", "\u0120m", "Slot", ");", "\u0120m", "N", "ai", ".", "as", "ync", "Channel", "\u0120.", "send", "Message", "(", "C", "MD", "_", "ADD", "_", "K", "EEP", "AL", "IVE", "_", "P", "ACK", "ET", "_", "FIL", "TER", ",", "\u0120slot", ",", "\u01200", "\u0120,", "\u0120m", "P", "acket", ");", "\u0120m", "N", "ai", ".", "as", "ync", "Channel", "\u0120.", "send", "Message", "(", "C", "MD", "_", "ST", "ART", "_", "S", "OCK", "ET", "_", "K", "EEP", "AL", "IVE", ",", "\u0120slot", ",", "\u0120m", "Inter", "val", ",", "\u0120m", "P", "acket", ");", "\u0120break", ";", "\u0120default", ":", "\u0120Log", ".", "w", "tf", "(", "TAG", ",", "\u0120\"", "Starting", "\u0120keep", "al", "ive", "\u0120with", "\u0120unknown", "\u0120type", ":", "\u0120\"", "\u0120+", "\u0120m", "Type", ");", "\u0120}", "\u0120m", "Start", "ed", "State", "\u0120=", "\u0120START", "ING", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120handle", "Stop", "Keep", "al", "ive", "(", "m", "N", "ai", ",", "\u0120m", "Slot", ",", "\u0120error", ");", "\u0120return", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["Return", "\u0120early", "\u0120so", "\u0120you", "\u0120don", "'t", "\u0120enter", "\u0120START", "ING", "\u0120state", "?", "\u0120Call", "\u0120handle", "Stop", "Keep", "al", "ive", "\u0120with", "\u0120ERROR", "_", "IN", "VAL", "ID", "_", "P", "ACK", "ET", "?"]}
{"function": "public NewTmfViewAction(TmfView view) { super(MessageFormat.format(Messages.TmfView_NewTmfViewNameText, view.getTitle().toLowerCase()), IAction.AS_PUSH_BUTTON); setToolTipText(MessageFormat.format(Messages.TmfView_NewTmfViewToolTipText, view.getTitle())); }", "text": "I think we always display view names capitalized to users.", "function_tokens": ["public", "\u0120New", "T", "m", "f", "View", "Action", "(", "T", "m", "f", "View", "\u0120view", ")", "\u0120{", "\u0120super", "(", "Message", "Format", ".", "format", "(", "Mess", "ages", ".", "T", "m", "f", "View", "_", "New", "T", "m", "f", "View", "Name", "Text", ",", "\u0120view", ".", "get", "Title", "().", "to", "Lower", "Case", "()", "),", "\u0120I", "Action", ".", "AS", "_", "P", "USH", "_", "BUT", "TON", ");", "\u0120set", "Tool", "Tip", "Text", "(", "Message", "Format", ".", "format", "(", "Mess", "ages", ".", "T", "m", "f", "View", "_", "New", "T", "m", "f", "View", "Tool", "Tip", "Text", ",", "\u0120view", ".", "get", "Title", "()", "));", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120always", "\u0120display", "\u0120view", "\u0120names", "\u0120capital", "ized", "\u0120to", "\u0120users", "."]}
{"function": "public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(\"message must be non-empty\"); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(); } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }", "text": "Unrelated change. Should be in a separate commit.", "function_tokens": ["public", "\u0120Change", "Info", "\u0120apply", "(", "Rev", "ision", "Resource", "\u0120r", "src", ",", "\u0120Input", "\u0120input", ")", "\u0120throws", "\u0120Bad", "Request", "Exception", ",", "\u0120Resource", "Conf", "lict", "Exception", ",", "\u0120Email", "Exception", ",", "\u0120Or", "m", "Exception", ",", "\u0120Resource", "Not", "Found", "Exception", ",", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "Str", "ings", ".", "is", "Null", "Or", "Empty", "(", "input", ".", "message", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Bad", "Request", "Exception", "(\"", "message", "\u0120must", "\u0120be", "\u0120non", "-", "empty", "\");", "\u0120}", "\u0120final", "\u0120Rep", "ository", "\u0120git", ";", "\u0120try", "\u0120{", "\u0120git", "\u0120=", "\u0120git", "Manager", ".", "open", "Rep", "ository", "(", "rs", "rc", ".", "get", "Change", "().", "get", "Project", "());", "\u0120}", "\u0120catch", "\u0120(", "Rep", "ository", "Not", "Found", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Not", "Found", "Exception", "();", "\u0120}", "\u0120try", "\u0120{", "\u0120return", "\u0120json", ".", "format", "(", "Change", "Ut", "il", ".", "edit", "Comm", "it", "Message", "(", "\u0120r", "src", ".", "get", "Patch", "Set", "().", "get", "Id", "(),", "\u0120r", "src", ".", "get", "Control", "().", "get", "Ref", "Control", "(),", "\u0120(", "Ident", "ified", "User", ")", "\u0120r", "src", ".", "get", "Control", "().", "get", "Current", "User", "(),", "\u0120input", ".", "message", ",", "\u0120db", "Provider", ".", "get", "(),", "\u0120commit", "Message", "Edited", "S", "ender", "Factory", ",", "\u0120git", ",", "\u0120my", "Ident", ",", "\u0120patch", "Set", "In", "ser", "ter", "Factory", "));", "\u0120}", "\u0120catch", "\u0120(", "Invalid", "Change", "Operation", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Bad", "Request", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "Missing", "Object", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Conf", "lict", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "In", "correct", "Object", "Type", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Conf", "lict", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "Patch", "Set", "Info", "Not", "Available", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Conf", "lict", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "No", "Such", "Change", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Resource", "Not", "Found", "Exception", "();", "\u0120}", "\u0120finally", "\u0120{", "\u0120git", ".", "close", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Un", "related", "\u0120change", ".", "\u0120Should", "\u0120be", "\u0120in", "\u0120a", "\u0120separate", "\u0120commit", "."]}
{"function": "public CompletableFuture<Snapshot> copyTo(FileWrapper target, UserContext context) { ensureUnmodified(); NetworkAccess network = context.network; SafeRandom random = context.crypto.random; Hasher hasher = context.crypto.hasher; if (! target.isDirectory()) { return Futures.errored(new IllegalStateException(\"CopyTo target \" + target + \" must be a directory\")); } return context.network.synchronizer.applyComplexUpdate(target.owner(), target.signingPair(), (base, committer) -> { return target.hasChildWithName(base.get(target.writer()).props, getFileProperties().name, network).thenCompose(childExists -> { if (childExists) { CompletableFuture<Snapshot> error = new CompletableFuture<>(); error.completeExceptionally(new IllegalStateException(\"CopyTo target \" + target + \" already has child with name \" + getFileProperties().name)); return error; } if (isDirectory()) { byte[] newMapKey = random.randomBytes(32); SymmetricKey newBaseKey = SymmetricKey.random(); SymmetricKey newWriterBaseKey = SymmetricKey.random(); WritableAbsoluteCapability newCap = new WritableAbsoluteCapability(target.owner(), target.writer(), newMapKey, newBaseKey, newWriterBaseKey); SymmetricKey newParentParentKey = target.getParentKey(); return pointer.fileAccess.copyTo(base, committer, pointer.capability, newBaseKey, target.writableFilePointer(), target.entryWriter, newParentParentKey, newMapKey, network, random, hasher) .thenCompose(updatedBase -> { return target.addLinkTo(updatedBase, committer, getName(), newCap, network, random, hasher); }); } else { return base.withWriter(owner(), writer(), network).thenCompose(snapshot -> getInputStream(snapshot.get(writer()).props, network, random, x -> {}) .thenCompose(stream -> target.uploadFileSection(snapshot, committer, getName(), stream, false, 0, getSize(), Optional.empty(), false, network, random, hasher, x -> {}, target.generateChildLocations(props.getNumberOfChunks(), random)))); } }); }); }", "text": "this may impact web-ui code. Do we want to expose Snapshot in API?", "function_tokens": ["public", "\u0120Com", "ple", "table", "Future", "<", "Snap", "shot", ">", "\u0120copy", "To", "(", "File", "Wra", "pper", "\u0120target", ",", "\u0120User", "Context", "\u0120context", ")", "\u0120{", "\u0120ensure", "Un", "modified", "();", "\u0120Network", "Access", "\u0120network", "\u0120=", "\u0120context", ".", "network", ";", "\u0120Safe", "Random", "\u0120random", "\u0120=", "\u0120context", ".", "crypt", "o", ".", "random", ";", "\u0120Has", "her", "\u0120has", "her", "\u0120=", "\u0120context", ".", "crypt", "o", ".", "has", "her", ";", "\u0120if", "\u0120(!", "\u0120target", ".", "is", "Directory", "())", "\u0120{", "\u0120return", "\u0120Fut", "ures", ".", "er", "rored", "(", "new", "\u0120Illegal", "State", "Exception", "(\"", "Copy", "To", "\u0120target", "\u0120\"", "\u0120+", "\u0120target", "\u0120+", "\u0120\"", "\u0120must", "\u0120be", "\u0120a", "\u0120directory", "\")", ");", "\u0120}", "\u0120return", "\u0120context", ".", "network", ".", "syn", "chron", "izer", ".", "apply", "Com", "plex", "Update", "(", "target", ".", "owner", "(),", "\u0120target", ".", "sign", "ing", "P", "air", "(),", "\u0120(", "base", ",", "\u0120comm", "itter", ")", "\u0120->", "\u0120{", "\u0120return", "\u0120target", ".", "has", "Child", "With", "Name", "(", "base", ".", "get", "(", "target", ".", "writer", "()", ").", "pro", "ps", ",", "\u0120get", "File", "Pro", "perties", "().", "name", ",", "\u0120network", ").", "then", "Comp", "ose", "(", "child", "Ex", "ists", "\u0120->", "\u0120{", "\u0120if", "\u0120(", "child", "Ex", "ists", ")", "\u0120{", "\u0120Com", "ple", "table", "Future", "<", "Snap", "shot", ">", "\u0120error", "\u0120=", "\u0120new", "\u0120Com", "ple", "table", "Future", "<", ">", "();", "\u0120error", ".", "complete", "Exception", "ally", "(", "new", "\u0120Illegal", "State", "Exception", "(\"", "Copy", "To", "\u0120target", "\u0120\"", "\u0120+", "\u0120target", "\u0120+", "\u0120\"", "\u0120already", "\u0120has", "\u0120child", "\u0120with", "\u0120name", "\u0120\"", "\u0120+", "\u0120get", "File", "Pro", "perties", "().", "name", "));", "\u0120return", "\u0120error", ";", "\u0120}", "\u0120if", "\u0120(", "is", "Directory", "())", "\u0120{", "\u0120byte", "[]", "\u0120new", "Map", "Key", "\u0120=", "\u0120random", ".", "random", "Bytes", "(", "32", ");", "\u0120Sy", "mm", "etric", "Key", "\u0120new", "Base", "Key", "\u0120=", "\u0120Sy", "mm", "etric", "Key", ".", "random", "();", "\u0120Sy", "mm", "etric", "Key", "\u0120new", "Writer", "Base", "Key", "\u0120=", "\u0120Sy", "mm", "etric", "Key", ".", "random", "();", "\u0120Writ", "able", "Abs", "olute", "Cap", "ability", "\u0120new", "Cap", "\u0120=", "\u0120new", "\u0120Writ", "able", "Abs", "olute", "Cap", "ability", "(", "target", ".", "owner", "(),", "\u0120target", ".", "writer", "(),", "\u0120new", "Map", "Key", ",", "\u0120new", "Base", "Key", ",", "\u0120new", "Writer", "Base", "Key", ");", "\u0120Sy", "mm", "etric", "Key", "\u0120new", "Parent", "Parent", "Key", "\u0120=", "\u0120target", ".", "get", "Parent", "Key", "();", "\u0120return", "\u0120pointer", ".", "file", "Access", ".", "copy", "To", "(", "base", ",", "\u0120comm", "itter", ",", "\u0120pointer", ".", "cap", "ability", ",", "\u0120new", "Base", "Key", ",", "\u0120target", ".", "writ", "able", "File", "Po", "inter", "(),", "\u0120target", ".", "entry", "Writer", ",", "\u0120new", "Parent", "Parent", "Key", ",", "\u0120new", "Map", "Key", ",", "\u0120network", ",", "\u0120random", ",", "\u0120has", "her", ")", "\u0120.", "then", "Comp", "ose", "(", "updated", "Base", "\u0120->", "\u0120{", "\u0120return", "\u0120target", ".", "add", "Link", "To", "(", "updated", "Base", ",", "\u0120comm", "itter", ",", "\u0120get", "Name", "(),", "\u0120new", "Cap", ",", "\u0120network", ",", "\u0120random", ",", "\u0120has", "her", ");", "\u0120});", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120base", ".", "with", "Writer", "(", "owner", "(),", "\u0120writer", "(),", "\u0120network", ").", "then", "Comp", "ose", "(", "snap", "shot", "\u0120->", "\u0120get", "Input", "Stream", "(", "snap", "shot", ".", "get", "(", "writer", "()", ").", "pro", "ps", ",", "\u0120network", ",", "\u0120random", ",", "\u0120x", "\u0120->", "\u0120{}", ")", "\u0120.", "then", "Comp", "ose", "(", "stream", "\u0120->", "\u0120target", ".", "upload", "File", "Section", "(", "snap", "shot", ",", "\u0120comm", "itter", ",", "\u0120get", "Name", "(),", "\u0120stream", ",", "\u0120false", ",", "\u01200", ",", "\u0120get", "Size", "(),", "\u0120Optional", ".", "empty", "(),", "\u0120false", ",", "\u0120network", ",", "\u0120random", ",", "\u0120has", "her", ",", "\u0120x", "\u0120->", "\u0120{", "},", "\u0120target", ".", "gener", "ate", "Child", "L", "ocations", "(", "pro", "ps", ".", "get", "Number", "Of", "Ch", "unks", "(),", "\u0120random", "))", "));", "\u0120}", "\u0120});", "\u0120});", "\u0120}"], "docstring_tokens": ["this", "\u0120may", "\u0120impact", "\u0120web", "-", "ui", "\u0120code", ".", "\u0120Do", "\u0120we", "\u0120want", "\u0120to", "\u0120expose", "\u0120Snap", "shot", "\u0120in", "\u0120API", "?"]}
{"function": "public void testBlogPosting() { onView(withText(\"Log In\")) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserEmail), closeSoftKeyboard()); onView(withText(\"Next\")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.login_enter_password)) .perform(click()); onView(withId(R.id.input)) .perform(replaceText(mUserPassword), closeSoftKeyboard()); onView(withText(\"Next\")) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(\"Continue\")) .perform(click()); onView(withId(R.id.viewpager_main)) .perform(ViewPagerActions.scrollToFirst()); onView(withId(R.id.fab_button)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.title)) .perform(replaceText(\"Hello\"), closeSoftKeyboard()); onView(withId(R.id.aztec)) .perform(replaceText(\"World\"), closeSoftKeyboard()); onView(withId(R.id.menu_save_post)) .perform(click()); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withId(R.id.promo_dialog_button_positive)) .perform(click()); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } onView(withText(R.string.uploading_post)).inRoot(new ToastMatcher()) .check(matches(isDisplayed())); }", "text": "This seems to fail the test when SmartLock for Passwords pops up the dialog for selecting a saved email/pass combination.", "function_tokens": ["public", "\u0120void", "\u0120test", "Blog", "Post", "ing", "()", "\u0120{", "\u0120on", "View", "(", "with", "Text", "(\"", "Log", "\u0120In", "\"))", "\u0120.", "per", "form", "(", "click", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "input", "))", "\u0120.", "per", "form", "(", "replace", "Text", "(", "m", "User", "Email", "),", "\u0120close", "Soft", "Key", "board", "());", "\u0120on", "View", "(", "with", "Text", "(\"", "Next", "\"))", "\u0120.", "per", "form", "(", "click", "());", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "5000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "login", "_", "enter", "_", "password", "))", "\u0120.", "per", "form", "(", "click", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "input", "))", "\u0120.", "per", "form", "(", "replace", "Text", "(", "m", "User", "Password", "),", "\u0120close", "Soft", "Key", "board", "());", "\u0120on", "View", "(", "with", "Text", "(\"", "Next", "\"))", "\u0120.", "per", "form", "(", "click", "());", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "5000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120on", "View", "(", "with", "Text", "(\"", "Continue", "\"))", "\u0120.", "per", "form", "(", "click", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "view", "p", "ager", "_", "main", "))", "\u0120.", "per", "form", "(", "View", "P", "ager", "A", "ctions", ".", "scroll", "To", "First", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "fab", "_", "button", "))", "\u0120.", "per", "form", "(", "click", "());", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "5000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "title", "))", "\u0120.", "per", "form", "(", "replace", "Text", "(\"", "Hello", "\"),", "\u0120close", "Soft", "Key", "board", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "az", "tec", "))", "\u0120.", "per", "form", "(", "replace", "Text", "(\"", "World", "\"),", "\u0120close", "Soft", "Key", "board", "());", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "menu", "_", "save", "_", "post", "))", "\u0120.", "per", "form", "(", "click", "());", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "5000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120on", "View", "(", "with", "Id", "(", "R", ".", "id", ".", "prom", "o", "_", "dial", "og", "_", "button", "_", "positive", "))", "\u0120.", "per", "form", "(", "click", "());", "\u0120try", "\u0120{", "\u0120Thread", ".", "sleep", "(", "2000", ");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120on", "View", "(", "with", "Text", "(", "R", ".", "string", ".", "upload", "ing", "_", "post", ")).", "in", "Root", "(", "new", "\u0120Toast", "Mat", "cher", "())", "\u0120.", "check", "(", "mat", "ches", "(", "is", "Dis", "played", "()", "));", "\u0120}"], "docstring_tokens": ["This", "\u0120seems", "\u0120to", "\u0120fail", "\u0120the", "\u0120test", "\u0120when", "\u0120Smart", "Lock", "\u0120for", "\u0120Pass", "words", "\u0120pops", "\u0120up", "\u0120the", "\u0120dialog", "\u0120for", "\u0120selecting", "\u0120a", "\u0120saved", "\u0120email", "/", "pass", "\u0120combination", "."]}
{"function": "public void placeOnTop(Node pNode) { assert pNode != null; if( aType == DiagramType.SEQUENCE && pNode.getClass() == CallNode.class ) { return; } if( pNode.hasParent() ) { Node parent = pNode.getParent(); parent.placeLast(pNode); placeOnTop(parent); } else if( containsAsRoot(pNode) ) { removeRootNode(pNode); addRootNode(pNode); } }", "text": "CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.", "function_tokens": ["public", "\u0120void", "\u0120place", "On", "Top", "(", "Node", "\u0120p", "Node", ")", "\u0120{", "\u0120assert", "\u0120p", "Node", "\u0120!=", "\u0120null", ";", "\u0120if", "(", "\u0120a", "Type", "\u0120==", "\u0120Di", "agram", "Type", ".", "SE", "QU", "ENCE", "\u0120&&", "\u0120p", "Node", ".", "get", "Class", "()", "\u0120==", "\u0120Call", "Node", ".", "class", "\u0120)", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "(", "\u0120p", "Node", ".", "has", "Parent", "()", "\u0120)", "\u0120{", "\u0120Node", "\u0120parent", "\u0120=", "\u0120p", "Node", ".", "get", "Parent", "();", "\u0120parent", ".", "place", "Last", "(", "p", "Node", ");", "\u0120place", "On", "Top", "(", "parent", ");", "\u0120}", "\u0120else", "\u0120if", "(", "\u0120contains", "As", "Root", "(", "p", "Node", ")", "\u0120)", "\u0120{", "\u0120remove", "Root", "Node", "(", "p", "Node", ");", "\u0120add", "Root", "Node", "(", "p", "Node", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Call", "Node", "\u0120are", "\u0120only", "\u0120present", "\u0120in", "\u0120sequence", "\u0120diagrams", ",", "\u0120so", "\u0120I", "\u0120would", "\u0120recommend", "\u0120eliminating", "\u0120the", "\u0120first", "\u0120(", "pres", "umed", "\u0120defensive", ")", "\u0120clause", "\u0120a", "Type", "\u0120==", "\u0120Di", "agram", "Type", ".", "SE", "QU", "ENCE", "\u0120because", "\u0120of", "\u0120the", "\u0120potential", "\u0120confusion", "\u0120if", "\u0120may", "\u0120cause", "."]}
{"function": "public int[] downloadSetupConfigurationTemplate(String uuid){ int[] result = new int[2]; try { SetupConfigurationTemplate setupConfigurationTemplate = setupConfigurationController.downloadSetupConfigurationTemplate(uuid); result[0] = SyncStatusConstants.SUCCESS; if(setupConfigurationTemplate != null) { result[1] = 1; } System.out.println(\"MuzimaSyncService: \"+setupConfigurationTemplate.getConfigJson()); setupConfigurationController.saveSetupConfigurationTemplate(setupConfigurationTemplate); } catch (SetupConfigurationController.SetupConfigurationDownloadException e){ Log.e(TAG, \"Exception when trying to download setup configs\"); result[0] = SyncStatusConstants.DOWNLOAD_ERROR; } catch (SetupConfigurationController.SetupConfigurationSaveException e){ Log.e(TAG, \"Exception when trying to save setup configs\"); result[0] = SyncStatusConstants.SAVE_ERROR; } return result; }", "text": "Replace with logger", "function_tokens": ["public", "\u0120int", "[]", "\u0120download", "Setup", "Configuration", "Template", "(", "String", "\u0120u", "uid", "){", "\u0120int", "[]", "\u0120result", "\u0120=", "\u0120new", "\u0120int", "[", "2", "];", "\u0120try", "\u0120{", "\u0120Setup", "Configuration", "Template", "\u0120setup", "Configuration", "Template", "\u0120=", "\u0120setup", "Configuration", "Controller", ".", "download", "Setup", "Configuration", "Template", "(", "uu", "id", ");", "\u0120result", "[", "0", "]", "\u0120=", "\u0120Sync", "Status", "Const", "ants", ".", "SU", "CC", "ESS", ";", "\u0120if", "(", "setup", "Configuration", "Template", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120result", "[", "1", "]", "\u0120=", "\u01201", ";", "\u0120}", "\u0120System", ".", "out", ".", "println", "(\"", "M", "uz", "ima", "Sync", "Service", ":", "\u0120\"+", "setup", "Configuration", "Template", ".", "get", "Config", "J", "son", "());", "\u0120setup", "Configuration", "Controller", ".", "save", "Setup", "Configuration", "Template", "(", "setup", "Configuration", "Template", ");", "\u0120}", "\u0120catch", "\u0120(", "Setup", "Configuration", "Controller", ".", "Setup", "Configuration", "Download", "Exception", "\u0120e", "){", "\u0120Log", ".", "e", "(", "TAG", ",", "\u0120\"", "Exception", "\u0120when", "\u0120trying", "\u0120to", "\u0120download", "\u0120setup", "\u0120config", "s", "\");", "\u0120result", "[", "0", "]", "\u0120=", "\u0120Sync", "Status", "Const", "ants", ".", "DOWN", "LOAD", "_", "ERROR", ";", "\u0120}", "\u0120catch", "\u0120(", "Setup", "Configuration", "Controller", ".", "Setup", "Configuration", "Save", "Exception", "\u0120e", "){", "\u0120Log", ".", "e", "(", "TAG", ",", "\u0120\"", "Exception", "\u0120when", "\u0120trying", "\u0120to", "\u0120save", "\u0120setup", "\u0120config", "s", "\");", "\u0120result", "[", "0", "]", "\u0120=", "\u0120Sync", "Status", "Const", "ants", ".", "SA", "VE", "_", "ERROR", ";", "\u0120}", "\u0120return", "\u0120result", ";", "\u0120}"], "docstring_tokens": ["Re", "place", "\u0120with", "\u0120logger"]}
{"function": "public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); if (orientation != newConfig.orientation) { try { orientation = newConfig.orientation; getFragmentManager().beginTransaction().remove(this).commit(); getFragmentManager().beginTransaction() .replace(R.id.cover_fragment_container, CoverFragment.class.newInstance()) .commitAllowingStateLoss(); } catch (Exception e) { Log.e(TAG, \"onConfigurationChanged \" + e.toString()); } } }", "text": "I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?", "function_tokens": ["public", "\u0120void", "\u0120on", "Configuration", "Changed", "(", "Configuration", "\u0120new", "Config", ")", "\u0120{", "\u0120super", ".", "on", "Configuration", "Changed", "(", "new", "Config", ");", "\u0120if", "\u0120(", "orient", "ation", "\u0120!=", "\u0120new", "Config", ".", "orient", "ation", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120orientation", "\u0120=", "\u0120new", "Config", ".", "orient", "ation", ";", "\u0120get", "Frag", "ment", "Manager", "().", "begin", "Transaction", "().", "remove", "(", "this", ").", "commit", "();", "\u0120get", "Frag", "ment", "Manager", "().", "begin", "Transaction", "()", "\u0120.", "replace", "(", "R", ".", "id", ".", "cover", "_", "fr", "ag", "ment", "_", "container", ",", "\u0120Cover", "Frag", "ment", ".", "class", ".", "new", "Instance", "())", "\u0120.", "commit", "All", "owing", "State", "L", "oss", "();", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120Log", ".", "e", "(", "TAG", ",", "\u0120\"", "on", "Configuration", "Changed", "\u0120\"", "\u0120+", "\u0120e", ".", "to", "String", "());", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120still", "\u0120think", "\u0120that", "\u0120this", "\u0120is", "\u0120pretty", "\u0120strange", ".", "\u0120What", "\u0120about", "\u0120just", "\u0120returning", "\u0120a", "\u0120Frame", "Layout", "\u0120in", "\u0120on", "Create", "View", "\u0120and", "\u0120re", "-", "in", "fl", "ating", "\u0120its", "\u0120content", "\u0120in", "\u0120on", "Configuration", "Changed", "?"]}
{"function": "protected void serviceStart() throws Exception { super.serviceStart(); if (UserGroupInformation.isSecurityEnabled()) { delegationTokenManager.startThreads(); } InetSocketAddress connectAddress = NetUtils.getConnectAddress(this.heartbeatListener.getAddress()); URI connectUri = RecoverableRpcProxy.toConnectURI(connectAddress); FSRecoveryHandler recoveryHandler = new FSRecoveryHandler(dag.assertAppPath(), getConfig()); recoveryHandler.writeConnectUri(connectUri.toString()); try { org.mortbay.log.Log.setLog(null); } catch (Throwable throwable) { } try { Configuration config = getConfig(); if (SecurityUtils.isStramWebSecurityEnabled()) { config = new Configuration(config); config.set(\"hadoop.http.filter.initializers\", StramWSFilterInitializer.class.getCanonicalName()); } addSSLConfigResource(config); WebApp webApp = WebApps.$for(\"stram\", StramAppContext.class, appContext, \"ws\").with(config).start(new StramWebApp(this.dnmgr)); LOG.info(\"Started web service at port: \" + webApp.port()); appMasterTrackingUrl = NetUtils.getConnectAddress(webApp.getListenerAddress()).getAddress().getCanonicalHostName() + \":\" + webApp.port(); if (ConfigUtils.isSSLEnabled(config)) { appMasterTrackingUrl = \"https://\" + appMasterTrackingUrl; } LOG.info(\"Setting tracking URL to: \" + appMasterTrackingUrl); } catch (Exception e) { LOG.error(\"Webapps failed to start. Ignoring for now:\", e); } }", "text": "Sounds like a workaround for host misconfiguration issue.", "function_tokens": ["protected", "\u0120void", "\u0120service", "Start", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120super", ".", "service", "Start", "();", "\u0120if", "\u0120(", "User", "Group", "Information", ".", "is", "Security", "Enabled", "())", "\u0120{", "\u0120delegation", "Token", "Manager", ".", "start", "Thread", "s", "();", "\u0120}", "\u0120In", "et", "Socket", "Address", "\u0120connect", "Address", "\u0120=", "\u0120Net", "Ut", "ils", ".", "get", "Connect", "Address", "(", "this", ".", "heart", "beat", "Listener", ".", "get", "Address", "());", "\u0120URI", "\u0120connect", "U", "ri", "\u0120=", "\u0120Recover", "able", "R", "pc", "Proxy", ".", "to", "Connect", "URI", "(", "connect", "Address", ");", "\u0120FS", "Rec", "overy", "Handler", "\u0120recovery", "Handler", "\u0120=", "\u0120new", "\u0120FS", "Rec", "overy", "Handler", "(", "d", "ag", ".", "assert", "App", "Path", "(),", "\u0120get", "Config", "());", "\u0120recovery", "Handler", ".", "write", "Connect", "U", "ri", "(", "connect", "U", "ri", ".", "to", "String", "());", "\u0120try", "\u0120{", "\u0120org", ".", "mort", "bay", ".", "log", ".", "Log", ".", "set", "Log", "(", "null", ");", "\u0120}", "\u0120catch", "\u0120(", "Throw", "able", "\u0120throw", "able", ")", "\u0120{", "\u0120}", "\u0120try", "\u0120{", "\u0120Configuration", "\u0120config", "\u0120=", "\u0120get", "Config", "();", "\u0120if", "\u0120(", "Security", "Ut", "ils", ".", "is", "St", "ram", "Web", "Security", "Enabled", "())", "\u0120{", "\u0120config", "\u0120=", "\u0120new", "\u0120Configuration", "(", "config", ");", "\u0120config", ".", "set", "(\"", "h", "ado", "op", ".", "http", ".", "filter", ".", "initial", "izers", "\",", "\u0120St", "ram", "WS", "Filter", "Initial", "izer", ".", "class", ".", "get", "Can", "on", "ical", "Name", "());", "\u0120}", "\u0120add", "SSL", "Config", "Resource", "(", "config", ");", "\u0120Web", "App", "\u0120web", "App", "\u0120=", "\u0120Web", "Apps", ".$", "for", "(\"", "st", "ram", "\",", "\u0120St", "ram", "App", "Context", ".", "class", ",", "\u0120app", "Context", ",", "\u0120\"", "ws", "\").", "with", "(", "config", ").", "start", "(", "new", "\u0120St", "ram", "Web", "App", "(", "this", ".", "d", "nm", "gr", "));", "\u0120LOG", ".", "info", "(\"", "Start", "ed", "\u0120web", "\u0120service", "\u0120at", "\u0120port", ":", "\u0120\"", "\u0120+", "\u0120web", "App", ".", "port", "());", "\u0120app", "Master", "Tr", "acking", "Url", "\u0120=", "\u0120Net", "Ut", "ils", ".", "get", "Connect", "Address", "(", "web", "App", ".", "get", "Listener", "Address", "()", ").", "get", "Address", "().", "get", "Can", "on", "ical", "Host", "Name", "()", "\u0120+", "\u0120\"", ":\"", "\u0120+", "\u0120web", "App", ".", "port", "();", "\u0120if", "\u0120(", "Config", "Ut", "ils", ".", "is", "SS", "LE", "n", "abled", "(", "config", "))", "\u0120{", "\u0120app", "Master", "Tr", "acking", "Url", "\u0120=", "\u0120\"", "https", "://", "\"", "\u0120+", "\u0120app", "Master", "Tr", "acking", "Url", ";", "\u0120}", "\u0120LOG", ".", "info", "(\"", "Setting", "\u0120tracking", "\u0120URL", "\u0120to", ":", "\u0120\"", "\u0120+", "\u0120app", "Master", "Tr", "acking", "Url", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Web", "apps", "\u0120failed", "\u0120to", "\u0120start", ".", "\u0120Ign", "oring", "\u0120for", "\u0120now", ":", "\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Sounds", "\u0120like", "\u0120a", "\u0120workaround", "\u0120for", "\u0120host", "\u0120mis", "config", "uration", "\u0120issue", "."]}
{"function": "protected void executeVdsBrokerCommand() { String storageDomainId = getParameters().getStorageDomainId().toString(); List<String> deviceList = getParameters().getDeviceList(); String[] deviceArray = deviceList.toArray(new String[deviceList.size()]); boolean isForce = getParameters().isForce(); boolean supportForceCreateVG = Config.<Boolean> getValue( ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString()); _result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray); proceedProxyReturnValue(); setReturnValue(_result.uuid); }", "text": "Could you please rename also _result?", "function_tokens": ["protected", "\u0120void", "\u0120execute", "V", "ds", "Bro", "ker", "Command", "()", "\u0120{", "\u0120String", "\u0120storage", "Domain", "Id", "\u0120=", "\u0120get", "Parameters", "().", "get", "Storage", "Domain", "Id", "().", "to", "String", "();", "\u0120List", "<", "String", ">", "\u0120device", "List", "\u0120=", "\u0120get", "Parameters", "().", "get", "Device", "List", "();", "\u0120String", "[]", "\u0120device", "Array", "\u0120=", "\u0120device", "List", ".", "to", "Array", "(", "new", "\u0120String", "[", "device", "List", ".", "size", "()", "]);", "\u0120boolean", "\u0120is", "Force", "\u0120=", "\u0120get", "Parameters", "().", "is", "Force", "();", "\u0120boolean", "\u0120support", "Force", "Create", "VG", "\u0120=", "\u0120Config", ".<", "Boo", "lean", ">", "\u0120get", "Value", "(", "\u0120Config", "Values", ".", "Support", "Force", "Create", "VG", ",", "\u0120get", "V", "ds", "().", "get", "V", "ds", "Group", "Comp", "atibility", "Version", "().", "to", "String", "());", "\u0120_", "result", "\u0120=", "\u0120support", "Force", "Create", "VG", "\u0120?", "\u0120get", "Bro", "ker", "().", "create", "VG", "(", "storage", "Domain", "Id", ",", "\u0120device", "Array", ",", "\u0120is", "Force", ")", "\u0120:", "\u0120get", "Bro", "ker", "().", "create", "VG", "(", "storage", "Domain", "Id", ",", "\u0120device", "Array", ");", "\u0120proceed", "Proxy", "Return", "Value", "();", "\u0120set", "Return", "Value", "(_", "result", ".", "uu", "id", ");", "\u0120}"], "docstring_tokens": ["Could", "\u0120you", "\u0120please", "\u0120rename", "\u0120also", "\u0120_", "result", "?"]}
{"function": "public boolean addNextEvent(final MistEvent event, final Direction direction) { if (operatorChainManager != null && queue.isEmpty()) { operatorChainManager.insert(this); } return queue.add(new Tuple<>(event, direction)); }", "text": "I think it would be good to perform this logic in OutputEmitter.", "function_tokens": ["public", "\u0120boolean", "\u0120add", "Next", "Event", "(", "final", "\u0120Mist", "Event", "\u0120event", ",", "\u0120final", "\u0120Direction", "\u0120direction", ")", "\u0120{", "\u0120if", "\u0120(", "operator", "Chain", "Manager", "\u0120!=", "\u0120null", "\u0120&&", "\u0120queue", ".", "is", "Empty", "())", "\u0120{", "\u0120operator", "Chain", "Manager", ".", "insert", "(", "this", ");", "\u0120}", "\u0120return", "\u0120queue", ".", "add", "(", "new", "\u0120T", "uple", "<", ">(", "event", ",", "\u0120direction", "));", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120it", "\u0120would", "\u0120be", "\u0120good", "\u0120to", "\u0120perform", "\u0120this", "\u0120logic", "\u0120in", "\u0120Output", "Em", "itter", "."]}
{"function": "public void freeUnderlyingResources() { int spi = mSpi.getSpi(); try { mSrvConfig .getNetdInstance() .ipSecDeleteSecurityAssociation( 0, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, 0, mConfig.getMarkMask()); } catch (RemoteException | ServiceSpecificException e) { Log.e(TAG, \"Failed to delete SA with ID: \" + mResourceId, e); } getResourceTracker().give(); }", "text": "I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).", "function_tokens": ["public", "\u0120void", "\u0120free", "Under", "lying", "Resources", "()", "\u0120{", "\u0120int", "\u0120sp", "i", "\u0120=", "\u0120m", "Sp", "i", ".", "get", "Sp", "i", "();", "\u0120try", "\u0120{", "\u0120m", "S", "r", "v", "Config", "\u0120.", "get", "Net", "d", "Instance", "()", "\u0120.", "ip", "Sec", "Delete", "Security", "Ass", "ociation", "(", "\u01200", ",", "\u0120m", "Config", ".", "get", "Source", "Address", "(),", "\u0120m", "Config", ".", "get", "Dest", "ination", "Address", "(),", "\u0120sp", "i", ",", "\u01200", ",", "\u0120m", "Config", ".", "get", "Mark", "Mask", "());", "\u0120}", "\u0120catch", "\u0120(", "Remote", "Exception", "\u0120|", "\u0120Service", "Specific", "Exception", "\u0120e", ")", "\u0120{", "\u0120Log", ".", "e", "(", "TAG", ",", "\u0120\"", "F", "ailed", "\u0120to", "\u0120delete", "\u0120SA", "\u0120with", "\u0120ID", ":", "\u0120\"", "\u0120+", "\u0120m", "Resource", "Id", ",", "\u0120e", ");", "\u0120}", "\u0120get", "Resource", "Tracker", "().", "give", "();", "\u0120}"], "docstring_tokens": ["I", "'d", "\u0120prefer", "\u0120that", "\u0120we", "\u0120call", "\u0120this", "\u0120something", "\u0120like", "\u0120DE", "FAULT", "_", "RE", "QUEST", "_", "ID", ".", "\u0120It", "'ll", "\u0120be", "\u0120easier", "\u0120to", "\u0120read", "\u0120and", "\u0120easier", "\u0120to", "\u0120change", "\u0120if", "\u0120we", "\u0120decide", "\u0120zero", "\u0120isn", "'t", "\u0120the", "\u0120best", "\u0120number", "\u0120(", "which", "\u0120I", "\u0120suggest", "\u0120it", "\u0120isn", "'t", "\u0120since", "\u0120it", "'s", "\u0120probably", "\u0120the", "\u0120most", "\u0120likely", "\u0120number", "\u0120to", "\u0120be", "\u0120non", "-", "unique", "\u0120with", "\u0120other", "\u0120users", "\u0120of", "\u0120the", "\u0120API", ")."]}
{"function": "public void execute() { final Setting setting = getActionContext().getSetting(); final EObject eObject = setting.getEObject(); final EStructuralFeature eStructuralFeature = setting.getEStructuralFeature(); final List<?> containments = (List<?>) eObject.eGet(eStructuralFeature, true); final List<?> moveUpList = Arrays.asList( ((IStructuredSelection) getTableViewer().getSelection()).toArray()); sortSelectionBasedOnIndex(moveUpList, containments); final EditingDomain editingDomain = getActionContext().getEditingDomain(); for (final Object moveUpObject : moveUpList) { final int currentIndex = containments.indexOf(moveUpObject); if (currentIndex <= 0) { return; } editingDomain.getCommandStack() .execute( new MoveCommand( editingDomain, eObject, eStructuralFeature, currentIndex, currentIndex - 1)); } }", "text": "we should probably check in the canExecute whether we reached the start of the list", "function_tokens": ["public", "\u0120void", "\u0120execute", "()", "\u0120{", "\u0120final", "\u0120Setting", "\u0120setting", "\u0120=", "\u0120get", "Action", "Context", "().", "get", "Setting", "();", "\u0120final", "\u0120E", "Object", "\u0120e", "Object", "\u0120=", "\u0120setting", ".", "get", "EO", "b", "ject", "();", "\u0120final", "\u0120E", "Struct", "ural", "Feature", "\u0120e", "Struct", "ural", "Feature", "\u0120=", "\u0120setting", ".", "get", "E", "Struct", "ural", "Feature", "();", "\u0120final", "\u0120List", "<?", ">", "\u0120contain", "ments", "\u0120=", "\u0120(", "List", "<?", ">)", "\u0120e", "Object", ".", "e", "Get", "(", "e", "Struct", "ural", "Feature", ",", "\u0120true", ");", "\u0120final", "\u0120List", "<?", ">", "\u0120move", "Up", "List", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(", "\u0120((", "I", "Struct", "ured", "Se", "lection", ")", "\u0120get", "Table", "View", "er", "().", "get", "Se", "lection", "()", ").", "to", "Array", "());", "\u0120sort", "Se", "lection", "Based", "On", "Index", "(", "move", "Up", "List", ",", "\u0120contain", "ments", ");", "\u0120final", "\u0120Editing", "Domain", "\u0120editing", "Domain", "\u0120=", "\u0120get", "Action", "Context", "().", "get", "Ed", "iting", "Domain", "();", "\u0120for", "\u0120(", "final", "\u0120Object", "\u0120move", "Up", "Object", "\u0120:", "\u0120move", "Up", "List", ")", "\u0120{", "\u0120final", "\u0120int", "\u0120current", "Index", "\u0120=", "\u0120contain", "ments", ".", "index", "Of", "(", "move", "Up", "Object", ");", "\u0120if", "\u0120(", "current", "Index", "\u0120<=", "\u01200", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120editing", "Domain", ".", "get", "Command", "Stack", "()", "\u0120.", "execute", "(", "\u0120new", "\u0120Move", "Command", "(", "\u0120editing", "Domain", ",", "\u0120e", "Object", ",", "\u0120e", "Struct", "ural", "Feature", ",", "\u0120current", "Index", ",", "\u0120current", "Index", "\u0120-", "\u01201", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["we", "\u0120should", "\u0120probably", "\u0120check", "\u0120in", "\u0120the", "\u0120can", "Exec", "ute", "\u0120whether", "\u0120we", "\u0120reached", "\u0120the", "\u0120start", "\u0120of", "\u0120the", "\u0120list"]}
{"function": "protected Array createArrayOf(String typeName, Object[] array) { Connection connection = null; try { connection = getJdbcTemplate().getDataSource().getConnection(); return connection.createArrayOf(typeName, array); } catch (SQLException e) { throw new RuntimeException(e); } finally { if (connection != null) { try { connection.close();} catch (SQLException e) {} } } }", "text": "Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }", "function_tokens": ["protected", "\u0120Array", "\u0120create", "Array", "Of", "(", "String", "\u0120type", "Name", ",", "\u0120Object", "[]", "\u0120array", ")", "\u0120{", "\u0120Connection", "\u0120connection", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120connection", "\u0120=", "\u0120get", "J", "db", "c", "Template", "().", "get", "Data", "Source", "().", "get", "Connection", "();", "\u0120return", "\u0120connection", ".", "create", "Array", "Of", "(", "type", "Name", ",", "\u0120array", ");", "\u0120}", "\u0120catch", "\u0120(", "S", "Q", "LE", "x", "ception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120if", "\u0120(", "connection", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120connection", ".", "close", "();", "}", "\u0120catch", "\u0120(", "S", "Q", "LE", "x", "ception", "\u0120e", ")", "\u0120{}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120to", "\u0120use", ":", "\u0120try", "\u0120(", "Connection", "\u0120connection", "\u0120=", "\u0120get", "J", "db", "c", "Template", "().", "get", "Data", "Source", "().", "get", "Connection", "())", "\u0120{", "\u0120return", "\u0120connection", ".", "create", "Array", "Of", "(", "type", "Name", ",", "\u0120array", ");", "\u0120}", "\u0120catch", "(", "S", "Q", "LE", "x", "ception", "\u0120ex", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(", "e", ");", "\u0120}"]}
{"function": "public byte[] serialize() { ByteBuffer buffer = ByteBuffer.allocate(9); buffer.put(TYPE_LONG); buffer.putLong(value); return buffer.array(); }", "text": "magic number", "function_tokens": ["public", "\u0120byte", "[]", "\u0120serial", "ize", "()", "\u0120{", "\u0120Byte", "Buffer", "\u0120buffer", "\u0120=", "\u0120Byte", "Buffer", ".", "all", "ocate", "(", "9", ");", "\u0120buffer", ".", "put", "(", "TYPE", "_", "L", "ONG", ");", "\u0120buffer", ".", "put", "Long", "(", "value", ");", "\u0120return", "\u0120buffer", ".", "array", "();", "\u0120}"], "docstring_tokens": ["magic", "\u0120number"]}
{"function": "public ServiceReference[] getServiceReferences(String clazz, String filter) { ServiceReference[] refs = null; try { if (bundleContext != null) { refs = bundleContext.getServiceReferences(clazz, filter); } } catch (InvalidSyntaxException e) { if (log.isLoggable(Level.SEVERE)) { log.log(Level.SEVERE, e.getMessage(), e); } } return refs; }", "text": "I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.", "function_tokens": ["public", "\u0120Service", "Reference", "[]", "\u0120get", "Service", "References", "(", "String", "\u0120cl", "azz", ",", "\u0120String", "\u0120filter", ")", "\u0120{", "\u0120Service", "Reference", "[]", "\u0120ref", "s", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "b", "undle", "Context", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120ref", "s", "\u0120=", "\u0120bundle", "Context", ".", "get", "Service", "References", "(", "cl", "azz", ",", "\u0120filter", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Invalid", "Sy", "ntax", "Exception", "\u0120e", ")", "\u0120{", "\u0120if", "\u0120(", "log", ".", "is", "L", "ogg", "able", "(", "Level", ".", "SE", "VER", "E", "))", "\u0120{", "\u0120log", ".", "log", "(", "Level", ".", "SE", "VER", "E", ",", "\u0120e", ".", "get", "Message", "(),", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120ref", "s", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120would", "\u0120prefer", "\u0120that", "\u0120the", "\u0120exception", "\u0120were", "\u0120re", "-", "th", "rown", "\u0120as", "\u0120a", "\u0120different", "\u0120typed", "\u0120exception", "\u0120(", "e", ".", "g", ".", "\u0120Platform", "Services", "Exception", ")", "\u0120and", "\u0120handled", "\u0120by", "\u0120the", "\u0120caller", "\u0120rather", "\u0120than", "\u0120just", "\u0120eating", "\u0120the", "\u0120exception", "\u0120here", "."]}
{"function": "private boolean execute(final IProcessDMContext processDmc, final IDebugCommandRequest request) { try { fExecutor.execute(new DsfRunnable() { @Override public void run() { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null) { procService.terminate(processDmc, new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!getStatus().isOK()) { request.setStatus(getStatus()); request.done(); } else { WaitForTerminationJob job = new WaitForTerminationJob(fSession.getId(), request); job.schedule(); } }; }); } else { request.done(); } } }); } catch (RejectedExecutionException e) { request.done(); } return false; }", "text": "Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?", "function_tokens": ["private", "\u0120boolean", "\u0120execute", "(", "final", "\u0120I", "Process", "DM", "Context", "\u0120process", "D", "mc", ",", "\u0120final", "\u0120ID", "eb", "ug", "Command", "Request", "\u0120request", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120f", "Exec", "utor", ".", "execute", "(", "new", "\u0120D", "sf", "Run", "n", "able", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120I", "Process", "es", "\u0120proc", "Service", "\u0120=", "\u0120f", "Tracker", ".", "get", "Service", "(", "I", "Process", "es", ".", "class", ");", "\u0120if", "\u0120(", "proc", "Service", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120proc", "Service", ".", "termin", "ate", "(", "process", "D", "mc", ",", "\u0120new", "\u0120Im", "mediate", "Request", "Monitor", "()", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120void", "\u0120handle", "Completed", "()", "\u0120{", "\u0120if", "\u0120(!", "get", "Status", "().", "is", "OK", "())", "\u0120{", "\u0120request", ".", "set", "Status", "(", "get", "Status", "());", "\u0120request", ".", "done", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120Wait", "For", "Ter", "mination", "Job", "\u0120job", "\u0120=", "\u0120new", "\u0120Wait", "For", "Ter", "mination", "Job", "(", "f", "Session", ".", "get", "Id", "(),", "\u0120request", ");", "\u0120job", ".", "sche", "dule", "();", "\u0120}", "\u0120};", "\u0120});", "\u0120}", "\u0120else", "\u0120{", "\u0120request", ".", "done", "();", "\u0120}", "\u0120}", "\u0120});", "\u0120}", "\u0120catch", "\u0120(", "Re", "jected", "Exec", "ution", "Exception", "\u0120e", ")", "\u0120{", "\u0120request", ".", "done", "();", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Usually", "\u0120we", "\u0120use", "\u0120Request", "Monitor", ".", "is", "Success", "().", "\u0120Is", "\u0120there", "\u0120a", "\u0120reason", "\u0120you", "\u0120use", "\u0120the", "\u0120I", "Status", "\u0120directly", "?"]}
{"function": "void deleteProperty(AccumuloElement element, Property property, Authorizations authorizations) { if (!element.getFetchHints().isIncludeAllProperties()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), \"All Properties\"); } if (!element.getFetchHints().isIncludeAllPropertyMetadata()) { throw new VertexiumMissingFetchHintException(element.getFetchHints(), \"All Property Metadata\"); } Mutation m = new Mutation(element.getId()); elementMutationBuilder.addPropertyDeleteToMutation(m, property); addMutations(element, m); getSearchIndex().deleteProperty( this, element, PropertyDescriptor.fromProperty(property), authorizations ); if (hasEventListeners()) { queueEvent(new DeletePropertyEvent(this, element, property)); } }", "text": "Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.", "function_tokens": ["void", "\u0120delete", "Property", "(", "Acc", "um", "ulo", "Element", "\u0120element", ",", "\u0120Property", "\u0120property", ",", "\u0120Author", "izations", "\u0120author", "izations", ")", "\u0120{", "\u0120if", "\u0120(!", "element", ".", "get", "F", "etch", "H", "ints", "().", "is", "In", "clude", "All", "Pro", "perties", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Ver", "tex", "ium", "Missing", "F", "etch", "H", "int", "Exception", "(", "element", ".", "get", "F", "etch", "H", "ints", "(),", "\u0120\"", "All", "\u0120Properties", "\");", "\u0120}", "\u0120if", "\u0120(!", "element", ".", "get", "F", "etch", "H", "ints", "().", "is", "In", "clude", "All", "Property", "Met", "adata", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Ver", "tex", "ium", "Missing", "F", "etch", "H", "int", "Exception", "(", "element", ".", "get", "F", "etch", "H", "ints", "(),", "\u0120\"", "All", "\u0120Property", "\u0120Met", "adata", "\");", "\u0120}", "\u0120M", "utation", "\u0120m", "\u0120=", "\u0120new", "\u0120M", "utation", "(", "element", ".", "get", "Id", "());", "\u0120element", "M", "utation", "Builder", ".", "add", "Property", "Delete", "To", "M", "utation", "(", "m", ",", "\u0120property", ");", "\u0120add", "M", "utations", "(", "element", ",", "\u0120m", ");", "\u0120get", "Search", "Index", "().", "delete", "Property", "(", "\u0120this", ",", "\u0120element", ",", "\u0120Property", "Desc", "ript", "or", ".", "from", "Property", "(", "property", "),", "\u0120author", "izations", "\u0120);", "\u0120if", "\u0120(", "has", "Event", "Listen", "ers", "())", "\u0120{", "\u0120queue", "Event", "(", "new", "\u0120Delete", "Property", "Event", "(", "this", ",", "\u0120element", ",", "\u0120property", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["Is", "\u0120the", "\u0120reason", "\u0120that", "\u0120we", "\u0120have", "\u0120to", "\u0120have", "\u0120is", "In", "clude", "All", "Pro", "perties", "\u0120because", "\u0120of", "\u0120the", "\u0120search", "\u0120index", "?", "\u0120Seems", "\u0120like", "\u0120we", "\u0120would", "\u0120really", "\u0120only", "\u0120need", "\u0120the", "\u0120one", "\u0120you", "\u0120loaded", "."]}
{"function": "public List<ExperimentSpotDesignReadSpec> list() { List expmts = this.getHibernateTemplate().find(\"from ExperimentSpotDesignReadSpec as readSpec order by readSpec.experimentSpotDesignReadSpecId asc\" ); return expmts; }", "text": "Why does this need to be ordered by the synthetic primary key?", "function_tokens": ["public", "\u0120List", "<", "Exper", "iment", "Spot", "Design", "Read", "Spec", ">", "\u0120list", "()", "\u0120{", "\u0120List", "\u0120exp", "m", "ts", "\u0120=", "\u0120this", ".", "get", "H", "iber", "n", "ate", "Template", "().", "find", "(\"", "from", "\u0120Experiment", "Spot", "Design", "Read", "Spec", "\u0120as", "\u0120read", "Spec", "\u0120order", "\u0120by", "\u0120read", "Spec", ".", "exper", "iment", "Spot", "Design", "Read", "Spec", "Id", "\u0120asc", "\"", "\u0120);", "\u0120return", "\u0120exp", "m", "ts", ";", "\u0120}"], "docstring_tokens": ["Why", "\u0120does", "\u0120this", "\u0120need", "\u0120to", "\u0120be", "\u0120ordered", "\u0120by", "\u0120the", "\u0120synthetic", "\u0120primary", "\u0120key", "?"]}
{"function": "public void testToFlowElement_autostart() throws Exception { final ReusableSubprocess definition = new ReusableSubprocess(); definition.getExecutionSet().setAdHocAutostart(new AdHocAutostart(true)); final View<BaseReusableSubprocess> view = new ViewImpl<>(definition, Bounds.create()); final Node<View<BaseReusableSubprocess>, ?> node = new NodeImpl<>(java.util.UUID.randomUUID().toString()); node.setContent(view); final PropertyWriter propertyWriter = tested.toFlowElement(node); assertTrue(CallActivityPropertyWriter.class.isInstance(propertyWriter)); assertTrue(CustomElement.autoStart.of(propertyWriter.getFlowElement()).get()); }", "text": "The Exception is never thrown.", "function_tokens": ["public", "\u0120void", "\u0120test", "To", "Flow", "Element", "_", "aut", "ost", "art", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120Re", "usable", "Sub", "process", "\u0120definition", "\u0120=", "\u0120new", "\u0120Re", "usable", "Sub", "process", "();", "\u0120definition", ".", "get", "Exec", "ution", "Set", "().", "set", "Ad", "H", "oc", "Aut", "ost", "art", "(", "new", "\u0120Ad", "H", "oc", "Aut", "ost", "art", "(", "true", "));", "\u0120final", "\u0120View", "<", "Base", "Re", "usable", "Sub", "process", ">", "\u0120view", "\u0120=", "\u0120new", "\u0120View", "Impl", "<", ">(", "definition", ",", "\u0120B", "ounds", ".", "create", "());", "\u0120final", "\u0120Node", "<", "View", "<", "Base", "Re", "usable", "Sub", "process", ">,", "\u0120?", ">", "\u0120node", "\u0120=", "\u0120new", "\u0120Node", "Impl", "<", ">(", "java", ".", "util", ".", "U", "UID", ".", "random", "U", "UID", "().", "to", "String", "());", "\u0120node", ".", "set", "Content", "(", "view", ");", "\u0120final", "\u0120Property", "Writer", "\u0120property", "Writer", "\u0120=", "\u0120tested", ".", "to", "Flow", "Element", "(", "node", ");", "\u0120assert", "True", "(", "Call", "Activity", "Property", "Writer", ".", "class", ".", "is", "Instance", "(", "property", "Writer", "));", "\u0120assert", "True", "(", "Custom", "Element", ".", "auto", "Start", ".", "of", "(", "property", "Writer", ".", "get", "Flow", "Element", "()", ").", "get", "());", "\u0120}"], "docstring_tokens": ["The", "\u0120Exception", "\u0120is", "\u0120never", "\u0120thrown", "."]}
{"function": "public static Date parseDate(String date, String format) { return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); }", "text": "Is a null check for the passed in \"date\" required here for safety?", "function_tokens": ["public", "\u0120static", "\u0120Date", "\u0120parse", "Date", "(", "String", "\u0120date", ",", "\u0120String", "\u0120format", ")", "\u0120{", "\u0120return", "\u0120parse", "Date", "(", "date", ",", "\u0120new", "\u0120Simple", "Date", "Format", "(", "format", ",", "\u0120Loc", "ale", ".", "get", "Default", "()", "));", "\u0120}"], "docstring_tokens": ["Is", "\u0120a", "\u0120null", "\u0120check", "\u0120for", "\u0120the", "\u0120passed", "\u0120in", "\u0120\"", "date", "\"", "\u0120required", "\u0120here", "\u0120for", "\u0120safety", "?"]}
{"function": "public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); } return false; }", "text": "Since numberOfVotes can be null you should replace this with Objects.equals(numberOfVotes, other.numberOfVotes)", "function_tokens": ["public", "\u0120boolean", "\u0120equals", "(", "Object", "\u0120that", ")", "\u0120{", "\u0120if", "\u0120(", "this", "\u0120==", "\u0120that", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "that", "\u0120instance", "of", "\u0120Rating", ")", "\u0120{", "\u0120Rating", "\u0120other", "\u0120=", "\u0120(", "Rating", ")", "\u0120that", ";", "\u0120return", "\u0120type", ".", "equ", "als", "(", "other", ".", "type", ")", "\u0120&&", "\u0120value", "\u0120==", "\u0120other", ".", "value", "\u0120&&", "\u0120number", "Of", "V", "otes", ".", "equ", "als", "(", "other", ".", "number", "Of", "V", "otes", ");", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Since", "\u0120number", "Of", "V", "otes", "\u0120can", "\u0120be", "\u0120null", "\u0120you", "\u0120should", "\u0120replace", "\u0120this", "\u0120with", "\u0120Objects", ".", "equ", "als", "(", "number", "Of", "V", "otes", ",", "\u0120other", ".", "number", "Of", "V", "otes", ")"]}
{"function": "public static void connect(Socket socket, SocketAddress endpoint, SocketAddress localAddr, int timeout) throws IOException { if (socket == null || endpoint == null || timeout < 0) { throw new IllegalArgumentException(\"Illegal argument for connect()\"); } SocketChannel ch = socket.getChannel(); if (localAddr != null) { Class localClass = localAddr.getClass(); Class remoteClass = endpoint.getClass(); Preconditions.checkArgument(localClass.equals(remoteClass), \"Local address %s must be of same family as remote address %s.\", localAddr, endpoint); socket.bind(localAddr); } try { if (ch == null) { socket.connect(endpoint, timeout); } else { SocketIOWithTimeout.connect(ch, endpoint, timeout); } } catch (SocketTimeoutException ste) { throw new ConnectTimeoutException(ste.getMessage()); } catch (UnresolvedAddressException ue) { throw new UnknownHostException(ue.getMessage()); } if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) { LOG.info(\"Detected a loopback TCP socket, disconnecting it\"); socket.close(); throw new ConnectException( \"Localhost targeted connection resulted in a loopback. \" + \"No daemon is listening on the target port.\"); } }", "text": "nit: call it uae?", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120connect", "(", "Socket", "\u0120socket", ",", "\u0120Socket", "Address", "\u0120endpoint", ",", "\u0120Socket", "Address", "\u0120local", "Add", "r", ",", "\u0120int", "\u0120timeout", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "socket", "\u0120==", "\u0120null", "\u0120||", "\u0120endpoint", "\u0120==", "\u0120null", "\u0120||", "\u0120timeout", "\u0120<", "\u01200", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Il", "legal", "\u0120argument", "\u0120for", "\u0120connect", "()", "\");", "\u0120}", "\u0120Socket", "Channel", "\u0120ch", "\u0120=", "\u0120socket", ".", "get", "Channel", "();", "\u0120if", "\u0120(", "local", "Add", "r", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Class", "\u0120local", "Class", "\u0120=", "\u0120local", "Add", "r", ".", "get", "Class", "();", "\u0120Class", "\u0120remote", "Class", "\u0120=", "\u0120endpoint", ".", "get", "Class", "();", "\u0120Pre", "cond", "itions", ".", "check", "Arg", "ument", "(", "local", "Class", ".", "equ", "als", "(", "remote", "Class", "),", "\u0120\"", "Local", "\u0120address", "\u0120%", "s", "\u0120must", "\u0120be", "\u0120of", "\u0120same", "\u0120family", "\u0120as", "\u0120remote", "\u0120address", "\u0120%", "s", ".\",", "\u0120local", "Add", "r", ",", "\u0120endpoint", ");", "\u0120socket", ".", "bind", "(", "local", "Add", "r", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "ch", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120socket", ".", "connect", "(", "end", "point", ",", "\u0120timeout", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Socket", "IO", "With", "Timeout", ".", "connect", "(", "ch", ",", "\u0120endpoint", ",", "\u0120timeout", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Socket", "Timeout", "Exception", "\u0120ste", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Connect", "Timeout", "Exception", "(", "ste", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "Un", "res", "olved", "Address", "Exception", "\u0120u", "e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Unknown", "Host", "Exception", "(", "ue", ".", "get", "Message", "());", "\u0120}", "\u0120if", "\u0120(", "socket", ".", "get", "Local", "Port", "()", "\u0120==", "\u0120socket", ".", "get", "Port", "()", "\u0120&&", "\u0120socket", ".", "get", "Local", "Address", "().", "equ", "als", "(", "socket", ".", "get", "In", "et", "Address", "()", "))", "\u0120{", "\u0120LOG", ".", "info", "(\"", "Det", "ected", "\u0120a", "\u0120loop", "back", "\u0120TCP", "\u0120socket", ",", "\u0120disconnect", "ing", "\u0120it", "\");", "\u0120socket", ".", "close", "();", "\u0120throw", "\u0120new", "\u0120Connect", "Exception", "(", "\u0120\"", "Local", "host", "\u0120targeted", "\u0120connection", "\u0120resulted", "\u0120in", "\u0120a", "\u0120loop", "back", ".", "\u0120\"", "\u0120+", "\u0120\"", "No", "\u0120daemon", "\u0120is", "\u0120listening", "\u0120on", "\u0120the", "\u0120target", "\u0120port", ".\"", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120call", "\u0120it", "\u0120u", "ae", "?"]}
{"function": "public void testReviewForm() throws ParseException { final DeliveryReviewView view = getDeliveryReviewView(); final DeliveryReviewView.DeliveryForm deliveryForm = view.getDelivery(); deliveryForm.setGrade(\"4.0\"); deliveryForm.setState(\"Rejected\"); deliveryForm.setCommentary(\"Hello World!\"); assertTrue(deliveryForm.getGrade() == 4.0D); assertEquals(Delivery.State.REJECTED, deliveryForm.getSelectedState()); assertEquals(\"Hello World!\", deliveryForm.getCommentary()); }", "text": "Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.", "function_tokens": ["public", "\u0120void", "\u0120test", "Review", "Form", "()", "\u0120throws", "\u0120Par", "se", "Exception", "\u0120{", "\u0120final", "\u0120Delivery", "Review", "View", "\u0120view", "\u0120=", "\u0120get", "Delivery", "Review", "View", "();", "\u0120final", "\u0120Delivery", "Review", "View", ".", "Delivery", "Form", "\u0120delivery", "Form", "\u0120=", "\u0120view", ".", "get", "Delivery", "();", "\u0120delivery", "Form", ".", "set", "Grade", "(\"", "4", ".", "0", "\");", "\u0120delivery", "Form", ".", "set", "State", "(\"", "Re", "jected", "\");", "\u0120delivery", "Form", ".", "set", "Comment", "ary", "(\"", "Hello", "\u0120World", "!\"", ");", "\u0120assert", "True", "(", "del", "ivery", "Form", ".", "get", "Grade", "()", "\u0120==", "\u01204", ".", "0", "D", ");", "\u0120assert", "Equ", "als", "(", "Delivery", ".", "State", ".", "RE", "JECT", "ED", ",", "\u0120delivery", "Form", ".", "get", "Se", "lected", "State", "());", "\u0120assert", "Equ", "als", "(\"", "Hello", "\u0120World", "!\",", "\u0120delivery", "Form", ".", "get", "Comment", "ary", "());", "\u0120}"], "docstring_tokens": ["Could", "\u0120have", "\u0120been", "\u0120Word", "Ut", "ils", ".", "capital", "ize", "(", "Delivery", ".", "State", ".", "RE", "JECT", "ED", ")", "\u0120so", "\u0120the", "\u0120test", "\u0120is", "\u0120more", "\u0120stable", "\u0120(", "will", "\u0120cause", "\u0120compilation", "\u0120errors", ")", "\u0120if", "\u0120we", "\u0120at", "\u0120some", "\u0120point", "\u0120change", "\u0120the", "\u0120Delivery", "\u0120API", "."]}
{"function": "private static void addRequestParameter(SOAPFactory soapFactory, OMElement bodyFirstChild, OMNamespace ns, String key, Object parameter) { if (parameter instanceof DataHandler) { DataHandler dataHandler = (DataHandler)parameter; OMText dataText = bodyFirstChild.getOMFactory().createOMText( dataHandler, true); OMElement omElement = soapFactory.createOMElement(key, ns, bodyFirstChild); omElement.addChild(dataText); omElement.addAttribute(\"filename\",((DataHandler) parameter).getDataSource().getName(),ns); omElement.addAttribute(\"filename\", ((DataHandler) parameter).getDataSource().getName(), ns); } else { String textValue = parameter.toString(); soapFactory.createOMElement(key, ns, bodyFirstChild).setText( textValue); } }", "text": "repeating code line.", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120add", "Request", "Parameter", "(", "SO", "AP", "Factory", "\u0120soap", "Factory", ",", "\u0120O", "ME", "lement", "\u0120body", "First", "Child", ",", "\u0120OM", "Names", "pace", "\u0120ns", ",", "\u0120String", "\u0120key", ",", "\u0120Object", "\u0120parameter", ")", "\u0120{", "\u0120if", "\u0120(", "param", "eter", "\u0120instance", "of", "\u0120Data", "Handler", ")", "\u0120{", "\u0120Data", "Handler", "\u0120data", "Handler", "\u0120=", "\u0120(", "Data", "Handler", ")", "param", "eter", ";", "\u0120OM", "Text", "\u0120data", "Text", "\u0120=", "\u0120body", "First", "Child", ".", "get", "OM", "Factory", "().", "create", "OM", "Text", "(", "\u0120data", "Handler", ",", "\u0120true", ");", "\u0120O", "ME", "lement", "\u0120om", "Element", "\u0120=", "\u0120soap", "Factory", ".", "create", "OME", "lement", "(", "key", ",", "\u0120ns", ",", "\u0120body", "First", "Child", ");", "\u0120om", "Element", ".", "add", "Child", "(", "data", "Text", ");", "\u0120om", "Element", ".", "add", "Attribute", "(\"", "filename", "\",", "((", "Data", "Handler", ")", "\u0120parameter", ").", "get", "Data", "Source", "().", "get", "Name", "(),", "ns", ");", "\u0120om", "Element", ".", "add", "Attribute", "(\"", "filename", "\",", "\u0120((", "Data", "Handler", ")", "\u0120parameter", ").", "get", "Data", "Source", "().", "get", "Name", "(),", "\u0120ns", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120text", "Value", "\u0120=", "\u0120parameter", ".", "to", "String", "();", "\u0120soap", "Factory", ".", "create", "OME", "lement", "(", "key", ",", "\u0120ns", ",", "\u0120body", "First", "Child", ").", "set", "Text", "(", "\u0120text", "Value", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["repe", "ating", "\u0120code", "\u0120line", "."]}
{"function": "public Future<Void> executeFailed(Stage stage, Class<?> executingClass, ConsumerRecord<byte[], byte[]> consumerRecord, Throwable error) { if (!withinToleranceLimits()) { errorHandlingMetrics.recordFailure(); markAsFailed(); throw new ConnectException(\"Tolerance exceeded in the errant record reporter\", error); } context.consumerRecord(consumerRecord); context.currentContext(stage, executingClass); context.error(error); errorHandlingMetrics.recordError(); return context.report(); }", "text": "if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.", "function_tokens": ["public", "\u0120Future", "<", "V", "oid", ">", "\u0120execute", "F", "ailed", "(", "Stage", "\u0120stage", ",", "\u0120Class", "<?", ">", "\u0120executing", "Class", ",", "\u0120Consumer", "Record", "<", "byte", "[", "],", "\u0120byte", "[]", ">", "\u0120consumer", "Record", ",", "\u0120Throw", "able", "\u0120error", ")", "\u0120{", "\u0120if", "\u0120(!", "within", "T", "olerance", "Lim", "its", "())", "\u0120{", "\u0120error", "Hand", "ling", "Met", "rics", ".", "record", "Failure", "();", "\u0120mark", "As", "F", "ailed", "();", "\u0120throw", "\u0120new", "\u0120Connect", "Exception", "(\"", "T", "olerance", "\u0120exceeded", "\u0120in", "\u0120the", "\u0120er", "rant", "\u0120record", "\u0120reporter", "\",", "\u0120error", ");", "\u0120}", "\u0120context", ".", "consumer", "Record", "(", "consumer", "Record", ");", "\u0120context", ".", "current", "Context", "(", "stage", ",", "\u0120executing", "Class", ");", "\u0120context", ".", "error", "(", "error", ");", "\u0120error", "Hand", "ling", "Met", "rics", ".", "record", "Error", "();", "\u0120return", "\u0120context", ".", "report", "();", "\u0120}"], "docstring_tokens": ["if", "\u0120we", "\u0120attempt", "\u0120an", "\u0120operation", "\u0120and", "\u0120it", "\u0120fails", ",", "\u0120record", "Failure", "\u0120will", "\u0120be", "\u0120incre", "mented", ",", "\u0120but", "\u0120record", "Error", "\u0120only", "\u0120tracks", "\u0120the", "\u0120cases", "\u0120where", "\u0120the", "\u0120when", "\u0120we", "\u0120encounter", "\u0120a", "\u0120problem", "\u0120that", "\u0120the", "\u0120framework", "\u0120cannot", "\u0120ret", "ry", "\u0120or", "\u0120skip", ".", "\u0120In", "\u0120the", "\u0120first", "\u0120case", ",", "\u0120we", "\u0120may", "\u0120still", "\u0120be", "\u0120able", "\u0120to", "\u0120ret", "ry", "\u0120or", "\u0120skip", "\u0120the", "\u0120record", ".", "\u0120In", "\u0120the", "\u0120execute", "F", "ailed", "\u0120scenario", ",", "\u0120we", "\u0120should", "\u0120record", "Failure", "()", "\u0120every", "\u0120time", ",", "\u0120and", "\u0120only", "\u0120record", "Error", "\u0120only", "\u0120when", "\u0120we", "\u0120have", "\u0120to", "\u0120fail", "\u0120the", "\u0120task", "."]}
{"function": "public OutputWriter createOutputWriter() { if (file.exists()) { ExcelDatastore datastore = new ExcelDatastore(file.getName(), new FileResource(file), file.getAbsolutePath()); try (final UpdateableDatastoreConnection connection = datastore.openConnection()) { final DataContext dataContext = connection.getDataContext(); final Schema[] schemas = dataContext.getSchemas(); if (schemas.length >= 1) { final String[] tableNames = schemas[1].getTableNames(); for (int i = 0; i < tableNames.length; i++) { if (tableNames[i].equals(sheetName)) { if (overwriteSheetIfExists) { final Table tableSheet = dataContext.getTableByQualifiedLabel(sheetName); final UpdateableDataContext updateableDataContext = connection .getUpdateableDataContext(); updateableDataContext.executeUpdate(new UpdateScript() { @Override public void run(UpdateCallback callback) { callback.dropTable(tableSheet).execute(); ; } }); } } } } } } String[] headers = new String[columns.length]; for (int i = 0; i < headers.length; i++) { headers[i] = columns[i].getName(); } return ExcelOutputWriterFactory.getWriter(file.getPath(), sheetName, columns); }", "text": "Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after \"information_schema\" :-)", "function_tokens": ["public", "\u0120Output", "Writer", "\u0120create", "Output", "Writer", "()", "\u0120{", "\u0120if", "\u0120(", "file", ".", "ex", "ists", "())", "\u0120{", "\u0120Excel", "Dat", "ast", "ore", "\u0120dat", "ast", "ore", "\u0120=", "\u0120new", "\u0120Excel", "Dat", "ast", "ore", "(", "file", ".", "get", "Name", "(),", "\u0120new", "\u0120File", "Resource", "(", "file", "),", "\u0120file", ".", "get", "Abs", "olute", "Path", "());", "\u0120try", "\u0120(", "final", "\u0120Update", "able", "Dat", "ast", "ore", "Connection", "\u0120connection", "\u0120=", "\u0120dat", "ast", "ore", ".", "open", "Connection", "())", "\u0120{", "\u0120final", "\u0120Data", "Context", "\u0120data", "Context", "\u0120=", "\u0120connection", ".", "get", "Data", "Context", "();", "\u0120final", "\u0120Sche", "ma", "[]", "\u0120sche", "mas", "\u0120=", "\u0120data", "Context", ".", "get", "Sche", "mas", "();", "\u0120if", "\u0120(", "sc", "hem", "as", ".", "length", "\u0120>=", "\u01201", ")", "\u0120{", "\u0120final", "\u0120String", "[]", "\u0120table", "Names", "\u0120=", "\u0120sche", "mas", "[", "1", "].", "get", "Table", "Names", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120table", "Names", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "table", "Names", "[", "i", "].", "equ", "als", "(", "sheet", "Name", "))", "\u0120{", "\u0120if", "\u0120(", "over", "write", "She", "et", "If", "Ex", "ists", ")", "\u0120{", "\u0120final", "\u0120Table", "\u0120table", "She", "et", "\u0120=", "\u0120data", "Context", ".", "get", "Table", "By", "Qual", "ified", "Label", "(", "sheet", "Name", ");", "\u0120final", "\u0120Update", "able", "Data", "Context", "\u0120update", "able", "Data", "Context", "\u0120=", "\u0120connection", "\u0120.", "get", "Update", "able", "Data", "Context", "();", "\u0120update", "able", "Data", "Context", ".", "execute", "Update", "(", "new", "\u0120Update", "Script", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "(", "Update", "Callback", "\u0120callback", ")", "\u0120{", "\u0120callback", ".", "drop", "Table", "(", "table", "She", "et", ").", "execute", "();", "\u0120;", "\u0120}", "\u0120});", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120String", "[]", "\u0120headers", "\u0120=", "\u0120new", "\u0120String", "[", "column", "s", ".", "length", "];", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120headers", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120headers", "[", "i", "]", "\u0120=", "\u0120columns", "[", "i", "].", "get", "Name", "();", "\u0120}", "\u0120return", "\u0120Excel", "Output", "Writer", "Factory", ".", "get", "Writer", "(", "file", ".", "get", "Path", "(),", "\u0120sheet", "Name", ",", "\u0120columns", ");", "\u0120}"], "docstring_tokens": ["Better", "\u0120way", "\u0120to", "\u0120get", "\u0120the", "\u0120proper", "\u0120schema", "\u0120is", "\u0120to", "\u0120say", "\u0120data", "Context", ".", "get", "Default", "Sche", "ma", "()", "\u0120...", "\u0120taking", "\u0120sche", "mas", "[", "1", "]", "\u0120is", "\u0120actually", "\u0120not", "\u0120guaranteed", "\u0120to", "\u0120work", "\u0120since", "\u0120sche", "mas", "\u0120are", "\u0120sorted", "\u0120alphabet", "ically", "\u0120and", "\u0120then", "\u0120you", "\u0120rely", "\u0120on", "\u0120the", "\u0120filename", "\u0120(", "which", "\u0120is", "\u0120used", "\u0120as", "\u0120schema", "\u0120name", ")", "\u0120to", "\u0120be", "\u0120sorted", "\u0120after", "\u0120\"", "information", "_", "sche", "ma", "\"", "\u0120:-)"]}
{"function": "public boolean isQueryCacheable(Query query) { return !query.isDescending() && !unCacheable.contains(query.getType()); }", "text": "any reason for disabling cache for descending order queries ?", "function_tokens": ["public", "\u0120boolean", "\u0120is", "Query", "Cache", "able", "(", "Query", "\u0120query", ")", "\u0120{", "\u0120return", "\u0120!", "query", ".", "is", "Desc", "ending", "()", "\u0120&&", "\u0120!", "un", "Cache", "able", ".", "cont", "ains", "(", "query", ".", "get", "Type", "());", "\u0120}"], "docstring_tokens": ["any", "\u0120reason", "\u0120for", "\u0120disabling", "\u0120cache", "\u0120for", "\u0120descending", "\u0120order", "\u0120queries", "\u0120?"]}
{"function": "public void testBacktickEscapedIdentifier() { assertTrue(CharFormatUtil.unescapeIdentifier(\"``\").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(\"\").isEmpty()); assertTrue(CharFormatUtil.unescapeIdentifier(\"`s`\").equals(\"s\")); assertTrue(CharFormatUtil.unescapeIdentifier(\"`self`\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"`self\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"self`\").equals(\"self\")); assertFalse(CharFormatUtil.unescapeIdentifier(\"``self`\").equals(\"self\")); }", "text": "assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?", "function_tokens": ["public", "\u0120void", "\u0120test", "Back", "tick", "Esc", "aped", "Ident", "ifier", "()", "\u0120{", "\u0120assert", "True", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "``", "\").", "is", "Empty", "());", "\u0120assert", "True", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "\").", "is", "Empty", "());", "\u0120assert", "True", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "`", "s", "`", "\").", "equ", "als", "(\"", "s", "\")", ");", "\u0120assert", "True", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "`", "self", "`", "\").", "equ", "als", "(\"", "self", "\")", ");", "\u0120assert", "False", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "`", "self", "\").", "equ", "als", "(\"", "self", "\")", ");", "\u0120assert", "False", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "self", "`", "\").", "equ", "als", "(\"", "self", "\")", ");", "\u0120assert", "False", "(", "Char", "Format", "Ut", "il", ".", "un", "escape", "Ident", "ifier", "(\"", "``", "self", "`", "\").", "equ", "als", "(\"", "self", "\")", ");", "\u0120}"], "docstring_tokens": ["assert", "False", "\u0120is", "\u0120kind", "\u0120of", "\u0120weird", "\u0120here", "\u0120(", "it", "'s", "\u0120like", "\u0120saying", "\u0120we", "\u0120expect", "\u0120that", "\u0120it", "\u0120should", "\u0120be", "\u0120anything", "\u0120but", "\u0120self", ").", "\u0120Can", "\u0120we", "\u0120change", "\u0120this", "\u0120to", "\u0120assert", "E", "qual", "\u0120(", "and", "\u0120the", "\u0120following", "\u0120assert", "False", "(", "s", ")", "\u0120as", "\u0120well", ")?"]}
{"function": "protected void validateAuthenticationState(HttpClient httpClient) throws GerritLoginException { Optional<Cookie> cookie = findCookieWithName(LOGIN_COOKIE_NAME, httpClient); cookie.ifPresent(this::setXsrfCookie); if (!cookie.isPresent()) { if (CoreUtil.TEST_MODE) { System.err.println(\" Authentication failed: \" + httpClient.getState()); } throw new GerritLoginException(); } }", "text": "maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still", "function_tokens": ["protected", "\u0120void", "\u0120validate", "Authent", "ication", "State", "(", "Http", "Client", "\u0120http", "Client", ")", "\u0120throws", "\u0120Ger", "rit", "Login", "Exception", "\u0120{", "\u0120Optional", "<", "C", "ookie", ">", "\u0120cookie", "\u0120=", "\u0120find", "C", "ookie", "With", "Name", "(", "LOG", "IN", "_", "C", "OOK", "IE", "_", "NAME", ",", "\u0120http", "Client", ");", "\u0120cookie", ".", "if", "Present", "(", "this", "::", "set", "X", "sr", "f", "C", "ookie", ");", "\u0120if", "\u0120(!", "cookie", ".", "is", "Present", "())", "\u0120{", "\u0120if", "\u0120(", "Core", "Ut", "il", ".", "T", "EST", "_", "MODE", ")", "\u0120{", "\u0120System", ".", "err", ".", "println", "(\"", "\u0120Authentication", "\u0120failed", ":", "\u0120\"", "\u0120+", "\u0120http", "Client", ".", "get", "State", "());", "\u0120}", "\u0120throw", "\u0120new", "\u0120Ger", "rit", "Login", "Exception", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["maybe", "\u0120it", "'s", "\u0120just", "\u0120me", "\u0120but", "\u0120that", "\u0120mixture", "\u0120of", "\u0120functional", "\u0120and", "\u0120non", "-", "functional", "\u0120programming", "\u0120doesn", "'t", "\u0120look", "\u0120right", ",", "\u0120I", "\u0120know", "\u0120it", "\u0120works", ",", "\u0120but", "\u0120still"]}
{"function": "private void testGetForDeletedBlobWithoutIncludeExpiredOption(List<BlobId> blobIds) { try { store.get(blobIds, EnumSet.noneOf(StoreGetOptions.class)); assertTrue( \"get should fail for a expired blob, if StoreGetOptions.Store_Include_Expired is not set in get options\", false); } catch (StoreException e) { assertTrue( \"get for expired blob with with StoreGetOptions.Store_Include_Expired not set in get options should throw exception with \" + StoreErrorCodes.TTL_Expired + \" error code.\", e.getErrorCode().equals(StoreErrorCodes.TTL_Expired)); } }", "text": "assertEquals and remove the expected value from message string", "function_tokens": ["private", "\u0120void", "\u0120test", "Get", "For", "De", "leted", "Bl", "ob", "Without", "In", "clude", "Ex", "pired", "Option", "(", "List", "<", "Bl", "ob", "Id", ">", "\u0120blob", "Id", "s", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120store", ".", "get", "(", "bl", "ob", "Id", "s", ",", "\u0120En", "um", "Set", ".", "none", "Of", "(", "Store", "Get", "Options", ".", "class", "));", "\u0120assert", "True", "(", "\u0120\"", "get", "\u0120should", "\u0120fail", "\u0120for", "\u0120a", "\u0120expired", "\u0120blob", ",", "\u0120if", "\u0120Store", "Get", "Options", ".", "Store", "_", "In", "clude", "_", "Ex", "pired", "\u0120is", "\u0120not", "\u0120set", "\u0120in", "\u0120get", "\u0120options", "\",", "\u0120false", ");", "\u0120}", "\u0120catch", "\u0120(", "Store", "Exception", "\u0120e", ")", "\u0120{", "\u0120assert", "True", "(", "\u0120\"", "get", "\u0120for", "\u0120expired", "\u0120blob", "\u0120with", "\u0120with", "\u0120Store", "Get", "Options", ".", "Store", "_", "In", "clude", "_", "Ex", "pired", "\u0120not", "\u0120set", "\u0120in", "\u0120get", "\u0120options", "\u0120should", "\u0120throw", "\u0120exception", "\u0120with", "\u0120\"", "\u0120+", "\u0120Store", "Error", "C", "odes", ".", "T", "TL", "_", "Ex", "pired", "\u0120+", "\u0120\"", "\u0120error", "\u0120code", ".\",", "\u0120e", ".", "get", "Error", "Code", "().", "equ", "als", "(", "Store", "Error", "C", "odes", ".", "T", "TL", "_", "Ex", "pired", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["assert", "Equ", "als", "\u0120and", "\u0120remove", "\u0120the", "\u0120expected", "\u0120value", "\u0120from", "\u0120message", "\u0120string"]}
{"function": "public Publisher<Integer> createFailedPublisher() { return null; }", "text": "should be possible to provide one", "function_tokens": ["public", "\u0120Publisher", "<", "Integer", ">", "\u0120create", "F", "ailed", "Publisher", "()", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["should", "\u0120be", "\u0120possible", "\u0120to", "\u0120provide", "\u0120one"]}
{"function": "public String name() { return Json.createReader(new StringReader(this.obj)) .readObject() .getString(\"name\"); }", "text": "Looks like a duplication to me. How about this.json().getString(\"name\")?", "function_tokens": ["public", "\u0120String", "\u0120name", "()", "\u0120{", "\u0120return", "\u0120J", "son", ".", "create", "Reader", "(", "new", "\u0120String", "Reader", "(", "this", ".", "obj", "))", "\u0120.", "read", "Object", "()", "\u0120.", "get", "String", "(\"", "name", "\");", "\u0120}"], "docstring_tokens": ["Looks", "\u0120like", "\u0120a", "\u0120duplication", "\u0120to", "\u0120me", ".", "\u0120How", "\u0120about", "\u0120this", ".", "json", "().", "get", "String", "(\"", "name", "\")", "?"]}
{"function": "protected FieldBase(String name, DataType dataType) { if (CoreUtils.isNullOrEmpty(name)) { throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\")); } this.name = name; this.dataType = dataType; }", "text": "Should we also validate that DataType != null.", "function_tokens": ["protected", "\u0120Field", "Base", "(", "String", "\u0120name", ",", "\u0120Data", "Type", "\u0120data", "Type", ")", "\u0120{", "\u0120if", "\u0120(", "Core", "Ut", "ils", ".", "is", "Null", "Or", "Empty", "(", "name", "))", "\u0120{", "\u0120throw", "\u0120logger", ".", "log", "Exception", "As", "Error", "(", "new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "The", "\u0120name", "\u0120of", "\u0120field", "\u0120cannot", "\u0120be", "\u0120null", "\")", ");", "\u0120}", "\u0120this", ".", "name", "\u0120=", "\u0120name", ";", "\u0120this", ".", "data", "Type", "\u0120=", "\u0120data", "Type", ";", "\u0120}"], "docstring_tokens": ["Should", "\u0120we", "\u0120also", "\u0120validate", "\u0120that", "\u0120Data", "Type", "\u0120!=", "\u0120null", "."]}
{"function": "public Map<?, ?> read() { final Yaml yaml = new Yaml(); final Map<String, String> properties = new HashMap<>(); try (InputStream in = inputStream) { yaml.loadAll(in).forEach((Object obj) -> this.loadValue(properties, \"\", obj)); return properties; } catch (IOException e) { throw new IllegalStateException(\"Cannot load environment\", e); } }", "text": "I think we need to close this InputStream at some point", "function_tokens": ["public", "\u0120Map", "<", "?,", "\u0120?", ">", "\u0120read", "()", "\u0120{", "\u0120final", "\u0120Yam", "l", "\u0120y", "aml", "\u0120=", "\u0120new", "\u0120Yam", "l", "();", "\u0120final", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120properties", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120try", "\u0120(", "Input", "Stream", "\u0120in", "\u0120=", "\u0120input", "Stream", ")", "\u0120{", "\u0120y", "aml", ".", "load", "All", "(", "in", ").", "for", "Each", "((", "Object", "\u0120obj", ")", "\u0120->", "\u0120this", ".", "load", "Value", "(", "properties", ",", "\u0120\"", "\",", "\u0120obj", "));", "\u0120return", "\u0120properties", ";", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "C", "annot", "\u0120load", "\u0120environment", "\",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120we", "\u0120need", "\u0120to", "\u0120close", "\u0120this", "\u0120Input", "Stream", "\u0120at", "\u0120some", "\u0120point"]}
{"function": "private static String createOrUpdateAccountsAndWait(Collection<Account> accounts) throws Exception { String jsonFilePath = tempDirPath + File.separator + UUID.randomUUID().toString() + \".json\"; writeAccountsToFile(accounts, jsonFilePath); int numOfAccounts = AccountUpdater.createOrUpdate(jsonFilePath, ZK_SERVER_ADDRESS, HELIX_STORE_ROOT_PATH, null, null); Thread.sleep(100); return numOfAccounts == -1 ? null : jsonFilePath; }", "text": "do you clean up these files on exit? or the root level dir is deleted on exit ?", "function_tokens": ["private", "\u0120static", "\u0120String", "\u0120create", "Or", "Update", "Account", "s", "And", "Wait", "(", "Collection", "<", "Account", ">", "\u0120accounts", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120String", "\u0120json", "File", "Path", "\u0120=", "\u0120temp", "Dir", "Path", "\u0120+", "\u0120File", ".", "separ", "ator", "\u0120+", "\u0120U", "UID", ".", "random", "U", "UID", "().", "to", "String", "()", "\u0120+", "\u0120\".", "json", "\";", "\u0120write", "Account", "s", "To", "File", "(", "account", "s", ",", "\u0120json", "File", "Path", ");", "\u0120int", "\u0120num", "Of", "Account", "s", "\u0120=", "\u0120Account", "Up", "d", "ater", ".", "create", "Or", "Update", "(", "json", "File", "Path", ",", "\u0120Z", "K", "_", "SER", "VER", "_", "AD", "DR", "ESS", ",", "\u0120HEL", "IX", "_", "ST", "ORE", "_", "RO", "OT", "_", "PATH", ",", "\u0120null", ",", "\u0120null", ");", "\u0120Thread", ".", "sleep", "(", "100", ");", "\u0120return", "\u0120num", "Of", "Account", "s", "\u0120==", "\u0120-", "1", "\u0120?", "\u0120null", "\u0120:", "\u0120json", "File", "Path", ";", "\u0120}"], "docstring_tokens": ["do", "\u0120you", "\u0120clean", "\u0120up", "\u0120these", "\u0120files", "\u0120on", "\u0120exit", "?", "\u0120or", "\u0120the", "\u0120root", "\u0120level", "\u0120dir", "\u0120is", "\u0120deleted", "\u0120on", "\u0120exit", "\u0120?"]}
{"function": "private Integer extractCount(HttpServletRequest request) { Integer count = Integer.valueOf(getParameter(request, \"count\")); checkArgument(COUNT_RANGE.contains(count), \"'count' must be in range %s, was %s\", COUNT_RANGE, count); return count; }", "text": "\"in range\" yet you're not providing a range; perhaps \"'count' must be at most %s\"? Also, shouldn't that be %d?", "function_tokens": ["private", "\u0120Integer", "\u0120extract", "Count", "(", "Http", "Serv", "let", "Request", "\u0120request", ")", "\u0120{", "\u0120Integer", "\u0120count", "\u0120=", "\u0120Integer", ".", "value", "Of", "(", "get", "Parameter", "(", "request", ",", "\u0120\"", "count", "\")", ");", "\u0120check", "Arg", "ument", "(", "C", "OUNT", "_", "R", "ANGE", ".", "cont", "ains", "(", "count", "),", "\u0120\"'", "count", "'", "\u0120must", "\u0120be", "\u0120in", "\u0120range", "\u0120%", "s", ",", "\u0120was", "\u0120%", "s", "\",", "\u0120C", "OUNT", "_", "R", "ANGE", ",", "\u0120count", ");", "\u0120return", "\u0120count", ";", "\u0120}"], "docstring_tokens": ["\"", "in", "\u0120range", "\"", "\u0120yet", "\u0120you", "'re", "\u0120not", "\u0120providing", "\u0120a", "\u0120range", ";", "\u0120perhaps", "\u0120\"'", "count", "'", "\u0120must", "\u0120be", "\u0120at", "\u0120most", "\u0120%", "s", "\"?", "\u0120Also", ",", "\u0120shouldn", "'t", "\u0120that", "\u0120be", "\u0120%", "d", "?"]}
{"function": "private void dismissToast() { try { toast.cancel(); } catch (NullPointerException e) { ZLog.logException(e); } }", "text": "hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)", "function_tokens": ["private", "\u0120void", "\u0120dismiss", "To", "ast", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120toast", ".", "c", "ancel", "();", "\u0120}", "\u0120catch", "\u0120(", "Null", "Po", "inter", "Exception", "\u0120e", ")", "\u0120{", "\u0120Z", "Log", ".", "log", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["he", "ar", "\u0120i", "\u0120think", "\u0120we", "\u0120could", "\u0120handle", "\u0120this", "\u0120error", "\u0120grace", "fully", "\u0120by", "\u0120if", "\u0120(", "to", "ast", "\u0120!=", "\u0120null", ")", "\u0120check", "\u0120and", "\u0120not", "\u0120send", "\u0120the", "\u0120trace", "back", "\u0120to", "\u0120crash", "y", "ly", "tics", "\u0120using", "\u0120Z", "log", ".", "log", "Exception", "(", "e", ")"]}
{"function": "public boolean hasDeploymentSubModel(final String subsystemName, final PathElement address) { final Resource root = deploymentUnit.getAttachment(DEPLOYMENT_RESOURCE); final PathElement subsystem = PathElement.pathElement(SUBSYSTEM, subsystemName); return root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address); }", "text": "Should this support a null address? Same with the other one, which make support a null or empty address.", "function_tokens": ["public", "\u0120boolean", "\u0120has", "Deploy", "ment", "Sub", "Model", "(", "final", "\u0120String", "\u0120subsystem", "Name", ",", "\u0120final", "\u0120Path", "Element", "\u0120address", ")", "\u0120{", "\u0120final", "\u0120Resource", "\u0120root", "\u0120=", "\u0120deployment", "Unit", ".", "get", "Att", "achment", "(", "DE", "PL", "OY", "MENT", "_", "RES", "OURCE", ");", "\u0120final", "\u0120Path", "Element", "\u0120subsystem", "\u0120=", "\u0120Path", "Element", ".", "path", "Element", "(", "SU", "BS", "Y", "STEM", ",", "\u0120subsystem", "Name", ");", "\u0120return", "\u0120root", ".", "has", "Child", "(", "sub", "system", ")", "\u0120&&", "\u0120root", ".", "get", "Child", "(", "sub", "system", ").", "has", "Child", "(", "address", ");", "\u0120}"], "docstring_tokens": ["Should", "\u0120this", "\u0120support", "\u0120a", "\u0120null", "\u0120address", "?", "\u0120Same", "\u0120with", "\u0120the", "\u0120other", "\u0120one", ",", "\u0120which", "\u0120make", "\u0120support", "\u0120a", "\u0120null", "\u0120or", "\u0120empty", "\u0120address", "."]}
{"function": "void scheduleKeepAliveHeartbeat() { Scheduler.get().scheduleFixedDelay(new RepeatingCommand() { @Override public boolean execute() { boolean sessionInUse = restApiSessionId != null; if (sessionInUse && refreshRestApiSession) { sendRequest(createRequest(engineAuthToken), new RestApiRequestCallback()); refreshRestApiSession = false; } return sessionInUse; } }, SESSION_HEARTBEAT_MS); }", "text": "this is followup of above, it should not be required.", "function_tokens": ["void", "\u0120schedule", "Keep", "Al", "ive", "Heart", "beat", "()", "\u0120{", "\u0120Sched", "uler", ".", "get", "().", "sche", "dule", "Fixed", "Del", "ay", "(", "new", "\u0120Repe", "ating", "Command", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120boolean", "\u0120execute", "()", "\u0120{", "\u0120boolean", "\u0120session", "In", "Use", "\u0120=", "\u0120rest", "A", "pi", "Session", "Id", "\u0120!=", "\u0120null", ";", "\u0120if", "\u0120(", "session", "In", "Use", "\u0120&&", "\u0120refresh", "Rest", "A", "pi", "Session", ")", "\u0120{", "\u0120send", "Request", "(", "create", "Request", "(", "engine", "Auth", "Token", "),", "\u0120new", "\u0120Rest", "A", "pi", "Request", "Callback", "());", "\u0120refresh", "Rest", "A", "pi", "Session", "\u0120=", "\u0120false", ";", "\u0120}", "\u0120return", "\u0120session", "In", "Use", ";", "\u0120}", "\u0120},", "\u0120S", "ESSION", "_", "HE", "ART", "BE", "AT", "_", "MS", ");", "\u0120}"], "docstring_tokens": ["this", "\u0120is", "\u0120follow", "up", "\u0120of", "\u0120above", ",", "\u0120it", "\u0120should", "\u0120not", "\u0120be", "\u0120required", "."]}
{"function": "public void marriedKeychainBloomFilter() throws Exception { wallet = new Wallet(params); blockStore = new MemoryBlockStore(params); chain = new BlockChain(params, wallet, blockStore); String XPUB = \"xpub68KFnj3bqUx1s7mHejLDBPywCAKdJEu1b49uniEEn2WSbHmZ7xbLqFTjJbtx1LUcAt1DwhoqWHmo2s5WMJp6wi38CiF2hYD49qVViKVvAoi\"; wallet.addFollowingAccounts(ImmutableList.of(DeterministicKey.deserializeB58(null, XPUB))); Address address = wallet.currentReceiveAddress(); assertTrue(wallet.getBloomFilter(1e-12).contains(address.getHash160())); Transaction t1 = createFakeTx(params, CENT, address); StoredBlock b1 = createFakeBlock(blockStore, t1).storedBlock; TransactionOutPoint outPoint = new TransactionOutPoint(params, 0, t1); assertFalse(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); wallet.receiveFromBlock(t1, b1, BlockChain.NewBlockType.BEST_CHAIN, 0); assertTrue(wallet.getBloomFilter(1e-12).contains(outPoint.bitcoinSerialize())); }", "text": "I should probably have asked this in the previous review, but why \"addFollowingAccounts\"? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.", "function_tokens": ["public", "\u0120void", "\u0120married", "Key", "chain", "Bloom", "Filter", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120wallet", "\u0120=", "\u0120new", "\u0120Wallet", "(", "params", ");", "\u0120block", "Store", "\u0120=", "\u0120new", "\u0120Memory", "Block", "Store", "(", "params", ");", "\u0120chain", "\u0120=", "\u0120new", "\u0120Block", "Chain", "(", "params", ",", "\u0120wallet", ",", "\u0120block", "Store", ");", "\u0120String", "\u0120X", "PU", "B", "\u0120=", "\u0120\"", "x", "pub", "68", "K", "F", "n", "j", "3", "b", "q", "U", "x", "1", "s", "7", "m", "He", "j", "L", "DB", "Py", "w", "CA", "K", "d", "J", "E", "u", "1", "b", "49", "uni", "E", "En", "2", "WS", "b", "H", "m", "Z", "7", "xb", "L", "q", "FT", "j", "J", "b", "tx", "1", "LU", "c", "At", "1", "D", "who", "q", "WH", "mo", "2", "s", "5", "WM", "J", "p", "6", "wi", "38", "C", "i", "F", "2", "h", "YD", "49", "q", "V", "Vi", "K", "V", "v", "A", "oi", "\";", "\u0120wallet", ".", "add", "Following", "Account", "s", "(", "Imm", "utable", "List", ".", "of", "(", "D", "eter", "ministic", "Key", ".", "des", "erial", "ize", "B", "58", "(", "null", ",", "\u0120X", "PU", "B", "))", ");", "\u0120Address", "\u0120address", "\u0120=", "\u0120wallet", ".", "current", "Re", "ceive", "Address", "();", "\u0120assert", "True", "(", "wallet", ".", "get", "Bloom", "Filter", "(", "1", "e", "-", "12", ").", "cont", "ains", "(", "address", ".", "get", "Hash", "160", "()", "));", "\u0120Transaction", "\u0120t", "1", "\u0120=", "\u0120create", "Fake", "Tx", "(", "params", ",", "\u0120CENT", ",", "\u0120address", ");", "\u0120St", "ored", "Block", "\u0120b", "1", "\u0120=", "\u0120create", "Fake", "Block", "(", "block", "Store", ",", "\u0120t", "1", ").", "st", "ored", "Block", ";", "\u0120Transaction", "Out", "Point", "\u0120out", "Point", "\u0120=", "\u0120new", "\u0120Transaction", "Out", "Point", "(", "params", ",", "\u01200", ",", "\u0120t", "1", ");", "\u0120assert", "False", "(", "wallet", ".", "get", "Bloom", "Filter", "(", "1", "e", "-", "12", ").", "cont", "ains", "(", "out", "Point", ".", "bitcoin", "Serial", "ize", "()", "));", "\u0120wallet", ".", "re", "ceive", "From", "Block", "(", "t", "1", ",", "\u0120b", "1", ",", "\u0120Block", "Chain", ".", "New", "Block", "Type", ".", "B", "EST", "_", "CH", "AIN", ",", "\u01200", ");", "\u0120assert", "True", "(", "wallet", ".", "get", "Bloom", "Filter", "(", "1", "e", "-", "12", ").", "cont", "ains", "(", "out", "Point", ".", "bitcoin", "Serial", "ize", "()", "));", "\u0120}"], "docstring_tokens": ["I", "\u0120should", "\u0120probably", "\u0120have", "\u0120asked", "\u0120this", "\u0120in", "\u0120the", "\u0120previous", "\u0120review", ",", "\u0120but", "\u0120why", "\u0120\"", "add", "Following", "Account", "s", "\"?", "\u0120We", "\u0120don", "'t", "\u0120talk", "\u0120about", "\u0120accounts", "\u0120mostly", "\u0120in", "\u0120other", "\u0120parts", "\u0120of", "\u0120the", "\u0120code", ".", "\u0120It", "\u0120could", "\u0120be", "\u0120ambiguous", "\u0120with", "\u0120the", "\u0120B", "IP", "32", "\u0120feature", "\u0120of", "\u0120the", "\u0120same", "\u0120name", "."]}
{"function": "public boolean test(Object receiver, String property, Object[] args, Object expectedValue) { IMonitorControl monitor = null; if (receiver instanceof IMonitorControl) { monitor = (IMonitorControl) receiver; } else { if (selectedMonitorId != null) { monitor = MonitorControlManager.getInstance().getMonitorControl(selectedMonitorId); } } if (monitor != null) { if (IS_ACTIVE.equals(property)) { return monitor.isActive() == toBoolean(expectedValue); } } return false; }", "text": "Please make sure this is properly formatted. \"else\" should be on the same line as the }.", "function_tokens": ["public", "\u0120boolean", "\u0120test", "(", "Object", "\u0120receiver", ",", "\u0120String", "\u0120property", ",", "\u0120Object", "[]", "\u0120args", ",", "\u0120Object", "\u0120expected", "Value", ")", "\u0120{", "\u0120IM", "on", "itor", "Control", "\u0120monitor", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "re", "ceiver", "\u0120instance", "of", "\u0120IM", "on", "itor", "Control", ")", "\u0120{", "\u0120monitor", "\u0120=", "\u0120(", "IM", "on", "itor", "Control", ")", "\u0120receiver", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "selected", "Monitor", "Id", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120monitor", "\u0120=", "\u0120Monitor", "Control", "Manager", ".", "get", "Instance", "().", "get", "Monitor", "Control", "(", "selected", "Monitor", "Id", ");", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "monitor", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "IS", "_", "ACT", "IVE", ".", "equ", "als", "(", "property", "))", "\u0120{", "\u0120return", "\u0120monitor", ".", "is", "Active", "()", "\u0120==", "\u0120to", "Boo", "lean", "(", "expected", "Value", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["Please", "\u0120make", "\u0120sure", "\u0120this", "\u0120is", "\u0120properly", "\u0120formatted", ".", "\u0120\"", "else", "\"", "\u0120should", "\u0120be", "\u0120on", "\u0120the", "\u0120same", "\u0120line", "\u0120as", "\u0120the", "\u0120}", "."]}
{"function": "public WorkspaceConfigImpl devFileToWorkspaceConfig(Devfile devfile) throws DevfileFormatException { validateCurrentVersion(devfile); WorkspaceConfigImpl config = new WorkspaceConfigImpl(); config.setName(devfile.getName()); List<ProjectConfigImpl> projects = new ArrayList<>(); devfile.getProjects().forEach(project -> projects.add(devProjectToProjectConfig(project))); config.setProjects(projects); Map<String, String> attributes = new HashMap<>(); StringJoiner pluginsStringJoiner = new StringJoiner(\",\"); StringJoiner toolIdToNameMappingStringJoiner = new StringJoiner(\",\"); for (Tool tool : devfile.getTools()) { switch (tool.getType()) { case EDITOR_TOOL_TYPE: attributes.put(WORKSPACE_TOOLING_EDITOR_ATTRIBUTE, tool.getId()); break; case PLUGIN_TOOL_TYPE: pluginsStringJoiner.add(tool.getId()); break; case KUBERNETES_TOOL_TYPE: continue; default: throw new DevfileFormatException( format(\"Unsupported tool %s type provided: %s\", tool.getName(), tool.getType())); } toolIdToNameMappingStringJoiner.add(tool.getId() + \"=\" + tool.getName()); } if (pluginsStringJoiner.length() > 0) { attributes.put(WORKSPACE_TOOLING_PLUGINS_ATTRIBUTE, pluginsStringJoiner.toString()); } if (toolIdToNameMappingStringJoiner.length() > 0) { attributes.put(ALIASES_WORKSPACE_ATTRIBUTE_NAME, toolIdToNameMappingStringJoiner.toString()); } config.setAttributes(attributes); List<CommandImpl> commands = new ArrayList<>(); devfile .getCommands() .forEach(command -> commands.addAll(devCommandToCommandImpls(devfile, command))); config.setCommands(commands); return config; }", "text": "throw exception?", "function_tokens": ["public", "\u0120Works", "pace", "Config", "Impl", "\u0120dev", "File", "To", "Works", "pace", "Config", "(", "Dev", "file", "\u0120dev", "file", ")", "\u0120throws", "\u0120Dev", "file", "Format", "Exception", "\u0120{", "\u0120validate", "Current", "Version", "(", "dev", "file", ");", "\u0120Works", "pace", "Config", "Impl", "\u0120config", "\u0120=", "\u0120new", "\u0120Works", "pace", "Config", "Impl", "();", "\u0120config", ".", "set", "Name", "(", "dev", "file", ".", "get", "Name", "());", "\u0120List", "<", "Project", "Config", "Impl", ">", "\u0120projects", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120dev", "file", ".", "get", "Project", "s", "().", "for", "Each", "(", "project", "\u0120->", "\u0120projects", ".", "add", "(", "dev", "Project", "To", "Project", "Config", "(", "project", "))", ");", "\u0120config", ".", "set", "Project", "s", "(", "projects", ");", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120attributes", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120String", "Jo", "iner", "\u0120plugins", "String", "Jo", "iner", "\u0120=", "\u0120new", "\u0120String", "Jo", "iner", "(", "\",\"", ");", "\u0120String", "Jo", "iner", "\u0120tool", "Id", "To", "Name", "M", "apping", "String", "Jo", "iner", "\u0120=", "\u0120new", "\u0120String", "Jo", "iner", "(", "\",\"", ");", "\u0120for", "\u0120(", "Tool", "\u0120tool", "\u0120:", "\u0120dev", "file", ".", "get", "Tools", "())", "\u0120{", "\u0120switch", "\u0120(", "tool", ".", "get", "Type", "())", "\u0120{", "\u0120case", "\u0120EDIT", "OR", "_", "TO", "OL", "_", "TYPE", ":", "\u0120attributes", ".", "put", "(", "WORK", "SP", "ACE", "_", "TO", "OL", "ING", "_", "EDIT", "OR", "_", "AT", "TR", "IB", "UTE", ",", "\u0120tool", ".", "get", "Id", "());", "\u0120break", ";", "\u0120case", "\u0120PL", "UG", "IN", "_", "TO", "OL", "_", "TYPE", ":", "\u0120plugins", "String", "Jo", "iner", ".", "add", "(", "tool", ".", "get", "Id", "());", "\u0120break", ";", "\u0120case", "\u0120K", "UB", "ER", "NET", "ES", "_", "TO", "OL", "_", "TYPE", ":", "\u0120continue", ";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Dev", "file", "Format", "Exception", "(", "\u0120format", "(\"", "Un", "supported", "\u0120tool", "\u0120%", "s", "\u0120type", "\u0120provided", ":", "\u0120%", "s", "\",", "\u0120tool", ".", "get", "Name", "(),", "\u0120tool", ".", "get", "Type", "()", "));", "\u0120}", "\u0120tool", "Id", "To", "Name", "M", "apping", "String", "Jo", "iner", ".", "add", "(", "tool", ".", "get", "Id", "()", "\u0120+", "\u0120\"", "=\"", "\u0120+", "\u0120tool", ".", "get", "Name", "());", "\u0120}", "\u0120if", "\u0120(", "plugins", "String", "Jo", "iner", ".", "length", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120attributes", ".", "put", "(", "WORK", "SP", "ACE", "_", "TO", "OL", "ING", "_", "PL", "UG", "INS", "_", "AT", "TR", "IB", "UTE", ",", "\u0120plugins", "String", "Jo", "iner", ".", "to", "String", "());", "\u0120}", "\u0120if", "\u0120(", "tool", "Id", "To", "Name", "M", "apping", "String", "Jo", "iner", ".", "length", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120attributes", ".", "put", "(", "AL", "IAS", "ES", "_", "WORK", "SP", "ACE", "_", "AT", "TR", "IB", "UTE", "_", "NAME", ",", "\u0120tool", "Id", "To", "Name", "M", "apping", "String", "Jo", "iner", ".", "to", "String", "());", "\u0120}", "\u0120config", ".", "set", "Attributes", "(", "att", "ributes", ");", "\u0120List", "<", "Command", "Impl", ">", "\u0120commands", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120dev", "file", "\u0120.", "get", "Comm", "ands", "()", "\u0120.", "for", "Each", "(", "command", "\u0120->", "\u0120commands", ".", "add", "All", "(", "dev", "Command", "To", "Command", "Impl", "s", "(", "dev", "file", ",", "\u0120command", "))", ");", "\u0120config", ".", "set", "Comm", "ands", "(", "comm", "ands", ");", "\u0120return", "\u0120config", ";", "\u0120}"], "docstring_tokens": ["throw", "\u0120exception", "?"]}
{"function": "public void testGetTaskRawFormViaUIClient() throws Exception { long processInstanceId = processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID); assertThat(processInstanceId).isGreaterThan(0); try { List<TaskSummary> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); assertThat(tasks).isNotNull().hasSize(1); Long taskId = tasks.get(0).getId(); String result = uiServicesClient.getTaskRawForm( CONTAINER_ID, taskId ); logger.debug(\"Form content is '{}'\", result); assertThat(result).isNotNull().isNotEmpty(); } finally { processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); } }", "text": "Please change user back to USER_YODA here.", "function_tokens": ["public", "\u0120void", "\u0120test", "Get", "Task", "Raw", "Form", "Via", "U", "IC", "l", "ient", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120long", "\u0120process", "Instance", "Id", "\u0120=", "\u0120process", "Client", ".", "start", "Process", "(", "CON", "TAIN", "ER", "_", "ID", ",", "\u0120H", "IR", "ING", "_", "2", "_", "PR", "OC", "ESS", "_", "ID", ");", "\u0120assert", "That", "(", "process", "Instance", "Id", ").", "is", "Great", "er", "Th", "an", "(", "0", ");", "\u0120try", "\u0120{", "\u0120List", "<", "Task", "Summary", ">", "\u0120tasks", "\u0120=", "\u0120task", "Client", ".", "find", "T", "asks", "By", "Status", "By", "Process", "Instance", "Id", "(", "process", "Instance", "Id", ",", "\u0120null", ",", "\u01200", ",", "\u012010", ");", "\u0120assert", "That", "(", "t", "asks", ").", "is", "Not", "Null", "().", "has", "Size", "(", "1", ");", "\u0120Long", "\u0120task", "Id", "\u0120=", "\u0120tasks", ".", "get", "(", "0", ").", "get", "Id", "();", "\u0120String", "\u0120result", "\u0120=", "\u0120u", "i", "Services", "Client", ".", "get", "Task", "Raw", "Form", "(", "\u0120CON", "TAIN", "ER", "_", "ID", ",", "\u0120task", "Id", "\u0120);", "\u0120logger", ".", "debug", "(\"", "Form", "\u0120content", "\u0120is", "\u0120'", "{", "}", "'", "\",", "\u0120result", ");", "\u0120assert", "That", "(", "result", ").", "is", "Not", "Null", "().", "is", "Not", "Empty", "();", "\u0120}", "\u0120finally", "\u0120{", "\u0120process", "Client", ".", "ab", "ort", "Process", "Instance", "(", "CON", "TAIN", "ER", "_", "ID", ",", "\u0120process", "Instance", "Id", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120change", "\u0120user", "\u0120back", "\u0120to", "\u0120US", "ER", "_", "Y", "OD", "A", "\u0120here", "."]}
{"function": "private void buyCard(GameUserBean gameUser, GameBean game, Map<String, String> returnedParams) throws PlayException, GameException { DevelopmentCards availableDevelopmentCards = game.getAvailableDevelopmentCards(); DevelopmentCard obtainedDevelopmentCard = cardUtil.pullDevelopmentCard(availableDevelopmentCards); DevelopmentCards usersDevelopmentCards = gameUser.getDevelopmentCards(); usersDevelopmentCards.increaseQuantityByOne(obtainedDevelopmentCard); availableDevelopmentCards.decreaseQuantityByOne(obtainedDevelopmentCard); returnedParams.put(\"card\", obtainedDevelopmentCard.name()); }", "text": "you don't take any resourcees from player when buying dev card", "function_tokens": ["private", "\u0120void", "\u0120buy", "Card", "(", "Game", "User", "Be", "an", "\u0120game", "User", ",", "\u0120Game", "Be", "an", "\u0120game", ",", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120returned", "Par", "ams", ")", "\u0120throws", "\u0120Play", "Exception", ",", "\u0120Game", "Exception", "\u0120{", "\u0120Development", "C", "ards", "\u0120available", "Development", "C", "ards", "\u0120=", "\u0120game", ".", "get", "Available", "Development", "C", "ards", "();", "\u0120Development", "Card", "\u0120obtained", "Development", "Card", "\u0120=", "\u0120card", "Ut", "il", ".", "pull", "Development", "Card", "(", "available", "Development", "C", "ards", ");", "\u0120Development", "C", "ards", "\u0120users", "Development", "C", "ards", "\u0120=", "\u0120game", "User", ".", "get", "Development", "C", "ards", "();", "\u0120users", "Development", "C", "ards", ".", "incre", "ase", "Quantity", "By", "One", "(", "ob", "tained", "Development", "Card", ");", "\u0120available", "Development", "C", "ards", ".", "dec", "re", "ase", "Quantity", "By", "One", "(", "ob", "tained", "Development", "Card", ");", "\u0120returned", "Par", "ams", ".", "put", "(\"", "card", "\",", "\u0120obtained", "Development", "Card", ".", "name", "());", "\u0120}"], "docstring_tokens": ["you", "\u0120don", "'t", "\u0120take", "\u0120any", "\u0120resource", "es", "\u0120from", "\u0120player", "\u0120when", "\u0120buying", "\u0120dev", "\u0120card"]}
{"function": "public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(\"Stream returnsCorrectInput!\").asBytes(); MatcherAssert.assertThat( \"Stream doesn't provide correct bytes\", new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }", "text": "@Serranya The same here. See above.", "function_tokens": ["public", "\u0120void", "\u0120returns", "Correct", "Input", "With", "Stream", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120final", "\u0120byte", "[]", "\u0120bytes", "\u0120=", "\u0120new", "\u0120Ut", "f", "8", "String", "(\"", "Stream", "\u0120returns", "Correct", "Input", "!\"", ").", "as", "Bytes", "();", "\u0120Mat", "cher", "Ass", "ert", ".", "assert", "That", "(", "\u0120\"", "Stream", "\u0120doesn", "'t", "\u0120provide", "\u0120correct", "\u0120bytes", "\",", "\u0120new", "\u0120By", "tes", "Of", "(", "\u0120new", "\u0120Body", ".", "Stream", "(", "new", "\u0120Input", "Of", "(", "bytes", ").", "stream", "())", "\u0120).", "as", "Bytes", "(),", "\u0120new", "\u0120Is", "E", "qual", "<", ">(", "bytes", ")", "\u0120);", "\u0120}"], "docstring_tokens": ["@", "Ser", "r", "anya", "\u0120The", "\u0120same", "\u0120here", ".", "\u0120See", "\u0120above", "."]}
{"function": "private void handleSelectorEvents(List<ResponseInfo> responseInfoList) { long handleSelectorEventsStartTimeMs = System.currentTimeMillis(); for (String connId : selector.connected()) { connectionTracker.checkInConnection(connId); } List<String> disconnectedList = selector.disconnected(); networkMetrics.connectionsDisconnectedCount.mark(disconnectedList.size()); for (String connId : disconnectedList) { connectionTracker.removeConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); if (requestMetadata != null) { responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), NetworkClientErrorCode.NetworkError, null)); } } for (NetworkReceive recv : selector.completedReceives()) { String connId = recv.getConnectionId(); connectionTracker.checkInConnection(connId); RequestMetadata requestMetadata = connectionIdToRequestInFlight.remove(connId); responseInfoList .add(new ResponseInfo(requestMetadata.requestInfo.getRequest(), null, recv.getReceivedBytes().getPayload())); requestMetadata.onResponseReceive(); } networkMetrics.handleSelectorEventsTime.update(System.currentTimeMillis() - handleSelectorEventsStartTimeMs); }", "text": "What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.", "function_tokens": ["private", "\u0120void", "\u0120handle", "Select", "or", "Events", "(", "List", "<", "Response", "Info", ">", "\u0120response", "Info", "List", ")", "\u0120{", "\u0120long", "\u0120handle", "Select", "or", "Events", "Start", "Time", "Ms", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120for", "\u0120(", "String", "\u0120conn", "Id", "\u0120:", "\u0120selector", ".", "connected", "())", "\u0120{", "\u0120connection", "Tracker", ".", "check", "In", "Connection", "(", "conn", "Id", ");", "\u0120}", "\u0120List", "<", "String", ">", "\u0120disconnected", "List", "\u0120=", "\u0120selector", ".", "dis", "connected", "();", "\u0120network", "Met", "rics", ".", "connect", "ions", "Dis", "connected", "Count", ".", "mark", "(", "dis", "connected", "List", ".", "size", "());", "\u0120for", "\u0120(", "String", "\u0120conn", "Id", "\u0120:", "\u0120disconnected", "List", ")", "\u0120{", "\u0120connection", "Tracker", ".", "remove", "Connection", "(", "conn", "Id", ");", "\u0120Request", "Met", "adata", "\u0120request", "Met", "adata", "\u0120=", "\u0120connection", "Id", "To", "Request", "In", "Flight", ".", "remove", "(", "conn", "Id", ");", "\u0120if", "\u0120(", "request", "Met", "adata", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120response", "Info", "List", "\u0120.", "add", "(", "new", "\u0120Response", "Info", "(", "request", "Met", "adata", ".", "request", "Info", ".", "get", "Request", "(),", "\u0120Network", "Client", "Error", "Code", ".", "Network", "Error", ",", "\u0120null", "));", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "Network", "Re", "ceive", "\u0120rec", "v", "\u0120:", "\u0120selector", ".", "com", "pleted", "Re", "ce", "ives", "())", "\u0120{", "\u0120String", "\u0120conn", "Id", "\u0120=", "\u0120rec", "v", ".", "get", "Connection", "Id", "();", "\u0120connection", "Tracker", ".", "check", "In", "Connection", "(", "conn", "Id", ");", "\u0120Request", "Met", "adata", "\u0120request", "Met", "adata", "\u0120=", "\u0120connection", "Id", "To", "Request", "In", "Flight", ".", "remove", "(", "conn", "Id", ");", "\u0120response", "Info", "List", "\u0120.", "add", "(", "new", "\u0120Response", "Info", "(", "request", "Met", "adata", ".", "request", "Info", ".", "get", "Request", "(),", "\u0120null", ",", "\u0120rec", "v", ".", "get", "Re", "ceived", "Bytes", "().", "get", "Pay", "load", "()", "));", "\u0120request", "Met", "adata", ".", "on", "Response", "Re", "ceive", "();", "\u0120}", "\u0120network", "Met", "rics", ".", "handle", "Select", "or", "Events", "Time", ".", "update", "(", "System", ".", "current", "Time", "Mill", "is", "()", "\u0120-", "\u0120handle", "Select", "or", "Events", "Start", "Time", "Ms", ");", "\u0120}"], "docstring_tokens": ["What", "\u0120is", "\u0120the", "\u0120use", "\u0120of", "\u0120this", "\u0120metric", "?", "\u0120There", "\u0120are", "\u0120no", "\u0120I", "/", "O", "\u0120or", "\u0120cpu", "\u0120intensive", "\u0120stuff", "\u0120being", "\u0120done", "\u0120within", "\u0120this", "\u0120method", "."]}
{"function": "public Void visitInstanceOf(InstanceOfTree node, Void p) { if (node.getType().getKind() == Kind.ANNOTATED_TYPE) { AnnotatedTypeMirror type = atypeFactory.fromExpression((ExpressionTree) node.getType()); if (type.hasAnnotation(Nullable.class)) { checker.reportError(node, \"instanceof.nullable.error\"); } if (type.hasAnnotation(NonNull.class)) { checker.reportWarning(node, \"instanceof.nonnull.redundant\"); } } return super.visitInstanceOf(node, p); }", "text": "Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.", "function_tokens": ["public", "\u0120Void", "\u0120visit", "Instance", "Of", "(", "Instance", "Of", "Tree", "\u0120node", ",", "\u0120Void", "\u0120p", ")", "\u0120{", "\u0120if", "\u0120(", "node", ".", "get", "Type", "().", "get", "Kind", "()", "\u0120==", "\u0120Kind", ".", "AN", "NOT", "ATED", "_", "TYPE", ")", "\u0120{", "\u0120An", "not", "ated", "Type", "Mir", "ror", "\u0120type", "\u0120=", "\u0120at", "ype", "Factory", ".", "from", "Exp", "ression", "((", "Exp", "ression", "Tree", ")", "\u0120node", ".", "get", "Type", "());", "\u0120if", "\u0120(", "type", ".", "has", "An", "notation", "(", "Null", "able", ".", "class", "))", "\u0120{", "\u0120check", "er", ".", "report", "Error", "(", "node", ",", "\u0120\"", "instance", "of", ".", "null", "able", ".", "error", "\");", "\u0120}", "\u0120if", "\u0120(", "type", ".", "has", "An", "notation", "(", "Non", "Null", ".", "class", "))", "\u0120{", "\u0120check", "er", ".", "report", "Warning", "(", "node", ",", "\u0120\"", "instance", "of", ".", "non", "null", ".", "red", "und", "ant", "\");", "\u0120}", "\u0120}", "\u0120return", "\u0120super", ".", "vis", "it", "Instance", "Of", "(", "node", ",", "\u0120p", ");", "\u0120}"], "docstring_tokens": ["Could", "\u0120you", ":", "\u0120-", "\u0120call", "\u0120Tree", "Ut", "ils", ".", "annot", "ations", "From", "Tree", "()", "\u0120-", "\u0120use", "\u0120An", "notation", "Ut", "ils", ".", "cont", "ains", "Same", "\u0120to", "\u0120look", "\u0120for", "\u0120the", "\u0120annotations", "\u0120Then", "\u0120you", "\u0120don", "'t", "\u0120need", "\u0120to", "\u0120change", "\u0120the", "\u0120visibility", "\u0120below", "."]}
{"function": "public void onStartup(ServletContext servletContext) { LongTaskTimer longTaskTimer = LongTaskTimer .builder(\"spring.cloud.dataflow.server\").description(\"DataFlow duration timer\") .tags(Tags.empty()).register(Metrics.globalRegistry); this.longTaskSample = longTaskTimer.start(); if (StringUtils.hasText(dataSourceUrl) && dataSourceUrl.startsWith(\"jdbc:h2:tcp://localhost:\")) { logger.info(\"Start Embedded H2\"); initH2TCPServer(); } }", "text": "Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow", "function_tokens": ["public", "\u0120void", "\u0120on", "Start", "up", "(", "Serv", "let", "Context", "\u0120serv", "let", "Context", ")", "\u0120{", "\u0120Long", "Task", "Timer", "\u0120long", "Task", "Timer", "\u0120=", "\u0120Long", "Task", "Timer", "\u0120.", "builder", "(\"", "spring", ".", "cloud", ".", "data", "flow", ".", "server", "\").", "description", "(\"", "Data", "Flow", "\u0120duration", "\u0120timer", "\")", "\u0120.", "tags", "(", "Tags", ".", "empty", "()", ").", "register", "(", "Met", "rics", ".", "global", "Reg", "istry", ");", "\u0120this", ".", "long", "Task", "Sample", "\u0120=", "\u0120long", "Task", "Timer", ".", "start", "();", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "has", "Text", "(", "data", "Source", "Url", ")", "\u0120&&", "\u0120data", "Source", "Url", ".", "st", "arts", "With", "(\"", "j", "db", "c", ":", "h", "2", ":", "t", "cp", "://", "localhost", ":\"", "))", "\u0120{", "\u0120logger", ".", "info", "(\"", "Start", "\u0120Emb", "edded", "\u0120H", "2", "\");", "\u0120init", "H", "2", "TC", "PS", "erver", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Not", "\u0120sure", "\u0120if", "\u0120this", "\u0120description", "\u0120will", "\u0120be", "\u0120displayed", "\u0120anywhere", ".", "\u0120If", "\u0120it", "\u0120gets", "\u0120displayed", ",", "\u0120please", "\u0120change", "\u0120the", "\u0120name", "\u0120Data", "Flow", "\u0120to", "\u0120Spring", "\u0120Cloud", "\u0120Data", "\u0120Flow"]}
{"function": "public String getJournalKeyFromDoi(String doi, Site site) { Map<String, Object> journalDoiRegexList = getJournalDoiRegexList(site); for (Map.Entry<String, Object> entry : journalDoiRegexList.entrySet()) { if (doi.matches(entry.getValue().toString())) { return entry.getKey(); } } return null; }", "text": "String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.", "function_tokens": ["public", "\u0120String", "\u0120get", "Journal", "Key", "From", "Do", "i", "(", "String", "\u0120doi", ",", "\u0120Site", "\u0120site", ")", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120journal", "Do", "i", "Re", "gex", "List", "\u0120=", "\u0120get", "Journal", "Do", "i", "Re", "gex", "List", "(", "site", ");", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120Object", ">", "\u0120entry", "\u0120:", "\u0120journal", "Do", "i", "Re", "gex", "List", ".", "entry", "Set", "())", "\u0120{", "\u0120if", "\u0120(", "doi", ".", "mat", "ches", "(", "entry", ".", "get", "Value", "().", "to", "String", "()", "))", "\u0120{", "\u0120return", "\u0120entry", ".", "get", "Key", "();", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["String", ".", "mat", "ches", "\u0120can", "\u0120be", "\u0120expensive", ".", "\u0120If", "\u0120we", "'re", "\u0120caching", "\u0120the", "\u0120list", "\u0120of", "\u0120pattern", "\u0120per", "\u0120Site", ",", "\u0120it", "\u0120would", "\u0120be", "\u0120best", "\u0120to", "\u0120cache", "\u0120compiled", "\u0120java", ".", "util", ".", "re", "gex", ".", "Pattern", "\u0120objects", "."]}
{"function": "private void addSidecar( PodData pod, CheContainer container, ChePlugin chePlugin, KubernetesEnvironment kubernetesEnvironment, Collection<CommandImpl> sidecarRelatedCommands) throws InfrastructureException { K8sContainerResolver k8sContainerResolver = new K8sContainerResolverBuilder() .setContainer(container) .setImagePullPolicy(sidecarImagePullPolicy) .setPluginName(chePlugin.getName()) .setPluginEndpoints(chePlugin.getEndpoints()) .build(); List<ChePluginEndpoint> containerEndpoints = k8sContainerResolver.getEndpoints(); Container k8sContainer = k8sContainerResolver.resolve(); String machineName = Names.machineName(pod, k8sContainer); pod.getSpec().getContainers().add(k8sContainer); MachineResolver machineResolver = new MachineResolverBuilder() .setCheContainer(container) .setContainer(k8sContainer) .setContainerEndpoints(containerEndpoints) .setDefaultSidecarMemorySizeAttribute(defaultSidecarMemoryLimitBytes) .setAttributes(kubernetesEnvironment.getAttributes()) .build(); InternalMachineConfig machineConfig = machineResolver.resolve(); machineConfig.getAttributes().put(CONTAINER_TYPE_ATTRIBUTE, \"tool-container\"); kubernetesEnvironment.getMachines().put(machineName, machineConfig); sidecarRelatedCommands.forEach(c -> c.getAttributes().put(\"machineName\", machineName)); container .getCommands() .stream() .map(c -> asCommand(machineName, c)) .forEach(c -> kubernetesEnvironment.getCommands().add(c)); SidecarServicesProvisioner sidecarServicesProvisioner = new SidecarServicesProvisioner(containerEndpoints, pod.getMetadata().getName()); sidecarServicesProvisioner.provision(kubernetesEnvironment); }", "text": "It would be better to make value a constant too", "function_tokens": ["private", "\u0120void", "\u0120add", "Side", "car", "(", "\u0120Pod", "Data", "\u0120pod", ",", "\u0120Che", "Container", "\u0120container", ",", "\u0120Che", "Plugin", "\u0120che", "Plugin", ",", "\u0120Ku", "ber", "net", "es", "Environment", "\u0120k", "uber", "net", "es", "Environment", ",", "\u0120Collection", "<", "Command", "Impl", ">", "\u0120side", "car", "Related", "Comm", "ands", ")", "\u0120throws", "\u0120Infrastructure", "Exception", "\u0120{", "\u0120K", "8", "s", "Container", "Res", "olver", "\u0120k", "8", "s", "Container", "Res", "olver", "\u0120=", "\u0120new", "\u0120K", "8", "s", "Container", "Res", "olver", "Builder", "()", "\u0120.", "set", "Container", "(", "container", ")", "\u0120.", "set", "Image", "Pull", "Policy", "(", "side", "car", "Image", "Pull", "Policy", ")", "\u0120.", "set", "Plugin", "Name", "(", "che", "Plugin", ".", "get", "Name", "())", "\u0120.", "set", "Plugin", "End", "points", "(", "che", "Plugin", ".", "get", "End", "points", "())", "\u0120.", "build", "();", "\u0120List", "<", "Che", "Plugin", "End", "point", ">", "\u0120container", "End", "points", "\u0120=", "\u0120k", "8", "s", "Container", "Res", "olver", ".", "get", "End", "points", "();", "\u0120Container", "\u0120k", "8", "s", "Container", "\u0120=", "\u0120k", "8", "s", "Container", "Res", "olver", ".", "res", "olve", "();", "\u0120String", "\u0120machine", "Name", "\u0120=", "\u0120Names", ".", "machine", "Name", "(", "pod", ",", "\u0120k", "8", "s", "Container", ");", "\u0120pod", ".", "get", "Spec", "().", "get", "Cont", "ainers", "().", "add", "(", "k", "8", "s", "Container", ");", "\u0120Machine", "Res", "olver", "\u0120machine", "Res", "olver", "\u0120=", "\u0120new", "\u0120Machine", "Res", "olver", "Builder", "()", "\u0120.", "set", "Che", "Container", "(", "container", ")", "\u0120.", "set", "Container", "(", "k", "8", "s", "Container", ")", "\u0120.", "set", "Container", "End", "points", "(", "container", "End", "points", ")", "\u0120.", "set", "Default", "Side", "car", "Memory", "Size", "Attribute", "(", "default", "Side", "car", "Memory", "Limit", "Bytes", ")", "\u0120.", "set", "Attributes", "(", "k", "uber", "net", "es", "Environment", ".", "get", "Attributes", "())", "\u0120.", "build", "();", "\u0120Internal", "Machine", "Config", "\u0120machine", "Config", "\u0120=", "\u0120machine", "Res", "olver", ".", "res", "olve", "();", "\u0120machine", "Config", ".", "get", "Attributes", "().", "put", "(", "CON", "TAIN", "ER", "_", "TYPE", "_", "AT", "TR", "IB", "UTE", ",", "\u0120\"", "tool", "-", "container", "\");", "\u0120k", "uber", "net", "es", "Environment", ".", "get", "Mach", "ines", "().", "put", "(", "machine", "Name", ",", "\u0120machine", "Config", ");", "\u0120side", "car", "Related", "Comm", "ands", ".", "for", "Each", "(", "c", "\u0120->", "\u0120c", ".", "get", "Attributes", "().", "put", "(\"", "machine", "Name", "\",", "\u0120machine", "Name", "));", "\u0120container", "\u0120.", "get", "Comm", "ands", "()", "\u0120.", "stream", "()", "\u0120.", "map", "(", "c", "\u0120->", "\u0120as", "Command", "(", "machine", "Name", ",", "\u0120c", "))", "\u0120.", "for", "Each", "(", "c", "\u0120->", "\u0120k", "uber", "net", "es", "Environment", ".", "get", "Comm", "ands", "().", "add", "(", "c", "));", "\u0120Side", "car", "Services", "Pro", "vision", "er", "\u0120side", "car", "Services", "Pro", "vision", "er", "\u0120=", "\u0120new", "\u0120Side", "car", "Services", "Pro", "vision", "er", "(", "container", "End", "points", ",", "\u0120pod", ".", "get", "Met", "adata", "().", "get", "Name", "());", "\u0120side", "car", "Services", "Pro", "vision", "er", ".", "pro", "vision", "(", "k", "uber", "net", "es", "Environment", ");", "\u0120}"], "docstring_tokens": ["It", "\u0120would", "\u0120be", "\u0120better", "\u0120to", "\u0120make", "\u0120value", "\u0120a", "\u0120constant", "\u0120too"]}
{"function": "@Override public void draw(Canvas canvas) { if (!animating) { image.draw(canvas); } else { if (placeholder != null) { placeholder.draw(canvas); } float normalized = (SystemClock.uptimeMillis() - startTimeMillis) / FADE_DURATION; int alpha = (int) (0xFF * normalized); if (normalized >= 1f) { animating = false; placeholder = null; image.setAlpha(0xFF); image.draw(canvas); } else { image.setAlpha(alpha); image.draw(canvas); invalidateSelf(); } } if (debugging) { drawDebugIndicator(canvas); } }", "text": "Don't we need to reset alpha here? Drawables share a global state.", "function_tokens": ["@", "Override", "\u0120public", "\u0120void", "\u0120draw", "(", "Can", "vas", "\u0120canvas", ")", "\u0120{", "\u0120if", "\u0120(!", "anim", "ating", ")", "\u0120{", "\u0120image", ".", "draw", "(", "can", "vas", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120if", "\u0120(", "place", "holder", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120placeholder", ".", "draw", "(", "can", "vas", ");", "\u0120}", "\u0120float", "\u0120normalized", "\u0120=", "\u0120(", "System", "Clock", ".", "upt", "ime", "Mill", "is", "()", "\u0120-", "\u0120start", "Time", "Mill", "is", ")", "\u0120/", "\u0120F", "ADE", "_", "D", "UR", "ATION", ";", "\u0120int", "\u0120alpha", "\u0120=", "\u0120(", "int", ")", "\u0120(", "0", "x", "FF", "\u0120*", "\u0120normalized", ");", "\u0120if", "\u0120(", "normal", "ized", "\u0120>=", "\u01201", "f", ")", "\u0120{", "\u0120anim", "ating", "\u0120=", "\u0120false", ";", "\u0120placeholder", "\u0120=", "\u0120null", ";", "\u0120image", ".", "set", "Alpha", "(", "0", "x", "FF", ");", "\u0120image", ".", "draw", "(", "can", "vas", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120image", ".", "set", "Alpha", "(", "alpha", ");", "\u0120image", ".", "draw", "(", "can", "vas", ");", "\u0120invalid", "ate", "Self", "();", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "debug", "ging", ")", "\u0120{", "\u0120draw", "Debug", "Ind", "icator", "(", "can", "vas", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Don", "'t", "\u0120we", "\u0120need", "\u0120to", "\u0120reset", "\u0120alpha", "\u0120here", "?", "\u0120Draw", "ables", "\u0120share", "\u0120a", "\u0120global", "\u0120state", "."]}
{"function": "public void addingAStudentAddsThemToTheSortedRoster() { school = new School(); school.add(\"Aimee\", 2); List<String> expected = Arrays.asList(\"Aimee\"); assertEquals(expected,school.roster()); }", "text": "There should be a space here between expected and school.roster()", "function_tokens": ["public", "\u0120void", "\u0120adding", "A", "Student", "Adds", "The", "m", "To", "The", "S", "orted", "R", "oster", "()", "\u0120{", "\u0120school", "\u0120=", "\u0120new", "\u0120School", "();", "\u0120school", ".", "add", "(\"", "A", "ime", "e", "\",", "\u01202", ");", "\u0120List", "<", "String", ">", "\u0120expected", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(\"", "A", "ime", "e", "\");", "\u0120assert", "Equ", "als", "(", "expected", ",", "school", ".", "ro", "ster", "());", "\u0120}"], "docstring_tokens": ["There", "\u0120should", "\u0120be", "\u0120a", "\u0120space", "\u0120here", "\u0120between", "\u0120expected", "\u0120and", "\u0120school", ".", "ro", "ster", "()"]}
{"function": "public static <T extends RemoteJsonService> T create(Class<T> serviceClass, GerritHttpClient gerritHttpClient, Version version) { String uri = GerritVersion.isVersion26OrLater(version) ? \"/gerrit_ui/rpc/\" : \"/gerrit/rpc/\"; InvocationHandler handler = new GerritService(gerritHttpClient, uri + serviceClass.getSimpleName()); return serviceClass.cast(Proxy.newProxyInstance(GerritService.class.getClassLoader(), new Class<?>[] { serviceClass }, handler)); }", "text": "We should put the URL fragments into static vars in a common file then select them based on version in one place rather than scatterred throughout code.", "function_tokens": ["public", "\u0120static", "\u0120<", "T", "\u0120extends", "\u0120Remote", "J", "son", "Service", ">", "\u0120T", "\u0120create", "(", "Class", "<", "T", ">", "\u0120service", "Class", ",", "\u0120Ger", "rit", "Http", "Client", "\u0120ger", "rit", "Http", "Client", ",", "\u0120Version", "\u0120version", ")", "\u0120{", "\u0120String", "\u0120ur", "i", "\u0120=", "\u0120Ger", "rit", "Version", ".", "is", "Version", "26", "Or", "Later", "(", "version", ")", "\u0120?", "\u0120\"/", "ger", "rit", "_", "ui", "/", "r", "pc", "/\"", "\u0120:", "\u0120\"/", "ger", "rit", "/", "r", "pc", "/", "\";", "\u0120Inv", "ocation", "Handler", "\u0120handler", "\u0120=", "\u0120new", "\u0120Ger", "rit", "Service", "(", "ger", "rit", "Http", "Client", ",", "\u0120ur", "i", "\u0120+", "\u0120service", "Class", ".", "get", "Simple", "Name", "());", "\u0120return", "\u0120service", "Class", ".", "cast", "(", "Proxy", ".", "new", "Proxy", "Instance", "(", "Ger", "rit", "Service", ".", "class", ".", "get", "Class", "Loader", "(),", "\u0120new", "\u0120Class", "<?", ">", "[]", "\u0120{", "\u0120service", "Class", "\u0120},", "\u0120handler", "));", "\u0120}"], "docstring_tokens": ["We", "\u0120should", "\u0120put", "\u0120the", "\u0120URL", "\u0120fragments", "\u0120into", "\u0120static", "\u0120v", "ars", "\u0120in", "\u0120a", "\u0120common", "\u0120file", "\u0120then", "\u0120select", "\u0120them", "\u0120based", "\u0120on", "\u0120version", "\u0120in", "\u0120one", "\u0120place", "\u0120rather", "\u0120than", "\u0120scatter", "red", "\u0120throughout", "\u0120code", "."]}
{"function": "public V replace(K key, V value) { V v = delegate.replace(key, value); if (v != null) { stats.incrementCacheHits(); } else { stats.incrementCacheMisses(); } stats.incrementCachePuts(); return v; }", "text": "This should be in the if(v != null) check I am thinking", "function_tokens": ["public", "\u0120V", "\u0120replace", "(", "K", "\u0120key", ",", "\u0120V", "\u0120value", ")", "\u0120{", "\u0120V", "\u0120v", "\u0120=", "\u0120delegate", ".", "replace", "(", "key", ",", "\u0120value", ");", "\u0120if", "\u0120(", "v", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120stats", ".", "incre", "ment", "Cache", "H", "its", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120stats", ".", "incre", "ment", "Cache", "Miss", "es", "();", "\u0120}", "\u0120stats", ".", "incre", "ment", "Cache", "P", "uts", "();", "\u0120return", "\u0120v", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120should", "\u0120be", "\u0120in", "\u0120the", "\u0120if", "(", "v", "\u0120!=", "\u0120null", ")", "\u0120check", "\u0120I", "\u0120am", "\u0120thinking"]}
{"function": "public JCloudsSlave( @Nonnull ProvisioningActivity.Id id, @Nonnull Server metadata, @Nonnull String labelString, @Nonnull SlaveOptions slaveOptions ) throws IOException, Descriptor.FormException { super( metadata.getName(), null, slaveOptions.getFsRoot(), slaveOptions.getNumExecutors(), Mode.NORMAL, labelString, null, new JCloudsRetentionStrategy(), Collections.singletonList(new EnvironmentVariablesNodeProperty( new EnvironmentVariablesNodeProperty.Entry(\"OPENSTACK_PUBLIC_IP\", Openstack.getPublicAddress(metadata)) )) ); this.cloudName = id.getCloudName(); this.provisioningId = id; this.options = slaveOptions; this.nodeId = metadata.getId(); final Map<String, String> instanceMetaData = metadata.getMetadata(); if (instanceMetaData != null && !instanceMetaData.isEmpty()) { this.openstackMetaData = new TreeMap<>(instanceMetaData); } else { this.openstackMetaData = null; } setLauncher(new JCloudsLauncher(getLauncherFactory().createLauncher(this))); }", "text": "Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.", "function_tokens": ["public", "\u0120J", "Cloud", "s", "Sl", "ave", "(", "\u0120@", "Non", "null", "\u0120Provision", "ing", "Activity", ".", "Id", "\u0120id", ",", "\u0120@", "Non", "null", "\u0120Server", "\u0120metadata", ",", "\u0120@", "Non", "null", "\u0120String", "\u0120label", "String", ",", "\u0120@", "Non", "null", "\u0120Slave", "Options", "\u0120slave", "Options", "\u0120)", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Des", "cript", "or", ".", "Form", "Exception", "\u0120{", "\u0120super", "(", "\u0120metadata", ".", "get", "Name", "(),", "\u0120null", ",", "\u0120slave", "Options", ".", "get", "Fs", "Root", "(),", "\u0120slave", "Options", ".", "get", "Num", "Exec", "ut", "ors", "(),", "\u0120Mode", ".", "NOR", "MAL", ",", "\u0120label", "String", ",", "\u0120null", ",", "\u0120new", "\u0120J", "Cloud", "s", "Ret", "ention", "Str", "ategy", "(),", "\u0120Collections", ".", "sing", "leton", "List", "(", "new", "\u0120Environment", "Vari", "ables", "Node", "Property", "(", "\u0120new", "\u0120Environment", "Vari", "ables", "Node", "Property", ".", "Entry", "(\"", "OP", "EN", "ST", "ACK", "_", "PU", "BLIC", "_", "IP", "\",", "\u0120Open", "stack", ".", "get", "Public", "Address", "(", "metadata", "))", "\u0120))", "\u0120);", "\u0120this", ".", "cloud", "Name", "\u0120=", "\u0120id", ".", "get", "Cloud", "Name", "();", "\u0120this", ".", "pro", "vision", "ing", "Id", "\u0120=", "\u0120id", ";", "\u0120this", ".", "options", "\u0120=", "\u0120slave", "Options", ";", "\u0120this", ".", "node", "Id", "\u0120=", "\u0120metadata", ".", "get", "Id", "();", "\u0120final", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120instance", "Meta", "Data", "\u0120=", "\u0120metadata", ".", "get", "Met", "adata", "();", "\u0120if", "\u0120(", "instance", "Meta", "Data", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "instance", "Meta", "Data", ".", "is", "Empty", "())", "\u0120{", "\u0120this", ".", "open", "stack", "Meta", "Data", "\u0120=", "\u0120new", "\u0120Tree", "Map", "<", ">(", "instance", "Meta", "Data", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120this", ".", "open", "stack", "Meta", "Data", "\u0120=", "\u0120null", ";", "\u0120}", "\u0120set", "Laun", "cher", "(", "new", "\u0120J", "Cloud", "s", "Laun", "cher", "(", "get", "Laun", "cher", "Factory", "().", "create", "Laun", "cher", "(", "this", "))", ");", "\u0120}"], "docstring_tokens": ["Initial", "ize", "\u0120it", "\u0120to", "\u0120Collections", ".", "empty", "Map", "()", "\u0120right", "\u0120away", "\u0120so", "\u0120you", "\u0120can", "\u0120forget", "\u0120about", "\u0120the", "\u0120null", "\u0120in", "\u0120get", "Open", "stack", "Meta", "Data", "().", "\u0120It", "\u0120will", "\u0120also", "\u0120save", "\u0120some", "\u0120un", "needed", "\u0120allocations", "."]}
{"function": "protected List<SurveyGroupDto> parseSurveyGroups(String response) throws Exception { List<SurveyGroupDto> dtoList = new ArrayList<SurveyGroupDto>(); JSONArray jsonArray = getJsonArray(response); if (jsonArray == null) { return dtoList; } for (int i = 0; i < jsonArray.length(); i++) { JSONObject o = jsonArray.getJSONObject(i); if (o != null) { try { SurveyGroupDto dto = new SurveyGroupDto(); if (o.has(\"name\") && o.isNull(\"name\")) { dto.setName(o.getString(\"name\")); } if (!o.has(\"monitoringGroup\") || o.isNull(\"monitoringGroup\")) { dto.setMonitoringGroup(false); } else { dto.setMonitoringGroup(o.getBoolean(\"monitoringGroup\")); } dtoList.add(dto); } catch (Exception e) { System.out.println(\"Error in json parsing: \" + e.getMessage()); e.printStackTrace(); } } } return dtoList; }", "text": "I guess you mean !o.isNull(\"name\")? Which by itself would be enough. No need for the o.has(\"name\")", "function_tokens": ["protected", "\u0120List", "<", "Sur", "vey", "Group", "D", "to", ">", "\u0120parse", "Sur", "vey", "G", "roups", "(", "String", "\u0120response", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120List", "<", "Sur", "vey", "Group", "D", "to", ">", "\u0120d", "to", "List", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "Sur", "vey", "Group", "D", "to", ">", "();", "\u0120JSON", "Array", "\u0120json", "Array", "\u0120=", "\u0120get", "J", "son", "Array", "(", "response", ");", "\u0120if", "\u0120(", "json", "Array", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120d", "to", "List", ";", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120json", "Array", ".", "length", "();", "\u0120i", "++)", "\u0120{", "\u0120JSON", "Object", "\u0120o", "\u0120=", "\u0120json", "Array", ".", "get", "JSON", "Object", "(", "i", ");", "\u0120if", "\u0120(", "o", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Survey", "Group", "D", "to", "\u0120d", "to", "\u0120=", "\u0120new", "\u0120Survey", "Group", "D", "to", "();", "\u0120if", "\u0120(", "o", ".", "has", "(\"", "name", "\")", "\u0120&&", "\u0120o", ".", "is", "Null", "(\"", "name", "\"))", "\u0120{", "\u0120d", "to", ".", "set", "Name", "(", "o", ".", "get", "String", "(\"", "name", "\")", ");", "\u0120}", "\u0120if", "\u0120(!", "o", ".", "has", "(\"", "monitor", "ing", "Group", "\")", "\u0120||", "\u0120o", ".", "is", "Null", "(\"", "monitor", "ing", "Group", "\"))", "\u0120{", "\u0120d", "to", ".", "set", "Monitor", "ing", "Group", "(", "false", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120d", "to", ".", "set", "Monitor", "ing", "Group", "(", "o", ".", "get", "Boo", "lean", "(\"", "monitor", "ing", "Group", "\")", ");", "\u0120}", "\u0120d", "to", "List", ".", "add", "(", "d", "to", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120System", ".", "out", ".", "println", "(\"", "Error", "\u0120in", "\u0120json", "\u0120parsing", ":", "\u0120\"", "\u0120+", "\u0120e", ".", "get", "Message", "());", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120return", "\u0120d", "to", "List", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120guess", "\u0120you", "\u0120mean", "\u0120!", "o", ".", "is", "Null", "(\"", "name", "\")", "?", "\u0120Which", "\u0120by", "\u0120itself", "\u0120would", "\u0120be", "\u0120enough", ".", "\u0120No", "\u0120need", "\u0120for", "\u0120the", "\u0120o", ".", "has", "(\"", "name", "\")"]}
{"function": "public Factory build() { BitSet redacted = new BitSet(); List<String> fields = new ArrayList<>(), keys = new ArrayList<>(); List<Integer> keyToFieldList = new ArrayList<>(); int i = 0; for (String fieldName : fieldNames) { if (redactedFieldNames.contains(fieldName)) redacted.set(i); fields.add(fieldName); keys.add(fieldName); keyToFieldList.add(i++); } for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) { String nextPrefix = entry.getKey(); String[] nextFieldNames = entry.getValue(); for (i = 0; i < nextFieldNames.length; i++) { String nextFieldName = nextFieldNames[i]; int index = fields.indexOf(nextFieldName); if (index == -1) { index = fields.size(); fields.add(nextFieldName); } keys.add(nextPrefix + nextFieldName); keyToFieldList.add(index); } } int[] keyToField = new int[keys.size()]; for (i = 0; i < keyToField.length; i++) { keyToField[i] = keyToFieldList.get(i); } String[] validated = fields.toArray(new String[0]); if (validated.length == 0) return new Factory(delegate); return new RealFactory(delegate, validated, keys.toArray(new String[0]), keyToField, redacted); }", "text": "Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...", "function_tokens": ["public", "\u0120Factory", "\u0120build", "()", "\u0120{", "\u0120Bit", "Set", "\u0120redacted", "\u0120=", "\u0120new", "\u0120Bit", "Set", "();", "\u0120List", "<", "String", ">", "\u0120fields", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "(),", "\u0120keys", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120List", "<", "Integer", ">", "\u0120key", "To", "Field", "List", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120for", "\u0120(", "String", "\u0120field", "Name", "\u0120:", "\u0120field", "Names", ")", "\u0120{", "\u0120if", "\u0120(", "red", "acted", "Field", "Names", ".", "cont", "ains", "(", "field", "Name", "))", "\u0120redacted", ".", "set", "(", "i", ");", "\u0120fields", ".", "add", "(", "field", "Name", ");", "\u0120keys", ".", "add", "(", "field", "Name", ");", "\u0120key", "To", "Field", "List", ".", "add", "(", "i", "++", ");", "\u0120}", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120String", "[]", ">", "\u0120entry", "\u0120:", "\u0120pref", "ixed", "Names", ".", "entry", "Set", "())", "\u0120{", "\u0120String", "\u0120next", "Pref", "ix", "\u0120=", "\u0120entry", ".", "get", "Key", "();", "\u0120String", "[]", "\u0120next", "Field", "Names", "\u0120=", "\u0120entry", ".", "get", "Value", "();", "\u0120for", "\u0120(", "i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120next", "Field", "Names", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120String", "\u0120next", "Field", "Name", "\u0120=", "\u0120next", "Field", "Names", "[", "i", "];", "\u0120int", "\u0120index", "\u0120=", "\u0120fields", ".", "index", "Of", "(", "next", "Field", "Name", ");", "\u0120if", "\u0120(", "index", "\u0120==", "\u0120-", "1", ")", "\u0120{", "\u0120index", "\u0120=", "\u0120fields", ".", "size", "();", "\u0120fields", ".", "add", "(", "next", "Field", "Name", ");", "\u0120}", "\u0120keys", ".", "add", "(", "next", "Pref", "ix", "\u0120+", "\u0120next", "Field", "Name", ");", "\u0120key", "To", "Field", "List", ".", "add", "(", "index", ");", "\u0120}", "\u0120}", "\u0120int", "[]", "\u0120key", "To", "Field", "\u0120=", "\u0120new", "\u0120int", "[", "keys", ".", "size", "()", "];", "\u0120for", "\u0120(", "i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120key", "To", "Field", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120key", "To", "Field", "[", "i", "]", "\u0120=", "\u0120key", "To", "Field", "List", ".", "get", "(", "i", ");", "\u0120}", "\u0120String", "[]", "\u0120validated", "\u0120=", "\u0120fields", ".", "to", "Array", "(", "new", "\u0120String", "[", "0", "]);", "\u0120if", "\u0120(", "valid", "ated", ".", "length", "\u0120==", "\u01200", ")", "\u0120return", "\u0120new", "\u0120Factory", "(", "de", "legate", ");", "\u0120return", "\u0120new", "\u0120Real", "Factory", "(", "de", "legate", ",", "\u0120validated", ",", "\u0120keys", ".", "to", "Array", "(", "new", "\u0120String", "[", "0", "]),", "\u0120key", "To", "Field", ",", "\u0120redacted", ");", "\u0120}"], "docstring_tokens": ["Since", "\u0120we", "'re", "\u0120not", "\u0120doing", "\u0120any", "\u0120extra", "\u0120validation", "\u0120here", "\u0120this", "\u0120is", "\u0120confusing", "\u0120to", "\u0120me", ".", "\u0120How", "\u0120about", "\u0120java", "\u0120if", "\u0120(", "fields", ".", "is", "Empty", "())", "\u0120return", "\u0120new", "\u0120Factory", "(", "de", "legate", ");", "\u0120return", "\u0120new", "\u0120Real", "Factory", "(", "de", "legate", ",", "\u0120fields", ".", "to", "Array", "(", "..."]}
{"function": "public static String minimalEscape(Object content) { if (content == null) { return null; } String str = String.valueOf(content); StringBuilder result = new StringBuilder((int) (str.length() * 1.1)); int length = str.length(); char c; for (int i = 0; i < length; ++i) { c = str.charAt(i); switch (c) { case '&': result.append(AMP); break; case '<': result.append(LT); break; default: result.append(c); } } return result.toString(); }", "text": "Missing Unstable attribute.", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120minimal", "E", "scape", "(", "Object", "\u0120content", ")", "\u0120{", "\u0120if", "\u0120(", "content", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120String", "\u0120str", "\u0120=", "\u0120String", ".", "value", "Of", "(", "content", ");", "\u0120String", "Builder", "\u0120result", "\u0120=", "\u0120new", "\u0120String", "Builder", "((", "int", ")", "\u0120(", "str", ".", "length", "()", "\u0120*", "\u01201", ".", "1", "));", "\u0120int", "\u0120length", "\u0120=", "\u0120str", ".", "length", "();", "\u0120char", "\u0120c", ";", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120length", ";", "\u0120++", "i", ")", "\u0120{", "\u0120c", "\u0120=", "\u0120str", ".", "char", "At", "(", "i", ");", "\u0120switch", "\u0120(", "c", ")", "\u0120{", "\u0120case", "\u0120'", "&", "':", "\u0120result", ".", "append", "(", "AMP", ");", "\u0120break", ";", "\u0120case", "\u0120'", "<", "':", "\u0120result", ".", "append", "(", "LT", ");", "\u0120break", ";", "\u0120default", ":", "\u0120result", ".", "append", "(", "c", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120result", ".", "to", "String", "();", "\u0120}"], "docstring_tokens": ["Missing", "\u0120Un", "stable", "\u0120attribute", "."]}
{"function": "public void overloadedMethodsGetResolved() throws Exception { provider = new ExtensionAwareEvaluationContextProvider( Collections.singletonList(new DummyExtension(\"_first\", \"first\") { @Override public Object getRootObject() { return new RootWithOverloads(); } })); assertThat(evaluateExpression(\"method()\")).isEqualTo(\"zero\"); assertThat(evaluateExpression(\"method(23)\")).isEqualTo(\"single-int\"); assertThat(evaluateExpression(\"method('hello')\")).isEqualTo(\"single-string\"); assertThat(evaluateExpression(\"method('one', 'two')\")).isEqualTo(\"two\"); assertThat(evaluateExpression(\"method(1, 2)\")).isEqualTo(\"two-ints\"); assertThat(evaluateExpression(\"method(1, 'two')\")).isEqualTo(\"int-and-string\"); }", "text": "Shall we extract that setup step? It's repeated in every test below.", "function_tokens": ["public", "\u0120void", "\u0120overloaded", "Methods", "Get", "Res", "olved", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120provider", "\u0120=", "\u0120new", "\u0120Extension", "A", "ware", "E", "val", "uation", "Context", "Provider", "(", "\u0120Collections", ".", "sing", "leton", "List", "(", "new", "\u0120D", "ummy", "Ext", "ension", "(\"", "_", "first", "\",", "\u0120\"", "first", "\")", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Object", "\u0120get", "Root", "Object", "()", "\u0120{", "\u0120return", "\u0120new", "\u0120Root", "With", "Over", "loads", "();", "\u0120}", "\u0120}", "));", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "()", "\")", ").", "is", "E", "qual", "To", "(\"", "zero", "\");", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "(", "23", ")", "\")", ").", "is", "E", "qual", "To", "(\"", "single", "-", "int", "\");", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "('", "hello", "')", "\")", ").", "is", "E", "qual", "To", "(\"", "single", "-", "string", "\");", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "('", "one", "',", "\u0120'", "two", "')", "\")", ").", "is", "E", "qual", "To", "(\"", "two", "\");", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "(", "1", ",", "\u01202", ")", "\")", ").", "is", "E", "qual", "To", "(\"", "two", "-", "ints", "\");", "\u0120assert", "That", "(", "evaluate", "Exp", "ression", "(\"", "method", "(", "1", ",", "\u0120'", "two", "')", "\")", ").", "is", "E", "qual", "To", "(\"", "int", "-", "and", "-", "string", "\");", "\u0120}"], "docstring_tokens": ["Sh", "all", "\u0120we", "\u0120extract", "\u0120that", "\u0120setup", "\u0120step", "?", "\u0120It", "'s", "\u0120repeated", "\u0120in", "\u0120every", "\u0120test", "\u0120below", "."]}
{"function": "public static String getPreferredVariable(IPath[] paths, IContainer target) { IPath commonRoot = null; for (IPath path : paths) { if (path != null) { if (commonRoot == null) commonRoot = path; else { int count = commonRoot.matchingFirstSegments(path); int remainingSegments = commonRoot.segmentCount() - count; if (remainingSegments <= 0) return null; commonRoot = commonRoot.removeLastSegments(remainingSegments); } } } String mostAppropriate = null; String mostAppropriateToParent = null; int mostAppropriateCount = Integer.MAX_VALUE; int mostAppropriateCountToParent = Integer.MAX_VALUE; IPathVariableManager pathVariableManager = target.getPathVariableManager(); for (String variable : pathVariableManager.getPathVariableNames()) { if (isPreferred(variable)) { URI rawValue = pathVariableManager.getURIValue(variable); URI value = pathVariableManager.resolveURI(rawValue); if (value != null) { IPath path = URIUtil.toPath(value); if (path != null) { int difference = path.matchingFirstSegments(commonRoot); if (difference > 0) { if (difference < mostAppropriateCount) { mostAppropriateCount = difference; mostAppropriate = variable; } } else { difference = commonRoot.matchingFirstSegments(path); if (difference > 0) { if (difference < mostAppropriateCountToParent) { mostAppropriateCountToParent = difference; mostAppropriateToParent = variable; } } } } } } } if (mostAppropriate == null) { if (mostAppropriateToParent == null) return \"PROJECT_LOC\"; return mostAppropriateToParent; } return mostAppropriate; }", "text": "rename 'variableName'", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120get", "Pre", "ferred", "Variable", "(", "IP", "ath", "[]", "\u0120paths", ",", "\u0120I", "Container", "\u0120target", ")", "\u0120{", "\u0120IP", "ath", "\u0120common", "Root", "\u0120=", "\u0120null", ";", "\u0120for", "\u0120(", "IP", "ath", "\u0120path", "\u0120:", "\u0120paths", ")", "\u0120{", "\u0120if", "\u0120(", "path", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "common", "Root", "\u0120==", "\u0120null", ")", "\u0120common", "Root", "\u0120=", "\u0120path", ";", "\u0120else", "\u0120{", "\u0120int", "\u0120count", "\u0120=", "\u0120common", "Root", ".", "match", "ing", "First", "Seg", "ments", "(", "path", ");", "\u0120int", "\u0120remaining", "Seg", "ments", "\u0120=", "\u0120common", "Root", ".", "se", "gment", "Count", "()", "\u0120-", "\u0120count", ";", "\u0120if", "\u0120(", "rem", "aining", "Seg", "ments", "\u0120<=", "\u01200", ")", "\u0120return", "\u0120null", ";", "\u0120common", "Root", "\u0120=", "\u0120common", "Root", ".", "remove", "Last", "Seg", "ments", "(", "rem", "aining", "Seg", "ments", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120String", "\u0120most", "App", "ropri", "ate", "\u0120=", "\u0120null", ";", "\u0120String", "\u0120most", "App", "ropri", "ate", "To", "Parent", "\u0120=", "\u0120null", ";", "\u0120int", "\u0120most", "App", "ropri", "ate", "Count", "\u0120=", "\u0120Integer", ".", "MAX", "_", "VALUE", ";", "\u0120int", "\u0120most", "App", "ropri", "ate", "Count", "To", "Parent", "\u0120=", "\u0120Integer", ".", "MAX", "_", "VALUE", ";", "\u0120IP", "ath", "Variable", "Manager", "\u0120path", "Variable", "Manager", "\u0120=", "\u0120target", ".", "get", "Path", "Variable", "Manager", "();", "\u0120for", "\u0120(", "String", "\u0120variable", "\u0120:", "\u0120path", "Variable", "Manager", ".", "get", "Path", "Variable", "Names", "())", "\u0120{", "\u0120if", "\u0120(", "is", "Pre", "ferred", "(", "variable", "))", "\u0120{", "\u0120URI", "\u0120raw", "Value", "\u0120=", "\u0120path", "Variable", "Manager", ".", "get", "UR", "IV", "al", "ue", "(", "variable", ");", "\u0120URI", "\u0120value", "\u0120=", "\u0120path", "Variable", "Manager", ".", "res", "olve", "URI", "(", "raw", "Value", ");", "\u0120if", "\u0120(", "value", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120IP", "ath", "\u0120path", "\u0120=", "\u0120URI", "Ut", "il", ".", "to", "Path", "(", "value", ");", "\u0120if", "\u0120(", "path", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120int", "\u0120difference", "\u0120=", "\u0120path", ".", "match", "ing", "First", "Seg", "ments", "(", "common", "Root", ");", "\u0120if", "\u0120(", "diff", "erence", "\u0120>", "\u01200", ")", "\u0120{", "\u0120if", "\u0120(", "diff", "erence", "\u0120<", "\u0120most", "App", "ropri", "ate", "Count", ")", "\u0120{", "\u0120most", "App", "ropri", "ate", "Count", "\u0120=", "\u0120difference", ";", "\u0120most", "App", "ropri", "ate", "\u0120=", "\u0120variable", ";", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120difference", "\u0120=", "\u0120common", "Root", ".", "match", "ing", "First", "Seg", "ments", "(", "path", ");", "\u0120if", "\u0120(", "diff", "erence", "\u0120>", "\u01200", ")", "\u0120{", "\u0120if", "\u0120(", "diff", "erence", "\u0120<", "\u0120most", "App", "ropri", "ate", "Count", "To", "Parent", ")", "\u0120{", "\u0120most", "App", "ropri", "ate", "Count", "To", "Parent", "\u0120=", "\u0120difference", ";", "\u0120most", "App", "ropri", "ate", "To", "Parent", "\u0120=", "\u0120variable", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "most", "App", "ropri", "ate", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "most", "App", "ropri", "ate", "To", "Parent", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120\"", "PRO", "JECT", "_", "LOC", "\";", "\u0120return", "\u0120most", "App", "ropri", "ate", "To", "Parent", ";", "\u0120}", "\u0120return", "\u0120most", "App", "ropri", "ate", ";", "\u0120}"], "docstring_tokens": ["ren", "ame", "\u0120'", "variable", "Name", "'"]}
{"function": "public void deleteStorage(final String id, final Optional<String> user) throws DbWriteOperationsBlockedException, NoSuchStorageException, StorageIsUsedException, InternalNakadiException { if (featureToggleService.isFeatureEnabled(FeatureToggleService.Feature.DISABLE_DB_WRITE_OPERATIONS)) { throw new DbWriteOperationsBlockedException(\"Cannot delete storage: write operations on DB \" + \"are blocked by feature flag.\"); } try { final Optional<Object> storageOrNone = storageDbRepository.getStorage(id) .map(Function.identity()); storageDbRepository.deleteStorage(id); auditLogPublisher.publish( Optional.empty(), storageOrNone, NakadiAuditLogPublisher.ResourceType.STORAGE, NakadiAuditLogPublisher.ActionType.DELETED, id, user); } catch (final RepositoryProblemException e) { LOG.error(\"DB error occurred when deleting storage\", e); throw new InternalNakadiException(e.getMessage()); } catch (final TransactionException e) { LOG.error(\"Error with transaction handling when deleting storage\", e); throw new InternalNakadiException(\"Transaction error occurred when deleting storage\"); } }", "text": "Good catch, thanks. Fixed <LINK_0>", "function_tokens": ["public", "\u0120void", "\u0120delete", "Storage", "(", "final", "\u0120String", "\u0120id", ",", "\u0120final", "\u0120Optional", "<", "String", ">", "\u0120user", ")", "\u0120throws", "\u0120D", "b", "Write", "Oper", "ations", "Bl", "ocked", "Exception", ",", "\u0120No", "Such", "Storage", "Exception", ",", "\u0120Storage", "Is", "Used", "Exception", ",", "\u0120Internal", "N", "ak", "adi", "Exception", "\u0120{", "\u0120if", "\u0120(", "feature", "T", "oggle", "Service", ".", "is", "Feature", "Enabled", "(", "Feature", "T", "oggle", "Service", ".", "Feature", ".", "DIS", "ABLE", "_", "DB", "_", "WR", "ITE", "_", "OPER", "ATIONS", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120D", "b", "Write", "Oper", "ations", "Bl", "ocked", "Exception", "(\"", "C", "annot", "\u0120delete", "\u0120storage", ":", "\u0120write", "\u0120operations", "\u0120on", "\u0120DB", "\u0120\"", "\u0120+", "\u0120\"", "are", "\u0120blocked", "\u0120by", "\u0120feature", "\u0120flag", ".\"", ");", "\u0120}", "\u0120try", "\u0120{", "\u0120final", "\u0120Optional", "<", "Object", ">", "\u0120storage", "Or", "None", "\u0120=", "\u0120storage", "Db", "Rep", "ository", ".", "get", "Storage", "(", "id", ")", "\u0120.", "map", "(", "Function", ".", "ident", "ity", "());", "\u0120storage", "Db", "Rep", "ository", ".", "delete", "Storage", "(", "id", ");", "\u0120audit", "Log", "Publisher", ".", "pub", "lish", "(", "\u0120Optional", ".", "empty", "(),", "\u0120storage", "Or", "None", ",", "\u0120Nak", "adi", "Aud", "it", "Log", "Publisher", ".", "Resource", "Type", ".", "ST", "OR", "AGE", ",", "\u0120Nak", "adi", "Aud", "it", "Log", "Publisher", ".", "Action", "Type", ".", "DE", "LET", "ED", ",", "\u0120id", ",", "\u0120user", ");", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Rep", "ository", "Problem", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "DB", "\u0120error", "\u0120occurred", "\u0120when", "\u0120deleting", "\u0120storage", "\",", "\u0120e", ");", "\u0120throw", "\u0120new", "\u0120Internal", "N", "ak", "adi", "Exception", "(", "e", ".", "get", "Message", "());", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Transaction", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Error", "\u0120with", "\u0120transaction", "\u0120handling", "\u0120when", "\u0120deleting", "\u0120storage", "\",", "\u0120e", ");", "\u0120throw", "\u0120new", "\u0120Internal", "N", "ak", "adi", "Exception", "(\"", "Transaction", "\u0120error", "\u0120occurred", "\u0120when", "\u0120deleting", "\u0120storage", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["Good", "\u0120catch", ",", "\u0120thanks", ".", "\u0120Fixed", "\u0120<", "L", "INK", "_", "0", ">"]}
{"function": "private static String loadFile(String fileName) { String content = \"\"; fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName); File file = new File(fileName); if (file.exists()) { try { content = new String(Files.readAllBytes(file.toPath())); } catch (Exception e) { log.error(\"Failed to read sysprep template '{}': {}\", fileName, e.getMessage()); log.debug(\"Exception\", e); } } else { log.error(\"Sysprep template: '{}' not found\", fileName); } return content; }", "text": "The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada", "function_tokens": ["private", "\u0120static", "\u0120String", "\u0120load", "File", "(", "String", "\u0120file", "Name", ")", "\u0120{", "\u0120String", "\u0120content", "\u0120=", "\u0120\"", "\";", "\u0120file", "Name", "\u0120=", "\u0120Config", "Ut", "il", ".", "res", "olve", "Path", "(", "get", "Sys", "prep", "Dir", "(),", "\u0120file", "Name", ");", "\u0120File", "\u0120file", "\u0120=", "\u0120new", "\u0120File", "(", "file", "Name", ");", "\u0120if", "\u0120(", "file", ".", "ex", "ists", "())", "\u0120{", "\u0120try", "\u0120{", "\u0120content", "\u0120=", "\u0120new", "\u0120String", "(", "Files", ".", "read", "All", "Bytes", "(", "file", ".", "to", "Path", "()", "));", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "F", "ailed", "\u0120to", "\u0120read", "\u0120sy", "sp", "rep", "\u0120template", "\u0120'", "{", "}", "':", "\u0120{}", "\",", "\u0120file", "Name", ",", "\u0120e", ".", "get", "Message", "());", "\u0120log", ".", "debug", "(\"", "Exception", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "error", "(\"", "Sys", "prep", "\u0120template", ":", "\u0120'", "{", "}", "'", "\u0120not", "\u0120found", "\",", "\u0120file", "Name", ");", "\u0120}", "\u0120return", "\u0120content", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120cleaner", "\u0120way", "\u0120would", "\u0120be", "\u0120to", "\u0120use", "\u0120n", "io", "\u0120classes", "\u0120only", ":", "\u0120Path", "\u0120path", "\u0120=", "\u0120Path", "s", ".", "get", "(", "file", "Name", ");", "\u0120if", "\u0120(", "Files", ".", "ex", "ists", "(", "path", "))", "\u0120{", "\u0120//", "\u0120y", "ada", "\u0120y", "ada"]}
{"function": "public boolean invalidateIfNecessary(BaragonRequest request) { if (request.getLoadBalancerService().getOptions().get(\"edgeCacheDNS\") == null) { return false; } try { String edgeCacheDNS = ((String) request.getLoadBalancerService().getOptions().get(\"edgeCacheDNS\")); Optional<CloudflareZone> matchingZone = getCloudflareZone(edgeCacheDNS); if (!matchingZone.isPresent()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but no matching Cloudflare Zone was found!\"); return false; } String zoneId = matchingZone.get().getId(); Optional<CloudflareDnsRecord> matchingDnsRecord = getCloudflareDnsRecord(edgeCacheDNS, zoneId); if (!matchingDnsRecord.isPresent()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but no matching Cloudflare DNS Record was found!\"); return false; } if (!matchingDnsRecord.get().isProxied()) { LOG.warn(\"`edgeCacheDNS` was defined on the request, but {} is not a proxied DNS record!\", edgeCacheDNS); return false; } return cf.purgeCache( zoneId, Collections.singletonList( String.format(CACHE_TAG_FORMAT, request.getLoadBalancerService().getServiceId(), environment.getName()) ) ); } catch (CloudflareClientException e) { LOG.error(\"Unable to invalidate Cloudflare cache for request {}\", request, e); return false; } }", "text": "edgeCacheDNS as a static variable since it's used a few times?", "function_tokens": ["public", "\u0120boolean", "\u0120invalid", "ate", "If", "N", "ec", "ess", "ary", "(", "Bar", "agon", "Request", "\u0120request", ")", "\u0120{", "\u0120if", "\u0120(", "request", ".", "get", "Load", "Bal", "ancer", "Service", "().", "get", "Options", "().", "get", "(\"", "edge", "Cache", "D", "NS", "\")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120String", "\u0120edge", "Cache", "D", "NS", "\u0120=", "\u0120((", "String", ")", "\u0120request", ".", "get", "Load", "Bal", "ancer", "Service", "().", "get", "Options", "().", "get", "(\"", "edge", "Cache", "D", "NS", "\")", ");", "\u0120Optional", "<", "Cloud", "fl", "are", "Zone", ">", "\u0120matching", "Zone", "\u0120=", "\u0120get", "Cloud", "fl", "are", "Zone", "(", "edge", "Cache", "D", "NS", ");", "\u0120if", "\u0120(!", "match", "ing", "Zone", ".", "is", "Present", "())", "\u0120{", "\u0120LOG", ".", "warn", "(\"", "`", "edge", "Cache", "D", "NS", "`", "\u0120was", "\u0120defined", "\u0120on", "\u0120the", "\u0120request", ",", "\u0120but", "\u0120no", "\u0120matching", "\u0120Cloud", "fl", "are", "\u0120Zone", "\u0120was", "\u0120found", "!\"", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120String", "\u0120zone", "Id", "\u0120=", "\u0120matching", "Zone", ".", "get", "().", "get", "Id", "();", "\u0120Optional", "<", "Cloud", "fl", "are", "D", "ns", "Record", ">", "\u0120matching", "D", "ns", "Record", "\u0120=", "\u0120get", "Cloud", "fl", "are", "D", "ns", "Record", "(", "edge", "Cache", "D", "NS", ",", "\u0120zone", "Id", ");", "\u0120if", "\u0120(!", "match", "ing", "D", "ns", "Record", ".", "is", "Present", "())", "\u0120{", "\u0120LOG", ".", "warn", "(\"", "`", "edge", "Cache", "D", "NS", "`", "\u0120was", "\u0120defined", "\u0120on", "\u0120the", "\u0120request", ",", "\u0120but", "\u0120no", "\u0120matching", "\u0120Cloud", "fl", "are", "\u0120DNS", "\u0120Record", "\u0120was", "\u0120found", "!\"", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(!", "match", "ing", "D", "ns", "Record", ".", "get", "().", "is", "Pro", "x", "ied", "())", "\u0120{", "\u0120LOG", ".", "warn", "(\"", "`", "edge", "Cache", "D", "NS", "`", "\u0120was", "\u0120defined", "\u0120on", "\u0120the", "\u0120request", ",", "\u0120but", "\u0120{}", "\u0120is", "\u0120not", "\u0120a", "\u0120prox", "ied", "\u0120DNS", "\u0120record", "!\",", "\u0120edge", "Cache", "D", "NS", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120return", "\u0120cf", ".", "pur", "ge", "Cache", "(", "\u0120zone", "Id", ",", "\u0120Collections", ".", "sing", "leton", "List", "(", "\u0120String", ".", "format", "(", "C", "AC", "HE", "_", "TAG", "_", "FORM", "AT", ",", "\u0120request", ".", "get", "Load", "Bal", "ancer", "Service", "().", "get", "Service", "Id", "(),", "\u0120environment", ".", "get", "Name", "())", "\u0120)", "\u0120);", "\u0120}", "\u0120catch", "\u0120(", "Cloud", "fl", "are", "Client", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "Un", "able", "\u0120to", "\u0120invalid", "ate", "\u0120Cloud", "fl", "are", "\u0120cache", "\u0120for", "\u0120request", "\u0120{}", "\",", "\u0120request", ",", "\u0120e", ");", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["edge", "Cache", "D", "NS", "\u0120as", "\u0120a", "\u0120static", "\u0120variable", "\u0120since", "\u0120it", "'s", "\u0120used", "\u0120a", "\u0120few", "\u0120times", "?"]}
{"function": "private <V> void addCallback(CompletableFuture<V> cfuture, CommitData cd, OnSuccessInterface<V> onSuccessInterface) { cfuture.handleAsync((result, exception) -> { if (result != null) { try { onSuccessInterface.onSuccess(cd, result); return null; } catch (Exception e) { cd.commitObserver.failed(e); return null; } } else { cd.commitObserver.failed(exception); return null; } }, env.getSharedResources().getAsyncCommitExecutor()); }", "text": "If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }", "function_tokens": ["private", "\u0120<", "V", ">", "\u0120void", "\u0120add", "Callback", "(", "Com", "ple", "table", "Future", "<", "V", ">", "\u0120cf", "uture", ",", "\u0120Commit", "Data", "\u0120cd", ",", "\u0120On", "Success", "Interface", "<", "V", ">", "\u0120on", "Success", "Interface", ")", "\u0120{", "\u0120cf", "uture", ".", "handle", "Async", "((", "result", ",", "\u0120exception", ")", "\u0120->", "\u0120{", "\u0120if", "\u0120(", "result", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120on", "Success", "Interface", ".", "on", "Success", "(", "cd", ",", "\u0120result", ");", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120cd", ".", "commit", "Obs", "erver", ".", "failed", "(", "e", ");", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120cd", ".", "commit", "Obs", "erver", ".", "failed", "(", "ex", "ception", ");", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120},", "\u0120env", ".", "get", "Sh", "ared", "Resources", "().", "get", "Async", "Comm", "it", "Exec", "utor", "());", "\u0120}"], "docstring_tokens": ["If", "\u0120a", "\u0120future", "\u0120completes", "\u0120successfully", "\u0120and", "\u0120returns", "\u0120null", ",", "\u0120then", "\u0120do", "\u0120not", "\u0120want", "\u0120to", "\u0120take", "\u0120the", "\u0120exception", "\u0120handling", "\u0120path", ".", "\u0120Maybe", "\u0120the", "\u0120code", "\u0120should", "\u0120do", "\u0120:", "\u0120java", "\u0120if", "(", "ex", "ception", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120//", "handle", "\u0120exception", "\u0120}", "\u0120else", "\u0120{", "\u0120//", "handle", "\u0120result", "\u0120}"]}
{"function": "public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) { log.debug(\"deleteAsyncQueryAndResultCollection\"); Collection<AsyncQuery> asyncQueryList = null; try { asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> { EntityProjection asyncQueryCollection = EntityProjection.builder() .type(AsyncQuery.class) .filterExpression(filterExpression) .build(); Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope); Iterator<Object> itr = loaded.iterator(); while (itr.hasNext()) { AsyncQuery query = (AsyncQuery) itr.next(); if (query != null) { tx.delete(query, scope); } } return loaded; }); } catch (Exception e) { log.error(\"Exception: {}\", e); } return asyncQueryList; }", "text": "The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).", "function_tokens": ["public", "\u0120Collection", "<", "Async", "Query", ">", "\u0120delete", "Async", "Query", "And", "Result", "Collection", "(", "Filter", "Exp", "ression", "\u0120filter", "Exp", "ression", ")", "\u0120{", "\u0120log", ".", "debug", "(\"", "delete", "Async", "Query", "And", "Result", "Collection", "\");", "\u0120Collection", "<", "Async", "Query", ">", "\u0120async", "Query", "List", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120async", "Query", "List", "\u0120=", "\u0120(", "Collection", "<", "Async", "Query", ">)", "\u0120execute", "In", "Transaction", "(", "data", "Store", ",", "\u0120(", "tx", ",", "\u0120scope", ")", "\u0120->", "\u0120{", "\u0120Entity", "Project", "ion", "\u0120async", "Query", "Collection", "\u0120=", "\u0120Entity", "Project", "ion", ".", "builder", "()", "\u0120.", "type", "(", "Async", "Query", ".", "class", ")", "\u0120.", "filter", "Exp", "ression", "(", "filter", "Exp", "ression", ")", "\u0120.", "build", "();", "\u0120Iter", "able", "<", "Object", ">", "\u0120loaded", "\u0120=", "\u0120tx", ".", "load", "Object", "s", "(", "as", "ync", "Query", "Collection", ",", "\u0120scope", ");", "\u0120Iter", "ator", "<", "Object", ">", "\u0120it", "r", "\u0120=", "\u0120loaded", ".", "iterator", "();", "\u0120while", "\u0120(", "it", "r", ".", "has", "Next", "())", "\u0120{", "\u0120As", "ync", "Query", "\u0120query", "\u0120=", "\u0120(", "Async", "Query", ")", "\u0120it", "r", ".", "next", "();", "\u0120if", "\u0120(", "query", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120tx", ".", "delete", "(", "query", ",", "\u0120scope", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120loaded", ";", "\u0120});", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "Exception", ":", "\u0120{}", "\",", "\u0120e", ");", "\u0120}", "\u0120return", "\u0120async", "Query", "List", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120DA", "O", "\u0120should", "\u0120not", "\u0120swallow", "\u0120exceptions", ".", "\u0120Utilities", "\u0120need", "\u0120to", "\u0120propagate", "\u0120exceptions", "\u0120and", "\u0120let", "\u0120the", "\u0120calling", "\u0120code", "\u0120handle", "\u0120them", "\u0120(", "or", "\u0120the", "\u0120utility", "\u0120will", "\u0120have", "\u0120limited", "\u0120reuse", "\u0120and", "\u0120can", "\u0120only", "\u0120be", "\u0120used", "\u0120in", "\u0120limited", "\u0120contexts", ")."]}
{"function": "public static void markNoteAsRead(final Note note) { if (note == null) { return; } if (note.isUnread()) { WordPress.getRestClientUtilsV1_1().decrementUnreadCount(note.getId(), \"10\", new RestRequest.Listener() { @Override public void onResponse(JSONObject response) { note.setRead(); NotificationsTable.saveNote(note); } }, new RestRequest.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { AppLog.e(AppLog.T.NOTIFS, \"Could not mark note as read via API.\"); } }); } }", "text": "Let's do the same way @jleandroperez did on iOS here <LINK_0>", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120mark", "Note", "As", "Read", "(", "final", "\u0120Note", "\u0120note", ")", "\u0120{", "\u0120if", "\u0120(", "note", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "note", ".", "is", "Un", "read", "())", "\u0120{", "\u0120WordPress", ".", "get", "Rest", "Client", "Ut", "ils", "V", "1", "_", "1", "().", "dec", "re", "ment", "Un", "read", "Count", "(", "note", ".", "get", "Id", "(),", "\u0120\"", "10", "\",", "\u0120new", "\u0120Rest", "Request", ".", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Response", "(", "JSON", "Object", "\u0120response", ")", "\u0120{", "\u0120note", ".", "set", "Read", "();", "\u0120Not", "ifications", "Table", ".", "save", "Note", "(", "note", ");", "\u0120}", "\u0120},", "\u0120new", "\u0120Rest", "Request", ".", "Error", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Error", "Response", "(", "Vol", "ley", "Error", "\u0120error", ")", "\u0120{", "\u0120App", "Log", ".", "e", "(", "App", "Log", ".", "T", ".", "NOT", "IF", "S", ",", "\u0120\"", "Could", "\u0120not", "\u0120mark", "\u0120note", "\u0120as", "\u0120read", "\u0120via", "\u0120API", ".\"", ");", "\u0120}", "\u0120});", "\u0120}", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120do", "\u0120the", "\u0120same", "\u0120way", "\u0120@", "j", "le", "andro", "pe", "rez", "\u0120did", "\u0120on", "\u0120iOS", "\u0120here", "\u0120<", "L", "INK", "_", "0", ">"]}
{"function": "public Set<String> map(Set<String> genres) { Set<String> tags = Sets.newHashSet(); for (String genre : genres) { if (genre.contains(\"<LINK_0>\")) { tags.add(paTagMap.get(genre)); } } if (tags.size() == 1 && tags.contains(\"film\")) { tags.add(\"action\"); } return tags; }", "text": "Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise", "function_tokens": ["public", "\u0120Set", "<", "String", ">", "\u0120map", "(", "Set", "<", "String", ">", "\u0120genres", ")", "\u0120{", "\u0120Set", "<", "String", ">", "\u0120tags", "\u0120=", "\u0120Sets", ".", "new", "Hash", "Set", "();", "\u0120for", "\u0120(", "String", "\u0120genre", "\u0120:", "\u0120genres", ")", "\u0120{", "\u0120if", "\u0120(", "genre", ".", "cont", "ains", "(\"", "<", "L", "INK", "_", "0", ">\"", "))", "\u0120{", "\u0120tags", ".", "add", "(", "pa", "Tag", "Map", ".", "get", "(", "genre", "));", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "tags", ".", "size", "()", "\u0120==", "\u01201", "\u0120&&", "\u0120tags", ".", "cont", "ains", "(\"", "film", "\"))", "\u0120{", "\u0120tags", ".", "add", "(\"", "action", "\");", "\u0120}", "\u0120return", "\u0120tags", ";", "\u0120}"], "docstring_tokens": ["Are", "\u0120there", "\u0120any", "\u0120PA", "\u0120genres", "\u0120that", "\u0120we", "\u0120don", "'t", "\u0120have", "\u0120a", "\u0120mapping", "\u0120for", "?", "\u0120i", ".", "e", ".", "\u0120is", "\u0120this", "\u0120an", "\u0120exhaustive", "\u0120mapping", "?", "\u0120We", "'re", "\u0120gun", "na", "\u0120get", "\u0120null", "s", "\u0120in", "\u0120our", "\u0120Set", "\u0120otherwise"]}
{"function": "public void checkWebJavaSpringCommands() { consoles.startCommandAndCheckResult(WEB_JAVA_SPRING, BUILD, \"build\", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, BUILD, \"web-java-spring:build\", BUILD_SUCCESS); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, \"web-java-spring:build and run\", \"Server startup in\"); consoles.startCommandAndCheckApp(currentWindow, \" consoles.closeProcessTabWithAskDialog(\"web-java-spring:build and run\"); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, RUN, \"web-java-spring:run tomcat\", \"Server startup in\"); consoles.startCommandAndCheckApp(currentWindow, \" projectExplorer.invokeCommandWithContextMenu( RUN, WEB_JAVA_SPRING, \"web-java-spring:stop tomcat\"); consoles.selectProcessInProcessConsoleTreeByName(\"Terminal\"); terminal.typeIntoTerminal(\"ps ax\"); terminal.typeIntoTerminal(ENTER.toString()); terminal.waitExpectedTextNotPresentTerminal(\"/bin/bash -c $TOMCAT_HOME/bin/catalina.sh\"); consoles.startCommandAndCheckResult( WEB_JAVA_SPRING, DEBUG, \"web-java-spring:debug\", \"Listening for transport dt_socket at address: 8000\"); }", "text": "let's make constant with \"web-java-spring:stop tomcat\" command: STOP_TOMCAT_COMMAND_ITEM_NAME", "function_tokens": ["public", "\u0120void", "\u0120check", "Web", "Java", "Spring", "Comm", "ands", "()", "\u0120{", "\u0120consoles", ".", "start", "Command", "And", "Check", "Result", "(", "WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120BU", "ILD", ",", "\u0120\"", "build", "\",", "\u0120BU", "ILD", "_", "SU", "CC", "ESS", ");", "\u0120consoles", ".", "start", "Command", "And", "Check", "Result", "(", "\u0120WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120BU", "ILD", ",", "\u0120\"", "web", "-", "java", "-", "spring", ":", "build", "\",", "\u0120BU", "ILD", "_", "SU", "CC", "ESS", ");", "\u0120consoles", ".", "start", "Command", "And", "Check", "Result", "(", "\u0120WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120RUN", ",", "\u0120\"", "web", "-", "java", "-", "spring", ":", "build", "\u0120and", "\u0120run", "\",", "\u0120\"", "Server", "\u0120startup", "\u0120in", "\");", "\u0120consoles", ".", "start", "Command", "And", "Check", "App", "(", "current", "Window", ",", "\u0120\"", "\u0120consoles", ".", "close", "Process", "Tab", "With", "Ask", "Dialog", "(\"", "web", "-", "java", "-", "spring", ":", "build", "\u0120and", "\u0120run", "\");", "\u0120consoles", ".", "start", "Command", "And", "Check", "Result", "(", "\u0120WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120RUN", ",", "\u0120\"", "web", "-", "java", "-", "spring", ":", "run", "\u0120tom", "cat", "\",", "\u0120\"", "Server", "\u0120startup", "\u0120in", "\");", "\u0120consoles", ".", "start", "Command", "And", "Check", "App", "(", "current", "Window", ",", "\u0120\"", "\u0120project", "Expl", "orer", ".", "invoke", "Command", "With", "Context", "Menu", "(", "\u0120RUN", ",", "\u0120WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120\"", "web", "-", "java", "-", "spring", ":", "stop", "\u0120tom", "cat", "\");", "\u0120consoles", ".", "select", "Process", "In", "Process", "Console", "Tree", "By", "Name", "(\"", "Termin", "al", "\");", "\u0120terminal", ".", "type", "Int", "o", "Termin", "al", "(\"", "ps", "\u0120ax", "\");", "\u0120terminal", ".", "type", "Int", "o", "Termin", "al", "(", "ENT", "ER", ".", "to", "String", "());", "\u0120terminal", ".", "wait", "Ex", "pected", "Text", "Not", "Present", "Termin", "al", "(\"", "/", "bin", "/", "bash", "\u0120-", "c", "\u0120$", "T", "OM", "C", "AT", "_", "HOME", "/", "bin", "/", "cat", "al", "ina", ".", "sh", "\");", "\u0120consoles", ".", "start", "Command", "And", "Check", "Result", "(", "\u0120WE", "B", "_", "J", "AV", "A", "_", "SP", "R", "ING", ",", "\u0120DEBUG", ",", "\u0120\"", "web", "-", "java", "-", "spring", ":", "debug", "\",", "\u0120\"", "List", "ening", "\u0120for", "\u0120transport", "\u0120d", "t", "_", "socket", "\u0120at", "\u0120address", ":", "\u01208000", "\");", "\u0120}"], "docstring_tokens": ["let", "'s", "\u0120make", "\u0120constant", "\u0120with", "\u0120\"", "web", "-", "java", "-", "spring", ":", "stop", "\u0120tom", "cat", "\"", "\u0120command", ":", "\u0120STOP", "_", "T", "OM", "C", "AT", "_", "COM", "M", "AND", "_", "IT", "EM", "_", "NAME"]}
{"function": "public abstract BufferedSink valueSink() throws IOException; public final JsonWriter jsonValue(@Nullable Object value) throws IOException { if (value instanceof Map<?, ?>) { beginObject(); for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { Object key = entry.getKey(); if (!(key instanceof String)) { throw new IllegalArgumentException( \"Map keys must be of type String: \" + key.getClass().getName()); } name(((String) key)); jsonValue(entry.getValue()); } endObject(); } else if (value instanceof List<?>) { beginArray(); for (Object element : ((List<?>) value)) { jsonValue(element); } endArray(); } else if (value instanceof String) { value(((String) value)); } else if (value instanceof Boolean) { value(((Boolean) value).booleanValue()); } else if (value instanceof Double) { value(((Double) value).doubleValue()); } else if (value instanceof Long) { value(((Long) value).longValue()); } else if (value instanceof Number) { value(((Number) value)); } else if (value == null) { nullValue(); } else { throw new IllegalArgumentException(\"Unsupported type: \" + value.getClass().getName()); } return this; }", "text": "what does this do if key is null?", "function_tokens": ["public", "\u0120abstract", "\u0120Buff", "ered", "S", "ink", "\u0120value", "S", "ink", "()", "\u0120throws", "\u0120IO", "Exception", ";", "\u0120public", "\u0120final", "\u0120J", "son", "Writer", "\u0120json", "Value", "(", "@", "Null", "able", "\u0120Object", "\u0120value", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Map", "<", "?,", "\u0120?", ">)", "\u0120{", "\u0120begin", "Object", "();", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "?,", "\u0120?", ">", "\u0120entry", "\u0120:", "\u0120((", "Map", "<", "?,", "\u0120?", ">)", "\u0120value", ").", "entry", "Set", "())", "\u0120{", "\u0120Object", "\u0120key", "\u0120=", "\u0120entry", ".", "get", "Key", "();", "\u0120if", "\u0120(!", "(", "key", "\u0120instance", "of", "\u0120String", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "Map", "\u0120keys", "\u0120must", "\u0120be", "\u0120of", "\u0120type", "\u0120String", ":", "\u0120\"", "\u0120+", "\u0120key", ".", "get", "Class", "().", "get", "Name", "());", "\u0120}", "\u0120name", "((", "(", "String", ")", "\u0120key", "));", "\u0120json", "Value", "(", "entry", ".", "get", "Value", "());", "\u0120}", "\u0120end", "Object", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120List", "<?", ">)", "\u0120{", "\u0120begin", "Array", "();", "\u0120for", "\u0120(", "Object", "\u0120element", "\u0120:", "\u0120((", "List", "<?", ">)", "\u0120value", "))", "\u0120{", "\u0120json", "Value", "(", "element", ");", "\u0120}", "\u0120end", "Array", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120String", ")", "\u0120{", "\u0120value", "((", "(", "String", ")", "\u0120value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Boolean", ")", "\u0120{", "\u0120value", "((", "(", "Boo", "lean", ")", "\u0120value", ").", "bo", "olean", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Double", ")", "\u0120{", "\u0120value", "((", "(", "Double", ")", "\u0120value", ").", "double", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Long", ")", "\u0120{", "\u0120value", "((", "(", "Long", ")", "\u0120value", ").", "long", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120instance", "of", "\u0120Number", ")", "\u0120{", "\u0120value", "((", "(", "Number", ")", "\u0120value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "value", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120null", "Value", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "Un", "supported", "\u0120type", ":", "\u0120\"", "\u0120+", "\u0120value", ".", "get", "Class", "().", "get", "Name", "());", "\u0120}", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["what", "\u0120does", "\u0120this", "\u0120do", "\u0120if", "\u0120key", "\u0120is", "\u0120null", "?"]}
{"function": "void process(Content dataSource, IngestJobContext context, DataSourceIngestModuleProgress progressBar) { this.context = context; String modOutPath = Case.getCurrentCase().getModuleDirectory() + File.separator + PREFETCH_DIR_NAME; File dir = new File(modOutPath); if (dir.exists() == false) { dir.mkdirs(); } extractPrefetchFiles(dataSource); final String prefetchDumper = getPathForPrefetchDumper(); if (prefetchDumper == null) { logger.log(Level.SEVERE, \"Error finding parse_prefetch program\"); return; } if (context.dataSourceIngestIsCancelled()) { return; } String modOutFile = modOutPath + File.separator + PREFETCH_PARSER_DB_FILE; try { String tempDirPath = RAImageIngestModule.getRATempPath(Case.getCurrentCase(), PREFETCH_DIR_NAME ); parsePrefetchFiles(prefetchDumper, tempDirPath, modOutFile, modOutPath); createAppExecArtifacts(modOutFile); } catch (IOException ex) { logger.log(Level.WARNING, \"Error runing parse_prefetch or creating artifacts.\", ex); } }", "text": "The output of this call should be checked and if it's false I think it should bail.", "function_tokens": ["void", "\u0120process", "(", "Content", "\u0120data", "Source", ",", "\u0120In", "gest", "Job", "Context", "\u0120context", ",", "\u0120Data", "Source", "Ing", "est", "Module", "Progress", "\u0120progress", "Bar", ")", "\u0120{", "\u0120this", ".", "context", "\u0120=", "\u0120context", ";", "\u0120String", "\u0120mod", "Out", "Path", "\u0120=", "\u0120Case", ".", "get", "Current", "Case", "().", "get", "Module", "Directory", "()", "\u0120+", "\u0120File", ".", "separ", "ator", "\u0120+", "\u0120PRE", "F", "ET", "CH", "_", "DIR", "_", "NAME", ";", "\u0120File", "\u0120dir", "\u0120=", "\u0120new", "\u0120File", "(", "mod", "Out", "Path", ");", "\u0120if", "\u0120(", "dir", ".", "ex", "ists", "()", "\u0120==", "\u0120false", ")", "\u0120{", "\u0120dir", ".", "mk", "dir", "s", "();", "\u0120}", "\u0120extract", "Pref", "etch", "Files", "(", "data", "Source", ");", "\u0120final", "\u0120String", "\u0120pref", "etch", "D", "umper", "\u0120=", "\u0120get", "Path", "For", "Pref", "etch", "D", "umper", "();", "\u0120if", "\u0120(", "pre", "f", "etch", "D", "umper", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "log", "(", "Level", ".", "SE", "VER", "E", ",", "\u0120\"", "Error", "\u0120finding", "\u0120parse", "_", "pre", "f", "etch", "\u0120program", "\");", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "context", ".", "data", "Source", "Ing", "est", "Is", "C", "ance", "lled", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120String", "\u0120mod", "Out", "File", "\u0120=", "\u0120mod", "Out", "Path", "\u0120+", "\u0120File", ".", "separ", "ator", "\u0120+", "\u0120PRE", "F", "ET", "CH", "_", "PAR", "SER", "_", "DB", "_", "FILE", ";", "\u0120try", "\u0120{", "\u0120String", "\u0120temp", "Dir", "Path", "\u0120=", "\u0120RA", "Image", "Ing", "est", "Module", ".", "get", "R", "AT", "emp", "Path", "(", "Case", ".", "get", "Current", "Case", "(),", "\u0120PRE", "F", "ET", "CH", "_", "DIR", "_", "NAME", "\u0120);", "\u0120parse", "Pref", "etch", "Files", "(", "pre", "f", "etch", "D", "umper", ",", "\u0120temp", "Dir", "Path", ",", "\u0120mod", "Out", "File", ",", "\u0120mod", "Out", "Path", ");", "\u0120create", "App", "Exec", "Art", "ifacts", "(", "mod", "Out", "File", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120ex", ")", "\u0120{", "\u0120logger", ".", "log", "(", "Level", ".", "WARNING", ",", "\u0120\"", "Error", "\u0120run", "ing", "\u0120parse", "_", "pre", "f", "etch", "\u0120or", "\u0120creating", "\u0120artifacts", ".\",", "\u0120ex", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["The", "\u0120output", "\u0120of", "\u0120this", "\u0120call", "\u0120should", "\u0120be", "\u0120checked", "\u0120and", "\u0120if", "\u0120it", "'s", "\u0120false", "\u0120I", "\u0120think", "\u0120it", "\u0120should", "\u0120bail", "."]}
{"function": "public void parsesInvalidIdField() throws IOException { final MemberProfileJson memberprofilejson = Mockito.mock(MemberProfileJson.class); Mockito.when( memberprofilejson.fetch( Mockito.anyString(), Mockito.anyString(), Mockito.any(Href.class) ) ).thenReturn( Json.createReader( new FileInputStream( PsLinkedinTest.class.getResource( \"linkedinTestUserInvalidId.json\" ).getPath() ) ).readObject() ); try { new PsLinkedin(memberprofilejson) .enter(REQUEST); } catch (final ClassCastException ex) { MatcherAssert.assertThat( ex.getMessage(), Matchers.containsString(\"cannot be cast to\") ); throw ex; } }", "text": "@ikhvostenkov please name it json", "function_tokens": ["public", "\u0120void", "\u0120pars", "es", "Invalid", "Id", "Field", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120final", "\u0120Member", "Profile", "J", "son", "\u0120member", "profile", "json", "\u0120=", "\u0120Mock", "ito", ".", "m", "ock", "(", "Member", "Profile", "J", "son", ".", "class", ");", "\u0120Mock", "ito", ".", "when", "(", "\u0120member", "profile", "json", ".", "f", "etch", "(", "\u0120Mock", "ito", ".", "any", "String", "(),", "\u0120Mock", "ito", ".", "any", "String", "(),", "\u0120Mock", "ito", ".", "any", "(", "H", "ref", ".", "class", ")", "\u0120)", "\u0120).", "then", "Return", "(", "\u0120J", "son", ".", "create", "Reader", "(", "\u0120new", "\u0120File", "Input", "Stream", "(", "\u0120Ps", "Link", "edin", "Test", ".", "class", ".", "get", "Resource", "(", "\u0120\"", "linked", "in", "Test", "User", "Invalid", "Id", ".", "json", "\"", "\u0120).", "get", "Path", "()", "\u0120)", "\u0120).", "read", "Object", "()", "\u0120);", "\u0120try", "\u0120{", "\u0120new", "\u0120Ps", "Link", "edin", "(", "member", "profile", "json", ")", "\u0120.", "enter", "(", "RE", "QUEST", ");", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Class", "Cast", "Exception", "\u0120ex", ")", "\u0120{", "\u0120Mat", "cher", "Ass", "ert", ".", "assert", "That", "(", "\u0120ex", ".", "get", "Message", "(),", "\u0120Mat", "chers", ".", "cont", "ains", "String", "(\"", "c", "annot", "\u0120be", "\u0120cast", "\u0120to", "\")", "\u0120);", "\u0120throw", "\u0120ex", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "ikh", "v", "ost", "en", "kov", "\u0120please", "\u0120name", "\u0120it", "\u0120json"]}
{"function": "public Matcher<View> atPositionOnView(final int position, final int targetViewId) { return new TypeSafeMatcher<View>() { Resources resources = null; View childView; public void describeTo(Description description) { String idDescription = Integer.toString(recyclerViewId); if (this.resources != null) { try { idDescription = this.resources.getResourceName(recyclerViewId); } catch (Resources.NotFoundException var4) { idDescription = String.format(\"%s (resource name not found)\", recyclerViewId); } } description.appendText(\"with id: \" + idDescription); } public boolean matchesSafely(View view) { this.resources = view.getResources(); if (childView == null) { RecyclerView recyclerView = (RecyclerView) view.getRootView().findViewById(recyclerViewId); if (recyclerView != null && recyclerView.getId() == recyclerViewId) { childView = recyclerView.findViewHolderForAdapterPosition(position).itemView; } else { return false; } } if (targetViewId == -1) { return view == childView; } else { View targetView = childView.findViewById(targetViewId); return view == targetView; } } }; }", "text": "why var4? Resources.NotFoundException e would be a bit nicer..", "function_tokens": ["public", "\u0120Mat", "cher", "<", "View", ">", "\u0120at", "Position", "On", "View", "(", "final", "\u0120int", "\u0120position", ",", "\u0120final", "\u0120int", "\u0120target", "View", "Id", ")", "\u0120{", "\u0120return", "\u0120new", "\u0120Type", "Safe", "Mat", "cher", "<", "View", ">", "()", "\u0120{", "\u0120Resources", "\u0120resources", "\u0120=", "\u0120null", ";", "\u0120View", "\u0120child", "View", ";", "\u0120public", "\u0120void", "\u0120describe", "To", "(", "Description", "\u0120description", ")", "\u0120{", "\u0120String", "\u0120id", "Description", "\u0120=", "\u0120Integer", ".", "to", "String", "(", "re", "cycl", "er", "View", "Id", ");", "\u0120if", "\u0120(", "this", ".", "resources", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120id", "Description", "\u0120=", "\u0120this", ".", "resources", ".", "get", "Resource", "Name", "(", "re", "cycl", "er", "View", "Id", ");", "\u0120}", "\u0120catch", "\u0120(", "Resources", ".", "Not", "Found", "Exception", "\u0120var", "4", ")", "\u0120{", "\u0120id", "Description", "\u0120=", "\u0120String", ".", "format", "(\"", "%", "s", "\u0120(", "resource", "\u0120name", "\u0120not", "\u0120found", ")\",", "\u0120recy", "cler", "View", "Id", ");", "\u0120}", "\u0120}", "\u0120description", ".", "append", "Text", "(\"", "with", "\u0120id", ":", "\u0120\"", "\u0120+", "\u0120id", "Description", ");", "\u0120}", "\u0120public", "\u0120boolean", "\u0120matches", "Safe", "ly", "(", "View", "\u0120view", ")", "\u0120{", "\u0120this", ".", "resources", "\u0120=", "\u0120view", ".", "get", "Resources", "();", "\u0120if", "\u0120(", "child", "View", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120Rec", "y", "cler", "View", "\u0120recy", "cler", "View", "\u0120=", "\u0120(", "Rec", "y", "cler", "View", ")", "\u0120view", ".", "get", "Root", "View", "().", "find", "View", "ById", "(", "re", "cycl", "er", "View", "Id", ");", "\u0120if", "\u0120(", "re", "cycl", "er", "View", "\u0120!=", "\u0120null", "\u0120&&", "\u0120recy", "cler", "View", ".", "get", "Id", "()", "\u0120==", "\u0120recy", "cler", "View", "Id", ")", "\u0120{", "\u0120child", "View", "\u0120=", "\u0120recy", "cler", "View", ".", "find", "View", "H", "older", "For", "Adapter", "Position", "(", "position", ").", "item", "View", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "target", "View", "Id", "\u0120==", "\u0120-", "1", ")", "\u0120{", "\u0120return", "\u0120view", "\u0120==", "\u0120child", "View", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120View", "\u0120target", "View", "\u0120=", "\u0120child", "View", ".", "find", "View", "ById", "(", "target", "View", "Id", ");", "\u0120return", "\u0120view", "\u0120==", "\u0120target", "View", ";", "\u0120}", "\u0120}", "\u0120};", "\u0120}"], "docstring_tokens": ["why", "\u0120var", "4", "?", "\u0120Resources", ".", "Not", "Found", "Exception", "\u0120e", "\u0120would", "\u0120be", "\u0120a", "\u0120bit", "\u0120nicer", ".."]}
{"function": "public I setContext(HttpRequest request) { this.request = GeneratedHttpRequest.class.cast(request); return (I) this; }", "text": "Check for illegal arg or are we happy with a ClassCastException here?", "function_tokens": ["public", "\u0120I", "\u0120set", "Context", "(", "Http", "Request", "\u0120request", ")", "\u0120{", "\u0120this", ".", "request", "\u0120=", "\u0120Gener", "ated", "Http", "Request", ".", "class", ".", "cast", "(", "request", ");", "\u0120return", "\u0120(", "I", ")", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["Check", "\u0120for", "\u0120illegal", "\u0120arg", "\u0120or", "\u0120are", "\u0120we", "\u0120happy", "\u0120with", "\u0120a", "\u0120Class", "Cast", "Exception", "\u0120here", "?"]}
{"function": "private <T extends Enum<T>> void registerStatistic(String statNameSuffix, StatisticType type, final OperationStatisticDescriptor<T> descriptor, final EnumSet<T> outcomes) { if (contextObject == null) { return; } Set<TreeNode> result = queryBuilder() .descendants() .filter(context(attributes(Matchers.<Map<String, Object>>allOf( hasAttribute(\"type\", descriptor.getType()), hasAttribute(\"name\", descriptor.getObserverName()), hasAttribute(\"tags\", new Matcher<Set<String>>() { @Override protected boolean matchesSafely(Set<String> object) { return object.containsAll(descriptor.getTags()); } }))))) .filter(context(identifier(subclassOf(OperationStatistic.class)))) .build().execute(Collections.singleton(ContextManager.nodeFor(contextObject))); if (!result.isEmpty()) { for (TreeNode node : result) { String discriminator = null; Map<String, Object> properties = (Map<String, Object>) node.getContext().attributes().get(\"properties\"); if (properties != null && properties.containsKey(\"discriminator\")) { discriminator = properties.get(\"discriminator\").toString(); } String fullStatName = (discriminator == null ? \"\" : (discriminator + \":\")) + statNameSuffix; final OperationStatistic<T> statistic = (OperationStatistic<T>) node.getContext().attributes().get(\"this\"); registerStatistic(fullStatName, type, new ValueStatistic<Number>() { @Override public Number value() { return statistic.sum(outcomes); } }); } } }", "text": "Mutualize with the other matcher on tags", "function_tokens": ["private", "\u0120<", "T", "\u0120extends", "\u0120En", "um", "<", "T", ">>", "\u0120void", "\u0120register", "Stat", "istic", "(", "String", "\u0120stat", "Name", "S", "uff", "ix", ",", "\u0120Stat", "istic", "Type", "\u0120type", ",", "\u0120final", "\u0120Operation", "Stat", "istic", "Desc", "ript", "or", "<", "T", ">", "\u0120descriptor", ",", "\u0120final", "\u0120En", "um", "Set", "<", "T", ">", "\u0120outcomes", ")", "\u0120{", "\u0120if", "\u0120(", "context", "Object", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120Set", "<", "Tree", "Node", ">", "\u0120result", "\u0120=", "\u0120query", "Builder", "()", "\u0120.", "desc", "endants", "()", "\u0120.", "filter", "(", "context", "(", "att", "ributes", "(", "Mat", "chers", ".<", "Map", "<", "String", ",", "\u0120Object", ">>", "all", "Of", "(", "\u0120has", "Attribute", "(\"", "type", "\",", "\u0120descriptor", ".", "get", "Type", "()", "),", "\u0120has", "Attribute", "(\"", "name", "\",", "\u0120descriptor", ".", "get", "Obs", "erver", "Name", "()", "),", "\u0120has", "Attribute", "(\"", "tags", "\",", "\u0120new", "\u0120Mat", "cher", "<", "Set", "<", "String", ">>", "()", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120boolean", "\u0120matches", "Safe", "ly", "(", "Set", "<", "String", ">", "\u0120object", ")", "\u0120{", "\u0120return", "\u0120object", ".", "cont", "ains", "All", "(", "desc", "ript", "or", ".", "get", "Tags", "());", "\u0120}", "\u0120}", "))", ")))", "\u0120.", "filter", "(", "context", "(", "ident", "ifier", "(", "sub", "class", "Of", "(", "Operation", "Stat", "istic", ".", "class", "))))", "\u0120.", "build", "().", "execute", "(", "Col", "lections", ".", "sing", "leton", "(", "Context", "Manager", ".", "node", "For", "(", "context", "Object", "))", ");", "\u0120if", "\u0120(!", "result", ".", "is", "Empty", "())", "\u0120{", "\u0120for", "\u0120(", "Tree", "Node", "\u0120node", "\u0120:", "\u0120result", ")", "\u0120{", "\u0120String", "\u0120discrim", "inator", "\u0120=", "\u0120null", ";", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120properties", "\u0120=", "\u0120(", "Map", "<", "String", ",", "\u0120Object", ">)", "\u0120node", ".", "get", "Context", "().", "att", "ributes", "().", "get", "(\"", "properties", "\");", "\u0120if", "\u0120(", "properties", "\u0120!=", "\u0120null", "\u0120&&", "\u0120properties", ".", "cont", "ains", "Key", "(\"", "disc", "rim", "inator", "\"))", "\u0120{", "\u0120discrim", "inator", "\u0120=", "\u0120properties", ".", "get", "(\"", "disc", "rim", "inator", "\").", "to", "String", "();", "\u0120}", "\u0120String", "\u0120full", "Stat", "Name", "\u0120=", "\u0120(", "disc", "rim", "inator", "\u0120==", "\u0120null", "\u0120?", "\u0120\"\"", "\u0120:", "\u0120(", "disc", "rim", "inator", "\u0120+", "\u0120\"", ":\"", "))", "\u0120+", "\u0120stat", "Name", "S", "uff", "ix", ";", "\u0120final", "\u0120Operation", "Stat", "istic", "<", "T", ">", "\u0120statistic", "\u0120=", "\u0120(", "Operation", "Stat", "istic", "<", "T", ">)", "\u0120node", ".", "get", "Context", "().", "att", "ributes", "().", "get", "(\"", "this", "\");", "\u0120register", "Stat", "istic", "(", "full", "Stat", "Name", ",", "\u0120type", ",", "\u0120new", "\u0120Value", "Stat", "istic", "<", "Number", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Number", "\u0120value", "()", "\u0120{", "\u0120return", "\u0120statistic", ".", "sum", "(", "out", "comes", ");", "\u0120}", "\u0120});", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Mut", "ual", "ize", "\u0120with", "\u0120the", "\u0120other", "\u0120mat", "cher", "\u0120on", "\u0120tags"]}
{"function": "private void setPublicURIs(final FileSystem fileSystem) { final String[] uris = fileSystem.toString().split(\"\\\\r?\\\\n\"); final List<PublicURI> publicURIs = new ArrayList<>(uris.length); for (final String s : uris) { final int protocolStart = s.indexOf(\"://\"); publicURIs.add(getPublicURI(s, protocolStart)); } repo.setPublicURIs(publicURIs); }", "text": "Maybe using a constant here for \"://\"", "function_tokens": ["private", "\u0120void", "\u0120set", "Public", "UR", "Is", "(", "final", "\u0120File", "System", "\u0120file", "System", ")", "\u0120{", "\u0120final", "\u0120String", "[]", "\u0120ur", "is", "\u0120=", "\u0120file", "System", ".", "to", "String", "().", "split", "(\"", "\\\\", "r", "?", "\\\\", "n", "\");", "\u0120final", "\u0120List", "<", "Public", "URI", ">", "\u0120public", "UR", "Is", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">(", "ur", "is", ".", "length", ");", "\u0120for", "\u0120(", "final", "\u0120String", "\u0120s", "\u0120:", "\u0120ur", "is", ")", "\u0120{", "\u0120final", "\u0120int", "\u0120protocol", "Start", "\u0120=", "\u0120s", ".", "index", "Of", "(", "\":", "//", "\");", "\u0120public", "UR", "Is", ".", "add", "(", "get", "Public", "URI", "(", "s", ",", "\u0120protocol", "Start", "));", "\u0120}", "\u0120repo", ".", "set", "Public", "UR", "Is", "(", "public", "UR", "Is", ");", "\u0120}"], "docstring_tokens": ["Maybe", "\u0120using", "\u0120a", "\u0120constant", "\u0120here", "\u0120for", "\u0120\"", "://", "\""]}
{"function": "private void handleRelatedAlarms(OnmsAlarm situation) { if (!situation.isSituation()) { return; } alarmAssociationById.putIfAbsent(situation.getId(), new HashMap<>()); final Map<Integer, AlarmAssociationAndFact> associationFacts = alarmAssociationById.get(situation.getId()); for (AlarmAssociation association : situation.getAssociatedAlarms()) { Integer alarmId = association.getRelatedAlarm().getId(); AlarmAssociationAndFact assocationFact = associationFacts.get(alarmId); if (assocationFact == null) { LOG.debug(\"Inserting alarm association into session: {}\", association); final FactHandle fact = getKieSession().insert(association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } else { FactHandle fact = assocationFact.getFact(); LOG.trace(\"Updating alarm assocation in session: {}\", assocationFact); getKieSession().update(fact, association); associationFacts.put(alarmId, new AlarmAssociationAndFact(association, fact)); } } Set<Integer> deletedAlarmIds = associationFacts.values().stream() .map(fact -> fact.getAlarmAssociation().getRelatedAlarm().getId()) .filter(alarmId -> !situation.getRelatedAlarmIds().contains(alarmId)) .collect(Collectors.toSet()); deletedAlarmIds.stream().forEach(alarmId -> { final AlarmAssociationAndFact associationAndFact = associationFacts.remove(alarmId); if (associationAndFact != null) { LOG.debug(\"Deleting AlarmAssociationAndFact from session: {}\", associationAndFact.getAlarmAssociation()); getKieSession().delete(associationAndFact.getFact()); } }); }", "text": "suggestion deletedAlarmIds.forEach(alarmId -> {", "function_tokens": ["private", "\u0120void", "\u0120handle", "Related", "Al", "arms", "(", "On", "ms", "Al", "arm", "\u0120situation", ")", "\u0120{", "\u0120if", "\u0120(!", "sit", "uation", ".", "is", "Sit", "uation", "())", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120alarm", "Ass", "ociation", "ById", ".", "put", "If", "Abs", "ent", "(", "sit", "uation", ".", "get", "Id", "(),", "\u0120new", "\u0120Hash", "Map", "<", ">", "());", "\u0120final", "\u0120Map", "<", "Integer", ",", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", ">", "\u0120association", "F", "acts", "\u0120=", "\u0120alarm", "Ass", "ociation", "ById", ".", "get", "(", "sit", "uation", ".", "get", "Id", "());", "\u0120for", "\u0120(", "Al", "arm", "Ass", "ociation", "\u0120association", "\u0120:", "\u0120situation", ".", "get", "Associated", "Al", "arms", "())", "\u0120{", "\u0120Integer", "\u0120alarm", "Id", "\u0120=", "\u0120association", ".", "get", "Related", "Al", "arm", "().", "get", "Id", "();", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", "\u0120ass", "ocation", "Fact", "\u0120=", "\u0120association", "F", "acts", ".", "get", "(", "al", "arm", "Id", ");", "\u0120if", "\u0120(", "ass", "ocation", "Fact", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Insert", "ing", "\u0120alarm", "\u0120association", "\u0120into", "\u0120session", ":", "\u0120{}", "\",", "\u0120association", ");", "\u0120final", "\u0120Fact", "Handle", "\u0120fact", "\u0120=", "\u0120get", "K", "ie", "Session", "().", "insert", "(", "ass", "ociation", ");", "\u0120association", "F", "acts", ".", "put", "(", "al", "arm", "Id", ",", "\u0120new", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", "(", "ass", "ociation", ",", "\u0120fact", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120Fact", "Handle", "\u0120fact", "\u0120=", "\u0120ass", "ocation", "Fact", ".", "get", "Fact", "();", "\u0120LOG", ".", "trace", "(\"", "Up", "dating", "\u0120alarm", "\u0120ass", "ocation", "\u0120in", "\u0120session", ":", "\u0120{}", "\",", "\u0120ass", "ocation", "Fact", ");", "\u0120get", "K", "ie", "Session", "().", "update", "(", "fact", ",", "\u0120association", ");", "\u0120association", "F", "acts", ".", "put", "(", "al", "arm", "Id", ",", "\u0120new", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", "(", "ass", "ociation", ",", "\u0120fact", "));", "\u0120}", "\u0120}", "\u0120Set", "<", "Integer", ">", "\u0120deleted", "Al", "arm", "Id", "s", "\u0120=", "\u0120association", "F", "acts", ".", "values", "().", "stream", "()", "\u0120.", "map", "(", "fact", "\u0120->", "\u0120fact", ".", "get", "Al", "arm", "Ass", "ociation", "().", "get", "Related", "Al", "arm", "().", "get", "Id", "())", "\u0120.", "filter", "(", "al", "arm", "Id", "\u0120->", "\u0120!", "sit", "uation", ".", "get", "Related", "Al", "arm", "Id", "s", "().", "cont", "ains", "(", "al", "arm", "Id", "))", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "Set", "());", "\u0120deleted", "Al", "arm", "Id", "s", ".", "stream", "().", "for", "Each", "(", "al", "arm", "Id", "\u0120->", "\u0120{", "\u0120final", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", "\u0120association", "And", "Fact", "\u0120=", "\u0120association", "F", "acts", ".", "remove", "(", "al", "arm", "Id", ");", "\u0120if", "\u0120(", "ass", "ociation", "And", "Fact", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "De", "le", "ting", "\u0120Al", "arm", "Ass", "ociation", "And", "Fact", "\u0120from", "\u0120session", ":", "\u0120{}", "\",", "\u0120association", "And", "Fact", ".", "get", "Al", "arm", "Ass", "ociation", "());", "\u0120get", "K", "ie", "Session", "().", "delete", "(", "ass", "ociation", "And", "Fact", ".", "get", "Fact", "());", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120deleted", "Al", "arm", "Id", "s", ".", "for", "Each", "(", "al", "arm", "Id", "\u0120->", "\u0120{"]}
{"function": "public Obs saveObs(Obs obs, String changeMessage) throws APIException { if(obs == null){ throw new APIException(\"Obs.error.cannot.be.null\", (Object[]) null); } if(obs.getId() != null && changeMessage == null){ throw new APIException(\"Obs.error.ChangeMessage.required\", (Object[]) null); } handleExistingObsWithComplexConcept(obs); ensureRequirePrivilege(obs); if (obs.getObsId() == null || obs.getVoided()) { return saveNewOrVoidedObs(obs,changeMessage); } else if(!obs.isDirty()){ setPersonFromEncounter(obs); return saveObsNotDirty(obs, changeMessage); } else { Errors errors = new BindException(obs, \"obs\"); new ObsValidator().validate(obs, errors); if (!errors.hasFieldErrors(\"person\")){ setPersonFromEncounter(obs); return saveExistingObs(obs,changeMessage); } else{ throw new APIException(\"Obs.error.PersonId.mismatch\", (Object[]) null); } } }", "text": "You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.", "function_tokens": ["public", "\u0120Obs", "\u0120save", "Obs", "(", "Obs", "\u0120obs", ",", "\u0120String", "\u0120change", "Message", ")", "\u0120throws", "\u0120API", "Exception", "\u0120{", "\u0120if", "(", "obs", "\u0120==", "\u0120null", "){", "\u0120throw", "\u0120new", "\u0120API", "Exception", "(\"", "Obs", ".", "error", ".", "c", "annot", ".", "be", ".", "null", "\",", "\u0120(", "Object", "[", "])", "\u0120null", ");", "\u0120}", "\u0120if", "(", "obs", ".", "get", "Id", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120change", "Message", "\u0120==", "\u0120null", "){", "\u0120throw", "\u0120new", "\u0120API", "Exception", "(\"", "Obs", ".", "error", ".", "Change", "Message", ".", "required", "\",", "\u0120(", "Object", "[", "])", "\u0120null", ");", "\u0120}", "\u0120handle", "Ex", "isting", "Obs", "With", "Com", "plex", "Con", "cept", "(", "obs", ");", "\u0120ensure", "Requ", "ire", "Priv", "ilege", "(", "obs", ");", "\u0120if", "\u0120(", "obs", ".", "get", "Obs", "Id", "()", "\u0120==", "\u0120null", "\u0120||", "\u0120obs", ".", "get", "V", "oided", "())", "\u0120{", "\u0120return", "\u0120save", "New", "Or", "V", "oided", "Obs", "(", "obs", ",", "change", "Message", ");", "\u0120}", "\u0120else", "\u0120if", "(", "!", "obs", ".", "is", "D", "irty", "()", "){", "\u0120set", "Person", "From", "En", "counter", "(", "obs", ");", "\u0120return", "\u0120save", "Obs", "Not", "D", "irty", "(", "obs", ",", "\u0120change", "Message", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Errors", "\u0120errors", "\u0120=", "\u0120new", "\u0120Bind", "Exception", "(", "obs", ",", "\u0120\"", "obs", "\");", "\u0120new", "\u0120Obs", "Valid", "ator", "().", "valid", "ate", "(", "obs", ",", "\u0120errors", ");", "\u0120if", "\u0120(!", "errors", ".", "has", "Field", "Er", "rors", "(\"", "person", "\"))", "{", "\u0120set", "Person", "From", "En", "counter", "(", "obs", ");", "\u0120return", "\u0120save", "Ex", "isting", "Obs", "(", "obs", ",", "change", "Message", ");", "\u0120}", "\u0120else", "{", "\u0120throw", "\u0120new", "\u0120API", "Exception", "(\"", "Obs", ".", "error", ".", "Person", "Id", ".", "m", "ism", "atch", "\",", "\u0120(", "Object", "[", "])", "\u0120null", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["You", "\u0120don", "'t", "\u0120need", "\u0120to", "\u0120call", "\u0120the", "\u0120valid", "ator", ",", "\u0120it", "'s", "\u0120called", "\u0120automatically", "\u0120via", "\u0120A", "OP", "\u0120advice", "\u0120around", "\u0120the", "\u0120save", "Obs", "\u0120method", "."]}
{"function": "protected void onExportChanged() { boolean externalNetwork = (Boolean) getExport().getEntity(); getQos().setIsChangable(!externalNetwork); getAddQosCommand().setIsExecutionAllowed(!externalNetwork); String label = getNetworkLabel().getSelectedItem(); if (externalNetwork) { getNetworkLabel().setItems(new HashSet<String>()); } else { getNetworkLabel().setItems(dcLabels); } getNetworkLabel().setSelectedItem(label); }", "text": "consider 'ternary if' here", "function_tokens": ["protected", "\u0120void", "\u0120on", "Export", "Changed", "()", "\u0120{", "\u0120boolean", "\u0120external", "Network", "\u0120=", "\u0120(", "Boo", "lean", ")", "\u0120get", "Export", "().", "get", "Entity", "();", "\u0120get", "Q", "os", "().", "set", "Is", "Ch", "ang", "able", "(", "!", "external", "Network", ");", "\u0120get", "Add", "Q", "os", "Command", "().", "set", "Is", "Exec", "ution", "All", "owed", "(", "!", "external", "Network", ");", "\u0120String", "\u0120label", "\u0120=", "\u0120get", "Network", "Label", "().", "get", "Se", "lected", "Item", "();", "\u0120if", "\u0120(", "external", "Network", ")", "\u0120{", "\u0120get", "Network", "Label", "().", "set", "Items", "(", "new", "\u0120Hash", "Set", "<", "String", ">", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120get", "Network", "Label", "().", "set", "Items", "(", "dc", "Lab", "els", ");", "\u0120}", "\u0120get", "Network", "Label", "().", "set", "Se", "lected", "Item", "(", "label", ");", "\u0120}"], "docstring_tokens": ["consider", "\u0120'", "tern", "ary", "\u0120if", "'", "\u0120here"]}
{"function": "protected void executeCommand() { setVds(null); if (getVds() == null) { setCommandShouldBeLogged(false); log.infoFormat(\"SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore.\", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } if (getVds().getStatus() != VDSStatus.Maintenance) { setCommandShouldBeLogged(false); log.infoFormat(\"SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance.\", getVdsName(), getVdsId()); getReturnValue().setSucceeded(false); return; } boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString()); if (result) { getVds().setStatus(VDSStatus.Down); if (!getParameters().getKeepPolicyPMEnabled()) { getVds().setPowerManagementControlledByPolicy(false); } getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData()); } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) { FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop); parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled()); Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext()); } getReturnValue().setSucceeded(result); }", "text": "power down", "function_tokens": ["protected", "\u0120void", "\u0120execute", "Command", "()", "\u0120{", "\u0120set", "V", "ds", "(", "null", ");", "\u0120if", "\u0120(", "get", "V", "ds", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120set", "Command", "Should", "Be", "Log", "ged", "(", "false", ");", "\u0120log", ".", "info", "Format", "(\"", "SS", "H", "\u0120power", "down", "\u0120will", "\u0120not", "\u0120be", "\u0120executed", "\u0120on", "\u0120host", "\u0120{", "0", "}", "({", "1", "})", "\u0120since", "\u0120it", "\u0120doesn", "'t", "\u0120exist", "\u0120anymore", ".\",", "\u0120get", "V", "ds", "Name", "(),", "\u0120get", "V", "ds", "Id", "());", "\u0120get", "Return", "Value", "().", "set", "S", "uc", "ceed", "ed", "(", "false", ");", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "get", "V", "ds", "().", "get", "Status", "()", "\u0120!=", "\u0120V", "DS", "Status", ".", "Main", "tenance", ")", "\u0120{", "\u0120set", "Command", "Should", "Be", "Log", "ged", "(", "false", ");", "\u0120log", ".", "info", "Format", "(\"", "SS", "H", "\u0120power", "down", "\u0120will", "\u0120not", "\u0120be", "\u0120executed", "\u0120on", "\u0120host", "\u0120{", "0", "}", "({", "1", "})", "\u0120since", "\u0120it", "\u0120is", "\u0120not", "\u0120in", "\u0120Maintenance", ".\",", "\u0120get", "V", "ds", "Name", "(),", "\u0120get", "V", "ds", "Id", "());", "\u0120get", "Return", "Value", "().", "set", "S", "uc", "ceed", "ed", "(", "false", ");", "\u0120return", ";", "\u0120}", "\u0120boolean", "\u0120result", "\u0120=", "\u0120execute", "S", "sh", "Power", "down", "(", "get", "V", "ds", "().", "get", "V", "ds", "Group", "Comp", "atibility", "Version", "().", "to", "String", "());", "\u0120if", "\u0120(", "result", ")", "\u0120{", "\u0120get", "V", "ds", "().", "set", "Status", "(", "V", "DS", "Status", ".", "Down", ");", "\u0120if", "\u0120(!", "get", "Parameters", "().", "get", "Keep", "Policy", "PM", "Enabled", "())", "\u0120{", "\u0120get", "V", "ds", "().", "set", "Power", "Management", "Cont", "rolled", "By", "Policy", "(", "false", ");", "\u0120}", "\u0120get", "Db", "Fac", "ade", "().", "get", "V", "ds", "Dynamic", "D", "ao", "().", "update", "(", "get", "V", "ds", "().", "get", "Dynamic", "Data", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "get", "Parameters", "().", "get", "Fall", "back", "To", "Power", "Management", "()", "\u0120&&", "\u0120get", "V", "ds", "().", "get", "pm", "_", "enabled", "())", "\u0120{", "\u0120F", "ence", "V", "ds", "Action", "Parameters", "\u0120parameters", "\u0120=", "\u0120new", "\u0120F", "ence", "V", "ds", "Action", "Parameters", "(", "get", "V", "ds", "().", "get", "Id", "(),", "\u0120F", "ence", "Action", "Type", ".", "Stop", ");", "\u0120parameters", ".", "set", "Keep", "Policy", "PM", "Enabled", "(", "get", "Parameters", "().", "get", "Keep", "Policy", "PM", "Enabled", "());", "\u0120Back", "end", ".", "get", "Instance", "().", "run", "Internal", "Action", "(", "V", "dc", "Action", "Type", ".", "Stop", "V", "ds", ",", "\u0120parameters", ",", "\u0120Execution", "Handler", ".", "create", "Internal", "Job", "Context", "());", "\u0120}", "\u0120get", "Return", "Value", "().", "set", "S", "uc", "ceed", "ed", "(", "result", ");", "\u0120}"], "docstring_tokens": ["power", "\u0120down"]}
{"function": "public Optional<Symbol> resolveMember(String memberName) { if (types.stream().anyMatch(type -> type instanceof RuntimeType && ((RuntimeType) type).hasUnresolvedHierarchy())) { return Optional.empty(); } Set<Optional<Symbol>> resolved = types.stream() .map(t -> t.resolveMember(memberName)) .filter(Optional::isPresent) .collect(Collectors.toSet()); if (resolved.isEmpty()) { return Optional.empty(); } else if (resolved.size() == 1) { return resolved.iterator().next(); } return Optional.of(AmbiguousSymbolImpl.create(resolved.stream().map(s -> s.orElse(null)).filter(Objects::nonNull).collect(Collectors.toSet()))); }", "text": "I don't think \"resolveMember\" should create a new symbol. We should find another approach", "function_tokens": ["public", "\u0120Optional", "<", "Sy", "mbol", ">", "\u0120resolve", "Member", "(", "String", "\u0120member", "Name", ")", "\u0120{", "\u0120if", "\u0120(", "types", ".", "stream", "().", "any", "Match", "(", "type", "\u0120->", "\u0120type", "\u0120instance", "of", "\u0120Runtime", "Type", "\u0120&&", "\u0120((", "Runtime", "Type", ")", "\u0120type", ").", "has", "Un", "res", "olved", "H", "ier", "archy", "()", "))", "\u0120{", "\u0120return", "\u0120Optional", ".", "empty", "();", "\u0120}", "\u0120Set", "<", "Optional", "<", "Sy", "mbol", ">>", "\u0120resolved", "\u0120=", "\u0120types", ".", "stream", "()", "\u0120.", "map", "(", "t", "\u0120->", "\u0120t", ".", "res", "olve", "Member", "(", "member", "Name", "))", "\u0120.", "filter", "(", "Optional", "::", "is", "Present", ")", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "Set", "());", "\u0120if", "\u0120(", "res", "olved", ".", "is", "Empty", "())", "\u0120{", "\u0120return", "\u0120Optional", ".", "empty", "();", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "res", "olved", ".", "size", "()", "\u0120==", "\u01201", ")", "\u0120{", "\u0120return", "\u0120resolved", ".", "iterator", "().", "next", "();", "\u0120}", "\u0120return", "\u0120Optional", ".", "of", "(", "Amb", "iguous", "Sy", "mbol", "Impl", ".", "create", "(", "res", "olved", ".", "stream", "().", "map", "(", "s", "\u0120->", "\u0120s", ".", "or", "Else", "(", "null", ")).", "filter", "(", "Object", "s", "::", "non", "Null", ").", "collect", "(", "Collect", "ors", ".", "to", "Set", "()", "))", ");", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120\"", "res", "olve", "Member", "\"", "\u0120should", "\u0120create", "\u0120a", "\u0120new", "\u0120symbol", ".", "\u0120We", "\u0120should", "\u0120find", "\u0120another", "\u0120approach"]}
{"function": "public static BlobProperties buildBlobProperties(Map<String, Object> args) throws RestServiceException { Account account = (Account) args.get(InternalKeys.TARGET_ACCOUNT_KEY); if (account == null) { throw new RestServiceException(InternalKeys.TARGET_ACCOUNT_KEY + \" is not set\", RestServiceErrorCode.MissingArgs); } Container container = (Container) args.get(InternalKeys.TARGET_CONTAINER_KEY); if (container == null) { throw new RestServiceException(InternalKeys.TARGET_CONTAINER_KEY + \" is not set\", RestServiceErrorCode.MissingArgs); } String serviceId = getHeader(args, Headers.SERVICE_ID, true); String contentType = getHeader(args, Headers.AMBRY_CONTENT_TYPE, true); String ownerId = getHeader(args, Headers.OWNER_ID, false); long ttl = Utils.Infinite_Time; String ttlStr = getHeader(args, Headers.TTL, false); if (ttlStr != null) { try { ttl = Long.parseLong(ttlStr); if (ttl < -1) { throw new RestServiceException(Headers.TTL + \"[\" + ttl + \"] is not valid (has to be >= -1)\", RestServiceErrorCode.InvalidArgs); } } catch (NumberFormatException e) { throw new RestServiceException(Headers.TTL + \"[\" + ttlStr + \"] could not parsed into a number\", RestServiceErrorCode.InvalidArgs); } } return new BlobProperties(-1, serviceId, ownerId, contentType, isPrivate(args), ttl, account.getId(), container.getId()); }", "text": "Let's make this InternalServerError", "function_tokens": ["public", "\u0120static", "\u0120Bl", "ob", "Pro", "perties", "\u0120build", "Bl", "ob", "Pro", "perties", "(", "Map", "<", "String", ",", "\u0120Object", ">", "\u0120args", ")", "\u0120throws", "\u0120Rest", "Service", "Exception", "\u0120{", "\u0120Account", "\u0120account", "\u0120=", "\u0120(", "Account", ")", "\u0120args", ".", "get", "(", "Internal", "Keys", ".", "T", "ARGET", "_", "ACC", "OUNT", "_", "KEY", ");", "\u0120if", "\u0120(", "account", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Rest", "Service", "Exception", "(", "Internal", "Keys", ".", "T", "ARGET", "_", "ACC", "OUNT", "_", "KEY", "\u0120+", "\u0120\"", "\u0120is", "\u0120not", "\u0120set", "\",", "\u0120Rest", "Service", "Error", "Code", ".", "Missing", "Args", ");", "\u0120}", "\u0120Container", "\u0120container", "\u0120=", "\u0120(", "Container", ")", "\u0120args", ".", "get", "(", "Internal", "Keys", ".", "T", "ARGET", "_", "CON", "TAIN", "ER", "_", "KEY", ");", "\u0120if", "\u0120(", "container", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Rest", "Service", "Exception", "(", "Internal", "Keys", ".", "T", "ARGET", "_", "CON", "TAIN", "ER", "_", "KEY", "\u0120+", "\u0120\"", "\u0120is", "\u0120not", "\u0120set", "\",", "\u0120Rest", "Service", "Error", "Code", ".", "Missing", "Args", ");", "\u0120}", "\u0120String", "\u0120service", "Id", "\u0120=", "\u0120get", "Header", "(", "args", ",", "\u0120Head", "ers", ".", "SER", "VICE", "_", "ID", ",", "\u0120true", ");", "\u0120String", "\u0120content", "Type", "\u0120=", "\u0120get", "Header", "(", "args", ",", "\u0120Head", "ers", ".", "AM", "BR", "Y", "_", "CONT", "ENT", "_", "TYPE", ",", "\u0120true", ");", "\u0120String", "\u0120owner", "Id", "\u0120=", "\u0120get", "Header", "(", "args", ",", "\u0120Head", "ers", ".", "OWN", "ER", "_", "ID", ",", "\u0120false", ");", "\u0120long", "\u0120t", "tl", "\u0120=", "\u0120Ut", "ils", ".", "Inf", "inite", "_", "Time", ";", "\u0120String", "\u0120t", "tl", "Str", "\u0120=", "\u0120get", "Header", "(", "args", ",", "\u0120Head", "ers", ".", "T", "TL", ",", "\u0120false", ");", "\u0120if", "\u0120(", "tt", "l", "Str", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120t", "tl", "\u0120=", "\u0120Long", ".", "parse", "Long", "(", "tt", "l", "Str", ");", "\u0120if", "\u0120(", "tt", "l", "\u0120<", "\u0120-", "1", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Rest", "Service", "Exception", "(", "Head", "ers", ".", "T", "TL", "\u0120+", "\u0120\"[", "\"", "\u0120+", "\u0120t", "tl", "\u0120+", "\u0120\"", "]", "\u0120is", "\u0120not", "\u0120valid", "\u0120(", "has", "\u0120to", "\u0120be", "\u0120>=", "\u0120-", "1", ")\",", "\u0120Rest", "Service", "Error", "Code", ".", "Invalid", "Args", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Number", "Format", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Rest", "Service", "Exception", "(", "Head", "ers", ".", "T", "TL", "\u0120+", "\u0120\"[", "\"", "\u0120+", "\u0120t", "tl", "Str", "\u0120+", "\u0120\"", "]", "\u0120could", "\u0120not", "\u0120parsed", "\u0120into", "\u0120a", "\u0120number", "\",", "\u0120Rest", "Service", "Error", "Code", ".", "Invalid", "Args", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120new", "\u0120Bl", "ob", "Pro", "perties", "(-", "1", ",", "\u0120service", "Id", ",", "\u0120owner", "Id", ",", "\u0120content", "Type", ",", "\u0120is", "Private", "(", "args", "),", "\u0120t", "tl", ",", "\u0120account", ".", "get", "Id", "(),", "\u0120container", ".", "get", "Id", "());", "\u0120}"], "docstring_tokens": ["Let", "'s", "\u0120make", "\u0120this", "\u0120Internal", "Server", "Error"]}
{"function": "public AlphaRejectBlocksNode(Context context) { Config config = context.get(Config.class); DisplayResolutionDependentFBOs displayResolutionDependentFBOs = context.get(DisplayResolutionDependentFBOs.class); worldRenderer = context.get(WorldRenderer.class); renderQueues = context.get(RenderQueuesHelper.class); wireframeStateChange = new SetWireframe(true); RenderingDebugConfig renderingDebugConfig = config.getRendering().getDebug(); new WireframeTrigger(renderingDebugConfig, this); playerCamera = worldRenderer.getActiveCamera(); addDesiredStateChange(new LookThrough(playerCamera)); addDesiredStateChange(new BindFBO(READONLY_GBUFFER, displayResolutionDependentFBOs)); addDesiredStateChange(new EnableMaterial(CHUNK_SHADER.toString())); chunkShader = getMaterial(CHUNK_SHADER); }", "text": "1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?", "function_tokens": ["public", "\u0120Alpha", "Re", "ject", "Blocks", "Node", "(", "Context", "\u0120context", ")", "\u0120{", "\u0120Config", "\u0120config", "\u0120=", "\u0120context", ".", "get", "(", "Config", ".", "class", ");", "\u0120Display", "Res", "olution", "D", "ependent", "F", "BO", "s", "\u0120display", "Res", "olution", "D", "ependent", "F", "BO", "s", "\u0120=", "\u0120context", ".", "get", "(", "Display", "Res", "olution", "D", "ependent", "F", "BO", "s", ".", "class", ");", "\u0120world", "R", "end", "erer", "\u0120=", "\u0120context", ".", "get", "(", "World", "R", "end", "erer", ".", "class", ");", "\u0120render", "Que", "ues", "\u0120=", "\u0120context", ".", "get", "(", "Render", "Que", "ues", "Helper", ".", "class", ");", "\u0120wire", "frame", "State", "Change", "\u0120=", "\u0120new", "\u0120Set", "Wire", "frame", "(", "true", ");", "\u0120Rend", "ering", "Debug", "Config", "\u0120rendering", "Debug", "Config", "\u0120=", "\u0120config", ".", "get", "R", "end", "ering", "().", "get", "Debug", "();", "\u0120new", "\u0120Wire", "frame", "Trigger", "(", "render", "ing", "Debug", "Config", ",", "\u0120this", ");", "\u0120player", "Camera", "\u0120=", "\u0120world", "R", "end", "erer", ".", "get", "Active", "Camera", "();", "\u0120add", "Des", "ired", "State", "Change", "(", "new", "\u0120Look", "Through", "(", "player", "Camera", "));", "\u0120add", "Des", "ired", "State", "Change", "(", "new", "\u0120Bind", "F", "BO", "(", "READ", "ON", "LY", "_", "GB", "U", "FFER", ",", "\u0120display", "Res", "olution", "D", "ependent", "F", "BO", "s", "));", "\u0120add", "Des", "ired", "State", "Change", "(", "new", "\u0120Enable", "Material", "(", "CH", "UN", "K", "_", "SH", "AD", "ER", ".", "to", "String", "()", "));", "\u0120chunk", "Sh", "ader", "\u0120=", "\u0120get", "Material", "(", "CH", "UN", "K", "_", "SH", "AD", "ER", ");", "\u0120}"], "docstring_tokens": ["1", ".", "\u0120unless", "\u0120there", "\u0120are", "\u0120other", "\u0120reasons", "\u0120I", "'d", "\u0120rewrite", "\u0120this", "\u0120as", "\u0120context", ".", "get", "(", "Config", ".", "class", ").", "get", "R", "end", "ering", "().", "get", "Debug", "();", "\u0120and", "\u0120I", "'d", "\u0120avoid", "\u0120storing", "\u0120the", "\u0120config", ".", "\u01202", ".", "\u0120Can", "\u0120you", "\u0120check", "\u0120if", "\u0120by", "\u0120any", "\u0120chance", "\u0120the", "\u0120Rend", "ering", "Config", "\u0120class", "\u0120is", "\u0120available", "\u0120straight", "\u0120from", "\u0120the", "\u0120context", "?"]}
{"function": "public static String print(Node n, String encoding) { if (n == null) { return null; } try { Document document = null; if (n instanceof Document) { document = (Document) n; } else { document = n.getOwnerDocument(); } StringWriter stringOut = new StringWriter(); DOMImplementationLS domImpl = (DOMImplementationLS) document.getImplementation(); LSSerializer lsSerializer = domImpl.createLSSerializer(); lsSerializer.getDomConfig().setParameter(XML_DECLARATION, false); LSOutput lsout = domImpl.createLSOutput(); lsout.setEncoding(encoding); lsout.setCharacterStream(stringOut); NodeList childNodes = n.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { lsSerializer.write(childNodes.item(i), lsout); } return stringOut.toString(); } catch (DOMException | LSException e) { LOGGER.debug(e.getMessage(), e); } return null; }", "text": "Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120print", "(", "Node", "\u0120n", ",", "\u0120String", "\u0120encoding", ")", "\u0120{", "\u0120if", "\u0120(", "n", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120try", "\u0120{", "\u0120Document", "\u0120document", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "n", "\u0120instance", "of", "\u0120Document", ")", "\u0120{", "\u0120document", "\u0120=", "\u0120(", "Document", ")", "\u0120n", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120document", "\u0120=", "\u0120n", ".", "get", "Owner", "Document", "();", "\u0120}", "\u0120String", "Writer", "\u0120string", "Out", "\u0120=", "\u0120new", "\u0120String", "Writer", "();", "\u0120DOM", "Im", "plementation", "LS", "\u0120dom", "Impl", "\u0120=", "\u0120(", "DOM", "Im", "plementation", "LS", ")", "\u0120document", ".", "get", "Im", "plementation", "();", "\u0120L", "SS", "erial", "izer", "\u0120ls", "Serial", "izer", "\u0120=", "\u0120dom", "Impl", ".", "create", "L", "SS", "erial", "izer", "();", "\u0120ls", "Serial", "izer", ".", "get", "Dom", "Config", "().", "set", "Parameter", "(", "X", "ML", "_", "DEC", "L", "AR", "ATION", ",", "\u0120false", ");", "\u0120LS", "Output", "\u0120ls", "out", "\u0120=", "\u0120dom", "Impl", ".", "create", "LS", "Output", "();", "\u0120ls", "out", ".", "set", "Enc", "oding", "(", "enc", "oding", ");", "\u0120ls", "out", ".", "set", "Character", "Stream", "(", "string", "Out", ");", "\u0120Node", "List", "\u0120child", "N", "odes", "\u0120=", "\u0120n", ".", "get", "Child", "N", "odes", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120child", "N", "odes", ".", "get", "Length", "();", "\u0120i", "++)", "\u0120{", "\u0120ls", "Serial", "izer", ".", "write", "(", "child", "N", "odes", ".", "item", "(", "i", "),", "\u0120ls", "out", ");", "\u0120}", "\u0120return", "\u0120string", "Out", ".", "to", "String", "();", "\u0120}", "\u0120catch", "\u0120(", "DOM", "Exception", "\u0120|", "\u0120LS", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(", "e", ".", "get", "Message", "(),", "\u0120e", ");", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["Just", "\u0120want", "\u0120to", "\u0120make", "\u0120sure", "\u0120I", "'m", "\u0120understanding", "\u0120this", "\u0120correctly", ",", "\u0120previously", "\u0120we", "\u0120weren", "'t", "\u0120looking", "\u0120at", "\u0120these", "\u0120child", "n", "odes", "\u0120but", "\u0120now", "\u0120we", "\u0120are", "?"]}
{"function": "public void onCompletion(Void result, Exception exception) { callbackTracker.markOperationEnd(); if (exception == null) { try { RestMethod restMethod = restRequest.getRestMethod(); logger.trace(\"Forwarding {} to the IdConverter/Router\", restMethod); switch (restMethod) { case GET: String receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); InboundIdConverterCallback idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, getCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case HEAD: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, headCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; case DELETE: receivedId = RestUtils.getRequestPath(restRequest).getOperationOrBlobId(false); idConverterCallback = new InboundIdConverterCallback(restRequest, restResponseChannel, deleteCallback); idConverter.convert(restRequest, receivedId, idConverterCallback); break; default: exception = new IllegalStateException(\"Unrecognized RestMethod: \" + restMethod); } } catch (Exception e) { exception = extractExecutionExceptionCause(e); } } if (exception != null) { submitResponse(restRequest, restResponseChannel, null, exception); } callbackTracker.markCallbackProcessingEnd(); }", "text": "Why not extract receivedId before switch block? (reduce the duplicate code)", "function_tokens": ["public", "\u0120void", "\u0120on", "Com", "pletion", "(", "V", "oid", "\u0120result", ",", "\u0120Exception", "\u0120exception", ")", "\u0120{", "\u0120callback", "Tracker", ".", "mark", "Operation", "End", "();", "\u0120if", "\u0120(", "ex", "ception", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Rest", "Method", "\u0120rest", "Method", "\u0120=", "\u0120rest", "Request", ".", "get", "Rest", "Method", "();", "\u0120logger", ".", "trace", "(\"", "Forward", "ing", "\u0120{}", "\u0120to", "\u0120the", "\u0120Id", "Con", "ver", "ter", "/", "R", "outer", "\",", "\u0120rest", "Method", ");", "\u0120switch", "\u0120(", "rest", "Method", ")", "\u0120{", "\u0120case", "\u0120GET", ":", "\u0120String", "\u0120received", "Id", "\u0120=", "\u0120Rest", "Ut", "ils", ".", "get", "Request", "Path", "(", "rest", "Request", ").", "get", "Operation", "Or", "Bl", "ob", "Id", "(", "false", ");", "\u0120In", "bound", "Id", "Con", "ver", "ter", "Callback", "\u0120id", "Con", "ver", "ter", "Callback", "\u0120=", "\u0120new", "\u0120In", "bound", "Id", "Con", "ver", "ter", "Callback", "(", "rest", "Request", ",", "\u0120rest", "Response", "Channel", ",", "\u0120get", "Callback", ");", "\u0120id", "Con", "ver", "ter", ".", "con", "vert", "(", "rest", "Request", ",", "\u0120received", "Id", ",", "\u0120id", "Con", "ver", "ter", "Callback", ");", "\u0120break", ";", "\u0120case", "\u0120HEAD", ":", "\u0120received", "Id", "\u0120=", "\u0120Rest", "Ut", "ils", ".", "get", "Request", "Path", "(", "rest", "Request", ").", "get", "Operation", "Or", "Bl", "ob", "Id", "(", "false", ");", "\u0120id", "Con", "ver", "ter", "Callback", "\u0120=", "\u0120new", "\u0120In", "bound", "Id", "Con", "ver", "ter", "Callback", "(", "rest", "Request", ",", "\u0120rest", "Response", "Channel", ",", "\u0120head", "Callback", ");", "\u0120id", "Con", "ver", "ter", ".", "con", "vert", "(", "rest", "Request", ",", "\u0120received", "Id", ",", "\u0120id", "Con", "ver", "ter", "Callback", ");", "\u0120break", ";", "\u0120case", "\u0120DE", "LE", "TE", ":", "\u0120received", "Id", "\u0120=", "\u0120Rest", "Ut", "ils", ".", "get", "Request", "Path", "(", "rest", "Request", ").", "get", "Operation", "Or", "Bl", "ob", "Id", "(", "false", ");", "\u0120id", "Con", "ver", "ter", "Callback", "\u0120=", "\u0120new", "\u0120In", "bound", "Id", "Con", "ver", "ter", "Callback", "(", "rest", "Request", ",", "\u0120rest", "Response", "Channel", ",", "\u0120delete", "Callback", ");", "\u0120id", "Con", "ver", "ter", ".", "con", "vert", "(", "rest", "Request", ",", "\u0120received", "Id", ",", "\u0120id", "Con", "ver", "ter", "Callback", ");", "\u0120break", ";", "\u0120default", ":", "\u0120exception", "\u0120=", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "Un", "recogn", "ized", "\u0120Rest", "Method", ":", "\u0120\"", "\u0120+", "\u0120rest", "Method", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120exception", "\u0120=", "\u0120extract", "Exec", "ution", "Exception", "Cause", "(", "e", ");", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "ex", "ception", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120submit", "Response", "(", "rest", "Request", ",", "\u0120rest", "Response", "Channel", ",", "\u0120null", ",", "\u0120exception", ");", "\u0120}", "\u0120callback", "Tracker", ".", "mark", "Callback", "Process", "ing", "End", "();", "\u0120}"], "docstring_tokens": ["Why", "\u0120not", "\u0120extract", "\u0120received", "Id", "\u0120before", "\u0120switch", "\u0120block", "?", "\u0120(", "red", "uce", "\u0120the", "\u0120duplicate", "\u0120code", ")"]}
{"function": "@OnClick(R.id.gallery_cta_button) void onTranslateClick(View v) { GalleryItemFragment item = getCurrentItem(); if (item == null || item.getImageTitle() == null || item.getMediaInfo() == null || item.getMediaInfo().getMetadata() == null) { return; } if (imageEditType != null) { switch (imageEditType) { case ADD_TAGS: startTagsEdit(item); break; case ADD_CAPTION_TRANSLATION: startCaptionTranslation(item); break; default: startCaptionEdit(item); } } }", "text": "Feels like this null check can be included above.", "function_tokens": ["@", "On", "Click", "(", "R", ".", "id", ".", "gallery", "_", "ct", "a", "_", "button", ")", "\u0120void", "\u0120on", "Trans", "late", "Click", "(", "View", "\u0120v", ")", "\u0120{", "\u0120Gallery", "Item", "Frag", "ment", "\u0120item", "\u0120=", "\u0120get", "Current", "Item", "();", "\u0120if", "\u0120(", "item", "\u0120==", "\u0120null", "\u0120||", "\u0120item", ".", "get", "Image", "Title", "()", "\u0120==", "\u0120null", "\u0120||", "\u0120item", ".", "get", "Media", "Info", "()", "\u0120==", "\u0120null", "\u0120||", "\u0120item", ".", "get", "Media", "Info", "().", "get", "Met", "adata", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "image", "Edit", "Type", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120switch", "\u0120(", "image", "Edit", "Type", ")", "\u0120{", "\u0120case", "\u0120ADD", "_", "TAG", "S", ":", "\u0120start", "Tags", "Edit", "(", "item", ");", "\u0120break", ";", "\u0120case", "\u0120ADD", "_", "CAP", "TION", "_", "TR", "AN", "SL", "ATION", ":", "\u0120start", "Ca", "ption", "Translation", "(", "item", ");", "\u0120break", ";", "\u0120default", ":", "\u0120start", "Ca", "ption", "Edit", "(", "item", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Fe", "els", "\u0120like", "\u0120this", "\u0120null", "\u0120check", "\u0120can", "\u0120be", "\u0120included", "\u0120above", "."]}
{"function": "private static String toHex(String s) { StringBuffer buf = null; try { buf = new StringBuffer(s.getBytes(\"UTF-8\").length); for (byte x : s.getBytes(\"UTF-8\")) { buf.append(\"%\"); buf.append(Integer.toHexString(x & 0xFF)); } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return buf.toString().toUpperCase(); }", "text": "Extra space", "function_tokens": ["private", "\u0120static", "\u0120String", "\u0120to", "H", "ex", "(", "String", "\u0120s", ")", "\u0120{", "\u0120String", "Buffer", "\u0120buf", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120buf", "\u0120=", "\u0120new", "\u0120String", "Buffer", "(", "s", ".", "get", "Bytes", "(\"", "UTF", "-", "8", "\").", "length", ");", "\u0120for", "\u0120(", "byte", "\u0120x", "\u0120:", "\u0120s", ".", "get", "Bytes", "(\"", "UTF", "-", "8", "\"))", "\u0120{", "\u0120buf", ".", "append", "(\"", "%", "\");", "\u0120buf", ".", "append", "(", "Integer", ".", "to", "H", "ex", "String", "(", "x", "\u0120&", "\u01200", "x", "FF", "));", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Un", "supported", "Enc", "oding", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120return", "\u0120buf", ".", "to", "String", "().", "to", "U", "pper", "Case", "();", "\u0120}"], "docstring_tokens": ["Extra", "\u0120space"]}
{"function": "private SmooshedWriter delegateSmooshedWriter(final String name,final long size) throws IOException { final File tmpFile = new File(baseDir, name); createFiles.add(tmpFile); return new SmooshedWriter () { private int currOffset = 0; private boolean open = true; private final FileOutputStream out = new FileOutputStream(tmpFile); @Override public void close() throws IOException { open = false; out.close(); files.add(tmpFile); if(!writerCurrentlyInUse ) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { FileChannel channel = out.getChannel(); int bytesWritten = channel.write(buffer); return addToOffset(bytesWritten); } @Override public int write(InputStream in) throws IOException { return addToOffset(Ints.checkedCast(java.nio.file.Files.copy(in, tmpFile.toPath()))); } public int addToOffset(int numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(\"Wrote more bytes[%,d] than available[%,d]. Don't do that.\", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return numBytesWritten; } @Override public boolean isOpen() { return open; } }; }", "text": "This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name \"verify\" which makes it clear that the intent of the method is to do some state checks...", "function_tokens": ["private", "\u0120Sm", "oos", "hed", "Writer", "\u0120delegate", "S", "mo", "os", "hed", "Writer", "(", "final", "\u0120String", "\u0120name", ",", "final", "\u0120long", "\u0120size", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120final", "\u0120File", "\u0120tmp", "File", "\u0120=", "\u0120new", "\u0120File", "(", "base", "Dir", ",", "\u0120name", ");", "\u0120create", "Files", ".", "add", "(", "tmp", "File", ");", "\u0120return", "\u0120new", "\u0120Sm", "oos", "hed", "Writer", "\u0120()", "\u0120{", "\u0120private", "\u0120int", "\u0120cur", "r", "Offset", "\u0120=", "\u01200", ";", "\u0120private", "\u0120boolean", "\u0120open", "\u0120=", "\u0120true", ";", "\u0120private", "\u0120final", "\u0120File", "Output", "Stream", "\u0120out", "\u0120=", "\u0120new", "\u0120File", "Output", "Stream", "(", "tmp", "File", ");", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120close", "()", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120open", "\u0120=", "\u0120false", ";", "\u0120out", ".", "close", "();", "\u0120files", ".", "add", "(", "tmp", "File", ");", "\u0120if", "(", "!", "writer", "Currently", "In", "Use", "\u0120)", "\u0120{", "\u0120merge", "With", "S", "mo", "osher", "();", "\u0120}", "\u0120}", "\u0120public", "\u0120int", "\u0120bytes", "Left", "()", "\u0120{", "\u0120return", "\u0120(", "int", ")", "\u0120(", "size", "\u0120-", "\u0120cur", "r", "Offset", ");", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120int", "\u0120write", "(", "Byte", "Buffer", "\u0120buffer", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120File", "Channel", "\u0120channel", "\u0120=", "\u0120out", ".", "get", "Channel", "();", "\u0120int", "\u0120bytes", "Written", "\u0120=", "\u0120channel", ".", "write", "(", "buffer", ");", "\u0120return", "\u0120add", "To", "Offset", "(", "bytes", "Written", ");", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120int", "\u0120write", "(", "Input", "Stream", "\u0120in", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120return", "\u0120add", "To", "Offset", "(", "Int", "s", ".", "checked", "Cast", "(", "java", ".", "n", "io", ".", "file", ".", "Files", ".", "copy", "(", "in", ",", "\u0120tmp", "File", ".", "to", "Path", "()", "))", ");", "\u0120}", "\u0120public", "\u0120int", "\u0120add", "To", "Offset", "(", "int", "\u0120num", "Bytes", "Written", ")", "\u0120{", "\u0120if", "\u0120(", "num", "Bytes", "Written", "\u0120>", "\u0120bytes", "Left", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120IS", "E", "(\"", "W", "rote", "\u0120more", "\u0120bytes", "[", "%,", "d", "]", "\u0120than", "\u0120available", "[", "%,", "d", "].", "\u0120Don", "'t", "\u0120do", "\u0120that", ".\",", "\u0120num", "Bytes", "Written", ",", "\u0120bytes", "Left", "());", "\u0120}", "\u0120cur", "r", "Offset", "\u0120+=", "\u0120num", "Bytes", "Written", ";", "\u0120return", "\u0120num", "Bytes", "Written", ";", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120boolean", "\u0120is", "Open", "()", "\u0120{", "\u0120return", "\u0120open", ";", "\u0120}", "\u0120};", "\u0120}"], "docstring_tokens": ["This", "\u0120method", "\u0120has", "\u0120a", "\u0120really", "\u0120weird", "\u0120contract", ".", "\u01201", ".", "\u0120Why", "\u0120is", "\u0120it", "\u0120public", "?", "\u01202", ".", "\u0120Why", "\u0120does", "\u0120it", "\u0120return", "\u0120its", "\u0120incoming", "\u0120argument", "\u0120without", "\u0120any", "\u0120adjustment", "?", "\u0120The", "\u0120name", "\u0120of", "\u0120the", "\u0120method", "\u0120makes", "\u0120it", "\u0120seem", "\u0120like", "\u0120this", "\u0120would", "\u0120be", "\u0120returning", "\u0120the", "\u0120total", "\u0120offset", "\u0120instead", "\u0120of", "\u0120the", "\u0120size", ".", "\u0120The", "\u0120methods", "\u0120in", "\u0120the", "\u0120non", "-", "de", "legate", "\u0120writer", "\u0120all", "\u0120do", "\u0120this", "\u0120call", "\u0120first", "\u0120with", "\u0120the", "\u0120name", "\u0120\"", "ver", "ify", "\"", "\u0120which", "\u0120makes", "\u0120it", "\u0120clear", "\u0120that", "\u0120the", "\u0120intent", "\u0120of", "\u0120the", "\u0120method", "\u0120is", "\u0120to", "\u0120do", "\u0120some", "\u0120state", "\u0120checks", "..."]}
{"function": "public DnsClientImpl(VertxInternal vertx, DnsClientOptions options) { Objects.requireNonNull(options, \"no null options accepted\"); Objects.requireNonNull(options.getHost(), \"no null host accepted\"); if (options.getPort() < 1) { throw new IllegalArgumentException(\"DNS client port \" + options.getPort() + \" must be > 0\"); } if (options.getQueryTimeout() < 0) { throw new IllegalArgumentException(\"DNS client timeout \" + options.getQueryTimeout() + \" must be > 0\"); } this.options = new DnsClientOptions(options); ContextInternal creatingContext = vertx.getContext(); if (creatingContext != null && creatingContext.isMultiThreadedWorkerContext()) { throw new IllegalStateException(\"Cannot use DnsClient in a multi-threaded worker verticle\"); } this.dnsServer = new InetSocketAddress(options.getHost(), options.getPort()); this.vertx = vertx; Transport transport = vertx.transport(); actualCtx = vertx.getOrCreateContext(); channel = transport.datagramChannel(InternetProtocolFamily.IPv4); channel.config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true); channel.config().setMaxMessagesPerRead(1); channel.config().setAllocator(PartialPooledByteBufAllocator.INSTANCE); actualCtx.nettyEventLoop().register(channel); if (options.getLogActivity()) { channel.pipeline().addLast(\"logging\", new LoggingHandler()); } channel.pipeline().addLast(new DatagramDnsQueryEncoder()); channel.pipeline().addLast(new DatagramDnsResponseDecoder()); channel.pipeline().addLast(new SimpleChannelInboundHandler<DnsResponse>() { @Override protected void channelRead0(ChannelHandlerContext ctx, DnsResponse msg) throws Exception { int id = msg.id(); Query query = inProgressMap.get(id); if (query != null) { query.handle(msg); } } }); }", "text": "I think this test should be moved to options instead", "function_tokens": ["public", "\u0120D", "ns", "Client", "Impl", "(", "Vert", "x", "Internal", "\u0120vert", "x", ",", "\u0120D", "ns", "Client", "Options", "\u0120options", ")", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "options", ",", "\u0120\"", "no", "\u0120null", "\u0120options", "\u0120accepted", "\");", "\u0120Objects", ".", "require", "Non", "Null", "(", "options", ".", "get", "Host", "(),", "\u0120\"", "no", "\u0120null", "\u0120host", "\u0120accepted", "\");", "\u0120if", "\u0120(", "options", ".", "get", "Port", "()", "\u0120<", "\u01201", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "D", "NS", "\u0120client", "\u0120port", "\u0120\"", "\u0120+", "\u0120options", ".", "get", "Port", "()", "\u0120+", "\u0120\"", "\u0120must", "\u0120be", "\u0120>", "\u01200", "\");", "\u0120}", "\u0120if", "\u0120(", "options", ".", "get", "Query", "Timeout", "()", "\u0120<", "\u01200", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "D", "NS", "\u0120client", "\u0120timeout", "\u0120\"", "\u0120+", "\u0120options", ".", "get", "Query", "Timeout", "()", "\u0120+", "\u0120\"", "\u0120must", "\u0120be", "\u0120>", "\u01200", "\");", "\u0120}", "\u0120this", ".", "options", "\u0120=", "\u0120new", "\u0120D", "ns", "Client", "Options", "(", "options", ");", "\u0120Context", "Internal", "\u0120creating", "Context", "\u0120=", "\u0120vert", "x", ".", "get", "Context", "();", "\u0120if", "\u0120(", "creat", "ing", "Context", "\u0120!=", "\u0120null", "\u0120&&", "\u0120creating", "Context", ".", "is", "Multi", "Thread", "ed", "Work", "er", "Context", "())", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "C", "annot", "\u0120use", "\u0120D", "ns", "Client", "\u0120in", "\u0120a", "\u0120multi", "-", "thread", "ed", "\u0120worker", "\u0120vert", "icle", "\");", "\u0120}", "\u0120this", ".", "d", "ns", "Server", "\u0120=", "\u0120new", "\u0120In", "et", "Socket", "Address", "(", "options", ".", "get", "Host", "(),", "\u0120options", ".", "get", "Port", "());", "\u0120this", ".", "vert", "x", "\u0120=", "\u0120vert", "x", ";", "\u0120Transport", "\u0120transport", "\u0120=", "\u0120vert", "x", ".", "trans", "port", "();", "\u0120actual", "C", "tx", "\u0120=", "\u0120vert", "x", ".", "get", "Or", "Create", "Context", "();", "\u0120channel", "\u0120=", "\u0120transport", ".", "dat", "agram", "Channel", "(", "Internet", "Prot", "ocol", "Family", ".", "IP", "v", "4", ");", "\u0120channel", ".", "config", "().", "set", "Option", "(", "Channel", "Option", ".", "D", "AT", "AG", "RAM", "_", "CH", "ANN", "EL", "_", "ACT", "IVE", "_", "ON", "_", "REG", "IS", "TR", "ATION", ",", "\u0120true", ");", "\u0120channel", ".", "config", "().", "set", "Max", "Mess", "ages", "Per", "Read", "(", "1", ");", "\u0120channel", ".", "config", "().", "set", "All", "oc", "ator", "(", "Part", "ial", "Pool", "ed", "Byte", "B", "uf", "All", "oc", "ator", ".", "INST", "ANCE", ");", "\u0120actual", "C", "tx", ".", "net", "ty", "Event", "Loop", "().", "register", "(", "channel", ");", "\u0120if", "\u0120(", "options", ".", "get", "Log", "Activity", "())", "\u0120{", "\u0120channel", ".", "p", "ip", "eline", "().", "add", "Last", "(\"", "log", "ging", "\",", "\u0120new", "\u0120Log", "ging", "Handler", "());", "\u0120}", "\u0120channel", ".", "p", "ip", "eline", "().", "add", "Last", "(", "new", "\u0120Dat", "agram", "D", "ns", "Query", "Enc", "oder", "());", "\u0120channel", ".", "p", "ip", "eline", "().", "add", "Last", "(", "new", "\u0120Dat", "agram", "D", "ns", "Response", "Dec", "oder", "());", "\u0120channel", ".", "p", "ip", "eline", "().", "add", "Last", "(", "new", "\u0120Simple", "Channel", "In", "bound", "Handler", "<", "D", "ns", "Response", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120protected", "\u0120void", "\u0120channel", "Read", "0", "(", "Channel", "Handler", "Context", "\u0120c", "tx", ",", "\u0120D", "ns", "Response", "\u0120msg", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120int", "\u0120id", "\u0120=", "\u0120msg", ".", "id", "();", "\u0120Query", "\u0120query", "\u0120=", "\u0120in", "Progress", "Map", ".", "get", "(", "id", ");", "\u0120if", "\u0120(", "query", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120query", ".", "handle", "(", "msg", ");", "\u0120}", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120this", "\u0120test", "\u0120should", "\u0120be", "\u0120moved", "\u0120to", "\u0120options", "\u0120instead"]}
{"function": "public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager( getResources().getInteger(R.integer.news_fragment_column_count), StaggeredGridLayoutManager.VERTICAL); getListView().setLayoutManager(layoutManager); mAdapter = new NewsAdapter(getActivity(), ((GdgActivity) getActivity()).getGoogleApiClient()); setRecyclerAdapter(mAdapter); setOnRefreshListener(this); final String plusId = getArguments().getString(Const.EXTRA_PLUS_ID); if (Utils.isOnline(getActivity())) { new Builder<>(String.class, Activities.class) .addParameter(plusId) .setOnPreExecuteListener(new CommonAsyncTask.OnPreExecuteListener() { @Override public void onPreExecute() { setIsLoading(true); } }) .setOnBackgroundExecuteListener( new CommonAsyncTask.OnBackgroundExecuteListener<String, Activities>() { @Override public Activities doInBackground(String... params) { Activities feed = (Activities) App.getInstance().getModelCache().get(Const.CACHE_KEY_NEWS + params[0]); if (feed == null) { feed = getActivityFeedSync(params[0]); } return feed; } }) .setOnPostExecuteListener(new CommonAsyncTask.OnPostExecuteListener<String, Activities>() { @Override public void onPostExecute(String[] params, Activities activityFeed) { if (activityFeed != null) { mAdapter.addAll(activityFeed.getItems()); setIsLoading(false); } } }) .buildAndExecute(); } else { App.getInstance().getModelCache().getAsync(Const.CACHE_KEY_NEWS + plusId, false, new ModelCache.CacheListener() { @Override public void onGet(Object item) { Activities feed = (Activities) item; if (isAdded()) { Snackbar snackbar = Snackbar.make(getView(), R.string.cached_content, Snackbar.LENGTH_SHORT); ColoredSnackBar.info(snackbar).show(); } mAdapter.addAll(feed.getItems()); setIsLoading(false); } @Override public void onNotFound(String key) { showError(R.string.offline_alert); } }); } }", "text": "Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.", "function_tokens": ["public", "\u0120void", "\u0120on", "Activity", "Created", "(", "B", "undle", "\u0120saved", "Instance", "State", ")", "\u0120{", "\u0120super", ".", "on", "Activity", "Created", "(", "s", "aved", "Instance", "State", ");", "\u0120St", "ag", "gered", "Grid", "Layout", "Manager", "\u0120layout", "Manager", "\u0120=", "\u0120new", "\u0120St", "ag", "gered", "Grid", "Layout", "Manager", "(", "\u0120get", "Resources", "().", "get", "Integer", "(", "R", ".", "integer", ".", "news", "_", "fr", "ag", "ment", "_", "column", "_", "count", "),", "\u0120St", "ag", "gered", "Grid", "Layout", "Manager", ".", "VERT", "ICAL", ");", "\u0120get", "List", "View", "().", "set", "Layout", "Manager", "(", "layout", "Manager", ");", "\u0120m", "Adapter", "\u0120=", "\u0120new", "\u0120News", "Adapter", "(", "get", "Activity", "(),", "\u0120((", "G", "d", "g", "Activity", ")", "\u0120get", "Activity", "()", ").", "get", "Google", "A", "pi", "Client", "());", "\u0120set", "Rec", "y", "cler", "Adapter", "(", "m", "Adapter", ");", "\u0120set", "On", "Ref", "resh", "Listener", "(", "this", ");", "\u0120final", "\u0120String", "\u0120plus", "Id", "\u0120=", "\u0120get", "Arg", "uments", "().", "get", "String", "(", "Const", ".", "EXT", "RA", "_", "PL", "US", "_", "ID", ");", "\u0120if", "\u0120(", "Ut", "ils", ".", "is", "Online", "(", "get", "Activity", "()", "))", "\u0120{", "\u0120new", "\u0120Builder", "<", ">(", "String", ".", "class", ",", "\u0120Activities", ".", "class", ")", "\u0120.", "add", "Parameter", "(", "plus", "Id", ")", "\u0120.", "set", "On", "Pre", "Exec", "ute", "Listener", "(", "new", "\u0120Common", "Async", "Task", ".", "On", "Pre", "Exec", "ute", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Pre", "Exec", "ute", "()", "\u0120{", "\u0120set", "Is", "Loading", "(", "true", ");", "\u0120}", "\u0120})", "\u0120.", "set", "On", "Background", "Exec", "ute", "Listener", "(", "\u0120new", "\u0120Common", "Async", "Task", ".", "On", "Background", "Exec", "ute", "Listener", "<", "String", ",", "\u0120Activities", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Activities", "\u0120do", "In", "Background", "(", "String", "...", "\u0120params", ")", "\u0120{", "\u0120Activities", "\u0120feed", "\u0120=", "\u0120(", "Activ", "ities", ")", "\u0120App", ".", "get", "Instance", "().", "get", "Model", "Cache", "().", "get", "(", "Const", ".", "C", "AC", "HE", "_", "KEY", "_", "NEWS", "\u0120+", "\u0120params", "[", "0", "]);", "\u0120if", "\u0120(", "feed", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120feed", "\u0120=", "\u0120get", "Activity", "Feed", "Sync", "(", "params", "[", "0", "]);", "\u0120}", "\u0120return", "\u0120feed", ";", "\u0120}", "\u0120})", "\u0120.", "set", "On", "Post", "Exec", "ute", "Listener", "(", "new", "\u0120Common", "Async", "Task", ".", "On", "Post", "Exec", "ute", "Listener", "<", "String", ",", "\u0120Activities", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Post", "Exec", "ute", "(", "String", "[]", "\u0120params", ",", "\u0120Activities", "\u0120activity", "Feed", ")", "\u0120{", "\u0120if", "\u0120(", "activity", "Feed", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120m", "Adapter", ".", "add", "All", "(", "activity", "Feed", ".", "get", "Items", "());", "\u0120set", "Is", "Loading", "(", "false", ");", "\u0120}", "\u0120}", "\u0120})", "\u0120.", "build", "And", "Exec", "ute", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120App", ".", "get", "Instance", "().", "get", "Model", "Cache", "().", "get", "Async", "(", "Const", ".", "C", "AC", "HE", "_", "KEY", "_", "NEWS", "\u0120+", "\u0120plus", "Id", ",", "\u0120false", ",", "\u0120new", "\u0120Model", "Cache", ".", "Cache", "Listener", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Get", "(", "Object", "\u0120item", ")", "\u0120{", "\u0120Activities", "\u0120feed", "\u0120=", "\u0120(", "Activ", "ities", ")", "\u0120item", ";", "\u0120if", "\u0120(", "is", "Added", "())", "\u0120{", "\u0120Sn", "ack", "bar", "\u0120snack", "bar", "\u0120=", "\u0120Sn", "ack", "bar", ".", "make", "(", "get", "View", "(),", "\u0120R", ".", "string", ".", "c", "ached", "_", "content", ",", "\u0120Sn", "ack", "bar", ".", "L", "ENGTH", "_", "SH", "ORT", ");", "\u0120Col", "ored", "Sn", "ack", "Bar", ".", "info", "(", "sn", "ack", "bar", ").", "show", "();", "\u0120}", "\u0120m", "Adapter", ".", "add", "All", "(", "feed", ".", "get", "Items", "());", "\u0120set", "Is", "Loading", "(", "false", ");", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Not", "Found", "(", "String", "\u0120key", ")", "\u0120{", "\u0120show", "Error", "(", "R", ".", "string", ".", "off", "line", "_", "alert", ");", "\u0120}", "\u0120});", "\u0120}", "\u0120}"], "docstring_tokens": ["Since", "\u0120the", "\u0120classes", "\u0120in", "\u0120the", "\u0120cache", "\u0120are", "\u0120now", "\u0120changed", ",", "\u0120we", "\u0120shouldn", "'t", "\u0120do", "\u0120this", ".", "\u0120We", "\u0120can", "\u0120either", "\u0120change", "\u0120the", "\u0120keys", "\u0120here", ".", "\u0120That", "\u0120will", "\u0120give", "\u0120us", "\u0120new", "\u0120space", "\u0120in", "\u0120cache", ".", "\u0120Or", "\u0120we", "\u0120can", "\u0120delete", "\u0120the", "\u0120cache", "\u0120on", "\u0120app", "\u0120update", "."]}
{"function": "public String[] getSupportedExtensions() { return new String[] { \"at3\", \"oma\", \"aa3\", \"at9\", }; }", "text": "@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.", "function_tokens": ["public", "\u0120String", "[]", "\u0120get", "Supported", "Ext", "ensions", "()", "\u0120{", "\u0120return", "\u0120new", "\u0120String", "[]", "\u0120{", "\u0120\"", "at", "3", "\",", "\u0120\"", "oma", "\",", "\u0120\"", "aa", "3", "\",", "\u0120\"", "at", "9", "\",", "\u0120};", "\u0120}"], "docstring_tokens": ["@", "N", "ad", "ahar", "\u0120I", "\u0120just", "\u0120read", "\u0120that", "\u0120the", "\u0120one", "\u0120used", "\u0120by", "\u0120the", "\u0120PS", "3", "\u0120are", "\u0120.", "**", "at", "rac", "**", ".", "\u0120Did", "\u0120you", "\u0120tried", "\u0120to", "\u0120stream", "\u0120this", "\u0120kind", "\u0120of", "\u0120file", "\u0120to", "\u0120the", "\u0120PS", "3", "\u0120?", "\u0120**", "P", ".", "S", ".", "**", "\u0120.", "om", "g", "\u0120(", "from", "\u0120the", "\u0120french", "\u0120Wikipedia", ")", "\u0120and", "\u0120.", "ms", "a", "\u0120are", "\u0120seen", "\u0120as", "\u0120well", "."]}
{"function": "public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }", "text": "SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE", "function_tokens": ["public", "\u0120void", "\u0120the", "Set", "Special", "Days", "Request", "Is", "Re", "ceived", "()", "\u0120throws", "\u0120Throw", "able", "\u0120{", "\u0120PR", "OP", "ERT", "IES", "_", "MAP", ".", "put", "(", "DE", "VICE", "_", "IDENT", "IFIC", "ATION", "_", "G", "_", "LAB", "EL", ",", "\u0120this", ".", "device", "Id", ".", "get", "Device", "Id", "G", "());", "\u0120PR", "OP", "ERT", "IES", "_", "MAP", ".", "put", "(", "OR", "GAN", "IS", "ATION", "_", "IDENT", "IFIC", "ATION", "_", "LAB", "EL", ",", "\u0120this", ".", "organ", "isation", "Id", ".", "get", "Organ", "isation", "Id", "());", "\u0120this", ".", "Request", "Runner", "(", "PR", "OP", "ERT", "IES", "_", "MAP", ",", "\u0120TEST", "_", "C", "ASE", "_", "NAME", "_", "RE", "QUEST", ",", "\u0120TEST", "_", "C", "ASE", "_", "X", "ML", ",", "\u0120TEST", "_", "SU", "ITE", "_", "X", "ML", ");", "\u0120}"], "docstring_tokens": ["Set", "Special", "Days", "\u0120should", "\u0120be", "\u0120tested", "\u0120on", "\u0120an", "\u0120E", "-", "meter", "\u0120DE", "VICE", "_", "IDENT", "IFIC", "ATION", "_", "G", "_", "LAB", "EL", "\u0120->", "\u0120DE", "VICE", "_", "IDENT", "IFIC", "ATION", "_", "E", "_", "LAB", "EL", "\u0120get", "Device", "Id", "G", "\u0120->", "\u0120get", "Device", "Id", "E"]}
{"function": "public String buildRunCommand() { final List<String> runCommand; if (importsZip == null || abstractEntryClient instanceof ToolClient || Objects.equals(languageType, LanguageType.WDL)) { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), \"--inputs\", provisionedParameterFile.getAbsolutePath()); } else { runCommand = Lists.newArrayList(primaryDescriptor.getAbsolutePath(), \"--inputs\", provisionedParameterFile.getAbsolutePath(), \"--imports\", importsZip.getAbsolutePath()); } System.out.println(\"Calling out to \" + LAUNCHER_NAME + \" to run your workflow\"); final String[] s = { \"java\", \"-jar\", exectionFile.getAbsolutePath(), \"run\" }; List<String> arguments = new ArrayList<>(); arguments.addAll(Arrays.asList(s)); arguments.addAll(runCommand); final String join = Joiner.on(\" \").join(arguments); System.out.println(\"Executing: \" + join); return join; }", "text": "You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.", "function_tokens": ["public", "\u0120String", "\u0120build", "Run", "Command", "()", "\u0120{", "\u0120final", "\u0120List", "<", "String", ">", "\u0120run", "Command", ";", "\u0120if", "\u0120(", "im", "ports", "Zip", "\u0120==", "\u0120null", "\u0120||", "\u0120abstract", "Entry", "Client", "\u0120instance", "of", "\u0120Tool", "Client", "\u0120||", "\u0120Objects", ".", "equ", "als", "(", "language", "Type", ",", "\u0120Language", "Type", ".", "W", "DL", "))", "\u0120{", "\u0120run", "Command", "\u0120=", "\u0120Lists", ".", "new", "Array", "List", "(", "primary", "Desc", "ript", "or", ".", "get", "Abs", "olute", "Path", "(),", "\u0120\"", "--", "input", "s", "\",", "\u0120provision", "ed", "Parameter", "File", ".", "get", "Abs", "olute", "Path", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120run", "Command", "\u0120=", "\u0120Lists", ".", "new", "Array", "List", "(", "primary", "Desc", "ript", "or", ".", "get", "Abs", "olute", "Path", "(),", "\u0120\"", "--", "input", "s", "\",", "\u0120provision", "ed", "Parameter", "File", ".", "get", "Abs", "olute", "Path", "(),", "\u0120\"", "--", "im", "ports", "\",", "\u0120imports", "Zip", ".", "get", "Abs", "olute", "Path", "());", "\u0120}", "\u0120System", ".", "out", ".", "println", "(\"", "Calling", "\u0120out", "\u0120to", "\u0120\"", "\u0120+", "\u0120LA", "UNCH", "ER", "_", "NAME", "\u0120+", "\u0120\"", "\u0120to", "\u0120run", "\u0120your", "\u0120workflow", "\");", "\u0120final", "\u0120String", "[]", "\u0120s", "\u0120=", "\u0120{", "\u0120\"", "java", "\",", "\u0120\"-", "jar", "\",", "\u0120ex", "ection", "File", ".", "get", "Abs", "olute", "Path", "(),", "\u0120\"", "run", "\"", "\u0120};", "\u0120List", "<", "String", ">", "\u0120arguments", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120arguments", ".", "add", "All", "(", "Ar", "rays", ".", "as", "List", "(", "s", "));", "\u0120arguments", ".", "add", "All", "(", "run", "Command", ");", "\u0120final", "\u0120String", "\u0120join", "\u0120=", "\u0120Jo", "iner", ".", "on", "(\"", "\u0120\"", ").", "join", "(", "arg", "uments", ");", "\u0120System", ".", "out", ".", "println", "(\"", "Exec", "uting", ":", "\u0120\"", "\u0120+", "\u0120join", ");", "\u0120return", "\u0120join", ";", "\u0120}"], "docstring_tokens": ["You", "\u0120could", "\u0120have", "\u0120LA", "UNCH", "ER", "_", "NAME", "\u0120be", "\u0120an", "\u0120abstract", "\u0120method", "\u0120in", "\u0120the", "\u0120base", "\u0120class", ",", "\u0120and", "\u0120print", "\u0120this", "\u0120message", "\u0120in", "\u0120the", "\u0120base", "\u0120class", "."]}
{"function": "public Mono<CloseableChannel> start(ConnectionAcceptor acceptor, int mtu) { Objects.requireNonNull(acceptor, \"acceptor must not be null\"); return server .handle( (request, response) -> { transportHeaders.get().forEach(response::addHeader); return response.sendWebsocket( null, Math.max(DEFAULT_FRAME_SIZE, mtu == 0 ? FRAME_MAX_SIZE : mtu), (in, out) -> { DuplexConnection connection = new WebsocketDuplexConnection((Connection) in); if (mtu > 0) { connection = new FragmentationDuplexConnection( connection, ByteBufAllocator.DEFAULT, mtu, false); } return acceptor.apply(connection).then(out.neverComplete()); }); }) .bind() .map(CloseableChannel::new); }", "text": "what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?", "function_tokens": ["public", "\u0120Mono", "<", "Close", "able", "Channel", ">", "\u0120start", "(", "Connection", "Accept", "or", "\u0120accept", "or", ",", "\u0120int", "\u0120m", "tu", ")", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "accept", "or", ",", "\u0120\"", "accept", "or", "\u0120must", "\u0120not", "\u0120be", "\u0120null", "\");", "\u0120return", "\u0120server", "\u0120.", "handle", "(", "\u0120(", "request", ",", "\u0120response", ")", "\u0120->", "\u0120{", "\u0120transport", "Head", "ers", ".", "get", "().", "for", "Each", "(", "response", "::", "add", "Header", ");", "\u0120return", "\u0120response", ".", "send", "We", "bs", "ocket", "(", "\u0120null", ",", "\u0120Math", ".", "max", "(", "DE", "FAULT", "_", "FR", "AME", "_", "SIZE", ",", "\u0120m", "tu", "\u0120==", "\u01200", "\u0120?", "\u0120FR", "AME", "_", "MAX", "_", "SIZE", "\u0120:", "\u0120m", "tu", "),", "\u0120(", "in", ",", "\u0120out", ")", "\u0120->", "\u0120{", "\u0120Dup", "lex", "Connection", "\u0120connection", "\u0120=", "\u0120new", "\u0120Webs", "ocket", "D", "up", "lex", "Connection", "((", "Connection", ")", "\u0120in", ");", "\u0120if", "\u0120(", "mt", "u", "\u0120>", "\u01200", ")", "\u0120{", "\u0120connection", "\u0120=", "\u0120new", "\u0120Frag", "mentation", "D", "up", "lex", "Connection", "(", "\u0120connection", ",", "\u0120Byte", "B", "uf", "All", "oc", "ator", ".", "DE", "FAULT", ",", "\u0120m", "tu", ",", "\u0120false", ");", "\u0120}", "\u0120return", "\u0120accept", "or", ".", "apply", "(", "connection", ").", "then", "(", "out", ".", "never", "Complete", "());", "\u0120});", "\u0120})", "\u0120.", "bind", "()", "\u0120.", "map", "(", "Close", "able", "Channel", "::", "new", ");", "\u0120}"], "docstring_tokens": ["what", "\u0120is", "\u0120this", "\u0120doing", "?", "\u0120Is", "\u0120there", "\u0120a", "\u0120reason", "\u0120we", "\u0120are", "\u0120setting", "\u0120the", "\u0120max", "\u0120frame", "\u0120size", "\u0120to", "\u0120anything", "\u0120but", "\u0120rs", "ocket", "\u0120max", "\u0120frame", "\u0120size", "?"]}
{"function": "private ClusteringModel pmmlClusteringModel(KMeansModel model, Map<Integer,Long> clusterSizesMap) { ClusteringModel clusteringModel = new ClusteringModel(AppPMMLUtils.buildMiningSchema(inputSchema), new ComparisonMeasure(ComparisonMeasure.Kind.DISTANCE) .withMeasure(new SquaredEuclidean()), MiningFunctionType.CLUSTERING, ClusteringModel.ModelClass.CENTER_BASED, model.clusterCenters().length) .withNumberOfClusters(model.k()); if (initializationStrategy.equals(KMeans.K_MEANS_PARALLEL())) { clusteringModel.setAlgorithmName(\"K-Means||\"); } else if (initializationStrategy.equals(KMeans.RANDOM())) { clusteringModel.setAlgorithmName(\"random\"); } Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { FieldName field = FieldName.create(\"field_\" + i); clusteringModel.getClusteringFields().add( new ClusteringField(field).withCompareFunction(CompareFunctionType.ABS_DIFF)); clusteringModel.getClusters().add(toCluster(clusterCenters[i], i, (int)clusterSizesMap.get(i).longValue())); } return clusteringModel; }", "text": "call intValue() and then there is no cast", "function_tokens": ["private", "\u0120Cl", "ust", "ering", "Model", "\u0120p", "mm", "l", "Cl", "ust", "ering", "Model", "(", "K", "Me", "ans", "Model", "\u0120model", ",", "\u0120Map", "<", "Integer", ",", "Long", ">", "\u0120cluster", "S", "izes", "Map", ")", "\u0120{", "\u0120Cl", "ust", "ering", "Model", "\u0120clust", "ering", "Model", "\u0120=", "\u0120new", "\u0120Cl", "ust", "ering", "Model", "(", "App", "PM", "ML", "Ut", "ils", ".", "build", "M", "ining", "Sche", "ma", "(", "input", "Sche", "ma", "),", "\u0120new", "\u0120Comparison", "Measure", "(", "Compar", "ison", "Measure", ".", "Kind", ".", "D", "IST", "ANCE", ")", "\u0120.", "with", "Measure", "(", "new", "\u0120Squ", "ared", "E", "ucl", "ide", "an", "()", "),", "\u0120Mining", "Function", "Type", ".", "CL", "UST", "ER", "ING", ",", "\u0120Cl", "ust", "ering", "Model", ".", "Model", "Class", ".", "CENT", "ER", "_", "B", "ASED", ",", "\u0120model", ".", "cl", "uster", "Cent", "ers", "().", "length", ")", "\u0120.", "with", "Number", "Of", "Cl", "usters", "(", "model", ".", "k", "());", "\u0120if", "\u0120(", "initial", "ization", "Str", "ategy", ".", "equ", "als", "(", "K", "Me", "ans", ".", "K", "_", "ME", "ANS", "_", "PAR", "AL", "LE", "L", "()", "))", "\u0120{", "\u0120clust", "ering", "Model", ".", "set", "Al", "gorithm", "Name", "(\"", "K", "-", "Me", "ans", "||", "\");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "initial", "ization", "Str", "ategy", ".", "equ", "als", "(", "K", "Me", "ans", ".", "R", "AND", "OM", "()", "))", "\u0120{", "\u0120clust", "ering", "Model", ".", "set", "Al", "gorithm", "Name", "(\"", "random", "\");", "\u0120}", "\u0120Vector", "[]", "\u0120cluster", "Cent", "ers", "\u0120=", "\u0120model", ".", "cl", "uster", "Cent", "ers", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120cluster", "Cent", "ers", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120Field", "Name", "\u0120field", "\u0120=", "\u0120Field", "Name", ".", "create", "(\"", "field", "_", "\"", "\u0120+", "\u0120i", ");", "\u0120clust", "ering", "Model", ".", "get", "Cl", "ust", "ering", "Field", "s", "().", "add", "(", "\u0120new", "\u0120Cl", "ust", "ering", "Field", "(", "field", ").", "with", "Compare", "Function", "(", "Compare", "Function", "Type", ".", "A", "BS", "_", "D", "IFF", "));", "\u0120clust", "ering", "Model", ".", "get", "Cl", "usters", "().", "add", "(", "to", "Cl", "uster", "(", "cl", "uster", "Cent", "ers", "[", "i", "],", "\u0120i", ",", "\u0120(", "int", ")", "cl", "uster", "S", "izes", "Map", ".", "get", "(", "i", ").", "long", "Value", "()", "));", "\u0120}", "\u0120return", "\u0120clust", "ering", "Model", ";", "\u0120}"], "docstring_tokens": ["call", "\u0120int", "Value", "()", "\u0120and", "\u0120then", "\u0120there", "\u0120is", "\u0120no", "\u0120cast"]}
{"function": "private List<Target> computeTargets(final ArgumentParser parser, final List<String> explicitEndpoints, final List<String> domainsArguments, final String srvName) { if (explicitEndpoints != null && !explicitEndpoints.isEmpty()) { final List<Target> targets = Lists.newArrayListWithExpectedSize(explicitEndpoints.size()); for (final String endpoint : explicitEndpoints) { targets.add(ExplicitTarget.from(URI.create(endpoint))); } return targets; } else if (domainsArguments != null && !domainsArguments.isEmpty()) { final Iterable<String> sites = parseDomains(domainsArguments); return SrvTarget.from(srvName, sites); } else if (!cliConfig.getMasterEndpoints().isEmpty()) { final List<URI> cliConfigMasterEndpoints = cliConfig.getMasterEndpoints(); List<Target> targets = Lists.newArrayListWithExpectedSize(cliConfigMasterEndpoints.size()); for (final URI endpoint : cliConfigMasterEndpoints) { targets.add(ExplicitTarget.from(endpoint)); } return targets; } else if (!cliConfig.getSitesString().isEmpty()) { final Iterable<String> sites = parseDomainsString(cliConfig.getSitesString()); return SrvTarget.from(srvName, sites); } handleError(parser, new ArgumentParserException( \"no masters specified. Use the -z or -d option to specify which helios \" + \"cluster/master to connect to\", parser)); return ImmutableList.of(); }", "text": "I think you can probably change the return type to List<? extends Target>", "function_tokens": ["private", "\u0120List", "<", "Target", ">", "\u0120compute", "T", "arg", "ets", "(", "final", "\u0120Argument", "Parser", "\u0120parser", ",", "\u0120final", "\u0120List", "<", "String", ">", "\u0120explicit", "End", "points", ",", "\u0120final", "\u0120List", "<", "String", ">", "\u0120domains", "Arg", "uments", ",", "\u0120final", "\u0120String", "\u0120sr", "v", "Name", ")", "\u0120{", "\u0120if", "\u0120(", "expl", "icit", "End", "points", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "expl", "icit", "End", "points", ".", "is", "Empty", "())", "\u0120{", "\u0120final", "\u0120List", "<", "Target", ">", "\u0120targets", "\u0120=", "\u0120Lists", ".", "new", "Array", "List", "With", "Ex", "pected", "Size", "(", "expl", "icit", "End", "points", ".", "size", "());", "\u0120for", "\u0120(", "final", "\u0120String", "\u0120endpoint", "\u0120:", "\u0120explicit", "End", "points", ")", "\u0120{", "\u0120targets", ".", "add", "(", "Expl", "icit", "Target", ".", "from", "(", "URI", ".", "create", "(", "end", "point", "))", ");", "\u0120}", "\u0120return", "\u0120targets", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "dom", "ains", "Arg", "uments", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "dom", "ains", "Arg", "uments", ".", "is", "Empty", "())", "\u0120{", "\u0120final", "\u0120Iter", "able", "<", "String", ">", "\u0120sites", "\u0120=", "\u0120parse", "Dom", "ains", "(", "dom", "ains", "Arg", "uments", ");", "\u0120return", "\u0120Sr", "v", "Target", ".", "from", "(", "sr", "v", "Name", ",", "\u0120sites", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(!", "cli", "Config", ".", "get", "Master", "End", "points", "().", "is", "Empty", "())", "\u0120{", "\u0120final", "\u0120List", "<", "URI", ">", "\u0120cl", "i", "Config", "Master", "End", "points", "\u0120=", "\u0120cl", "i", "Config", ".", "get", "Master", "End", "points", "();", "\u0120List", "<", "Target", ">", "\u0120targets", "\u0120=", "\u0120Lists", ".", "new", "Array", "List", "With", "Ex", "pected", "Size", "(", "cli", "Config", "Master", "End", "points", ".", "size", "());", "\u0120for", "\u0120(", "final", "\u0120URI", "\u0120endpoint", "\u0120:", "\u0120cl", "i", "Config", "Master", "End", "points", ")", "\u0120{", "\u0120targets", ".", "add", "(", "Expl", "icit", "Target", ".", "from", "(", "end", "point", "));", "\u0120}", "\u0120return", "\u0120targets", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(!", "cli", "Config", ".", "get", "S", "ites", "String", "().", "is", "Empty", "())", "\u0120{", "\u0120final", "\u0120Iter", "able", "<", "String", ">", "\u0120sites", "\u0120=", "\u0120parse", "Dom", "ains", "String", "(", "cli", "Config", ".", "get", "S", "ites", "String", "());", "\u0120return", "\u0120Sr", "v", "Target", ".", "from", "(", "sr", "v", "Name", ",", "\u0120sites", ");", "\u0120}", "\u0120handle", "Error", "(", "parser", ",", "\u0120new", "\u0120Argument", "Parser", "Exception", "(", "\u0120\"", "no", "\u0120masters", "\u0120specified", ".", "\u0120Use", "\u0120the", "\u0120-", "z", "\u0120or", "\u0120-", "d", "\u0120option", "\u0120to", "\u0120specify", "\u0120which", "\u0120hel", "ios", "\u0120\"", "\u0120+", "\u0120\"", "cl", "uster", "/", "master", "\u0120to", "\u0120connect", "\u0120to", "\",", "\u0120parser", "));", "\u0120return", "\u0120Imm", "utable", "List", ".", "of", "();", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120you", "\u0120can", "\u0120probably", "\u0120change", "\u0120the", "\u0120return", "\u0120type", "\u0120to", "\u0120List", "<?", "\u0120extends", "\u0120Target", ">"]}
{"function": "void processNotification(OSNotification originalNotification, @Nullable OSNotification notification) { OneSignal.onesignalLog(OneSignal.LOG_LEVEL.DEBUG, \"processNotification called from Thread: \" + Thread.currentThread().toString()); if (notification != null) { boolean display = isStringEmpty(notification.getBody()); if (!display) { notDisplayNotificationLogic(originalNotification); } else { notificationJob.setNotification(notification); NotificationBundleProcessor.processJobForDisplay(this, isBackgroundLogic); } if (isRestoring) OSUtils.sleep(100); } else { notDisplayNotificationLogic(originalNotification); } }", "text": "This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?", "function_tokens": ["void", "\u0120process", "Not", "ification", "(", "OS", "Not", "ification", "\u0120original", "Not", "ification", ",", "\u0120@", "Null", "able", "\u0120OS", "Not", "ification", "\u0120notification", ")", "\u0120{", "\u0120One", "Sign", "al", ".", "ones", "ign", "al", "Log", "(", "One", "Sign", "al", ".", "LOG", "_", "LE", "VEL", ".", "DEBUG", ",", "\u0120\"", "process", "Not", "ification", "\u0120called", "\u0120from", "\u0120Thread", ":", "\u0120\"", "\u0120+", "\u0120Thread", ".", "current", "Thread", "().", "to", "String", "());", "\u0120if", "\u0120(", "not", "ification", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120boolean", "\u0120display", "\u0120=", "\u0120is", "String", "Empty", "(", "not", "ification", ".", "get", "Body", "());", "\u0120if", "\u0120(!", "display", ")", "\u0120{", "\u0120not", "Display", "Not", "ification", "Log", "ic", "(", "original", "Not", "ification", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120notification", "Job", ".", "set", "Not", "ification", "(", "not", "ification", ");", "\u0120Notification", "B", "undle", "Process", "or", ".", "process", "Job", "For", "Display", "(", "this", ",", "\u0120is", "Background", "Log", "ic", ");", "\u0120}", "\u0120if", "\u0120(", "is", "Rest", "oring", ")", "\u0120OS", "Ut", "ils", ".", "sleep", "(", "100", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120not", "Display", "Not", "ification", "Log", "ic", "(", "original", "Not", "ification", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120passing", "\u0120is", "Background", "Log", "ic", "\u0120but", "\u0120the", "\u0120param", "\u0120name", "\u0120for", "\u0120process", "Job", "For", "Display", "\u0120is", "\u0120call", "Fore", "ground", "Log", "ic", ".", "\u0120Seems", "\u0120like", "\u0120we", "\u0120are", "\u0120flipping", "\u0120the", "\u0120logic", "\u0120here", "\u0120when", "\u0120we", "\u0120should", "\u0120not", "?", "\u0120Or", "\u0120just", "\u0120one", "\u0120of", "\u0120the", "\u0120names", "\u0120wrong", "?"]}
{"function": "public void missingMapping(RegistryEvent.MissingMappings<Item> event) { for (MissingMappings.Mapping<Item> entry : event.getAllMappings()) { if (entry.key.toString().equals(\"minecraft:totem\")) { ResourceLocation newTotem = new ResourceLocation(\"minecraft:totem_of_undying\"); entry.remap(ForgeRegistries.ITEMS.getValue(newTotem)); } if (entry.key.toString().equals(\"forge:bucketFilled\")) { ResourceLocation newBucket = new ResourceLocation(\"forge:bucket_filled\"); entry.remap(ForgeRegistries.ITEMS.getValue(newBucket)); } } }", "text": "I'm pretty sure it ends up being lower cased because the registries do not support capital letters.", "function_tokens": ["public", "\u0120void", "\u0120missing", "M", "apping", "(", "Reg", "istry", "Event", ".", "Missing", "M", "appings", "<", "Item", ">", "\u0120event", ")", "\u0120{", "\u0120for", "\u0120(", "Missing", "M", "appings", ".", "M", "apping", "<", "Item", ">", "\u0120entry", "\u0120:", "\u0120event", ".", "get", "All", "M", "appings", "())", "\u0120{", "\u0120if", "\u0120(", "entry", ".", "key", ".", "to", "String", "().", "equ", "als", "(\"", "minecraft", ":", "t", "ot", "em", "\"))", "\u0120{", "\u0120Resource", "Location", "\u0120new", "T", "ot", "em", "\u0120=", "\u0120new", "\u0120Resource", "Location", "(\"", "minecraft", ":", "t", "ot", "em", "_", "of", "_", "und", "ying", "\");", "\u0120entry", ".", "rem", "ap", "(", "Forge", "Reg", "istries", ".", "IT", "EMS", ".", "get", "Value", "(", "new", "T", "ot", "em", "));", "\u0120}", "\u0120if", "\u0120(", "entry", ".", "key", ".", "to", "String", "().", "equ", "als", "(\"", "forge", ":", "buck", "et", "F", "illed", "\"))", "\u0120{", "\u0120Resource", "Location", "\u0120new", "B", "ucket", "\u0120=", "\u0120new", "\u0120Resource", "Location", "(\"", "forge", ":", "buck", "et", "_", "filled", "\");", "\u0120entry", ".", "rem", "ap", "(", "Forge", "Reg", "istries", ".", "IT", "EMS", ".", "get", "Value", "(", "new", "B", "ucket", "));", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "'m", "\u0120pretty", "\u0120sure", "\u0120it", "\u0120ends", "\u0120up", "\u0120being", "\u0120lower", "\u0120c", "ased", "\u0120because", "\u0120the", "\u0120regist", "ries", "\u0120do", "\u0120not", "\u0120support", "\u0120capital", "\u0120letters", "."]}
{"function": "public ProductInfo updateProduct(String productId, ProductInfo pinfo) { if (productId == null) { throw new IllegalArgumentException(\"productId is null\"); } if (pinfo == null) { throw new IllegalArgumentException(\"pinfo is null\"); } ProductData pdata = this.productMap.get(productId); if (pdata == null) { throw new IllegalStateException(\"product does not exist: \" + productId); } Collection<ProductContentData> pcdata = this.resolveProductContent(pdata.getProductContent()); if (pcdata != null) { pdata.setProductContent(pcdata); } if (pinfo.getName() != null) { pdata.setName(pinfo.getName()); } if (pinfo.getMultiplier() != null) { pdata.setMultiplier(pinfo.getMultiplier()); } if (pinfo.getAttributes() != null) { pdata.setAttributes(pinfo.getAttributes()); } if (pinfo.getDependentProductIds() != null) { pdata.setDependentProductIds(pinfo.getDependentProductIds()); } if (pinfo.getBranding() != null) { pdata.setBranding(this.resolveBranding(pinfo.getBranding())); } this.updateProductContentMappings(pdata); pdata.setUpdated(new Date()); return pdata; }", "text": "Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata)", "function_tokens": ["public", "\u0120Product", "Info", "\u0120update", "Product", "(", "String", "\u0120product", "Id", ",", "\u0120Product", "Info", "\u0120pin", "fo", ")", "\u0120{", "\u0120if", "\u0120(", "product", "Id", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "product", "Id", "\u0120is", "\u0120null", "\");", "\u0120}", "\u0120if", "\u0120(", "p", "info", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "p", "info", "\u0120is", "\u0120null", "\");", "\u0120}", "\u0120Product", "Data", "\u0120p", "data", "\u0120=", "\u0120this", ".", "product", "Map", ".", "get", "(", "product", "Id", ");", "\u0120if", "\u0120(", "p", "data", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "product", "\u0120does", "\u0120not", "\u0120exist", ":", "\u0120\"", "\u0120+", "\u0120product", "Id", ");", "\u0120}", "\u0120Collection", "<", "Product", "Content", "Data", ">", "\u0120pc", "data", "\u0120=", "\u0120this", ".", "res", "olve", "Product", "Content", "(", "p", "data", ".", "get", "Product", "Content", "());", "\u0120if", "\u0120(", "pc", "data", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "Product", "Content", "(", "pc", "data", ");", "\u0120}", "\u0120if", "\u0120(", "p", "info", ".", "get", "Name", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "Name", "(", "p", "info", ".", "get", "Name", "());", "\u0120}", "\u0120if", "\u0120(", "p", "info", ".", "get", "Mult", "ipl", "ier", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "Mult", "ipl", "ier", "(", "p", "info", ".", "get", "Mult", "ipl", "ier", "());", "\u0120}", "\u0120if", "\u0120(", "p", "info", ".", "get", "Attributes", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "Attributes", "(", "p", "info", ".", "get", "Attributes", "());", "\u0120}", "\u0120if", "\u0120(", "p", "info", ".", "get", "D", "ependent", "Product", "Id", "s", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "D", "ependent", "Product", "Id", "s", "(", "p", "info", ".", "get", "D", "ependent", "Product", "Id", "s", "());", "\u0120}", "\u0120if", "\u0120(", "p", "info", ".", "get", "Br", "anding", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120p", "data", ".", "set", "Br", "anding", "(", "this", ".", "res", "olve", "Br", "anding", "(", "p", "info", ".", "get", "Br", "anding", "()", "));", "\u0120}", "\u0120this", ".", "update", "Product", "Content", "M", "appings", "(", "p", "data", ");", "\u0120p", "data", ".", "set", "Updated", "(", "new", "\u0120Date", "());", "\u0120return", "\u0120p", "data", ";", "\u0120}"], "docstring_tokens": ["Why", "\u0120is", "\u0120this", "\u0120changed", "?", "\u0120We", "\u0120want", "\u0120to", "\u0120resolve", "\u0120the", "\u0120product", "\u0120content", "\u0120on", "\u0120the", "\u0120incoming", "\u0120data", "\u0120(", "p", "info", ")", "\u0120not", "\u0120the", "\u0120existing", "\u0120product", "\u0120(", "p", "data", ")"]}
{"function": "public void injectHooks() { HookFile hookFile = fetchHookFile(); if (hookFile == null) { return; } HookParser parser = hookFile.getParser(); Injectable[] injectables = parser.getInjectables(); if (injectables == null) { return; } int index = 0; try { for (Injectable inj : injectables) { inj.inject(); index++; } } catch (NullPointerException ex) { if(!crashed) { Injectable inj = injectables[index]; int resp = UILog.alert(\"Outdated client\", \"This server currently has outdated hooks, please report it to a member of the Parabot staff/Dev Team.\\r\\n\\r\\n\" + \"Broken hook:\\r\\n\"+inj, new Object[]{\"Close\", \"Report here...\"}, JOptionPane.ERROR_MESSAGE); if(resp == 1) { URI uri = URI.create(Configuration.COMMUNITY + \"forum/135-reports/\"); try { Desktop.getDesktop().browse(uri); } catch (IOException ignore) {} } } crashed = true; throw ex; } Context.getInstance().setHookParser(parser); }", "text": "Remove /Dev Team", "function_tokens": ["public", "\u0120void", "\u0120inject", "H", "ooks", "()", "\u0120{", "\u0120Hook", "File", "\u0120hook", "File", "\u0120=", "\u0120fetch", "H", "ook", "File", "();", "\u0120if", "\u0120(", "hook", "File", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120Hook", "Parser", "\u0120parser", "\u0120=", "\u0120hook", "File", ".", "get", "Parser", "();", "\u0120In", "ject", "able", "[]", "\u0120inject", "ables", "\u0120=", "\u0120parser", ".", "get", "In", "ject", "ables", "();", "\u0120if", "\u0120(", "in", "ject", "ables", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120int", "\u0120index", "\u0120=", "\u01200", ";", "\u0120try", "\u0120{", "\u0120for", "\u0120(", "In", "ject", "able", "\u0120inj", "\u0120:", "\u0120inject", "ables", ")", "\u0120{", "\u0120inj", ".", "in", "ject", "();", "\u0120index", "++;", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Null", "Po", "inter", "Exception", "\u0120ex", ")", "\u0120{", "\u0120if", "(", "!", "cr", "ashed", ")", "\u0120{", "\u0120In", "ject", "able", "\u0120inj", "\u0120=", "\u0120inject", "ables", "[", "index", "];", "\u0120int", "\u0120resp", "\u0120=", "\u0120U", "IL", "og", ".", "alert", "(\"", "Out", "dated", "\u0120client", "\",", "\u0120\"", "This", "\u0120server", "\u0120currently", "\u0120has", "\u0120outdated", "\u0120hooks", ",", "\u0120please", "\u0120report", "\u0120it", "\u0120to", "\u0120a", "\u0120member", "\u0120of", "\u0120the", "\u0120Par", "ab", "ot", "\u0120staff", "/", "Dev", "\u0120Team", ".", "\\", "r", "\\", "n", "\\", "r", "\\", "n", "\"", "\u0120+", "\u0120\"", "Bro", "ken", "\u0120hook", ":\\", "r", "\\", "n", "\"", "+", "in", "j", ",", "\u0120new", "\u0120Object", "[]", "{\"", "Close", "\",", "\u0120\"", "Report", "\u0120here", "...\"", "},", "\u0120J", "Option", "P", "ane", ".", "ERROR", "_", "M", "ES", "SA", "GE", ");", "\u0120if", "(", "resp", "\u0120==", "\u01201", ")", "\u0120{", "\u0120URI", "\u0120ur", "i", "\u0120=", "\u0120URI", ".", "create", "(", "Configuration", ".", "COM", "M", "UN", "ITY", "\u0120+", "\u0120\"", "forum", "/", "135", "-", "reports", "/", "\");", "\u0120try", "\u0120{", "\u0120Desktop", ".", "get", "Desktop", "().", "brow", "se", "(", "uri", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120ignore", ")", "\u0120{}", "\u0120}", "\u0120}", "\u0120crashed", "\u0120=", "\u0120true", ";", "\u0120throw", "\u0120ex", ";", "\u0120}", "\u0120Context", ".", "get", "Instance", "().", "set", "H", "ook", "Parser", "(", "parser", ");", "\u0120}"], "docstring_tokens": ["Remove", "\u0120/", "Dev", "\u0120Team"]}
{"function": "public void execute(TupleWindow inputWindow) { for (Tuple tuple : inputWindow.get()) { sum += tuple.getLongByField(\"value\"); } state.put(\"sum\", sum); collector.emit(new Values(sum)); }", "text": "You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode", "function_tokens": ["public", "\u0120void", "\u0120execute", "(", "T", "uple", "Window", "\u0120input", "Window", ")", "\u0120{", "\u0120for", "\u0120(", "T", "uple", "\u0120tuple", "\u0120:", "\u0120input", "Window", ".", "get", "())", "\u0120{", "\u0120sum", "\u0120+=", "\u0120tuple", ".", "get", "Long", "By", "Field", "(\"", "value", "\");", "\u0120}", "\u0120state", ".", "put", "(\"", "sum", "\",", "\u0120sum", ");", "\u0120collector", ".", "em", "it", "(", "new", "\u0120Values", "(", "sum", "));", "\u0120}"], "docstring_tokens": ["You", "\u0120could", "\u0120move", "\u0120this", "\u0120line", "\u0120to", "\u0120pre", "Save", ".", "\u0120That", "\u0120way", "\u0120the", "\u0120top", "oli", "ogy", "\u0120can", "\u0120be", "\u0120used", "\u0120both", "\u0120in", "\u0120effectively", "\u0120once", "\u0120as", "\u0120well", "\u0120as", "\u0120at", "le", "ast", "/", "at", "most", "\u0120once", "\u0120mode"]}
{"function": "private CDPStructuredNotificationDetails getNotificationDetails(ResourceEvent resourceEvent, String resourceCrn, String resourceType, Object payload) { String serializedPayload; try { serializedPayload = new Gson().toJson(payload); LOGGER.debug(\"CDPStructuredNotificationDetails' payload has been serialized with ResourceEvent[{}], resource type[{}], CRN[{}]\", resourceEvent.name(), resourceType, resourceCrn); } catch (RuntimeException re) { String msg = String.format(\"CDPStructuredNotificationDetails' payload couldn't be serialized with ResourceEvent[%s], resource type[%s], CRN[%s]\", resourceEvent.name(), resourceType, resourceCrn); LOGGER.warn(msg, re); serializedPayload = msg; } return new CDPStructuredNotificationDetails(resourceEvent, resourceCrn, resourceType, serializedPayload); }", "text": "I see no reason to introduce msg here, you could just use serializedPayload", "function_tokens": ["private", "\u0120C", "DP", "Struct", "ured", "Not", "ification", "Details", "\u0120get", "Not", "ification", "Details", "(", "Resource", "Event", "\u0120resource", "Event", ",", "\u0120String", "\u0120resource", "Cr", "n", ",", "\u0120String", "\u0120resource", "Type", ",", "\u0120Object", "\u0120payload", ")", "\u0120{", "\u0120String", "\u0120serial", "ized", "Pay", "load", ";", "\u0120try", "\u0120{", "\u0120serial", "ized", "Pay", "load", "\u0120=", "\u0120new", "\u0120G", "son", "().", "to", "J", "son", "(", "pay", "load", ");", "\u0120LOG", "GER", ".", "debug", "(\"", "C", "DP", "Struct", "ured", "Not", "ification", "Details", "'", "\u0120payload", "\u0120has", "\u0120been", "\u0120serial", "ized", "\u0120with", "\u0120Resource", "Event", "[", "{", "}", "],", "\u0120resource", "\u0120type", "[", "{", "}", "],", "\u0120CR", "N", "[", "{", "}", "]", "\",", "\u0120resource", "Event", ".", "name", "(),", "\u0120resource", "Type", ",", "\u0120resource", "Cr", "n", ");", "\u0120}", "\u0120catch", "\u0120(", "Runtime", "Exception", "\u0120re", ")", "\u0120{", "\u0120String", "\u0120msg", "\u0120=", "\u0120String", ".", "format", "(\"", "C", "DP", "Struct", "ured", "Not", "ification", "Details", "'", "\u0120payload", "\u0120couldn", "'t", "\u0120be", "\u0120serial", "ized", "\u0120with", "\u0120Resource", "Event", "[", "%", "s", "],", "\u0120resource", "\u0120type", "[", "%", "s", "],", "\u0120CR", "N", "[", "%", "s", "]", "\",", "\u0120resource", "Event", ".", "name", "(),", "\u0120resource", "Type", ",", "\u0120resource", "Cr", "n", ");", "\u0120LOG", "GER", ".", "warn", "(", "msg", ",", "\u0120re", ");", "\u0120serial", "ized", "Pay", "load", "\u0120=", "\u0120msg", ";", "\u0120}", "\u0120return", "\u0120new", "\u0120C", "DP", "Struct", "ured", "Not", "ification", "Details", "(", "resource", "Event", ",", "\u0120resource", "Cr", "n", ",", "\u0120resource", "Type", ",", "\u0120serial", "ized", "Pay", "load", ");", "\u0120}"], "docstring_tokens": ["I", "\u0120see", "\u0120no", "\u0120reason", "\u0120to", "\u0120introduce", "\u0120msg", "\u0120here", ",", "\u0120you", "\u0120could", "\u0120just", "\u0120use", "\u0120serial", "ized", "Pay", "load"]}
{"function": "public static Map<String, String> getInputFiles(String descriptorAbsolutePath) { WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, \"Problem parsing WDL file: \" + ex.getMessage(), API_ERROR); } return wdlInputs; }", "text": "Put the test in the same package (not directory) and you can at least use package private or protected", "function_tokens": ["public", "\u0120static", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120get", "Input", "Files", "(", "String", "\u0120descriptor", "Abs", "olute", "Path", ")", "\u0120{", "\u0120W", "dl", "Bridge", "\u0120w", "dl", "Bridge", "\u0120=", "\u0120new", "\u0120W", "dl", "Bridge", "();", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120w", "dl", "Input", "s", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120w", "dl", "Input", "s", "\u0120=", "\u0120w", "dl", "Bridge", ".", "get", "Input", "Files", "(", "desc", "ript", "or", "Abs", "olute", "Path", ");", "\u0120}", "\u0120catch", "\u0120(", "W", "dl", "Parser", ".", "Sy", "ntax", "Error", "\u0120ex", ")", "\u0120{", "\u0120exception", "Message", "(", "ex", ",", "\u0120\"", "Problem", "\u0120parsing", "\u0120W", "DL", "\u0120file", ":", "\u0120\"", "\u0120+", "\u0120ex", ".", "get", "Message", "(),", "\u0120API", "_", "ERROR", ");", "\u0120}", "\u0120return", "\u0120w", "dl", "Input", "s", ";", "\u0120}"], "docstring_tokens": ["Put", "\u0120the", "\u0120test", "\u0120in", "\u0120the", "\u0120same", "\u0120package", "\u0120(", "not", "\u0120directory", ")", "\u0120and", "\u0120you", "\u0120can", "\u0120at", "\u0120least", "\u0120use", "\u0120package", "\u0120private", "\u0120or", "\u0120protected"]}
{"function": "public List<Timeline> listTimelines(final String eventType) { return jdbcTemplate.query( BASE_TIMELINE_QUERY + \" WHERE t.et_name=? order by t.t_order\", new Object[]{eventType}, timelineRowMapper); }", "text": "a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.", "function_tokens": ["public", "\u0120List", "<", "Tim", "eline", ">", "\u0120list", "Tim", "elines", "(", "final", "\u0120String", "\u0120event", "Type", ")", "\u0120{", "\u0120return", "\u0120j", "db", "c", "Template", ".", "query", "(", "\u0120BASE", "_", "T", "IM", "EL", "INE", "_", "QU", "ERY", "\u0120+", "\u0120\"", "\u0120WHERE", "\u0120t", ".", "et", "_", "name", "=", "?", "\u0120order", "\u0120by", "\u0120t", ".", "t", "_", "order", "\",", "\u0120new", "\u0120Object", "[]", "{", "event", "Type", "},", "\u0120timeline", "Row", "M", "apper", ");", "\u0120}"], "docstring_tokens": ["a", "\u0120very", "\u0120small", "\u0120imp", "ove", "ment", ",", "\u0120but", "\u0120you", "\u0120can", "\u0120use", "\u0120the", "\u0120method", "\u0120notation", "\u0120when", "\u0120the", "\u0120m", "apper", "\u0120is", "\u0120on", "\u0120second", "\u0120place", "\u0120and", "\u0120params", "\u0120var", "arg", "\u0120is", "\u0120on", "\u01203", "rd", "\u0120place", ".", "\u0120That", "\u0120will", "\u0120allow", "\u0120to", "\u0120pass", "\u0120event", "Type", "\u0120without", "\u0120creation", "\u0120of", "\u0120array", "."]}
{"function": "public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, \"filter\"); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }", "text": "suggestion Objects.requireNonNull(filter, \"filter cannot be null\");", "function_tokens": ["public", "\u0120static", "\u0120List", "<", "Block", "Meta", "Data", ">", "\u0120filter", "Row", "G", "roups", "(", "List", "<", "Filter", "Level", ">", "\u0120levels", ",", "\u0120Filter", "\u0120filter", ",", "\u0120List", "<", "Block", "Meta", "Data", ">", "\u0120blocks", ",", "\u0120Par", "quet", "File", "Reader", "\u0120reader", ")", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "filter", ",", "\u0120\"", "filter", "\");", "\u0120return", "\u0120filter", ".", "accept", "(", "new", "\u0120Row", "Group", "Filter", "(", "levels", ",", "\u0120blocks", ",", "\u0120reader", "));", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120Objects", ".", "require", "Non", "Null", "(", "filter", ",", "\u0120\"", "filter", "\u0120cannot", "\u0120be", "\u0120null", "\");"]}
{"function": "private void write(Object msg, boolean flush, ChannelPromise promise) { final AbstractChannelHandlerContext next; if (flush) { AbstractChannelHandlerContext ctx = this; do { ctx = ctx.prev; } while ((ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0); next = ctx; } else { next = findContextOutbound(MASK_WRITE); } final Object m = pipeline.touch(msg, next); EventExecutor executor = next.executor(); if (executor.inEventLoop()) { if (flush) { next.invokeWriteAndFlush(m, promise); } else { next.invokeWrite(m, promise); } } else { final AbstractWriteTask task; if (flush) { task = WriteAndFlushTask.newInstance(next, m, promise); } else { task = WriteTask.newInstance(next, m, promise); } if (!safeExecute(executor, task, promise, m)) { task.cancel(); } } }", "text": "Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0", "function_tokens": ["private", "\u0120void", "\u0120write", "(", "Object", "\u0120msg", ",", "\u0120boolean", "\u0120flush", ",", "\u0120Channel", "Prom", "ise", "\u0120promise", ")", "\u0120{", "\u0120final", "\u0120Abstract", "Channel", "Handler", "Context", "\u0120next", ";", "\u0120if", "\u0120(", "flush", ")", "\u0120{", "\u0120Abstract", "Channel", "Handler", "Context", "\u0120c", "tx", "\u0120=", "\u0120this", ";", "\u0120do", "\u0120{", "\u0120c", "tx", "\u0120=", "\u0120c", "tx", ".", "prev", ";", "\u0120}", "\u0120while", "\u0120((", "ctx", ".", "exec", "ution", "Mask", "\u0120&", "\u0120MAS", "K", "_", "WR", "ITE", ")", "\u0120==", "\u01200", "\u0120&&", "\u0120(", "ctx", ".", "exec", "ution", "Mask", "\u0120&", "\u0120MAS", "K", "_", "FL", "USH", ")", "\u0120==", "\u01200", ");", "\u0120next", "\u0120=", "\u0120c", "tx", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120next", "\u0120=", "\u0120find", "Context", "Out", "bound", "(", "MAS", "K", "_", "WR", "ITE", ");", "\u0120}", "\u0120final", "\u0120Object", "\u0120m", "\u0120=", "\u0120pipeline", ".", "touch", "(", "msg", ",", "\u0120next", ");", "\u0120Event", "Exec", "utor", "\u0120execut", "or", "\u0120=", "\u0120next", ".", "exec", "utor", "();", "\u0120if", "\u0120(", "exec", "utor", ".", "in", "Event", "Loop", "())", "\u0120{", "\u0120if", "\u0120(", "flush", ")", "\u0120{", "\u0120next", ".", "invoke", "Write", "And", "Fl", "ush", "(", "m", ",", "\u0120promise", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120next", ".", "invoke", "Write", "(", "m", ",", "\u0120promise", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120final", "\u0120Abstract", "Write", "Task", "\u0120task", ";", "\u0120if", "\u0120(", "flush", ")", "\u0120{", "\u0120task", "\u0120=", "\u0120Write", "And", "Fl", "ush", "Task", ".", "new", "Instance", "(", "next", ",", "\u0120m", ",", "\u0120promise", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120task", "\u0120=", "\u0120Write", "Task", ".", "new", "Instance", "(", "next", ",", "\u0120m", ",", "\u0120promise", ");", "\u0120}", "\u0120if", "\u0120(!", "safe", "Exec", "ute", "(", "exec", "utor", ",", "\u0120task", ",", "\u0120promise", ",", "\u0120m", "))", "\u0120{", "\u0120task", ".", "c", "ancel", "();", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Isn", "'t", "\u0120(", "ctx", ".", "exec", "ution", "Mask", "\u0120&", "\u0120MAS", "K", "_", "WR", "ITE", ")", "\u0120==", "\u01200", "\u0120&&", "\u0120(", "ctx", ".", "exec", "ution", "Mask", "\u0120&", "\u0120MAS", "K", "_", "FL", "USH", ")", "\u0120==", "\u01200", "\u0120the", "\u0120same", "\u0120as", ":", "\u0120(", "ctx", ".", "exec", "ution", "Mask", "\u0120&", "\u0120(", "MAS", "K", "_", "WR", "ITE", "|", "MAS", "K", "_", "FL", "USH", "))", "\u0120==", "\u01200"]}
{"function": "public void serialize_test() { Note note = new Note() .setAuthor(HARDCODED_AUTHOR) .setDate(HARDCODED_DATE) .setUserIdsToNotify(Arrays.asList(HARDCODED_USER_IDS)) .setId(HARDCODED_ID) .setContactId(HARDCODED_CONTACT_ID) .setLinkedDealId(HARDCODED_LINKED_ID) .setModifiedAt(HARDCODED_MODIFY_DATE) .setCreatedAt(HARDCODED_CREATE_DATE); String json = NoteSerializer.toJsonObject(note); try { Note parsedNote = NoteSerializer.fromString(json); assertEquals(HARDCODED_AUTHOR, parsedNote.getAuthor()); assertEquals(HARDCODED_CONTACT_ID, parsedNote.getContactId()); assertEquals(HARDCODED_DATE, parsedNote.getDate()); assertEquals(HARDCODED_MODIFY_DATE, parsedNote.getModifiedAt()); assertEquals(HARDCODED_CREATE_DATE, parsedNote.getCreatedAt()); assertEquals(HARDCODED_ID, parsedNote.getId()); List<String> parsedUserIds = parsedNote.getUserIdsToNotify(); List<String> originalUserIds = Arrays.asList(HARDCODED_USER_IDS); assertTrue( parsedUserIds.containsAll(originalUserIds) && originalUserIds.containsAll(parsedUserIds)); } catch (OnePageException e) { e.printStackTrace(); } }", "text": "@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail()", "function_tokens": ["public", "\u0120void", "\u0120serial", "ize", "_", "test", "()", "\u0120{", "\u0120Note", "\u0120note", "\u0120=", "\u0120new", "\u0120Note", "()", "\u0120.", "set", "Author", "(", "H", "AR", "DC", "OD", "ED", "_", "A", "UTH", "OR", ")", "\u0120.", "set", "Date", "(", "H", "AR", "DC", "OD", "ED", "_", "D", "ATE", ")", "\u0120.", "set", "User", "Id", "s", "To", "Not", "ify", "(", "Ar", "rays", ".", "as", "List", "(", "H", "AR", "DC", "OD", "ED", "_", "USER", "_", "IDS", "))", "\u0120.", "set", "Id", "(", "H", "AR", "DC", "OD", "ED", "_", "ID", ")", "\u0120.", "set", "Contact", "Id", "(", "H", "AR", "DC", "OD", "ED", "_", "CONT", "ACT", "_", "ID", ")", "\u0120.", "set", "Link", "ed", "Deal", "Id", "(", "H", "AR", "DC", "OD", "ED", "_", "L", "INK", "ED", "_", "ID", ")", "\u0120.", "set", "Mod", "ified", "At", "(", "H", "AR", "DC", "OD", "ED", "_", "MOD", "IF", "Y", "_", "D", "ATE", ")", "\u0120.", "set", "Created", "At", "(", "H", "AR", "DC", "OD", "ED", "_", "CRE", "ATE", "_", "D", "ATE", ");", "\u0120String", "\u0120json", "\u0120=", "\u0120Note", "Serial", "izer", ".", "to", "J", "son", "Object", "(", "note", ");", "\u0120try", "\u0120{", "\u0120Note", "\u0120parsed", "Note", "\u0120=", "\u0120Note", "Serial", "izer", ".", "from", "String", "(", "json", ");", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "A", "UTH", "OR", ",", "\u0120parsed", "Note", ".", "get", "Author", "());", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "CONT", "ACT", "_", "ID", ",", "\u0120parsed", "Note", ".", "get", "Contact", "Id", "());", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "D", "ATE", ",", "\u0120parsed", "Note", ".", "get", "Date", "());", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "MOD", "IF", "Y", "_", "D", "ATE", ",", "\u0120parsed", "Note", ".", "get", "Mod", "ified", "At", "());", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "CRE", "ATE", "_", "D", "ATE", ",", "\u0120parsed", "Note", ".", "get", "Created", "At", "());", "\u0120assert", "Equ", "als", "(", "H", "AR", "DC", "OD", "ED", "_", "ID", ",", "\u0120parsed", "Note", ".", "get", "Id", "());", "\u0120List", "<", "String", ">", "\u0120parsed", "User", "Id", "s", "\u0120=", "\u0120parsed", "Note", ".", "get", "User", "Id", "s", "To", "Not", "ify", "();", "\u0120List", "<", "String", ">", "\u0120original", "User", "Id", "s", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(", "H", "AR", "DC", "OD", "ED", "_", "USER", "_", "IDS", ");", "\u0120assert", "True", "(", "\u0120parsed", "User", "Id", "s", ".", "cont", "ains", "All", "(", "original", "User", "Id", "s", ")", "\u0120&&", "\u0120original", "User", "Id", "s", ".", "cont", "ains", "All", "(", "p", "ars", "ed", "User", "Id", "s", "));", "\u0120}", "\u0120catch", "\u0120(", "One", "Page", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["@", "fr", "agg", "j", "kee", "\u0120Would", "\u0120recommend", "\u0120to", "\u0120put", "\u0120something", "\u0120to", "\u0120make", "\u0120test", "\u0120fail", "\u0120if", "\u0120inside", "\u0120the", "\u0120catch", "\u0120block", ".", "\u0120Because", "\u0120right", "\u0120now", "\u0120the", "\u0120test", "\u0120will", "\u0120still", "\u0120pass", "\u0120even", "\u0120if", "\u0120parsing", "\u0120completely", "\u0120fails", "\u0120(", "line", "\u012043", ").", "\u0120After", "\u0120a", "\u0120quick", "\u0120look", "\u0120I", "\u0120found", "\u0120the", "\u0120following", "\u0120method", "\u0120to", "\u0120do", "\u0120the", "\u0120trick", ":", "\u0120jun", "it", ".", "framework", ".", "Ass", "ert", "#", "fail", "()"]}
{"function": "public Owner updateOwner(@PathParam(\"owner_key\") @Verify(Owner.class) String key, @ApiParam(name = \"owner\", required = true) Owner owner) { Owner toUpdate = findOwner(key); EventBuilder eventBuilder = eventFactory.getEventBuilder(Target.OWNER, Type.MODIFIED) .setOldEntity(toUpdate); log.debug(\"Updating owner: {}\", key); if (owner.getDisplayName() != null) { toUpdate.setDisplayName(owner.getDisplayName()); } if (owner.getParentOwner() != null) { toUpdate.setParentOwner(owner.getParentOwner()); } if (owner.getDefaultServiceLevel() != null) { if (owner.getDefaultServiceLevel().equals(\"\")) { toUpdate.setDefaultServiceLevel(null); } else { serviceLevelValidator.validate(toUpdate, owner.getDefaultServiceLevel()); toUpdate.setDefaultServiceLevel(owner.getDefaultServiceLevel()); } } if (owner.getAutobindDisabled() != null) { toUpdate.setAutobindDisabled(owner.getAutobindDisabled()); } if (config.getBoolean(ConfigProperties.STANDALONE) && !toUpdate.getContentAccessMode().equals(owner.getContentAccessMode()) && owner.getContentAccessMode() != null) { throw new BadRequestException( i18n.tr(\"The owner content access mode cannot be set directly in standalone mode.\")); } boolean refreshContentAccess = false; if (owner.getContentAccessMode() != null) { if (toUpdate.isAllowedContentAccessMode(owner.getContentAccessMode())) { String before = toUpdate.getContentAccessMode(); String after = owner.getContentAccessMode(); if (!after.equals(before)) { toUpdate.setContentAccessMode(owner.getContentAccessMode()); refreshContentAccess = true; } } else { throw new BadRequestException( i18n.tr(\"The content access mode is not allowed for this owner.\")); } } ownerCurator.merge(toUpdate); ownerCurator.flush(); if (refreshContentAccess) { ownerManager.refreshOwnerForContentAccess(toUpdate); } Event e = eventBuilder.setNewEntity(toUpdate).buildEvent(); sink.queueEvent(e); return toUpdate; }", "text": "Need a null check here.", "function_tokens": ["public", "\u0120Owner", "\u0120update", "Owner", "(", "@", "Path", "Param", "(\"", "owner", "_", "key", "\")", "\u0120@", "Ver", "ify", "(", "Owner", ".", "class", ")", "\u0120String", "\u0120key", ",", "\u0120@", "A", "pi", "Param", "(", "name", "\u0120=", "\u0120\"", "owner", "\",", "\u0120required", "\u0120=", "\u0120true", ")", "\u0120Owner", "\u0120owner", ")", "\u0120{", "\u0120Owner", "\u0120to", "Update", "\u0120=", "\u0120find", "Owner", "(", "key", ");", "\u0120Event", "Builder", "\u0120event", "Builder", "\u0120=", "\u0120event", "Factory", ".", "get", "Event", "Builder", "(", "Target", ".", "OWN", "ER", ",", "\u0120Type", ".", "MOD", "IFIED", ")", "\u0120.", "set", "Old", "Entity", "(", "to", "Update", ");", "\u0120log", ".", "debug", "(\"", "Up", "dating", "\u0120owner", ":", "\u0120{}", "\",", "\u0120key", ");", "\u0120if", "\u0120(", "owner", ".", "get", "Display", "Name", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120to", "Update", ".", "set", "Display", "Name", "(", "owner", ".", "get", "Display", "Name", "());", "\u0120}", "\u0120if", "\u0120(", "owner", ".", "get", "Parent", "Owner", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120to", "Update", ".", "set", "Parent", "Owner", "(", "owner", ".", "get", "Parent", "Owner", "());", "\u0120}", "\u0120if", "\u0120(", "owner", ".", "get", "Default", "Service", "Level", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "owner", ".", "get", "Default", "Service", "Level", "().", "equ", "als", "(\"", "\"))", "\u0120{", "\u0120to", "Update", ".", "set", "Default", "Service", "Level", "(", "null", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120service", "Level", "Valid", "ator", ".", "valid", "ate", "(", "to", "Update", ",", "\u0120owner", ".", "get", "Default", "Service", "Level", "());", "\u0120to", "Update", ".", "set", "Default", "Service", "Level", "(", "owner", ".", "get", "Default", "Service", "Level", "());", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "owner", ".", "get", "Aut", "ob", "ind", "Dis", "abled", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120to", "Update", ".", "set", "Aut", "ob", "ind", "Dis", "abled", "(", "owner", ".", "get", "Aut", "ob", "ind", "Dis", "abled", "());", "\u0120}", "\u0120if", "\u0120(", "config", ".", "get", "Boo", "lean", "(", "Config", "Pro", "perties", ".", "ST", "AND", "AL", "ONE", ")", "\u0120&&", "\u0120!", "to", "Update", ".", "get", "Content", "Access", "Mode", "().", "equ", "als", "(", "owner", ".", "get", "Content", "Access", "Mode", "())", "\u0120&&", "\u0120owner", ".", "get", "Content", "Access", "Mode", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Bad", "Request", "Exception", "(", "\u0120i", "18", "n", ".", "tr", "(\"", "The", "\u0120owner", "\u0120content", "\u0120access", "\u0120mode", "\u0120cannot", "\u0120be", "\u0120set", "\u0120directly", "\u0120in", "\u0120standalone", "\u0120mode", ".\"", "));", "\u0120}", "\u0120boolean", "\u0120refresh", "Content", "Access", "\u0120=", "\u0120false", ";", "\u0120if", "\u0120(", "owner", ".", "get", "Content", "Access", "Mode", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "to", "Update", ".", "is", "All", "owed", "Content", "Access", "Mode", "(", "owner", ".", "get", "Content", "Access", "Mode", "()", "))", "\u0120{", "\u0120String", "\u0120before", "\u0120=", "\u0120to", "Update", ".", "get", "Content", "Access", "Mode", "();", "\u0120String", "\u0120after", "\u0120=", "\u0120owner", ".", "get", "Content", "Access", "Mode", "();", "\u0120if", "\u0120(!", "after", ".", "equ", "als", "(", "before", "))", "\u0120{", "\u0120to", "Update", ".", "set", "Content", "Access", "Mode", "(", "owner", ".", "get", "Content", "Access", "Mode", "());", "\u0120refresh", "Content", "Access", "\u0120=", "\u0120true", ";", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Bad", "Request", "Exception", "(", "\u0120i", "18", "n", ".", "tr", "(\"", "The", "\u0120content", "\u0120access", "\u0120mode", "\u0120is", "\u0120not", "\u0120allowed", "\u0120for", "\u0120this", "\u0120owner", ".\"", "));", "\u0120}", "\u0120}", "\u0120owner", "Cur", "ator", ".", "mer", "ge", "(", "to", "Update", ");", "\u0120owner", "Cur", "ator", ".", "flush", "();", "\u0120if", "\u0120(", "ref", "resh", "Content", "Access", ")", "\u0120{", "\u0120owner", "Manager", ".", "ref", "resh", "Owner", "For", "Content", "Access", "(", "to", "Update", ");", "\u0120}", "\u0120Event", "\u0120e", "\u0120=", "\u0120event", "Builder", ".", "set", "New", "Entity", "(", "to", "Update", ").", "build", "Event", "();", "\u0120sink", ".", "queue", "Event", "(", "e", ");", "\u0120return", "\u0120to", "Update", ";", "\u0120}"], "docstring_tokens": ["Need", "\u0120a", "\u0120null", "\u0120check", "\u0120here", "."]}
{"function": "public void testAcquireLockWithLockNotAvailableException() { JedisOps ops = mock(JedisOps.class); when(ops.setnx(eq(\"key\"), anyString())).thenReturn(0L); when(ops.ttl(\"key\")).thenReturn(30L); RedisLock lock = new RedisLock(ops); try { lock.acquireLock(\"key\", 10); } catch (LockNotAvailableException e) { assertTrue(\"LockNotAvailableException expected\", true); } InOrder inOrder = inOrder(ops); inOrder.verify(ops, times(1)).setnx(eq(\"key\"), anyString()); inOrder.verify(ops, times(1)).expire(\"key\", 10); }", "text": "This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock(\"key\", 10); fail(\"expected exception\"); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock(\"key\", 10); fail(\"expected exception\"); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.", "function_tokens": ["public", "\u0120void", "\u0120test", "Ac", "quire", "Lock", "With", "Lock", "Not", "Available", "Exception", "()", "\u0120{", "\u0120Jed", "is", "Ops", "\u0120ops", "\u0120=", "\u0120mock", "(", "J", "ed", "is", "Ops", ".", "class", ");", "\u0120when", "(", "ops", ".", "set", "n", "x", "(", "eq", "(\"", "key", "\"),", "\u0120any", "String", "())", ").", "then", "Return", "(", "0", "L", ");", "\u0120when", "(", "ops", ".", "tt", "l", "(\"", "key", "\")", ").", "then", "Return", "(", "30", "L", ");", "\u0120Red", "is", "Lock", "\u0120lock", "\u0120=", "\u0120new", "\u0120Red", "is", "Lock", "(", "ops", ");", "\u0120try", "\u0120{", "\u0120lock", ".", "ac", "quire", "Lock", "(\"", "key", "\",", "\u012010", ");", "\u0120}", "\u0120catch", "\u0120(", "Lock", "Not", "Available", "Exception", "\u0120e", ")", "\u0120{", "\u0120assert", "True", "(\"", "Lock", "Not", "Available", "Exception", "\u0120expected", "\",", "\u0120true", ");", "\u0120}", "\u0120In", "Order", "\u0120in", "Order", "\u0120=", "\u0120in", "Order", "(", "ops", ");", "\u0120in", "Order", ".", "ver", "ify", "(", "ops", ",", "\u0120times", "(", "1", ")).", "set", "n", "x", "(", "eq", "(\"", "key", "\"),", "\u0120any", "String", "());", "\u0120in", "Order", ".", "ver", "ify", "(", "ops", ",", "\u0120times", "(", "1", ")).", "ex", "pire", "(\"", "key", "\",", "\u012010", ");", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120actually", "\u0120not", "\u0120an", "\u0120effective", "\u0120way", "\u0120to", "\u0120test", "\u0120that", "\u0120the", "\u0120exception", "\u0120is", "\u0120thrown", ".", "\u0120If", "\u0120the", "\u0120exception", "\u0120is", "\u0120not", "\u0120thrown", ",", "\u0120the", "\u0120catch", "\u0120block", "\u0120is", "\u0120never", "\u0120executed", ",", "\u0120so", "\u0120the", "\u0120assert", "True", "()", "\u0120will", "\u0120never", "\u0120fire", ".", "\u0120You", "\u0120should", "\u0120instead", "\u0120use", "\u0120a", "\u0120pattern", "\u0120like", "\u0120try", "\u0120{", "\u0120lock", ".", "ac", "quire", "Lock", "(\"", "key", "\",", "\u012010", ");", "\u0120fail", "(\"", "expected", "\u0120exception", "\");", "\u0120}", "\u0120catch", "\u0120(", "Lock", "Not", "Available", "Exception", "\u0120e", ")", "\u0120{", "\u0120//", "\u0120stuff", "\u0120}", "\u0120I", "\u0120frequently", "\u0120like", "\u0120to", "\u0120extend", "\u0120this", "\u0120to", "\u0120Exception", "\u0120thrown", "Ex", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120lock", ".", "ac", "quire", "Lock", "(\"", "key", "\",", "\u012010", ");", "\u0120fail", "(\"", "expected", "\u0120exception", "\");", "\u0120}", "\u0120catch", "\u0120(", "Lock", "Not", "Available", "Exception", "\u0120e", ")", "\u0120{", "\u0120thrown", "Ex", "\u0120=", "\u0120e", ";", "\u0120}", "\u0120assert", "Not", "Null", "(", "th", "rown", "Ex", ")", "\u0120as", "\u0120a", "\u0120double", "-", "check", "\u0120that", "\u0120we", "\u0120did", "\u0120indeed", "\u0120throw", "\u0120an", "\u0120exception", "."]}
{"function": "public List<DataType> all() { return new ArrayList<>(dataTypes.values()); }", "text": "as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); }", "function_tokens": ["public", "\u0120List", "<", "Data", "Type", ">", "\u0120all", "()", "\u0120{", "\u0120return", "\u0120new", "\u0120Array", "List", "<", ">(", "data", "Types", ".", "values", "());", "\u0120}"], "docstring_tokens": ["as", "\u0120the", "\u0120all", "()", "\u0120is", "\u0120used", "\u0120just", "\u0120internally", "\u0120I", "\u0120think", "\u0120we", "\u0120can", "\u0120rewrite", "\u0120it", "\u0120as", ":", "\u0120java", "\u0120public", "\u0120Collection", "<", "Data", "Type", ">", "\u0120all", "()", "\u0120{", "\u0120return", "\u0120data", "Types", ".", "values", "();", "\u0120}"]}
{"function": "private void startSequencesAtBeginning(TopicPartition topicPartition, ProducerIdAndEpoch newProducerIdAndEpoch) { final PrimitiveRef.IntRef sequence = PrimitiveRef.ofInt(0); getPartition(topicPartition).resetSequenceNumbers(inFlightBatch -> { inFlightBatch.resetProducerState(newProducerIdAndEpoch, sequence.value, inFlightBatch.isTransactional()); sequence.value += inFlightBatch.recordCount; }); getPartition(topicPartition).nextSequence = sequence.value; getPartition(topicPartition).lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER; }", "text": "nit: maybe we can save the result of getPartition(topicPartition)", "function_tokens": ["private", "\u0120void", "\u0120start", "Sequ", "ences", "At", "Beginning", "(", "Topic", "Part", "ition", "\u0120topic", "Part", "ition", ",", "\u0120Producer", "Id", "And", "Ep", "och", "\u0120new", "Produ", "cer", "Id", "And", "Ep", "och", ")", "\u0120{", "\u0120final", "\u0120Prim", "itive", "Ref", ".", "Int", "Ref", "\u0120sequence", "\u0120=", "\u0120Prim", "itive", "Ref", ".", "of", "Int", "(", "0", ");", "\u0120get", "Part", "ition", "(", "topic", "Part", "ition", ").", "reset", "Sequ", "ence", "Numbers", "(", "in", "Flight", "B", "atch", "\u0120->", "\u0120{", "\u0120in", "Flight", "B", "atch", ".", "reset", "Produ", "cer", "State", "(", "new", "Produ", "cer", "Id", "And", "Ep", "och", ",", "\u0120sequence", ".", "value", ",", "\u0120in", "Flight", "B", "atch", ".", "is", "Trans", "act", "ional", "());", "\u0120sequence", ".", "value", "\u0120+=", "\u0120in", "Flight", "B", "atch", ".", "record", "Count", ";", "\u0120});", "\u0120get", "Part", "ition", "(", "topic", "Part", "ition", ").", "next", "Sequ", "ence", "\u0120=", "\u0120sequence", ".", "value", ";", "\u0120get", "Part", "ition", "(", "topic", "Part", "ition", ").", "last", "A", "ck", "ed", "Sequ", "ence", "\u0120=", "\u0120NO", "_", "L", "AST", "_", "ACK", "ED", "_", "SE", "QU", "ENCE", "_", "NUM", "BER", ";", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120maybe", "\u0120we", "\u0120can", "\u0120save", "\u0120the", "\u0120result", "\u0120of", "\u0120get", "Part", "ition", "(", "topic", "Part", "ition", ")"]}
{"function": "private String getDataSourceName(DataSource dataSource) { Preconditions.checkArgument( dataSource instanceof TableDataSource, \"Subqueries and Unions are only supported in the broker\" ); return Iterables.getOnlyElement(dataSource.getNames()); }", "text": "I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?", "function_tokens": ["private", "\u0120String", "\u0120get", "Data", "Source", "Name", "(", "Data", "Source", "\u0120data", "Source", ")", "\u0120{", "\u0120Pre", "cond", "itions", ".", "check", "Arg", "ument", "(", "\u0120data", "Source", "\u0120instance", "of", "\u0120Table", "Data", "Source", ",", "\u0120\"", "Sub", "qu", "eries", "\u0120and", "\u0120Un", "ions", "\u0120are", "\u0120only", "\u0120supported", "\u0120in", "\u0120the", "\u0120broker", "\"", "\u0120);", "\u0120return", "\u0120Iter", "ables", ".", "get", "Only", "Element", "(", "data", "Source", ".", "get", "Names", "());", "\u0120}"], "docstring_tokens": ["I", "\u0120think", "\u0120these", "\u0120instance", "\u0120of", "\u0120are", "\u0120getting", "\u0120away", "\u0120from", "\u0120why", "\u0120we", "\u0120should", "\u0120have", "\u0120inheritance", "\u0120in", "\u0120the", "\u0120first", "\u0120place", ".", "\u0120Can", "\u0120we", "\u0120throw", "\u0120an", "\u0120U", "OE", "\u0120in", "\u0120other", "\u0120non", "\u0120table", "\u0120data", "\u0120source", "\u0120data", "\u0120sources", "?"]}
{"function": "private void canTerminate(IProcessDMContext[] procDmcs, DataRequestMonitor<Boolean> rm) { if (procDmcs.length == 0) { IGDBControl gdbControl = fTracker.getService(IGDBControl.class); if (gdbControl != null) { rm.setData(true); } else { rm.setStatus(new Status(IStatus.ERROR, GdbUIPlugin.PLUGIN_ID, \"Service is not available.\")); } rm.done(); return; } IMultiTerminate multiTerminate = fTracker.getService(IMultiTerminate.class); if (multiTerminate != null) { multiTerminate.canTerminateSome(procDmcs, rm); } else { IProcesses procService = fTracker.getService(IProcesses.class); if (procService != null && procDmcs.length == 1) { procService.canTerminate(procDmcs[0], rm); } else { rm.setData(false);; rm.done(); } } }", "text": "Two ;;", "function_tokens": ["private", "\u0120void", "\u0120can", "Termin", "ate", "(", "I", "Process", "DM", "Context", "[]", "\u0120proc", "D", "m", "cs", ",", "\u0120Data", "Request", "Monitor", "<", "Boo", "lean", ">", "\u0120rm", ")", "\u0120{", "\u0120if", "\u0120(", "proc", "D", "m", "cs", ".", "length", "\u0120==", "\u01200", ")", "\u0120{", "\u0120IG", "D", "BC", "ont", "rol", "\u0120g", "db", "Control", "\u0120=", "\u0120f", "Tracker", ".", "get", "Service", "(", "IG", "D", "BC", "ont", "rol", ".", "class", ");", "\u0120if", "\u0120(", "g", "db", "Control", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120rm", ".", "set", "Data", "(", "true", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120rm", ".", "set", "Status", "(", "new", "\u0120Status", "(", "I", "Status", ".", "ERROR", ",", "\u0120G", "db", "UI", "Plugin", ".", "PL", "UG", "IN", "_", "ID", ",", "\u0120\"", "Service", "\u0120is", "\u0120not", "\u0120available", ".\"", "));", "\u0120}", "\u0120rm", ".", "done", "();", "\u0120return", ";", "\u0120}", "\u0120IM", "ult", "i", "Termin", "ate", "\u0120multi", "Termin", "ate", "\u0120=", "\u0120f", "Tracker", ".", "get", "Service", "(", "IM", "ult", "i", "Termin", "ate", ".", "class", ");", "\u0120if", "\u0120(", "multi", "Termin", "ate", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120multi", "Termin", "ate", ".", "can", "Termin", "ate", "Some", "(", "proc", "D", "m", "cs", ",", "\u0120rm", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120I", "Process", "es", "\u0120proc", "Service", "\u0120=", "\u0120f", "Tracker", ".", "get", "Service", "(", "I", "Process", "es", ".", "class", ");", "\u0120if", "\u0120(", "proc", "Service", "\u0120!=", "\u0120null", "\u0120&&", "\u0120proc", "D", "m", "cs", ".", "length", "\u0120==", "\u01201", ")", "\u0120{", "\u0120proc", "Service", ".", "can", "Termin", "ate", "(", "proc", "D", "m", "cs", "[", "0", "],", "\u0120rm", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120rm", ".", "set", "Data", "(", "false", ");", ";", "\u0120rm", ".", "done", "();", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Two", "\u0120;;"]}
{"function": "public AbfsRestOperation createPath(final String path, final boolean isFile, final boolean overwrite, final String permission, final String umask, final boolean appendBlob) throws AzureBlobFileSystemException { final List<AbfsHttpHeader> requestHeaders = createDefaultHeaders(); if (!overwrite) { requestHeaders.add(new AbfsHttpHeader(IF_NONE_MATCH, AbfsHttpConstants.STAR)); } if (permission != null && !permission.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_PERMISSIONS, permission)); } if (umask != null && !umask.isEmpty()) { requestHeaders.add(new AbfsHttpHeader(HttpHeaderConfigurations.X_MS_UMASK, umask)); } final AbfsUriQueryBuilder abfsUriQueryBuilder = createDefaultUriQueryBuilder(); abfsUriQueryBuilder.addQuery(QUERY_PARAM_RESOURCE, isFile ? FILE : DIRECTORY); if (appendBlob) { abfsUriQueryBuilder.addQuery(QUERY_PARAM_BLOBTYPE, APPEND_BLOB_TYPE); } final URL url = createRequestUrl(path, abfsUriQueryBuilder.toString()); final AbfsRestOperation op = new AbfsRestOperation( AbfsRestOperationType.CreatePath, this, HTTP_METHOD_PUT, url, requestHeaders); op.execute(); return op; }", "text": "Test the change against an account in prod tenant which still doesnt have Dec-12 bits .", "function_tokens": ["public", "\u0120Ab", "fs", "Rest", "Operation", "\u0120create", "Path", "(", "final", "\u0120String", "\u0120path", ",", "\u0120final", "\u0120boolean", "\u0120is", "File", ",", "\u0120final", "\u0120boolean", "\u0120overwrite", ",", "\u0120final", "\u0120String", "\u0120permission", ",", "\u0120final", "\u0120String", "\u0120um", "ask", ",", "\u0120final", "\u0120boolean", "\u0120append", "Bl", "ob", ")", "\u0120throws", "\u0120Azure", "Bl", "ob", "File", "System", "Exception", "\u0120{", "\u0120final", "\u0120List", "<", "Ab", "fs", "Http", "Header", ">", "\u0120request", "Head", "ers", "\u0120=", "\u0120create", "Default", "Head", "ers", "();", "\u0120if", "\u0120(!", "over", "write", ")", "\u0120{", "\u0120request", "Head", "ers", ".", "add", "(", "new", "\u0120Ab", "fs", "Http", "Header", "(", "IF", "_", "N", "ONE", "_", "M", "ATCH", ",", "\u0120Ab", "fs", "Http", "Const", "ants", ".", "STAR", "));", "\u0120}", "\u0120if", "\u0120(", "per", "mission", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "per", "mission", ".", "is", "Empty", "())", "\u0120{", "\u0120request", "Head", "ers", ".", "add", "(", "new", "\u0120Ab", "fs", "Http", "Header", "(", "Http", "Header", "Config", "urations", ".", "X", "_", "MS", "_", "PER", "M", "ISS", "IONS", ",", "\u0120permission", "));", "\u0120}", "\u0120if", "\u0120(", "um", "ask", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "um", "ask", ".", "is", "Empty", "())", "\u0120{", "\u0120request", "Head", "ers", ".", "add", "(", "new", "\u0120Ab", "fs", "Http", "Header", "(", "Http", "Header", "Config", "urations", ".", "X", "_", "MS", "_", "UM", "AS", "K", ",", "\u0120um", "ask", "));", "\u0120}", "\u0120final", "\u0120Ab", "fs", "U", "ri", "Query", "Builder", "\u0120ab", "fs", "U", "ri", "Query", "Builder", "\u0120=", "\u0120create", "Default", "U", "ri", "Query", "Builder", "();", "\u0120ab", "fs", "U", "ri", "Query", "Builder", ".", "add", "Query", "(", "QU", "ERY", "_", "PAR", "AM", "_", "RES", "OURCE", ",", "\u0120is", "File", "\u0120?", "\u0120FILE", "\u0120:", "\u0120DIRECT", "ORY", ");", "\u0120if", "\u0120(", "append", "Bl", "ob", ")", "\u0120{", "\u0120ab", "fs", "U", "ri", "Query", "Builder", ".", "add", "Query", "(", "QU", "ERY", "_", "PAR", "AM", "_", "BL", "OB", "TYPE", ",", "\u0120APP", "END", "_", "BL", "OB", "_", "TYPE", ");", "\u0120}", "\u0120final", "\u0120URL", "\u0120url", "\u0120=", "\u0120create", "Request", "Url", "(", "path", ",", "\u0120ab", "fs", "U", "ri", "Query", "Builder", ".", "to", "String", "());", "\u0120final", "\u0120Ab", "fs", "Rest", "Operation", "\u0120op", "\u0120=", "\u0120new", "\u0120Ab", "fs", "Rest", "Operation", "(", "\u0120Ab", "fs", "Rest", "Operation", "Type", ".", "Create", "Path", ",", "\u0120this", ",", "\u0120HTTP", "_", "METHOD", "_", "PUT", ",", "\u0120url", ",", "\u0120request", "Head", "ers", ");", "\u0120op", ".", "execute", "();", "\u0120return", "\u0120op", ";", "\u0120}"], "docstring_tokens": ["Test", "\u0120the", "\u0120change", "\u0120against", "\u0120an", "\u0120account", "\u0120in", "\u0120prod", "\u0120tenant", "\u0120which", "\u0120still", "\u0120doesnt", "\u0120have", "\u0120Dec", "-", "12", "\u0120bits", "\u0120."]}
{"function": "private void buildColumns(ElasticsearchTableDescription tableDescription) { Set<ElasticsearchColumn> columns = new HashSet(); Client client = clients.get(tableDescription.getClusterName()); verify(client != null); try { GetMappingsRequest mappingsRequest = new GetMappingsRequest().types(tableDescription.getType()); String index = tableDescription.getIndex(); if (!isNullOrEmpty(index)) { mappingsRequest.indices(index); } ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = client.admin().indices().getMappings(mappingsRequest).actionGet(timeout.toMillis()).getMappings(); Iterator<String> indexIterator = mappings.keysIt(); while (indexIterator.hasNext()) { MappingMetaData mappingMetaData = mappings.get(indexIterator.next()).get(tableDescription.getType()); JSONObject mappingObject = new JSONObject(mappingMetaData.source().toString()).getJSONObject(tableDescription.getType()); JSONObject properties = mappingObject.getJSONObject(\"properties\"); List<String> lists = new ArrayList<String>(); if (properties.has(\"_meta\")) { JSONObject meta = mappingObject.getJSONObject(\"_meta\"); if (meta.has(\"lists\")) { JSONArray arrays = meta.getJSONArray(\"lists\"); for (int i = 0; i < arrays.length(); i++) { lists.add(arrays.getString(i)); } } } for (String columnMetadata : getColumnsMetadata(null, properties)) { Optional<ElasticsearchColumn> column = createColumn(columnMetadata, lists); if (!column.isPresent()) { continue; } if (columns.stream().noneMatch(col -> col.getName().equals(column.get().getName()))) { columns.add(column.get()); } } } columns.add(createColumn(\"_id.type:string\", ImmutableList.of()).get()); columns.add(createColumn(\"_index.type:string\", ImmutableList.of()).get()); tableDescription.setColumns(ImmutableList.copyOf(columns)); tableDescription.setColumnsMetadata(columns.stream().map(ElasticsearchColumnMetadata::new).collect(Collectors.toList())); } catch (JSONException e) { throw new PrestoException(ELASTIC_SEARCH_MAPPING_REQUEST_ERROR, e); } }", "text": "verify(client != null, \"client cannot be null\");", "function_tokens": ["private", "\u0120void", "\u0120build", "Column", "s", "(", "El", "astic", "search", "Table", "Description", "\u0120table", "Description", ")", "\u0120{", "\u0120Set", "<", "El", "astic", "search", "Column", ">", "\u0120columns", "\u0120=", "\u0120new", "\u0120Hash", "Set", "();", "\u0120Client", "\u0120client", "\u0120=", "\u0120clients", ".", "get", "(", "table", "Description", ".", "get", "Cl", "uster", "Name", "());", "\u0120verify", "(", "client", "\u0120!=", "\u0120null", ");", "\u0120try", "\u0120{", "\u0120Get", "M", "appings", "Request", "\u0120m", "appings", "Request", "\u0120=", "\u0120new", "\u0120Get", "M", "appings", "Request", "().", "types", "(", "table", "Description", ".", "get", "Type", "());", "\u0120String", "\u0120index", "\u0120=", "\u0120table", "Description", ".", "get", "Index", "();", "\u0120if", "\u0120(!", "is", "Null", "Or", "Empty", "(", "index", "))", "\u0120{", "\u0120m", "appings", "Request", ".", "ind", "ices", "(", "index", ");", "\u0120}", "\u0120Imm", "utable", "Open", "Map", "<", "String", ",", "\u0120Imm", "utable", "Open", "Map", "<", "String", ",", "\u0120M", "apping", "Meta", "Data", ">>", "\u0120m", "appings", "\u0120=", "\u0120client", ".", "admin", "().", "ind", "ices", "().", "get", "M", "appings", "(", "m", "appings", "Request", ").", "action", "Get", "(", "timeout", ".", "to", "Mill", "is", "()", ").", "get", "M", "appings", "();", "\u0120Iter", "ator", "<", "String", ">", "\u0120index", "Iterator", "\u0120=", "\u0120m", "appings", ".", "keys", "It", "();", "\u0120while", "\u0120(", "index", "Iterator", ".", "has", "Next", "())", "\u0120{", "\u0120M", "apping", "Meta", "Data", "\u0120mapping", "Meta", "Data", "\u0120=", "\u0120m", "appings", ".", "get", "(", "index", "Iterator", ".", "next", "()", ").", "get", "(", "table", "Description", ".", "get", "Type", "());", "\u0120JSON", "Object", "\u0120mapping", "Object", "\u0120=", "\u0120new", "\u0120JSON", "Object", "(", "m", "apping", "Meta", "Data", ".", "source", "().", "to", "String", "()", ").", "get", "JSON", "Object", "(", "table", "Description", ".", "get", "Type", "());", "\u0120JSON", "Object", "\u0120properties", "\u0120=", "\u0120mapping", "Object", ".", "get", "JSON", "Object", "(\"", "properties", "\");", "\u0120List", "<", "String", ">", "\u0120lists", "\u0120=", "\u0120new", "\u0120Array", "List", "<", "String", ">", "();", "\u0120if", "\u0120(", "properties", ".", "has", "(\"", "_", "meta", "\"))", "\u0120{", "\u0120JSON", "Object", "\u0120meta", "\u0120=", "\u0120mapping", "Object", ".", "get", "JSON", "Object", "(\"", "_", "meta", "\");", "\u0120if", "\u0120(", "meta", ".", "has", "(\"", "lists", "\"))", "\u0120{", "\u0120JSON", "Array", "\u0120arrays", "\u0120=", "\u0120meta", ".", "get", "JSON", "Array", "(\"", "lists", "\");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120arrays", ".", "length", "();", "\u0120i", "++)", "\u0120{", "\u0120lists", ".", "add", "(", "arr", "ays", ".", "get", "String", "(", "i", "));", "\u0120}", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "String", "\u0120column", "Met", "adata", "\u0120:", "\u0120get", "Column", "s", "Met", "adata", "(", "null", ",", "\u0120properties", "))", "\u0120{", "\u0120Optional", "<", "El", "astic", "search", "Column", ">", "\u0120column", "\u0120=", "\u0120create", "Column", "(", "column", "Met", "adata", ",", "\u0120lists", ");", "\u0120if", "\u0120(!", "column", ".", "is", "Present", "())", "\u0120{", "\u0120continue", ";", "\u0120}", "\u0120if", "\u0120(", "column", "s", ".", "stream", "().", "none", "Match", "(", "col", "\u0120->", "\u0120col", ".", "get", "Name", "().", "equ", "als", "(", "column", ".", "get", "().", "get", "Name", "()", ")))", "\u0120{", "\u0120columns", ".", "add", "(", "column", ".", "get", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120columns", ".", "add", "(", "create", "Column", "(\"", "_", "id", ".", "type", ":", "string", "\",", "\u0120Imm", "utable", "List", ".", "of", "()", ").", "get", "());", "\u0120columns", ".", "add", "(", "create", "Column", "(\"", "_", "index", ".", "type", ":", "string", "\",", "\u0120Imm", "utable", "List", ".", "of", "()", ").", "get", "());", "\u0120table", "Description", ".", "set", "Column", "s", "(", "Imm", "utable", "List", ".", "copy", "Of", "(", "column", "s", "));", "\u0120table", "Description", ".", "set", "Column", "s", "Met", "adata", "(", "column", "s", ".", "stream", "().", "map", "(", "El", "astic", "search", "Column", "Met", "adata", "::", "new", ").", "collect", "(", "Collect", "ors", ".", "to", "List", "()", "));", "\u0120}", "\u0120catch", "\u0120(", "JSON", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Prest", "o", "Exception", "(", "EL", "AST", "IC", "_", "SE", "ARCH", "_", "M", "APP", "ING", "_", "RE", "QUEST", "_", "ERROR", ",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["ver", "ify", "(", "client", "\u0120!=", "\u0120null", ",", "\u0120\"", "client", "\u0120cannot", "\u0120be", "\u0120null", "\");"]}
{"function": "private static SecretKeyEncryptionStrategy instantiateSecreteKeyEncryptionStrategy(String className) { log.debug(\"About to instantiate secret key encryption strategy {}\", className); SecretKeyEncryptionStrategy strategy = null; Class keyEncryptionStrategyClazz = null; try { keyEncryptionStrategyClazz = AccumuloVFSClassLoader.loadClass(className); } catch (ClassNotFoundException e1) { throw new RuntimeException(\"Could not find configured secret key encryption strategy: \" + className); } Class[] interfaces = keyEncryptionStrategyClazz.getInterfaces(); boolean implementsSecretKeyStrategy = false; for (Class clazz : interfaces) { if (clazz.equals(SecretKeyEncryptionStrategy.class)) { implementsSecretKeyStrategy = true; break; } } if (!implementsSecretKeyStrategy) { throw new RuntimeException(\"Configured Accumulo secret key encryption strategy \\\"%s\\\" does not implement the SecretKeyEncryptionStrategy interface.\"); } else { try { strategy = (SecretKeyEncryptionStrategy) keyEncryptionStrategyClazz.newInstance(); log.debug(\"Successfully instantiated secret key encryption strategy {}\", className); } catch (InstantiationException e) { throw new RuntimeException(\"Got instantiation exception {} when instantiating secret key encryption strategy \" + className); } catch (IllegalAccessException e) { throw new RuntimeException(\"Got illegal access exception when trying to instantiate secret key encryption strategy \" + className); } } return strategy; }", "text": "Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.", "function_tokens": ["private", "\u0120static", "\u0120Secret", "Key", "Enc", "ryption", "Str", "ategy", "\u0120instant", "iate", "Sec", "rete", "Key", "Enc", "ryption", "Str", "ategy", "(", "String", "\u0120class", "Name", ")", "\u0120{", "\u0120log", ".", "debug", "(\"", "About", "\u0120to", "\u0120instant", "iate", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", "\u0120{}", "\",", "\u0120class", "Name", ");", "\u0120Secret", "Key", "Enc", "ryption", "Str", "ategy", "\u0120strategy", "\u0120=", "\u0120null", ";", "\u0120Class", "\u0120key", "Enc", "ryption", "Str", "ategy", "Cl", "azz", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120key", "Enc", "ryption", "Str", "ategy", "Cl", "azz", "\u0120=", "\u0120Acc", "um", "ulo", "V", "FS", "Class", "Loader", ".", "load", "Class", "(", "class", "Name", ");", "\u0120}", "\u0120catch", "\u0120(", "Class", "Not", "Found", "Exception", "\u0120e", "1", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Could", "\u0120not", "\u0120find", "\u0120configured", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", ":", "\u0120\"", "\u0120+", "\u0120class", "Name", ");", "\u0120}", "\u0120Class", "[]", "\u0120interfaces", "\u0120=", "\u0120key", "Enc", "ryption", "Str", "ategy", "Cl", "azz", ".", "get", "Inter", "faces", "();", "\u0120boolean", "\u0120implements", "Secret", "Key", "Str", "ategy", "\u0120=", "\u0120false", ";", "\u0120for", "\u0120(", "Class", "\u0120cl", "azz", "\u0120:", "\u0120interfaces", ")", "\u0120{", "\u0120if", "\u0120(", "cl", "azz", ".", "equ", "als", "(", "Secret", "Key", "Enc", "ryption", "Str", "ategy", ".", "class", "))", "\u0120{", "\u0120implements", "Secret", "Key", "Str", "ategy", "\u0120=", "\u0120true", ";", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "im", "ple", "ments", "Secret", "Key", "Str", "ategy", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Config", "ured", "\u0120Acc", "um", "ulo", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", "\u0120\\\"", "%", "s", "\\\"", "\u0120does", "\u0120not", "\u0120implement", "\u0120the", "\u0120Secret", "Key", "Enc", "ryption", "Str", "ategy", "\u0120interface", ".\"", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120try", "\u0120{", "\u0120strategy", "\u0120=", "\u0120(", "Secret", "Key", "Enc", "ryption", "Str", "ategy", ")", "\u0120key", "Enc", "ryption", "Str", "ategy", "Cl", "azz", ".", "new", "Instance", "();", "\u0120log", ".", "debug", "(\"", "Success", "fully", "\u0120instant", "iated", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", "\u0120{}", "\",", "\u0120class", "Name", ");", "\u0120}", "\u0120catch", "\u0120(", "Instant", "iation", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Got", "\u0120instant", "iation", "\u0120exception", "\u0120{}", "\u0120when", "\u0120instant", "iating", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", "\u0120\"", "\u0120+", "\u0120class", "Name", ");", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "Access", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "Exception", "(\"", "Got", "\u0120illegal", "\u0120access", "\u0120exception", "\u0120when", "\u0120trying", "\u0120to", "\u0120instant", "iate", "\u0120secret", "\u0120key", "\u0120encryption", "\u0120strategy", "\u0120\"", "\u0120+", "\u0120class", "Name", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120strategy", ";", "\u0120}"], "docstring_tokens": ["Since", "\u0120a", "\u0120lot", "\u0120of", "\u0120these", "\u0120catch", "\u0120blocks", "\u0120have", "\u0120essentially", "\u0120the", "\u0120same", "\u0120error", ",", "\u0120it", "'d", "\u0120probably", "\u0120be", "\u0120better", "\u0120to", "\u0120use", "\u0120the", "\u0120multi", "-", "catch", "\u0120syntax", ",", "\u0120just", "\u0120to", "\u0120clean", "\u0120things", "\u0120up", "\u0120a", "\u0120bit", ".", "\u0120The", "\u0120original", "\u0120exception", "\u0120should", "\u0120be", "\u0120passed", "\u0120as", "\u0120a", "\u0120parameter", ",", "\u0120so", "\u0120we", "\u0120don", "'t", "\u0120lose", "\u0120portions", "\u0120of", "\u0120the", "\u0120stack", "\u0120trace", "."]}
{"function": "public void removeAllChangeListeners() { realm.checkIfValid(); realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE); collection.removeAllListeners(); }", "text": "Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?", "function_tokens": ["public", "\u0120void", "\u0120remove", "All", "Change", "Listen", "ers", "()", "\u0120{", "\u0120realm", ".", "check", "If", "Valid", "();", "\u0120realm", ".", "shared", "Real", "m", ".", "cap", "abilities", ".", "check", "Can", "Del", "iver", "Not", "ification", "(", "Base", "Real", "m", ".", "LIST", "EN", "ER", "_", "NOT", "_", "ALL", "OW", "ED", "_", "M", "ES", "SA", "GE", ");", "\u0120collection", ".", "remove", "All", "Listen", "ers", "();", "\u0120}"], "docstring_tokens": ["Would", "\u0120be", "\u0120nice", "\u0120if", "\u0120this", "\u0120could", "\u0120be", "\u0120incorporated", "\u0120into", "\u0120the", "\u0120check", "For", "Add", "Remove", "Listener", "\u0120method", "?", "\u0120Perhaps", "\u0120check", "For", "Add", "Remove", "Listener", "(", "list", "ener", ",", "\u0120check", "For", "Null", ")", "\u0120?"]}
{"function": "public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), buildPayload(4 * MiB))).isEqualTo(HashCode.fromString(TREEHASH)); RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), \"PUT /-/vaults/\" + VAULT_NAME + \"/multipart-uploads/\" + MULTIPART_UPLOAD_ID + \" \" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), \"bytes 0-4194303/*\"); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), \"4194304\"); }", "text": "Should TREEHASH be a HashCode?", "function_tokens": ["public", "\u0120void", "\u0120test", "Upload", "Part", "()", "\u0120throws", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120Mock", "Response", "\u0120m", "r", "\u0120=", "\u0120build", "Base", "Response", "(", "204", ");", "\u0120m", "r", ".", "add", "Header", "(", "Gl", "ac", "ier", "Head", "ers", ".", "T", "REE", "_", "H", "ASH", ",", "\u0120T", "REE", "H", "ASH", ");", "\u0120server", ".", "en", "queue", "(", "mr", ");", "\u0120assert", "That", "(", "client", ".", "upload", "Part", "(", "VA", "ULT", "_", "NAME", ",", "\u0120M", "ULT", "IP", "ART", "_", "U", "PL", "OAD", "_", "ID", ",", "\u0120Content", "Range", ".", "from", "Part", "Number", "(", "0", ",", "\u01204", "),", "\u0120build", "Pay", "load", "(", "4", "\u0120*", "\u0120Mi", "B", "))", ").", "is", "E", "qual", "To", "(", "Hash", "Code", ".", "from", "String", "(", "T", "REE", "H", "ASH", "));", "\u0120Recorded", "Request", "\u0120request", "\u0120=", "\u0120server", ".", "take", "Request", "();", "\u0120assert", "Equ", "als", "(", "request", ".", "get", "Request", "Line", "(),", "\u0120\"", "PUT", "\u0120/", "-", "/", "v", "aults", "/\"", "\u0120+", "\u0120VA", "ULT", "_", "NAME", "\u0120+", "\u0120\"/", "mult", "ip", "art", "-", "uploads", "/\"", "\u0120+", "\u0120M", "ULT", "IP", "ART", "_", "U", "PL", "OAD", "_", "ID", "\u0120+", "\u0120\"", "\u0120\"", "\u0120+", "\u0120HTTP", ");", "\u0120assert", "Equ", "als", "(", "request", ".", "get", "Header", "(", "Http", "Head", "ers", ".", "CONT", "ENT", "_", "R", "ANGE", "),", "\u0120\"", "bytes", "\u01200", "-", "4", "194", "303", "/*", "\");", "\u0120assert", "Equ", "als", "(", "request", ".", "get", "Header", "(", "Http", "Head", "ers", ".", "CONT", "ENT", "_", "L", "ENGTH", "),", "\u0120\"", "4", "194", "304", "\");", "\u0120}"], "docstring_tokens": ["Should", "\u0120T", "REE", "H", "ASH", "\u0120be", "\u0120a", "\u0120Hash", "Code", "?"]}
{"function": "public String render(final ListAllMyBucketsResult obj) throws JsonProcessingException { if (obj == null) { return \"You do not have any buckets\"; } ObjectMapper mapper = new ObjectMapper(); return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); }", "text": "final", "function_tokens": ["public", "\u0120String", "\u0120render", "(", "final", "\u0120List", "All", "My", "B", "uck", "ets", "Result", "\u0120obj", ")", "\u0120throws", "\u0120J", "son", "Process", "ing", "Exception", "\u0120{", "\u0120if", "\u0120(", "obj", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120\"", "You", "\u0120do", "\u0120not", "\u0120have", "\u0120any", "\u0120buckets", "\";", "\u0120}", "\u0120Object", "M", "apper", "\u0120m", "apper", "\u0120=", "\u0120new", "\u0120Object", "M", "apper", "();", "\u0120return", "\u0120m", "apper", ".", "writer", "With", "Default", "Pretty", "Pr", "inter", "().", "write", "Value", "As", "String", "(", "obj", ");", "\u0120}"], "docstring_tokens": ["final"]}
{"function": "protected void doMerge(Mapper mergeWith, boolean updateAllTypes) { super.doMerge(mergeWith, updateAllTypes); var mw = ((KeywordFieldMapper) mergeWith); this.ignoreAbove = ((KeywordFieldMapper) mergeWith).ignoreAbove; if (!Objects.equals(this.lengthLimit, mw.lengthLimit)) { throw new IllegalArgumentException( \"mapper [\" + name() + \"] has different length_limit settings, current [\" + this.fieldType().lengthLimit + \"], merged [\" + mw.fieldType().lengthLimit + \"]\"); } }", "text": "suggestion this.ignoreAbove = mw.ignoreAbove;", "function_tokens": ["protected", "\u0120void", "\u0120do", "Mer", "ge", "(", "M", "apper", "\u0120merge", "With", ",", "\u0120boolean", "\u0120update", "All", "Types", ")", "\u0120{", "\u0120super", ".", "do", "Mer", "ge", "(", "mer", "ge", "With", ",", "\u0120update", "All", "Types", ");", "\u0120var", "\u0120m", "w", "\u0120=", "\u0120((", "Key", "word", "Field", "M", "apper", ")", "\u0120merge", "With", ");", "\u0120this", ".", "ignore", "Above", "\u0120=", "\u0120((", "Key", "word", "Field", "M", "apper", ")", "\u0120merge", "With", ").", "ignore", "Above", ";", "\u0120if", "\u0120(!", "Object", "s", ".", "equ", "als", "(", "this", ".", "length", "Limit", ",", "\u0120m", "w", ".", "length", "Limit", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "m", "apper", "\u0120[\"", "\u0120+", "\u0120name", "()", "\u0120+", "\u0120\"", "]", "\u0120has", "\u0120different", "\u0120length", "_", "limit", "\u0120settings", ",", "\u0120current", "\u0120[\"", "\u0120+", "\u0120this", ".", "field", "Type", "().", "length", "Limit", "\u0120+", "\u0120\"", "],", "\u0120merged", "\u0120[\"", "\u0120+", "\u0120m", "w", ".", "field", "Type", "().", "length", "Limit", "\u0120+", "\u0120\"", "]", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120this", ".", "ignore", "Above", "\u0120=", "\u0120m", "w", ".", "ignore", "Above", ";"]}
{"function": "private void storeReleasedTime(AndroidCommCarePlatform platform, Reference ref) { long releasedOnTime = -1; if (ref instanceof JavaHttpReference) { Headers responseHeaders = ((JavaHttpReference)ref).getResponseHeaders(); if (responseHeaders != null) { String releasedOnStr = responseHeaders.get(HEADER_APP_RELEASED_ON); try { if (releasedOnStr != null) { releasedOnTime = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\").parse(releasedOnStr).getTime(); } } catch (ParseException e) { e.printStackTrace(); } } } if (releasedOnTime == -1) { releasedOnTime = new Date().getTime(); } HiddenPreferences.setReleasedOnTimeForOngoingAppDownload(platform, releasedOnTime); }", "text": "I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.", "function_tokens": ["private", "\u0120void", "\u0120store", "Released", "Time", "(", "Android", "Comm", "Care", "Platform", "\u0120platform", ",", "\u0120Reference", "\u0120ref", ")", "\u0120{", "\u0120long", "\u0120released", "On", "Time", "\u0120=", "\u0120-", "1", ";", "\u0120if", "\u0120(", "ref", "\u0120instance", "of", "\u0120Java", "Http", "Reference", ")", "\u0120{", "\u0120Head", "ers", "\u0120response", "Head", "ers", "\u0120=", "\u0120((", "Java", "Http", "Reference", ")", "ref", ").", "get", "Response", "Head", "ers", "();", "\u0120if", "\u0120(", "response", "Head", "ers", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120String", "\u0120released", "On", "Str", "\u0120=", "\u0120response", "Head", "ers", ".", "get", "(", "HEAD", "ER", "_", "APP", "_", "RE", "LE", "ASED", "_", "ON", ");", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "released", "On", "Str", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120released", "On", "Time", "\u0120=", "\u0120new", "\u0120Simple", "Date", "Format", "(\"", "yy", "yy", "-", "MM", "-", "dd", "'", "T", "'", "HH", ":", "mm", "'", "Z", "'", "\").", "parse", "(", "released", "On", "Str", ").", "get", "Time", "();", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Par", "se", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "released", "On", "Time", "\u0120==", "\u0120-", "1", ")", "\u0120{", "\u0120released", "On", "Time", "\u0120=", "\u0120new", "\u0120Date", "().", "get", "Time", "();", "\u0120}", "\u0120Hidden", "Pref", "erences", ".", "set", "Released", "On", "Time", "For", "O", "ng", "oing", "App", "Download", "(", "platform", ",", "\u0120released", "On", "Time", ");", "\u0120}"], "docstring_tokens": ["I", "'m", "\u0120not", "\u0120sure", "\u0120we", "\u0120actually", "\u0120want", "\u0120to", "\u0120eat", "\u0120this", "\u0120error", "\u0120silently", ".", "\u0120A", "\u0120parse", "\u0120error", "\u0120here", "\u0120means", "\u0120that", "\u0120HQ", "\u0120is", "\u0120setting", "\u0120the", "\u0120header", ",", "\u0120but", "\u0120in", "\u0120the", "\u0120wrong", "\u0120format", ",", "\u0120which", "\u0120means", "\u0120that", "\u0120the", "\u0120phones", "\u0120will", "\u0120all", "\u0120just", "\u0120silently", "\u0120fail", "\u0120to", "\u0120properly", "\u0120use", "\u0120the", "\u0120feature", "\u0120correctly", ",", "\u0120but", "\u0120without", "\u0120anyone", "'s", "\u0120knowledge", "."]}
{"function": "public void centerOnNode(DataNode node) throws NodeNotFoundException { double x = -1; for (WrapperClone wrapperClone : graphData) { if (wrapperClone.getDataNodes().contains(node)) { x = wrapperClone.getX(); break; } } if (x != -1) { setZoomCenter(x); } else { throw new NodeNotFoundException(); } }", "text": "Wrapper#getX() : float Use float instead of double.", "function_tokens": ["public", "\u0120void", "\u0120center", "On", "Node", "(", "Data", "Node", "\u0120node", ")", "\u0120throws", "\u0120Node", "Not", "Found", "Exception", "\u0120{", "\u0120double", "\u0120x", "\u0120=", "\u0120-", "1", ";", "\u0120for", "\u0120(", "Wra", "pper", "Cl", "one", "\u0120wrapper", "Cl", "one", "\u0120:", "\u0120graph", "Data", ")", "\u0120{", "\u0120if", "\u0120(", "wrapper", "Cl", "one", ".", "get", "Data", "N", "odes", "().", "cont", "ains", "(", "node", "))", "\u0120{", "\u0120x", "\u0120=", "\u0120wrapper", "Cl", "one", ".", "get", "X", "();", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "x", "\u0120!=", "\u0120-", "1", ")", "\u0120{", "\u0120set", "Z", "oom", "Center", "(", "x", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Node", "Not", "Found", "Exception", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Wra", "pper", "#", "get", "X", "()", "\u0120:", "\u0120float", "\u0120Use", "\u0120float", "\u0120instead", "\u0120of", "\u0120double", "."]}
{"function": "public SourceRecord extractRecord() throws SQLException { Struct record = new Struct(schemaMapping.schema()); for (FieldSetter setter : schemaMapping.fieldSetters()) { try { setter.setField(record, resultSet); } catch (IOException e) { log.warn(\"Ignoring record because processing failed:\", e); } catch (SQLException e) { log.warn(\"Ignoring record due to SQL error:\", e); } } offset = criteria.extractValues(schemaMapping.schema(), record, offset); final String topic; final Map<String, String> partition; switch (mode) { case TABLE: if (useFqn) { String fqn = ExpressionBuilder.create().append(tableId, false).toString(); partition = new HashMap<>(); partition.put(JdbcSourceConnectorConstants.TABLE_NAME_KEY, fqn); partition.put(JdbcSourceConnectorConstants.OFFSET_PROTOCOL_VERSION, \"1\"); topic = topicPrefix + fqn; } else { String name = tableId.tableName(); partition = Collections.singletonMap(JdbcSourceConnectorConstants.TABLE_NAME_KEY, name); topic = topicPrefix + name; } break; case QUERY: partition = Collections.singletonMap(JdbcSourceConnectorConstants.QUERY_NAME_KEY, JdbcSourceConnectorConstants.QUERY_NAME_VALUE); topic = topicPrefix; break; default: throw new ConnectException(\"Unexpected query mode: \" + mode); } return new SourceRecord(partition, offset.toMap(), topic, record.schema(), record); }", "text": "Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.", "function_tokens": ["public", "\u0120Source", "Record", "\u0120extract", "Record", "()", "\u0120throws", "\u0120SQ", "LE", "x", "ception", "\u0120{", "\u0120Struct", "\u0120record", "\u0120=", "\u0120new", "\u0120Struct", "(", "sche", "ma", "M", "apping", ".", "sche", "ma", "());", "\u0120for", "\u0120(", "Field", "Set", "ter", "\u0120set", "ter", "\u0120:", "\u0120schema", "M", "apping", ".", "field", "Set", "ters", "())", "\u0120{", "\u0120try", "\u0120{", "\u0120set", "ter", ".", "set", "Field", "(", "record", ",", "\u0120result", "Set", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "(\"", "Ign", "oring", "\u0120record", "\u0120because", "\u0120processing", "\u0120failed", ":", "\",", "\u0120e", ");", "\u0120}", "\u0120catch", "\u0120(", "S", "Q", "LE", "x", "ception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "warn", "(\"", "Ign", "oring", "\u0120record", "\u0120due", "\u0120to", "\u0120SQL", "\u0120error", ":", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120offset", "\u0120=", "\u0120criteria", ".", "ext", "ract", "Values", "(", "sche", "ma", "M", "apping", ".", "sche", "ma", "(),", "\u0120record", ",", "\u0120offset", ");", "\u0120final", "\u0120String", "\u0120topic", ";", "\u0120final", "\u0120Map", "<", "String", ",", "\u0120String", ">", "\u0120partition", ";", "\u0120switch", "\u0120(", "mode", ")", "\u0120{", "\u0120case", "\u0120TABLE", ":", "\u0120if", "\u0120(", "use", "F", "q", "n", ")", "\u0120{", "\u0120String", "\u0120f", "q", "n", "\u0120=", "\u0120Expression", "Builder", ".", "create", "().", "append", "(", "table", "Id", ",", "\u0120false", ").", "to", "String", "();", "\u0120partition", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120partition", ".", "put", "(", "J", "db", "c", "Source", "Connector", "Const", "ants", ".", "TABLE", "_", "NAME", "_", "KEY", ",", "\u0120f", "q", "n", ");", "\u0120partition", ".", "put", "(", "J", "db", "c", "Source", "Connector", "Const", "ants", ".", "OFF", "SET", "_", "PR", "OT", "OC", "OL", "_", "VERSION", ",", "\u0120\"", "1", "\");", "\u0120topic", "\u0120=", "\u0120topic", "Pref", "ix", "\u0120+", "\u0120f", "q", "n", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120name", "\u0120=", "\u0120table", "Id", ".", "table", "Name", "();", "\u0120partition", "\u0120=", "\u0120Collections", ".", "sing", "leton", "Map", "(", "J", "db", "c", "Source", "Connector", "Const", "ants", ".", "TABLE", "_", "NAME", "_", "KEY", ",", "\u0120name", ");", "\u0120topic", "\u0120=", "\u0120topic", "Pref", "ix", "\u0120+", "\u0120name", ";", "\u0120}", "\u0120break", ";", "\u0120case", "\u0120QU", "ERY", ":", "\u0120partition", "\u0120=", "\u0120Collections", ".", "sing", "leton", "Map", "(", "J", "db", "c", "Source", "Connector", "Const", "ants", ".", "QU", "ERY", "_", "NAME", "_", "KEY", ",", "\u0120J", "db", "c", "Source", "Connector", "Const", "ants", ".", "QU", "ERY", "_", "NAME", "_", "VALUE", ");", "\u0120topic", "\u0120=", "\u0120topic", "Pref", "ix", ";", "\u0120break", ";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Connect", "Exception", "(\"", "U", "nexpected", "\u0120query", "\u0120mode", ":", "\u0120\"", "\u0120+", "\u0120mode", ");", "\u0120}", "\u0120return", "\u0120new", "\u0120Source", "Record", "(", "part", "ition", ",", "\u0120offset", ".", "to", "Map", "(),", "\u0120topic", ",", "\u0120record", ".", "sche", "ma", "(),", "\u0120record", ");", "\u0120}"], "docstring_tokens": ["Se", "ems", "\u0120like", "\u0120all", "\u0120of", "\u0120this", "\u0120could", "\u0120be", "\u0120extracted", "\u0120into", "\u0120a", "\u0120strategy", "\u0120function", "\u0120to", "\u0120compute", "\u0120the", "\u0120topic", "\u0120given", "\u0120the", "\u0120table", "\u0120ID", "\u0120(", "e", ".", "g", ".,", "\u0120topic", "Name", "(", "Table", "Id", ")),", "\u0120and", "\u0120a", "\u0120second", "\u0120method", "\u0120to", "\u0120compute", "\u0120the", "\u0120partitions", "\u0120for", "\u0120a", "\u0120table", "\u0120ID", "\u0120(", "e", ".", "g", ".,", "\u0120source", "Part", "itions", "(", "Table", "Id", ")).", "\u0120We", "\u0120could", "\u0120have", "\u0120separate", "\u0120strategy", "\u0120implementations", "\u0120for", "\u0120each", "\u0120protocol", "\u0120version", ",", "\u0120and", "\u0120a", "\u0120particular", "\u0120strategy", "\u0120implementation", "\u0120can", "\u0120be", "\u0120passed", "\u0120into", "\u0120this", "\u0120class", "."]}
{"function": "protected void decodeValue(Klv klv) { byte[] bytes = klv.getValue(); CharsetDetector charsetDetector = new CharsetDetector(); charsetDetector.setText(bytes); CharsetMatch charsetMatch = charsetDetector.detect(); Charset charset = Charset.defaultCharset(); if (charsetMatch != null) { try { charset = Charset.forName(charsetMatch.getName()); } catch (IllegalArgumentException e) { LOGGER.trace( \"Unsupported encoding of %s, falling back to default encoding\", charsetMatch.getName()); } } value = new String(bytes, charset); }", "text": ":question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.", "function_tokens": ["protected", "\u0120void", "\u0120decode", "Value", "(", "K", "lv", "\u0120k", "lv", ")", "\u0120{", "\u0120byte", "[]", "\u0120bytes", "\u0120=", "\u0120k", "lv", ".", "get", "Value", "();", "\u0120Ch", "ars", "et", "Det", "ector", "\u0120chars", "et", "Det", "ector", "\u0120=", "\u0120new", "\u0120Ch", "ars", "et", "Det", "ector", "();", "\u0120chars", "et", "Det", "ector", ".", "set", "Text", "(", "bytes", ");", "\u0120Ch", "ars", "et", "Match", "\u0120chars", "et", "Match", "\u0120=", "\u0120chars", "et", "Det", "ector", ".", "det", "ect", "();", "\u0120Ch", "ars", "et", "\u0120chars", "et", "\u0120=", "\u0120Ch", "ars", "et", ".", "default", "Ch", "ars", "et", "();", "\u0120if", "\u0120(", "ch", "ars", "et", "Match", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120chars", "et", "\u0120=", "\u0120Ch", "ars", "et", ".", "for", "Name", "(", "ch", "ars", "et", "Match", ".", "get", "Name", "());", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "Arg", "ument", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "trace", "(", "\u0120\"", "Un", "supported", "\u0120encoding", "\u0120of", "\u0120%", "s", ",", "\u0120falling", "\u0120back", "\u0120to", "\u0120default", "\u0120encoding", "\",", "\u0120chars", "et", "Match", ".", "get", "Name", "());", "\u0120}", "\u0120}", "\u0120value", "\u0120=", "\u0120new", "\u0120String", "(", "bytes", ",", "\u0120chars", "et", ");", "\u0120}"], "docstring_tokens": [":", "question", ":", "\u0120is", "\u0120it", "\u0120safe", "\u0120to", "\u0120use", "\u0120Ch", "ars", "et", ".", "default", "Ch", "ars", "et", "()", "\u0120here", "?", "\u0120Some", "\u0120systems", "\u0120have", "\u0120different", "\u0120default", "\u0120chars", "ets", ".", "\u0120For", "\u0120example", ",", "\u0120Windows", "\u0120vs", "\u0120Linux", "."]}
{"function": "private AzureBlobStorageImpl constructImpl() { Objects.requireNonNull(blobName, \"'blobName' cannot be null.\"); if (Objects.isNull(containerName) || containerName.isEmpty()) { containerName = BlobContainerAsyncClient.ROOT_CONTAINER_NAME; } checkValidEncryptionParameters(); HttpPipeline pipeline = super.getPipeline(); if (pipeline == null) { pipeline = buildPipeline(); } return new AzureBlobStorageBuilder() .url(String.format(\"%s/%s/%s\", endpoint, containerName, blobName)) .pipeline(pipeline) .build(); }", "text": "ImplUtils has a isNullOrEmpty method that should handle these checks.", "function_tokens": ["private", "\u0120Azure", "Bl", "ob", "Storage", "Impl", "\u0120construct", "Impl", "()", "\u0120{", "\u0120Objects", ".", "require", "Non", "Null", "(", "bl", "ob", "Name", ",", "\u0120\"'", "bl", "ob", "Name", "'", "\u0120cannot", "\u0120be", "\u0120null", ".\"", ");", "\u0120if", "\u0120(", "Object", "s", ".", "is", "Null", "(", "container", "Name", ")", "\u0120||", "\u0120container", "Name", ".", "is", "Empty", "())", "\u0120{", "\u0120container", "Name", "\u0120=", "\u0120Bl", "ob", "Container", "Async", "Client", ".", "RO", "OT", "_", "CON", "TAIN", "ER", "_", "NAME", ";", "\u0120}", "\u0120check", "Valid", "Enc", "ryption", "Parameters", "();", "\u0120H", "ttp", "P", "ip", "eline", "\u0120pipeline", "\u0120=", "\u0120super", ".", "get", "P", "ip", "eline", "();", "\u0120if", "\u0120(", "p", "ip", "eline", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120pipeline", "\u0120=", "\u0120build", "P", "ip", "eline", "();", "\u0120}", "\u0120return", "\u0120new", "\u0120Azure", "Bl", "ob", "Storage", "Builder", "()", "\u0120.", "url", "(", "String", ".", "format", "(\"", "%", "s", "/", "%", "s", "/", "%", "s", "\",", "\u0120endpoint", ",", "\u0120container", "Name", ",", "\u0120blob", "Name", "))", "\u0120.", "p", "ip", "eline", "(", "p", "ip", "eline", ")", "\u0120.", "build", "();", "\u0120}"], "docstring_tokens": ["Impl", "Ut", "ils", "\u0120has", "\u0120a", "\u0120is", "Null", "Or", "Empty", "\u0120method", "\u0120that", "\u0120should", "\u0120handle", "\u0120these", "\u0120checks", "."]}
{"function": "public void testLongFileNameThatDoesNotRequireEncoding() { String str = StringUtils.repeat(\"1\", 256); assertEquals( \"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.71634944\", fileManager.getFileName(TaskTestUtil.createMockTask(str), true)); }", "text": "Could you use Strings.repeat or something?", "function_tokens": ["public", "\u0120void", "\u0120test", "Long", "File", "Name", "That", "Does", "Not", "Requ", "ire", "Enc", "oding", "()", "\u0120{", "\u0120String", "\u0120str", "\u0120=", "\u0120String", "Ut", "ils", ".", "repeat", "(\"", "1", "\",", "\u0120256", ");", "\u0120assert", "Equ", "als", "(", "\u0120\"", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "1111", "11", ".", "7", "16", "349", "44", "\",", "\u0120file", "Manager", ".", "get", "File", "Name", "(", "Task", "Test", "Ut", "il", ".", "create", "M", "ock", "Task", "(", "str", "),", "\u0120true", "));", "\u0120}"], "docstring_tokens": ["Could", "\u0120you", "\u0120use", "\u0120Str", "ings", ".", "repeat", "\u0120or", "\u0120something", "?"]}
{"function": "public boolean applyCSSProperty(Object element, String property, CSSValue value, String pseudo, CSSEngine engine) throws Exception { if (!(element instanceof ISelectionBackgroundCustomizationElement && element instanceof ElementAdapter) || !(((ElementAdapter) element).getNativeWidget() instanceof Widget) || property == null || value.getCssValueType() != CSSValue.CSS_PRIMITIVE_VALUE) { return false; } Widget widget = (Widget) ((ElementAdapter) element).getNativeWidget(); ISelectionBackgroundCustomizationElement treeElement = (ISelectionBackgroundCustomizationElement) element; Color newColor = (Color) engine.convert(value, Color.class, widget.getDisplay()); switch (property.toLowerCase()) { case SWT_SELECTION_FOREGROUND_COLOR: treeElement.setSelectionForegroundColor(newColor); break; case SWT_SELECTION_BACKGROUND_COLOR: treeElement.setSelectionBackgroundColor(newColor); break; case SWT_SELECTION_BORDER_COLOR: treeElement.setSelectionBorderColor(newColor); break; case SWT_HOT_BACKGROUND_COLOR: treeElement.setHotBackgroundColor(newColor); break; case SWT_HOT_BORDER_COLOR: treeElement.setHotBorderColor(newColor); break; } return true; }", "text": "the original code does not make toLowerCase(). Why did you add it?", "function_tokens": ["public", "\u0120boolean", "\u0120apply", "CSS", "Property", "(", "Object", "\u0120element", ",", "\u0120String", "\u0120property", ",", "\u0120CSS", "Value", "\u0120value", ",", "\u0120String", "\u0120pseudo", ",", "\u0120CS", "SE", "ng", "ine", "\u0120engine", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120if", "\u0120(!", "(", "element", "\u0120instance", "of", "\u0120IS", "election", "Background", "Custom", "ization", "Element", "\u0120&&", "\u0120element", "\u0120instance", "of", "\u0120Element", "Adapter", ")", "\u0120||", "\u0120!", "((", "(", "Element", "Adapter", ")", "\u0120element", ").", "get", "Native", "Widget", "()", "\u0120instance", "of", "\u0120W", "idget", ")", "\u0120||", "\u0120property", "\u0120==", "\u0120null", "\u0120||", "\u0120value", ".", "get", "C", "ss", "Value", "Type", "()", "\u0120!=", "\u0120CSS", "Value", ".", "CSS", "_", "PR", "IM", "IT", "IVE", "_", "VALUE", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120W", "idget", "\u0120widget", "\u0120=", "\u0120(", "Widget", ")", "\u0120((", "Element", "Adapter", ")", "\u0120element", ").", "get", "Native", "Widget", "();", "\u0120IS", "election", "Background", "Custom", "ization", "Element", "\u0120tree", "Element", "\u0120=", "\u0120(", "IS", "election", "Background", "Custom", "ization", "Element", ")", "\u0120element", ";", "\u0120Color", "\u0120new", "Color", "\u0120=", "\u0120(", "Color", ")", "\u0120engine", ".", "con", "vert", "(", "value", ",", "\u0120Color", ".", "class", ",", "\u0120widget", ".", "get", "Display", "());", "\u0120switch", "\u0120(", "property", ".", "to", "Lower", "Case", "())", "\u0120{", "\u0120case", "\u0120SW", "T", "_", "SELECT", "ION", "_", "FORE", "GROUND", "_", "COLOR", ":", "\u0120tree", "Element", ".", "set", "Se", "lection", "Fore", "ground", "Color", "(", "new", "Color", ");", "\u0120break", ";", "\u0120case", "\u0120SW", "T", "_", "SELECT", "ION", "_", "BACK", "GROUND", "_", "COLOR", ":", "\u0120tree", "Element", ".", "set", "Se", "lection", "Background", "Color", "(", "new", "Color", ");", "\u0120break", ";", "\u0120case", "\u0120SW", "T", "_", "SELECT", "ION", "_", "B", "ORD", "ER", "_", "COLOR", ":", "\u0120tree", "Element", ".", "set", "Se", "lection", "Border", "Color", "(", "new", "Color", ");", "\u0120break", ";", "\u0120case", "\u0120SW", "T", "_", "H", "OT", "_", "BACK", "GROUND", "_", "COLOR", ":", "\u0120tree", "Element", ".", "set", "Hot", "Background", "Color", "(", "new", "Color", ");", "\u0120break", ";", "\u0120case", "\u0120SW", "T", "_", "H", "OT", "_", "B", "ORD", "ER", "_", "COLOR", ":", "\u0120tree", "Element", ".", "set", "Hot", "Border", "Color", "(", "new", "Color", ");", "\u0120break", ";", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["the", "\u0120original", "\u0120code", "\u0120does", "\u0120not", "\u0120make", "\u0120to", "Lower", "Case", "().", "\u0120Why", "\u0120did", "\u0120you", "\u0120add", "\u0120it", "?"]}
{"function": "public Optional<Guid> getUserIdIfExternal() { return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId()); }", "text": "this can be reduced to protected.", "function_tokens": ["public", "\u0120Optional", "<", "Gu", "id", ">", "\u0120get", "User", "Id", "If", "External", "()", "\u0120{", "\u0120return", "\u0120is", "Internal", "Exec", "ution", "()", "\u0120?", "\u0120Optional", ".", "empty", "()", "\u0120:", "\u0120Optional", ".", "of", "Null", "able", "(", "get", "User", "Id", "());", "\u0120}"], "docstring_tokens": ["this", "\u0120can", "\u0120be", "\u0120reduced", "\u0120to", "\u0120protected", "."]}
{"function": "protected DatabaseName unmarshal0( ReadableChannel channel ) throws IOException { byte nullMarker = channel.get(); if ( nullMarker == 0 ) { return null; } else { int nameLength = (int) channel.get(); byte[] nameBytes = new byte[nameLength]; channel.get( nameBytes, nameLength ); return new DatabaseName( UTF8.decode( nameBytes ) ); } }", "text": "We have a StringMarshal helper class that does all of this UTF8 logic for a string.", "function_tokens": ["protected", "\u0120Database", "Name", "\u0120unm", "arsh", "al", "0", "(", "\u0120Read", "able", "Channel", "\u0120channel", "\u0120)", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120byte", "\u0120null", "Mark", "er", "\u0120=", "\u0120channel", ".", "get", "();", "\u0120if", "\u0120(", "\u0120null", "Mark", "er", "\u0120==", "\u01200", "\u0120)", "\u0120{", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120int", "\u0120name", "Length", "\u0120=", "\u0120(", "int", ")", "\u0120channel", ".", "get", "();", "\u0120byte", "[]", "\u0120name", "Bytes", "\u0120=", "\u0120new", "\u0120byte", "[", "name", "Length", "];", "\u0120channel", ".", "get", "(", "\u0120name", "Bytes", ",", "\u0120name", "Length", "\u0120);", "\u0120return", "\u0120new", "\u0120Database", "Name", "(", "\u0120UTF", "8", ".", "dec", "ode", "(", "\u0120name", "Bytes", "\u0120)", "\u0120);", "\u0120}", "\u0120}"], "docstring_tokens": ["We", "\u0120have", "\u0120a", "\u0120String", "Marsh", "al", "\u0120helper", "\u0120class", "\u0120that", "\u0120does", "\u0120all", "\u0120of", "\u0120this", "\u0120UTF", "8", "\u0120logic", "\u0120for", "\u0120a", "\u0120string", "."]}
{"function": "protected <C, R> void doDispatch(CommandMessage<C> command, CommandCallback<? super C, R> callback) { MessageMonitor.MonitorCallback monitorCallback = messageMonitor.onMessageIngested(command); MessageHandler<? super CommandMessage<?>> handler = findCommandHandlerFor(command).orElseThrow(() -> { NoHandlerForCommandException exception = new NoHandlerForCommandException( format(\"No handler was subscribed to command [%s]\", command.getCommandName())); monitorCallback.reportFailure(exception); return exception; }); try { Object result = doDispatch(command, handler); monitorCallback.reportSuccess(); callback.onSuccess(command, (R) result); } catch (Exception throwable) { monitorCallback.reportFailure(throwable); callback.onFailure(command, throwable); } }", "text": "Shouldn't it be No handler was subscribed **for** command?", "function_tokens": ["protected", "\u0120<", "C", ",", "\u0120R", ">", "\u0120void", "\u0120do", "Dispatch", "(", "Command", "Message", "<", "C", ">", "\u0120command", ",", "\u0120Command", "Callback", "<?", "\u0120super", "\u0120C", ",", "\u0120R", ">", "\u0120callback", ")", "\u0120{", "\u0120Message", "Monitor", ".", "Monitor", "Callback", "\u0120monitor", "Callback", "\u0120=", "\u0120message", "Monitor", ".", "on", "Message", "Ing", "ested", "(", "command", ");", "\u0120Message", "Handler", "<?", "\u0120super", "\u0120Command", "Message", "<?", ">>", "\u0120handler", "\u0120=", "\u0120find", "Command", "Handler", "For", "(", "command", ").", "or", "Else", "Throw", "(", "()", "\u0120->", "\u0120{", "\u0120No", "Handler", "For", "Command", "Exception", "\u0120exception", "\u0120=", "\u0120new", "\u0120No", "Handler", "For", "Command", "Exception", "(", "\u0120format", "(\"", "No", "\u0120handler", "\u0120was", "\u0120subscribed", "\u0120to", "\u0120command", "\u0120[", "%", "s", "]", "\",", "\u0120command", ".", "get", "Command", "Name", "()", "));", "\u0120monitor", "Callback", ".", "report", "Failure", "(", "ex", "ception", ");", "\u0120return", "\u0120exception", ";", "\u0120});", "\u0120try", "\u0120{", "\u0120Object", "\u0120result", "\u0120=", "\u0120do", "Dispatch", "(", "command", ",", "\u0120handler", ");", "\u0120monitor", "Callback", ".", "report", "Success", "();", "\u0120callback", ".", "on", "Success", "(", "command", ",", "\u0120(", "R", ")", "\u0120result", ");", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120throw", "able", ")", "\u0120{", "\u0120monitor", "Callback", ".", "report", "Failure", "(", "throw", "able", ");", "\u0120callback", ".", "on", "Failure", "(", "command", ",", "\u0120throw", "able", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120it", "\u0120be", "\u0120No", "\u0120handler", "\u0120was", "\u0120subscribed", "\u0120**", "for", "**", "\u0120command", "?"]}
{"function": "private void processNewResponses() throws InterruptedException, IOException { SocketServerResponse curr = (SocketServerResponse) channel.receiveResponse(id); while (curr != null) { curr.onDequeueFromResponseQueue(); SocketServerRequest request = (SocketServerRequest) curr.getRequest(); String connectionId = request.getConnectionId(); try { if (curr.getPayload() == null) { logger.trace(\"Socket server received no response and hence closing the connection\"); selector.close(connectionId); } else { logger.trace(\"Socket server received response to send, registering for write: {}\", curr); NetworkSend networkSend = new NetworkSend(connectionId, curr.getPayload(), curr.getMetrics(), time); selector.send(networkSend); } } catch (IllegalStateException e) { logger .error(\"Attempt to write to socket for which there is no open connection. Connection id {}\", connectionId); } finally { curr = (SocketServerResponse) channel.receiveResponse(id); } } }", "text": "This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.", "function_tokens": ["private", "\u0120void", "\u0120process", "New", "Resp", "ons", "es", "()", "\u0120throws", "\u0120Inter", "rupted", "Exception", ",", "\u0120IO", "Exception", "\u0120{", "\u0120Socket", "Server", "Response", "\u0120cur", "r", "\u0120=", "\u0120(", "Socket", "Server", "Response", ")", "\u0120channel", ".", "re", "ceive", "Response", "(", "id", ");", "\u0120while", "\u0120(", "cur", "r", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120cur", "r", ".", "on", "De", "queue", "From", "Response", "Queue", "();", "\u0120Socket", "Server", "Request", "\u0120request", "\u0120=", "\u0120(", "Socket", "Server", "Request", ")", "\u0120cur", "r", ".", "get", "Request", "();", "\u0120String", "\u0120connection", "Id", "\u0120=", "\u0120request", ".", "get", "Connection", "Id", "();", "\u0120try", "\u0120{", "\u0120if", "\u0120(", "cur", "r", ".", "get", "Pay", "load", "()", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "trace", "(\"", "Socket", "\u0120server", "\u0120received", "\u0120no", "\u0120response", "\u0120and", "\u0120hence", "\u0120closing", "\u0120the", "\u0120connection", "\");", "\u0120selector", ".", "close", "(", "connection", "Id", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120logger", ".", "trace", "(\"", "Socket", "\u0120server", "\u0120received", "\u0120response", "\u0120to", "\u0120send", ",", "\u0120registering", "\u0120for", "\u0120write", ":", "\u0120{}", "\",", "\u0120cur", "r", ");", "\u0120Network", "Send", "\u0120network", "Send", "\u0120=", "\u0120new", "\u0120Network", "Send", "(", "connection", "Id", ",", "\u0120cur", "r", ".", "get", "Pay", "load", "(),", "\u0120cur", "r", ".", "get", "Met", "rics", "(),", "\u0120time", ");", "\u0120selector", ".", "send", "(", "network", "Send", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Il", "legal", "State", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", "\u0120.", "error", "(\"", "Attempt", "\u0120to", "\u0120write", "\u0120to", "\u0120socket", "\u0120for", "\u0120which", "\u0120there", "\u0120is", "\u0120no", "\u0120open", "\u0120connection", ".", "\u0120Connection", "\u0120id", "\u0120{}", "\",", "\u0120connection", "Id", ");", "\u0120}", "\u0120finally", "\u0120{", "\u0120cur", "r", "\u0120=", "\u0120(", "Socket", "Server", "Response", ")", "\u0120channel", ".", "re", "ceive", "Response", "(", "id", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120is", "\u0120again", "\u0120an", "\u0120assumption", ".", "\u0120Anything", "\u0120in", "\u0120the", "\u0120try", "\u0120block", "\u0120can", "\u0120throw", "\u0120Illegal", "State", "Exception", "\u0120right", "?", "\u0120I", "\u0120would", "\u0120suggest", "\u0120logging", "\u0120the", "\u0120exception", "\u0120message", "\u0120here", "."]}
{"function": "public static boolean postHasEdits(@Nullable PostImmutableModel oldPost, PostImmutableModel newPost) { if (oldPost == null) { return newPost != null; } return newPost == null || !(StringUtils.equals(oldPost.getTitle(), newPost.getTitle()) && StringUtils.equals(oldPost.getContent(), newPost.getContent()) && StringUtils.equals(oldPost.getExcerpt(), newPost.getExcerpt()) && StringUtils.equals(oldPost.getStatus(), newPost.getStatus()) && StringUtils.equals(oldPost.getPassword(), newPost.getPassword()) && StringUtils.equals(oldPost.getPostFormat(), newPost.getPostFormat()) && StringUtils.equals(oldPost.getDateCreated(), newPost.getDateCreated()) && StringUtils.equals(oldPost.getSlug(), newPost.getSlug()) && oldPost.getFeaturedImageId() == newPost.getFeaturedImageId() && oldPost.getTagNameList().containsAll(newPost.getTagNameList()) && newPost.getTagNameList().containsAll(oldPost.getTagNameList()) && oldPost.getCategoryIdList().containsAll(newPost.getCategoryIdList()) && newPost.getCategoryIdList().containsAll(oldPost.getCategoryIdList()) && oldPost.getLocation().equals(newPost.getLocation()) && oldPost.getChangesConfirmedContentHashcode() == newPost .getChangesConfirmedContentHashcode() ); }", "text": "Shouldn't we call PostLocation.companion.equals here?", "function_tokens": ["public", "\u0120static", "\u0120boolean", "\u0120post", "Has", "Ed", "its", "(", "@", "Null", "able", "\u0120Post", "Imm", "utable", "Model", "\u0120old", "Post", ",", "\u0120Post", "Imm", "utable", "Model", "\u0120new", "Post", ")", "\u0120{", "\u0120if", "\u0120(", "old", "Post", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120new", "Post", "\u0120!=", "\u0120null", ";", "\u0120}", "\u0120return", "\u0120new", "Post", "\u0120==", "\u0120null", "\u0120||", "\u0120!", "(", "String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Title", "(),", "\u0120new", "Post", ".", "get", "Title", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Content", "(),", "\u0120new", "Post", ".", "get", "Content", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Ex", "cerpt", "(),", "\u0120new", "Post", ".", "get", "Ex", "cerpt", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Status", "(),", "\u0120new", "Post", ".", "get", "Status", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Password", "(),", "\u0120new", "Post", ".", "get", "Password", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Post", "Format", "(),", "\u0120new", "Post", ".", "get", "Post", "Format", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Date", "Created", "(),", "\u0120new", "Post", ".", "get", "Date", "Created", "())", "\u0120&&", "\u0120String", "Ut", "ils", ".", "equ", "als", "(", "old", "Post", ".", "get", "Sl", "ug", "(),", "\u0120new", "Post", ".", "get", "Sl", "ug", "())", "\u0120&&", "\u0120old", "Post", ".", "get", "Featured", "Image", "Id", "()", "\u0120==", "\u0120new", "Post", ".", "get", "Featured", "Image", "Id", "()", "\u0120&&", "\u0120old", "Post", ".", "get", "Tag", "Name", "List", "().", "cont", "ains", "All", "(", "new", "Post", ".", "get", "Tag", "Name", "List", "())", "\u0120&&", "\u0120new", "Post", ".", "get", "Tag", "Name", "List", "().", "cont", "ains", "All", "(", "old", "Post", ".", "get", "Tag", "Name", "List", "())", "\u0120&&", "\u0120old", "Post", ".", "get", "Category", "Id", "List", "().", "cont", "ains", "All", "(", "new", "Post", ".", "get", "Category", "Id", "List", "())", "\u0120&&", "\u0120new", "Post", ".", "get", "Category", "Id", "List", "().", "cont", "ains", "All", "(", "old", "Post", ".", "get", "Category", "Id", "List", "())", "\u0120&&", "\u0120old", "Post", ".", "get", "Location", "().", "equ", "als", "(", "new", "Post", ".", "get", "Location", "())", "\u0120&&", "\u0120old", "Post", ".", "get", "Changes", "Conf", "irmed", "Content", "Hash", "code", "()", "\u0120==", "\u0120new", "Post", "\u0120.", "get", "Changes", "Conf", "irmed", "Content", "Hash", "code", "()", "\u0120);", "\u0120}"], "docstring_tokens": ["Should", "n", "'t", "\u0120we", "\u0120call", "\u0120Post", "Location", ".", "compan", "ion", ".", "equ", "als", "\u0120here", "?"]}
{"function": "public void noConflictTable() throws Exception, UpdateException { long baseline = System.currentTimeMillis(); final DataBuilderProvider.DataBuilder builder = DataBuilderProvider .row(-1, true); for (int i = 0; i < 1000; i++) { builder .row(i, true); } final Object[][] end = builder.end(); long now = System.currentTimeMillis(); System.out.println(\"Loading of model took.. \" + (now - baseline) + \" ms\"); baseline = now; final GuidedDecisionTable52 table52 = analyzerProvider.makeAnalyser() .withPersonAgeColumn(\"==\") .withPersonApprovedActionSetField() .withData(end) .buildTable(); now = System.currentTimeMillis(); System.out.println(\"Made table.. \" + (now - baseline) + \" ms\"); baseline = now; final Analyzer analyzer = analyzerProvider.makeAnalyser(table52); now = System.currentTimeMillis(); System.out.println(\"Indexing.. \" + (now - baseline) + \" ms\"); baseline = now; analyzer.analyze(); now = System.currentTimeMillis(); System.out.println(\"Validated.. \" + (now - baseline) + \" ms\"); baseline = now; table52.getData() .get(1) .get(2) .setNumericValue(3); List<Coordinate> updates = new ArrayList<>(); updates.add(new Coordinate(1, 2)); analyzerProvider.getUpdateManager(table52, analyzer) .update(table52, updates); now = System.currentTimeMillis(); System.out.println(\"Update.. \" + (now - baseline) + \" ms\"); assertContains(REDUNDANT_ROWS, analyzerProvider.getAnalysisReport()); }", "text": "Please don't use sysout. Logging is your friend.", "function_tokens": ["public", "\u0120void", "\u0120no", "Conf", "lict", "Table", "()", "\u0120throws", "\u0120Exception", ",", "\u0120Update", "Exception", "\u0120{", "\u0120long", "\u0120baseline", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120final", "\u0120Data", "Builder", "Provider", ".", "Data", "Builder", "\u0120builder", "\u0120=", "\u0120Data", "Builder", "Provider", "\u0120.", "row", "(-", "1", ",", "\u0120true", ");", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u01201000", ";", "\u0120i", "++)", "\u0120{", "\u0120builder", "\u0120.", "row", "(", "i", ",", "\u0120true", ");", "\u0120}", "\u0120final", "\u0120Object", "[", "][", "]", "\u0120end", "\u0120=", "\u0120builder", ".", "end", "();", "\u0120long", "\u0120now", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120System", ".", "out", ".", "println", "(\"", "Loading", "\u0120of", "\u0120model", "\u0120took", "..", "\u0120\"", "\u0120+", "\u0120(", "now", "\u0120-", "\u0120baseline", ")", "\u0120+", "\u0120\"", "\u0120ms", "\");", "\u0120baseline", "\u0120=", "\u0120now", ";", "\u0120final", "\u0120Gu", "ided", "Dec", "ision", "Table", "52", "\u0120table", "52", "\u0120=", "\u0120analy", "zer", "Provider", ".", "make", "An", "alys", "er", "()", "\u0120.", "with", "Person", "Age", "Column", "(\"", "==", "\")", "\u0120.", "with", "Person", "App", "ro", "ved", "Action", "Set", "Field", "()", "\u0120.", "with", "Data", "(", "end", ")", "\u0120.", "build", "Table", "();", "\u0120now", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120System", ".", "out", ".", "println", "(\"", "Made", "\u0120table", "..", "\u0120\"", "\u0120+", "\u0120(", "now", "\u0120-", "\u0120baseline", ")", "\u0120+", "\u0120\"", "\u0120ms", "\");", "\u0120baseline", "\u0120=", "\u0120now", ";", "\u0120final", "\u0120Analy", "zer", "\u0120analy", "zer", "\u0120=", "\u0120analy", "zer", "Provider", ".", "make", "An", "alys", "er", "(", "table", "52", ");", "\u0120now", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120System", ".", "out", ".", "println", "(\"", "Index", "ing", "..", "\u0120\"", "\u0120+", "\u0120(", "now", "\u0120-", "\u0120baseline", ")", "\u0120+", "\u0120\"", "\u0120ms", "\");", "\u0120baseline", "\u0120=", "\u0120now", ";", "\u0120analy", "zer", ".", "analy", "ze", "();", "\u0120now", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120System", ".", "out", ".", "println", "(\"", "Val", "idated", "..", "\u0120\"", "\u0120+", "\u0120(", "now", "\u0120-", "\u0120baseline", ")", "\u0120+", "\u0120\"", "\u0120ms", "\");", "\u0120baseline", "\u0120=", "\u0120now", ";", "\u0120table", "52", ".", "get", "Data", "()", "\u0120.", "get", "(", "1", ")", "\u0120.", "get", "(", "2", ")", "\u0120.", "set", "N", "umeric", "Value", "(", "3", ");", "\u0120List", "<", "Co", "ordinate", ">", "\u0120updates", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120updates", ".", "add", "(", "new", "\u0120Coord", "inate", "(", "1", ",", "\u01202", "));", "\u0120analy", "zer", "Provider", ".", "get", "Update", "Manager", "(", "table", "52", ",", "\u0120analy", "zer", ")", "\u0120.", "update", "(", "table", "52", ",", "\u0120updates", ");", "\u0120now", "\u0120=", "\u0120System", ".", "current", "Time", "Mill", "is", "();", "\u0120System", ".", "out", ".", "println", "(\"", "Update", "..", "\u0120\"", "\u0120+", "\u0120(", "now", "\u0120-", "\u0120baseline", ")", "\u0120+", "\u0120\"", "\u0120ms", "\");", "\u0120assert", "Cont", "ains", "(", "RED", "UN", "D", "ANT", "_", "R", "OWS", ",", "\u0120analy", "zer", "Provider", ".", "get", "Analysis", "Report", "());", "\u0120}"], "docstring_tokens": ["Please", "\u0120don", "'t", "\u0120use", "\u0120sys", "out", ".", "\u0120Log", "ging", "\u0120is", "\u0120your", "\u0120friend", "."]}
{"function": "private void makeDependences(Job job, Map<String, ArrayList<String>> dependencies) throws JobCreationException { if (dependencies != null && dependencies.size() > 0 && job.getType() == JobType.TASKSFLOW) { TaskFlowJob tfj = (TaskFlowJob) job; for (Task t : tfj.getTasks()) { ArrayList<String> names = dependencies.get(t.getName()); if (names != null) { for (String name : names) { if (tfj.getTask(name) == null) { throw new JobCreationException(\"Unknown dependence: \" + name); } else { t.addDependence(tfj.getTask(name)); } } } } } }", "text": "You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException(\"Unknown dependence: \" + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException(\"Unknown dependence: \" + name));", "function_tokens": ["private", "\u0120void", "\u0120make", "D", "epend", "ences", "(", "Job", "\u0120job", ",", "\u0120Map", "<", "String", ",", "\u0120Array", "List", "<", "String", ">>", "\u0120dependencies", ")", "\u0120throws", "\u0120Job", "Cre", "ation", "Exception", "\u0120{", "\u0120if", "\u0120(", "depend", "encies", "\u0120!=", "\u0120null", "\u0120&&", "\u0120dependencies", ".", "size", "()", "\u0120>", "\u01200", "\u0120&&", "\u0120job", ".", "get", "Type", "()", "\u0120==", "\u0120Job", "Type", ".", "T", "AS", "KS", "FL", "OW", ")", "\u0120{", "\u0120Task", "Flow", "Job", "\u0120tf", "j", "\u0120=", "\u0120(", "Task", "Flow", "Job", ")", "\u0120job", ";", "\u0120for", "\u0120(", "Task", "\u0120t", "\u0120:", "\u0120tf", "j", ".", "get", "T", "asks", "())", "\u0120{", "\u0120Array", "List", "<", "String", ">", "\u0120names", "\u0120=", "\u0120dependencies", ".", "get", "(", "t", ".", "get", "Name", "());", "\u0120if", "\u0120(", "names", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "String", "\u0120name", "\u0120:", "\u0120names", ")", "\u0120{", "\u0120if", "\u0120(", "tf", "j", ".", "get", "Task", "(", "name", ")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Job", "Cre", "ation", "Exception", "(\"", "Unknown", "\u0120dependence", ":", "\u0120\"", "\u0120+", "\u0120name", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120t", ".", "add", "D", "ependence", "(", "tf", "j", ".", "get", "Task", "(", "name", "));", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["You", "\u0120can", "\u0120replace", "\u0120java", "\u0120if", "\u0120(", "tf", "j", ".", "get", "Task", "(", "name", ")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Job", "Cre", "ation", "Exception", "(\"", "Unknown", "\u0120dependence", ":", "\u0120\"", "\u0120+", "\u0120name", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120t", ".", "add", "D", "ependence", "(", "tf", "j", ".", "get", "Task", "(", "name", "));", "\u0120}", "\u0120", "\u0120by", "\u0120java", "\u0120t", ".", "add", "D", "ependence", "(", "Optional", ".", "of", "Null", "able", "(", "tf", "j", ".", "get", "Task", "(", "name", ")).", "or", "Throw", "(", "\u0120()", "\u0120->", "\u0120new", "\u0120Job", "Cre", "ation", "Exception", "(\"", "Unknown", "\u0120dependence", ":", "\u0120\"", "\u0120+", "\u0120name", "));"]}
{"function": "private SubPlan reassignPartitioningHandleIfNecessaryHelper(Session session, Metadata metadata, SubPlan subPlan, PartitioningHandle newOutputPartitioningHandle) { PlanFragment fragment = subPlan.getFragment(); PartitioningHandleReassigner partitioningHandleReassigner = new PartitioningHandleReassigner(fragment.getPartitioning(), metadata, session); PlanNode newRoot; if (fragment.getPartitioning().isSingleNode()) { newRoot = fragment.getRoot(); } else { newRoot = SimplePlanRewriter.rewriteWith(partitioningHandleReassigner, fragment.getRoot()); } PartitioningScheme outputPartitioningScheme = fragment.getPartitioningScheme(); Partitioning newOutputPartitioning = outputPartitioningScheme.getPartitioning(); if (outputPartitioningScheme.getPartitioning().getHandle().getConnectorId().isPresent()) { newOutputPartitioning = newOutputPartitioning.withAlternativePartitiongingHandle(newOutputPartitioningHandle); } PlanFragment newFragment = new PlanFragment( fragment.getId(), newRoot, fragment.getSymbols(), fragment.getPartitioning(), fragment.getPartitionedSources(), new PartitioningScheme( newOutputPartitioning, outputPartitioningScheme.getOutputLayout(), outputPartitioningScheme.getHashColumn(), outputPartitioningScheme.isReplicateNullsAndAny(), outputPartitioningScheme.getBucketToPartition()), fragment.getStageExecutionStrategy(), fragment.getStatsAndCosts()); ImmutableList.Builder<SubPlan> childrenBuilder = ImmutableList.builder(); for (SubPlan child : subPlan.getChildren()) { childrenBuilder.add(reassignPartitioningHandleIfNecessaryHelper(session, metadata, child, fragment.getPartitioning())); } return new SubPlan(newFragment, childrenBuilder.build()); }", "text": "Should the condition here and the condition on 153 the same?", "function_tokens": ["private", "\u0120Sub", "Plan", "\u0120reass", "ign", "Part", "ition", "ing", "Handle", "If", "N", "ec", "ess", "ary", "Helper", "(", "Session", "\u0120session", ",", "\u0120Met", "adata", "\u0120metadata", ",", "\u0120Sub", "Plan", "\u0120sub", "Plan", ",", "\u0120Part", "ition", "ing", "Handle", "\u0120new", "Output", "Part", "ition", "ing", "Handle", ")", "\u0120{", "\u0120Plan", "Frag", "ment", "\u0120fragment", "\u0120=", "\u0120sub", "Plan", ".", "get", "Frag", "ment", "();", "\u0120Part", "ition", "ing", "Handle", "Re", "ass", "ign", "er", "\u0120partition", "ing", "Handle", "Re", "ass", "ign", "er", "\u0120=", "\u0120new", "\u0120Part", "ition", "ing", "Handle", "Re", "ass", "ign", "er", "(", "fr", "ag", "ment", ".", "get", "Part", "ition", "ing", "(),", "\u0120metadata", ",", "\u0120session", ");", "\u0120Plan", "Node", "\u0120new", "Root", ";", "\u0120if", "\u0120(", "fr", "ag", "ment", ".", "get", "Part", "ition", "ing", "().", "is", "Single", "Node", "())", "\u0120{", "\u0120new", "Root", "\u0120=", "\u0120fragment", ".", "get", "Root", "();", "\u0120}", "\u0120else", "\u0120{", "\u0120new", "Root", "\u0120=", "\u0120Simple", "Plan", "Rew", "riter", ".", "rew", "rite", "With", "(", "part", "ition", "ing", "Handle", "Re", "ass", "ign", "er", ",", "\u0120fragment", ".", "get", "Root", "());", "\u0120}", "\u0120Part", "ition", "ing", "Sche", "me", "\u0120output", "Part", "ition", "ing", "Sche", "me", "\u0120=", "\u0120fragment", ".", "get", "Part", "ition", "ing", "Sche", "me", "();", "\u0120Part", "ition", "ing", "\u0120new", "Output", "Part", "ition", "ing", "\u0120=", "\u0120output", "Part", "ition", "ing", "Sche", "me", ".", "get", "Part", "ition", "ing", "();", "\u0120if", "\u0120(", "output", "Part", "ition", "ing", "Sche", "me", ".", "get", "Part", "ition", "ing", "().", "get", "Handle", "().", "get", "Connector", "Id", "().", "is", "Present", "())", "\u0120{", "\u0120new", "Output", "Part", "ition", "ing", "\u0120=", "\u0120new", "Output", "Part", "ition", "ing", ".", "with", "Alternative", "Part", "ition", "ging", "Handle", "(", "new", "Output", "Part", "ition", "ing", "Handle", ");", "\u0120}", "\u0120Plan", "Frag", "ment", "\u0120new", "Frag", "ment", "\u0120=", "\u0120new", "\u0120Plan", "Frag", "ment", "(", "\u0120fragment", ".", "get", "Id", "(),", "\u0120new", "Root", ",", "\u0120fragment", ".", "get", "Sy", "mb", "ols", "(),", "\u0120fragment", ".", "get", "Part", "ition", "ing", "(),", "\u0120fragment", ".", "get", "Part", "ition", "ed", "Sources", "(),", "\u0120new", "\u0120Part", "ition", "ing", "Sche", "me", "(", "\u0120new", "Output", "Part", "ition", "ing", ",", "\u0120output", "Part", "ition", "ing", "Sche", "me", ".", "get", "Output", "Layout", "(),", "\u0120output", "Part", "ition", "ing", "Sche", "me", ".", "get", "Hash", "Column", "(),", "\u0120output", "Part", "ition", "ing", "Sche", "me", ".", "is", "Repl", "icate", "Null", "s", "And", "Any", "(),", "\u0120output", "Part", "ition", "ing", "Sche", "me", ".", "get", "B", "ucket", "To", "Part", "ition", "()", "),", "\u0120fragment", ".", "get", "Stage", "Exec", "ution", "Str", "ategy", "(),", "\u0120fragment", ".", "get", "Stats", "And", "Cost", "s", "());", "\u0120Imm", "utable", "List", ".", "Builder", "<", "Sub", "Plan", ">", "\u0120children", "Builder", "\u0120=", "\u0120Imm", "utable", "List", ".", "builder", "();", "\u0120for", "\u0120(", "Sub", "Plan", "\u0120child", "\u0120:", "\u0120sub", "Plan", ".", "get", "Children", "())", "\u0120{", "\u0120children", "Builder", ".", "add", "(", "re", "ass", "ign", "Part", "ition", "ing", "Handle", "If", "N", "ec", "ess", "ary", "Helper", "(", "session", ",", "\u0120metadata", ",", "\u0120child", ",", "\u0120fragment", ".", "get", "Part", "ition", "ing", "()", "));", "\u0120}", "\u0120return", "\u0120new", "\u0120Sub", "Plan", "(", "new", "Frag", "ment", ",", "\u0120children", "Builder", ".", "build", "());", "\u0120}"], "docstring_tokens": ["Should", "\u0120the", "\u0120condition", "\u0120here", "\u0120and", "\u0120the", "\u0120condition", "\u0120on", "\u0120153", "\u0120the", "\u0120same", "?"]}
{"function": "public void doPolling(Guid cmdId, List<Guid> childCmdIds) { RebootVmCommand<P> command = getCommand(cmdId); boolean anyFailed = false; for (Guid childCmdId : childCmdIds) { CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId); switch (entity.getCommandStatus()) { case FAILED: case FAILED_RESTARTED: case UNKNOWN: anyFailed = true; break; default: break; } } if (anyFailed) { command.setCommandStatus(CommandStatus.FAILED); } else { VM vm = DbFacade.getInstance().getVmDao().get(command.getParameters().getVmId()); if (isVmDownForColdReboot(vm)) { command.proceedWithColdRun(); } } }", "text": "what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..", "function_tokens": ["public", "\u0120void", "\u0120do", "Poll", "ing", "(", "Gu", "id", "\u0120cmd", "Id", ",", "\u0120List", "<", "Gu", "id", ">", "\u0120child", "Cmd", "Id", "s", ")", "\u0120{", "\u0120Reboot", "V", "m", "Command", "<", "P", ">", "\u0120command", "\u0120=", "\u0120get", "Command", "(", "cmd", "Id", ");", "\u0120boolean", "\u0120any", "F", "ailed", "\u0120=", "\u0120false", ";", "\u0120for", "\u0120(", "Gu", "id", "\u0120child", "Cmd", "Id", "\u0120:", "\u0120child", "Cmd", "Id", "s", ")", "\u0120{", "\u0120Command", "Entity", "\u0120entity", "\u0120=", "\u0120Command", "Co", "ord", "inator", "Ut", "il", ".", "get", "Command", "Entity", "(", "child", "Cmd", "Id", ");", "\u0120switch", "\u0120(", "entity", ".", "get", "Command", "Status", "())", "\u0120{", "\u0120case", "\u0120FA", "IL", "ED", ":", "\u0120case", "\u0120FA", "IL", "ED", "_", "R", "EST", "ART", "ED", ":", "\u0120case", "\u0120UN", "KNOWN", ":", "\u0120any", "F", "ailed", "\u0120=", "\u0120true", ";", "\u0120break", ";", "\u0120default", ":", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "any", "F", "ailed", ")", "\u0120{", "\u0120command", ".", "set", "Command", "Status", "(", "Command", "Status", ".", "FA", "IL", "ED", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120VM", "\u0120vm", "\u0120=", "\u0120D", "b", "Fac", "ade", ".", "get", "Instance", "().", "get", "V", "m", "D", "ao", "().", "get", "(", "command", ".", "get", "Parameters", "().", "get", "V", "m", "Id", "());", "\u0120if", "\u0120(", "is", "V", "m", "Down", "For", "Cold", "Reb", "oot", "(", "vm", "))", "\u0120{", "\u0120command", ".", "pro", "ceed", "With", "Cold", "Run", "();", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["what", "\u0120if", "\u0120the", "\u0120VM", "\u0120is", "\u0120highly", "-", "available", "\u0120(", "so", "\u0120it", "\u0120was", "\u0120automatically", "\u0120restart", "ed", ")", "\u0120or", "\u0120the", "\u0120user", "\u0120managed", "\u0120to", "\u0120run", "\u0120the", "\u0120VM", "\u0120before", "\u0120coc", "o", "\u0120got", "\u0120it", "?", "\u0120I", "\u0120think", "\u0120this", "\u0120command", "\u0120should", "\u0120lock", "\u0120the", "\u0120VM", "\u0120but", "\u0120it", "\u0120is", "\u0120tricky", ".."]}
{"function": "public void run() { if (!mServiceConnection.isBound()) { mServiceConnection.unBindService(mContext); mCallback.onError(new AuthenticationException(ADALError.BROKER_BIND_SERVICE_FAILED)); } }", "text": "It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120if", "\u0120(!", "m", "Service", "Connection", ".", "is", "Bound", "())", "\u0120{", "\u0120m", "Service", "Connection", ".", "un", "Bind", "Service", "(", "m", "Context", ");", "\u0120m", "Callback", ".", "on", "Error", "(", "new", "\u0120Authentication", "Exception", "(", "AD", "AL", "Error", ".", "BR", "OK", "ER", "_", "B", "IND", "_", "SER", "VICE", "_", "FA", "IL", "ED", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["It", "'s", "\u0120unclear", "\u0120to", "\u0120me", "\u0120what", "'s", "\u0120going", "\u0120on", "\u0120here", ".", "\u0120This", "\u0120appears", "\u0120to", "\u0120check", "\u0120that", "\u0120the", "\u0120service", "\u0120*", "is", "n", "'t", "*", "\u0120bound", "\u0120before", "\u0120calling", "\u0120un", "bind", "Service", "(", "Context", ")."]}
{"function": "public int hashCode() { return Objects.hash(machine, content); }", "text": "-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.", "function_tokens": ["public", "\u0120int", "\u0120hash", "Code", "()", "\u0120{", "\u0120return", "\u0120Objects", ".", "hash", "(", "machine", ",", "\u0120content", ");", "\u0120}"], "docstring_tokens": ["-", "1", "\u0120for", "\u0120using", "\u0120Objects", ".", "hash", "(", "...)", "\u0120for", "\u0120hash", "codes", ",", "\u0120as", "\u0120it", "\u0120will", "\u0120create", "\u0120an", "\u0120array", "\u0120and", "\u0120i", "\u0120think", "\u0120that", "\u0120it", "\u0120is", "\u0120important", "\u0120to", "\u0120make", "\u0120such", "\u0120thin", "\u0120places", "\u0120as", "\u0120cheaper", "\u0120as", "\u0120possible", ".", "\u0120If", "\u0120you", "\u0120define", "\u0120hash", "code", "\u0120for", "\u0120Log", "Message", ",", "\u0120then", "\u0120it", "\u0120is", "\u0120useful", "\u0120to", "\u0120use", "\u0120this", "\u0120message", "\u0120in", "\u0120collections", "\u0120or", "\u0120sm", "th", ",", "\u0120and", "\u0120based", "\u0120on", "\u0120log", "\u0120message", "\u0120nature", "\u0120you", "\u0120will", "\u0120have", "\u0120to", "\u0120deal", "\u0120with", "\u0120tons", "\u0120of", "\u0120those", "\u0120messages", ".", "\u0120Check", "out", "\u0120[", "this", "](", "<", "L", "INK", "_", "0", ">", "\u0120for", "\u0120generating", "\u0120cheaper", "\u0120hash", "code", "."]}
{"function": "private Stream<Map<Address, InternalCacheEntry<K, V>>> getConflicts(LocalizedCacheTopology topology) { if (stateConsumer.isStateTransferInProgress()) throw log.getConflictsStateTransferInProgress(cacheName); if (!streamInProgress.compareAndSet(false, true)) throw log.getConflictsAlreadyInProgress(); try { return StreamSupport .stream(new ReplicaSpliterator(topology), false) .filter(filterConsistentEntries()); } finally { streamInProgress.compareAndSet(true, false); } }", "text": "isn't the topology always a LocalizedCacheTopology?", "function_tokens": ["private", "\u0120Stream", "<", "Map", "<", "Address", ",", "\u0120Internal", "Cache", "Entry", "<", "K", ",", "\u0120V", ">>>", "\u0120get", "Conf", "licts", "(", "Local", "ized", "Cache", "Top", "ology", "\u0120top", "ology", ")", "\u0120{", "\u0120if", "\u0120(", "state", "Consumer", ".", "is", "State", "Transfer", "In", "Progress", "())", "\u0120throw", "\u0120log", ".", "get", "Conf", "licts", "State", "Transfer", "In", "Progress", "(", "cache", "Name", ");", "\u0120if", "\u0120(!", "stream", "In", "Progress", ".", "comp", "are", "And", "Set", "(", "false", ",", "\u0120true", "))", "\u0120throw", "\u0120log", ".", "get", "Conf", "licts", "Already", "In", "Progress", "();", "\u0120try", "\u0120{", "\u0120return", "\u0120Stream", "Support", "\u0120.", "stream", "(", "new", "\u0120Repl", "ica", "Spl", "iterator", "(", "top", "ology", "),", "\u0120false", ")", "\u0120.", "filter", "(", "filter", "Cons", "istent", "Ent", "ries", "());", "\u0120}", "\u0120finally", "\u0120{", "\u0120stream", "In", "Progress", ".", "comp", "are", "And", "Set", "(", "true", ",", "\u0120false", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["is", "n", "'t", "\u0120the", "\u0120top", "ology", "\u0120always", "\u0120a", "\u0120Local", "ized", "Cache", "Top", "ology", "?"]}
{"function": "public void testMergeRunnersEnsureGroupMerging() throws Exception { GroupByQuery query = GroupByQuery .builder() .setDataSource(\"xx\") .setQuerySegmentSpec(new LegacySegmentSpec(\"1970/3000\")) .setGranularity(QueryGranularities.ALL) .setDimensions(Lists.<DimensionSpec>newArrayList(new DefaultDimensionSpec(\"tags\", \"tags\"))) .setAggregatorSpecs( Arrays.asList( new AggregatorFactory[] { new CountAggregatorFactory(\"count\") } ) ) .build(); final QueryRunnerFactory factory = GroupByQueryRunnerTest.makeQueryRunnerFactory(new GroupByQueryConfig()); QueryRunner mergedRunner = factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { return factory.getToolchest().mergeResults( new QueryRunner() { @Override public Sequence run(Query query, Map responseContext) { try { return new MergeSequence( query.getResultOrdering(), Sequences.simple( Arrays.asList( factory.createRunner(createSegment()).run(query, responseContext), factory.createRunner(createSegment()).run(query, responseContext) ) ) ); } catch (Exception e) { Assert.fail(e.getMessage()); return null; } } } ).run(query, responseContext); } } ); Sequence<Row> result = mergedRunner.run(query, Maps.newHashMap()); List<Row> expectedResults = Arrays.asList( GroupByQueryRunnerTestHelper.createExpectedRow(\"1970-01-01T00:00:00.000Z\", \"tags\", \"t1\", \"count\", 2L), GroupByQueryRunnerTestHelper.createExpectedRow(\"1970-01-01T00:00:00.000Z\", \"tags\", \"t2\", \"count\", 4L) ); TestHelper.assertExpectedObjects(expectedResults, Sequences.toList(result, new ArrayList<Row>()), \"\"); }", "text": "Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e)", "function_tokens": ["public", "\u0120void", "\u0120test", "Mer", "ge", "Run", "ners", "En", "sure", "Group", "Mer", "ging", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Group", "By", "Query", "\u0120query", "\u0120=", "\u0120Group", "By", "Query", "\u0120.", "builder", "()", "\u0120.", "set", "Data", "Source", "(\"", "xx", "\")", "\u0120.", "set", "Query", "Seg", "ment", "Spec", "(", "new", "\u0120Legacy", "Seg", "ment", "Spec", "(\"", "1970", "/", "3000", "\"))", "\u0120.", "set", "G", "ran", "ularity", "(", "Query", "G", "ran", "ular", "ities", ".", "ALL", ")", "\u0120.", "set", "Dim", "ensions", "(", "L", "ists", ".<", "Dim", "ension", "Spec", ">", "new", "Array", "List", "(", "new", "\u0120Default", "Dim", "ension", "Spec", "(\"", "tags", "\",", "\u0120\"", "tags", "\"", ")))", "\u0120.", "set", "Agg", "reg", "ator", "Spe", "cs", "(", "\u0120Ar", "rays", ".", "as", "List", "(", "\u0120new", "\u0120Agg", "reg", "ator", "Factory", "[]", "\u0120{", "\u0120new", "\u0120Count", "Agg", "reg", "ator", "Factory", "(\"", "count", "\")", "\u0120}", "\u0120)", "\u0120)", "\u0120.", "build", "();", "\u0120final", "\u0120Query", "Runner", "Factory", "\u0120factory", "\u0120=", "\u0120Group", "By", "Query", "Runner", "Test", ".", "make", "Query", "Runner", "Factory", "(", "new", "\u0120Group", "By", "Query", "Config", "());", "\u0120Query", "Runner", "\u0120merged", "Runner", "\u0120=", "\u0120factory", ".", "get", "Tool", "chest", "().", "mer", "ge", "Results", "(", "\u0120new", "\u0120Query", "Runner", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Sequence", "\u0120run", "(", "Query", "\u0120query", ",", "\u0120Map", "\u0120response", "Context", ")", "\u0120{", "\u0120return", "\u0120factory", ".", "get", "Tool", "chest", "().", "mer", "ge", "Results", "(", "\u0120new", "\u0120Query", "Runner", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120Sequence", "\u0120run", "(", "Query", "\u0120query", ",", "\u0120Map", "\u0120response", "Context", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120return", "\u0120new", "\u0120Merge", "Sequ", "ence", "(", "\u0120query", ".", "get", "Result", "Order", "ing", "(),", "\u0120Sequ", "ences", ".", "simple", "(", "\u0120Ar", "rays", ".", "as", "List", "(", "\u0120factory", ".", "create", "Runner", "(", "create", "Seg", "ment", "()", ").", "run", "(", "query", ",", "\u0120response", "Context", "),", "\u0120factory", ".", "create", "Runner", "(", "create", "Seg", "ment", "()", ").", "run", "(", "query", ",", "\u0120response", "Context", ")", "\u0120)", "\u0120)", "\u0120);", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120Ass", "ert", ".", "fail", "(", "e", ".", "get", "Message", "());", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120}", "\u0120}", "\u0120).", "run", "(", "query", ",", "\u0120response", "Context", ");", "\u0120}", "\u0120}", "\u0120);", "\u0120Sequence", "<", "Row", ">", "\u0120result", "\u0120=", "\u0120merged", "Runner", ".", "run", "(", "query", ",", "\u0120Maps", ".", "new", "Hash", "Map", "());", "\u0120List", "<", "Row", ">", "\u0120expected", "Results", "\u0120=", "\u0120Ar", "rays", ".", "as", "List", "(", "\u0120Group", "By", "Query", "Runner", "Test", "Helper", ".", "create", "Ex", "pected", "Row", "(\"", "1970", "-", "01", "-", "01", "T", "00", ":", "00", ":", "00", ".", "000", "Z", "\",", "\u0120\"", "tags", "\",", "\u0120\"", "t", "1", "\",", "\u0120\"", "count", "\",", "\u01202", "L", "),", "\u0120Group", "By", "Query", "Runner", "Test", "Helper", ".", "create", "Ex", "pected", "Row", "(\"", "1970", "-", "01", "-", "01", "T", "00", ":", "00", ":", "00", ".", "000", "Z", "\",", "\u0120\"", "tags", "\",", "\u0120\"", "t", "2", "\",", "\u0120\"", "count", "\",", "\u01204", "L", ")", "\u0120);", "\u0120Test", "Helper", ".", "assert", "Ex", "pected", "Object", "s", "(", "expected", "Results", ",", "\u0120Sequ", "ences", ".", "to", "List", "(", "result", ",", "\u0120new", "\u0120Array", "List", "<", "Row", ">", "()", "),", "\u0120\"\"", ");", "\u0120}"], "docstring_tokens": ["Ass", "ert", ".", "fail", "\u0120inside", "\u0120a", "\u0120callback", "\u0120like", "\u0120this", "\u0120seems", "\u0120kinda", "\u0120weird", "\u0120--", "\u0120usually", "\u0120asserts", "\u0120run", "\u0120inside", "\u0120the", "\u0120main", "\u0120test", "\u0120code", ".", "\u0120Would", "\u0120it", "\u0120work", "\u0120if", "\u0120this", "\u0120is", "\u0120just", "\u0120a", "\u0120re", "-", "throw", "?", "\u0120Like", "\u0120throw", "\u0120Throw", "ables", ".", "prop", "agate", "(", "e", ")"]}
{"function": "public WTextAreaUI() { panel.add(messages); WFieldLayout fieldLayout = new WFieldLayout(LAYOUT_FLAT); fieldLayout.setTitle(\"this is a bunch of fields\"); WTextArea wTextField = new WTextArea(); fieldLayout.addField(\"this is a textarea\", wTextField); wTextField.setMandatory(true); panel.add(fieldLayout); add(createWButton()); add(panel); }", "text": "Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?", "function_tokens": ["public", "\u0120W", "Text", "Area", "UI", "()", "\u0120{", "\u0120panel", ".", "add", "(", "mess", "ages", ");", "\u0120W", "Field", "Layout", "\u0120field", "Layout", "\u0120=", "\u0120new", "\u0120W", "Field", "Layout", "(", "L", "AY", "OUT", "_", "FL", "AT", ");", "\u0120field", "Layout", ".", "set", "Title", "(\"", "this", "\u0120is", "\u0120a", "\u0120bunch", "\u0120of", "\u0120fields", "\");", "\u0120W", "Text", "Area", "\u0120w", "Text", "Field", "\u0120=", "\u0120new", "\u0120W", "Text", "Area", "();", "\u0120field", "Layout", ".", "add", "Field", "(\"", "this", "\u0120is", "\u0120a", "\u0120text", "area", "\",", "\u0120w", "Text", "Field", ");", "\u0120w", "Text", "Field", ".", "set", "Mand", "atory", "(", "true", ");", "\u0120panel", ".", "add", "(", "field", "Layout", ");", "\u0120add", "(", "create", "W", "Button", "());", "\u0120add", "(", "panel", ");", "\u0120}"], "docstring_tokens": ["Copy", "-", "paste", "\u0120and", "\u0120you", "\u0120haven", "'t", "\u0120changed", "\u0120the", "\u0120member", "\u0120name", ".", "\u0120Is", "\u0120it", "\u0120wise", "\u0120to", "\u0120have", "\u0120a", "\u0120W", "Text", "Area", "\u0120called", "\u0120w", "Text", "Field", "?"]}
{"function": "public String toString() { StringBuilder result = new StringBuilder(\"[Test: \\\"\" + m_name + \"\\\"\").append(\" verbose:\").append(m_verbose); result.append(\"[parameters:\"); for (Map.Entry<String, String> entry : m_parameters.entrySet()) { result.append(entry.getKey()).append(\"=>\").append(entry.getValue()); } result.append(\"]\"); result.append(\"[metagroups:\"); for (Map.Entry<String, List<String>> entry : m_metaGroups.entrySet()) { result.append(entry.getKey()).append(\"=\"); for (String n : entry.getValue()) { result.append(n).append(\",\"); } } result.append(\"] \"); result.append(\"[included: \"); for (String g : m_includedGroups) { result.append(g).append(\" \"); } result.append(\"]\"); result.append(\"[excluded: \"); for (String g : m_excludedGroups) { result.append(g).append(\"\"); } result.append(\"] \"); result.append(\" classes:\"); for (XmlClass cl : m_xmlClasses) { result.append(cl).append(\" \"); } result.append(\" packages:\"); for (XmlPackage p : m_xmlPackages) { result.append(p).append(\" \"); } result.append(\"] \"); return result.toString(); }", "text": "You missed new StringBuilder().append(\"[Test: \\\"\").append(m_name).append(\"\\\"\")", "function_tokens": ["public", "\u0120String", "\u0120to", "String", "()", "\u0120{", "\u0120String", "Builder", "\u0120result", "\u0120=", "\u0120new", "\u0120String", "Builder", "(\"", "[", "Test", ":", "\u0120\\", "\"\"", "\u0120+", "\u0120m", "_", "name", "\u0120+", "\u0120\"", "\\\"", "\").", "append", "(\"", "\u0120verb", "ose", ":", "\").", "append", "(", "m", "_", "verb", "ose", ");", "\u0120result", ".", "append", "(\"", "[", "param", "eters", ":\"", ");", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120String", ">", "\u0120entry", "\u0120:", "\u0120m", "_", "param", "eters", ".", "entry", "Set", "())", "\u0120{", "\u0120result", ".", "append", "(", "entry", ".", "get", "Key", "()", ").", "append", "(\"", "=>", "\").", "append", "(", "entry", ".", "get", "Value", "());", "\u0120}", "\u0120result", ".", "append", "(\"", "]", "\");", "\u0120result", ".", "append", "(\"", "[", "met", "ag", "roups", ":\"", ");", "\u0120for", "\u0120(", "Map", ".", "Entry", "<", "String", ",", "\u0120List", "<", "String", ">>", "\u0120entry", "\u0120:", "\u0120m", "_", "meta", "G", "roups", ".", "entry", "Set", "())", "\u0120{", "\u0120result", ".", "append", "(", "entry", ".", "get", "Key", "()", ").", "append", "(\"", "=\"", ");", "\u0120for", "\u0120(", "String", "\u0120n", "\u0120:", "\u0120entry", ".", "get", "Value", "())", "\u0120{", "\u0120result", ".", "append", "(", "n", ").", "append", "(", "\",\"", ");", "\u0120}", "\u0120}", "\u0120result", ".", "append", "(\"", "]", "\u0120\"", ");", "\u0120result", ".", "append", "(\"", "[", "in", "cluded", ":", "\u0120\"", ");", "\u0120for", "\u0120(", "String", "\u0120g", "\u0120:", "\u0120m", "_", "in", "cluded", "G", "roups", ")", "\u0120{", "\u0120result", ".", "append", "(", "g", ").", "append", "(\"", "\u0120\"", ");", "\u0120}", "\u0120result", ".", "append", "(\"", "]", "\");", "\u0120result", ".", "append", "(\"", "[", "ex", "cluded", ":", "\u0120\"", ");", "\u0120for", "\u0120(", "String", "\u0120g", "\u0120:", "\u0120m", "_", "ex", "cluded", "G", "roups", ")", "\u0120{", "\u0120result", ".", "append", "(", "g", ").", "append", "(\"", "\");", "\u0120}", "\u0120result", ".", "append", "(\"", "]", "\u0120\"", ");", "\u0120result", ".", "append", "(\"", "\u0120classes", ":\"", ");", "\u0120for", "\u0120(", "X", "ml", "Class", "\u0120cl", "\u0120:", "\u0120m", "_", "xml", "Class", "es", ")", "\u0120{", "\u0120result", ".", "append", "(", "cl", ").", "append", "(\"", "\u0120\"", ");", "\u0120}", "\u0120result", ".", "append", "(\"", "\u0120packages", ":\"", ");", "\u0120for", "\u0120(", "X", "ml", "Package", "\u0120p", "\u0120:", "\u0120m", "_", "xml", "Pack", "ages", ")", "\u0120{", "\u0120result", ".", "append", "(", "p", ").", "append", "(\"", "\u0120\"", ");", "\u0120}", "\u0120result", ".", "append", "(\"", "]", "\u0120\"", ");", "\u0120return", "\u0120result", ".", "to", "String", "();", "\u0120}"], "docstring_tokens": ["You", "\u0120missed", "\u0120new", "\u0120String", "Builder", "().", "append", "(\"", "[", "Test", ":", "\u0120\\\"", "\").", "append", "(", "m", "_", "name", ").", "append", "(\"", "\\\"", "\")"]}
{"function": "public void testRename() throws Exception { typeContext = new LabelClientTypeContext(store, LabelType.METRIC, metrics, eventBus, MAX_CACHE_SIZE); final LabelId labelId = typeContext.createId(\"oldName\").get(); ListenableFuture<Void> response = typeContext.rename(\"oldName\", \"newName\"); Futures.addCallback(response, new FutureCallback<Void>() { @Override public void onSuccess(final Void result) { Futures.addCallback(typeContext.getName(labelId), new FutureCallback<Optional<String>>() { @Override public void onSuccess(final Optional<String> result) { if (!result.isPresent()) { fail(); } assertEquals(\"newName\", result.get()); } @Override public void onFailure(final Throwable throwable) { fail(); } }); } @Override public void onFailure(final Throwable throwable) { fail(); } }); }", "text": "See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.", "function_tokens": ["public", "\u0120void", "\u0120test", "R", "ename", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120type", "Context", "\u0120=", "\u0120new", "\u0120Label", "Client", "Type", "Context", "(", "store", ",", "\u0120Label", "Type", ".", "MET", "RIC", ",", "\u0120metrics", ",", "\u0120event", "Bus", ",", "\u0120MAX", "_", "C", "AC", "HE", "_", "SIZE", ");", "\u0120final", "\u0120Label", "Id", "\u0120label", "Id", "\u0120=", "\u0120type", "Context", ".", "create", "Id", "(\"", "old", "Name", "\").", "get", "();", "\u0120Listen", "able", "Future", "<", "V", "oid", ">", "\u0120response", "\u0120=", "\u0120type", "Context", ".", "ren", "ame", "(\"", "old", "Name", "\",", "\u0120\"", "new", "Name", "\");", "\u0120Fut", "ures", ".", "add", "Callback", "(", "response", ",", "\u0120new", "\u0120Future", "Callback", "<", "V", "oid", ">", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Success", "(", "final", "\u0120Void", "\u0120result", ")", "\u0120{", "\u0120Fut", "ures", ".", "add", "Callback", "(", "type", "Context", ".", "get", "Name", "(", "label", "Id", "),", "\u0120new", "\u0120Future", "Callback", "<", "Optional", "<", "String", ">>", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Success", "(", "final", "\u0120Optional", "<", "String", ">", "\u0120result", ")", "\u0120{", "\u0120if", "\u0120(!", "result", ".", "is", "Present", "())", "\u0120{", "\u0120fail", "();", "\u0120}", "\u0120assert", "Equ", "als", "(\"", "new", "Name", "\",", "\u0120result", ".", "get", "());", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Failure", "(", "final", "\u0120Throw", "able", "\u0120throw", "able", ")", "\u0120{", "\u0120fail", "();", "\u0120}", "\u0120});", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120on", "Failure", "(", "final", "\u0120Throw", "able", "\u0120throw", "able", ")", "\u0120{", "\u0120fail", "();", "\u0120}", "\u0120});", "\u0120}"], "docstring_tokens": ["See", "\u0120above", "\u0120about", "\u0120not", "\u0120blocking", "\u0120the", "\u0120calls", "\u0120for", "\u0120futures", ".", "\u0120In", "\u0120any", "\u0120case", "\u0120it", "\u0120is", "\u0120probably", "\u0120less", "\u0120verb", "ose", "\u0120to", "\u0120just", "\u0120block", "\u0120and", "\u0120work", "\u0120with", "\u0120the", "\u0120result", "\u0120directly", ".", "\u0120Also", ",", "\u0120the", "\u0120contract", "\u0120for", "\u0120Store", "#", "ren", "ame", "Label", "\u0120is", "\u0120that", "\u0120if", "\u0120one", "\u0120checks", "\u0120that", "\u0120the", "\u0120current", "\u0120name", "\u0120exists", "\u0120and", "\u0120the", "\u0120new", "\u0120name", "\u0120does", "\u0120not", "\u0120exist", "\u0120before", "\u0120a", "\u0120call", "\u0120to", "\u0120it", ",", "\u0120then", "\u0120if", "\u0120the", "\u0120#", "ren", "ame", "Label", "\u0120call", "\u0120returns", "\u0120successfully", "\u0120and", "\u0120the", "\u0120future", "\u0120does", "\u0120not", "\u0120contain", "\u0120an", "\u0120exception", ",", "\u0120then", "\u0120the", "\u0120label", "\u0120should", "\u0120have", "\u0120been", "\u0120renamed", ".", "\u0120This", "\u0120means", "\u0120it", "\u0120is", "\u0120not", "\u0120strictly", "\u0120necessary", "\u0120to", "\u0120test", "\u0120that", "\u0120the", "\u0120label", "\u0120is", "\u0120renamed", "\u0120here", ",", "\u0120it", "'s", "\u0120enough", "\u0120to", "\u0120call", "\u0120#", "ren", "ame", "\u0120and", "\u0120block", "\u0120on", "\u0120it", "\u0120to", "\u0120make", "\u0120sure", "\u0120it", "\u0120does", "\u0120not", "\u0120contain", "\u0120an", "\u0120exception", "."]}
{"function": "public void setLibraryAliasGenerator(NameGenerator<Library> generator) { this.libraryAliasGenerator = (DefaultLibraryAliasGenerator) generator; }", "text": "Remove cast", "function_tokens": ["public", "\u0120void", "\u0120set", "Library", "Alias", "Gener", "ator", "(", "Name", "Gener", "ator", "<", "Library", ">", "\u0120generator", ")", "\u0120{", "\u0120this", ".", "library", "Alias", "Gener", "ator", "\u0120=", "\u0120(", "Default", "Library", "Alias", "Gener", "ator", ")", "\u0120generator", ";", "\u0120}"], "docstring_tokens": ["Remove", "\u0120cast"]}
{"function": "public Set<Field> getFields() { return fields.keySet(); }", "text": "What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.", "function_tokens": ["public", "\u0120Set", "<", "Field", ">", "\u0120get", "Field", "s", "()", "\u0120{", "\u0120return", "\u0120fields", ".", "key", "Set", "();", "\u0120}"], "docstring_tokens": ["What", "'s", "\u0120the", "\u0120reason", "\u0120for", "\u0120this", "\u0120change", "?", "\u0120We", "\u0120want", "\u0120people", "\u0120to", "\u0120use", "\u0120set", "Field", "s", "\u0120to", "\u0120change", "\u0120the", "\u0120fields", ",", "\u0120so", "\u0120it", "'s", "\u0120good", "\u0120practice", "\u0120to", "\u0120return", "\u0120un", "mod", "if", "able", "Set", "\u0120here", "."]}
{"function": "protected void deleteLog() { CommandContext commandContext = new CommandContext(); commandContext.setData(\"SingleRun\", \"true\"); commandContext.setData(\"OlderThan\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); synchronized (this) { jobServicesClient.scheduleRequest(CONTAINER_ID, JobRequestInstance.builder().command(\"org.jbpm.executor.commands.LogCleanupCommand\").build()); } }", "text": "This commandContext seems unused.", "function_tokens": ["protected", "\u0120void", "\u0120delete", "Log", "()", "\u0120{", "\u0120Command", "Context", "\u0120command", "Context", "\u0120=", "\u0120new", "\u0120Command", "Context", "();", "\u0120command", "Context", ".", "set", "Data", "(\"", "Single", "Run", "\",", "\u0120\"", "true", "\");", "\u0120command", "Context", ".", "set", "Data", "(\"", "O", "lder", "Th", "an", "\",", "\u0120new", "\u0120Simple", "Date", "Format", "(\"", "yy", "yy", "-", "MM", "-", "dd", "\u0120HH", ":", "mm", ":", "ss", "\").", "format", "(", "new", "\u0120Date", "()", "));", "\u0120synchronized", "\u0120(", "this", ")", "\u0120{", "\u0120job", "Services", "Client", ".", "sche", "dule", "Request", "(", "CON", "TAIN", "ER", "_", "ID", ",", "\u0120Job", "Request", "Instance", ".", "builder", "().", "command", "(\"", "org", ".", "j", "b", "pm", ".", "exec", "utor", ".", "comm", "ands", ".", "Log", "Clean", "up", "Command", "\").", "build", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["This", "\u0120command", "Context", "\u0120seems", "\u0120unused", "."]}
{"function": "private ContextMenuHandler showContextMenu() { if (contextMenuHandler == null) { contextMenuHandler = event -> { event.preventDefault(); event.stopPropagation(); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().setPopupPosition(event.getNativeEvent().getClientX(), event.getNativeEvent().getClientY()); popup.asPopupPanel().show(); }; } return contextMenuHandler; }", "text": "Twice the same call.", "function_tokens": ["private", "\u0120Context", "Menu", "Handler", "\u0120show", "Context", "Menu", "()", "\u0120{", "\u0120if", "\u0120(", "context", "Menu", "Handler", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120context", "Menu", "Handler", "\u0120=", "\u0120event", "\u0120->", "\u0120{", "\u0120event", ".", "pre", "vent", "Default", "();", "\u0120event", ".", "stop", "Prop", "ag", "ation", "();", "\u0120popup", ".", "as", "Pop", "up", "Panel", "().", "set", "Pop", "up", "Position", "(", "event", ".", "get", "Native", "Event", "().", "get", "Client", "X", "(),", "\u0120event", ".", "get", "Native", "Event", "().", "get", "Client", "Y", "());", "\u0120popup", ".", "as", "Pop", "up", "Panel", "().", "set", "Pop", "up", "Position", "(", "event", ".", "get", "Native", "Event", "().", "get", "Client", "X", "(),", "\u0120event", ".", "get", "Native", "Event", "().", "get", "Client", "Y", "());", "\u0120popup", ".", "as", "Pop", "up", "Panel", "().", "show", "();", "\u0120};", "\u0120}", "\u0120return", "\u0120context", "Menu", "Handler", ";", "\u0120}"], "docstring_tokens": ["Tw", "ice", "\u0120the", "\u0120same", "\u0120call", "."]}
{"function": "protected Control renderControl(SWTGridCell cell, Composite parent) throws NoRendererFoundException, NoPropertyDescriptorFoundExeption { final CTabFolder folder = new CTabFolder(parent, SWT.BOTTOM); folder.setBackground(parent.getBackground()); final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); final AdapterFactoryItemDelegator adapterFactoryItemDelegator = new AdapterFactoryItemDelegator( composedAdapterFactory); final EList<VAbstractCategorization> categorizations = getCategorizations(); for (final VAbstractCategorization categorization : categorizations) { final CTabItem item = new CTabItem(folder, SWT.NULL); final IItemPropertyDescriptor itemPropertyDescriptor = adapterFactoryItemDelegator.getPropertyDescriptor( categorization, VViewPackage.eINSTANCE.getElement_Name()); String categorizationName; if (itemPropertyDescriptor == null) { categorizationName = \"Categorization\"; } else { final PropertyValueWrapper valueWrapper = (PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization); if (valueWrapper == null) { categorizationName = itemPropertyDescriptor.getDisplayName(categorization); } else { categorizationName = (String) ((PropertyValueWrapper) itemPropertyDescriptor .getPropertyValue(categorization)).getEditableValue(categorization); } } item.setText(categorizationName); final AbstractSWTRenderer<VElement> renderer = getSWTRendererFactory().getRenderer(categorization, getViewModelContext()); final SWTGridDescription gridDescription = renderer.getGridDescription(GridDescriptionFactory.INSTANCE .createEmptyGridDescription()); for (final SWTGridCell gridCell : gridDescription.getGrid()) { final Control render = renderer.render(gridCell, folder); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.FILL).grab(true, true) .applyTo(render); item.setControl(render); } } composedAdapterFactory.dispose(); if (folder.getItemCount() > 0) { folder.setSelection(0); } return folder; }", "text": "what is a PropertyValueWrapper? Why do you need it?", "function_tokens": ["protected", "\u0120Control", "\u0120render", "Control", "(", "SW", "TG", "rid", "Cell", "\u0120cell", ",", "\u0120Composite", "\u0120parent", ")", "\u0120throws", "\u0120No", "R", "end", "erer", "Found", "Exception", ",", "\u0120No", "Property", "Desc", "ript", "or", "Found", "Ex", "e", "ption", "\u0120{", "\u0120final", "\u0120CT", "ab", "Folder", "\u0120folder", "\u0120=", "\u0120new", "\u0120CT", "ab", "Folder", "(", "parent", ",", "\u0120SW", "T", ".", "B", "OTT", "OM", ");", "\u0120folder", ".", "set", "Background", "(", "parent", ".", "get", "Background", "());", "\u0120final", "\u0120Comp", "osed", "Adapter", "Factory", "\u0120composed", "Adapter", "Factory", "\u0120=", "\u0120new", "\u0120Comp", "osed", "Adapter", "Factory", "(", "new", "\u0120Adapter", "Factory", "[]", "\u0120{", "\u0120new", "\u0120Reflect", "ive", "Item", "Provider", "Adapter", "Factory", "(),", "\u0120new", "\u0120Comp", "osed", "Adapter", "Factory", "(", "Comp", "osed", "Adapter", "Factory", ".", "Desc", "ript", "or", ".", "Reg", "istry", ".", "INST", "ANCE", ")", "\u0120});", "\u0120final", "\u0120Adapter", "Factory", "Item", "De", "leg", "ator", "\u0120adapter", "Factory", "Item", "De", "leg", "ator", "\u0120=", "\u0120new", "\u0120Adapter", "Factory", "Item", "De", "leg", "ator", "(", "\u0120composed", "Adapter", "Factory", ");", "\u0120final", "\u0120E", "List", "<", "V", "Abstract", "C", "ategor", "ization", ">", "\u0120categor", "izations", "\u0120=", "\u0120get", "C", "ategor", "izations", "();", "\u0120for", "\u0120(", "final", "\u0120V", "Abstract", "C", "ategor", "ization", "\u0120categor", "ization", "\u0120:", "\u0120categor", "izations", ")", "\u0120{", "\u0120final", "\u0120CT", "ab", "Item", "\u0120item", "\u0120=", "\u0120new", "\u0120CT", "ab", "Item", "(", "folder", ",", "\u0120SW", "T", ".", "NULL", ");", "\u0120final", "\u0120I", "Item", "Property", "Desc", "ript", "or", "\u0120item", "Property", "Desc", "ript", "or", "\u0120=", "\u0120adapter", "Factory", "Item", "De", "leg", "ator", ".", "get", "Property", "Desc", "ript", "or", "(", "\u0120categor", "ization", ",", "\u0120V", "View", "Package", ".", "e", "INST", "ANCE", ".", "get", "Element", "_", "Name", "());", "\u0120String", "\u0120categor", "ization", "Name", ";", "\u0120if", "\u0120(", "item", "Property", "Desc", "ript", "or", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120categor", "ization", "Name", "\u0120=", "\u0120\"", "C", "ategor", "ization", "\";", "\u0120}", "\u0120else", "\u0120{", "\u0120final", "\u0120Property", "Value", "Wra", "pper", "\u0120value", "Wra", "pper", "\u0120=", "\u0120(", "Property", "Value", "Wra", "pper", ")", "\u0120item", "Property", "Desc", "ript", "or", "\u0120.", "get", "Property", "Value", "(", "c", "ategor", "ization", ");", "\u0120if", "\u0120(", "value", "Wra", "pper", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120categor", "ization", "Name", "\u0120=", "\u0120item", "Property", "Desc", "ript", "or", ".", "get", "Display", "Name", "(", "c", "ategor", "ization", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120categor", "ization", "Name", "\u0120=", "\u0120(", "String", ")", "\u0120((", "Property", "Value", "Wra", "pper", ")", "\u0120item", "Property", "Desc", "ript", "or", "\u0120.", "get", "Property", "Value", "(", "c", "ategor", "ization", ")).", "get", "Ed", "itable", "Value", "(", "c", "ategor", "ization", ");", "\u0120}", "\u0120}", "\u0120item", ".", "set", "Text", "(", "c", "ategor", "ization", "Name", ");", "\u0120final", "\u0120Abstract", "SW", "TR", "end", "erer", "<", "VE", "lement", ">", "\u0120rend", "erer", "\u0120=", "\u0120get", "SW", "TR", "end", "erer", "Factory", "().", "get", "R", "end", "erer", "(", "c", "ategor", "ization", ",", "\u0120get", "View", "Model", "Context", "());", "\u0120final", "\u0120SW", "TG", "rid", "Description", "\u0120grid", "Description", "\u0120=", "\u0120rend", "erer", ".", "get", "Grid", "Description", "(", "Grid", "Description", "Factory", ".", "INST", "ANCE", "\u0120.", "create", "Empty", "Grid", "Description", "());", "\u0120for", "\u0120(", "final", "\u0120SW", "TG", "rid", "Cell", "\u0120grid", "Cell", "\u0120:", "\u0120grid", "Description", ".", "get", "Grid", "())", "\u0120{", "\u0120final", "\u0120Control", "\u0120render", "\u0120=", "\u0120rend", "erer", ".", "render", "(", "grid", "Cell", ",", "\u0120folder", ");", "\u0120Grid", "Data", "Factory", ".", "fill", "Def", "aults", "().", "align", "(", "SW", "T", ".", "F", "ILL", ",", "\u0120SW", "T", ".", "F", "ILL", ").", "grab", "(", "true", ",", "\u0120true", ")", "\u0120.", "apply", "To", "(", "render", ");", "\u0120item", ".", "set", "Control", "(", "render", ");", "\u0120}", "\u0120}", "\u0120composed", "Adapter", "Factory", ".", "dis", "pose", "();", "\u0120if", "\u0120(", "folder", ".", "get", "Item", "Count", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120folder", ".", "set", "Se", "lection", "(", "0", ");", "\u0120}", "\u0120return", "\u0120folder", ";", "\u0120}"], "docstring_tokens": ["what", "\u0120is", "\u0120a", "\u0120Property", "Value", "Wra", "pper", "?", "\u0120Why", "\u0120do", "\u0120you", "\u0120need", "\u0120it", "?"]}
{"function": "public static void copy(File source, File dest) throws IOException { try (InputStream in = new FileInputStream(source)) { try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } } }", "text": "consider replacing 96-97 with just one try block (see line 455)", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120copy", "(", "File", "\u0120source", ",", "\u0120File", "\u0120dest", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120try", "\u0120(", "Input", "Stream", "\u0120in", "\u0120=", "\u0120new", "\u0120File", "Input", "Stream", "(", "source", "))", "\u0120{", "\u0120try", "\u0120(", "Output", "Stream", "\u0120out", "\u0120=", "\u0120new", "\u0120Buff", "ered", "Output", "Stream", "(", "new", "\u0120File", "Output", "Stream", "(", "dest", ")))", "\u0120{", "\u0120transfer", "Data", "(", "in", ",", "\u0120out", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["consider", "\u0120replacing", "\u012096", "-", "97", "\u0120with", "\u0120just", "\u0120one", "\u0120try", "\u0120block", "\u0120(", "see", "\u0120line", "\u0120455", ")"]}
{"function": "public boolean includeMethod( IMethodSelectorContext context, ITestNGMethod tm, boolean isTestMethod) { if (!m_isInitialized) { m_isInitialized = true; init(context); } if (script != null) { return getScriptSelector(script.getLanguage()).includeMethodFromExpression(script.getExpression(), tm); } return includeMethodFromIncludeExclude(tm, isTestMethod); }", "text": "So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.", "function_tokens": ["public", "\u0120boolean", "\u0120include", "Method", "(", "\u0120IM", "et", "hod", "Select", "or", "Context", "\u0120context", ",", "\u0120IT", "est", "NG", "Method", "\u0120t", "m", ",", "\u0120boolean", "\u0120is", "Test", "Method", ")", "\u0120{", "\u0120if", "\u0120(!", "m", "_", "is", "Initialized", ")", "\u0120{", "\u0120m", "_", "is", "Initialized", "\u0120=", "\u0120true", ";", "\u0120init", "(", "context", ");", "\u0120}", "\u0120if", "\u0120(", "script", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120get", "Script", "Select", "or", "(", "script", ".", "get", "Language", "()", ").", "include", "Method", "From", "Exp", "ression", "(", "script", ".", "get", "Exp", "ression", "(),", "\u0120t", "m", ");", "\u0120}", "\u0120return", "\u0120include", "Method", "From", "In", "clude", "Ex", "clude", "(", "tm", ",", "\u0120is", "Test", "Method", ");", "\u0120}"], "docstring_tokens": ["So", "\u0120we", "\u0120are", "\u0120back", "\u0120to", "\u0120the", "\u0120same", "\u0120perf", "\u0120issue", "\u0120that", "\u0120you", "\u0120mentioned", "\u0120in", "\u0120my", "\u0120PR", "\u0120:)", "\u0120I", "\u0120would", "\u0120be", "\u0120curious", "\u0120to", "\u0120know", "\u0120how", "\u0120do", "\u0120you", "\u0120propose", "\u0120we", "\u0120solve", "\u0120this", "."]}
{"function": "public String getUpload() { Desktop desktop = getDesktop(); String upload = _auxinf != null ? _auxinf.upload : null; if (desktop != null && !Strings.isEmpty(upload) && !upload.contains(\"maxsize=\")) upload = upload.concat(\",maxsize=\" + desktop.getWebApp().getConfiguration().getMaxUploadSize()); return upload; }", "text": "not good to add sth when calling getter", "function_tokens": ["public", "\u0120String", "\u0120get", "Upload", "()", "\u0120{", "\u0120Desktop", "\u0120desktop", "\u0120=", "\u0120get", "Desktop", "();", "\u0120String", "\u0120upload", "\u0120=", "\u0120_", "aux", "inf", "\u0120!=", "\u0120null", "\u0120?", "\u0120_", "aux", "inf", ".", "upload", "\u0120:", "\u0120null", ";", "\u0120if", "\u0120(", "desktop", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "Str", "ings", ".", "is", "Empty", "(", "upload", ")", "\u0120&&", "\u0120!", "upload", ".", "cont", "ains", "(\"", "max", "size", "=\"", "))", "\u0120upload", "\u0120=", "\u0120upload", ".", "con", "cat", "(", "\",", "max", "size", "=\"", "\u0120+", "\u0120desktop", ".", "get", "Web", "App", "().", "get", "Configuration", "().", "get", "Max", "Upload", "Size", "());", "\u0120return", "\u0120upload", ";", "\u0120}"], "docstring_tokens": ["not", "\u0120good", "\u0120to", "\u0120add", "\u0120st", "h", "\u0120when", "\u0120calling", "\u0120get", "ter"]}
{"function": "public void testSendCloseSession() throws Exception { assertTrue(\"Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!\", serverFactory instanceof NettyServerCnxnFactory); try (ZooKeeper zk = createClient()) { final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer(); final String path = \"/a\"; zk.create(path, \"test\".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); assertNotNull(\"Didn't create znode:\" + path, zk.exists(path, true)); assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount()); Iterable<ServerCnxn> connections = serverFactory.getConnections(); assertEquals(\"Mismatch in number of live connections!\", 1, serverFactory.getNumAliveConnections()); for (ServerCnxn serverCnxn : connections) { serverCnxn.sendCloseSession(); } LOG.info(\"Waiting for the channel disconnected event\"); int timeout = 0; while (serverFactory.getNumAliveConnections() != 0) { Thread.sleep(1000); timeout += 1000; if (timeout > CONNECTION_TIMEOUT) { fail(\"The number of live connections should be 0\"); } } assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount()); } }", "text": "Please don't do unrelated refactor work next time", "function_tokens": ["public", "\u0120void", "\u0120test", "Send", "Close", "Session", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120assert", "True", "(\"", "Did", "n", "'t", "\u0120instant", "iate", "\u0120Server", "C", "n", "x", "n", "Factory", "\u0120with", "\u0120Net", "ty", "Server", "C", "n", "x", "n", "Factory", "!\",", "\u0120server", "Factory", "\u0120instance", "of", "\u0120Net", "ty", "Server", "C", "n", "x", "n", "Factory", ");", "\u0120try", "\u0120(", "Z", "oo", "K", "eeper", "\u0120z", "k", "\u0120=", "\u0120create", "Client", "())", "\u0120{", "\u0120final", "\u0120Zoo", "K", "eeper", "Server", "\u0120z", "k", "Server", "\u0120=", "\u0120server", "Factory", ".", "get", "Z", "oo", "K", "eeper", "Server", "();", "\u0120final", "\u0120String", "\u0120path", "\u0120=", "\u0120\"/", "a", "\";", "\u0120z", "k", ".", "create", "(", "path", ",", "\u0120\"", "test", "\".", "get", "Bytes", "(", "Standard", "Ch", "ars", "ets", ".", "UTF", "_", "8", "),", "\u0120Id", "s", ".", "OP", "EN", "_", "AC", "L", "_", "UN", "SA", "FE", ",", "\u0120Create", "Mode", ".", "P", "ERS", "IST", "ENT", ");", "\u0120assert", "Not", "Null", "(\"", "Did", "n", "'t", "\u0120create", "\u0120z", "node", ":\"", "\u0120+", "\u0120path", ",", "\u0120z", "k", ".", "ex", "ists", "(", "path", ",", "\u0120true", "));", "\u0120assert", "Equ", "als", "(", "1", ",", "\u0120z", "k", "Server", ".", "get", "Z", "K", "Database", "().", "get", "Data", "Tree", "().", "get", "Watch", "Count", "());", "\u0120Iter", "able", "<", "Server", "C", "n", "x", "n", ">", "\u0120connections", "\u0120=", "\u0120server", "Factory", ".", "get", "Connect", "ions", "();", "\u0120assert", "Equ", "als", "(\"", "M", "ism", "atch", "\u0120in", "\u0120number", "\u0120of", "\u0120live", "\u0120connections", "!\",", "\u01201", ",", "\u0120server", "Factory", ".", "get", "Num", "Al", "ive", "Connect", "ions", "());", "\u0120for", "\u0120(", "Server", "C", "n", "x", "n", "\u0120server", "C", "n", "x", "n", "\u0120:", "\u0120connections", ")", "\u0120{", "\u0120server", "C", "n", "x", "n", ".", "send", "Close", "Session", "();", "\u0120}", "\u0120LOG", ".", "info", "(\"", "Wa", "iting", "\u0120for", "\u0120the", "\u0120channel", "\u0120disconnected", "\u0120event", "\");", "\u0120int", "\u0120timeout", "\u0120=", "\u01200", ";", "\u0120while", "\u0120(", "server", "Factory", ".", "get", "Num", "Al", "ive", "Connect", "ions", "()", "\u0120!=", "\u01200", ")", "\u0120{", "\u0120Thread", ".", "sleep", "(", "1000", ");", "\u0120timeout", "\u0120+=", "\u01201000", ";", "\u0120if", "\u0120(", "timeout", "\u0120>", "\u0120CON", "N", "ECTION", "_", "TIME", "OUT", ")", "\u0120{", "\u0120fail", "(\"", "The", "\u0120number", "\u0120of", "\u0120live", "\u0120connections", "\u0120should", "\u0120be", "\u01200", "\");", "\u0120}", "\u0120}", "\u0120assert", "Equ", "als", "(", "0", ",", "\u0120z", "k", "Server", ".", "get", "Z", "K", "Database", "().", "get", "Data", "Tree", "().", "get", "Watch", "Count", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["Please", "\u0120don", "'t", "\u0120do", "\u0120unrelated", "\u0120ref", "actor", "\u0120work", "\u0120next", "\u0120time"]}
{"function": "public static SentryStackTraceElement[] fromStackTraceElements(StackTraceElement[] stackTraceElements) { Frame[] localsCache = LocalsCache.getCache(); SentryStackTraceElement[] sentryStackTraceElements = new SentryStackTraceElement[stackTraceElements.length]; boolean mayHaveLocals = localsCache.length == stackTraceElements.length; for (int i = 0; i < stackTraceElements.length; i++) { Map<String, Object> vars = null; if (mayHaveLocals) { Frame frame = localsCache[i]; Frame.LocalVariable[] frameLocals = frame.getLocals(); if (frameLocals != null && frameLocals.length > 0) { for (Frame.LocalVariable localVariable : frameLocals) { if (localVariable != null) { if (vars == null) { vars = new HashMap<>(); } vars.put(localVariable.getName(), localVariable.getValue()); } } } } sentryStackTraceElements[i] = fromStackTraceElement(stackTraceElements[i], vars); } return sentryStackTraceElements; }", "text": "This check seems a little fragile at first glance (not sure why.)", "function_tokens": ["public", "\u0120static", "\u0120Sent", "ry", "Stack", "Tr", "ace", "Element", "[]", "\u0120from", "Stack", "Tr", "ace", "E", "lements", "(", "Stack", "Tr", "ace", "Element", "[]", "\u0120stack", "Tr", "ace", "E", "lements", ")", "\u0120{", "\u0120Frame", "[]", "\u0120locals", "Cache", "\u0120=", "\u0120Loc", "als", "Cache", ".", "get", "Cache", "();", "\u0120Sent", "ry", "Stack", "Tr", "ace", "Element", "[]", "\u0120sent", "ry", "Stack", "Tr", "ace", "E", "lements", "\u0120=", "\u0120new", "\u0120Sent", "ry", "Stack", "Tr", "ace", "Element", "[", "stack", "Tr", "ace", "E", "lements", ".", "length", "];", "\u0120boolean", "\u0120may", "Have", "Loc", "als", "\u0120=", "\u0120locals", "Cache", ".", "length", "\u0120==", "\u0120stack", "Tr", "ace", "E", "lements", ".", "length", ";", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120stack", "Tr", "ace", "E", "lements", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120v", "ars", "\u0120=", "\u0120null", ";", "\u0120if", "\u0120(", "may", "Have", "Loc", "als", ")", "\u0120{", "\u0120Frame", "\u0120frame", "\u0120=", "\u0120locals", "Cache", "[", "i", "];", "\u0120Frame", ".", "Local", "Variable", "[]", "\u0120frame", "Loc", "als", "\u0120=", "\u0120frame", ".", "get", "Loc", "als", "();", "\u0120if", "\u0120(", "frame", "Loc", "als", "\u0120!=", "\u0120null", "\u0120&&", "\u0120frame", "Loc", "als", ".", "length", "\u0120>", "\u01200", ")", "\u0120{", "\u0120for", "\u0120(", "Frame", ".", "Local", "Variable", "\u0120local", "Variable", "\u0120:", "\u0120frame", "Loc", "als", ")", "\u0120{", "\u0120if", "\u0120(", "local", "Variable", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "v", "ars", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120v", "ars", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120}", "\u0120v", "ars", ".", "put", "(", "local", "Variable", ".", "get", "Name", "(),", "\u0120local", "Variable", ".", "get", "Value", "());", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120sent", "ry", "Stack", "Tr", "ace", "E", "lements", "[", "i", "]", "\u0120=", "\u0120from", "Stack", "Tr", "ace", "Element", "(", "stack", "Tr", "ace", "E", "lements", "[", "i", "],", "\u0120v", "ars", ");", "\u0120}", "\u0120return", "\u0120sent", "ry", "Stack", "Tr", "ace", "E", "lements", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120check", "\u0120seems", "\u0120a", "\u0120little", "\u0120fragile", "\u0120at", "\u0120first", "\u0120glance", "\u0120(", "not", "\u0120sure", "\u0120why", ".)"]}
{"function": "public void runBeforeAllTests() { conceptService = Context.getConceptService(); executeDataSet(STANDARD_TEST_DATASET_XML); }", "text": "Isn't this dataset automatically executed?", "function_tokens": ["public", "\u0120void", "\u0120run", "Before", "All", "T", "ests", "()", "\u0120{", "\u0120concept", "Service", "\u0120=", "\u0120Context", ".", "get", "Con", "cept", "Service", "();", "\u0120execute", "Data", "Set", "(", "ST", "AND", "ARD", "_", "T", "EST", "_", "D", "AT", "AS", "ET", "_", "X", "ML", ");", "\u0120}"], "docstring_tokens": ["Isn", "'t", "\u0120this", "\u0120dataset", "\u0120automatically", "\u0120executed", "?"]}
{"function": "public static void setParamsWithRegistrationConfigurationMappings(RegistrationConfiguration registrationConfiguration, ImportFromConfParameters params) { if (registrationConfiguration.getAffinityGroupMappings() != null && registrationConfiguration.isSetAffinityGroupMappings()) { Map<String, Object> affinityGroupMap = new HashMap<>(); affinityGroupMap.put(AFFINITY_GROUP_KEY, mapAffinityGroupMapping(registrationConfiguration.getAffinityGroupMappings())); params.setAffinityGroupMap(affinityGroupMap); } if (registrationConfiguration.getAffinityLabelMappings() != null && registrationConfiguration.isSetAffinityLabelMappings()) { Map<String, Object> affinityLabelMap = new HashMap<>(); affinityLabelMap.put(AFFINITY_LABEL_KEY, mapAffinityLabelMapping(registrationConfiguration.getAffinityLabelMappings())); params.setAffinityLabelMap(affinityLabelMap); } if (registrationConfiguration.getClusterMappings() != null && registrationConfiguration.isSetClusterMappings()) { Map<String, Object> clusterMap = new HashMap<>(); clusterMap.put(CLUSTER_KEY, mapClusterMapping(registrationConfiguration.getClusterMappings())); params.setClusterMap(clusterMap); } if (registrationConfiguration.getLunMapping() != null && registrationConfiguration.isSetLunMapping()) { Map<String, Object> lunMap = new HashMap<>(); lunMap.put(EXTERNAL_LUN_KEY, mapExternalLunMapping(registrationConfiguration.getLunMapping())); params.setExternalLunMap(lunMap); } if (registrationConfiguration.getRoleMappings() != null && registrationConfiguration.isSetRoleMappings()) { Map<String, Object> roleMap = new HashMap<>(); roleMap.put(ROLE_KEY, mapExternalRoleMapping(registrationConfiguration.getRoleMappings())); params.setRoleMap(roleMap); } if (registrationConfiguration.getDomainMappings() != null && registrationConfiguration.isSetDomainMappings()) { Map<String, Object> domainMap = new HashMap<>(); domainMap.put(DOMAIN_KEY, mapExternalDomainMapping(registrationConfiguration.getDomainMappings())); params.setDomainMap(domainMap); } }", "text": "If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to \"params.setAffinityGroupMap\" directly the result of \"mapAffinityGroupMapping\": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120set", "Par", "ams", "With", "Registration", "Configuration", "M", "appings", "(", "Registration", "Configuration", "\u0120registration", "Configuration", ",", "\u0120Import", "From", "Conf", "Parameters", "\u0120params", ")", "\u0120{", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "Aff", "inity", "Group", "M", "appings", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "Aff", "inity", "Group", "M", "appings", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120affinity", "Group", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120affinity", "Group", "Map", ".", "put", "(", "A", "FF", "IN", "ITY", "_", "GROUP", "_", "KEY", ",", "\u0120map", "Aff", "inity", "Group", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "Aff", "inity", "Group", "M", "appings", "()", "));", "\u0120params", ".", "set", "Aff", "inity", "Group", "Map", "(", "aff", "inity", "Group", "Map", ");", "\u0120}", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "Aff", "inity", "Label", "M", "appings", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "Aff", "inity", "Label", "M", "appings", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120affinity", "Label", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120affinity", "Label", "Map", ".", "put", "(", "A", "FF", "IN", "ITY", "_", "LAB", "EL", "_", "KEY", ",", "\u0120map", "Aff", "inity", "Label", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "Aff", "inity", "Label", "M", "appings", "()", "));", "\u0120params", ".", "set", "Aff", "inity", "Label", "Map", "(", "aff", "inity", "Label", "Map", ");", "\u0120}", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "Cl", "uster", "M", "appings", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "Cl", "uster", "M", "appings", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120cluster", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120cluster", "Map", ".", "put", "(", "CL", "UST", "ER", "_", "KEY", ",", "\u0120map", "Cl", "uster", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "Cl", "uster", "M", "appings", "()", "));", "\u0120params", ".", "set", "Cl", "uster", "Map", "(", "cl", "uster", "Map", ");", "\u0120}", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "L", "un", "M", "apping", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "L", "un", "M", "apping", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120lun", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120lun", "Map", ".", "put", "(", "EX", "TERN", "AL", "_", "L", "UN", "_", "KEY", ",", "\u0120map", "External", "L", "un", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "L", "un", "M", "apping", "()", "));", "\u0120params", ".", "set", "External", "L", "un", "Map", "(", "l", "un", "Map", ");", "\u0120}", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "Role", "M", "appings", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "Role", "M", "appings", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120role", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120role", "Map", ".", "put", "(", "RO", "LE", "_", "KEY", ",", "\u0120map", "External", "Role", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "Role", "M", "appings", "()", "));", "\u0120params", ".", "set", "Role", "Map", "(", "role", "Map", ");", "\u0120}", "\u0120if", "\u0120(", "reg", "istration", "Configuration", ".", "get", "Domain", "M", "appings", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120registration", "Configuration", ".", "is", "Set", "Domain", "M", "appings", "())", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Object", ">", "\u0120domain", "Map", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", ">", "();", "\u0120domain", "Map", ".", "put", "(", "DOM", "AIN", "_", "KEY", ",", "\u0120map", "External", "Domain", "M", "apping", "(", "reg", "istration", "Configuration", ".", "get", "Domain", "M", "appings", "()", "));", "\u0120params", ".", "set", "Domain", "Map", "(", "domain", "Map", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["If", "\u0120I", "\u0120understand", "\u0120correctly", "\u0120the", "\u0120*", "_", "KEY", "\u0120strings", "\u0120aren", "'t", "\u0120needed", "\u0120now", ",", "\u0120and", "\u0120what", "\u0120you", "\u0120want", "\u0120to", "\u0120do", "\u0120here", "\u0120is", "\u0120pass", "\u0120to", "\u0120\"", "params", ".", "set", "Aff", "inity", "Group", "Map", "\"", "\u0120directly", "\u0120the", "\u0120result", "\u0120of", "\u0120\"", "map", "Aff", "inity", "Group", "M", "apping", "\":", "\u0120params", ".", "set", "Aff", "inity", "Group", "Map", "(", "map", "Aff", "inity", "Group", "M", "apping", "(", "...", "));", "\u0120What", "\u0120am", "\u0120I", "\u0120missing", "?"]}
{"function": "private void fillDriverSpecificChannelConfiguration(final Tocd mainOcd, final List<Tad> driverSpecificChannelConfiguration) { final ChannelDescriptor basicChanneldescriptor = new BaseChannelDescriptor(); final Object baseChannelDescriptor = basicChanneldescriptor.getDescriptor(); if (nonNull(baseChannelDescriptor) && baseChannelDescriptor instanceof List<?>) { List<Tad> channelConfiguration = (List<Tad>) baseChannelDescriptor; channelConfiguration.addAll(driverSpecificChannelConfiguration); for (final Tad attribute : channelConfiguration) { final Set<String> channelPrefixes = retrieveChannelPrefixes(this.assetConfiguration.getAssetChannels()); for (final String prefix : channelPrefixes) { final Tad newAttribute = cloneAd(attribute, prefix); mainOcd.addAD(newAttribute); } } } }", "text": "Add invariants", "function_tokens": ["private", "\u0120void", "\u0120fill", "Driver", "Specific", "Channel", "Configuration", "(", "final", "\u0120T", "oc", "d", "\u0120main", "O", "cd", ",", "\u0120final", "\u0120List", "<", "T", "ad", ">", "\u0120driver", "Specific", "Channel", "Configuration", ")", "\u0120{", "\u0120final", "\u0120Channel", "Desc", "ript", "or", "\u0120basic", "Ch", "anne", "ld", "esc", "ript", "or", "\u0120=", "\u0120new", "\u0120Base", "Channel", "Desc", "ript", "or", "();", "\u0120final", "\u0120Object", "\u0120base", "Channel", "Desc", "ript", "or", "\u0120=", "\u0120basic", "Ch", "anne", "ld", "esc", "ript", "or", ".", "get", "Desc", "ript", "or", "();", "\u0120if", "\u0120(", "non", "Null", "(", "base", "Channel", "Desc", "ript", "or", ")", "\u0120&&", "\u0120base", "Channel", "Desc", "ript", "or", "\u0120instance", "of", "\u0120List", "<?", ">)", "\u0120{", "\u0120List", "<", "T", "ad", ">", "\u0120channel", "Configuration", "\u0120=", "\u0120(", "List", "<", "T", "ad", ">)", "\u0120base", "Channel", "Desc", "ript", "or", ";", "\u0120channel", "Configuration", ".", "add", "All", "(", "driver", "Specific", "Channel", "Configuration", ");", "\u0120for", "\u0120(", "final", "\u0120Tad", "\u0120attribute", "\u0120:", "\u0120channel", "Configuration", ")", "\u0120{", "\u0120final", "\u0120Set", "<", "String", ">", "\u0120channel", "Pref", "ix", "es", "\u0120=", "\u0120retrieve", "Channel", "Pref", "ix", "es", "(", "this", ".", "ass", "et", "Configuration", ".", "get", "Asset", "Ch", "annels", "());", "\u0120for", "\u0120(", "final", "\u0120String", "\u0120prefix", "\u0120:", "\u0120channel", "Pref", "ix", "es", ")", "\u0120{", "\u0120final", "\u0120Tad", "\u0120new", "Attribute", "\u0120=", "\u0120clone", "Ad", "(", "attribute", ",", "\u0120prefix", ");", "\u0120main", "O", "cd", ".", "add", "AD", "(", "new", "Attribute", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Add", "\u0120invari", "ants"]}
{"function": "protected ACTION getUserAction(Cluster cluster, Path buildPath) throws FalconException { ACTION action = unmarshalAction(ACTION_TEMPLATE); JAXBElement<org.apache.falcon.oozie.spark.ACTION> actionJaxbElement = OozieUtils.unMarshalSparkAction(action); org.apache.falcon.oozie.spark.ACTION sparkAction = actionJaxbElement.getValue(); String sparkMasterURL = entity.getSparkAttributes().getMaster(); Path sparkJarFilePath = new Path(entity.getSparkAttributes().getJar()); String sparkJobName = entity.getSparkAttributes().getName(); String sparkOpts = entity.getSparkAttributes().getSparkOpts(); String sparkClassName = entity.getSparkAttributes().getClazz(); String clusterEntitySparkMasterURL = getClusterEntitySparkMaster(cluster); sparkMasterURL = (sparkMasterURL == null) ? clusterEntitySparkMasterURL : sparkMasterURL; if (StringUtils.isBlank(sparkMasterURL)) { throw new FalconException(\"Spark Master URL can'be empty\"); } sparkAction.setMaster(sparkMasterURL); sparkAction.setName(sparkJobName); addPrepareDeleteOutputPath(sparkAction); if (StringUtils.isNotEmpty(sparkOpts)) { sparkAction.setSparkOpts(sparkOpts); } if (StringUtils.isNotEmpty(sparkClassName)) { sparkAction.setClazz(sparkClassName); } List<String> argList = sparkAction.getArg(); List<String> sparkArgs = entity.getSparkAttributes().getArgs(); if (sparkArgs != null) { argList.addAll(sparkArgs); } addOutputFeedsAsArgument(argList, cluster); addInputFeedsAsArgument(argList, cluster); validateSparkJarFilePath(sparkJarFilePath); sparkAction.setJar(getSparkJarFileName(sparkJarFilePath)); setSparkLibFileToWorkflowLib(sparkJarFilePath, entity); propagateEntityProperties(sparkAction); OozieUtils.marshalSparkAction(action, actionJaxbElement); return action; }", "text": "just pass sparkJarFilePath.toString less number of changes will be required in the code.", "function_tokens": ["protected", "\u0120ACTION", "\u0120get", "User", "Action", "(", "Cl", "uster", "\u0120cluster", ",", "\u0120Path", "\u0120build", "Path", ")", "\u0120throws", "\u0120Falcon", "Exception", "\u0120{", "\u0120ACTION", "\u0120action", "\u0120=", "\u0120unm", "arsh", "al", "Action", "(", "ACTION", "_", "T", "EM", "PL", "ATE", ");", "\u0120J", "AX", "BE", "lement", "<", "org", ".", "apache", ".", "fal", "con", ".", "oo", "zie", ".", "sp", "ark", ".", "ACTION", ">", "\u0120action", "J", "ax", "b", "Element", "\u0120=", "\u0120O", "oz", "ie", "Ut", "ils", ".", "un", "Marsh", "al", "Sp", "ark", "Action", "(", "action", ");", "\u0120org", ".", "apache", ".", "fal", "con", ".", "oo", "zie", ".", "sp", "ark", ".", "ACTION", "\u0120spark", "Action", "\u0120=", "\u0120action", "J", "ax", "b", "Element", ".", "get", "Value", "();", "\u0120String", "\u0120spark", "Master", "URL", "\u0120=", "\u0120entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Master", "();", "\u0120Path", "\u0120spark", "Jar", "File", "Path", "\u0120=", "\u0120new", "\u0120Path", "(", "entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Jar", "());", "\u0120String", "\u0120spark", "Job", "Name", "\u0120=", "\u0120entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Name", "();", "\u0120String", "\u0120spark", "Opt", "s", "\u0120=", "\u0120entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Sp", "ark", "Opt", "s", "();", "\u0120String", "\u0120spark", "Class", "Name", "\u0120=", "\u0120entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Cl", "azz", "();", "\u0120String", "\u0120cluster", "Entity", "Sp", "ark", "Master", "URL", "\u0120=", "\u0120get", "Cl", "uster", "Entity", "Sp", "ark", "Master", "(", "cl", "uster", ");", "\u0120spark", "Master", "URL", "\u0120=", "\u0120(", "sp", "ark", "Master", "URL", "\u0120==", "\u0120null", ")", "\u0120?", "\u0120cluster", "Entity", "Sp", "ark", "Master", "URL", "\u0120:", "\u0120spark", "Master", "URL", ";", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "sp", "ark", "Master", "URL", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Falcon", "Exception", "(\"", "Sp", "ark", "\u0120Master", "\u0120URL", "\u0120can", "'", "be", "\u0120empty", "\");", "\u0120}", "\u0120spark", "Action", ".", "set", "Master", "(", "sp", "ark", "Master", "URL", ");", "\u0120spark", "Action", ".", "set", "Name", "(", "sp", "ark", "Job", "Name", ");", "\u0120add", "Prep", "are", "Delete", "Output", "Path", "(", "sp", "ark", "Action", ");", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Empty", "(", "sp", "ark", "Opt", "s", "))", "\u0120{", "\u0120spark", "Action", ".", "set", "Sp", "ark", "Opt", "s", "(", "sp", "ark", "Opt", "s", ");", "\u0120}", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Empty", "(", "sp", "ark", "Class", "Name", "))", "\u0120{", "\u0120spark", "Action", ".", "set", "Cl", "azz", "(", "sp", "ark", "Class", "Name", ");", "\u0120}", "\u0120List", "<", "String", ">", "\u0120arg", "List", "\u0120=", "\u0120spark", "Action", ".", "get", "Arg", "();", "\u0120List", "<", "String", ">", "\u0120spark", "Args", "\u0120=", "\u0120entity", ".", "get", "Sp", "ark", "Attributes", "().", "get", "Args", "();", "\u0120if", "\u0120(", "sp", "ark", "Args", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120arg", "List", ".", "add", "All", "(", "sp", "ark", "Args", ");", "\u0120}", "\u0120add", "Output", "Feed", "s", "As", "Arg", "ument", "(", "arg", "List", ",", "\u0120cluster", ");", "\u0120add", "Input", "Feed", "s", "As", "Arg", "ument", "(", "arg", "List", ",", "\u0120cluster", ");", "\u0120validate", "Sp", "ark", "Jar", "File", "Path", "(", "sp", "ark", "Jar", "File", "Path", ");", "\u0120spark", "Action", ".", "set", "Jar", "(", "get", "Sp", "ark", "Jar", "File", "Name", "(", "sp", "ark", "Jar", "File", "Path", "));", "\u0120set", "Sp", "ark", "Lib", "File", "To", "Work", "flow", "Lib", "(", "sp", "ark", "Jar", "File", "Path", ",", "\u0120entity", ");", "\u0120propagate", "Entity", "Pro", "perties", "(", "sp", "ark", "Action", ");", "\u0120O", "oz", "ie", "Ut", "ils", ".", "m", "arsh", "al", "Sp", "ark", "Action", "(", "action", ",", "\u0120action", "J", "ax", "b", "Element", ");", "\u0120return", "\u0120action", ";", "\u0120}"], "docstring_tokens": ["just", "\u0120pass", "\u0120spark", "Jar", "File", "Path", ".", "to", "String", "\u0120less", "\u0120number", "\u0120of", "\u0120changes", "\u0120will", "\u0120be", "\u0120required", "\u0120in", "\u0120the", "\u0120code", "."]}
{"function": "public ArrayList<Pojo> getResults(String query) { ArrayList<Pojo> pojos = new ArrayList<>(); if (android.os.Build.VERSION.SDK_INT >= 11) { Set<String> selectedProviders = new TreeSet<>(); selectedProviders.addAll(PreferenceManager.getDefaultSharedPreferences(this).getStringSet(\"search-providers\", new HashSet<>(Arrays.asList(\"Google\")))); for (String searchProvider : selectedProviders) { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.url = searchProviderUrls.get(searchProvider); pojo.name = searchProvider; pojos.add(pojo); } } else { SearchPojo pojo = new SearchPojo(); pojo.query = query; pojo.relevance = 10; pojo.name=\"Google\"; pojo.url = searchProviderUrls.get(\"Google\"); pojos.add(pojo); } Pattern p = Pattern.compile(URL_REGEX); Matcher m = p.matcher(query); if(m.find()) { String guessedUrl = URLUtil.guessUrl(query).toString(); if(URLUtil.isValidUrl (guessedUrl)) { SearchPojo pojo = new SearchPojo(); pojo.query = \"\"; pojo.relevance = 50; pojo.name = guessedUrl; pojo.url = guessedUrl; pojo.direct = true; pojos.add(pojo); } } return pojos; }", "text": "Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.", "function_tokens": ["public", "\u0120Array", "List", "<", "Po", "jo", ">", "\u0120get", "Results", "(", "String", "\u0120query", ")", "\u0120{", "\u0120Array", "List", "<", "Po", "jo", ">", "\u0120po", "j", "os", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120if", "\u0120(", "android", ".", "os", ".", "Build", ".", "VERSION", ".", "SD", "K", "_", "INT", "\u0120>=", "\u012011", ")", "\u0120{", "\u0120Set", "<", "String", ">", "\u0120selected", "Prov", "iders", "\u0120=", "\u0120new", "\u0120Tree", "Set", "<", ">", "();", "\u0120selected", "Prov", "iders", ".", "add", "All", "(", "Pre", "ference", "Manager", ".", "get", "Default", "Sh", "ared", "Pref", "erences", "(", "this", ").", "get", "String", "Set", "(\"", "search", "-", "prov", "iders", "\",", "\u0120new", "\u0120Hash", "Set", "<", ">(", "Ar", "rays", ".", "as", "List", "(\"", "Google", "\"))", "));", "\u0120for", "\u0120(", "String", "\u0120search", "Provider", "\u0120:", "\u0120selected", "Prov", "iders", ")", "\u0120{", "\u0120Search", "Po", "jo", "\u0120po", "jo", "\u0120=", "\u0120new", "\u0120Search", "Po", "jo", "();", "\u0120po", "jo", ".", "query", "\u0120=", "\u0120query", ";", "\u0120po", "jo", ".", "re", "lev", "ance", "\u0120=", "\u012010", ";", "\u0120po", "jo", ".", "url", "\u0120=", "\u0120search", "Provider", "Ur", "ls", ".", "get", "(", "search", "Provider", ");", "\u0120po", "jo", ".", "name", "\u0120=", "\u0120search", "Provider", ";", "\u0120po", "j", "os", ".", "add", "(", "po", "jo", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Search", "Po", "jo", "\u0120po", "jo", "\u0120=", "\u0120new", "\u0120Search", "Po", "jo", "();", "\u0120po", "jo", ".", "query", "\u0120=", "\u0120query", ";", "\u0120po", "jo", ".", "re", "lev", "ance", "\u0120=", "\u012010", ";", "\u0120po", "jo", ".", "name", "=\"", "Google", "\";", "\u0120po", "jo", ".", "url", "\u0120=", "\u0120search", "Provider", "Ur", "ls", ".", "get", "(\"", "Google", "\");", "\u0120po", "j", "os", ".", "add", "(", "po", "jo", ");", "\u0120}", "\u0120Pattern", "\u0120p", "\u0120=", "\u0120Pattern", ".", "comp", "ile", "(", "URL", "_", "REG", "EX", ");", "\u0120Mat", "cher", "\u0120m", "\u0120=", "\u0120p", ".", "mat", "cher", "(", "query", ");", "\u0120if", "(", "m", ".", "find", "())", "\u0120{", "\u0120String", "\u0120guessed", "Url", "\u0120=", "\u0120URL", "Ut", "il", ".", "gu", "ess", "Url", "(", "query", ").", "to", "String", "();", "\u0120if", "(", "URL", "Ut", "il", ".", "is", "Valid", "Url", "\u0120(", "gu", "essed", "Url", "))", "\u0120{", "\u0120Search", "Po", "jo", "\u0120po", "jo", "\u0120=", "\u0120new", "\u0120Search", "Po", "jo", "();", "\u0120po", "jo", ".", "query", "\u0120=", "\u0120\"", "\";", "\u0120po", "jo", ".", "re", "lev", "ance", "\u0120=", "\u012050", ";", "\u0120po", "jo", ".", "name", "\u0120=", "\u0120guessed", "Url", ";", "\u0120po", "jo", ".", "url", "\u0120=", "\u0120guessed", "Url", ";", "\u0120po", "jo", ".", "direct", "\u0120=", "\u0120true", ";", "\u0120po", "j", "os", ".", "add", "(", "po", "jo", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120po", "j", "os", ";", "\u0120}"], "docstring_tokens": ["Nit", "pick", ":", "\u0120Please", "\u0120pre", "-", "comp", "ile", "\u0120this", "\u0120value", "\u0120on", "\u0120class", "\u0120creation", "\u0120by", "\u0120adding", "\u0120it", "\u0120as", "\u0120a", "\u0120private", "\u0120static", "\u0120final", "\u0120", "\u0120", "\u0120line", "\u0120below", "\u0120the", "\u0120definition", "\u0120of", "\u0120search", "Provider", "Ur", "ls", "\u0120above", "."]}
{"function": "public AutoRegisterModules discover() throws InvalidPluginException { sysSingletons = Sets.newHashSet(); sysListen = LinkedListMultimap.create(); if (sshGen != null) { sshGen.setPluginName(pluginName); } if (httpGen != null) { httpGen.setPluginName(pluginName); } scan(); if (!sysSingletons.isEmpty() || !sysListen.isEmpty()) { sysModule = makeSystemModule(); } if (sshGen != null) { sshModule = sshGen.create(); } if (httpGen != null) { httpModule = httpGen.create(); } return this; }", "text": "The same.", "function_tokens": ["public", "\u0120Auto", "Register", "Mod", "ules", "\u0120discover", "()", "\u0120throws", "\u0120Invalid", "Plugin", "Exception", "\u0120{", "\u0120sys", "Sing", "let", "ons", "\u0120=", "\u0120Sets", ".", "new", "Hash", "Set", "();", "\u0120sys", "Listen", "\u0120=", "\u0120Link", "ed", "List", "Mult", "im", "ap", ".", "create", "();", "\u0120if", "\u0120(", "ssh", "Gen", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120ssh", "Gen", ".", "set", "Plugin", "Name", "(", "plugin", "Name", ");", "\u0120}", "\u0120if", "\u0120(", "http", "Gen", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120http", "Gen", ".", "set", "Plugin", "Name", "(", "plugin", "Name", ");", "\u0120}", "\u0120scan", "();", "\u0120if", "\u0120(!", "sys", "Sing", "let", "ons", ".", "is", "Empty", "()", "\u0120||", "\u0120!", "sys", "Listen", ".", "is", "Empty", "())", "\u0120{", "\u0120sys", "Module", "\u0120=", "\u0120make", "System", "Module", "();", "\u0120}", "\u0120if", "\u0120(", "ssh", "Gen", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120ssh", "Module", "\u0120=", "\u0120ssh", "Gen", ".", "create", "();", "\u0120}", "\u0120if", "\u0120(", "http", "Gen", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120http", "Module", "\u0120=", "\u0120http", "Gen", ".", "create", "();", "\u0120}", "\u0120return", "\u0120this", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120same", "."]}
{"function": "public <K, V> MessageStream<KV<K, V>> partitionBy(Function<? super M, ? extends K> keyExtractor, Function<? super M, ? extends V> valueExtractor, KVSerde<K, V> serde) { int opId = this.graph.getNextOpId(); String opName = String.format(\"%s-%s\", OperatorSpec.OpCode.PARTITION_BY.name().toLowerCase(), opId); IntermediateMessageStreamImpl<KV<K, V>> intermediateStream = this.graph.getIntermediateStream(opName, serde); PartitionByOperatorSpec<M, K, V> partitionByOperatorSpec = OperatorSpecs.createRepartitionOperatorSpec( intermediateStream.getOutputStream(), keyExtractor, valueExtractor, opId); this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return intermediateStream; }", "text": "The phrase \"repartition\" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data.", "function_tokens": ["public", "\u0120<", "K", ",", "\u0120V", ">", "\u0120Message", "Stream", "<", "K", "V", "<", "K", ",", "\u0120V", ">>", "\u0120partition", "By", "(", "Function", "<?", "\u0120super", "\u0120M", ",", "\u0120?", "\u0120extends", "\u0120K", ">", "\u0120key", "Ext", "ractor", ",", "\u0120Function", "<?", "\u0120super", "\u0120M", ",", "\u0120?", "\u0120extends", "\u0120V", ">", "\u0120value", "Ext", "ractor", ",", "\u0120K", "V", "Ser", "de", "<", "K", ",", "\u0120V", ">", "\u0120ser", "de", ")", "\u0120{", "\u0120int", "\u0120op", "Id", "\u0120=", "\u0120this", ".", "graph", ".", "get", "Next", "Op", "Id", "();", "\u0120String", "\u0120op", "Name", "\u0120=", "\u0120String", ".", "format", "(\"", "%", "s", "-", "%", "s", "\",", "\u0120Operator", "Spec", ".", "Op", "Code", ".", "PART", "ITION", "_", "BY", ".", "name", "().", "to", "Lower", "Case", "(),", "\u0120op", "Id", ");", "\u0120Intermediate", "Message", "Stream", "Impl", "<", "K", "V", "<", "K", ",", "\u0120V", ">>", "\u0120intermediate", "Stream", "\u0120=", "\u0120this", ".", "graph", ".", "get", "Inter", "mediate", "Stream", "(", "op", "Name", ",", "\u0120ser", "de", ");", "\u0120Part", "ition", "By", "Oper", "ator", "Spec", "<", "M", ",", "\u0120K", ",", "\u0120V", ">", "\u0120partition", "By", "Oper", "ator", "Spec", "\u0120=", "\u0120Operator", "Spe", "cs", ".", "create", "Rep", "art", "ition", "Oper", "ator", "Spec", "(", "\u0120intermediate", "Stream", ".", "get", "Output", "Stream", "(),", "\u0120key", "Ext", "ractor", ",", "\u0120value", "Ext", "ractor", ",", "\u0120op", "Id", ");", "\u0120this", ".", "operator", "Spec", ".", "register", "Next", "Oper", "ator", "Spec", "(", "part", "ition", "By", "Oper", "ator", "Spec", ");", "\u0120return", "\u0120intermediate", "Stream", ";", "\u0120}"], "docstring_tokens": ["The", "\u0120phrase", "\u0120\"", "re", "part", "ition", "\"", "\u0120has", "\u0120a", "\u0120better", "\u0120ring", "\u0120to", "\u0120it", ".", "\u0120But", "\u0120here", "\u0120I", "\u0120prefer", "\u0120partition", "By", "\u0120for", "\u01202", "\u0120reasons", ":", "\u01201", ".", "\u0120Cons", "ist", "ency", "\u0120between", "\u0120the", "\u0120operation", "\u0120name", "\u0120and", "\u0120the", "\u0120operator", "\u0120spec", "\u0120name", ".", "\u01202", ".", "\u0120RE", "part", "ition", "\u0120implies", "\u0120that", "\u0120the", "\u0120input", "\u0120data", "\u0120is", "\u0120already", "\u0120partition", "ed", "\u0120in", "\u0120some", "\u0120fashion", ".", "\u0120Part", "ition", "By", "\u0120implies", "\u0120nothing", "\u0120and", "\u0120just", "\u0120describes", "\u0120what", "\u0120will", "\u0120be", "\u0120done", "\u0120with", "\u0120the", "\u0120data", "."]}
{"function": "public RealmIdentity getRealmIdentity(final Principal principal) throws RealmUnavailableException { boolean ok = false; final RealmIdentity authenticationIdentity = authenticationRealm.getRealmIdentity(principal); Principal authorizationPrincipal = principal; if(principalTransformer != null) { authorizationPrincipal = principalTransformer.apply(authorizationPrincipal); if (authorizationPrincipal == null) return null; } final RealmIdentity[] authorizationIdentities = new RealmIdentity[authorizationRealms.length]; try { for (int i = 0; i < authorizationIdentities.length; i++) { SecurityRealm authorizationRealm = authorizationRealms[i]; authorizationIdentities[i] = authorizationRealm == authenticationRealm && principalTransformer == null ? authenticationIdentity : authorizationRealm.getRealmIdentity(authorizationPrincipal); } final Identity identity = new Identity(authenticationIdentity, authorizationIdentities); ok = true; return identity; } finally { if (!ok) { authenticationIdentity.dispose(); for (RealmIdentity current : authorizationIdentities) { if (current != null) current.dispose(); } } } }", "text": "Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.", "function_tokens": ["public", "\u0120Realm", "Id", "entity", "\u0120get", "Real", "m", "Id", "entity", "(", "final", "\u0120Principal", "\u0120principal", ")", "\u0120throws", "\u0120Realm", "Un", "available", "Exception", "\u0120{", "\u0120boolean", "\u0120ok", "\u0120=", "\u0120false", ";", "\u0120final", "\u0120Realm", "Id", "entity", "\u0120authentication", "Id", "entity", "\u0120=", "\u0120authentication", "Real", "m", ".", "get", "Real", "m", "Id", "entity", "(", "pr", "inc", "ipal", ");", "\u0120Principal", "\u0120authorization", "Princ", "ipal", "\u0120=", "\u0120principal", ";", "\u0120if", "(", "pr", "inc", "ipal", "Trans", "former", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120authorization", "Princ", "ipal", "\u0120=", "\u0120principal", "Trans", "former", ".", "apply", "(", "author", "ization", "Princ", "ipal", ");", "\u0120if", "\u0120(", "author", "ization", "Princ", "ipal", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120final", "\u0120Realm", "Id", "entity", "[]", "\u0120authorization", "Ident", "ities", "\u0120=", "\u0120new", "\u0120Realm", "Id", "entity", "[", "author", "ization", "Real", "ms", ".", "length", "];", "\u0120try", "\u0120{", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120authorization", "Ident", "ities", ".", "length", ";", "\u0120i", "++)", "\u0120{", "\u0120Security", "Real", "m", "\u0120authorization", "Real", "m", "\u0120=", "\u0120authorization", "Real", "ms", "[", "i", "];", "\u0120authorization", "Ident", "ities", "[", "i", "]", "\u0120=", "\u0120authorization", "Real", "m", "\u0120==", "\u0120authentication", "Real", "m", "\u0120&&", "\u0120principal", "Trans", "former", "\u0120==", "\u0120null", "\u0120?", "\u0120authentication", "Id", "entity", "\u0120:", "\u0120authorization", "Real", "m", ".", "get", "Real", "m", "Id", "entity", "(", "author", "ization", "Princ", "ipal", ");", "\u0120}", "\u0120final", "\u0120Identity", "\u0120identity", "\u0120=", "\u0120new", "\u0120Identity", "(", "authent", "ication", "Id", "entity", ",", "\u0120authorization", "Ident", "ities", ");", "\u0120ok", "\u0120=", "\u0120true", ";", "\u0120return", "\u0120identity", ";", "\u0120}", "\u0120finally", "\u0120{", "\u0120if", "\u0120(!", "ok", ")", "\u0120{", "\u0120authentication", "Id", "entity", ".", "dis", "pose", "();", "\u0120for", "\u0120(", "Real", "m", "Id", "entity", "\u0120current", "\u0120:", "\u0120authorization", "Ident", "ities", ")", "\u0120{", "\u0120if", "\u0120(", "current", "\u0120!=", "\u0120null", ")", "\u0120current", ".", "dis", "pose", "();", "\u0120}", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Need", "\u0120to", "\u0120be", "\u0120a", "\u0120bit", "\u0120careful", "\u0120here", "\u0120since", "\u0120get", "Real", "m", "Id", "entity", "\u0120should", "\u0120only", "\u0120return", "\u0120a", "\u0120non", "-", "null", "\u0120value", ".", "\u0120I", "\u0120think", "\u0120we", "\u0120should", "\u0120throw", "\u0120an", "\u0120Illegal", "State", "Exception", "\u0120here", "\u0120if", "\u0120we", "\u0120have", "\u0120a", "\u0120null", "\u0120value", "\u0120at", "\u0120this", "\u0120point", "."]}
{"function": "protected void doStart() throws Exception { super.doStart(); if (!Files.exists(baseDirectory)) { if (getEndpoint().isAutoCreate()) { baseDirectory = Files.createDirectories(baseDirectory); } else { throw new RuntimeCamelException(\"Path must exists when autoCreate = false\"); } } if (!Files.isDirectory(baseDirectory)) { throw new RuntimeCamelException(String.format(\"Parameter path must be directory, %s given\", baseDirectory.toString())); } DirectoryWatcher.Builder watcherBuilder = DirectoryWatcher.builder() .path(this.baseDirectory) .logger(log) .listener(new FileWatchDirectoryChangeListener()); if (!System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) { watcherBuilder.watchService(this.baseDirectory.getFileSystem().newWatchService()); } watcherBuilder.fileHashing(getEndpoint().isUseFileHashing()); if (getEndpoint().getFileHasher() != null && getEndpoint().isUseFileHashing()) { watcherBuilder.fileHasher(getEndpoint().getFileHasher()); } this.watcher = watcherBuilder.build(); watchDirExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, \"CamelFileWatchService\", getEndpoint().getPollThreads()); pollExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager() .newFixedThreadPool(this, \"CamelFileWatchPoll\", getEndpoint().getConcurrentConsumers()); for (int i = 0; i < getEndpoint().getPollThreads(); i++) { this.watcher.watchAsync(watchDirExecutorService); } for (int i = 0; i < getEndpoint().getConcurrentConsumers(); i++) { pollExecutorService.submit(new PollRunnable()); } }", "text": "We tend to use IllegalArgumentException for these kind", "function_tokens": ["protected", "\u0120void", "\u0120do", "Start", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120super", ".", "do", "Start", "();", "\u0120if", "\u0120(!", "Files", ".", "ex", "ists", "(", "base", "Directory", "))", "\u0120{", "\u0120if", "\u0120(", "get", "End", "point", "().", "is", "Auto", "Create", "())", "\u0120{", "\u0120base", "Directory", "\u0120=", "\u0120Files", ".", "create", "Direct", "ories", "(", "base", "Directory", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "C", "amel", "Exception", "(\"", "Path", "\u0120must", "\u0120exists", "\u0120when", "\u0120auto", "Create", "\u0120=", "\u0120false", "\");", "\u0120}", "\u0120}", "\u0120if", "\u0120(!", "Files", ".", "is", "Directory", "(", "base", "Directory", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Runtime", "C", "amel", "Exception", "(", "String", ".", "format", "(\"", "Parameter", "\u0120path", "\u0120must", "\u0120be", "\u0120directory", ",", "\u0120%", "s", "\u0120given", "\",", "\u0120base", "Directory", ".", "to", "String", "()", "));", "\u0120}", "\u0120Directory", "W", "atcher", ".", "Builder", "\u0120wat", "cher", "Builder", "\u0120=", "\u0120Directory", "W", "atcher", ".", "builder", "()", "\u0120.", "path", "(", "this", ".", "base", "Directory", ")", "\u0120.", "log", "ger", "(", "log", ")", "\u0120.", "list", "ener", "(", "new", "\u0120File", "Watch", "Directory", "Change", "Listener", "());", "\u0120if", "\u0120(!", "System", ".", "get", "Property", "(\"", "os", ".", "name", "\").", "to", "Lower", "Case", "().", "cont", "ains", "(\"", "mac", "\"))", "\u0120{", "\u0120wat", "cher", "Builder", ".", "watch", "Service", "(", "this", ".", "base", "Directory", ".", "get", "File", "System", "().", "new", "Watch", "Service", "());", "\u0120}", "\u0120wat", "cher", "Builder", ".", "file", "H", "ashing", "(", "get", "End", "point", "().", "is", "Use", "File", "H", "ashing", "());", "\u0120if", "\u0120(", "get", "End", "point", "().", "get", "File", "Has", "her", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120get", "End", "point", "().", "is", "Use", "File", "H", "ashing", "())", "\u0120{", "\u0120wat", "cher", "Builder", ".", "file", "Has", "her", "(", "get", "End", "point", "().", "get", "File", "Has", "her", "());", "\u0120}", "\u0120this", ".", "w", "atcher", "\u0120=", "\u0120wat", "cher", "Builder", ".", "build", "();", "\u0120watch", "Dir", "Exec", "utor", "Service", "\u0120=", "\u0120get", "End", "point", "().", "get", "C", "amel", "Context", "().", "get", "Exec", "utor", "Service", "Manager", "()", "\u0120.", "new", "Fixed", "Thread", "Pool", "(", "this", ",", "\u0120\"", "C", "amel", "File", "Watch", "Service", "\",", "\u0120get", "End", "point", "().", "get", "Poll", "Thread", "s", "());", "\u0120poll", "Exec", "utor", "Service", "\u0120=", "\u0120get", "End", "point", "().", "get", "C", "amel", "Context", "().", "get", "Exec", "utor", "Service", "Manager", "()", "\u0120.", "new", "Fixed", "Thread", "Pool", "(", "this", ",", "\u0120\"", "C", "amel", "File", "Watch", "Poll", "\",", "\u0120get", "End", "point", "().", "get", "Con", "current", "Cons", "umers", "());", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120get", "End", "point", "().", "get", "Poll", "Thread", "s", "();", "\u0120i", "++)", "\u0120{", "\u0120this", ".", "w", "atcher", ".", "watch", "Async", "(", "watch", "Dir", "Exec", "utor", "Service", ");", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120get", "End", "point", "().", "get", "Con", "current", "Cons", "umers", "();", "\u0120i", "++)", "\u0120{", "\u0120poll", "Exec", "utor", "Service", ".", "submit", "(", "new", "\u0120Poll", "Run", "n", "able", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["We", "\u0120tend", "\u0120to", "\u0120use", "\u0120Illegal", "Arg", "ument", "Exception", "\u0120for", "\u0120these", "\u0120kind"]}
{"function": "public String getDescription() { return Localization.lang( \"Removes all {} brackets around words.\"); }", "text": "add \"balanced\" ?", "function_tokens": ["public", "\u0120String", "\u0120get", "Description", "()", "\u0120{", "\u0120return", "\u0120Local", "ization", ".", "lang", "(", "\u0120\"", "Rem", "oves", "\u0120all", "\u0120{}", "\u0120brackets", "\u0120around", "\u0120words", ".\"", ");", "\u0120}"], "docstring_tokens": ["add", "\u0120\"", "balanced", "\"", "\u0120?"]}
{"function": "public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException { ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile()); if (useSsl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, \"true\"); } if (useSasl()) { clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, \"true\"); } if (getZooKeeperInstance().size() > 0) { List<String> zkOpts = getZooKeeperInstance(); String instanceName = zkOpts.get(0); String hosts = zkOpts.get(1); clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, hosts); clientConfig.setProperty(ClientProperty.INSTANCE_NAME, instanceName); } if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) { AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig)); clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST)); } if (null != zooKeeperHosts) { clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts); } return clientConfig; }", "text": "Conditional is more clear as: !getZooKeeperInstance().isEmpty()", "function_tokens": ["public", "\u0120Client", "Configuration", "\u0120get", "Client", "Configuration", "()", "\u0120throws", "\u0120Configuration", "Exception", ",", "\u0120File", "Not", "Found", "Exception", "\u0120{", "\u0120Client", "Configuration", "\u0120client", "Config", "\u0120=", "\u0120client", "Config", "File", "\u0120==", "\u0120null", "\u0120?", "\u0120Client", "Configuration", ".", "load", "Default", "()", "\u0120:", "\u0120new", "\u0120Client", "Configuration", "(", "get", "Client", "Config", "File", "());", "\u0120if", "\u0120(", "use", "S", "sl", "())", "\u0120{", "\u0120client", "Config", ".", "set", "Property", "(", "Client", "Property", ".", "INST", "ANCE", "_", "R", "PC", "_", "SSL", "_", "EN", "AB", "LED", ",", "\u0120\"", "true", "\");", "\u0120}", "\u0120if", "\u0120(", "use", "S", "as", "l", "())", "\u0120{", "\u0120client", "Config", ".", "set", "Property", "(", "Client", "Property", ".", "INST", "ANCE", "_", "R", "PC", "_", "S", "AS", "L", "_", "EN", "AB", "LED", ",", "\u0120\"", "true", "\");", "\u0120}", "\u0120if", "\u0120(", "get", "Z", "oo", "K", "eeper", "Instance", "().", "size", "()", "\u0120>", "\u01200", ")", "\u0120{", "\u0120List", "<", "String", ">", "\u0120z", "k", "Opt", "s", "\u0120=", "\u0120get", "Z", "oo", "K", "eeper", "Instance", "();", "\u0120String", "\u0120instance", "Name", "\u0120=", "\u0120z", "k", "Opt", "s", ".", "get", "(", "0", ");", "\u0120String", "\u0120hosts", "\u0120=", "\u0120z", "k", "Opt", "s", ".", "get", "(", "1", ");", "\u0120client", "Config", ".", "set", "Property", "(", "Client", "Property", ".", "INST", "ANCE", "_", "Z", "K", "_", "H", "OST", ",", "\u0120hosts", ");", "\u0120client", "Config", ".", "set", "Property", "(", "Client", "Property", ".", "INST", "ANCE", "_", "NAME", ",", "\u0120instance", "Name", ");", "\u0120}", "\u0120if", "\u0120(!", "client", "Config", ".", "cont", "ains", "Key", "(", "Client", "Property", ".", "INST", "ANCE", "_", "Z", "K", "_", "H", "OST", ".", "get", "Key", "()", "))", "\u0120{", "\u0120Acc", "um", "ulo", "Configuration", "\u0120site", "Conf", "\u0120=", "\u0120Site", "Configuration", ".", "get", "Instance", "(", "Client", "Context", ".", "con", "vert", "Client", "Config", "(", "client", "Config", "));", "\u0120client", "Config", ".", "with", "Z", "k", "Host", "s", "(", "site", "Conf", ".", "get", "(", "Property", ".", "INST", "ANCE", "_", "Z", "K", "_", "H", "OST", "));", "\u0120}", "\u0120if", "\u0120(", "null", "\u0120!=", "\u0120zoo", "K", "eeper", "Host", "s", ")", "\u0120{", "\u0120client", "Config", ".", "set", "Property", "(", "Client", "Property", ".", "INST", "ANCE", "_", "Z", "K", "_", "H", "OST", ",", "\u0120zoo", "K", "eeper", "Host", "s", ");", "\u0120}", "\u0120return", "\u0120client", "Config", ";", "\u0120}"], "docstring_tokens": ["Cond", "itional", "\u0120is", "\u0120more", "\u0120clear", "\u0120as", ":", "\u0120!", "get", "Z", "oo", "K", "eeper", "Instance", "().", "is", "Empty", "()"]}
{"function": "private void recordLatency(Response<? extends Request> response, String operation) { Serializable start = response.getRequest().getPropertyValue(METRICS_OPERATION_START); long latency = calculateLatency((Long) start); if (latency > 0) { DistributionSummary.builder(metricName(METRIC_PREFIX, operation, \"latency\")) .baseUnit(\"milliseconds\") .tags(\"successful\", Boolean.toString(response.getProcessingErrors().isEmpty())) .publishPercentiles(0.5, 0.95) .register(Metrics.globalRegistry) .record(latency); } }", "text": "If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace(\"Computed a suspicious latency of {} for {}\", latency, operation); return; } DistributionSummary.builder(...)", "function_tokens": ["private", "\u0120void", "\u0120record", "Lat", "ency", "(", "Response", "<?", "\u0120extends", "\u0120Request", ">", "\u0120response", ",", "\u0120String", "\u0120operation", ")", "\u0120{", "\u0120Serial", "izable", "\u0120start", "\u0120=", "\u0120response", ".", "get", "Request", "().", "get", "Property", "Value", "(", "MET", "R", "ICS", "_", "OPER", "ATION", "_", "ST", "ART", ");", "\u0120long", "\u0120latency", "\u0120=", "\u0120calculate", "Lat", "ency", "((", "Long", ")", "\u0120start", ");", "\u0120if", "\u0120(", "lat", "ency", "\u0120>", "\u01200", ")", "\u0120{", "\u0120Distribution", "Summary", ".", "builder", "(", "met", "ric", "Name", "(", "MET", "RIC", "_", "P", "REF", "IX", ",", "\u0120operation", ",", "\u0120\"", "lat", "ency", "\"))", "\u0120.", "base", "Unit", "(\"", "mill", "isec", "onds", "\")", "\u0120.", "tags", "(\"", "successful", "\",", "\u0120Boolean", ".", "to", "String", "(", "response", ".", "get", "Process", "ing", "Er", "rors", "().", "is", "Empty", "()", "))", "\u0120.", "pub", "lish", "Percent", "iles", "(", "0", ".", "5", ",", "\u01200", ".", "95", ")", "\u0120.", "register", "(", "Met", "rics", ".", "global", "Reg", "istry", ")", "\u0120.", "record", "(", "lat", "ency", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["If", "\u0120we", "\u0120encounter", "\u0120the", "\u0120opposite", "\u0120is", "\u0120there", "\u0120anything", "\u0120we", "\u0120could", "\u0120do", "\u0120to", "\u0120fix", "\u0120it", "?", "\u0120Or", "\u0120would", "\u0120it", "\u0120not", "\u0120matter", "?", "\u0120", "\u0120if", "\u0120(", "lat", "ency", "\u0120<=", "\u01200", ")", "\u0120{", "\u0120LOG", "GER", ".", "trace", "(\"", "Com", "puted", "\u0120a", "\u0120suspicious", "\u0120latency", "\u0120of", "\u0120{}", "\u0120for", "\u0120{}", "\",", "\u0120latency", ",", "\u0120operation", ");", "\u0120return", ";", "\u0120}", "\u0120Distribution", "Summary", ".", "builder", "(", "...)"]}
{"function": "public Object execute(ExecutionEvent event) throws ExecutionException { final Repository repo = getRepository(true, event); IResource[] resources = getSelectedResources(event); if (repo == null) return null; CommitSelectionDialog dlg = new CommitSelectionDialog(getShell(event), repo, resources); if (dlg.open() != Window.OK) return null; if (resources.length == 1 && resources[0] instanceof IFile) { final IFile baseFile = (IFile) resources[0]; final ITypedElement base = SaveableCompareEditorInput .createFileElement(baseFile); final ITypedElement next; ITypedElement ancestor = null; RevCommit commonAncestor = null; try { RepositoryMapping mapping = RepositoryMapping .getMapping(resources[0]); next = getElementForCommit(mapping.getRepository(), mapping .getRepoRelativePath(baseFile), dlg.getCommitId()); commonAncestor = RevUtils.getCommonAncestor(repo, repo.resolve(Constants.HEAD), dlg.getCommitId()); if (commonAncestor != null) ancestor = CompareUtils.getFileRevisionTypedElement( mapping .getRepoRelativePath(baseFile), commonAncestor, mapping.getRepository()); } catch (IOException e) { Activator.handleError( UIText.CompareWithIndexAction_errorOnAddToIndex, e, true); return null; } final GitCompareFileRevisionEditorInput in = new GitCompareFileRevisionEditorInput( base, next, ancestor, null); in.getCompareConfiguration() .setRightLabel(dlg.getCommitId().name()); if (commonAncestor != null) in.getCompareConfiguration() .setAncestorLabel(commonAncestor.name()); CompareUI.openCompareEditor(in); } else { CompareTreeView view; try { view = (CompareTreeView) PlatformUI.getWorkbench() .getActiveWorkbenchWindow().getActivePage().showView( CompareTreeView.ID); view.setInput(resources, dlg.getCommitId().name()); } catch (PartInitException e) { Activator.handleError(e.getMessage(), e, true); } } return null; }", "text": "This seems to be unnecessary. I also get the label after removing this.", "function_tokens": ["public", "\u0120Object", "\u0120execute", "(", "Exec", "ution", "Event", "\u0120event", ")", "\u0120throws", "\u0120Execution", "Exception", "\u0120{", "\u0120final", "\u0120Rep", "ository", "\u0120repo", "\u0120=", "\u0120get", "Rep", "ository", "(", "true", ",", "\u0120event", ");", "\u0120I", "Resource", "[]", "\u0120resources", "\u0120=", "\u0120get", "Se", "lected", "Resources", "(", "event", ");", "\u0120if", "\u0120(", "re", "po", "\u0120==", "\u0120null", ")", "\u0120return", "\u0120null", ";", "\u0120Commit", "Se", "lection", "Dialog", "\u0120d", "l", "g", "\u0120=", "\u0120new", "\u0120Commit", "Se", "lection", "Dialog", "(", "get", "Shell", "(", "event", "),", "\u0120repo", ",", "\u0120resources", ");", "\u0120if", "\u0120(", "dl", "g", ".", "open", "()", "\u0120!=", "\u0120Window", ".", "OK", ")", "\u0120return", "\u0120null", ";", "\u0120if", "\u0120(", "resources", ".", "length", "\u0120==", "\u01201", "\u0120&&", "\u0120resources", "[", "0", "]", "\u0120instance", "of", "\u0120I", "File", ")", "\u0120{", "\u0120final", "\u0120I", "File", "\u0120base", "File", "\u0120=", "\u0120(", "IF", "ile", ")", "\u0120resources", "[", "0", "];", "\u0120final", "\u0120IT", "yp", "ed", "Element", "\u0120base", "\u0120=", "\u0120Save", "able", "Compare", "Editor", "Input", "\u0120.", "create", "File", "Element", "(", "base", "File", ");", "\u0120final", "\u0120IT", "yp", "ed", "Element", "\u0120next", ";", "\u0120IT", "yp", "ed", "Element", "\u0120ancestor", "\u0120=", "\u0120null", ";", "\u0120Rev", "Comm", "it", "\u0120common", "An", "cest", "or", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120{", "\u0120Rep", "ository", "M", "apping", "\u0120mapping", "\u0120=", "\u0120Rep", "ository", "M", "apping", "\u0120.", "get", "M", "apping", "(", "resources", "[", "0", "]);", "\u0120next", "\u0120=", "\u0120get", "Element", "For", "Comm", "it", "(", "m", "apping", ".", "get", "Rep", "ository", "(),", "\u0120mapping", "\u0120.", "get", "Rep", "o", "Rel", "ative", "Path", "(", "base", "File", "),", "\u0120d", "l", "g", ".", "get", "Comm", "it", "Id", "());", "\u0120common", "An", "cest", "or", "\u0120=", "\u0120Rev", "Ut", "ils", ".", "get", "Common", "An", "cest", "or", "(", "re", "po", ",", "\u0120repo", ".", "res", "olve", "(", "Const", "ants", ".", "HEAD", "),", "\u0120d", "l", "g", ".", "get", "Comm", "it", "Id", "());", "\u0120if", "\u0120(", "common", "An", "cest", "or", "\u0120!=", "\u0120null", ")", "\u0120ancestor", "\u0120=", "\u0120Compare", "Ut", "ils", ".", "get", "File", "Rev", "ision", "Typ", "ed", "Element", "(", "\u0120mapping", "\u0120.", "get", "Rep", "o", "Rel", "ative", "Path", "(", "base", "File", "),", "\u0120common", "An", "cest", "or", ",", "\u0120mapping", ".", "get", "Rep", "ository", "());", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120Activ", "ator", ".", "handle", "Error", "(", "\u0120U", "IT", "ext", ".", "Compare", "With", "Index", "Action", "_", "error", "On", "Add", "To", "Index", ",", "\u0120e", ",", "\u0120true", ");", "\u0120return", "\u0120null", ";", "\u0120}", "\u0120final", "\u0120Git", "Compare", "File", "Rev", "ision", "Editor", "Input", "\u0120in", "\u0120=", "\u0120new", "\u0120Git", "Compare", "File", "Rev", "ision", "Editor", "Input", "(", "\u0120base", ",", "\u0120next", ",", "\u0120ancestor", ",", "\u0120null", ");", "\u0120in", ".", "get", "Compare", "Configuration", "()", "\u0120.", "set", "Right", "Label", "(", "dl", "g", ".", "get", "Comm", "it", "Id", "().", "name", "());", "\u0120if", "\u0120(", "common", "An", "cest", "or", "\u0120!=", "\u0120null", ")", "\u0120in", ".", "get", "Compare", "Configuration", "()", "\u0120.", "set", "An", "cest", "or", "Label", "(", "common", "An", "cest", "or", ".", "name", "());", "\u0120Compare", "UI", ".", "open", "Compare", "Editor", "(", "in", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120Compare", "Tree", "View", "\u0120view", ";", "\u0120try", "\u0120{", "\u0120view", "\u0120=", "\u0120(", "Compare", "Tree", "View", ")", "\u0120Platform", "UI", ".", "get", "Work", "bench", "()", "\u0120.", "get", "Active", "Work", "bench", "Window", "().", "get", "Active", "Page", "().", "show", "View", "(", "\u0120Compare", "Tree", "View", ".", "ID", ");", "\u0120view", ".", "set", "Input", "(", "resources", ",", "\u0120d", "l", "g", ".", "get", "Comm", "it", "Id", "().", "name", "());", "\u0120}", "\u0120catch", "\u0120(", "Part", "Init", "Exception", "\u0120e", ")", "\u0120{", "\u0120Activ", "ator", ".", "handle", "Error", "(", "e", ".", "get", "Message", "(),", "\u0120e", ",", "\u0120true", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120null", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120seems", "\u0120to", "\u0120be", "\u0120unnecessary", ".", "\u0120I", "\u0120also", "\u0120get", "\u0120the", "\u0120label", "\u0120after", "\u0120removing", "\u0120this", "."]}
{"function": "private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( \"org.Address\", new ModelField[]{ new ModelField( \"this\", \"org.Address\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, \"this\" ), new ModelField( \"street\", \"String\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( \"homeAddress\", \"Boolean\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( \"number\", \"java.lang.Integer\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }", "text": "@jomarko Thanks.. I'd have made this Integer.class.getName() too", "function_tokens": ["private", "\u0120Package", "Data", "Model", "Oracle", "Incre", "mental", "Pay", "load", "\u0120create", "Address", "Pay", "load", "()", "\u0120{", "\u0120Package", "Data", "Model", "Oracle", "Incre", "mental", "Pay", "load", "\u0120payload", "\u0120=", "\u0120new", "\u0120Package", "Data", "Model", "Oracle", "Incre", "mental", "Pay", "load", "();", "\u0120Hash", "Map", "<", "String", ",", "\u0120Model", "Field", "[]", ">", "\u0120address", "Model", "Field", "s", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "String", ",", "\u0120Model", "Field", "[]", ">", "();", "\u0120address", "Model", "Field", "s", ".", "put", "(", "\u0120\"", "org", ".", "Address", "\",", "\u0120new", "\u0120Model", "Field", "[]", "{", "\u0120new", "\u0120Model", "Field", "(", "\u0120\"", "this", "\",", "\u0120\"", "org", ".", "Address", "\",", "\u0120Model", "Field", ".", "FIELD", "_", "CLASS", "_", "TYPE", ".", "REG", "ULAR", "_", "CLASS", ",", "\u0120Model", "Field", ".", "FIELD", "_", "OR", "IG", "IN", ".", "S", "ELF", ",", "\u0120Field", "Access", "ors", "And", "Mut", "ators", ".", "ACC", "ESS", "OR", ",", "\u0120\"", "this", "\"", "\u0120),", "\u0120new", "\u0120Model", "Field", "(", "\u0120\"", "street", "\",", "\u0120\"", "String", "\",", "\u0120Model", "Field", ".", "FIELD", "_", "CLASS", "_", "TYPE", ".", "REG", "ULAR", "_", "CLASS", ",", "\u0120Model", "Field", ".", "FIELD", "_", "OR", "IG", "IN", ".", "DEC", "L", "AR", "ED", ",", "\u0120Field", "Access", "ors", "And", "Mut", "ators", ".", "B", "OTH", ",", "\u0120Data", "Type", ".", "TYPE", "_", "STR", "ING", "\u0120),", "\u0120new", "\u0120Model", "Field", "(", "\u0120\"", "home", "Address", "\",", "\u0120\"", "Boo", "lean", "\",", "\u0120Model", "Field", ".", "FIELD", "_", "CLASS", "_", "TYPE", ".", "REG", "ULAR", "_", "CLASS", ",", "\u0120Model", "Field", ".", "FIELD", "_", "OR", "IG", "IN", ".", "DEC", "L", "AR", "ED", ",", "\u0120Field", "Access", "ors", "And", "Mut", "ators", ".", "B", "OTH", ",", "\u0120Data", "Type", ".", "TYPE", "_", "B", "OO", "LE", "AN", "\u0120),", "\u0120new", "\u0120Model", "Field", "(", "\u0120\"", "number", "\",", "\u0120\"", "java", ".", "lang", ".", "Integer", "\",", "\u0120Model", "Field", ".", "FIELD", "_", "CLASS", "_", "TYPE", ".", "REG", "ULAR", "_", "CLASS", ",", "\u0120Model", "Field", ".", "FIELD", "_", "OR", "IG", "IN", ".", "DEC", "L", "AR", "ED", ",", "\u0120Field", "Access", "ors", "And", "Mut", "ators", ".", "B", "OTH", ",", "\u0120Data", "Type", ".", "TYPE", "_", "NUM", "ER", "IC", "_", "INT", "EG", "ER", "\u0120)", "}", "\u0120);", "\u0120payload", ".", "set", "Model", "Field", "s", "(", "\u0120address", "Model", "Field", "s", "\u0120);", "\u0120return", "\u0120payload", ";", "\u0120}"], "docstring_tokens": ["@", "j", "om", "ark", "o", "\u0120Thanks", "..", "\u0120I", "'d", "\u0120have", "\u0120made", "\u0120this", "\u0120Integer", ".", "class", ".", "get", "Name", "()", "\u0120too"]}
{"function": "private boolean processRow(String line) { List<String> values = ImmutableList.copyOf(ON_COMMA.split(line)); if (Iterables.size(values) < 8) { return true; } BbcGenreTree.Builder genreTree = BbcGenreTree.builder(genresPrefix + values.get(0)); if (!Strings.isNullOrEmpty(values.get(1))) { genreTree.withSecondLevelGenre(genresPrefix + stripQuotationMarks(values.get(1))); } if (!Strings.isNullOrEmpty(values.get(2))) { genreTree.withThirdLevelGenre(genresPrefix + stripQuotationMarks(values.get(2))); } mapping.put(genreTree.build(), parseYouViewGenres(Iterables.skip(values, 4))); return true; }", "text": "Log/throw?", "function_tokens": ["private", "\u0120boolean", "\u0120process", "Row", "(", "String", "\u0120line", ")", "\u0120{", "\u0120List", "<", "String", ">", "\u0120values", "\u0120=", "\u0120Imm", "utable", "List", ".", "copy", "Of", "(", "ON", "_", "COM", "MA", ".", "split", "(", "line", "));", "\u0120if", "\u0120(", "Iter", "ables", ".", "size", "(", "values", ")", "\u0120<", "\u01208", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120B", "bc", "Gen", "re", "Tree", ".", "Builder", "\u0120genre", "Tree", "\u0120=", "\u0120B", "bc", "Gen", "re", "Tree", ".", "builder", "(", "gen", "res", "Pref", "ix", "\u0120+", "\u0120values", ".", "get", "(", "0", "));", "\u0120if", "\u0120(!", "Str", "ings", ".", "is", "Null", "Or", "Empty", "(", "values", ".", "get", "(", "1", ")))", "\u0120{", "\u0120genre", "Tree", ".", "with", "Second", "Level", "Gen", "re", "(", "gen", "res", "Pref", "ix", "\u0120+", "\u0120strip", "Qu", "otation", "M", "arks", "(", "values", ".", "get", "(", "1", "))", ");", "\u0120}", "\u0120if", "\u0120(!", "Str", "ings", ".", "is", "Null", "Or", "Empty", "(", "values", ".", "get", "(", "2", ")))", "\u0120{", "\u0120genre", "Tree", ".", "with", "Third", "Level", "Gen", "re", "(", "gen", "res", "Pref", "ix", "\u0120+", "\u0120strip", "Qu", "otation", "M", "arks", "(", "values", ".", "get", "(", "2", "))", ");", "\u0120}", "\u0120mapping", ".", "put", "(", "genre", "Tree", ".", "build", "(),", "\u0120parse", "You", "View", "Gen", "res", "(", "Iter", "ables", ".", "skip", "(", "values", ",", "\u01204", "))", ");", "\u0120return", "\u0120true", ";", "\u0120}"], "docstring_tokens": ["Log", "/", "throw", "?"]}
{"function": "public static String doGetFeatureUrl(String srs, JSONObject download, boolean addNameSpace) throws JSONException { String getFeatureUrl = \"\"; StringWriter s = new StringWriter(); s.append(PropertyUtil.get(\"download.basket.wfs.service.url\")); if (addNameSpace) { s.append(\"?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName=\" + srs + \"&outputFormat=SHAPE-ZIP&typeNames=\" + download.getString(PARAM_LAYER)); } else { s.append(\"?SERVICE=wfs&version=1.0.0&request=GetFeature&srsName=\" + srs + \"&outputFormat=SHAPE-ZIP&typeNames=\" + Helpers.getLayerNameWithoutNameSpace(download.getString(PARAM_LAYER))); } getFeatureUrl = s.toString(); return getFeatureUrl; }", "text": "StringBuilder instead of StringWriter would be more traditional choice, not that big of a deal though.", "function_tokens": ["public", "\u0120static", "\u0120String", "\u0120do", "Get", "Feature", "Url", "(", "String", "\u0120s", "rs", ",", "\u0120JSON", "Object", "\u0120download", ",", "\u0120boolean", "\u0120add", "Name", "Space", ")", "\u0120throws", "\u0120JSON", "Exception", "\u0120{", "\u0120String", "\u0120get", "Feature", "Url", "\u0120=", "\u0120\"", "\";", "\u0120String", "Writer", "\u0120s", "\u0120=", "\u0120new", "\u0120String", "Writer", "();", "\u0120s", ".", "append", "(", "Property", "Ut", "il", ".", "get", "(\"", "download", ".", "b", "asket", ".", "w", "fs", ".", "service", ".", "url", "\")", ");", "\u0120if", "\u0120(", "add", "Name", "Space", ")", "\u0120{", "\u0120s", ".", "append", "(\"", "?", "SER", "VICE", "=", "w", "fs", "&", "version", "=", "1", ".", "0", ".", "0", "&", "request", "=", "Get", "Feature", "&", "s", "rs", "Name", "=\"", "\u0120+", "\u0120s", "rs", "\u0120+", "\u0120\"", "&", "output", "Format", "=", "SH", "APE", "-", "Z", "IP", "&", "type", "Names", "=\"", "\u0120+", "\u0120download", ".", "get", "String", "(", "PAR", "AM", "_", "L", "AY", "ER", "));", "\u0120}", "\u0120else", "\u0120{", "\u0120s", ".", "append", "(\"", "?", "SER", "VICE", "=", "w", "fs", "&", "version", "=", "1", ".", "0", ".", "0", "&", "request", "=", "Get", "Feature", "&", "s", "rs", "Name", "=\"", "\u0120+", "\u0120s", "rs", "\u0120+", "\u0120\"", "&", "output", "Format", "=", "SH", "APE", "-", "Z", "IP", "&", "type", "Names", "=\"", "\u0120+", "\u0120Help", "ers", ".", "get", "Layer", "Name", "Without", "Name", "Space", "(", "download", ".", "get", "String", "(", "PAR", "AM", "_", "L", "AY", "ER", "))", ");", "\u0120}", "\u0120get", "Feature", "Url", "\u0120=", "\u0120s", ".", "to", "String", "();", "\u0120return", "\u0120get", "Feature", "Url", ";", "\u0120}"], "docstring_tokens": ["String", "Builder", "\u0120instead", "\u0120of", "\u0120String", "Writer", "\u0120would", "\u0120be", "\u0120more", "\u0120traditional", "\u0120choice", ",", "\u0120not", "\u0120that", "\u0120big", "\u0120of", "\u0120a", "\u0120deal", "\u0120though", "."]}
{"function": "public void init() throws DBException { _db.init(); this.reportLatencyForEachError = Boolean.parseBoolean(getProperties(). getProperty(\"reportlatencyforeacherror\", \"false\")); String latencyTrackedErrors = getProperties().getProperty( \"latencytrackederrors\", null); if (latencyTrackedErrors != null) { this.latencyTrackedErrors = new HashSet<String>(Arrays.asList( latencyTrackedErrors.split(\",\"))); } System.out.println(\"DBWrapper: report latency for each error is \" + this.reportLatencyForEachError + \" and specific error codes to track\" + \" for latency are: \" + this.latencyTrackedErrors.toString()); }", "text": "this should be on System.err", "function_tokens": ["public", "\u0120void", "\u0120init", "()", "\u0120throws", "\u0120DB", "Exception", "\u0120{", "\u0120_", "db", ".", "init", "();", "\u0120this", ".", "report", "Lat", "ency", "For", "Each", "Error", "\u0120=", "\u0120Boolean", ".", "parse", "Boo", "lean", "(", "get", "Pro", "perties", "().", "\u0120get", "Property", "(\"", "report", "lat", "ency", "fore", "acher", "ror", "\",", "\u0120\"", "false", "\")", ");", "\u0120String", "\u0120latency", "Tr", "acked", "Er", "rors", "\u0120=", "\u0120get", "Pro", "perties", "().", "get", "Property", "(", "\u0120\"", "lat", "ency", "track", "eder", "rors", "\",", "\u0120null", ");", "\u0120if", "\u0120(", "lat", "ency", "Tr", "acked", "Er", "rors", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120this", ".", "lat", "ency", "Tr", "acked", "Er", "rors", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", "String", ">(", "Ar", "rays", ".", "as", "List", "(", "\u0120latency", "Tr", "acked", "Er", "rors", ".", "split", "(", "\",\"", "))", ");", "\u0120}", "\u0120System", ".", "out", ".", "println", "(\"", "DB", "Wra", "pper", ":", "\u0120report", "\u0120latency", "\u0120for", "\u0120each", "\u0120error", "\u0120is", "\u0120\"", "\u0120+", "\u0120this", ".", "report", "Lat", "ency", "For", "Each", "Error", "\u0120+", "\u0120\"", "\u0120and", "\u0120specific", "\u0120error", "\u0120codes", "\u0120to", "\u0120track", "\"", "\u0120+", "\u0120\"", "\u0120for", "\u0120latency", "\u0120are", ":", "\u0120\"", "\u0120+", "\u0120this", ".", "lat", "ency", "Tr", "acked", "Er", "rors", ".", "to", "String", "());", "\u0120}"], "docstring_tokens": ["this", "\u0120should", "\u0120be", "\u0120on", "\u0120System", ".", "err"]}
{"function": "public ProductInfo createProduct(ProductInfo pinfo) { if (pinfo == null) { throw new IllegalArgumentException(\"pinfo is null\"); } if (StringUtils.isBlank(pinfo.getId())) { throw new IllegalArgumentException(\"product is lacking an identifier: \" + pinfo); } if (this.productMap.containsKey(pinfo.getId())) { throw new IllegalStateException(\"product already exists: \" + pinfo.getId()); } ProductData pdata = new ProductData(); pdata.setId(pinfo.getId()); pdata.setProductContent(this.resolveProductContent(pinfo.getProductContent())); pdata.setName(pinfo.getName()); pdata.setMultiplier(pinfo.getMultiplier()); pdata.setAttributes(pinfo.getAttributes()); pdata.setDependentProductIds(pinfo.getDependentProductIds()); pdata.setCreated(new Date()); pdata.setUpdated(new Date()); pdata.setBranding(this.resolveBranding(pinfo.getBranding())); pdata.setProvidedProducts(this.resolveProvidedProducts(pinfo.getProvidedProducts())); this.productMap.put(pdata.getId(), pdata); this.productSubscriptionMap.put(pdata.getId(), new HashSet<>()); this.updateProductContentMappings(pdata); return pdata; }", "text": "I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.", "function_tokens": ["public", "\u0120Product", "Info", "\u0120create", "Product", "(", "Product", "Info", "\u0120pin", "fo", ")", "\u0120{", "\u0120if", "\u0120(", "p", "info", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "p", "info", "\u0120is", "\u0120null", "\");", "\u0120}", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Bl", "ank", "(", "p", "info", ".", "get", "Id", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "product", "\u0120is", "\u0120lacking", "\u0120an", "\u0120identifier", ":", "\u0120\"", "\u0120+", "\u0120pin", "fo", ");", "\u0120}", "\u0120if", "\u0120(", "this", ".", "product", "Map", ".", "cont", "ains", "Key", "(", "p", "info", ".", "get", "Id", "()", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "State", "Exception", "(\"", "product", "\u0120already", "\u0120exists", ":", "\u0120\"", "\u0120+", "\u0120pin", "fo", ".", "get", "Id", "());", "\u0120}", "\u0120Product", "Data", "\u0120p", "data", "\u0120=", "\u0120new", "\u0120Product", "Data", "();", "\u0120p", "data", ".", "set", "Id", "(", "p", "info", ".", "get", "Id", "());", "\u0120p", "data", ".", "set", "Product", "Content", "(", "this", ".", "res", "olve", "Product", "Content", "(", "p", "info", ".", "get", "Product", "Content", "()", "));", "\u0120p", "data", ".", "set", "Name", "(", "p", "info", ".", "get", "Name", "());", "\u0120p", "data", ".", "set", "Mult", "ipl", "ier", "(", "p", "info", ".", "get", "Mult", "ipl", "ier", "());", "\u0120p", "data", ".", "set", "Attributes", "(", "p", "info", ".", "get", "Attributes", "());", "\u0120p", "data", ".", "set", "D", "ependent", "Product", "Id", "s", "(", "p", "info", ".", "get", "D", "ependent", "Product", "Id", "s", "());", "\u0120p", "data", ".", "set", "Created", "(", "new", "\u0120Date", "());", "\u0120p", "data", ".", "set", "Updated", "(", "new", "\u0120Date", "());", "\u0120p", "data", ".", "set", "Br", "anding", "(", "this", ".", "res", "olve", "Br", "anding", "(", "p", "info", ".", "get", "Br", "anding", "()", "));", "\u0120p", "data", ".", "set", "Prov", "ided", "Products", "(", "this", ".", "res", "olve", "Prov", "ided", "Products", "(", "p", "info", ".", "get", "Prov", "ided", "Products", "()", "));", "\u0120this", ".", "product", "Map", ".", "put", "(", "p", "data", ".", "get", "Id", "(),", "\u0120p", "data", ");", "\u0120this", ".", "product", "Sub", "scription", "Map", ".", "put", "(", "p", "data", ".", "get", "Id", "(),", "\u0120new", "\u0120Hash", "Set", "<", ">", "());", "\u0120this", ".", "update", "Product", "Content", "M", "appings", "(", "p", "data", ");", "\u0120return", "\u0120p", "data", ";", "\u0120}"], "docstring_tokens": ["I", "\u0120don", "'t", "\u0120think", "\u0120the", "\u0120new", "\u0120method", "\u0120resolve", "Prov", "ided", "Products", "\u0120is", "\u0120needed", ".", "\u0120We", "\u0120could", "\u0120simply", "\u0120use", "\u0120the", "\u0120existing", "\u0120resolve", "Product", "/", "res", "olve", "Products", "\u0120methods", "\u0120to", "\u0120lookup", "\u0120any", "\u0120existing", "\u0120provided", "\u0120products", "\u0120we", "\u0120have", ",", "\u0120assuming", "\u0120they", "\u0120were", "\u0120already", "\u0120created", ".", "\u0120spec", "\u0120tests", "\u0120would", "\u0120have", "\u0120to", "\u0120make", "\u0120sure", "\u0120that", "\u0120the", "\u0120provided", "\u0120products", "\u0120are", "\u0120created", "\u0120first", ",", "\u0120and", "\u0120then", "\u0120create", "\u0120a", "\u0120marketing", "\u0120product", "\u0120that", "\u0120references", "\u0120them", ".", "\u0120The", "\u0120only", "\u0120reason", "\u0120the", "\u0120resolve", "Br", "anding", "\u0120method", "\u0120was", "\u0120created", "\u0120this", "\u0120way", "\u0120was", "\u0120because", "\u0120you", "\u0120can", "'t", "\u0120really", "\u0120create", "\u0120a", "\u0120branding", "\u0120standalone", ".", "\u0120It", "\u0120is", "\u0120an", "\u0120entity", "\u0120fully", "\u0120owned", "\u0120by", "\u0120a", "\u0120product", "."]}
{"function": "public PcapPacket(PcapFile file, @Nullable Packet parent, boolean isPcapNg, ByteBuffer header, @Nullable ByteBuffer payload, long index) throws BadPacketException { super(file, parent, PcapProtocol.PCAP); if (header.array().length < PcapFileValues.PACKET_HEADER_SIZE) { fChildPacket = null; throw new BadPacketException(\"The Pcap packet header is too small.\"); } fSourceEndpoint = null; fDestinationEndpoint = null; fFields = null; fPacketIndex = index; header.order(getPcapFile().getByteOrder()); header.position(0); if (isPcapNg) { header.getInt(); header.getInt(); header.getInt(); } long timestampMostSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); long timestampLeastSignificant = ConversionHelper.unsignedIntToLong(header.getInt()); switch (getTimestampScale()) { case MICROSECOND: if (timestampLeastSignificant > TIMESTAMP_MICROSECOND_MAX) { fChildPacket = null; throw new BadPacketException(\"The timestamp is erroneous.\"); } fTimestamp = TIMESTAMP_MICROSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; case NANOSECOND: if (timestampLeastSignificant > TIMESTAMP_NANOSECOND_MAX) { fChildPacket = null; throw new BadPacketException(\"The timestamp is erroneous.\"); } fTimestamp = TIMESTAMP_NANOSECOND_MAX * timestampMostSignificant + timestampLeastSignificant; break; default: throw new IllegalArgumentException(\"The timestamp precision is not valid!\"); } fIncludedLength = ConversionHelper.unsignedIntToLong(header.getInt()); fOriginalLength = ConversionHelper.unsignedIntToLong(header.getInt()); final ByteBuffer pcapPacket = payload; if (pcapPacket == null) { fChildPacket = null; fPayload = null; return; } pcapPacket.order(ByteOrder.BIG_ENDIAN); pcapPacket.position(0); fPayload = pcapPacket; fChildPacket = findChildPacket(); }", "text": "read the values and validate", "function_tokens": ["public", "\u0120P", "cap", "P", "acket", "(", "P", "cap", "File", "\u0120file", ",", "\u0120@", "Null", "able", "\u0120Pack", "et", "\u0120parent", ",", "\u0120boolean", "\u0120is", "P", "cap", "N", "g", ",", "\u0120Byte", "Buffer", "\u0120header", ",", "\u0120@", "Null", "able", "\u0120Byte", "Buffer", "\u0120payload", ",", "\u0120long", "\u0120index", ")", "\u0120throws", "\u0120Bad", "P", "acket", "Exception", "\u0120{", "\u0120super", "(", "file", ",", "\u0120parent", ",", "\u0120P", "cap", "Prot", "ocol", ".", "PC", "AP", ");", "\u0120if", "\u0120(", "header", ".", "array", "().", "length", "\u0120<", "\u0120P", "cap", "File", "Values", ".", "P", "ACK", "ET", "_", "HEAD", "ER", "_", "SIZE", ")", "\u0120{", "\u0120f", "Child", "P", "acket", "\u0120=", "\u0120null", ";", "\u0120throw", "\u0120new", "\u0120Bad", "P", "acket", "Exception", "(\"", "The", "\u0120P", "cap", "\u0120packet", "\u0120header", "\u0120is", "\u0120too", "\u0120small", ".\"", ");", "\u0120}", "\u0120f", "Source", "End", "point", "\u0120=", "\u0120null", ";", "\u0120f", "Dest", "ination", "End", "point", "\u0120=", "\u0120null", ";", "\u0120f", "Field", "s", "\u0120=", "\u0120null", ";", "\u0120f", "P", "acket", "Index", "\u0120=", "\u0120index", ";", "\u0120header", ".", "order", "(", "get", "P", "cap", "File", "().", "get", "Byte", "Order", "());", "\u0120header", ".", "position", "(", "0", ");", "\u0120if", "\u0120(", "is", "P", "cap", "N", "g", ")", "\u0120{", "\u0120header", ".", "get", "Int", "();", "\u0120header", ".", "get", "Int", "();", "\u0120header", ".", "get", "Int", "();", "\u0120}", "\u0120long", "\u0120timestamp", "Most", "Sign", "ificant", "\u0120=", "\u0120Conversion", "Helper", ".", "unsigned", "Int", "To", "Long", "(", "header", ".", "get", "Int", "());", "\u0120long", "\u0120timestamp", "Le", "ast", "Sign", "ificant", "\u0120=", "\u0120Conversion", "Helper", ".", "unsigned", "Int", "To", "Long", "(", "header", ".", "get", "Int", "());", "\u0120switch", "\u0120(", "get", "Tim", "estamp", "Scale", "())", "\u0120{", "\u0120case", "\u0120MIC", "R", "OS", "EC", "OND", ":", "\u0120if", "\u0120(", "tim", "estamp", "Le", "ast", "Sign", "ificant", "\u0120>", "\u0120TIM", "EST", "AMP", "_", "MIC", "R", "OS", "EC", "OND", "_", "MAX", ")", "\u0120{", "\u0120f", "Child", "P", "acket", "\u0120=", "\u0120null", ";", "\u0120throw", "\u0120new", "\u0120Bad", "P", "acket", "Exception", "(\"", "The", "\u0120timestamp", "\u0120is", "\u0120erroneous", ".\"", ");", "\u0120}", "\u0120f", "Tim", "estamp", "\u0120=", "\u0120TIM", "EST", "AMP", "_", "MIC", "R", "OS", "EC", "OND", "_", "MAX", "\u0120*", "\u0120timestamp", "Most", "Sign", "ificant", "\u0120+", "\u0120timestamp", "Le", "ast", "Sign", "ificant", ";", "\u0120break", ";", "\u0120case", "\u0120N", "AN", "OS", "EC", "OND", ":", "\u0120if", "\u0120(", "tim", "estamp", "Le", "ast", "Sign", "ificant", "\u0120>", "\u0120TIM", "EST", "AMP", "_", "N", "AN", "OS", "EC", "OND", "_", "MAX", ")", "\u0120{", "\u0120f", "Child", "P", "acket", "\u0120=", "\u0120null", ";", "\u0120throw", "\u0120new", "\u0120Bad", "P", "acket", "Exception", "(\"", "The", "\u0120timestamp", "\u0120is", "\u0120erroneous", ".\"", ");", "\u0120}", "\u0120f", "Tim", "estamp", "\u0120=", "\u0120TIM", "EST", "AMP", "_", "N", "AN", "OS", "EC", "OND", "_", "MAX", "\u0120*", "\u0120timestamp", "Most", "Sign", "ificant", "\u0120+", "\u0120timestamp", "Le", "ast", "Sign", "ificant", ";", "\u0120break", ";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "The", "\u0120timestamp", "\u0120precision", "\u0120is", "\u0120not", "\u0120valid", "!\"", ");", "\u0120}", "\u0120f", "In", "cluded", "Length", "\u0120=", "\u0120Conversion", "Helper", ".", "unsigned", "Int", "To", "Long", "(", "header", ".", "get", "Int", "());", "\u0120f", "Original", "Length", "\u0120=", "\u0120Conversion", "Helper", ".", "unsigned", "Int", "To", "Long", "(", "header", ".", "get", "Int", "());", "\u0120final", "\u0120Byte", "Buffer", "\u0120p", "cap", "P", "acket", "\u0120=", "\u0120payload", ";", "\u0120if", "\u0120(", "p", "cap", "P", "acket", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120f", "Child", "P", "acket", "\u0120=", "\u0120null", ";", "\u0120f", "Pay", "load", "\u0120=", "\u0120null", ";", "\u0120return", ";", "\u0120}", "\u0120p", "cap", "P", "acket", ".", "order", "(", "Byte", "Order", ".", "BI", "G", "_", "END", "IAN", ");", "\u0120p", "cap", "P", "acket", ".", "position", "(", "0", ");", "\u0120f", "Pay", "load", "\u0120=", "\u0120p", "cap", "P", "acket", ";", "\u0120f", "Child", "P", "acket", "\u0120=", "\u0120find", "Child", "P", "acket", "();", "\u0120}"], "docstring_tokens": ["read", "\u0120the", "\u0120values", "\u0120and", "\u0120validate"]}
{"function": "public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); System.out.println(headers.get(name)); return headers.get(name); }", "text": "Need to remove this leftover debug output", "function_tokens": ["public", "\u0120List", "<", "String", ">", "\u0120get", "Head", "ers", "(", "String", "\u0120name", ")", "\u0120{", "\u0120Mult", "ival", "ued", "Map", "<", "String", ",", "\u0120String", ">", "\u0120headers", "\u0120=", "\u0120request", "Context", ".", "get", "M", "utable", "Head", "ers", "();", "\u0120System", ".", "out", ".", "println", "(", "headers", ".", "get", "(", "name", "));", "\u0120return", "\u0120headers", ".", "get", "(", "name", ");", "\u0120}"], "docstring_tokens": ["Need", "\u0120to", "\u0120remove", "\u0120this", "\u0120leftover", "\u0120debug", "\u0120output"]}
{"function": "public Boolean call() throws Exception { long sleepBackoff = 200L, maxSleep = 0L; do { final PoolEntry poolEntry = createPoolEntry(); if (poolEntry != null) { connectionBag.add(poolEntry); return Boolean.TRUE; } else if (poolEntry == MAXED_POOL_MARKER) { return Boolean.FALSE; } else if (maxSleep == sleepBackoff) { return Boolean.FALSE; } maxSleep = sleepBackoff; quietlySleep(sleepBackoff); sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3)); } while (true); }", "text": "How can this work? This is going to insert MAXED_POOL_MARKER into the bag.", "function_tokens": ["public", "\u0120Boolean", "\u0120call", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120long", "\u0120sleep", "Back", "off", "\u0120=", "\u0120200", "L", ",", "\u0120max", "Sleep", "\u0120=", "\u01200", "L", ";", "\u0120do", "\u0120{", "\u0120final", "\u0120Pool", "Entry", "\u0120pool", "Entry", "\u0120=", "\u0120create", "Pool", "Entry", "();", "\u0120if", "\u0120(", "pool", "Entry", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120connection", "B", "ag", ".", "add", "(", "pool", "Entry", ");", "\u0120return", "\u0120Boolean", ".", "TR", "UE", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "pool", "Entry", "\u0120==", "\u0120MAX", "ED", "_", "PO", "OL", "_", "M", "ARK", "ER", ")", "\u0120{", "\u0120return", "\u0120Boolean", ".", "F", "ALSE", ";", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "max", "Sleep", "\u0120==", "\u0120sleep", "Back", "off", ")", "\u0120{", "\u0120return", "\u0120Boolean", ".", "F", "ALSE", ";", "\u0120}", "\u0120max", "Sleep", "\u0120=", "\u0120sleep", "Back", "off", ";", "\u0120quietly", "Sleep", "(", "sleep", "Back", "off", ");", "\u0120sleep", "Back", "off", "\u0120=", "\u0120Math", ".", "min", "(", "connection", "Timeout", "\u0120/", "\u01202", ",", "\u0120(", "long", ")", "\u0120(", "sleep", "Back", "off", "\u0120*", "\u01201", ".", "3", "));", "\u0120}", "\u0120while", "\u0120(", "true", ");", "\u0120}"], "docstring_tokens": ["How", "\u0120can", "\u0120this", "\u0120work", "?", "\u0120This", "\u0120is", "\u0120going", "\u0120to", "\u0120insert", "\u0120MAX", "ED", "_", "PO", "OL", "_", "M", "ARK", "ER", "\u0120into", "\u0120the", "\u0120bag", "."]}
{"function": "private void createFeatures(ArcGISMap map){ LayerList layers = map.getOperationalLayers(); for(Layer layer: layers){ FeatureLayer fLayer = (FeatureLayer) layer; if(fLayer.getName().contains(\"Alaska National Parks\")){ mOperationalLayers.add(fLayer); } } List<ArcGISFeatureTable> tables = map.getTables(); final ArcGISFeatureTable speciesFeatureTable = tables.get(0); speciesFeatureTable.addDoneLoadingListener(new Runnable() { @Override public void run() { Log.d(TAG, \"Found table: \" + speciesFeatureTable.getTableName()); } }); speciesFeatureTable.loadAsync(); }", "text": "No need to explicitly load tables with query if you are using the latest build", "function_tokens": ["private", "\u0120void", "\u0120create", "Features", "(", "Arc", "G", "IS", "Map", "\u0120map", "){", "\u0120Layer", "List", "\u0120layers", "\u0120=", "\u0120map", ".", "get", "Oper", "ational", "L", "ayers", "();", "\u0120for", "(", "Layer", "\u0120layer", ":", "\u0120layers", "){", "\u0120Feature", "Layer", "\u0120f", "Layer", "\u0120=", "\u0120(", "Feature", "Layer", ")", "\u0120layer", ";", "\u0120if", "(", "f", "Layer", ".", "get", "Name", "().", "cont", "ains", "(\"", "Al", "aska", "\u0120National", "\u0120Parks", "\"))", "{", "\u0120m", "Oper", "ational", "L", "ayers", ".", "add", "(", "f", "Layer", ");", "\u0120}", "\u0120}", "\u0120List", "<", "Arc", "G", "IS", "Feature", "Table", ">", "\u0120tables", "\u0120=", "\u0120map", ".", "get", "T", "ables", "();", "\u0120final", "\u0120Arc", "G", "IS", "Feature", "Table", "\u0120species", "Feature", "Table", "\u0120=", "\u0120tables", ".", "get", "(", "0", ");", "\u0120species", "Feature", "Table", ".", "add", "Done", "Loading", "Listener", "(", "new", "\u0120Run", "n", "able", "()", "\u0120{", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120Log", ".", "d", "(", "TAG", ",", "\u0120\"", "Found", "\u0120table", ":", "\u0120\"", "\u0120+", "\u0120species", "Feature", "Table", ".", "get", "Table", "Name", "());", "\u0120}", "\u0120});", "\u0120species", "Feature", "Table", ".", "load", "Async", "();", "\u0120}"], "docstring_tokens": ["No", "\u0120need", "\u0120to", "\u0120explicitly", "\u0120load", "\u0120tables", "\u0120with", "\u0120query", "\u0120if", "\u0120you", "\u0120are", "\u0120using", "\u0120the", "\u0120latest", "\u0120build"]}
{"function": "public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) { if (clazz == null || json == null) { return; } for (int i = 0; i < json.length(); i++) { try { configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false); } catch (JSONException e) { throw new RealmException(\"Could not map Json\", e); } } }", "text": "\"Json\" -> \"JSON\" (do a search-n-replace)", "function_tokens": ["public", "\u0120<", "E", "\u0120extends", "\u0120Realm", "Object", ">", "\u0120void", "\u0120create", "All", "From", "J", "son", "(", "Class", "<", "E", ">", "\u0120cl", "azz", ",", "\u0120JSON", "Array", "\u0120json", ")", "\u0120{", "\u0120if", "\u0120(", "cl", "azz", "\u0120==", "\u0120null", "\u0120||", "\u0120json", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120json", ".", "length", "();", "\u0120i", "++)", "\u0120{", "\u0120try", "\u0120{", "\u0120configuration", ".", "get", "Sche", "ma", "Med", "iator", "().", "create", "Or", "Update", "Using", "J", "son", "Object", "(", "cl", "azz", ",", "\u0120this", ",", "\u0120json", ".", "get", "JSON", "Object", "(", "i", "),", "\u0120false", ");", "\u0120}", "\u0120catch", "\u0120(", "JSON", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Realm", "Exception", "(\"", "Could", "\u0120not", "\u0120map", "\u0120J", "son", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["\"", "J", "son", "\"", "\u0120->", "\u0120\"", "JSON", "\"", "\u0120(", "do", "\u0120a", "\u0120search", "-", "n", "-", "replace", ")"]}
{"function": "protected ClusterState execute(ClusterState currentState, AlterTableRequest request) throws Exception { Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.tableIdent().indexNameOrAlias()); if (request.isPartitioned()) { if (request.partitionIndexName() != null) { concreteIndices = indexNameExpressionResolver.concreteIndices(currentState, INDICES_OPTIONS, request.partitionIndexName()); currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } else { currentState = updateTemplate(currentState, request); if (!request.excludePartitions()) { List<String> supportedSettings = TableParameters.PARTITIONED_TABLE_PARAMETER_INFO_FOR_TEMPLATE_UPDATE .supportedSettings() .values() .stream() .map(Setting::getKey) .collect(Collectors.toList()); supportedSettings.add(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS); TableParameter parameterWithFilteredSettings = new TableParameter(request.settings(), supportedSettings); currentState = updateSettings(currentState, parameterWithFilteredSettings.settings(), concreteIndices); currentState = updateMapping(currentState, request, concreteIndices); } } } else { currentState = updateMapping(currentState, request, concreteIndices); currentState = updateSettings(currentState, request.settings(), concreteIndices); } return currentState; }", "text": "Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here)", "function_tokens": ["protected", "\u0120Cluster", "State", "\u0120execute", "(", "Cl", "uster", "State", "\u0120current", "State", ",", "\u0120Alter", "Table", "Request", "\u0120request", ")", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Index", "[]", "\u0120concrete", "Ind", "ices", "\u0120=", "\u0120index", "Name", "Exp", "ression", "Res", "olver", ".", "con", "crete", "Ind", "ices", "(", "current", "State", ",", "\u0120IND", "ICES", "_", "OP", "T", "IONS", ",", "\u0120request", ".", "table", "Ident", "().", "index", "Name", "Or", "Alias", "());", "\u0120if", "\u0120(", "request", ".", "is", "Part", "ition", "ed", "())", "\u0120{", "\u0120if", "\u0120(", "request", ".", "part", "ition", "Index", "Name", "()", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120concrete", "Ind", "ices", "\u0120=", "\u0120index", "Name", "Exp", "ression", "Res", "olver", ".", "con", "crete", "Ind", "ices", "(", "current", "State", ",", "\u0120IND", "ICES", "_", "OP", "T", "IONS", ",", "\u0120request", ".", "part", "ition", "Index", "Name", "());", "\u0120current", "State", "\u0120=", "\u0120update", "M", "apping", "(", "current", "State", ",", "\u0120request", ",", "\u0120concrete", "Ind", "ices", ");", "\u0120current", "State", "\u0120=", "\u0120update", "Settings", "(", "current", "State", ",", "\u0120request", ".", "settings", "(),", "\u0120concrete", "Ind", "ices", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120current", "State", "\u0120=", "\u0120update", "Template", "(", "current", "State", ",", "\u0120request", ");", "\u0120if", "\u0120(!", "request", ".", "ex", "clude", "Part", "itions", "())", "\u0120{", "\u0120List", "<", "String", ">", "\u0120supported", "Settings", "\u0120=", "\u0120Table", "Parameters", ".", "PART", "ITION", "ED", "_", "TABLE", "_", "PAR", "AM", "ET", "ER", "_", "INFO", "_", "FOR", "_", "T", "EM", "PL", "ATE", "_", "UPDATE", "\u0120.", "supported", "Settings", "()", "\u0120.", "values", "()", "\u0120.", "stream", "()", "\u0120.", "map", "(", "Setting", "::", "get", "Key", ")", "\u0120.", "collect", "(", "Collect", "ors", ".", "to", "List", "());", "\u0120supported", "Settings", ".", "add", "(", "Index", "Meta", "Data", ".", "SET", "TING", "_", "AUT", "O", "_", "EXP", "AND", "_", "RE", "PLIC", "AS", ");", "\u0120Table", "Parameter", "\u0120parameter", "With", "Fil", "tered", "Settings", "\u0120=", "\u0120new", "\u0120Table", "Parameter", "(", "request", ".", "settings", "(),", "\u0120supported", "Settings", ");", "\u0120current", "State", "\u0120=", "\u0120update", "Settings", "(", "current", "State", ",", "\u0120parameter", "With", "Fil", "tered", "Settings", ".", "settings", "(),", "\u0120concrete", "Ind", "ices", ");", "\u0120current", "State", "\u0120=", "\u0120update", "M", "apping", "(", "current", "State", ",", "\u0120request", ",", "\u0120concrete", "Ind", "ices", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120current", "State", "\u0120=", "\u0120update", "M", "apping", "(", "current", "State", ",", "\u0120request", ",", "\u0120concrete", "Ind", "ices", ");", "\u0120current", "State", "\u0120=", "\u0120update", "Settings", "(", "current", "State", ",", "\u0120request", ".", "settings", "(),", "\u0120concrete", "Ind", "ices", ");", "\u0120}", "\u0120return", "\u0120current", "State", ";", "\u0120}"], "docstring_tokens": ["Could", "\u0120we", "\u0120move", "\u0120this", "\u0120call", "\u0120elsewhere", "\u0120given", "\u0120that", "\u0120in", "\u0120some", "\u0120cases", "\u0120it", "\u0120becomes", "\u0120unused", "?", "\u0120(", "e", ".", "g", ".", "\u0120if", "\u0120partition", "ed", "\u0120and", "\u0120part", "ioned", "Index", "Name", "\u0120!=", "\u0120null", "\u0120then", "\u0120we", "\u0120don", "'t", "\u0120use", "\u0120the", "\u0120result", "\u0120here", ")"]}
{"function": "public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject fDiffProject : fDiffProjects) { IProject tempProject = Utilities.getProject(fDiffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }", "text": "not a field", "function_tokens": ["public", "\u0120IS", "ched", "uling", "Rule", "[]", "\u0120get", "Target", "Project", "s", "()", "\u0120{", "\u0120List", "<", "IS", "ched", "uling", "Rule", ">", "\u0120projects", "=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120I", "Resource", "Rule", "Factory", "\u0120rule", "Factory", "=", "\u0120Resources", "Plugin", ".", "get", "Works", "pace", "().", "get", "Rule", "Factory", "();", "\u0120for", "\u0120(", "Diff", "Project", "\u0120f", "Diff", "Project", "\u0120:", "\u0120f", "Diff", "Project", "s", ")", "\u0120{", "\u0120I", "Project", "\u0120temp", "Project", "\u0120=", "\u0120Utilities", ".", "get", "Project", "(", "f", "Diff", "Project", ");", "\u0120IS", "ched", "uling", "Rule", "\u0120schedule", "Rule", "=", "\u0120rule", "Factory", ".", "mod", "ify", "Rule", "(", "temp", "Project", ".", "get", "File", "(", "I", "Project", "Description", ".", "DES", "CRIPTION", "_", "FILE", "_", "NAME", "));", "\u0120Multi", "Rule", "\u0120multi", "Rule", "=", "\u0120new", "\u0120Multi", "Rule", "(", "new", "\u0120IS", "ched", "uling", "Rule", "[]", "\u0120{", "\u0120schedule", "Rule", ",", "\u0120temp", "Project", "\u0120}", "\u0120);", "\u0120projects", ".", "add", "(", "multi", "Rule", ");", "\u0120}", "\u0120return", "\u0120projects", ".", "to", "Array", "(", "new", "\u0120IS", "ched", "uling", "Rule", "[", "projects", ".", "size", "()", "]);", "\u0120}"], "docstring_tokens": ["not", "\u0120a", "\u0120field"]}
{"function": "public static void fillReleasesTable(XWPFTable table, Collection<LicenseInfoParsingResult> projectLicenseInfoResults) { for (LicenseInfoParsingResult result : projectLicenseInfoResults) { String releaseName = nullToEmptyString(result.getName()); String version = nullToEmptyString(result.getVersion()); if (result.getStatus()== LicenseInfoRequestStatus.SUCCESS) { Set<String> copyrights = Collections.emptySet(); Set<LicenseNameWithText> licenseNamesWithTexts = Collections.emptySet(); Set<String> acknowledgements = Collections.emptySet(); if (result.isSetLicenseInfo()) { LicenseInfo licenseInfo = result.getLicenseInfo(); if (licenseInfo.isSetCopyrights()) { copyrights = licenseInfo.getCopyrights(); } if (licenseInfo.isSetLicenseNamesWithTexts()) { licenseNamesWithTexts = licenseInfo.getLicenseNamesWithTexts(); acknowledgements = licenseNamesWithTexts.stream() .map(LicenseNameWithText::getAcknowledgements) .filter(Objects::nonNull).collect(Collectors.toSet()); } } addReleaseTableRow(table, releaseName, version, licenseNamesWithTexts, acknowledgements, copyrights); } else { String filename = Optional.ofNullable(result.getLicenseInfo()) .map(LicenseInfo::getFilenames) .map(l -> l.stream().findFirst().orElse(null)) .orElse(\"\"); addReleaseTableErrorRow(table, releaseName, version, nullToEmptyString(result.getMessage()), filename); } } }", "text": "the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).", "function_tokens": ["public", "\u0120static", "\u0120void", "\u0120fill", "Re", "leases", "Table", "(", "X", "WP", "FT", "able", "\u0120table", ",", "\u0120Collection", "<", "License", "Info", "P", "ars", "ing", "Result", ">", "\u0120project", "License", "Info", "Results", ")", "\u0120{", "\u0120for", "\u0120(", "License", "Info", "P", "ars", "ing", "Result", "\u0120result", "\u0120:", "\u0120project", "License", "Info", "Results", ")", "\u0120{", "\u0120String", "\u0120release", "Name", "\u0120=", "\u0120null", "To", "Empty", "String", "(", "result", ".", "get", "Name", "());", "\u0120String", "\u0120version", "\u0120=", "\u0120null", "To", "Empty", "String", "(", "result", ".", "get", "Version", "());", "\u0120if", "\u0120(", "result", ".", "get", "Status", "()", "==", "\u0120License", "Info", "Request", "Status", ".", "SU", "CC", "ESS", ")", "\u0120{", "\u0120Set", "<", "String", ">", "\u0120cop", "yrights", "\u0120=", "\u0120Collections", ".", "empty", "Set", "();", "\u0120Set", "<", "License", "Name", "With", "Text", ">", "\u0120license", "Names", "With", "Text", "s", "\u0120=", "\u0120Collections", ".", "empty", "Set", "();", "\u0120Set", "<", "String", ">", "\u0120acknowled", "gements", "\u0120=", "\u0120Collections", ".", "empty", "Set", "();", "\u0120if", "\u0120(", "result", ".", "is", "Set", "License", "Info", "())", "\u0120{", "\u0120License", "Info", "\u0120license", "Info", "\u0120=", "\u0120result", ".", "get", "License", "Info", "();", "\u0120if", "\u0120(", "license", "Info", ".", "is", "Set", "Cop", "yrights", "())", "\u0120{", "\u0120cop", "yrights", "\u0120=", "\u0120license", "Info", ".", "get", "Cop", "yrights", "();", "\u0120}", "\u0120if", "\u0120(", "license", "Info", ".", "is", "Set", "License", "Names", "With", "Text", "s", "())", "\u0120{", "\u0120license", "Names", "With", "Text", "s", "\u0120=", "\u0120license", "Info", ".", "get", "License", "Names", "With", "Text", "s", "();", "\u0120acknowled", "gements", "\u0120=", "\u0120license", "Names", "With", "Text", "s", ".", "stream", "()", "\u0120.", "map", "(", "License", "Name", "With", "Text", "::", "get", "Acknowled", "gements", ")", "\u0120.", "filter", "(", "Object", "s", "::", "non", "Null", ").", "collect", "(", "Collect", "ors", ".", "to", "Set", "());", "\u0120}", "\u0120}", "\u0120add", "Release", "Table", "Row", "(", "table", ",", "\u0120release", "Name", ",", "\u0120version", ",", "\u0120license", "Names", "With", "Text", "s", ",", "\u0120acknowled", "gements", ",", "\u0120cop", "yrights", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120filename", "\u0120=", "\u0120Optional", ".", "of", "Null", "able", "(", "result", ".", "get", "License", "Info", "())", "\u0120.", "map", "(", "License", "Info", "::", "get", "Fil", "en", "ames", ")", "\u0120.", "map", "(", "l", "\u0120->", "\u0120l", ".", "stream", "().", "find", "First", "().", "or", "Else", "(", "null", "))", "\u0120.", "or", "Else", "(\"", "\");", "\u0120add", "Release", "Table", "Error", "Row", "(", "table", ",", "\u0120release", "Name", ",", "\u0120version", ",", "\u0120null", "To", "Empty", "String", "(", "result", ".", "get", "Message", "()", "),", "\u0120filename", ");", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["the", "\u0120line", "\u0120.", "map", "(", "l", "\u0120->", "\u0120l", ".", "stream", "().", "find", "First", "().", "or", "Else", "(", "null", "))", "\u0120might", "\u0120be", "\u0120equivalent", "\u0120to", "\u0120.", "flat", "Map", "(", "l", "\u0120->", "\u0120l", ".", "stream", "().", "find", "First", "()", ")."]}
{"function": "public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { throw new IllegalArgumentException( \"startTimeNanos should be greater than 0!\" ); } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = \"SlowQuery: \" + queryExecutionMillis + \" milliseconds. SQL: '\" + sql + \"'\"; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }", "text": "I would suggest providing more clue about the exception like  throw new IllegalArgumentException( \"startTimeNanos [\" + startTimeNanos + \"] should be greater than 0!\" );  to help debugger a little bit.", "function_tokens": ["public", "\u0120void", "\u0120log", "Slow", "Query", "(", "String", "\u0120sql", ",", "\u0120long", "\u0120start", "Time", "N", "anos", ")", "\u0120{", "\u0120if", "\u0120(", "\u0120log", "Slow", "Query", "\u0120<", "\u01201", "\u0120)", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "\u0120start", "Time", "N", "anos", "\u0120<=", "\u01200", "\u0120)", "\u0120{", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "start", "Time", "N", "anos", "\u0120should", "\u0120be", "\u0120greater", "\u0120than", "\u01200", "!\"", "\u0120);", "\u0120}", "\u0120long", "\u0120query", "Exec", "ution", "Mill", "is", "\u0120=", "\u0120Time", "Unit", ".", "N", "AN", "OS", "EC", "ON", "DS", ".", "to", "Mill", "is", "(", "\u0120System", ".", "n", "ano", "Time", "()", "\u0120-", "\u0120start", "Time", "N", "anos", "\u0120);", "\u0120if", "\u0120(", "\u0120query", "Exec", "ution", "Mill", "is", "\u0120>", "\u0120log", "Slow", "Query", "\u0120)", "\u0120{", "\u0120String", "\u0120log", "Data", "\u0120=", "\u0120\"", "Slow", "Query", ":", "\u0120\"", "\u0120+", "\u0120query", "Exec", "ution", "Mill", "is", "\u0120+", "\u0120\"", "\u0120milliseconds", ".", "\u0120SQL", ":", "\u0120'", "\"", "\u0120+", "\u0120sql", "\u0120+", "\u0120\"'", "\";", "\u0120LOG", "_", "SL", "OW", ".", "info", "(", "\u0120log", "Data", "\u0120);", "\u0120if", "\u0120(", "\u0120log", "To", "St", "d", "out", "\u0120)", "\u0120{", "\u0120System", ".", "out", ".", "println", "(", "\u0120log", "Data", "\u0120);", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120would", "\u0120suggest", "\u0120providing", "\u0120more", "\u0120clue", "\u0120about", "\u0120the", "\u0120exception", "\u0120like", "\u0120", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(", "\u0120\"", "start", "Time", "N", "anos", "\u0120[\"", "\u0120+", "\u0120start", "Time", "N", "anos", "\u0120+", "\u0120\"", "]", "\u0120should", "\u0120be", "\u0120greater", "\u0120than", "\u01200", "!\"", "\u0120);", "\u0120", "\u0120to", "\u0120help", "\u0120debugger", "\u0120a", "\u0120little", "\u0120bit", "."]}
{"function": "public void bucketLoaded(AbstractBucket<Object> bucket) { try { super.bucketLoaded(bucket); logger.debug(\"Bucket {} loaded\", bucket.bucketKey); eventBucketExchanger.exchange(bucket.bucketKey, 1, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { logger.debug(\"Timeout happened\"); } catch (InterruptedException e) { e.printStackTrace(); } }", "text": "why swallowing?", "function_tokens": ["public", "\u0120void", "\u0120bucket", "Load", "ed", "(", "Abstract", "B", "ucket", "<", "Object", ">", "\u0120bucket", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120super", ".", "buck", "et", "Load", "ed", "(", "buck", "et", ");", "\u0120logger", ".", "debug", "(\"", "B", "ucket", "\u0120{}", "\u0120loaded", "\",", "\u0120bucket", ".", "buck", "et", "Key", ");", "\u0120event", "B", "ucket", "Ex", "ch", "anger", ".", "ex", "change", "(", "buck", "et", ".", "buck", "et", "Key", ",", "\u01201", ",", "\u0120Time", "Unit", ".", "M", "ILL", "IS", "EC", "ON", "DS", ");", "\u0120}", "\u0120catch", "\u0120(", "Timeout", "Exception", "\u0120e", ")", "\u0120{", "\u0120logger", ".", "debug", "(\"", "Timeout", "\u0120happened", "\");", "\u0120}", "\u0120catch", "\u0120(", "Inter", "rupted", "Exception", "\u0120e", ")", "\u0120{", "\u0120e", ".", "print", "Stack", "Tr", "ace", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["why", "\u0120swallowing", "?"]}
{"function": "public ControllerFactory() { }", "text": "Why public?", "function_tokens": ["public", "\u0120Controller", "Factory", "()", "\u0120{", "\u0120}"], "docstring_tokens": ["Why", "\u0120public", "?"]}
{"function": "public void inputReady(NHttpServerConnection conn, ContentDecoder decoder) { try { ProtocolState protocolState = SourceContext.getState(conn); if (protocolState != ProtocolState.REQUEST_HEAD && protocolState != ProtocolState.REQUEST_BODY) { handleInvalidState(conn, \"Request message body data received\"); return; } log.info(\"point 1\"); SourceContext.updateState(conn, ProtocolState.REQUEST_BODY); SourceRequest request = SourceContext.getRequest(conn); int readBytes = request.read(conn, decoder); if (isMessageSizeValidationEnabled) { HttpContext httpContext = conn.getContext(); if (httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM) == null) { httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, 0); } int messageSizeSum = (int) httpContext.getAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM); messageSizeSum += readBytes; if (messageSizeSum > validMaxMessageSize) { log.warn(\"Payload exceeds valid payload size range, hence discontinuing chunk stream at \" + messageSizeSum + \" bytes to prevent OOM.\"); dropSourceConnection(conn); conn.getContext().setAttribute(PassThroughConstants.SOURCE_CONNECTION_DROPPED, true); request.getPipe().forceProducerComplete(decoder); } httpContext.setAttribute(PassThroughConstants.MESSAGE_SIZE_VALIDATION_SUM, messageSizeSum); } if (readBytes > 0) { metrics.incrementBytesReceived(readBytes); } } catch (IOException e) { logIOException(conn, e); informReaderError(conn); SourceContext.updateState(conn, ProtocolState.CLOSED); sourceConfiguration.getSourceConnections().shutDownConnection(conn, true); } }", "text": "remove this log", "function_tokens": ["public", "\u0120void", "\u0120input", "Ready", "(", "NH", "ttp", "Server", "Connection", "\u0120conn", ",", "\u0120Content", "Dec", "oder", "\u0120dec", "oder", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Protocol", "State", "\u0120protocol", "State", "\u0120=", "\u0120Source", "Context", ".", "get", "State", "(", "conn", ");", "\u0120if", "\u0120(", "prot", "ocol", "State", "\u0120!=", "\u0120Protocol", "State", ".", "RE", "QUEST", "_", "HEAD", "\u0120&&", "\u0120protocol", "State", "\u0120!=", "\u0120Protocol", "State", ".", "RE", "QUEST", "_", "B", "ODY", ")", "\u0120{", "\u0120handle", "Invalid", "State", "(", "conn", ",", "\u0120\"", "Request", "\u0120message", "\u0120body", "\u0120data", "\u0120received", "\");", "\u0120return", ";", "\u0120}", "\u0120log", ".", "info", "(\"", "point", "\u01201", "\");", "\u0120Source", "Context", ".", "update", "State", "(", "conn", ",", "\u0120Protocol", "State", ".", "RE", "QUEST", "_", "B", "ODY", ");", "\u0120Source", "Request", "\u0120request", "\u0120=", "\u0120Source", "Context", ".", "get", "Request", "(", "conn", ");", "\u0120int", "\u0120read", "Bytes", "\u0120=", "\u0120request", ".", "read", "(", "conn", ",", "\u0120dec", "oder", ");", "\u0120if", "\u0120(", "is", "Message", "Size", "Val", "idation", "Enabled", ")", "\u0120{", "\u0120H", "ttp", "Context", "\u0120http", "Context", "\u0120=", "\u0120conn", ".", "get", "Context", "();", "\u0120if", "\u0120(", "http", "Context", ".", "get", "Attribute", "(", "Pass", "Through", "Const", "ants", ".", "M", "ES", "SA", "GE", "_", "SIZE", "_", "VAL", "ID", "ATION", "_", "S", "UM", ")", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120http", "Context", ".", "set", "Attribute", "(", "Pass", "Through", "Const", "ants", ".", "M", "ES", "SA", "GE", "_", "SIZE", "_", "VAL", "ID", "ATION", "_", "S", "UM", ",", "\u01200", ");", "\u0120}", "\u0120int", "\u0120message", "Size", "Sum", "\u0120=", "\u0120(", "int", ")", "\u0120http", "Context", ".", "get", "Attribute", "(", "Pass", "Through", "Const", "ants", ".", "M", "ES", "SA", "GE", "_", "SIZE", "_", "VAL", "ID", "ATION", "_", "S", "UM", ");", "\u0120message", "Size", "Sum", "\u0120+=", "\u0120read", "Bytes", ";", "\u0120if", "\u0120(", "message", "Size", "Sum", "\u0120>", "\u0120valid", "Max", "Message", "Size", ")", "\u0120{", "\u0120log", ".", "warn", "(\"", "Pay", "load", "\u0120exceeds", "\u0120valid", "\u0120payload", "\u0120size", "\u0120range", ",", "\u0120hence", "\u0120discontin", "uing", "\u0120chunk", "\u0120stream", "\u0120at", "\u0120\"", "\u0120+", "\u0120message", "Size", "Sum", "\u0120+", "\u0120\"", "\u0120bytes", "\u0120to", "\u0120prevent", "\u0120O", "OM", ".\"", ");", "\u0120drop", "Source", "Connection", "(", "conn", ");", "\u0120conn", ".", "get", "Context", "().", "set", "Attribute", "(", "Pass", "Through", "Const", "ants", ".", "SOURCE", "_", "CON", "N", "ECTION", "_", "DR", "OP", "P", "ED", ",", "\u0120true", ");", "\u0120request", ".", "get", "P", "ipe", "().", "force", "Produ", "cer", "Complete", "(", "dec", "oder", ");", "\u0120}", "\u0120http", "Context", ".", "set", "Attribute", "(", "Pass", "Through", "Const", "ants", ".", "M", "ES", "SA", "GE", "_", "SIZE", "_", "VAL", "ID", "ATION", "_", "S", "UM", ",", "\u0120message", "Size", "Sum", ");", "\u0120}", "\u0120if", "\u0120(", "read", "Bytes", "\u0120>", "\u01200", ")", "\u0120{", "\u0120metrics", ".", "incre", "ment", "Bytes", "Re", "ceived", "(", "read", "Bytes", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", "IO", "Exception", "(", "conn", ",", "\u0120e", ");", "\u0120inform", "Reader", "Error", "(", "conn", ");", "\u0120Source", "Context", ".", "update", "State", "(", "conn", ",", "\u0120Protocol", "State", ".", "CL", "OSED", ");", "\u0120source", "Configuration", ".", "get", "Source", "Connect", "ions", "().", "shut", "Down", "Connection", "(", "conn", ",", "\u0120true", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["remove", "\u0120this", "\u0120log"]}
{"function": "private ColumnChunk readStruct(GroupField field) throws IOException { List<TypeSignatureParameter> fields = field.getType().getTypeSignature().getParameters(); Block[] blocks = new Block[fields.size()]; ColumnChunk columnChunk = null; List<Optional<Field>> parameters = field.getChildren(); for (int i = 0; i < fields.size(); i++) { Optional<Field> parameter = parameters.get(i); if (parameter.isPresent()) { columnChunk = readColumnChunk(parameter.get()); blocks[i] = columnChunk.getBlock(); } } for (int i = 0; i < fields.size(); i++) { if (blocks[i] == null) { blocks[i] = RunLengthEncodedBlock.create(field.getType(), null, columnChunk.getBlock().getPositionCount()); } } BooleanList structIsNull = ParquetStructColumnReader.calculateStructOffsets(field, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); Block rowBlock = RowBlock.fromFieldBlocks(structIsNull.toBooleanArray(), blocks, structIsNull.toBooleanArray().length); return new ColumnChunk(rowBlock, columnChunk.getDefinitionLevels(), columnChunk.getRepetitionLevels()); }", "text": "is double call to structIsNull.toBooleanArray() intentional?", "function_tokens": ["private", "\u0120Column", "Ch", "unk", "\u0120read", "Struct", "(", "Group", "Field", "\u0120field", ")", "\u0120throws", "\u0120IO", "Exception", "\u0120{", "\u0120List", "<", "Type", "Sign", "ature", "Parameter", ">", "\u0120fields", "\u0120=", "\u0120field", ".", "get", "Type", "().", "get", "Type", "Sign", "ature", "().", "get", "Parameters", "();", "\u0120Block", "[]", "\u0120blocks", "\u0120=", "\u0120new", "\u0120Block", "[", "fields", ".", "size", "()", "];", "\u0120Column", "Ch", "unk", "\u0120column", "Ch", "unk", "\u0120=", "\u0120null", ";", "\u0120List", "<", "Optional", "<", "Field", ">>", "\u0120parameters", "\u0120=", "\u0120field", ".", "get", "Children", "();", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120fields", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120Optional", "<", "Field", ">", "\u0120parameter", "\u0120=", "\u0120parameters", ".", "get", "(", "i", ");", "\u0120if", "\u0120(", "param", "eter", ".", "is", "Present", "())", "\u0120{", "\u0120column", "Ch", "unk", "\u0120=", "\u0120read", "Column", "Ch", "unk", "(", "param", "eter", ".", "get", "());", "\u0120blocks", "[", "i", "]", "\u0120=", "\u0120column", "Ch", "unk", ".", "get", "Block", "();", "\u0120}", "\u0120}", "\u0120for", "\u0120(", "int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120fields", ".", "size", "();", "\u0120i", "++)", "\u0120{", "\u0120if", "\u0120(", "blocks", "[", "i", "]", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120blocks", "[", "i", "]", "\u0120=", "\u0120Run", "Length", "Enc", "oded", "Block", ".", "create", "(", "field", ".", "get", "Type", "(),", "\u0120null", ",", "\u0120column", "Ch", "unk", ".", "get", "Block", "().", "get", "Position", "Count", "());", "\u0120}", "\u0120}", "\u0120Boolean", "List", "\u0120struct", "Is", "Null", "\u0120=", "\u0120Par", "quet", "Struct", "Column", "Reader", ".", "cal", "cul", "ate", "Struct", "Off", "sets", "(", "field", ",", "\u0120column", "Ch", "unk", ".", "get", "Definition", "Level", "s", "(),", "\u0120column", "Ch", "unk", ".", "get", "Rep", "etition", "Level", "s", "());", "\u0120Block", "\u0120row", "Block", "\u0120=", "\u0120Row", "Block", ".", "from", "Field", "Blocks", "(", "struct", "Is", "Null", ".", "to", "Boo", "lean", "Array", "(),", "\u0120blocks", ",", "\u0120struct", "Is", "Null", ".", "to", "Boo", "lean", "Array", "().", "length", ");", "\u0120return", "\u0120new", "\u0120Column", "Ch", "unk", "(", "row", "Block", ",", "\u0120column", "Ch", "unk", ".", "get", "Definition", "Level", "s", "(),", "\u0120column", "Ch", "unk", ".", "get", "Rep", "etition", "Level", "s", "());", "\u0120}"], "docstring_tokens": ["is", "\u0120double", "\u0120call", "\u0120to", "\u0120struct", "Is", "Null", ".", "to", "Boo", "lean", "Array", "()", "\u0120intentional", "?"]}
{"function": "private void regenerateCertificatesImpl(Iterable<Entitlement> entitlements) { if (entitlements != null) { Set<String> deadCertIds = new HashSet<>(); for (Entitlement entitlement : entitlements) { Set<EntitlementCertificate> existing = entitlement.getCertificates(); try { entitlement.setCertificates(null); EntitlementCertificate generated = this.generateEntitlementCertificate( entitlement.getPool(), entitlement); entitlement.setDirty(false); this.eventSink.queueEvent(this.eventFactory.entitlementChanged(entitlement)); log.debug(\"Generated entitlementCertificate: #{}\", generated.getId()); if (existing != null) { for (EntitlementCertificate cert : existing) { if (cert != null) { deadCertIds.add(cert.getId()); this.entitlementCertificateCurator.evict(cert); } } } } catch (CertificateSizeException cse) { entitlement.setCertificates(existing); log.warn(\"The certificate cannot be regenerated at this time: {}\", cse.getMessage()); } } this.entitlementCurator.saveOrUpdateAll(entitlements, false, false); int count = this.entitlementCertificateCurator.deleteByIds(deadCertIds); log.debug(\"{} old entitlement certificates deleted\"); } }", "text": "suggestion log.debug(\"{} old entitlement certificates deleted\", count);", "function_tokens": ["private", "\u0120void", "\u0120regenerate", "Cert", "ific", "ates", "Impl", "(", "Iter", "able", "<", "Ent", "it", "lement", ">", "\u0120entitle", "ments", ")", "\u0120{", "\u0120if", "\u0120(", "ent", "itle", "ments", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120Set", "<", "String", ">", "\u0120dead", "Cert", "Id", "s", "\u0120=", "\u0120new", "\u0120Hash", "Set", "<", ">", "();", "\u0120for", "\u0120(", "Ent", "it", "lement", "\u0120entitlement", "\u0120:", "\u0120entitle", "ments", ")", "\u0120{", "\u0120Set", "<", "Ent", "it", "lement", "Cert", "ificate", ">", "\u0120existing", "\u0120=", "\u0120entitlement", ".", "get", "Cert", "ific", "ates", "();", "\u0120try", "\u0120{", "\u0120entitlement", ".", "set", "Cert", "ific", "ates", "(", "null", ");", "\u0120Ent", "it", "lement", "Cert", "ificate", "\u0120generated", "\u0120=", "\u0120this", ".", "gener", "ate", "Ent", "it", "lement", "Cert", "ificate", "(", "\u0120entitlement", ".", "get", "Pool", "(),", "\u0120entitlement", ");", "\u0120entitlement", ".", "set", "D", "irty", "(", "false", ");", "\u0120this", ".", "event", "S", "ink", ".", "queue", "Event", "(", "this", ".", "event", "Factory", ".", "ent", "it", "lement", "Changed", "(", "ent", "it", "lement", "));", "\u0120log", ".", "debug", "(\"", "Gener", "ated", "\u0120entitlement", "Cert", "ificate", ":", "\u0120#", "{", "}", "\",", "\u0120generated", ".", "get", "Id", "());", "\u0120if", "\u0120(", "existing", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "Ent", "it", "lement", "Cert", "ificate", "\u0120cert", "\u0120:", "\u0120existing", ")", "\u0120{", "\u0120if", "\u0120(", "cert", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120dead", "Cert", "Id", "s", ".", "add", "(", "cert", ".", "get", "Id", "());", "\u0120this", ".", "ent", "it", "lement", "Cert", "ificate", "Cur", "ator", ".", "ev", "ict", "(", "cert", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Cert", "ificate", "Size", "Exception", "\u0120c", "se", ")", "\u0120{", "\u0120entitlement", ".", "set", "Cert", "ific", "ates", "(", "existing", ");", "\u0120log", ".", "warn", "(\"", "The", "\u0120certificate", "\u0120cannot", "\u0120be", "\u0120regener", "ated", "\u0120at", "\u0120this", "\u0120time", ":", "\u0120{}", "\",", "\u0120c", "se", ".", "get", "Message", "());", "\u0120}", "\u0120}", "\u0120this", ".", "ent", "it", "lement", "Cur", "ator", ".", "save", "Or", "Update", "All", "(", "ent", "itle", "ments", ",", "\u0120false", ",", "\u0120false", ");", "\u0120int", "\u0120count", "\u0120=", "\u0120this", ".", "ent", "it", "lement", "Cert", "ificate", "Cur", "ator", ".", "delete", "ById", "s", "(", "dead", "Cert", "Id", "s", ");", "\u0120log", ".", "debug", "(\"", "{", "}", "\u0120old", "\u0120entitlement", "\u0120certificates", "\u0120deleted", "\");", "\u0120}", "\u0120}"], "docstring_tokens": ["suggest", "ion", "\u0120log", ".", "debug", "(\"", "{", "}", "\u0120old", "\u0120entitlement", "\u0120certificates", "\u0120deleted", "\",", "\u0120count", ");"]}
{"function": "public boolean delete(final Identifier queryId) { if(queryStateMap.containsKey(queryId)) { queryStateMap.remove(queryId); return true; } else { return false; } }", "text": "replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;", "function_tokens": ["public", "\u0120boolean", "\u0120delete", "(", "final", "\u0120Ident", "ifier", "\u0120query", "Id", ")", "\u0120{", "\u0120if", "(", "query", "State", "Map", ".", "cont", "ains", "Key", "(", "query", "Id", "))", "\u0120{", "\u0120query", "State", "Map", ".", "remove", "(", "query", "Id", ");", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["replace", "\u0120the", "\u0120if", "\u0120...", "\u0120else", "\u0120block", "\u0120with", "\u0120", "\u0120return", "\u0120query", "State", "Map", ".", "remove", "(", "query", "Id", ")", "\u0120!=", "\u0120null", "\u0120?", "\u0120true", "\u0120:", "\u0120false", ";"]}
{"function": "public boolean onOptionsItemSelected(MenuItem item) { Intent intent = null; switch (item.getItemId()) { case R.id.menu_load: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, \"No connection found, please connect your device and try again\", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, \"Already fetching forms, ignored the request\", Toast.LENGTH_SHORT).show(); return true; } if (hasFormsWithData()) { Toast.makeText(this, \"There is existing form data for selected form(s). Finish Incomplete data and sync Complete data to Server first before downloading selected forms\", Toast.LENGTH_SHORT).show(); return true; } syncAllFormsInBackgroundService(); return true; case R.id.menu_upload: if (!NetworkUtils.isConnectedToNetwork(this)) { Toast.makeText(this, \"No connection found, please connect your device and try again\", Toast.LENGTH_SHORT).show(); return true; } if (syncInProgress) { Toast.makeText(this, \"Already uploading forms, ignored the request\", Toast.LENGTH_SHORT).show(); return true; } uploadAllFormsInBackgroundService(); return true; case R.id.menu_client_add: intent = new Intent(this, RegistrationFormsActivity.class); startActivity(intent); return true; case R.id.menu_tags: if (mainLayout.isDrawerOpen(GravityCompat.END)) { mainLayout.closeDrawer(GravityCompat.END); } else { mainLayout.openDrawer(GravityCompat.END); } return true; default: return super.onOptionsItemSelected(item); } }", "text": "Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?", "function_tokens": ["public", "\u0120boolean", "\u0120on", "Options", "Item", "Se", "lected", "(", "Menu", "Item", "\u0120item", ")", "\u0120{", "\u0120Intent", "\u0120intent", "\u0120=", "\u0120null", ";", "\u0120switch", "\u0120(", "item", ".", "get", "Item", "Id", "())", "\u0120{", "\u0120case", "\u0120R", ".", "id", ".", "menu", "_", "load", ":", "\u0120if", "\u0120(!", "Network", "Ut", "ils", ".", "is", "Connect", "ed", "To", "Network", "(", "this", "))", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "this", ",", "\u0120\"", "No", "\u0120connection", "\u0120found", ",", "\u0120please", "\u0120connect", "\u0120your", "\u0120device", "\u0120and", "\u0120try", "\u0120again", "\",", "\u0120Toast", ".", "L", "ENGTH", "_", "SH", "ORT", ").", "show", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "sync", "In", "Progress", ")", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "this", ",", "\u0120\"", "Already", "\u0120fetch", "ing", "\u0120forms", ",", "\u0120ignored", "\u0120the", "\u0120request", "\",", "\u0120Toast", ".", "L", "ENGTH", "_", "SH", "ORT", ").", "show", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "has", "Form", "s", "With", "Data", "())", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "this", ",", "\u0120\"", "There", "\u0120is", "\u0120existing", "\u0120form", "\u0120data", "\u0120for", "\u0120selected", "\u0120form", "(", "s", ").", "\u0120Finish", "\u0120In", "complete", "\u0120data", "\u0120and", "\u0120sync", "\u0120Complete", "\u0120data", "\u0120to", "\u0120Server", "\u0120first", "\u0120before", "\u0120downloading", "\u0120selected", "\u0120forms", "\",", "\u0120Toast", ".", "L", "ENGTH", "_", "SH", "ORT", ").", "show", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120sync", "All", "Form", "s", "In", "Background", "Service", "();", "\u0120return", "\u0120true", ";", "\u0120case", "\u0120R", ".", "id", ".", "menu", "_", "upload", ":", "\u0120if", "\u0120(!", "Network", "Ut", "ils", ".", "is", "Connect", "ed", "To", "Network", "(", "this", "))", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "this", ",", "\u0120\"", "No", "\u0120connection", "\u0120found", ",", "\u0120please", "\u0120connect", "\u0120your", "\u0120device", "\u0120and", "\u0120try", "\u0120again", "\",", "\u0120Toast", ".", "L", "ENGTH", "_", "SH", "ORT", ").", "show", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "sync", "In", "Progress", ")", "\u0120{", "\u0120Toast", ".", "make", "Text", "(", "this", ",", "\u0120\"", "Already", "\u0120uploading", "\u0120forms", ",", "\u0120ignored", "\u0120the", "\u0120request", "\",", "\u0120Toast", ".", "L", "ENGTH", "_", "SH", "ORT", ").", "show", "();", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120upload", "All", "Form", "s", "In", "Background", "Service", "();", "\u0120return", "\u0120true", ";", "\u0120case", "\u0120R", ".", "id", ".", "menu", "_", "client", "_", "add", ":", "\u0120intent", "\u0120=", "\u0120new", "\u0120Intent", "(", "this", ",", "\u0120Registration", "Form", "s", "Activity", ".", "class", ");", "\u0120start", "Activity", "(", "intent", ");", "\u0120return", "\u0120true", ";", "\u0120case", "\u0120R", ".", "id", ".", "menu", "_", "tags", ":", "\u0120if", "\u0120(", "main", "Layout", ".", "is", "Draw", "er", "Open", "(", "G", "ravity", "Compat", ".", "END", "))", "\u0120{", "\u0120main", "Layout", ".", "close", "Draw", "er", "(", "G", "ravity", "Compat", ".", "END", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120main", "Layout", ".", "open", "Draw", "er", "(", "G", "ravity", "Compat", ".", "END", ");", "\u0120}", "\u0120return", "\u0120true", ";", "\u0120default", ":", "\u0120return", "\u0120super", ".", "on", "Options", "Item", "Se", "lected", "(", "item", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["Make", "\u0120the", "\u0120code", "\u0120fold", "\u0120to", "\u0120the", "\u0120next", "\u0120line", "\u0120when", "\u0120the", "\u0120code", "\u0120is", "\u0120too", "\u0120long", ".", "\u0120And", "\u0120probably", "\u0120put", "\u0120this", "\u0120text", "\u0120in", "\u0120the", "\u0120strings", ".", "xml", "?"]}
{"function": "public void handle(XFormParser p, Element e, Object parent) { String event = e.getAttributeValue(null, \"event\"); FormDef form = (FormDef) parent; PollSensorAction action; String ref = e.getAttributeValue(null, \"ref\"); if (ref != null) { IDataReference dataRef = new XPathReference(ref); if (dataRef != null) { dataRef = XFormParser.getAbsRef(dataRef, TreeReference.rootRef()); } TreeReference treeRef = FormInstance.unpackReference(dataRef); p.registerActionTarget(treeRef); action = new PollSensorAction(treeRef); } else { action = new PollSensorAction(); } form.registerEventListener(event, action); }", "text": "Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.", "function_tokens": ["public", "\u0120void", "\u0120handle", "(", "X", "Form", "Parser", "\u0120p", ",", "\u0120Element", "\u0120e", ",", "\u0120Object", "\u0120parent", ")", "\u0120{", "\u0120String", "\u0120event", "\u0120=", "\u0120e", ".", "get", "Attribute", "Value", "(", "null", ",", "\u0120\"", "event", "\");", "\u0120Form", "Def", "\u0120form", "\u0120=", "\u0120(", "Form", "Def", ")", "\u0120parent", ";", "\u0120Poll", "Sensor", "Action", "\u0120action", ";", "\u0120String", "\u0120ref", "\u0120=", "\u0120e", ".", "get", "Attribute", "Value", "(", "null", ",", "\u0120\"", "ref", "\");", "\u0120if", "\u0120(", "ref", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120ID", "ata", "Reference", "\u0120data", "Ref", "\u0120=", "\u0120new", "\u0120XP", "ath", "Reference", "(", "ref", ");", "\u0120if", "\u0120(", "data", "Ref", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120data", "Ref", "\u0120=", "\u0120X", "Form", "Parser", ".", "get", "Abs", "Ref", "(", "data", "Ref", ",", "\u0120Tree", "Reference", ".", "root", "Ref", "());", "\u0120}", "\u0120Tree", "Reference", "\u0120tree", "Ref", "\u0120=", "\u0120Form", "Instance", ".", "un", "pack", "Reference", "(", "data", "Ref", ");", "\u0120p", ".", "register", "Action", "Target", "(", "tree", "Ref", ");", "\u0120action", "\u0120=", "\u0120new", "\u0120Poll", "Sensor", "Action", "(", "tree", "Ref", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120action", "\u0120=", "\u0120new", "\u0120Poll", "Sensor", "Action", "();", "\u0120}", "\u0120form", ".", "register", "Event", "Listener", "(", "event", ",", "\u0120action", ");", "\u0120}"], "docstring_tokens": ["Se", "ems", "\u0120unlikely", "\u0120that", "\u0120data", "Ref", "\u0120would", "\u0120be", "\u0120null", "\u0120having", "\u0120just", "\u0120assigned", "\u0120the", "\u0120result", "\u0120of", "\u0120a", "\u0120class", "\u0120constructor", "\u0120to", "\u0120it", "."]}
{"function": "public void setQuotaMode(QuotaMode mode) { logger.info(\"Setting Quota mode to \" + mode.name()); this.mode = mode; }", "text": "nit: try to avoid string concatenation in the log.  logger.info(\"Setting Quota mode to {}\", mode.name());", "function_tokens": ["public", "\u0120void", "\u0120set", "Qu", "ota", "Mode", "(", "Qu", "ota", "Mode", "\u0120mode", ")", "\u0120{", "\u0120logger", ".", "info", "(\"", "Setting", "\u0120Qu", "ota", "\u0120mode", "\u0120to", "\u0120\"", "\u0120+", "\u0120mode", ".", "name", "());", "\u0120this", ".", "mode", "\u0120=", "\u0120mode", ";", "\u0120}"], "docstring_tokens": ["nit", ":", "\u0120try", "\u0120to", "\u0120avoid", "\u0120string", "\u0120conc", "aten", "ation", "\u0120in", "\u0120the", "\u0120log", ".", "\u0120", "\u0120logger", ".", "info", "(\"", "Setting", "\u0120Qu", "ota", "\u0120mode", "\u0120to", "\u0120{}", "\",", "\u0120mode", ".", "name", "());"]}
{"function": "private static boolean isPreJava8() { final String version = System.getProperty(\"java.version\"); final String[] parts = version.split(\"\\\\.\"); try { int major = Integer.parseInt(parts[1]); final int token = Integer.parseInt(parts[0]); boolean isJEP223 = token != 1; if (isJEP223) { major = token; } return major < 8; } catch (final Exception ex) { return true; } }", "text": "Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.", "function_tokens": ["private", "\u0120static", "\u0120boolean", "\u0120is", "Pre", "Java", "8", "()", "\u0120{", "\u0120final", "\u0120String", "\u0120version", "\u0120=", "\u0120System", ".", "get", "Property", "(\"", "java", ".", "version", "\");", "\u0120final", "\u0120String", "[]", "\u0120parts", "\u0120=", "\u0120version", ".", "split", "(\"", "\\\\", ".\"", ");", "\u0120try", "\u0120{", "\u0120int", "\u0120major", "\u0120=", "\u0120Integer", ".", "parse", "Int", "(", "parts", "[", "1", "]);", "\u0120final", "\u0120int", "\u0120token", "\u0120=", "\u0120Integer", ".", "parse", "Int", "(", "parts", "[", "0", "]);", "\u0120boolean", "\u0120is", "J", "EP", "223", "\u0120=", "\u0120token", "\u0120!=", "\u01201", ";", "\u0120if", "\u0120(", "is", "J", "EP", "223", ")", "\u0120{", "\u0120major", "\u0120=", "\u0120token", ";", "\u0120}", "\u0120return", "\u0120major", "\u0120<", "\u01208", ";", "\u0120}", "\u0120catch", "\u0120(", "final", "\u0120Exception", "\u0120ex", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["Can", "\u0120we", "\u0120make", "\u0120this", "\u0120method", "\u0120delegate", "\u0120to", "\u0120a", "\u0120package", "-", "private", "\u0120static", "\u0120boolean", "\u0120is", "Pre", "Java", "8", "(", "String", "\u0120java", "Version", ")", "\u0120which", "\u0120we", "\u0120can", "\u0120invoke", "\u0120directly", "\u0120from", "\u0120the", "\u0120test", "?", "\u0120The", "\u0120reflective", "\u0120method", "\u0120is", "\u0120likely", "\u0120to", "\u0120cause", "\u0120failures", "\u0120if", "\u0120we", "\u0120ref", "actor", "\u0120this", "\u0120code", "\u0120in", "\u0120the", "\u0120future", ",", "\u0120and", "\u0120setting", "\u0120the", "\u0120java", ".", "version", "\u0120system", "\u0120property", "\u0120may", "\u0120have", "\u0120other", "\u0120consequences", "\u0120which", "\u0120I", "'d", "\u0120prefer", "\u0120to", "\u0120avoid", "."]}
{"function": "public PagingProvider<ReconnectableConnection, ReconnectableConnection> pagedOperation(Integer failOn) { return new PagingProvider<ReconnectableConnection, ReconnectableConnection>() { Integer counter = 0; @Override public List<ReconnectableConnection> getPage(ReconnectableConnection connection) { counter++; if (counter == failOn) { throw new ModuleException(MuleErrors.CONNECTIVITY, new ConnectionException(\"Failed to retrieve Page\")); } return Collections.singletonList(connection); } @Override public Optional<Integer> getTotalResults(ReconnectableConnection connection) { return Optional.empty(); } @Override public void close(ReconnectableConnection connection) { } }; }", "text": "static import", "function_tokens": ["public", "\u0120P", "aging", "Provider", "<", "Rec", "on", "nect", "able", "Connection", ",", "\u0120Recon", "nect", "able", "Connection", ">", "\u0120p", "aged", "Operation", "(", "Integer", "\u0120fail", "On", ")", "\u0120{", "\u0120return", "\u0120new", "\u0120P", "aging", "Provider", "<", "Rec", "on", "nect", "able", "Connection", ",", "\u0120Recon", "nect", "able", "Connection", ">", "()", "\u0120{", "\u0120Integer", "\u0120counter", "\u0120=", "\u01200", ";", "\u0120@", "Override", "\u0120public", "\u0120List", "<", "Rec", "on", "nect", "able", "Connection", ">", "\u0120get", "Page", "(", "Rec", "on", "nect", "able", "Connection", "\u0120connection", ")", "\u0120{", "\u0120counter", "++;", "\u0120if", "\u0120(", "counter", "\u0120==", "\u0120fail", "On", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Module", "Exception", "(", "M", "ule", "Er", "rors", ".", "CON", "NECT", "IV", "ITY", ",", "\u0120new", "\u0120Connection", "Exception", "(\"", "F", "ailed", "\u0120to", "\u0120retrieve", "\u0120Page", "\")", ");", "\u0120}", "\u0120return", "\u0120Collections", ".", "sing", "leton", "List", "(", "connection", ");", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120Optional", "<", "Integer", ">", "\u0120get", "Total", "Results", "(", "Rec", "on", "nect", "able", "Connection", "\u0120connection", ")", "\u0120{", "\u0120return", "\u0120Optional", ".", "empty", "();", "\u0120}", "\u0120@", "Override", "\u0120public", "\u0120void", "\u0120close", "(", "Rec", "on", "nect", "able", "Connection", "\u0120connection", ")", "\u0120{", "\u0120}", "\u0120};", "\u0120}"], "docstring_tokens": ["static", "\u0120import"]}
{"function": "public boolean writeMutexCell(String tenantId, String schemaName, String tableName, String columnName, String familyName) throws SQLException { try { byte[] rowKey = columnName != null ? SchemaUtil.getColumnKey(tenantId, schemaName, tableName, columnName, familyName) : SchemaUtil.getTableKey(tenantId, schemaName, tableName); byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); try (Table sysMutexTable = getTable(sysMutexPhysicalTableNameBytes)) { byte[] family = PhoenixDatabaseMetaData.SYSTEM_MUTEX_FAMILY_NAME_BYTES; byte[] qualifier = PhoenixDatabaseMetaData.SYSTEM_MUTEX_COLUMN_NAME_BYTES; byte[] value = MUTEX_LOCKED; Put put = new Put(rowKey); put.addColumn(family, qualifier, value); boolean checkAndPut = sysMutexTable.checkAndPut(rowKey, family, qualifier, null, put); String processName = ManagementFactory.getRuntimeMXBean().getName(); String msg = \" tenantId : \" + tenantId + \" schemaName : \" + schemaName + \" tableName : \" + tableName + \" columnName : \" + columnName + \" familyName : \" + familyName; if (!checkAndPut) { LOGGER.error(processName + \" failed to acquire mutex for \"+ msg); } else { LOGGER.debug(processName + \" acquired mutex for \"+ msg); } return checkAndPut; } } catch (IOException e) { throw ServerUtil.parseServerException(e); } }", "text": "byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that.", "function_tokens": ["public", "\u0120boolean", "\u0120write", "Mut", "ex", "Cell", "(", "String", "\u0120tenant", "Id", ",", "\u0120String", "\u0120schema", "Name", ",", "\u0120String", "\u0120table", "Name", ",", "\u0120String", "\u0120column", "Name", ",", "\u0120String", "\u0120family", "Name", ")", "\u0120throws", "\u0120SQ", "LE", "x", "ception", "\u0120{", "\u0120try", "\u0120{", "\u0120byte", "[]", "\u0120row", "Key", "\u0120=", "\u0120column", "Name", "\u0120!=", "\u0120null", "\u0120?", "\u0120Sche", "ma", "Ut", "il", ".", "get", "Column", "Key", "(", "ten", "ant", "Id", ",", "\u0120schema", "Name", ",", "\u0120table", "Name", ",", "\u0120column", "Name", ",", "\u0120family", "Name", ")", "\u0120:", "\u0120Sche", "ma", "Ut", "il", ".", "get", "Table", "Key", "(", "ten", "ant", "Id", ",", "\u0120schema", "Name", ",", "\u0120table", "Name", ");", "\u0120byte", "[]", "\u0120sys", "Mut", "ex", "Physical", "Table", "Name", "Bytes", "\u0120=", "\u0120get", "Sys", "Mut", "ex", "Physical", "Table", "Name", "Bytes", "();", "\u0120try", "\u0120(", "Table", "\u0120sys", "Mut", "ex", "Table", "\u0120=", "\u0120get", "Table", "(", "sys", "Mut", "ex", "Physical", "Table", "Name", "Bytes", "))", "\u0120{", "\u0120byte", "[]", "\u0120family", "\u0120=", "\u0120Phoenix", "Database", "Meta", "Data", ".", "SY", "STEM", "_", "M", "UT", "EX", "_", "F", "AM", "ILY", "_", "NAME", "_", "BY", "T", "ES", ";", "\u0120byte", "[]", "\u0120qualifier", "\u0120=", "\u0120Phoenix", "Database", "Meta", "Data", ".", "SY", "STEM", "_", "M", "UT", "EX", "_", "COL", "UM", "N", "_", "NAME", "_", "BY", "T", "ES", ";", "\u0120byte", "[]", "\u0120value", "\u0120=", "\u0120M", "UT", "EX", "_", "LOCK", "ED", ";", "\u0120Put", "\u0120put", "\u0120=", "\u0120new", "\u0120Put", "(", "row", "Key", ");", "\u0120put", ".", "add", "Column", "(", "family", ",", "\u0120qualifier", ",", "\u0120value", ");", "\u0120boolean", "\u0120check", "And", "Put", "\u0120=", "\u0120sys", "Mut", "ex", "Table", ".", "check", "And", "Put", "(", "row", "Key", ",", "\u0120family", ",", "\u0120qualifier", ",", "\u0120null", ",", "\u0120put", ");", "\u0120String", "\u0120process", "Name", "\u0120=", "\u0120Management", "Factory", ".", "get", "Runtime", "MX", "Be", "an", "().", "get", "Name", "();", "\u0120String", "\u0120msg", "\u0120=", "\u0120\"", "\u0120tenant", "Id", "\u0120:", "\u0120\"", "\u0120+", "\u0120tenant", "Id", "\u0120+", "\u0120\"", "\u0120schema", "Name", "\u0120:", "\u0120\"", "\u0120+", "\u0120schema", "Name", "\u0120+", "\u0120\"", "\u0120table", "Name", "\u0120:", "\u0120\"", "\u0120+", "\u0120table", "Name", "\u0120+", "\u0120\"", "\u0120column", "Name", "\u0120:", "\u0120\"", "\u0120+", "\u0120column", "Name", "\u0120+", "\u0120\"", "\u0120family", "Name", "\u0120:", "\u0120\"", "\u0120+", "\u0120family", "Name", ";", "\u0120if", "\u0120(!", "check", "And", "Put", ")", "\u0120{", "\u0120LOG", "GER", ".", "error", "(", "process", "Name", "\u0120+", "\u0120\"", "\u0120failed", "\u0120to", "\u0120acquire", "\u0120mut", "ex", "\u0120for", "\u0120\"+", "\u0120msg", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(", "process", "Name", "\u0120+", "\u0120\"", "\u0120acquired", "\u0120mut", "ex", "\u0120for", "\u0120\"+", "\u0120msg", ");", "\u0120}", "\u0120return", "\u0120check", "And", "Put", ";", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120Server", "Ut", "il", ".", "parse", "Server", "Exception", "(", "e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["byte", "[]", "\u0120sys", "Mut", "ex", "Physical", "Table", "Name", "Bytes", "\u0120=", "\u0120get", "Sys", "Mut", "ex", "Physical", "Table", "Name", "Bytes", "();", "\u0120If", "\u0120I", "\u0120understand", "\u0120correctly", "\u0120what", "\u0120@", "Ch", "in", "may", "SK", "ulk", "arn", "i", "\u0120described", "\u0120in", "\u0120the", "\u0120ticket", ",", "\u0120this", "\u0120call", "\u0120will", "\u0120still", "\u0120result", "\u0120to", "\u0120an", "\u0120admin", ".", "table", "Ex", "ists", "\u0120call", "\u0120to", "\u0120check", "\u0120the", "\u0120exist", "ance", "\u0120of", "\u0120SYSTEM", ".", "M", "UT", "EX", "/", "SY", "STEM", ":", "M", "UT", "EX", "\u0120and", "\u0120you", "\u0120didn", "'t", "\u0120changed", "\u0120that", "."]}
{"function": "public ReadableByteChannel get(PageId pageId, int pageOffset) throws IOException, PageNotFoundException { Path p = getFilePath(pageId); if (!Files.exists(p)) { throw new PageNotFoundException(p.toString()); } FileInputStream fis = new FileInputStream(p.toFile()); fis.skip(pageOffset); return fis.getChannel(); }", "text": "[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE", "function_tokens": ["public", "\u0120Read", "able", "Byte", "Channel", "\u0120get", "(", "Page", "Id", "\u0120page", "Id", ",", "\u0120int", "\u0120page", "Offset", ")", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Page", "Not", "Found", "Exception", "\u0120{", "\u0120Path", "\u0120p", "\u0120=", "\u0120get", "File", "Path", "(", "page", "Id", ");", "\u0120if", "\u0120(!", "Files", ".", "ex", "ists", "(", "p", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Page", "Not", "Found", "Exception", "(", "p", ".", "to", "String", "());", "\u0120}", "\u0120File", "Input", "Stream", "\u0120f", "is", "\u0120=", "\u0120new", "\u0120File", "Input", "Stream", "(", "p", ".", "to", "File", "());", "\u0120f", "is", ".", "skip", "(", "page", "Offset", ");", "\u0120return", "\u0120f", "is", ".", "get", "Channel", "();", "\u0120}"], "docstring_tokens": ["[", "ERROR", "]", "\u0120all", "ux", "io", ".", "client", ".", "file", ".", "cache", ".", "store", ".", "Local", "Page", "Store", ".", "get", "(", "Page", "Id", ",", "\u0120int", ")", "\u0120may", "\u0120fail", "\u0120to", "\u0120clean", "\u0120up", "\u0120java", ".", "io", ".", "Input", "Stream", "\u0120on", "\u0120checked", "\u0120exception", "\u0120[", "all", "ux", "io", ".", "client", ".", "file", ".", "cache", ".", "store", ".", "Local", "Page", "Store", ",", "\u0120all", "ux", "io", ".", "client", ".", "file", ".", "cache", ".", "store", ".", "Local", "Page", "Store", "]", "\u0120Ob", "lig", "ation", "\u0120to", "\u0120clean", "\u0120up", "\u0120resource", "\u0120created", "\u0120at", "\u0120Local", "Page", "Store", ".", "java", ":[", "line", "\u012078", "]", "\u0120is", "\u0120not", "\u0120discharged", "Path", "\u0120continues", "\u0120at", "\u0120Local", "Page", "Store", ".", "java", ":[", "line", "\u012079", "]", "\u0120O", "BL", "_", "UN", "S", "AT", "IS", "FI", "ED", "_", "O", "BL", "IG", "ATION", "_", "EX", "CEPT", "ION", "_", "ED", "GE"]}
{"function": "String extractMetadataFromSlots(List<oasis.names.tc.ebxml_regrep.xsd.rim._3.SlotType1> documentSlots, String slotName, int valueIndex) { LOG.debug(\"extractMetadataFromSlots slotname: {}; index: {}\", slotName, valueIndex); String slotValue = null; for (SlotType1 slot : documentSlots) { if (slotName.equals(slot.getName())) { LOG.debug(\"Found {}: {}\", slotName, slot.getValueList().getValue()); if (valueIndex < 0) { slotValue = StringUtils.join(slot.getValueList().getValue(), VALUE_LIST_SEPERATOR); } else if (slot.getValueList() != null && slot.getValueList().getValue() != null && !slot.getValueList().getValue().isEmpty()) { slotValue = slot.getValueList().getValue().get(valueIndex); } else { slotValue = \"\"; } break; } } LOG.debug(\"{}: {}\", slotName, slotValue); return slotValue; }", "text": "This statement slot.getValueList().getValue()) could cause an NPE", "function_tokens": ["String", "\u0120extract", "Met", "adata", "From", "Sl", "ots", "(", "List", "<", "o", "asis", ".", "names", ".", "tc", ".", "eb", "xml", "_", "reg", "rep", ".", "x", "sd", ".", "rim", "._", "3", ".", "Slot", "Type", "1", ">", "\u0120document", "Sl", "ots", ",", "\u0120String", "\u0120slot", "Name", ",", "\u0120int", "\u0120value", "Index", ")", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "ext", "ract", "Met", "adata", "From", "Sl", "ots", "\u0120slot", "name", ":", "\u0120{", "};", "\u0120index", ":", "\u0120{}", "\",", "\u0120slot", "Name", ",", "\u0120value", "Index", ");", "\u0120String", "\u0120slot", "Value", "\u0120=", "\u0120null", ";", "\u0120for", "\u0120(", "Slot", "Type", "1", "\u0120slot", "\u0120:", "\u0120document", "Sl", "ots", ")", "\u0120{", "\u0120if", "\u0120(", "slot", "Name", ".", "equ", "als", "(", "slot", ".", "get", "Name", "()", "))", "\u0120{", "\u0120LOG", ".", "debug", "(\"", "Found", "\u0120{}", ":", "\u0120{}", "\",", "\u0120slot", "Name", ",", "\u0120slot", ".", "get", "Value", "List", "().", "get", "Value", "());", "\u0120if", "\u0120(", "value", "Index", "\u0120<", "\u01200", ")", "\u0120{", "\u0120slot", "Value", "\u0120=", "\u0120String", "Ut", "ils", ".", "join", "(", "slot", ".", "get", "Value", "List", "().", "get", "Value", "(),", "\u0120VAL", "UE", "_", "LIST", "_", "SE", "PER", "ATOR", ");", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "slot", ".", "get", "Value", "List", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120slot", ".", "get", "Value", "List", "().", "get", "Value", "()", "\u0120!=", "\u0120null", "\u0120&&", "\u0120!", "slot", ".", "get", "Value", "List", "().", "get", "Value", "().", "is", "Empty", "())", "\u0120{", "\u0120slot", "Value", "\u0120=", "\u0120slot", ".", "get", "Value", "List", "().", "get", "Value", "().", "get", "(", "value", "Index", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120slot", "Value", "\u0120=", "\u0120\"", "\";", "\u0120}", "\u0120break", ";", "\u0120}", "\u0120}", "\u0120LOG", ".", "debug", "(\"", "{", "}:", "\u0120{}", "\",", "\u0120slot", "Name", ",", "\u0120slot", "Value", ");", "\u0120return", "\u0120slot", "Value", ";", "\u0120}"], "docstring_tokens": ["This", "\u0120statement", "\u0120slot", ".", "get", "Value", "List", "().", "get", "Value", "())", "\u0120could", "\u0120cause", "\u0120an", "\u0120N", "PE"]}
{"function": "public PartitionStatistics getTableStatistics(String databaseName, String tableName) { try { Table table = getTable(databaseName, tableName).orElseThrow( () -> new PrestoException(HIVE_METASTORE_ERROR, String.format(\"Could not retrieve table %s.%s\", databaseName, tableName))); HiveBasicStatistics basicStats = getHiveBasicStatistics(table.getParameters()); List<Column> columns = table.getPartitionColumns(); List<String> columnNames = columns.stream().map(Column::getName).collect(toImmutableList()); List<ColumnStatisticsInfo> colStatsList = client.getTableColumnStatistics(table.getDatabaseName(), table.getTableName(), columnNames); return new PartitionStatistics(basicStats, groupStatisticsByColumn(colStatsList, basicStats.getRowCount())); } catch (Exception e) { throw new PrestoException(HIVE_METASTORE_ERROR, e); } }", "text": "columnStatistics", "function_tokens": ["public", "\u0120Part", "ition", "Statistics", "\u0120get", "Table", "Statistics", "(", "String", "\u0120database", "Name", ",", "\u0120String", "\u0120table", "Name", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120Table", "\u0120table", "\u0120=", "\u0120get", "Table", "(", "database", "Name", ",", "\u0120table", "Name", ").", "or", "Else", "Throw", "(", "\u0120()", "\u0120->", "\u0120new", "\u0120Prest", "o", "Exception", "(", "H", "IVE", "_", "MET", "AST", "ORE", "_", "ERROR", ",", "\u0120String", ".", "format", "(\"", "Could", "\u0120not", "\u0120retrieve", "\u0120table", "\u0120%", "s", ".", "%", "s", "\",", "\u0120database", "Name", ",", "\u0120table", "Name", "))", ");", "\u0120Hive", "Basic", "Statistics", "\u0120basic", "Stats", "\u0120=", "\u0120get", "H", "ive", "Basic", "Statistics", "(", "table", ".", "get", "Parameters", "());", "\u0120List", "<", "Column", ">", "\u0120columns", "\u0120=", "\u0120table", ".", "get", "Part", "ition", "Column", "s", "();", "\u0120List", "<", "String", ">", "\u0120column", "Names", "\u0120=", "\u0120columns", ".", "stream", "().", "map", "(", "Column", "::", "get", "Name", ").", "collect", "(", "to", "Imm", "utable", "List", "());", "\u0120List", "<", "Column", "Statistics", "Info", ">", "\u0120col", "Stats", "List", "\u0120=", "\u0120client", ".", "get", "Table", "Column", "Statistics", "(", "table", ".", "get", "Database", "Name", "(),", "\u0120table", ".", "get", "Table", "Name", "(),", "\u0120column", "Names", ");", "\u0120return", "\u0120new", "\u0120Part", "ition", "Statistics", "(", "basic", "Stats", ",", "\u0120group", "Statistics", "By", "Column", "(", "col", "Stats", "List", ",", "\u0120basic", "Stats", ".", "get", "Row", "Count", "()", "));", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120e", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Prest", "o", "Exception", "(", "H", "IVE", "_", "MET", "AST", "ORE", "_", "ERROR", ",", "\u0120e", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["column", "Statistics"]}
{"function": "private void lazyLoadModulesConfig() throws IOException, ConfigInvalidException { if (modulesConfig == null) { loadModulesConfig(); } }", "text": "curly braces aren't required", "function_tokens": ["private", "\u0120void", "\u0120lazy", "Load", "Mod", "ules", "Config", "()", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Config", "Invalid", "Exception", "\u0120{", "\u0120if", "\u0120(", "modules", "Config", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120load", "Mod", "ules", "Config", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["cur", "ly", "\u0120braces", "\u0120aren", "'t", "\u0120required"]}
{"function": "public void run() { try { if (!makeResourceWritable(provider.getShell())) { return; } } catch (CoreException e) { MessageDialog.openWarning(provider.getShell(), \"Resource Not Accessible\", e.getMessage()); return; } if (LaunchUtils.hasLaunchedTestCases()) { MessageDialog.openWarning(provider.getShell(), Messages.RenameAction_ErrorDialogTitle, Messages.RenameAction_ErrorDialogMsg); return; } if (!RefactoringSaveHelper.checkDirtyEditors(provider.getShell())) { return; } if (containsSingleTag(getStructuredSelection())) { RenameTagWizard wizard = new RenameTagWizard(getSelectedTag()); run(wizard, provider.getShell()); } else { List<?> resources = getSelectedResources(); if (resources.size() == 1) { IResource resource = (IResource) resources.get(0); Q7RenameResourceWizard wizard = new Q7RenameResourceWizard( resource); run(wizard, provider.getShell()); } } }", "text": "Why do we handle error like this?", "function_tokens": ["public", "\u0120void", "\u0120run", "()", "\u0120{", "\u0120try", "\u0120{", "\u0120if", "\u0120(!", "make", "Resource", "Writ", "able", "(", "prov", "ider", ".", "get", "Shell", "()", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Core", "Exception", "\u0120e", ")", "\u0120{", "\u0120Message", "Dialog", ".", "open", "Warning", "(", "prov", "ider", ".", "get", "Shell", "(),", "\u0120\"", "Resource", "\u0120Not", "\u0120Access", "ible", "\",", "\u0120e", ".", "get", "Message", "());", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "Launch", "Ut", "ils", ".", "has", "Laun", "ched", "Test", "C", "ases", "())", "\u0120{", "\u0120Message", "Dialog", ".", "open", "Warning", "(", "prov", "ider", ".", "get", "Shell", "(),", "\u0120Messages", ".", "R", "ename", "Action", "_", "Error", "Dialog", "Title", ",", "\u0120Messages", ".", "R", "ename", "Action", "_", "Error", "Dialog", "Msg", ");", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(!", "Ref", "act", "oring", "Save", "Helper", ".", "check", "D", "irty", "Edit", "ors", "(", "prov", "ider", ".", "get", "Shell", "()", "))", "\u0120{", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(", "cont", "ains", "Single", "Tag", "(", "get", "Struct", "ured", "Se", "lection", "()", "))", "\u0120{", "\u0120Ren", "ame", "Tag", "W", "izard", "\u0120wizard", "\u0120=", "\u0120new", "\u0120Ren", "ame", "Tag", "W", "izard", "(", "get", "Se", "lected", "Tag", "());", "\u0120run", "(", "w", "izard", ",", "\u0120provider", ".", "get", "Shell", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120List", "<?", ">", "\u0120resources", "\u0120=", "\u0120get", "Se", "lected", "Resources", "();", "\u0120if", "\u0120(", "resources", ".", "size", "()", "\u0120==", "\u01201", ")", "\u0120{", "\u0120I", "Resource", "\u0120resource", "\u0120=", "\u0120(", "IR", "es", "ource", ")", "\u0120resources", ".", "get", "(", "0", ");", "\u0120Q", "7", "R", "ename", "Resource", "W", "izard", "\u0120wizard", "\u0120=", "\u0120new", "\u0120Q", "7", "R", "ename", "Resource", "W", "izard", "(", "\u0120resource", ");", "\u0120run", "(", "w", "izard", ",", "\u0120provider", ".", "get", "Shell", "());", "\u0120}", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120do", "\u0120we", "\u0120handle", "\u0120error", "\u0120like", "\u0120this", "?"]}
{"function": "private void setValue(Type type, BlockBuilder blockBuilder, String value) { if (value == null) { blockBuilder.appendNull(); return; } if (!(type instanceof FixedWidthType) && !(type instanceof VarcharType)) { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), \"type '\" + type + \"' not supported\"); } if (type instanceof FixedWidthType) { completedBytes += ((FixedWidthType) type).getFixedSize(); if (type instanceof BigintType) { type.writeLong(blockBuilder, parseDouble(value).longValue()); } else if (type instanceof IntegerType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else if (type instanceof TinyintType) { blockBuilder.writeByte(parseDouble(value).byteValue()); } else if (type instanceof SmallintType) { blockBuilder.writeShort(parseDouble(value).shortValue()); } else if (type instanceof BooleanType) { type.writeBoolean(blockBuilder, parseBoolean(value)); } else if (type instanceof DecimalType || type instanceof DoubleType) { type.writeDouble(blockBuilder, parseDouble(value)); } else if (type instanceof TimestampType) { type.writeLong(blockBuilder, parseLong(value)); } else if (type instanceof DateType) { blockBuilder.writeInt(parseDouble(value).intValue()); } else { throw new PinotException(PINOT_UNSUPPORTED_COLUMN_TYPE, Optional.empty(), \"type '\" + type + \"' not supported\"); } } else { Slice slice = Slices.utf8Slice(value); blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry(); completedBytes += slice.length(); } }", "text": "Why parseDouble and then convert that to int instead of directly parsing to int ?", "function_tokens": ["private", "\u0120void", "\u0120set", "Value", "(", "Type", "\u0120type", ",", "\u0120Block", "Builder", "\u0120block", "Builder", ",", "\u0120String", "\u0120value", ")", "\u0120{", "\u0120if", "\u0120(", "value", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120block", "Builder", ".", "append", "Null", "();", "\u0120return", ";", "\u0120}", "\u0120if", "\u0120(!", "(", "type", "\u0120instance", "of", "\u0120Fixed", "Width", "Type", ")", "\u0120&&", "\u0120!", "(", "type", "\u0120instance", "of", "\u0120V", "arch", "ar", "Type", "))", "\u0120{", "\u0120throw", "\u0120new", "\u0120Pin", "ot", "Exception", "(", "PIN", "OT", "_", "UN", "SUP", "PORT", "ED", "_", "COL", "UM", "N", "_", "TYPE", ",", "\u0120Optional", ".", "empty", "(),", "\u0120\"", "type", "\u0120'", "\"", "\u0120+", "\u0120type", "\u0120+", "\u0120\"'", "\u0120not", "\u0120supported", "\");", "\u0120}", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Fixed", "Width", "Type", ")", "\u0120{", "\u0120completed", "Bytes", "\u0120+=", "\u0120((", "Fixed", "Width", "Type", ")", "\u0120type", ").", "get", "Fixed", "Size", "();", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Big", "int", "Type", ")", "\u0120{", "\u0120type", ".", "write", "Long", "(", "block", "Builder", ",", "\u0120parse", "Double", "(", "value", ").", "long", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Integer", "Type", ")", "\u0120{", "\u0120block", "Builder", ".", "write", "Int", "(", "parse", "Double", "(", "value", ").", "int", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Tiny", "int", "Type", ")", "\u0120{", "\u0120block", "Builder", ".", "write", "Byte", "(", "parse", "Double", "(", "value", ").", "byte", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Small", "int", "Type", ")", "\u0120{", "\u0120block", "Builder", ".", "write", "Short", "(", "parse", "Double", "(", "value", ").", "short", "Value", "());", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Boolean", "Type", ")", "\u0120{", "\u0120type", ".", "write", "Boo", "lean", "(", "block", "Builder", ",", "\u0120parse", "Boo", "lean", "(", "value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Dec", "imal", "Type", "\u0120||", "\u0120type", "\u0120instance", "of", "\u0120Double", "Type", ")", "\u0120{", "\u0120type", ".", "write", "Double", "(", "block", "Builder", ",", "\u0120parse", "Double", "(", "value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Tim", "estamp", "Type", ")", "\u0120{", "\u0120type", ".", "write", "Long", "(", "block", "Builder", ",", "\u0120parse", "Long", "(", "value", "));", "\u0120}", "\u0120else", "\u0120if", "\u0120(", "type", "\u0120instance", "of", "\u0120Date", "Type", ")", "\u0120{", "\u0120block", "Builder", ".", "write", "Int", "(", "parse", "Double", "(", "value", ").", "int", "Value", "());", "\u0120}", "\u0120else", "\u0120{", "\u0120throw", "\u0120new", "\u0120Pin", "ot", "Exception", "(", "PIN", "OT", "_", "UN", "SUP", "PORT", "ED", "_", "COL", "UM", "N", "_", "TYPE", ",", "\u0120Optional", ".", "empty", "(),", "\u0120\"", "type", "\u0120'", "\"", "\u0120+", "\u0120type", "\u0120+", "\u0120\"'", "\u0120not", "\u0120supported", "\");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120Sl", "ice", "\u0120slice", "\u0120=", "\u0120S", "lic", "es", ".", "utf", "8", "Sl", "ice", "(", "value", ");", "\u0120block", "Builder", ".", "write", "Bytes", "(", "slice", ",", "\u01200", ",", "\u0120slice", ".", "length", "()", ").", "close", "Entry", "();", "\u0120completed", "Bytes", "\u0120+=", "\u0120slice", ".", "length", "();", "\u0120}", "\u0120}"], "docstring_tokens": ["Why", "\u0120parse", "Double", "\u0120and", "\u0120then", "\u0120convert", "\u0120that", "\u0120to", "\u0120int", "\u0120instead", "\u0120of", "\u0120directly", "\u0120parsing", "\u0120to", "\u0120int", "\u0120?"]}
{"function": "private void initialize() { this.setName(Constant.messages.getString(\"proxies.options.title\")); this.add(getScrollPane()); this.setLayout(new GridBagLayout()); this.add(getMainProxyPanel(), LayoutHelper.getGBC(0, 0, 1, 0.0)); this.add(getSecurityProtocolsPanel(), LayoutHelper.getGBC(0, 1, 1, 0.0)); this.add(getScrollPane(), LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0)); }", "text": "This can be removed? (Being added later.)", "function_tokens": ["private", "\u0120void", "\u0120initialize", "()", "\u0120{", "\u0120this", ".", "set", "Name", "(", "Con", "stant", ".", "mess", "ages", ".", "get", "String", "(\"", "pro", "x", "ies", ".", "options", ".", "title", "\")", ");", "\u0120this", ".", "add", "(", "get", "Scroll", "P", "ane", "());", "\u0120this", ".", "set", "Layout", "(", "new", "\u0120Grid", "B", "ag", "Layout", "());", "\u0120this", ".", "add", "(", "get", "Main", "Proxy", "Panel", "(),", "\u0120Layout", "Helper", ".", "get", "G", "BC", "(", "0", ",", "\u01200", ",", "\u01201", ",", "\u01200", ".", "0", "));", "\u0120this", ".", "add", "(", "get", "Security", "Prot", "ocol", "s", "Panel", "(),", "\u0120Layout", "Helper", ".", "get", "G", "BC", "(", "0", ",", "\u01201", ",", "\u01201", ",", "\u01200", ".", "0", "));", "\u0120this", ".", "add", "(", "get", "Scroll", "P", "ane", "(),", "\u0120Layout", "Helper", ".", "get", "G", "BC", "(", "0", ",", "\u01202", ",", "\u01201", ",", "\u01201", ".", "0", ",", "\u01201", ".", "0", "));", "\u0120}"], "docstring_tokens": ["This", "\u0120can", "\u0120be", "\u0120removed", "?", "\u0120(", "Being", "\u0120added", "\u0120later", ".)"]}
{"function": "public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } ImageTransfer other = (ImageTransfer) obj; return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && type == other.type && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal); }", "text": "please move it to line 168, just to make it look cleaner :)", "function_tokens": ["public", "\u0120boolean", "\u0120equals", "(", "Object", "\u0120obj", ")", "\u0120{", "\u0120if", "\u0120(", "this", "\u0120==", "\u0120obj", ")", "\u0120{", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120if", "\u0120(", "obj", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120if", "\u0120(", "get", "Class", "()", "\u0120!=", "\u0120obj", ".", "get", "Class", "())", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120Image", "Transfer", "\u0120other", "\u0120=", "\u0120(", "Image", "Transfer", ")", "\u0120obj", ";", "\u0120return", "\u0120Objects", ".", "equ", "als", "(", "command", "Id", ",", "\u0120other", ".", "command", "Id", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "phase", ",", "\u0120other", ".", "phase", ")", "\u0120&&", "\u0120type", "\u0120==", "\u0120other", ".", "type", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "last", "Updated", ",", "\u0120other", ".", "last", "Updated", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "message", ",", "\u0120other", ".", "message", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "v", "ds", "Id", ",", "\u0120other", ".", "v", "ds", "Id", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "disk", "Id", ",", "\u0120other", ".", "disk", "Id", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "im", "aged", "T", "icket", "Id", ",", "\u0120other", ".", "im", "aged", "T", "icket", "Id", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "proxy", "U", "ri", ",", "\u0120other", ".", "proxy", "U", "ri", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "signed", "T", "icket", ",", "\u0120other", ".", "signed", "T", "icket", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "bytes", "Sent", ",", "\u0120other", ".", "bytes", "Sent", ")", "\u0120&&", "\u0120Objects", ".", "equ", "als", "(", "bytes", "Total", ",", "\u0120other", ".", "bytes", "Total", ");", "\u0120}"], "docstring_tokens": ["please", "\u0120move", "\u0120it", "\u0120to", "\u0120line", "\u0120168", ",", "\u0120just", "\u0120to", "\u0120make", "\u0120it", "\u0120look", "\u0120cleaner", "\u0120:)"]}
{"function": "private static void printNetworkParameters(NetworkParams networkParams) { oshi.add(\"Network parameters:\" + networkParams.toString()); }", "text": "To match the old format, do \"Network parameters:\\n \" here.", "function_tokens": ["private", "\u0120static", "\u0120void", "\u0120print", "Network", "Parameters", "(", "Network", "Par", "ams", "\u0120network", "Par", "ams", ")", "\u0120{", "\u0120o", "shi", ".", "add", "(\"", "Network", "\u0120parameters", ":\"", "\u0120+", "\u0120network", "Par", "ams", ".", "to", "String", "());", "\u0120}"], "docstring_tokens": ["To", "\u0120match", "\u0120the", "\u0120old", "\u0120format", ",", "\u0120do", "\u0120\"", "Network", "\u0120parameters", ":\\", "n", "\u0120\"", "\u0120here", "."]}
{"function": "public static OzoneAcl convertOzoneAcl(OzoneAclInfo aclInfo) { ACLIdentityType aclType; switch(aclInfo.getType()) { case USER: aclType = ACLIdentityType.USER; break; case GROUP: aclType = ACLIdentityType.GROUP; break; case WORLD: aclType = ACLIdentityType.WORLD; break; default: throw new IllegalArgumentException(\"ACL type is not recognized\"); } List<IAccessAuthorizer.ACLType> aclRights = new ArrayList<>(); for(OzoneAclRights acl:aclInfo.getRightsList()) { try { aclRights.add(ACLType.valueOf(acl.name())); } catch(IllegalArgumentException iae) { LOG.error(\"ACL:{} right is not recognized.\", acl); } } return new OzoneAcl(aclType, aclInfo.getName(), aclRights); }", "text": "Do we missing some enums here?", "function_tokens": ["public", "\u0120static", "\u0120O", "zone", "A", "cl", "\u0120convert", "O", "zone", "A", "cl", "(", "O", "zone", "A", "cl", "Info", "\u0120a", "cl", "Info", ")", "\u0120{", "\u0120ACL", "Id", "entity", "Type", "\u0120a", "cl", "Type", ";", "\u0120switch", "(", "acl", "Info", ".", "get", "Type", "())", "\u0120{", "\u0120case", "\u0120US", "ER", ":", "\u0120a", "cl", "Type", "\u0120=", "\u0120ACL", "Id", "entity", "Type", ".", "USER", ";", "\u0120break", ";", "\u0120case", "\u0120GROUP", ":", "\u0120a", "cl", "Type", "\u0120=", "\u0120ACL", "Id", "entity", "Type", ".", "GROUP", ";", "\u0120break", ";", "\u0120case", "\u0120WORLD", ":", "\u0120a", "cl", "Type", "\u0120=", "\u0120ACL", "Id", "entity", "Type", ".", "WOR", "LD", ";", "\u0120break", ";", "\u0120default", ":", "\u0120throw", "\u0120new", "\u0120Illegal", "Arg", "ument", "Exception", "(\"", "AC", "L", "\u0120type", "\u0120is", "\u0120not", "\u0120recognized", "\");", "\u0120}", "\u0120List", "<", "IA", "ccess", "Author", "izer", ".", "AC", "L", "Type", ">", "\u0120a", "cl", "R", "ights", "\u0120=", "\u0120new", "\u0120Array", "List", "<", ">", "();", "\u0120for", "(", "O", "zone", "A", "cl", "R", "ights", "\u0120a", "cl", ":", "acl", "Info", ".", "get", "R", "ights", "List", "())", "\u0120{", "\u0120try", "\u0120{", "\u0120a", "cl", "R", "ights", ".", "add", "(", "AC", "L", "Type", ".", "value", "Of", "(", "acl", ".", "name", "()", "));", "\u0120}", "\u0120catch", "(", "Il", "legal", "Arg", "ument", "Exception", "\u0120", "iae", ")", "\u0120{", "\u0120LOG", ".", "error", "(\"", "AC", "L", ":{", "}", "\u0120right", "\u0120is", "\u0120not", "\u0120recognized", ".\",", "\u0120a", "cl", ");", "\u0120}", "\u0120}", "\u0120return", "\u0120new", "\u0120O", "zone", "A", "cl", "(", "acl", "Type", ",", "\u0120a", "cl", "Info", ".", "get", "Name", "(),", "\u0120a", "cl", "R", "ights", ");", "\u0120}"], "docstring_tokens": ["Do", "\u0120we", "\u0120missing", "\u0120some", "\u0120en", "ums", "\u0120here", "?"]}
{"function": "public void shouldSubstituteHexValuesInReplacementString() { String replacement = \"abc\\\\x01\\\\xaadef\"; ReplacerParamRule nonAsciiRegexRule = new ReplacerParamRule( \"\", REQ_HEADER_STR, \"anyMatchString\", true, replacement, null, true); assertThat( nonAsciiRegexRule.getEscapedReplacement(), equalTo(new String(new byte[] {'a', 'b', 'c', 1, (byte) 170, 'd', 'e', 'f'}))); }", "text": "These could be renamed to not use nonAscii.", "function_tokens": ["public", "\u0120void", "\u0120should", "Sub", "st", "itute", "H", "ex", "Values", "In", "Repl", "acement", "String", "()", "\u0120{", "\u0120String", "\u0120replacement", "\u0120=", "\u0120\"", "abc", "\\\\", "x", "01", "\\\\", "xa", "ade", "f", "\";", "\u0120Repl", "acer", "Param", "Rule", "\u0120non", "As", "ci", "i", "Re", "gex", "Rule", "\u0120=", "\u0120new", "\u0120Repl", "acer", "Param", "Rule", "(", "\u0120\"", "\",", "\u0120RE", "Q", "_", "HEAD", "ER", "_", "STR", ",", "\u0120\"", "any", "Match", "String", "\",", "\u0120true", ",", "\u0120replacement", ",", "\u0120null", ",", "\u0120true", ");", "\u0120assert", "That", "(", "\u0120non", "As", "ci", "i", "Re", "gex", "Rule", ".", "get", "Esc", "aped", "Repl", "acement", "(),", "\u0120equal", "To", "(", "new", "\u0120String", "(", "new", "\u0120byte", "[]", "\u0120{", "'", "a", "',", "\u0120'", "b", "',", "\u0120'", "c", "',", "\u01201", ",", "\u0120(", "byte", ")", "\u0120170", ",", "\u0120'", "d", "',", "\u0120'", "e", "',", "\u0120'", "f", "'", "}", "))", ");", "\u0120}"], "docstring_tokens": ["These", "\u0120could", "\u0120be", "\u0120renamed", "\u0120to", "\u0120not", "\u0120use", "\u0120non", "As", "ci", "i", "."]}
{"function": "protected Object transform( Message in, String mimeType, String transformerId, MimeTypeToTransformerMapper mapper) throws MimeTypeParseException, CatalogTransformerException { MimeType derivedMimeType = null; try (InputStream message = in.getBody(InputStream.class); TemporaryFileBackedOutputStream tfbos = new TemporaryFileBackedOutputStream()) { if (message == null) { throw new CatalogTransformerException( \"Message body was null; unable to generate Metacard!\"); } IOUtils.copy(message, tfbos); String fileExtensionHeader = getHeaderAsStringAndRemove(in, FILE_EXTENSION_HEADER); if (StringUtils.isNotEmpty(fileExtensionHeader)) { Optional<String> fileMimeType = getMimeTypeFor(tfbos.asByteSource().openBufferedStream(), fileExtensionHeader); if (fileMimeType.isPresent()) { LOGGER.trace( \"Setting mimetype to [{}] from Message header [{}]\", fileMimeType.get(), FILE_EXTENSION_HEADER); derivedMimeType = new MimeType(fileMimeType.get()); } } if (derivedMimeType == null) { if (StringUtils.isNotEmpty(mimeType)) { if (StringUtils.isNotEmpty(transformerId)) { derivedMimeType = new MimeType( mimeType + \";\" + MimeTypeToTransformerMapper.ID_KEY + \"=\" + transformerId); LOGGER.trace(\"Using mimeType to [{}]\", derivedMimeType); } else { LOGGER.trace(\"Using CatalogEndpoint's configured mimeType [{}]\", mimeType); derivedMimeType = new MimeType(mimeType); } } else { LOGGER.debug(\"Unable to determine mimeType. Defaulting to [{}]\", DEFAULT_MIME_TYPE); derivedMimeType = new MimeType(DEFAULT_MIME_TYPE); } } String metacardUpdateID = getHeaderAsStringAndRemove(in, METACARD_ID_HEADER); return generateMetacard(derivedMimeType, mapper, tfbos, metacardUpdateID) .orElseThrow( () -> new CatalogTransformerException( String.format( \"Did not find an InputTransformer for MIME Type [%s] and %s [%s]\", mimeType, MimeTypeToTransformerMapper.ID_KEY, transformerId))); } catch (IOException e) { LOGGER.debug(\"Failed to get mimeType by reading input stream\", e); } throw new CatalogTransformerException(\"Unable to transform incoming product\"); }", "text": "The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again.", "function_tokens": ["protected", "\u0120Object", "\u0120transform", "(", "\u0120Message", "\u0120in", ",", "\u0120String", "\u0120m", "ime", "Type", ",", "\u0120String", "\u0120transformer", "Id", ",", "\u0120M", "ime", "Type", "To", "Trans", "former", "M", "apper", "\u0120m", "apper", ")", "\u0120throws", "\u0120M", "ime", "Type", "Par", "se", "Exception", ",", "\u0120Catalog", "Trans", "former", "Exception", "\u0120{", "\u0120M", "ime", "Type", "\u0120derived", "M", "ime", "Type", "\u0120=", "\u0120null", ";", "\u0120try", "\u0120(", "Input", "Stream", "\u0120message", "\u0120=", "\u0120in", ".", "get", "Body", "(", "Input", "Stream", ".", "class", ");", "\u0120Temporary", "File", "B", "acked", "Output", "Stream", "\u0120t", "fb", "os", "\u0120=", "\u0120new", "\u0120Temporary", "File", "B", "acked", "Output", "Stream", "())", "\u0120{", "\u0120if", "\u0120(", "message", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120Catalog", "Trans", "former", "Exception", "(", "\u0120\"", "Message", "\u0120body", "\u0120was", "\u0120null", ";", "\u0120unable", "\u0120to", "\u0120generate", "\u0120Met", "ac", "ard", "!\"", ");", "\u0120}", "\u0120I", "OU", "t", "ils", ".", "copy", "(", "message", ",", "\u0120t", "fb", "os", ");", "\u0120String", "\u0120file", "Ext", "ension", "Header", "\u0120=", "\u0120get", "Header", "As", "String", "And", "Remove", "(", "in", ",", "\u0120FILE", "_", "EXT", "ENS", "ION", "_", "HEAD", "ER", ");", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Empty", "(", "file", "Ext", "ension", "Header", "))", "\u0120{", "\u0120Optional", "<", "String", ">", "\u0120file", "M", "ime", "Type", "\u0120=", "\u0120get", "M", "ime", "Type", "For", "(", "t", "fb", "os", ".", "as", "Byte", "Source", "().", "open", "Buff", "ered", "Stream", "(),", "\u0120file", "Ext", "ension", "Header", ");", "\u0120if", "\u0120(", "file", "M", "ime", "Type", ".", "is", "Present", "())", "\u0120{", "\u0120LOG", "GER", ".", "trace", "(", "\u0120\"", "Setting", "\u0120mim", "ety", "pe", "\u0120to", "\u0120[", "{", "}", "]", "\u0120from", "\u0120Message", "\u0120header", "\u0120[", "{", "}", "]", "\",", "\u0120file", "M", "ime", "Type", ".", "get", "(),", "\u0120FILE", "_", "EXT", "ENS", "ION", "_", "HEAD", "ER", ");", "\u0120derived", "M", "ime", "Type", "\u0120=", "\u0120new", "\u0120M", "ime", "Type", "(", "file", "M", "ime", "Type", ".", "get", "());", "\u0120}", "\u0120}", "\u0120if", "\u0120(", "derived", "M", "ime", "Type", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Empty", "(", "m", "ime", "Type", "))", "\u0120{", "\u0120if", "\u0120(", "String", "Ut", "ils", ".", "is", "Not", "Empty", "(", "trans", "former", "Id", "))", "\u0120{", "\u0120derived", "M", "ime", "Type", "\u0120=", "\u0120new", "\u0120M", "ime", "Type", "(", "\u0120m", "ime", "Type", "\u0120+", "\u0120\"", ";\"", "\u0120+", "\u0120M", "ime", "Type", "To", "Trans", "former", "M", "apper", ".", "ID", "_", "KEY", "\u0120+", "\u0120\"", "=\"", "\u0120+", "\u0120transformer", "Id", ");", "\u0120LOG", "GER", ".", "trace", "(\"", "Using", "\u0120m", "ime", "Type", "\u0120to", "\u0120[", "{", "}", "]", "\",", "\u0120derived", "M", "ime", "Type", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", "GER", ".", "trace", "(\"", "Using", "\u0120Catalog", "End", "point", "'s", "\u0120configured", "\u0120m", "ime", "Type", "\u0120[", "{", "}", "]", "\",", "\u0120m", "ime", "Type", ");", "\u0120derived", "M", "ime", "Type", "\u0120=", "\u0120new", "\u0120M", "ime", "Type", "(", "m", "ime", "Type", ");", "\u0120}", "\u0120}", "\u0120else", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "Un", "able", "\u0120to", "\u0120determine", "\u0120m", "ime", "Type", ".", "\u0120Default", "ing", "\u0120to", "\u0120[", "{", "}", "]", "\",", "\u0120DE", "FAULT", "_", "M", "IME", "_", "TYPE", ");", "\u0120derived", "M", "ime", "Type", "\u0120=", "\u0120new", "\u0120M", "ime", "Type", "(", "DE", "FAULT", "_", "M", "IME", "_", "TYPE", ");", "\u0120}", "\u0120}", "\u0120String", "\u0120met", "ac", "ard", "Update", "ID", "\u0120=", "\u0120get", "Header", "As", "String", "And", "Remove", "(", "in", ",", "\u0120MET", "AC", "ARD", "_", "ID", "_", "HEAD", "ER", ");", "\u0120return", "\u0120generate", "Met", "ac", "ard", "(", "derived", "M", "ime", "Type", ",", "\u0120m", "apper", ",", "\u0120t", "fb", "os", ",", "\u0120met", "ac", "ard", "Update", "ID", ")", "\u0120.", "or", "Else", "Throw", "(", "\u0120()", "\u0120->", "\u0120new", "\u0120Catalog", "Trans", "former", "Exception", "(", "\u0120String", ".", "format", "(", "\u0120\"", "Did", "\u0120not", "\u0120find", "\u0120an", "\u0120Input", "Trans", "former", "\u0120for", "\u0120M", "IME", "\u0120Type", "\u0120[", "%", "s", "]", "\u0120and", "\u0120%", "s", "\u0120[", "%", "s", "]", "\",", "\u0120m", "ime", "Type", ",", "\u0120M", "ime", "Type", "To", "Trans", "former", "M", "apper", ".", "ID", "_", "KEY", ",", "\u0120transformer", "Id", "))", ");", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120LOG", "GER", ".", "debug", "(\"", "F", "ailed", "\u0120to", "\u0120get", "\u0120m", "ime", "Type", "\u0120by", "\u0120reading", "\u0120input", "\u0120stream", "\",", "\u0120e", ");", "\u0120}", "\u0120throw", "\u0120new", "\u0120Catalog", "Trans", "former", "Exception", "(\"", "Un", "able", "\u0120to", "\u0120transform", "\u0120incoming", "\u0120product", "\");", "\u0120}"], "docstring_tokens": ["The", "\u0120change", "\u0120to", "\u0120Optional", "\u0120requires", "\u0120now", "\u0120to", "\u0120do", "\u0120a", "\u0120check", "\u0120here", "\u0120for", "\u0120presence", "\u0120and", "\u0120a", "\u0120get", "\u0120at", "\u0120line", "\u012087", "\u0120and", "\u012085", "\u0120which", "\u0120internally", "\u0120does", "\u0120that", "\u0120same", "\u0120check", "\u0120again", "."]}
{"function": "public Map<String, Discrepancy> getDiscrepanciesList() { Map<String, Discrepancy> toReturn = new HashMap<String, Discrepancy>(); String discrepanciesJson = artifact.getSoleAttributeAsString(DispoConstants.DispoDiscrepanciesJson, \"{}\"); try { JsonNode node = JsonUtil.getMapper().readTree(discrepanciesJson); Iterator<JsonNode> elements = node.getElements(); while (elements.hasNext()) { Discrepancy discrepancy = JsonUtil.getMapper().readValue(elements.next().toString(), Discrepancy.class); toReturn.put(discrepancy.getId(), discrepancy); } } catch (Exception ex) { throw new OseeCoreException(\"Could not parse Discrepancies Json\", ex); } return toReturn; }", "text": "Suggest JSON related capabilities be isolated to the JsonUtil class.", "function_tokens": ["public", "\u0120Map", "<", "String", ",", "\u0120Disc", "rep", "ancy", ">", "\u0120get", "Disc", "rep", "ancies", "List", "()", "\u0120{", "\u0120Map", "<", "String", ",", "\u0120Disc", "rep", "ancy", ">", "\u0120to", "Return", "\u0120=", "\u0120new", "\u0120Hash", "Map", "<", "String", ",", "\u0120Disc", "rep", "ancy", ">", "();", "\u0120String", "\u0120discrepancies", "J", "son", "\u0120=", "\u0120artifact", ".", "get", "S", "ole", "Attribute", "As", "String", "(", "Dis", "po", "Const", "ants", ".", "Dis", "po", "Disc", "rep", "ancies", "J", "son", ",", "\u0120\"{", "}", "\");", "\u0120try", "\u0120{", "\u0120J", "son", "Node", "\u0120node", "\u0120=", "\u0120J", "son", "Ut", "il", ".", "get", "M", "apper", "().", "read", "Tree", "(", "disc", "rep", "ancies", "J", "son", ");", "\u0120Iter", "ator", "<", "J", "son", "Node", ">", "\u0120elements", "\u0120=", "\u0120node", ".", "get", "E", "lements", "();", "\u0120while", "\u0120(", "e", "lements", ".", "has", "Next", "())", "\u0120{", "\u0120Disc", "rep", "ancy", "\u0120discrepancy", "\u0120=", "\u0120J", "son", "Ut", "il", ".", "get", "M", "apper", "().", "read", "Value", "(", "e", "lements", ".", "next", "().", "to", "String", "(),", "\u0120Disc", "rep", "ancy", ".", "class", ");", "\u0120to", "Return", ".", "put", "(", "disc", "rep", "ancy", ".", "get", "Id", "(),", "\u0120discrepancy", ");", "\u0120}", "\u0120}", "\u0120catch", "\u0120(", "Exception", "\u0120ex", ")", "\u0120{", "\u0120throw", "\u0120new", "\u0120O", "see", "Core", "Exception", "(\"", "Could", "\u0120not", "\u0120parse", "\u0120Disc", "rep", "ancies", "\u0120J", "son", "\",", "\u0120ex", ");", "\u0120}", "\u0120return", "\u0120to", "Return", ";", "\u0120}"], "docstring_tokens": ["Suggest", "\u0120JSON", "\u0120related", "\u0120capabilities", "\u0120be", "\u0120isolated", "\u0120to", "\u0120the", "\u0120J", "son", "Ut", "il", "\u0120class", "."]}
{"function": "public void setup() throws IOException, InterruptedException { m_eventdIpcMgr.setEventWriter(m_database); OnmsMonitoringLocation location = new OnmsMonitoringLocation(); location.setLocationName(\"Default\"); m_locationDao.save(location); final OnmsNode node = new OnmsNode(location, \"node1\"); node.setId(NODE_ID_ONE); m_nodeDao.save(node); Hashtable<String, Object> producerConfig = new Hashtable<String, Object>(); producerConfig.put(\"group.id\", \"OpenNMS\"); producerConfig.put(\"bootstrap.servers\", kafkaServer.getKafkaConnectString()); ConfigurationAdmin configAdmin = mock(ConfigurationAdmin.class, RETURNS_DEEP_STUBS); when(configAdmin.getConfiguration(KAFKA_PRODUCER_CLIENT_PID).getProperties()).thenReturn(producerConfig); ExecutorService executor = Executors.newSingleThreadExecutor(); kafkaConsumer = new KafkaMessageConsumerRunner(kafkaServer.getKafkaConnectString()); executor.execute(kafkaConsumer); kafkaProducer = new OpennmsKafkaProducer(protobufMapper, nodeCache, configAdmin, m_eventdIpcMgr, alarmLifecycleListenerManager); kafkaProducer.setEventTopic(\"events\"); kafkaProducer.setEventFilter(\"getUei().equals(\\\"uei.opennms.org/internal/discovery/newSuspect\\\")\"); kafkaProducer.setNodeTopic(\"nodes\"); kafkaProducer.init(); Thread.sleep(2000); }", "text": "What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?", "function_tokens": ["public", "\u0120void", "\u0120setup", "()", "\u0120throws", "\u0120IO", "Exception", ",", "\u0120Inter", "rupted", "Exception", "\u0120{", "\u0120m", "_", "event", "d", "I", "pc", "M", "gr", ".", "set", "Event", "Writer", "(", "m", "_", "database", ");", "\u0120On", "ms", "Monitor", "ing", "Location", "\u0120location", "\u0120=", "\u0120new", "\u0120On", "ms", "Monitor", "ing", "Location", "();", "\u0120location", ".", "set", "Location", "Name", "(\"", "Default", "\");", "\u0120m", "_", "location", "D", "ao", ".", "save", "(", "location", ");", "\u0120final", "\u0120On", "ms", "Node", "\u0120node", "\u0120=", "\u0120new", "\u0120On", "ms", "Node", "(", "location", ",", "\u0120\"", "node", "1", "\");", "\u0120node", ".", "set", "Id", "(", "N", "ODE", "_", "ID", "_", "ONE", ");", "\u0120m", "_", "node", "D", "ao", ".", "save", "(", "node", ");", "\u0120Hash", "table", "<", "String", ",", "\u0120Object", ">", "\u0120producer", "Config", "\u0120=", "\u0120new", "\u0120Hash", "table", "<", "String", ",", "\u0120Object", ">", "();", "\u0120producer", "Config", ".", "put", "(\"", "group", ".", "id", "\",", "\u0120\"", "Open", "N", "MS", "\");", "\u0120producer", "Config", ".", "put", "(\"", "boot", "strap", ".", "ser", "vers", "\",", "\u0120k", "af", "ka", "Server", ".", "get", "K", "af", "ka", "Connect", "String", "());", "\u0120Configuration", "Admin", "\u0120config", "Admin", "\u0120=", "\u0120mock", "(", "Configuration", "Admin", ".", "class", ",", "\u0120RET", "UR", "NS", "_", "D", "EEP", "_", "ST", "U", "BS", ");", "\u0120when", "(", "config", "Admin", ".", "get", "Configuration", "(", "K", "AF", "KA", "_", "PR", "OD", "UC", "ER", "_", "CL", "IENT", "_", "P", "ID", ").", "get", "Pro", "perties", "()", ").", "then", "Return", "(", "produ", "cer", "Config", ");", "\u0120Exec", "utor", "Service", "\u0120execut", "or", "\u0120=", "\u0120Exec", "ut", "ors", ".", "new", "Single", "Thread", "Exec", "utor", "();", "\u0120k", "af", "ka", "Consumer", "\u0120=", "\u0120new", "\u0120Kafka", "Message", "Consumer", "Runner", "(", "k", "af", "ka", "Server", ".", "get", "K", "af", "ka", "Connect", "String", "());", "\u0120execut", "or", ".", "execute", "(", "k", "af", "ka", "Consumer", ");", "\u0120k", "af", "ka", "Produ", "cer", "\u0120=", "\u0120new", "\u0120Op", "enn", "ms", "K", "af", "ka", "Produ", "cer", "(", "prot", "ob", "uf", "M", "apper", ",", "\u0120node", "Cache", ",", "\u0120config", "Admin", ",", "\u0120m", "_", "event", "d", "I", "pc", "M", "gr", ",", "\u0120alarm", "L", "if", "ecycle", "Listener", "Manager", ");", "\u0120k", "af", "ka", "Produ", "cer", ".", "set", "Event", "Topic", "(\"", "events", "\");", "\u0120k", "af", "ka", "Produ", "cer", ".", "set", "Event", "Filter", "(\"", "get", "U", "ei", "().", "equ", "als", "(", "\\\"", "ue", "i", ".", "op", "enn", "ms", ".", "org", "/", "internal", "/", "d", "iscovery", "/", "new", "Sus", "pect", "\\", "\")", "\");", "\u0120k", "af", "ka", "Produ", "cer", ".", "set", "Node", "Topic", "(\"", "n", "odes", "\");", "\u0120k", "af", "ka", "Produ", "cer", ".", "init", "();", "\u0120Thread", ".", "sleep", "(", "2000", ");", "\u0120}"], "docstring_tokens": ["What", "\u0120if", "\u0120it", "\u0120takes", "\u0120longer", "\u0120to", "\u0120initialize", "?", "\u0120Would", "\u0120it", "\u0120be", "\u0120possible", "\u0120to", "\u0120use", "\u0120something", "\u0120like", "\u0120await", "().", "at", "Most", "(", "1", ",", "\u0120MIN", "UT", "ES", ").", "until", "(", "()", "\u0120->", "\u0120k", "af", "ka", "Produ", "cer", ".", "is", "Ready", "()", ")?"]}
{"function": "public long updateHash( HashFunction hashFunction, long hash ) { class CodePointCursor { byte[] values; int i; @SuppressWarnings( \"WeakerAccess\" ) int codePointCount; @SuppressWarnings( \"WeakerAccess\" ) long next() { codePointCount++; byte b = values[i]; if ( b >= 0 ) { i++; return b; } int bytesNeeded = 0; while ( b < 0 ) { bytesNeeded++; b = (byte) (b << 1); } int codePoint = codePoint( values, b, i, bytesNeeded ); i += bytesNeeded; return codePoint; } } CodePointCursor cpc = new CodePointCursor(); cpc.values = bytes; cpc.i = offset; int len = offset + byteLength; while ( cpc.i < len ) { long codePointA = cpc.next() << 32; long codePointB = 0L; if ( cpc.i < len ) { codePointB = cpc.next(); } hash = hashFunction.update( hash, codePointA + codePointB ); } return hashFunction.update( hash, cpc.codePointCount ); }", "text": "The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?", "function_tokens": ["public", "\u0120long", "\u0120update", "Hash", "(", "\u0120Hash", "Function", "\u0120hash", "Function", ",", "\u0120long", "\u0120hash", "\u0120)", "\u0120{", "\u0120class", "\u0120Code", "Point", "C", "ursor", "\u0120{", "\u0120byte", "[]", "\u0120values", ";", "\u0120int", "\u0120i", ";", "\u0120@", "Supp", "ress", "W", "arn", "ings", "(", "\u0120\"", "We", "aker", "Access", "\"", "\u0120)", "\u0120int", "\u0120code", "Point", "Count", ";", "\u0120@", "Supp", "ress", "W", "arn", "ings", "(", "\u0120\"", "We", "aker", "Access", "\"", "\u0120)", "\u0120long", "\u0120next", "()", "\u0120{", "\u0120code", "Point", "Count", "++;", "\u0120byte", "\u0120b", "\u0120=", "\u0120values", "[", "i", "];", "\u0120if", "\u0120(", "\u0120b", "\u0120>=", "\u01200", "\u0120)", "\u0120{", "\u0120i", "++;", "\u0120return", "\u0120b", ";", "\u0120}", "\u0120int", "\u0120bytes", "Need", "ed", "\u0120=", "\u01200", ";", "\u0120while", "\u0120(", "\u0120b", "\u0120<", "\u01200", "\u0120)", "\u0120{", "\u0120bytes", "Need", "ed", "++;", "\u0120b", "\u0120=", "\u0120(", "byte", ")", "\u0120(", "b", "\u0120<<", "\u01201", ");", "\u0120}", "\u0120int", "\u0120code", "Point", "\u0120=", "\u0120code", "Point", "(", "\u0120values", ",", "\u0120b", ",", "\u0120i", ",", "\u0120bytes", "Need", "ed", "\u0120);", "\u0120i", "\u0120+=", "\u0120bytes", "Need", "ed", ";", "\u0120return", "\u0120code", "Point", ";", "\u0120}", "\u0120}", "\u0120Code", "Point", "C", "ursor", "\u0120c", "pc", "\u0120=", "\u0120new", "\u0120Code", "Point", "C", "ursor", "();", "\u0120c", "pc", ".", "values", "\u0120=", "\u0120bytes", ";", "\u0120c", "pc", ".", "i", "\u0120=", "\u0120offset", ";", "\u0120int", "\u0120len", "\u0120=", "\u0120offset", "\u0120+", "\u0120byte", "Length", ";", "\u0120while", "\u0120(", "\u0120c", "pc", ".", "i", "\u0120<", "\u0120len", "\u0120)", "\u0120{", "\u0120long", "\u0120code", "Point", "A", "\u0120=", "\u0120c", "pc", ".", "next", "()", "\u0120<<", "\u012032", ";", "\u0120long", "\u0120code", "Point", "B", "\u0120=", "\u01200", "L", ";", "\u0120if", "\u0120(", "\u0120c", "pc", ".", "i", "\u0120<", "\u0120len", "\u0120)", "\u0120{", "\u0120code", "Point", "B", "\u0120=", "\u0120c", "pc", ".", "next", "();", "\u0120}", "\u0120hash", "\u0120=", "\u0120hash", "Function", ".", "update", "(", "\u0120hash", ",", "\u0120code", "Point", "A", "\u0120+", "\u0120code", "Point", "B", "\u0120);", "\u0120}", "\u0120return", "\u0120hash", "Function", ".", "update", "(", "\u0120hash", ",", "\u0120c", "pc", ".", "code", "Point", "Count", "\u0120);", "\u0120}"], "docstring_tokens": ["The", "\u0120code", "\u0120point", "\u0120loop", "\u0120that", "\u0120now", "\u0120exists", "\u0120in", "\u0120this", "\u0120Code", "Point", "C", "ursor", "\u0120is", "\u0120sort", "\u0120of", "\u0120dupl", "icated", "\u0120elsewhere", "\u0120too", ".", "\u0120Would", "\u0120it", "\u0120be", "\u0120a", "\u0120good", "\u0120idea", "\u0120to", "\u0120port", "\u0120those", "\u0120places", "\u0120over", "\u0120to", "\u0120using", "\u0120it", "\u0120too", "?", "\u0120Also", "\u0120such", "\u0120objects", "\u0120will", "\u0120probably", "\u0120be", "\u0120optimized", "\u0120away", "\u0120since", "\u0120they", "\u0120don", "'t", "\u0120escape", "\u0120this", "\u0120method", ",", "\u0120right", "?"]}
{"function": "public void triggerCompleted() { getProcessInstance().removeEventListener(getEventType(), getEventListener(), true); ((org.jbpm.workflow.instance.NodeInstanceContainer)getNodeInstanceContainer()).setCurrentLevel(getLevel()); ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()).removeNodeInstance(this); NodeInstanceContainer container = ((org.jbpm.workflow.instance.NodeInstanceContainer) getNodeInstanceContainer()); NodeInstance instance = container.getNodeInstance(getNode()); triggerNodeInstance((org.jbpm.workflow.instance.NodeInstance) instance, NodeImpl.CONNECTION_DEFAULT_TYPE); }", "text": "what's the reason for this extra variable container?", "function_tokens": ["public", "\u0120void", "\u0120trigger", "Completed", "()", "\u0120{", "\u0120get", "Process", "Instance", "().", "remove", "Event", "Listener", "(", "get", "Event", "Type", "(),", "\u0120get", "Event", "Listener", "(),", "\u0120true", ");", "\u0120((", "org", ".", "j", "b", "pm", ".", "work", "flow", ".", "instance", ".", "Node", "Instance", "Container", ")", "get", "Node", "Instance", "Container", "()", ").", "set", "Current", "Level", "(", "get", "Level", "());", "\u0120((", "org", ".", "j", "b", "pm", ".", "work", "flow", ".", "instance", ".", "Node", "Instance", "Container", ")", "\u0120get", "Node", "Instance", "Container", "()", ").", "remove", "Node", "Instance", "(", "this", ");", "\u0120Node", "Instance", "Container", "\u0120container", "\u0120=", "\u0120((", "org", ".", "j", "b", "pm", ".", "work", "flow", ".", "instance", ".", "Node", "Instance", "Container", ")", "\u0120get", "Node", "Instance", "Container", "());", "\u0120Node", "Instance", "\u0120instance", "\u0120=", "\u0120container", ".", "get", "Node", "Instance", "(", "get", "Node", "());", "\u0120trigger", "Node", "Instance", "((", "org", ".", "j", "b", "pm", ".", "work", "flow", ".", "instance", ".", "Node", "Instance", ")", "\u0120instance", ",", "\u0120Node", "Impl", ".", "CON", "N", "ECTION", "_", "DE", "FAULT", "_", "TYPE", ");", "\u0120}"], "docstring_tokens": ["what", "'s", "\u0120the", "\u0120reason", "\u0120for", "\u0120this", "\u0120extra", "\u0120variable", "\u0120container", "?"]}
{"function": "void mapActionItemsToSelection(ISelection selection) { setMoveItemsEnabled(false); if (selection == null || selection.isEmpty()) return; if (selection instanceof IStructuredSelection) { IStructuredSelection structured = (IStructuredSelection) selection; Object obj = structured.getFirstElement(); if (!(obj instanceof PlanElement)) return; PlanElement firstSelectedEntry = (PlanElement) obj; PlanElement lastSelectedEntry = firstSelectedEntry; ElementAction type = firstSelectedEntry.getPlanElementAction(); unselectAllActionItemsExecpt(getItemFor(type)); if (structured.size() > 1) { for (Iterator iterator = structured.iterator(); iterator .hasNext();) { Object selectedObj = iterator.next(); if (!(selectedObj instanceof PlanElement)) continue; PlanElement entry = lastSelectedEntry = (PlanElement) selectedObj; if (type != entry.getPlanElementAction()) { unselectAllActionItemsExecpt(null); } } } enableMoveButtons(firstSelectedEntry, lastSelectedEntry); } }", "text": "We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.", "function_tokens": ["void", "\u0120map", "Action", "Items", "To", "Se", "lection", "(", "IS", "election", "\u0120selection", ")", "\u0120{", "\u0120set", "Move", "Items", "Enabled", "(", "false", ");", "\u0120if", "\u0120(", "selection", "\u0120==", "\u0120null", "\u0120||", "\u0120selection", ".", "is", "Empty", "())", "\u0120return", ";", "\u0120if", "\u0120(", "selection", "\u0120instance", "of", "\u0120I", "Struct", "ured", "Se", "lection", ")", "\u0120{", "\u0120I", "Struct", "ured", "Se", "lection", "\u0120structured", "\u0120=", "\u0120(", "I", "Struct", "ured", "Se", "lection", ")", "\u0120selection", ";", "\u0120Object", "\u0120obj", "\u0120=", "\u0120structured", ".", "get", "First", "Element", "();", "\u0120if", "\u0120(!", "(", "obj", "\u0120instance", "of", "\u0120Plan", "Element", "))", "\u0120return", ";", "\u0120Plan", "Element", "\u0120first", "Se", "lected", "Entry", "\u0120=", "\u0120(", "Plan", "Element", ")", "\u0120obj", ";", "\u0120Plan", "Element", "\u0120last", "Se", "lected", "Entry", "\u0120=", "\u0120first", "Se", "lected", "Entry", ";", "\u0120Element", "Action", "\u0120type", "\u0120=", "\u0120first", "Se", "lected", "Entry", ".", "get", "Plan", "Element", "Action", "();", "\u0120un", "select", "All", "Action", "Items", "Exec", "pt", "(", "get", "Item", "For", "(", "type", "));", "\u0120if", "\u0120(", "struct", "ured", ".", "size", "()", "\u0120>", "\u01201", ")", "\u0120{", "\u0120for", "\u0120(", "Iterator", "\u0120iterator", "\u0120=", "\u0120structured", ".", "iterator", "();", "\u0120iterator", "\u0120.", "has", "Next", "();", ")", "\u0120{", "\u0120Object", "\u0120selected", "Obj", "\u0120=", "\u0120iterator", ".", "next", "();", "\u0120if", "\u0120(!", "(", "selected", "Obj", "\u0120instance", "of", "\u0120Plan", "Element", "))", "\u0120continue", ";", "\u0120Plan", "Element", "\u0120entry", "\u0120=", "\u0120last", "Se", "lected", "Entry", "\u0120=", "\u0120(", "Plan", "Element", ")", "\u0120selected", "Obj", ";", "\u0120if", "\u0120(", "type", "\u0120!=", "\u0120entry", ".", "get", "Plan", "Element", "Action", "())", "\u0120{", "\u0120un", "select", "All", "Action", "Items", "Exec", "pt", "(", "null", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120enable", "Move", "But", "tons", "(", "first", "Se", "lected", "Entry", ",", "\u0120last", "Se", "lected", "Entry", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["We", "\u0120should", "\u0120first", "\u0120find", "\u0120out", "\u0120if", "\u0120we", "\u0120have", "\u0120to", "\u0120select", "\u0120one", "/", "d", "ese", "lect", "\u0120all", "\u0120and", "\u0120then", "\u0120do", "\u0120the", "\u0120right", "\u0120thing", "\u0120in", "\u0120the", "\u0120UI", "\u0120only", "\u0120once", "\u0120after", "\u0120the", "\u0120if", "-", "block", ".", "\u0120This", "\u0120avoids", "\u0120unnecessary", "\u0120UI", "\u0120changes", "."]}
{"function": "public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(\"P60000000000000D\"); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); assertThat(e.getMessage(), is(\"Error during type conversion from type: java.time.Duration to the required type: \" + \"long with value PT1440000000000000H due java.lang.ArithmeticException: long overflow\")); } }", "text": "I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.", "function_tokens": ["public", "\u0120void", "\u0120test", "To", "Mill", "is", "Over", "flow", "()", "\u0120throws", "\u0120Exception", "\u0120{", "\u0120Duration", "\u0120duration", "\u0120=", "\u0120Duration", ".", "parse", "(\"", "P", "6", "00000000", "00000", "D", "\");", "\u0120try", "\u0120{", "\u0120context", ".", "get", "Type", "Con", "ver", "ter", "().", "con", "vert", "To", "(", "long", ".", "class", ",", "\u0120duration", ");", "\u0120}", "\u0120catch", "\u0120(", "Type", "Con", "version", "Exception", "\u0120e", ")", "\u0120{", "\u0120assert", "Is", "Instance", "Of", "(", "Ar", "ithmetic", "Exception", ".", "class", ",", "\u0120e", ".", "get", "Cause", "().", "get", "Cause", "());", "\u0120assert", "That", "(", "e", ".", "get", "Message", "(),", "\u0120is", "(\"", "Error", "\u0120during", "\u0120type", "\u0120conversion", "\u0120from", "\u0120type", ":", "\u0120java", ".", "time", ".", "Duration", "\u0120to", "\u0120the", "\u0120required", "\u0120type", ":", "\u0120\"", "\u0120+", "\u0120\"", "long", "\u0120with", "\u0120value", "\u0120PT", "144", "00000000", "00000", "H", "\u0120due", "\u0120java", ".", "lang", ".", "Ar", "ithmetic", "Exception", ":", "\u0120long", "\u0120overflow", "\")", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "\u0120wonder", "\u0120if", "\u0120people", "\u0120running", "\u0120with", "\u0120locale", "\u0120GER", "MAN", ",", "\u0120CH", "IN", "ESE", "\u0120etc", "\u0120would", "\u0120get", "\u0120localized", "\u0120error", "\u0120messages", "\u0120from", "\u0120the", "\u0120JD", "K", "?", "\u0120You", "\u0120may", "\u0120need", "\u0120to", "\u0120just", "\u0120check", "\u0120the", "\u0120exception", "\u0120type", ",", "\u0120or", "\u0120maybe", "\u0120try", "\u0120to", "\u0120change", "\u0120the", "\u0120default", "\u0120locale", "\u0120and", "\u0120restore", "\u0120it", "\u0120back", "\u0120after", "\u0120the", "\u0120test", "."]}
{"function": "private void publishChildren(IModule[] module, ArrayList<IStatus> results, IModule[] children, File parentModule, IProgressMonitor monitor) { if( children == null ) return; monitor.beginTask(\"Assembling child modules\", children.length * 100); for( int i = 0; i < children.length; i++ ) { if( ServerModelUtilities.isBinaryModule(children[i])) results.addAll(Arrays.asList(fullBinaryPublish(module, children[i], ProgressMonitorUtil.submon(monitor, 100)))); else results.addAll(Arrays.asList(fullPublish(combine(module, children[i]), parentModule, ProgressMonitorUtil.submon(monitor, 100)))); } }", "text": "check if monitor is cancelled?", "function_tokens": ["private", "\u0120void", "\u0120publish", "Children", "(", "IM", "od", "ule", "[]", "\u0120module", ",", "\u0120Array", "List", "<", "I", "Status", ">", "\u0120results", ",", "\u0120I", "Module", "[]", "\u0120children", ",", "\u0120File", "\u0120parent", "Module", ",", "\u0120I", "Progress", "Monitor", "\u0120monitor", ")", "\u0120{", "\u0120if", "(", "\u0120children", "\u0120==", "\u0120null", "\u0120)", "\u0120return", ";", "\u0120monitor", ".", "begin", "Task", "(\"", "As", "semb", "ling", "\u0120child", "\u0120modules", "\",", "\u0120children", ".", "length", "\u0120*", "\u0120100", ");", "\u0120for", "(", "\u0120int", "\u0120i", "\u0120=", "\u01200", ";", "\u0120i", "\u0120<", "\u0120children", ".", "length", ";", "\u0120i", "++", "\u0120)", "\u0120{", "\u0120if", "(", "\u0120Server", "Model", "Ut", "ilities", ".", "is", "B", "inary", "Module", "(", "children", "[", "i", "]", "))", "\u0120results", ".", "add", "All", "(", "Ar", "rays", ".", "as", "List", "(", "full", "B", "inary", "Pub", "lish", "(", "module", ",", "\u0120children", "[", "i", "],", "\u0120Progress", "Monitor", "Ut", "il", ".", "sub", "mon", "(", "monitor", ",", "\u0120100", "))", "));", "\u0120else", "\u0120results", ".", "add", "All", "(", "Ar", "rays", ".", "as", "List", "(", "full", "Pub", "lish", "(", "comb", "ine", "(", "module", ",", "\u0120children", "[", "i", "]),", "\u0120parent", "Module", ",", "\u0120Progress", "Monitor", "Ut", "il", ".", "sub", "mon", "(", "monitor", ",", "\u0120100", "))", "));", "\u0120}", "\u0120}"], "docstring_tokens": ["check", "\u0120if", "\u0120monitor", "\u0120is", "\u0120cancelled", "?"]}
{"function": "public boolean isReady() { return false; }", "text": "@Irenyak1 why return false here?", "function_tokens": ["public", "\u0120boolean", "\u0120is", "Ready", "()", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}"], "docstring_tokens": ["@", "I", "ren", "y", "ak", "1", "\u0120why", "\u0120return", "\u0120false", "\u0120here", "?"]}
{"function": "private void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) { synchronized (lock) { final long id = idGenerator.getAndIncrement(); final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter); final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work); EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get(); workProcessor.onNext(syncSubscriber); Disposable thisWorkSubscriber = workSubscriber.get(); if (thisWorkSubscriber != null) { logger.info(\"[{}]: Receive request is placed in queue to process.\", id); return; } EmitterProcessor<ServiceBusReceivedMessageContext> source = messageSource.get(); if (source == null) { source = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS) .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false)); messageSource.set(source); logger.info(\"Created source for receiving messages.\"); } EmitterProcessor<ServiceBusReceivedMessageContext> finalSource = source; thisWorkSubscriber = workProcessor .subscribe(currentWork -> finalSource.subscribe(currentWork), error -> { logger.error(\"Error in processing messages [{}]\", error); }, () -> { logger.info(\"Receiving messages completed.\"); }); workSubscriber.set(thisWorkSubscriber); } }", "text": "These should be done through a sink.", "function_tokens": ["private", "\u0120void", "\u0120queue", "Work", "(", "int", "\u0120maximum", "Message", "Count", ",", "\u0120Duration", "\u0120max", "Wait", "Time", ",", "\u0120Fl", "ux", "S", "ink", "<", "Service", "Bus", "Re", "ceived", "Message", "Context", ">", "\u0120em", "itter", ")", "\u0120{", "\u0120synchronized", "\u0120(", "lock", ")", "\u0120{", "\u0120final", "\u0120long", "\u0120id", "\u0120=", "\u0120id", "Gener", "ator", ".", "get", "And", "Incre", "ment", "();", "\u0120final", "\u0120Syn", "chron", "ous", "Re", "ceive", "Work", "\u0120work", "\u0120=", "\u0120new", "\u0120Syn", "chron", "ous", "Re", "ceive", "Work", "(", "id", ",", "\u0120maximum", "Message", "Count", ",", "\u0120max", "Wait", "Time", ",", "\u0120em", "itter", ");", "\u0120final", "\u0120Syn", "chron", "ous", "Message", "Sub", "sc", "riber", "\u0120sync", "Sub", "sc", "riber", "\u0120=", "\u0120new", "\u0120Syn", "chron", "ous", "Message", "Sub", "sc", "riber", "(", "work", ");", "\u0120Em", "itter", "Process", "or", "<", "S", "ynchronous", "Message", "Sub", "sc", "riber", ">", "\u0120work", "Process", "or", "\u0120=", "\u0120work", "Queue", "Process", "or", ".", "get", "();", "\u0120work", "Process", "or", ".", "on", "Next", "(", "sync", "Sub", "sc", "riber", ");", "\u0120Dis", "pos", "able", "\u0120this", "Work", "Sub", "sc", "riber", "\u0120=", "\u0120work", "Sub", "sc", "riber", ".", "get", "();", "\u0120if", "\u0120(", "this", "Work", "Sub", "sc", "riber", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120logger", ".", "info", "(\"", "[", "{", "}", "]:", "\u0120Re", "ceive", "\u0120request", "\u0120is", "\u0120placed", "\u0120in", "\u0120queue", "\u0120to", "\u0120process", ".\",", "\u0120id", ");", "\u0120return", ";", "\u0120}", "\u0120Em", "itter", "Process", "or", "<", "Service", "Bus", "Re", "ceived", "Message", "Context", ">", "\u0120source", "\u0120=", "\u0120message", "Source", ".", "get", "();", "\u0120if", "\u0120(", "source", "\u0120==", "\u0120null", ")", "\u0120{", "\u0120source", "\u0120=", "\u0120this", ".", "as", "ync", "Client", ".", "re", "ceive", "(", "DE", "FAULT", "_", "RE", "CE", "IVE", "_", "OP", "T", "IONS", ")", "\u0120.", "sub", "scribe", "With", "(", "Em", "itter", "Process", "or", ".", "create", "(", "as", "ync", "Client", ".", "get", "Re", "ceiver", "Options", "().", "get", "Pref", "etch", "Count", "(),", "\u0120false", "));", "\u0120message", "Source", ".", "set", "(", "source", ");", "\u0120logger", ".", "info", "(\"", "Created", "\u0120source", "\u0120for", "\u0120receiving", "\u0120messages", ".\"", ");", "\u0120}", "\u0120Em", "itter", "Process", "or", "<", "Service", "Bus", "Re", "ceived", "Message", "Context", ">", "\u0120final", "Source", "\u0120=", "\u0120source", ";", "\u0120this", "Work", "Sub", "sc", "riber", "\u0120=", "\u0120work", "Process", "or", "\u0120.", "sub", "scribe", "(", "current", "Work", "\u0120->", "\u0120final", "Source", ".", "sub", "scribe", "(", "current", "Work", "),", "\u0120error", "\u0120->", "\u0120{", "\u0120logger", ".", "error", "(\"", "Error", "\u0120in", "\u0120processing", "\u0120messages", "\u0120[", "{", "}", "]", "\",", "\u0120error", ");", "\u0120},", "\u0120()", "\u0120->", "\u0120{", "\u0120logger", ".", "info", "(\"", "Re", "ce", "iving", "\u0120messages", "\u0120completed", ".\"", ");", "\u0120});", "\u0120work", "Sub", "sc", "riber", ".", "set", "(", "this", "Work", "Sub", "sc", "riber", ");", "\u0120}", "\u0120}"], "docstring_tokens": ["These", "\u0120should", "\u0120be", "\u0120done", "\u0120through", "\u0120a", "\u0120sink", "."]}
{"function": "private static String truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName(String legalLastName, String legalFirstName) { int maxAllowedLengthOfFirstName = VendorConstants.MAX_VENDOR_NAME_LENGTH - VendorConstants.NAME_DELIM.length() - legalLastName.length(); if (legalFirstName.length() <= maxAllowedLengthOfFirstName) { return legalFirstName; } else { String truncatedLegalFirstName = legalFirstName.substring(0, maxAllowedLengthOfFirstName); LOG.info(\"truncateLegalFirstNameToMaximumAllowedLengthWhenFormattedWithLegalLastName: Received legalFirstName '\" + legalFirstName + \"' with length of \" + legalFirstName.length() + \" and it is being truncated to '\" + truncatedLegalFirstName + \"' with length of \" + truncatedLegalFirstName.length()); return truncatedLegalFirstName; } }", "text": "If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood.", "function_tokens": ["private", "\u0120static", "\u0120String", "\u0120trunc", "ate", "Legal", "First", "Name", "To", "Maximum", "All", "owed", "Length", "When", "Form", "atted", "With", "Legal", "Last", "Name", "(", "String", "\u0120legal", "Last", "Name", ",", "\u0120String", "\u0120legal", "First", "Name", ")", "\u0120{", "\u0120int", "\u0120max", "All", "owed", "Length", "Of", "First", "Name", "\u0120=", "\u0120Vendor", "Const", "ants", ".", "MAX", "_", "V", "END", "OR", "_", "NAME", "_", "L", "ENGTH", "\u0120-", "\u0120Vendor", "Const", "ants", ".", "NAME", "_", "D", "EL", "IM", ".", "length", "()", "\u0120-", "\u0120legal", "Last", "Name", ".", "length", "();", "\u0120if", "\u0120(", "legal", "First", "Name", ".", "length", "()", "\u0120<=", "\u0120max", "All", "owed", "Length", "Of", "First", "Name", ")", "\u0120{", "\u0120return", "\u0120legal", "First", "Name", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120String", "\u0120trunc", "ated", "Legal", "First", "Name", "\u0120=", "\u0120legal", "First", "Name", ".", "sub", "string", "(", "0", ",", "\u0120max", "All", "owed", "Length", "Of", "First", "Name", ");", "\u0120LOG", ".", "info", "(\"", "tr", "unc", "ate", "Legal", "First", "Name", "To", "Maximum", "All", "owed", "Length", "When", "Form", "atted", "With", "Legal", "Last", "Name", ":", "\u0120Received", "\u0120legal", "First", "Name", "\u0120'", "\"", "\u0120+", "\u0120legal", "First", "Name", "\u0120+", "\u0120\"'", "\u0120with", "\u0120length", "\u0120of", "\u0120\"", "\u0120+", "\u0120legal", "First", "Name", ".", "length", "()", "\u0120+", "\u0120\"", "\u0120and", "\u0120it", "\u0120is", "\u0120being", "\u0120trunc", "ated", "\u0120to", "\u0120'", "\"", "\u0120+", "\u0120trunc", "ated", "Legal", "First", "Name", "\u0120+", "\u0120\"'", "\u0120with", "\u0120length", "\u0120of", "\u0120\"", "\u0120+", "\u0120trunc", "ated", "Legal", "First", "Name", ".", "length", "());", "\u0120return", "\u0120trunc", "ated", "Legal", "First", "Name", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["If", "\u0120the", "\u0120length", "\u0120of", "\u0120the", "\u0120legal", "\u0120last", "\u0120name", "\u0120is", "\u0120already", "\u0120the", "\u0120max", "\u0120length", ",", "\u0120then", "\u0120the", "\u0120legal", "\u0120first", "\u0120name", "\u0120would", "\u0120get", "\u0120trunc", "ated", "\u0120to", "\u0120an", "\u0120empty", "\u0120string", ".", "\u0120I", "\u0120think", "\u0120this", "\u0120code", "\u0120may", "\u0120handle", "\u0120it", ",", "\u0120but", "\u0120if", "\u0120you", "\u0120put", "\u0120in", "\u0120an", "\u0120explicit", "\u0120check", "\u0120for", "\u0120that", ",", "\u0120it", "\u0120may", "\u0120make", "\u0120the", "\u0120code", "\u0120intention", "\u0120more", "\u0120easily", "\u0120understood", "."]}
{"function": "public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) { GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId)); GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity(); snapshot.setClusterId(volume.getClusterId()); snapshot.setVolumeId(new Guid(volumeId)); DateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\"); String snapshotName = snapshotNamePrefix + \"-snap-\" + df.format(new Date()); snapshot.setSnapshotName(snapshotName); snapshot.setDescription(description); VDSReturnValue returnValue = getBackend().getResourceManager() .RunVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new GlusterVolumeCreateSnapshotVDSParameters(new Guid(serverId), volume.getName(), snapshotName, description, force)); if (returnValue.getSucceeded()) { snapshot.setSnapshotId((Guid) returnValue.getReturnValue()); snapshot.setCreatedAt(new Date()); snapshot.setStatus(GlusterSnapshotStatus.STARTED); getGlusterVolumeSnapshotDao().save(snapshot); } else { log.error(\"Error while creating snapshot for volume '{}': {}\", volume.getName(), returnValue.getVdsError() .getMessage()); log.debug(returnValue.getVdsError().getMessage()); } }", "text": "How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed", "function_tokens": ["public", "\u0120void", "\u0120on", "Timer", "(", "String", "\u0120server", "Id", ",", "\u0120String", "\u0120volume", "Id", ",", "\u0120String", "\u0120snapshot", "Name", "Pref", "ix", ",", "\u0120String", "\u0120description", ",", "\u0120boolean", "\u0120force", ")", "\u0120{", "\u0120Gl", "uster", "Volume", "Entity", "\u0120volume", "\u0120=", "\u0120get", "Gl", "uster", "Volume", "D", "ao", "().", "get", "ById", "(", "new", "\u0120Guid", "(", "volume", "Id", "));", "\u0120Gl", "uster", "Volume", "Snap", "shot", "Entity", "\u0120snapshot", "\u0120=", "\u0120new", "\u0120Gl", "uster", "Volume", "Snap", "shot", "Entity", "();", "\u0120snapshot", ".", "set", "Cl", "uster", "Id", "(", "volume", ".", "get", "Cl", "uster", "Id", "());", "\u0120snapshot", ".", "set", "Volume", "Id", "(", "new", "\u0120Guid", "(", "volume", "Id", "));", "\u0120Date", "Format", "\u0120df", "\u0120=", "\u0120new", "\u0120Simple", "Date", "Format", "(\"", "yy", "yy", "MM", "dd", "HH", "mm", "ss", "\");", "\u0120String", "\u0120snapshot", "Name", "\u0120=", "\u0120snapshot", "Name", "Pref", "ix", "\u0120+", "\u0120\"-", "snap", "-\"", "\u0120+", "\u0120df", ".", "format", "(", "new", "\u0120Date", "());", "\u0120snapshot", ".", "set", "Snap", "shot", "Name", "(", "snap", "shot", "Name", ");", "\u0120snapshot", ".", "set", "Description", "(", "description", ");", "\u0120V", "DS", "Return", "Value", "\u0120return", "Value", "\u0120=", "\u0120get", "Back", "end", "().", "get", "Resource", "Manager", "()", "\u0120.", "Run", "V", "ds", "Command", "(", "V", "DS", "Command", "Type", ".", "Create", "Gl", "uster", "Volume", "Snap", "shot", ",", "\u0120new", "\u0120Gl", "uster", "Volume", "Create", "Snap", "shot", "VD", "SP", "aram", "eters", "(", "new", "\u0120Guid", "(", "server", "Id", "),", "\u0120volume", ".", "get", "Name", "(),", "\u0120snapshot", "Name", ",", "\u0120description", ",", "\u0120force", "));", "\u0120if", "\u0120(", "return", "Value", ".", "get", "S", "uc", "ceed", "ed", "())", "\u0120{", "\u0120snapshot", ".", "set", "Snap", "shot", "Id", "((", "Gu", "id", ")", "\u0120return", "Value", ".", "get", "Return", "Value", "());", "\u0120snapshot", ".", "set", "Created", "At", "(", "new", "\u0120Date", "());", "\u0120snapshot", ".", "set", "Status", "(", "Gl", "uster", "Snap", "shot", "Status", ".", "ST", "ART", "ED", ");", "\u0120get", "Gl", "uster", "Volume", "Snap", "shot", "D", "ao", "().", "save", "(", "snap", "shot", ");", "\u0120}", "\u0120else", "\u0120{", "\u0120log", ".", "error", "(\"", "Error", "\u0120while", "\u0120creating", "\u0120snapshot", "\u0120for", "\u0120volume", "\u0120'", "{", "}", "':", "\u0120{}", "\",", "\u0120volume", ".", "get", "Name", "(),", "\u0120return", "Value", ".", "get", "V", "ds", "Error", "()", "\u0120.", "get", "Message", "());", "\u0120log", ".", "debug", "(", "return", "Value", ".", "get", "V", "ds", "Error", "().", "get", "Message", "());", "\u0120}", "\u0120}"], "docstring_tokens": ["How", "\u0120about", "\u0120raising", "\u0120an", "\u0120Audit", "\u0120log", "\u0120for", "\u0120failure", "?", "\u0120Otherwise", ",", "\u0120it", "\u0120may", "\u0120be", "\u0120difficult", "\u0120to", "\u0120track", "\u0120which", "\u0120snapshots", "\u0120failed"]}
{"function": "public boolean removeFileEntry(String index, TransientStore ts) { BatchFileEntry fileEntry = getFileEntry(index, false); if (fileEntry != null) { if (fileEntry.isChunked()) { for (String chunkEntryKey : fileEntry.getChunkEntryKeys()) { List<Blob> chunkBlobs = ts.getBlobs(chunkEntryKey); if (chunkBlobs != null) { for (Blob blob : chunkBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(\"Error while deleting chunk parent directory\", e); } } } ts.remove(chunkEntryKey); } fileEntry.beforeRemove(); } String fileEntryKey = fileEntry.getKey(); List<Blob> fileBlobs = ts.getBlobs(fileEntryKey); if (fileBlobs != null) { for (Blob blob : fileBlobs) { try { FileUtils.deleteDirectory(blob.getFile().getParentFile()); } catch (IOException e) { log.error(\"Error while deleting file parent directory\", e); } } } ts.remove(fileEntryKey); return true; } else { return false; } }", "text": "I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.", "function_tokens": ["public", "\u0120boolean", "\u0120remove", "File", "Entry", "(", "String", "\u0120index", ",", "\u0120Trans", "ient", "Store", "\u0120ts", ")", "\u0120{", "\u0120B", "atch", "File", "Entry", "\u0120file", "Entry", "\u0120=", "\u0120get", "File", "Entry", "(", "index", ",", "\u0120false", ");", "\u0120if", "\u0120(", "file", "Entry", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120if", "\u0120(", "file", "Entry", ".", "is", "Ch", "unk", "ed", "())", "\u0120{", "\u0120for", "\u0120(", "String", "\u0120chunk", "Entry", "Key", "\u0120:", "\u0120file", "Entry", ".", "get", "Ch", "unk", "Entry", "Keys", "())", "\u0120{", "\u0120List", "<", "Bl", "ob", ">", "\u0120chunk", "Bl", "obs", "\u0120=", "\u0120ts", ".", "get", "Bl", "obs", "(", "ch", "unk", "Entry", "Key", ");", "\u0120if", "\u0120(", "ch", "unk", "Bl", "obs", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "Bl", "ob", "\u0120blob", "\u0120:", "\u0120chunk", "Bl", "obs", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120File", "Ut", "ils", ".", "delete", "Directory", "(", "bl", "ob", ".", "get", "File", "().", "get", "Parent", "File", "());", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "Error", "\u0120while", "\u0120deleting", "\u0120chunk", "\u0120parent", "\u0120directory", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120ts", ".", "remove", "(", "ch", "unk", "Entry", "Key", ");", "\u0120}", "\u0120file", "Entry", ".", "before", "Remove", "();", "\u0120}", "\u0120String", "\u0120file", "Entry", "Key", "\u0120=", "\u0120file", "Entry", ".", "get", "Key", "();", "\u0120List", "<", "Bl", "ob", ">", "\u0120file", "Bl", "obs", "\u0120=", "\u0120ts", ".", "get", "Bl", "obs", "(", "file", "Entry", "Key", ");", "\u0120if", "\u0120(", "file", "Bl", "obs", "\u0120!=", "\u0120null", ")", "\u0120{", "\u0120for", "\u0120(", "Bl", "ob", "\u0120blob", "\u0120:", "\u0120file", "Bl", "obs", ")", "\u0120{", "\u0120try", "\u0120{", "\u0120File", "Ut", "ils", ".", "delete", "Directory", "(", "bl", "ob", ".", "get", "File", "().", "get", "Parent", "File", "());", "\u0120}", "\u0120catch", "\u0120(", "IO", "Exception", "\u0120e", ")", "\u0120{", "\u0120log", ".", "error", "(\"", "Error", "\u0120while", "\u0120deleting", "\u0120file", "\u0120parent", "\u0120directory", "\",", "\u0120e", ");", "\u0120}", "\u0120}", "\u0120}", "\u0120ts", ".", "remove", "(", "file", "Entry", "Key", ");", "\u0120return", "\u0120true", ";", "\u0120}", "\u0120else", "\u0120{", "\u0120return", "\u0120false", ";", "\u0120}", "\u0120}"], "docstring_tokens": ["I", "'d", "\u0120go", "\u0120with", "\u0120if", "\u0120(", "file", "Entry", "\u0120==", "\u0120null", ")", "\u0120{", "return", "\u0120false", ";}", "\u0120without", "\u0120else", "\u0120allowing", "\u0120to", "\u0120remove", "\u0120one", "\u0120indent", "ation", "\u0120level", "\u0120for", "\u0120the", "\u0120successful", "\u0120case", "."]}
